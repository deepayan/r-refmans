<!DOCTYPE html><html lang="en"><head><title>Help for package switchSelection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {switchSelection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot'><p>Bootstrap covariance matrix for least squares estimates of linear regression</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap for msel function</p></a></li>
<li><a href='#coef.msel'><p>Coefficients extraction method for msel.</p></a></li>
<li><a href='#cps'><p>A subset of data from Current Population Survey (CPS).</p></a></li>
<li><a href='#exogenous_fn'><p>Modify exogenous variables in data frame</p></a></li>
<li><a href='#fitted.msel'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#formula_merge'><p>Merge formulas</p></a></li>
<li><a href='#formula_split'><p>Split formula by symbol</p></a></li>
<li><a href='#formula.msel'><p>Formulas of msel model.</p></a></li>
<li><a href='#grad_msel'><p>Gradient of the Log-likelihood Function of Multivariate Ordered</p>
Probit Model</a></li>
<li><a href='#lnL_msel'><p>Log-likelihood Function of Multivariate Ordered Probit Model</p></a></li>
<li><a href='#logLik.msel'><p>Extract Log-Likelihood from a Fit of the msel Function.</p></a></li>
<li><a href='#loocv'><p>Leave-one-out cross-validation</p></a></li>
<li><a href='#lrtest_msel'><p>Likelihood ratio test</p></a></li>
<li><a href='#msel'><p>Multivariate and multinomial sample selection and endogenous switching models</p>
with multiple outcomes.</a></li>
<li><a href='#nobs.msel'><p>Extract the Number of Observations from a Fit of the msel Function.</p></a></li>
<li><a href='#predict.msel'><p>Predict method for msel function</p></a></li>
<li><a href='#print.lrtest_msel'><p>Print Method for Likelihood Ratio Test</p></a></li>
<li><a href='#print.msel'><p>Print for an Object of Class msel</p></a></li>
<li><a href='#print.struct_msel'><p>Print for an Object of Class struct_msel</p></a></li>
<li><a href='#print.summary.lrtest_msel'><p>Print Summary Method for Likelihood Ratio Test</p></a></li>
<li><a href='#print.summary.msel'><p>Print summary for an Object of Class msel</p></a></li>
<li><a href='#print.summary.test_msel'><p>Print summary for an Object of Class test_msel</p></a></li>
<li><a href='#sigma.msel'><p>Extract Residual Standard Deviation 'Sigma'</p></a></li>
<li><a href='#starsVector'><p>Stars for p-values</p></a></li>
<li><a href='#struct_msel'><p>Structure of the Object of Class msel</p></a></li>
<li><a href='#summary.lrtest_msel'><p>Summary Method for Likelihood Ratio Test</p></a></li>
<li><a href='#summary.msel'><p>Summary for an Object of Class msel</p></a></li>
<li><a href='#summary.test_msel'><p>Summary for an Object of Class delta_method</p></a></li>
<li><a href='#test_msel'><p>Tests and confidence intervals for the parameters estimated by</p>
the msel function</a></li>
<li><a href='#update_msel'><p>Update msel object with the new estimates</p></a></li>
<li><a href='#vcov.msel'><p>Calculate Variance-Covariance Matrix for a msel Object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Endogenous Switching and Sample Selection Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the parameters of multivariate endogenous switching and sample selection models using methods described in Newey (2009) &lt;<a href="https://doi.org/10.1111%2Fj.1368-423X.2008.00263.x">doi:10.1111/j.1368-423X.2008.00263.x</a>&gt;, E. Kossova, B. Potanin (2018) <a href="https://ideas.repec.org/a/ris/apltrx/0346.html">https://ideas.repec.org/a/ris/apltrx/0346.html</a>, E. Kossova, L. Kupriianova, B. Potanin (2020) <a href="https://ideas.repec.org/a/ris/apltrx/0391.html">https://ideas.repec.org/a/ris/apltrx/0391.html</a> and E. Kossova, B. Potanin (2022) <a href="https://ideas.repec.org/a/ris/apltrx/0455.html">https://ideas.repec.org/a/ris/apltrx/0455.html</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), hpa (&ge; 1.3.1), mnorm (&ge; 1.2.1), gena (&ge;
1.0.0), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, hpa, mnorm</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 15:35:29 UTC; Bogdan</td>
</tr>
<tr>
<td>Author:</td>
<td>Bogdan Potanin [aut, cre, ctb],
  Sofiia Dolgikh [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bogdan Potanin &lt;bogdanpotanin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 15:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot'>Bootstrap covariance matrix for least squares estimates of linear regression</h2><span id='topic+boot'></span>

<h3>Description</h3>

<p>This function calculates bootstrapped covariance matrix
for least squares estimates of linear regression. The estimates should be
obtained via <code>lm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(model, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_+3A_model">model</code></td>
<td>
<p>object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code id="boot_+3A_iter">iter</code></td>
<td>
<p>positive integer representing the number of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations may take long time for high <code>iter</code> value.
</p>


<h3>Value</h3>

<p>This function returns a bootstrapped covariance matrix of the
least squares estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n &lt;- 20
eps &lt;- rnorm(n)
x &lt;- runif(n)
y &lt;- x + eps
# Estimate the model
model &lt;- lm(y ~ x)
# Calculate bootstrap covariance matrix
boot(model, iter = 50)
</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrap for msel function</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap_msel'></span><span id='topic+bootstrap_combine_msel'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code> 
provides bootstrap estimates of the parameters of the model estimated via
the <code><a href="#topic+msel">msel</a></code> function.
Function <code><a href="#topic+bootstrap_combine_msel">bootstrap_combine_msel</a></code> allows to
combine several objects of class <code>'bootstrap_msel'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_msel(
  object,
  iter = 100,
  opt_type = "optim",
  opt_args = NULL,
  is_ind = FALSE,
  n_sim = 1000,
  n_cores = 1
)

bootstrap_combine_msel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>an object of class 'msel'.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_opt_type">opt_type</code></td>
<td>
<p>the same as <code>opt_type</code> argument of the
<code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_opt_args">opt_args</code></td>
<td>
<p>the same as <code>opt_args</code> argument of the
<code><a href="#topic+msel">msel</a></code> functions.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_is_ind">is_ind</code></td>
<td>
<p>logical; if <code>TRUE</code> then the function also returns a
numeric matrix of indexes of observations used in the bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_n_sim">n_sim</code></td>
<td>
<p>the same as <code>n_sim</code> argument of the
<code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_n_cores">n_cores</code></td>
<td>
<p>the same as <code>n_cores</code> argument of the 
<code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>objects returned by function 
<code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code> to be combined into a
single object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates <code>iter</code> bootstrap samples and 
estimates the parameters <code class="reqn">\theta</code> of the model by using each of
these samples. Estimate <code class="reqn">\hat{\theta}^{(b)}</code> from the <code class="reqn">b</code>-th of 
these samples is stored as the <code>b</code>-th row of the numeric matrix
<code>par</code> which is an element of the returned object.
</p>
<p>Use <code><a href="#topic+update_msel">update_msel</a></code> function to
transfer the bootstrap estimates to the object of class <code>'msel'</code>.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code>
returns an object of class <code>"bootstrap_msel"</code>.
This object is a list which may contain the following elements:
</p>

<ul>
<li> <p><code>par</code> - a numeric matrix such that <code>par[b, ]</code> is a vector 
of the estimates of the parameters of the model estimated via
<code><a href="#topic+msel">msel</a></code> function on the <code>b</code>-th bootstrap
sample.
</p>
</li>
<li> <p><code>iter</code> - the number of the bootstrap iterations.
</p>
</li>
<li> <p><code>cov</code> - bootstrap estimate of the covariance matrix which 
equals to <code>cov(par)</code>.
</p>
</li>
<li> <p><code>ind</code> - a numeric matrix such that <code>ind[, b]</code> stores the 
indexes of the observations from <code>object$data</code> included into the 
<code>b</code>-th bootstrap sample.
</p>
</li></ul>

<p>Function <code><a href="#topic+bootstrap_combine_msel">bootstrap_combine_msel</a></code> returns the 
object which combines several objects returned by the
<code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code> function into a single
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -------------------------------
# Bootstrap for the probit model
# -------------------------------

# ---
# Step 1
# Simulation of data
# ---

# Load required package
library("mnorm")

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 100

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
u &lt;- rnorm(n = n, mean = 0, sd = 1)

# Coefficients
gamma &lt;- c(-1, 2)

# Linear index
li &lt;- gamma[1] * w1 + gamma[2] * w2

# Latent variable
z_star &lt;- li + u

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z                                           &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]]                         &lt;- 3
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, z = z)

# ---
# Step 2
# Estimation of the parameters
# ---

# Estimation
model &lt;- msel(formula = z ~ w1 + w2, data = data)
summary(model)
 
# ---
# Step 3
# Bootstrap
# ---

# Perform bootstrap
bootstrap &lt;- bootstrap_msel(model)

# Test the hypothesis that H0: gamma[2] = -2gamma[1]
# by using the t-test and with bootstrap p-values
fn_test &lt;- function(object)
{
  gamma &lt;- coef(object, eq = 1)
  return(gamma[2] + 2 * gamma[1])
}
b &lt;- test_msel(object    = model, 
               fn        = fn_test,
               test      = "t", 
               method    = "bootstrap",
               ci        = "percentile",
               se_type   = "bootstrap",
               bootstrap = bootstrap)
summary(b)

# Replicate the analysis with the additional 20 bootstrap iterations
bootstrap2    &lt;- bootstrap_msel(model, iter = 20)
bootstrap_new &lt;- bootstrap_combine_msel(bootstrap, bootstrap2)
b2 &lt;- test_msel(object    = model, 
                fn        = fn_test,
                test      = "t", 
                method    = "bootstrap",
                ci        = "percentile",
                se_type   = "bootstrap",
                bootstrap = bootstrap)
summary(b2)

 
</code></pre>

<hr>
<h2 id='coef.msel'>Coefficients extraction method for msel.</h2><span id='topic+coef.msel'></span>

<h3>Description</h3>

<p>Extract coefficients and other estimates from msel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
coef(
  object,
  ...,
  eq = NULL,
  eq2 = NULL,
  eq3 = NULL,
  regime = NULL,
  type = "coef"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.msel_+3A_object">object</code></td>
<td>
<p>an object of class &quot;msel&quot;.</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_eq">eq</code></td>
<td>
<p>an integer representing the index of the ordered equation.</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_eq2">eq2</code></td>
<td>
<p>an integer representing the index of the continuous equation.</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_eq3">eq3</code></td>
<td>
<p>an integer representing the index of the alternative of the
multinomial equation.</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_regime">regime</code></td>
<td>
<p>an integer representing a regime of the continuous equation.</p>
</td></tr>
<tr><td><code id="coef.msel_+3A_type">type</code></td>
<td>
<p>a character representing a type of the output. Possible options
are <code>"coef"</code>, <code>"coef2"</code>, <code>coef_lambda</code>, 
<code>"coef_var"</code>, <code>"coef3"</code>, <code>"cuts"</code>, <code>"cov"</code>, 
<code>"cov1"</code>, <code>"var"</code>, <code>"cov2"</code>, <code>"cov3"</code>, 
and <code>marginal</code>.
See 'Details' for additional information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the notations from the 'Details' section of 
<code><a href="#topic+msel">msel</a></code>.
</p>
<p><strong>Mean coefficients of the ordinal equations</strong>
</p>
<p>Suppose that <code>type = "coef"</code>. Then estimates of the <code class="reqn">\gamma_{j}</code> 
coefficients are returned for each <code class="reqn">j\in\{1,...,J\}</code>. 
If <code>eq = j</code> then only estimates of the <code class="reqn">\gamma_{j}</code> coefficients 
are returned.
</p>
<p><strong>Variance coefficients of the ordinal equations</strong>
</p>
<p>Suppose that <code>type = "coef_var"</code>. Then estimates of the
<code class="reqn">\gamma_{j}^{*}</code> coefficients are returned for each 
<code class="reqn">j\in\{1,...,J\}</code>. If <code>eq = j</code> then only estimates of 
<code class="reqn">\gamma_{j}^{*}</code> coefficients are returned.
</p>
<p><strong>Coefficients of the continuous equations</strong>
</p>
<p>Suppose that <code>type = "coef2"</code>. Then estimates of the <code class="reqn">\beta_{r}</code> 
coefficients are returned for each <code class="reqn">r\in\{0,...,R - 1\}</code>. 
If <code>eq2 = k</code> then only estimates for the <code class="reqn">k</code>-th continuous equation 
are returned. If <code>regime = r</code> then estimates of the <code class="reqn">\beta_{r}</code>
coefficients are returned for the <code>eq2</code>-th continuous equation. 
Herewith if <code>regime</code> is not <code>NULL</code> and <code>eq2</code> is <code>NULL</code> 
it is assumed that <code>eq2 = 1</code>.
</p>
<p><strong>Selectivity terms</strong>
</p>
<p>Suppose that <code>type = "coef_lambda"</code>. Then estimates of the coefficients
associated with the selectivity terms are returned for each 
<code class="reqn">r\in\{0,...,R - 1\}</code>. If <code>eq2 = k</code> then only estimates for the 
<code class="reqn">k</code>-th continuous equation are returned. If <code>regime = r</code> then 
estimates of the coefficients of the selectivity terms are returned for the 
<code>eq2</code>-th continuous equation.
</p>
<p><strong>Thresholds of the ordinal equations</strong>
</p>
<p>Suppose that <code>type = "cuts"</code> or <code>type = "thresholds"</code>. Then 
estimates of the <code class="reqn">c_{j}</code> cuts (thresholds) are returned for each 
<code class="reqn">j\in\{1,...,J\}</code>. If <code>eq = j</code> then only estimates of the 
<code class="reqn">c_{j}</code> cuts are returned.
</p>
<p><strong>Covariances between the random errors of the ordinal equations</strong>
</p>
<p>Suppose that <code>type = "cov1"</code>. Then estimate of the covariance matrix of
<code class="reqn">u_{i}</code> is returned. If <code>eq = c(a, b)</code> then the function returns
<code class="reqn">(a, b)</code>-th element of this matrix i.e. an element from the
<code>a</code>-th row and the <code>b</code>-th column which represents an estimate of
<code class="reqn">Cov(u_{ai}, u_{bi})</code>.
</p>
<p><strong>Covariances between the random errors of the ordinal and continuous 
equations</strong>
</p>
<p>Suppose that <code>type = "cov12"</code>. Then estimates of the covariances between
random errors of the ordinal <code class="reqn">u_{i}</code> and cotninuous <code class="reqn">\varepsilon_{i}</code> 
equations are returned. If <code>eq2 = k</code> then covariances with random errors 
of the <code>k</code>-th continuous equation are returned. If in addition 
<code>eq = j</code> and <code>regime = r</code> then the function returns an estimate of 
<code class="reqn">Cov(u_{ji}, \varepsilon_{ri})</code> for the <code>k</code>-th continuous equation. 
If <code>eq2 = NULL</code> it is assumed that <code>eq2 = 1</code>.
</p>
<p><strong>Variances of the random errors of the continuous equations</strong>
</p>
<p>Suppose that <code>type = "var"</code>. Then estimates of the variances of 
<code class="reqn">\varepsilon_{i}</code> are returned. If <code>eq2 = k</code> then estimates only for
the <code class="reqn">k</code>-th continuous equation are returned. If in addition 
<code>regime = r</code> then estimate of the <code class="reqn">Var(\varepsilon_{ri})</code> is 
returned. Herewith if <code>regime</code> is not <code>NULL</code> and <code>eq2</code> is 
<code>NULL</code> it is assumed that <code>eq2 = 1</code>.
</p>
<p><strong>Covariances between the random errors of the continuous equations</strong>
</p>
<p>Suppose that <code>type = "cov2"</code>. Then estimates of the covariances between
random errors of different continuous equations in different regimes are 
returned. If <code>eq2 = c(a, b)</code> and <code>regime = c(c, d)</code> then function 
returns an estimate of the covariance of random errors of the <code>a</code>-th 
and <code>b</code>-th continuous equations in the regimes <code>c</code> and <code>d</code> 
correspondingly. If this covariance is not identifiable then <code>NA</code> value 
is returned.
</p>
<p><strong>Coefficients of the multinomial equation</strong>
</p>
<p>Suppose that <code>type = "coef3"</code>. Then estimates of the 
<code class="reqn">\tilde{\gamma}_{j}</code> coefficients are returned for each 
<code class="reqn">j\in\{0,...,\tilde{J} - 1\}</code>. If <code>eq3 = j</code> then only estimates of 
the <code class="reqn">\tilde{\gamma}_{j}</code> coefficients are returned.
</p>
<p><strong>Covariances between the random errors of the multinomial equations</strong>
</p>
<p>Suppose that <code>type = "cov3"</code>. Then estimate of the covariance matrix of
<code class="reqn">\tilde{u}_{i}</code> is returned. If <code>eq3 = c(a, b)</code> then the function 
returns <code class="reqn">(a, b)</code>-th element of this matrix i.e. an element from the
<code>a</code>-th row and the <code>b</code>-th column which represents an estimate of
<code class="reqn">Cov(\tilde{u}_{(a+1)i}, \tilde{u}_{(b+1)i})</code>.
</p>
<p><strong>Parameters of the marginal distributions</strong>
</p>
<p>Suppose that <code>type = "marginal"</code>. Then a list is returned which
<code>j</code>-th element is a numeric vector of estimates of the parameters
of the marginal distribution of <code class="reqn">u_{ji}</code>.
</p>
<p><strong>Asymptotic covariance matrix</strong>
</p>
<p>Suppose that <code>type = "cov"</code>. Then estimate of the asymptotic covariance
matrix of the estimator is returned. Note that this estimate depends
on the <code>cov_type</code> argument of <code><a href="#topic+msel">msel</a></code>.
</p>


<h3>Value</h3>

<p>See 'Details' section.
</p>

<hr>
<h2 id='cps'>A subset of data from Current Population Survey (CPS).</h2><span id='topic+cps'></span>

<h3>Description</h3>

<p>Labor market data on 18,253 middle age (25-54 years) married women
in the year 2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cps)
</code></pre>


<h3>Format</h3>

<p>A data frame with 18,253 rows and 23 columns. It contains information on
wages and some socio-demographic characteristics of the middle age
(25-54 years) married women:
</p>

<dl>
<dt>age</dt><dd><p>the age measured in years.</p>
</dd>
<dt>sage</dt><dd><p>the same as age but for a spouse.</p>
</dd>
<dt>work</dt><dd><p>a binary variable for the employment status 
(0 - unemployed, 1 - employed).</p>
</dd>
<dt>swork</dt><dd><p>the same as work but for a spouse.</p>
</dd>
<dt>nchild</dt><dd><p>the number of children under age 5.</p>
</dd>
<dt>snchild</dt><dd><p>the same as nchild but for a spouse.</p>
</dd>
<dt>health</dt><dd><p>subjective health status 
(1 - poor, 2 - fair, 3 - good, 4 - very good, 5 - excellent).</p>
</dd>
<dt>shealth</dt><dd><p>the same as health but for a spouse.</p>
</dd>
<dt>basic</dt><dd><p>a binary variable which equals 1 for those who have graduated 
from high school or has at least some college or has associated degree and 
does not have any higher level of education, 0 - otherwise.</p>
</dd>
<dt>bachelor</dt><dd><p>a binary variable which equals 1 for those whose highest 
education level is a bachelor degree.</p>
</dd>
<dt>master</dt><dd><p>a binary variable which equals 1 for those whose highest 
education level is a master degree.</p>
</dd>
<dt>sbasic</dt><dd><p>the same as basic but for a spouse.</p>
</dd>
<dt>sbachelor</dt><dd><p>the same as bachelor but for a spouse.</p>
</dd>
<dt>smaster</dt><dd><p>the same as master but for a spouse.</p>
</dd> 
<dt>educ</dt><dd><p>a categorical variable for the level of education such that 
educ = 0 if basic = 1, 
educ = 1 if bachelor = 1 and 
educ = 2 if master = 1.</p>
</dd>
<dt>seduc</dt><dd><p>the same as educ but for a spouse.</p>
</dd>
<dt>weeks</dt><dd><p>a total number of weeks worked durning the year.</p>
</dd>
<dt>sweeks</dt><dd><p>the same as weeks but for a spouse.</p>
</dd>
<dt>hours</dt><dd><p>a usual number of working hours per week.</p>
</dd>
<dt>shours</dt><dd><p>the same as hours but for a spouse.</p>
</dd>
<dt>wage</dt><dd><p>the wage of the individual.</p>
</dd>
<dt>swage</dt><dd><p>the same as wage but for a spouse.</p>
</dd>
<dt>lwage</dt><dd><p>an inverse hyperbolic sine transformation of the hourly wage.</p>
</dd>
<dt>slwage</dt><dd><p>the same as lwage but for a spouse.</p>
</dd>
<dt>state</dt><dd><p>a state of residence.</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>&lt;https://www.census.gov/programs-surveys/cps.html&gt;
</p>


<h3>References</h3>

<p>Flood S, King M, Rodgers R, Ruggles S, Warren R, 
Westberry M (2022). Integrated Public Use Microdata Series, 
Current Population Survey: Version 10.0 [dataset].
doi: 10.18128/D030.V10.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cps)
model &lt;- msel(work ~ age + bachelor + master, data = cps)
summary(model)
 
</code></pre>

<hr>
<h2 id='exogenous_fn'>Modify exogenous variables in data frame</h2><span id='topic+exogenous_fn'></span>

<h3>Description</h3>

<p>Change some values of the exogenous variables in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exogenous_fn(exogenous, newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exogenous_fn_+3A_exogenous">exogenous</code></td>
<td>
<p>list such that <code>exogenous[[i]]</code> represents the value 
(or a vector of values of the same size as <code>nrow(newdata)</code>) which will 
be exogenously assigned to the variable <code>names(exogenous)[[i]]</code> in 
<code>newdata</code> i.e., <code>newdata[, names(exogenous)[i]] &lt;- exogenous[[i]]</code>.
If <code>newdata</code> is <code>NULL</code> and <code>exogenous</code> is not <code>NULL</code> then
<code>newdata</code> is set to <code>object$data</code>.
This argument is especially useful for causal inference when some endogenous 
(dependent) variables should be exogenously assigned with some values i.e.,
in the right hand side of the <code>formula</code> and <code>formula2</code>.
The purpose of the <code>exogeneous</code> argument is just a <code>convenience</code> so
equivalently it is possible to exogenously provide the values to variables
via <code>newdata</code> argument.</p>
</td></tr>
<tr><td><code id="exogenous_fn_+3A_newdata">newdata</code></td>
<td>
<p>data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes <code>exogenous</code> variables in <code>newdata</code>.
</p>


<h3>Value</h3>

<p>The function returns data frame which is similar to <code>newdata</code> 
but some values of this data frame are set according to <code>exogenous</code>.
</p>

<hr>
<h2 id='fitted.msel'>Extract Model Fitted Values</h2><span id='topic+fitted.msel'></span>

<h3>Description</h3>

<p>Extracts fitted values from 'msel' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
fitted(object, ..., newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.msel_+3A_object">object</code></td>
<td>
<p>object of class 'msel'.</p>
</td></tr>
<tr><td><code id="fitted.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="fitted.msel_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used. 
This data frame should contain values of dependent variables even if they 
are not actually needed for prediction (simply assign them with 0 values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix. Its columns which names coincide with the
names of the ordinal and multinomial equations provide the index of the most 
probable category for each observation.
Columns which names coincide with the names of the continuous equations 
provide conditional expectations of the dependent variables in observable 
regimes for each observation.
</p>

<hr>
<h2 id='formula_merge'>Merge formulas</h2><span id='topic+formula_merge'></span>

<h3>Description</h3>

<p>This function merges all variables of several formulas
into a single formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_merge(..., type = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_merge_+3A_...">...</code></td>
<td>
<p>formulas to be merged such that there is a single element
on the left hand side and various elements on the right hand side.</p>
</td></tr>
<tr><td><code id="formula_merge_+3A_type">type</code></td>
<td>
<p>string representing the type of merge to be used.
If <code>type = "all"</code> then both right hand side and left hand side
elements of the formulas will be merged on the right hand side.
If <code>type = "terms"</code> then only right hand side elements of the
formulas will be merged on the right hand side.
If <code>type = "var-terms"</code> then the result is the same as in case
when <code>type = "terms"</code> but there will be left hand side element
of the first formula on the left hand side of the merged formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Merged formulas should have a single element on the left hand
side and voluntary number of elements on the right hand side.
</p>


<h3>Value</h3>

<p>This function returns a formula which form depends on 
<code>type</code> input argument value. See 'Details' for additional information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider three formulas
f1 &lt;- as.formula("y1 ~ x1 + x2")
f2 &lt;- as.formula("y2 ~ x2 + x3")
f3 &lt;- as.formula("y3 ~ y2 + x6")
# Merge these formulas in a various ways
formula_merge(f1, f2, f3, type = "all")
formula_merge(f1, f2, f3, type = "terms")
formula_merge(f1, f2, f3, type = "var-terms")

</code></pre>

<hr>
<h2 id='formula_split'>Split formula by symbol</h2><span id='topic+formula_split'></span>

<h3>Description</h3>

<p>This function splits one formula into two formulas
by symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_split(formula, symbol = "|")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_split_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>.</p>
</td></tr>
<tr><td><code id="formula_split_+3A_symbol">symbol</code></td>
<td>
<p>a string that is used to split <code>formula</code> into
two formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>symbol</code> should be on the right hand side of
the formula.
</p>


<h3>Value</h3>

<p>This function returns a list of two formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula_split("y ~ x1 + x2 | x2 + x3")
formula_split("y ~ x1 + x2 : x2 + x3", symbol = ":")

</code></pre>

<hr>
<h2 id='formula.msel'>Formulas of msel model.</h2><span id='topic+formula.msel'></span>

<h3>Description</h3>

<p>Provides formulas associated with the 
object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
formula(x, ..., type = "formula", eq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula.msel_+3A_x">x</code></td>
<td>
<p>object of class 'msel'.</p>
</td></tr>
<tr><td><code id="formula.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="formula.msel_+3A_type">type</code></td>
<td>
<p>character; 
if <code>type = "formula"</code> or <code>type = 1</code> then function returns formulas 
of the ordinal equations. 
If <code>type = "formula2"</code> or <code>type = 2</code> then function returns formulas 
of the continuous equations.
If <code>type = "formula3"</code> or <code>type = 3</code> then function returns formula 
of the multinomial equation.</p>
</td></tr>
<tr><td><code id="formula.msel_+3A_eq">eq</code></td>
<td>
<p>positive integer representing the index of the equation which
formula should be returned. If <code>NULL</code> (default) then formulas for each
equation will be returned as a list which <code>i</code>-th element associated 
with <code>i</code>-th equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a formula or a list of formulas depending on <code>eq</code> value.
</p>

<hr>
<h2 id='grad_msel'>Gradient of the Log-likelihood Function of Multivariate Ordered
Probit Model</h2><span id='topic+grad_msel'></span>

<h3>Description</h3>

<p>Calculates gradient of the log-likelihood function of 
multivariate ordered probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_msel(
  par,
  control_lnL,
  out_type = "grad",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_msel_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="grad_msel_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="grad_msel_+3A_out_type">out_type</code></td>
<td>
<p>string representing the output type of the function.</p>
</td></tr>
<tr><td><code id="grad_msel_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="grad_msel_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="grad_msel_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='lnL_msel'>Log-likelihood Function of Multivariate Ordered Probit Model</h2><span id='topic+lnL_msel'></span>

<h3>Description</h3>

<p>Calculates log-likelihood function of multivariate ordered
probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnL_msel(
  par,
  control_lnL,
  out_type = "val",
  n_sim = 1000L,
  n_cores = 1L,
  regularization = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lnL_msel_+3A_par">par</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="lnL_msel_+3A_control_lnl">control_lnL</code></td>
<td>
<p>list with some additional parameters.</p>
</td></tr>
<tr><td><code id="lnL_msel_+3A_out_type">out_type</code></td>
<td>
<p>string represeint the output type of the function.</p>
</td></tr>
<tr><td><code id="lnL_msel_+3A_n_sim">n_sim</code></td>
<td>
<p>the number of random draws for multivariate 
normal probabilities.</p>
</td></tr>
<tr><td><code id="lnL_msel_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of cores to be used.</p>
</td></tr>
<tr><td><code id="lnL_msel_+3A_regularization">regularization</code></td>
<td>
<p>list of regularization parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.msel'>Extract Log-Likelihood from a Fit of the msel Function.</h2><span id='topic+logLik.msel'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood from a model fit
of the <code><a href="#topic+msel">msel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.msel_+3A_object">object</code></td>
<td>
<p>object of class &quot;msel&quot;</p>
</td></tr>
<tr><td><code id="logLik.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>estimator == "2step"</code> in 
<code><a href="#topic+msel">msel</a></code> then function may return
<code>NA</code> value since two-step estimator of covariance matrix may be
not positively defined.
</p>


<h3>Value</h3>

<p>Returns an object of class 'logLik'.
</p>

<hr>
<h2 id='loocv'>Leave-one-out cross-validation</h2><span id='topic+loocv'></span>

<h3>Description</h3>

<p>This function calculates root mean squared error (RMSE) for
leave-one-out cross-validation of linear regression estimated via
least squares method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loocv_+3A_fit">fit</code></td>
<td>
<p>object of class <code>lm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast analytical formula is used.
</p>


<h3>Value</h3>

<p>This function returns a numeric value representing root mean squared 
error (RMSE) of leave-one-out cross-validation (LOOCV).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n &lt;- 100
eps &lt;- rnorm(n)
x &lt;- runif(n)
y &lt;- x + eps
# Estimate the model
model &lt;- lm(y ~ x)
# Perform cross-validation
loocv(model)
</code></pre>

<hr>
<h2 id='lrtest_msel'>Likelihood ratio test</h2><span id='topic+lrtest_msel'></span>

<h3>Description</h3>

<p>This function performs chi-squared test for nested models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrtest_msel(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrtest_msel_+3A_model1">model1</code></td>
<td>
<p>the first model.</p>
</td></tr>
<tr><td><code id="lrtest_msel_+3A_model2">model2</code></td>
<td>
<p>the second model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>model1</code> and <code>model2</code> should be objects
of class that has implementations of 
<code><a href="stats.html#topic+logLik">logLik</a></code> and 
<code><a href="stats.html#topic+nobs">nobs</a></code> methods. It is assumed that either <code>model1</code>
is nested into <code>model2</code> or vice versa. More precisely it is assumed
that the model with smaller log-likelihood value is nested into the model
with greater log-likelihood value.
</p>
<p>Arguments <code>model1</code> and <code>model2</code> may be the lists of models.
If <code>model1</code> is a list of models then it is assumed that the number
of degrees of freedom and log-likelihood of the first model are just a sum
of degrees of freedom and log-likelihoods of the models in this list.
Similarly for <code>model2</code>. 
</p>
<p>If <code>model1</code> or <code>model2</code> is a list then the number of observations 
of the associated models are calculated as the sum of the numbers of 
observations of the models in corresponding lists.
However sometimes it may be misleading. For example, when bivariate probit
model (full) is tested against two independent probit models (restricted). 
Then it will be assumed that the number of observations in the restricted
model is twice the number of observations in the full model that is not the
case. 
Fortunately it will not affect the results of the likelihood ratio test.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>'lrtest_msel'</code> that is
a list with the following elements:
</p>

<ul>
<li> <p><code>n1</code> - the number of observations in the first model.
</p>
</li>
<li> <p><code>n2</code> - the number of observations in the second model.
</p>
</li>
<li> <p><code>ll1</code> - log-likelihood value of the first model.
</p>
</li>
<li> <p><code>ll2</code> - log-likelihood value of the second model.
</p>
</li>
<li> <p><code>df1</code> - the number of parameters in the first model.
</p>
</li>
<li> <p><code>df2</code> - the number of parameters in the second model.
</p>
</li>
<li> <p><code>restrictions</code> - the number of restrictions in the nested model.
</p>
</li>
<li> <p><code>value</code> - chi-squared (likelihood ratio) test statistic value.
</p>
</li>
<li> <p><code>p_value</code> - p-value of the chi-squared (likelihood ratio) test.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Generate data according to linear regression
n   &lt;- 100
eps &lt;- rnorm(n)
x1  &lt;- runif(n)
x2  &lt;- runif(n)
y   &lt;- x1 + 0.2 * x2 + eps
# Estimate full model
model1 &lt;- lm(y ~ x1 + x2)
# Estimate restricted (nested) model
model2 &lt;- lm(y ~ x1)
# Likelihood ratio test results
lrtest_msel(model1, model2)
</code></pre>

<hr>
<h2 id='msel'>Multivariate and multinomial sample selection and endogenous switching models
with multiple outcomes.</h2><span id='topic+msel'></span>

<h3>Description</h3>

<p>This function allows to estimate parameters of the 
multivariate and multinomial sample selection and endogenous switching models
with multiple outcomes. Both maximum-likelihood and two-step estimators are
implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msel(
  formula = NA,
  formula2 = NA,
  formula3 = NA,
  data = NULL,
  groups = NA,
  groups2 = NA,
  groups3 = NA,
  marginal = list(),
  opt_type = "optim",
  opt_args = NA,
  start = NULL,
  estimator = "ml",
  cov_type = "mm",
  degrees = NA,
  degrees3 = NA,
  n_sim = 1000,
  n_cores = 1,
  control = list(),
  regularization = list(),
  type3 = "logit"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msel_+3A_formula">formula</code></td>
<td>
<p>a list which i-th element is an object of class 
<code>"formula"</code> describing the form of the linear predictor (index) of the  
i-th ordinal equation. Mean and variance equations should be separated 
by the '|' symbol.</p>
</td></tr>
<tr><td><code id="msel_+3A_formula2">formula2</code></td>
<td>
<p>a list which i-th element is an object of class 
<code>"formula"</code> describing the form of the linear predictor (index) of the 
i-th continuous equation.</p>
</td></tr>
<tr><td><code id="msel_+3A_formula3">formula3</code></td>
<td>
<p>an object of class <code>"formula"</code> describing the form of 
the linear predictor (index) of the multinomial equation.</p>
</td></tr>
<tr><td><code id="msel_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="msel_+3A_groups">groups</code></td>
<td>
<p>a matrix which (i, j)-th element is the j-th ordinal category
(value starting from 0) of the i-th dependent ordinal variable. Each row of 
this matrix describes observable (in data) combination of categories -
values of the ordinal dependent variables i.e., from the left hand side of
<code>formula</code>. Special category <code>'-1'</code> means that variable in the
j-th column is unobservable when other dependent variables have particular 
values i.e., given in the same row. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="msel_+3A_groups2">groups2</code></td>
<td>
<p>the same as <code>groups</code> argument but for the continuous
dependent variables from <code>formula2</code>. See 'Details' for additional 
information.</p>
</td></tr>
<tr><td><code id="msel_+3A_groups3">groups3</code></td>
<td>
<p>the same as <code>groups</code> argument but for the multinomial
dependent variable from <code>formula3</code>. See 'Details' for additional 
information.</p>
</td></tr>
<tr><td><code id="msel_+3A_marginal">marginal</code></td>
<td>
<p>a list such that <code>marginal[[i]]</code> represents parameters 
of the marginal distribution of the random error of the <code>i</code>-th ordered 
equation and <code>names(marginal)[i]</code> is a name of this distribution. 
Marginal distributions are the same as in <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code>.</p>
</td></tr>
<tr><td><code id="msel_+3A_opt_type">opt_type</code></td>
<td>
<p>a character representing the optimization function to be 
used. If <code>opt_type = "optim"</code> then <code><a href="stats.html#topic+optim">optim</a></code> will be 
used. If <code>opt_type = "gena"</code> then <code><a href="gena.html#topic+gena">gena</a></code> will be 
applied i.e., a genetic algorithm. If <code>opt_type = "pso"</code> then 
<code><a href="gena.html#topic+pso">pso</a></code> will be used i.e., a particle swarm optimization.</p>
</td></tr>
<tr><td><code id="msel_+3A_opt_args">opt_args</code></td>
<td>
<p>a list of input arguments for the optimization function
selected via the <code>opt_type</code> argument. See 'Details' for additional 
information.</p>
</td></tr>
<tr><td><code id="msel_+3A_start">start</code></td>
<td>
<p>a numeric vector of initial parameters' values. It will be used
as a starting point for the optimization purposes. It is also possible to
provide an object of class <code>'msel'</code> then its <code>'par'</code> element will 
be used as a starting point.</p>
</td></tr>
<tr><td><code id="msel_+3A_estimator">estimator</code></td>
<td>
<p>a character determining estimation method.
If <code>estimator = "ml"</code> then maximum-likelihood method will be used.
If <code>estimator = "2step"</code> then two-step estimation procedure similar
to Heckman's method will be applied. 
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="msel_+3A_cov_type">cov_type</code></td>
<td>
<p>a character determining the type of the covariance matrix 
estimate to be returned. First, suppose that <code>estimator = "ml"</code> then the
following estimators are available. If <code>cov_type = "hessian"</code> then 
negative inverse of Hessian matrix will be applied. If 
<code>cov_type = "gop"</code> then inverse of Jacobian outer products will be used.
If <code>cov_type = "sandwich"</code> then sandwich covariance matrix
estimator will be applied. if <code>cov_type = "no"</code> then an identity matrix 
will be used. If <code>cov_type = "mm"</code> (default) then sandwich estimator is 
used along with the penalized log-likelihood function. Therefore if there is 
no regularization then <code>"mm"</code> and <code>"sandwhich"</code> estimators are the
same. Second, suppose that <code>estimator = "2step"</code> then available 
estimators of the asymptotic covariance matrix are identity matrix 
<code>cov_type = "no"</code> and the method of moments <code>cov_type = "mm"</code>.</p>
</td></tr>
<tr><td><code id="msel_+3A_degrees">degrees</code></td>
<td>
<p>a vector of non-negative integers such that <code>degrees[i]</code>
represents the degree of the polynomial which elements are selectivity 
terms associated with the <code>i</code>-th ordered equation. See 'Details' for 
additional information.</p>
</td></tr>
<tr><td><code id="msel_+3A_degrees3">degrees3</code></td>
<td>
<p>a vector of non-negative integers such that 
<code>degrees3[i]</code> represents the degree of the polynomial which elements 
are selectivity terms associated with the <code>i</code>-th multinomial equation. 
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="msel_+3A_n_sim">n_sim</code></td>
<td>
<p>an integer representing the number of GHK draws when there are
more than 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
<tr><td><code id="msel_+3A_n_cores">n_cores</code></td>
<td>
<p>a positive integer representing the number of CPU cores used 
for the parallel computing. If possible it is highly recommend to set it 
equal to the number of available physical cores.</p>
</td></tr>
<tr><td><code id="msel_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See 'Details' for additional 
information.</p>
</td></tr>
<tr><td><code id="msel_+3A_regularization">regularization</code></td>
<td>
<p>a list of control parameters for regularization.
Element <code>ridge_ind</code> is a vector of indexes of parameters subject to 
regularization according to quadratic (ridge) penalty function.
These indexes correspond to parameters from <code>par</code> output element. 
Set <code>show_ind</code> argument of <code><a href="#topic+summary.msel">summary.msel</a></code> 
to <code>TRUE</code> to see these indexes.
Element <code>ridge_scale</code> is a numeric vector of weights of the ridge
penalty function. 
Element <code>ridge_location</code> is a numeric vector of values to be subtracted
from the parameters before they pass into the penalty function.
Elements <code>lasso_ind</code>, <code>lasso_scale</code> and <code>lasso_location</code> are
the same but for the lasso penalty term.</p>
</td></tr>
<tr><td><code id="msel_+3A_type3">type3</code></td>
<td>
<p>a character determining the type of the multinomial model to be
considered. If <code>type3 = "logit"</code> then multinomial logit model will
be used. If <code>type3 = "probit"</code> then multinomial probit model
will be applied. See 'Details' for additional information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to estimate multivariate and multinomial
sample selection and endogenous switching models with multiple outcomes. 
These models are the systems of ordinal, continuous and multinomial equations
described by <code>formula</code>, <code>formula2</code> and <code>formula3</code> 
respectively.
</p>
<p><strong>Ordinal equations</strong>
</p>
<p>Argument <code>formula</code> determines the regressors of the 
multivariate ordered probit model with the heteroscedastic random errors:
</p>
<p style="text-align: center;"><code class="reqn">z_{ji}^{*} = w_{ji}\gamma_{j} + \sigma_{ji}^{*}u_{ji},</code>
</p>
 
<p style="text-align: center;"><code class="reqn">\sigma_{ji}^{*} = \exp(w_{ji}^{*}\gamma_{j}^{*}), \quad 
      u_{i}\sim N\left(\begin{bmatrix}0\\ \vdots\\ 0\end{bmatrix}, 
                       \Sigma\right), i.i.d.,</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{ji}=\begin{cases}
                   0\text{, if }z_{ji}^{*}\leq c_{j1}\\
                   1\text{, if }c_{j1}&lt;z_{ji}^{*}\leq c_{j2}\\
                   2\text{, if }c_{j2}&lt;z_{ji}^{*}\leq c_{j3}\\
                   \vdots\\
                   m_{J-1}\text{, if }z_{(J-1)i}^{*}&gt;c_{(J-1)m_{j-1}}\\
                   \end{cases},</code>
</p>

<p style="text-align: center;"><code class="reqn">z_{i}=(z_{1i},...,z_{Ji})^{T},\quad
       u_{i} = (u_{1i},u_{2i},...,u_{Ji})^{T},</code>
</p>

<p style="text-align: center;"><code class="reqn">i\in\{1,2,...,n\},\quad j\in\{1,2,...,J\},</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">n</code> - the number of observations. If there are no omitted 
observations then <code class="reqn">n</code> equals to <code>nrow(data)</code>.
</p>
</li>
<li> <p><code class="reqn">J</code> - the number of ordinal equations which equals to 
<code>length(formula)</code>.
</p>
</li>
<li> <p><code class="reqn">z_{ji}^{*}</code> - an unobservable (latent) value of the <code>j</code>-th
dependent ordinal variable.
</p>
</li>
<li> <p><code class="reqn">z_{ji}</code> - an observable (ordinal) value of the <code>j</code>-th
dependent ordinal variable.
</p>
</li>
<li> <p><code class="reqn">m_{j}</code> - the number of categories of
<code class="reqn">z_{ji}\in\{0,1,...,m_{j}\}</code>.
</p>
</li>
<li> <p><code class="reqn">c_{jk}</code> - the <code class="reqn">k</code>-th cut (threshold) of the <code>j</code>-th
dependent ordinal variable.
</p>
</li>
<li> <p><code class="reqn">w_{ji}</code> - the regressors of the <code class="reqn">j</code>-th mean equation 
which should be described in <code>formula[[j]]</code>.
</p>
</li>
<li> <p><code class="reqn">\gamma_{j}</code> - the regression coefficients of the <code class="reqn">j</code>-th 
mean equation.
</p>
</li>
<li> <p><code class="reqn">w_{ji}\gamma_{j}</code> - the linear predictor (index) of the <code class="reqn">j</code>-th 
mean equation.
</p>
</li>
<li> <p><code class="reqn">u_{i}</code> - a multivariate normal random vector which elements are
standard normal random variables.
</p>
</li>
<li> <p><code class="reqn">\Sigma</code> - a correlation matrix of <code class="reqn">u_{i}</code> so
<code class="reqn">\Sigma_{t_{1}t_{2}}=\text{corr}\left(u_{it_{1}}, u_{it_{2}}\right)</code>.
</p>
</li>
<li> <p><code class="reqn">\sigma_{ji}^{*}</code> - a heteroscedastic standard deviation.
</p>
</li>
<li> <p><code class="reqn">\sigma_{ji}^{*}u_{ji}</code> - the heteroscedastic random errors.
</p>
</li>
<li> <p><code class="reqn">w_{ji}^{*}</code> - the regressors of the <code class="reqn">j</code>-th variance equation 
which should be described in <code>formula[[j]]</code> after '|' symbol.
</p>
</li>
<li> <p><code class="reqn">\gamma_{j}^{*}</code> - the regression coefficients of the <code class="reqn">j</code>-th 
variance equation.
</p>
</li>
<li> <p><code class="reqn">w_{ji}^{*}\gamma_{j}^{*}</code> - the linear predictor (index) of the 
<code class="reqn">j</code>-th variance equation.
</p>
</li></ul>

<p>Constant terms (intercepts) are excluded from the model for 
identification purposes. If <code class="reqn">z_{ji}</code> is a binary variable then 
<code class="reqn">-c_{j1}</code> may be interpreted as a constant term of the <code class="reqn">j</code>-th ordinal
equation. If all <code class="reqn">z_{ji}</code> are binary variables then the model becomes a
multivariate probit.
</p>
<p>By default the joint distribution of <code class="reqn">u_{i}</code> is multivariate normal.
However by using <code>marginal</code> argument it is possible to consider the 
joint distribution that is determined by the Gaussian copula and possibly
non-normal marginal distributions. Specifically, <code>names(marginal)[i]</code> 
is the name of the marginal distribution of <code class="reqn">u_{ji}</code> and 
<code>marginal[[i]]</code> is the number of parameters of this distribution.
The marginal distributions are the same as in <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code>.
</p>
<p><strong>Multinomial equation</strong>
</p>
<p>Argument <code>formula3</code> determines the regressors of the multinomial 
equation:
</p>
<p style="text-align: center;"><code class="reqn">\tilde{z}_{ji}^{*} = \tilde{w}_{i}\tilde{\gamma}_{j} + \tilde{u}_{ji},
\qquad j\in\{0,1,...,\tilde{J} - 1\},</code>
</p>

<p style="text-align: center;"><code class="reqn">\tilde{z}_{i}=\underset{t\in\{0,...,\tilde{J}-1\}}{\text{argmax}}
\text{ }\tilde{z}_{ti}^{*}, \qquad 
\tilde{u}_{i} = (\tilde{u}_{0i},\tilde{u}_{1i},...,
\tilde{u}_{(\tilde{J}-1)i})^{T},</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">\tilde{J}</code> - the number of the alternatives i.e., possible values
of the dependent variable of the multinomial equation.
</p>
</li>
<li> <p><code class="reqn">\tilde{z}_{ji}^{*}</code> - an unobservable (latent) value of the 
<code>j</code>-th alternative. Usually <code class="reqn">\tilde{z}_{ji}^{*}</code> is interpreted as 
a utility of the <code>j</code>-th alternative.
</p>
</li>
<li> <p><code class="reqn">\tilde{z}_{i}</code> - a selected alternative i.e., one which provides 
the greatest utility <code class="reqn">\tilde{z}_{ji}^{*}</code>.
</p>
</li>
<li> <p><code class="reqn">\tilde{w}_{i}</code> - the regressors of the multinomial equation
which should be described in <code>formula3</code> and assumed to be the same for
all the alternatives.
</p>
</li>
<li> <p><code class="reqn">\tilde{\gamma}_{j}</code> - the regression coefficients of the 
<code class="reqn">j</code>-th alternative's equation.
</p>
</li>
<li> <p><code class="reqn">\tilde{w}_{i}\tilde{\gamma}_{j}</code> - the linear predictor (index) 
of the <code class="reqn">j</code>-th alternative's equation.
</p>
</li>
<li> <p><code class="reqn">\tilde{u}_{i}</code> - a vector of random errors.
</p>
</li></ul>

<p>For the identification purposes it is assumed that the regression 
coefficients of the last alternative are zero 
<code class="reqn">\tilde{\gamma}_{\tilde{J} - 1} = (0,...,0)^{T}</code>.
</p>
<p>Joint distribution of <code class="reqn">\tilde{u}_{i}</code> depends on the value of 
<code>type3</code> argument. If <code>type3 = "logit"</code> then multinomial logit
model is considered. It assumes that <code class="reqn">\tilde{u}_{ji}</code> are independent
and their marginal distribution is Gumbel (error value distribution).
If <code>type3 = "probit"</code> then multinomial probit model is used so 
it is assumed that joint distribution of <code class="reqn">\tilde{u}_{i}</code> is 
multivariate normal with zero mean and the covariance matrix 
<code class="reqn">\tilde{\Sigma}</code>. For identification purposes it is also assumed 
that <code class="reqn">\tilde{\Sigma}_{11} = 1</code> so <code class="reqn">Var(\tilde{u}_{0i}) = 1</code>. 
In addition <code class="reqn">\tilde{u}_{(\tilde{J}-1)i}=0</code> which implies 
<code class="reqn">\tilde{\Sigma}_{t(\tilde{J})}=\tilde{\Sigma}_{(\tilde{J})t}=0</code> for all 
<code class="reqn">t\in\{0,...,\tilde{J}-1\}</code>.
</p>
<p><strong>Continuous equations</strong>
</p>
<p>Argument <code>formula3</code> determines the regressors of the continuous 
equations:
</p>
<p style="text-align: center;"><code class="reqn">y_{r^{(v)}i}^{(v)} = x_{i}^{(v)}\beta_{r^{(v)}}^{(v)} + 
\varepsilon_{r^{(v)}i}^{(v)},</code>
</p>

<p style="text-align: center;"><code class="reqn">r^{(v)}\in\{0,1,...,R^{(v)} - 1\}, \quad v\in \{1,...,V\},</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">V</code> - the number of continuous equations.
</p>
</li>
<li> <p><code class="reqn">r^{(v)}</code> - the regime of the <code class="reqn">v</code>-th continuous equation.
</p>
</li>
<li> <p><code class="reqn">y_{r^{(v)}i}^{(v)}</code> - the <code class="reqn">r^{(v)}</code>-th potential outcome
(in a sense of the Neyman-Rubin framework) of the <code class="reqn">v</code>-th continuous 
equation.
</p>
</li>
<li> <p><code class="reqn">R^{(v)}</code> - the number of the potential outcomes of the 
<code class="reqn">v</code>-th continuous equation.
</p>
</li>
<li> <p><code class="reqn">x_{i}^{(v)}</code> - the regressors of the <code class="reqn">v</code>-th continuous 
equation. They are provided via <code>formula2[[v]]</code>.
</p>
</li>
<li> <p><code class="reqn">\beta_{r^{(v)}}^{(v)}</code> - regression coefficients of the <code class="reqn">v</code>-th 
continuous equation in the regime <code class="reqn">r^{(v)}</code>.
</p>
</li>
<li> <p><code class="reqn">\varepsilon_{r^{(v)}i}^{(v)}</code> - a random error of the <code class="reqn">v</code>-th 
continuous equation in the regime <code class="reqn">r^{(v)}</code>.
</p>
</li></ul>

<p><strong>Estimation of the model with multivariate ordinal and 
multinomial equations</strong>
</p>
<p>If <code>formula2</code> is not provided then maximum-likelihood estimator is used 
<code>estimator = "ml"</code> to estimate the parameters of the multivariate 
ordinal and multinomial equations.
</p>
<p>If both <code>formula</code> and <code>formula3</code> are provided then parameters of
the multivariate ordered and multinomial equations are estimated under the
assumption that <code class="reqn">u_{i}</code> is independent of <code class="reqn">\tilde{u}_{i}</code>.
Therefore the estimates are identical to those obtained by separate
estimation of these models. We may relax the independence assumption
during future updates.
</p>
<p><strong>Estimation of the model with continuous equations</strong>
</p>
<p>If <code>formula</code> and <code>formula3</code> are not provided then it is assumed
that each continuous equation has only one regime so <code class="reqn">R^{(v)} = 1</code> for
each <code class="reqn">v\in\{1,...,V\}</code>.
</p>
<p>If <code>estimator = "ml"</code> then maximum-likelihood estimator is used under
the assumption that the distribution of random errors is multivariate normal.
If <code>estimator = "2step"</code> then <code class="reqn">V</code>-stage least squares estimator is
used. In the latter case <code class="reqn">v</code>-th equation is estimated by the least
squares estimator and for every <code class="reqn">v_{0}</code> such that <code class="reqn">v_{0} &lt; v</code> if 
<code class="reqn">y_{0i}^{(v_{0})}</code> is included in <code class="reqn">x_{i}^{(v)}</code> then 
<code class="reqn">y_{0i}^{(v_{0})}</code> is substituted with its estimate 
<code class="reqn">\hat{y}_{0i}^{(v_{0})}</code> obtained on the <code class="reqn">v_{0}</code>-th step.
Therefore if <code class="reqn">v_{0} &lt; v</code> then if some endogenous variable appears on the
left hand side of <code>formula2[[v]]</code> it should not appear on the right hand 
side of <code>formula2[[v0]]</code>.
</p>
<p><strong>Estimation of the model with ordinal outcomes and 
multivariate ordered selection</strong>
</p>
<p>Suppose that <code class="reqn">z_{i}</code> represents the ordinal potential outcomes while 
the observable values are <code class="reqn">z_{i}^{(o)} = g^{(1)}(z_{i})</code>, where function
<code class="reqn">g^{(1)}(z_{i})</code> converts unobservable values of <code class="reqn">z_{i}</code> to 
<code class="reqn">-1</code>. Therefore <code class="reqn">z_{ji}^{(o)}</code> instead of <code class="reqn">z_{i}</code> appears on the 
left hand side of the <code>formula[[j]]</code>.
</p>
<p>For example, consider a binary variable for the employment status 
(0 - unemployed, 1 - employed) and an ordinal variable <code class="reqn">z_{2i}</code> 
(ranging from 0 to 2) for job satisfaction 
(0 - unsatisfied, 1- satisfied, 2 - highly satisfied). Then <code class="reqn">z_{2i}</code> is 
observable only when <code class="reqn">z_{1i}</code> equals 1 since job satisfaction 
observable only for working individuals. Consequently <code class="reqn">z_{2i}^{(o)}</code> 
should be equal to -1 (minus one) whenever <code class="reqn">z_{1i}</code> equals to 0:
</p>
<p style="text-align: center;"><code class="reqn">z_{i}^{(o)}=g^{(1)}(z_{i})=
\begin{cases}
(1, 2)\text{, if }z_{i} = (1, 2)\\
(1, 1)\text{, if }z_{i} = (1, 1)\\
(1, 0)\text{, if }z_{i} = (1, 0)\\
(0, -1)\text{, otherwise}\\
\end{cases}</code>
</p>

<p>Rows of the matrix <code>groups</code> determine all possible values of the 
function <code class="reqn">g^{(1)}(z_{i})</code>. In this particular example matrix 
<code>groups</code> should have the following form:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}.</code>
</p>

<p>Notice that in this particular example it is necessary to ensure that
in <code>data</code> if <code class="reqn">z_{1i}^{(o)}</code> equals 0 then <code class="reqn">z_{2i}^{(o)}</code>
equals to -1. Also in this case matrix <code>groups</code> will be created 
automatically so there is no need to provide it manually.
</p>
<p>By using <code>groups</code> argument it is straightforward to consider 
various other models with ordinal outcomes and multivariate ordered 
selection mechanisms.
</p>
<p>If some values of the ordinal variables <code class="reqn">z_{ji}</code> are missing (by random) 
i.e., take <code>NA</code> value then the contribution of other ordinal dependent 
variables (for the i-th observation) still may be included into the 
likelihood function by manually substituting <code>NA</code> with -1 in the 
<code>data</code>. However, ensure that this particular (missing) <code class="reqn">z_{ji}</code> is 
not a regressor for other dependent variable that may happen in the 
hierarchical systems.
</p>
<p>It is useful to use <code>groups</code> argument to consider causal inference
models. For example, suppose that <code class="reqn">z_{1i}</code> represents a binary treatment 
variable for the university diploma (0 - no diploma, 1 - has diploma). Also, 
<code class="reqn">z_{2i}</code> is a binary potential outcome for the employment status 
(0 - unemployed, 1 - employed) of the individual if she has university 
diploma. Finally, <code class="reqn">z_{3i}</code> is a binary potential outcome for the 
employment status (0 - unemployed, 1 - employed) if individual does not have 
university diploma. Since <code class="reqn">z_{2i}</code> is observable only if <code class="reqn">z_{1i} = 1</code> 
and <code class="reqn">z_{3i}</code> is observable only when <code class="reqn">z_{2i} = 0</code> we get:
</p>
<p style="text-align: center;"><code class="reqn">z_{i}^{(o)} = 
\begin{cases}
(1, 1, -1)\text{, if }z_{1i} = 1\text{ and }z_{2i}=1\\
(1, 0, -1)\text{, if }z_{1i} = 1\text{ and }z_{2i}=0\\
(0, -1, 1)\text{, if }z_{1i} = 0\text{ and }z_{3i}=1\\
(0, -1, 0)\text{, if }z_{1i} = 0\text{ and }z_{3i}=0
\end{cases}.</code>
</p>

<p>Therefore to estimate this model it is necessary to ensure that in 
<code>data</code> we have <code class="reqn">z_{2i}^{(o)} = -1</code> when <code class="reqn">z_{1i}^{(o)} = 0</code> and 
<code class="reqn">z_{3i}^{(o)} = -1</code> if <code class="reqn">z_{1i}^{(o)} = 1</code>. Also the <code>groups</code>
argument should include all possible values of <code class="reqn">z_{i}^{(o)}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp;  1 &amp; -1\\
1 &amp;  0 &amp; -1\\
0 &amp; -1 &amp; 1\\
0 &amp; -1 &amp; 0                    
\end{bmatrix}.</code>
</p>

<p><strong>Estimation of the model with continuous outcomes and 
multivariate ordered selection</strong>
</p>
<p>To simplify the notations suppose that there is only one continuous equation
with multiple regimes:
</p>
<p style="text-align: center;"><code class="reqn">y_{ri} = x_{i}\beta_{r} + \varepsilon_{ri},</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{i} =
\begin{cases}
\text{unobservable, if }g^{(2)}\left(z_{i}^{(o)}\right) = -1\\
y_{0i}\text{, if }g^{(2)}\left(z_{i}^{(o)}\right) = 0\\
y_{1i}\text{, if }g^{(2)}\left(z_{i}^{(o)}\right) = 1\\
\vdots\\
y_{(R^{*}-1)i}\text{, if }g^{(2)}\left(z_{i}^{(o)}\right) = R^{*} - 1\\
\end{cases},</code>
</p>

<p style="text-align: center;"><code class="reqn">\varepsilon_{i} = (\varepsilon_{0i},\varepsilon_{1i},...,\varepsilon_{(R^{*}-1)i}),\quad
r\in\{0,1,...,R^{*} - 1\},</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">y_{i}</code> - an observable continuous outcome.
</p>
</li>
<li> <p><code class="reqn">r</code> - the index of the potential outcome.
</p>
</li>
<li> <p><code class="reqn">R^{*}</code> - the number of the regimes.
</p>
</li>
<li> <p><code class="reqn">y_{ri}</code> - a continuous potential outcome i.e., the value of
<code class="reqn">y_{i}</code> in the regime <code class="reqn">r</code>.
</p>
</li>
<li> <p><code class="reqn">x_{i}</code> - the vector of regressors provided in <code>formula2</code>.
</p>
</li>
<li> <p><code class="reqn">\beta_{r}</code> - the regression coefficients in the <code class="reqn">r</code>-th regime. 
</p>
</li>
<li> <p><code class="reqn">g^{(2)}(z_{i}^{(o)})</code> - a function determining which potential 
outcome is observable depending on the observable values of the ordinal 
variables <code class="reqn">z_{i}^{(o)}</code>.
</p>
</li>
<li> <p><code class="reqn">\varepsilon_{i}</code> - a vector of random errors.
</p>
</li></ul>

<p>The value of <code>groups2[i]</code> argument specifies the value 
of <code class="reqn">g^{(2)}(z_{i}^{(o)})</code> when <code class="reqn">z_{i}^{(o)}</code> equals to 
<code>groups[i, ]</code>. The values of <code class="reqn">y_{i}</code> in <code>data</code> such that
<code class="reqn">g^{(2)}(z_{i}^{(o)})=-1</code> should be set to <code>NA</code>.
</p>
<p>For example, consider a system of equations for wage <code class="reqn">y_{i}</code>,
employment status <code class="reqn">z_{1i}</code> (0 - unemployed, 1 - employed)
and job satisfaction <code class="reqn">z_{2i}</code> 
(0 - unsatisfied, 1- satisfied, 2 - highly satisfied). Notice that wage and
job satisfaction are observable only for working individuals. Also suppose
that wage is unobservable for unsatisfied workers and observable in different
regimes for other workers. Namely, for satisfied workers <code class="reqn">z_{2i} = 1</code> we 
observe <code class="reqn">y_{0i}</code> and for highly satisfied workers <code class="reqn">z_{2i} = 2</code> we 
observe <code class="reqn">y_{1i}</code>.
</p>
<p>To estimate this model it is necessary to  manually specify the structure of 
the equations via <code>groups</code> and <code>groups2</code> arguments by providing all 
possible combinations of the ordinal variables and the regimes of the 
continuous equation:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}, \text{groups2} =
\begin{bmatrix}
1\\
0\\
-1\\
-1                     
\end{bmatrix}.</code>
</p>

<p>Notice that <code>groups2[1] = 1</code> indicates that when 
<code>groups[1, ] = c(1, 2)</code> i.e. <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 2</code> 
we observe <code class="reqn">y_{i}</code> in regime <code>1</code> corresponding to the wage of highly 
satisfied workers <code class="reqn">y_{1i}</code>. 
Similarly <code>groups2[2] = 0</code> indicates that when 
<code>groups[2, ] = c(1, 1)</code> i.e., <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 1</code> we 
observe <code class="reqn">y_{i}</code> in the regime <code>0</code> corresponding to the wage of the
satisfied workers  <code class="reqn">y_{0i}</code>. Also, <code>groups3[3] = -1</code> means that when 
<code>groups[3, ] = c(1, 0)</code> i.e., <code class="reqn">z_{1i} = 1</code> and <code class="reqn">z_{2i} = 0</code> we
do not observe the wage of the worker <code class="reqn">y_{i}</code> since he is unsatisfied.
Finally, <code>groups3[4] = -1</code> means that when 
<code>groups[4, ] = c(0, -1)</code> i.e., <code class="reqn">z_{1i} = 0</code> and 
<code class="reqn">z_{2i}^{(o)} = -1</code> we do not observe the wage of the worker 
<code class="reqn">y_{i}</code> since he is unemployed.
</p>
<p>If the joint distribution of <code class="reqn">\varepsilon_{i}</code> and <code class="reqn">u_{i}</code> is 
multivariate normal then according to Kossova and Potanin (2018):
</p>
<p style="text-align: center;"><code class="reqn">y_{ri}=x_{i}\beta_{r}+\sum\limits_{j=1}^{J} 
\Sigma^{(12)}_{j(r+1)}\lambda_{ji}+\varepsilon_{ri}^{*},</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{ri}^{*} = \varepsilon_{ri} - 
E(\varepsilon_{i}|z_{1i},...z_{Ji})=\varepsilon_{ri} - 
\sum\limits_{j=1}^{J} \Sigma^{(12)}_{j(r+1)}\lambda_{ji},</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda_{ji}=
\lambda_{ji}^{(1)} + \lambda_{ji}^{(2)},\qquad 
\Sigma^{(12)}_{j(r+1)} = cov(u_{ji}, \varepsilon_{r+1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda_{ji}^{(1)}=
\begin{cases}
0\text{, if }z_{ji} = 0\\
-\frac{\partial \ln P_{i}^{*}}{\partial a_{ji}}\text{, otherwise }
\end{cases},
\qquad
\lambda_{ji}^{(2)}=
  \begin{cases}
0\text{, if }z_{ji} = m_{j} - 1\\
-\frac{\partial \ln P_{i}^{*}}{\partial b_{ji}}\text{, otherwise }
\end{cases},</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{i}^{*}(a_{1i},...,a_{Ji};b_{1i},...,b_{Ji})=
P(a_{1i}\leq u_{1i}\leq b_{1i},....,a_{Ji}\leq u_{Ji}\leq b_{Ji}),</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{ji}=
\begin{cases}
-\infty\text{, if }z_{ji} = 0\\
\frac{c_{jz_{ji}}-w_{ji}\gamma_{j}}{\sigma_{ji}^{*}}\text{, otherwise }
\end{cases},
\qquad 
b_{ji}=
  \begin{cases}
\infty\text{, if }z_{ji} = m_{j} - 1\\
\frac{c_{j(z_{ji}+1)}-w_{ji}\gamma_{j}}{\sigma_{ji}^{*}}\text{, otherwise }
\end{cases}.</code>
</p>

<p>Notice that the regression equation has selectivity terms <code class="reqn">\lambda_{ji}</code>
which may be correlated with <code class="reqn">x_{i}</code>. Therefore until random errors
<code class="reqn">u_{i}</code> and <code class="reqn">\varepsilon_{i}</code> are correlated the least squares 
estimator of <code class="reqn">x_{i}</code> on <code class="reqn">y_{ri}</code> is inconsistent. 
To get consistent estimates of <code class="reqn">\beta_{r}</code> it is possible to use 
maximum-likelihood <code>estimator = "ml"</code> or two-step (method of moments) 
<code>estimator = "2step"</code> estimator.
</p>
<p>If the two-step estimator is used then on the first step <code class="reqn">\lambda_{ji}</code>
are estimated as the functions of the estimates of the multinomial 
heteroscedastic ordered probit model. On the second step least squares 
regression of <code class="reqn">y_{ri}</code> on <code class="reqn">x_{i}</code> and the first step estimates 
<code class="reqn">\hat{\lambda}_{ji}</code> is used to estimate <code class="reqn">\beta_{r}</code> and 
<code class="reqn">\Sigma^{(12)}_{j(r+1)}</code>.
</p>
<p>If the joint distribution of random errors <code class="reqn">\varepsilon_{i}</code>, <code class="reqn">u_{i}</code> 
is not multivariate normal then <code class="reqn">\lambda_{ji}</code> terms may enter continuous
equation non-linearly. Following Newey (2009) and 
E. Kossova, L. Kupriianova, and B. Potanin (2020) it is assumed that:
</p>
<p style="text-align: center;"><code class="reqn">y_{ri}= x_{i}\beta_{r} + \zeta_{i}\tau_{r} + \varepsilon_{i}^{*},</code>
</p>

<p>where <code class="reqn">\tau_{r}</code> is a <code class="reqn">n_{\lambda}</code>-dimensional column vector and:
</p>
<p style="text-align: center;"><code class="reqn">\zeta_{i} = (\zeta_{1}(\lambda_{i}),...,
\zeta_{n_{\lambda}}(\lambda_{i})),\qquad \lambda_{i} = (\lambda_{1i},...,
\lambda_{Ji}).</code>
</p>

<p>Functions <code class="reqn">\zeta_{t}(\lambda_{i})</code> are specified manually by the user in
the <code>formula2</code> inside <code>I()</code>. For example, to specify
<code class="reqn">\zeta_{t}(\lambda_{i}) = \lambda_{1i}\times \lambda_{2i}</code> it is 
sufficient to have a term <code>I(lambda1 * lambda2)</code> in <code>formula2</code>. 
Notice that to avoid the confusions no variables in <code>data</code> should have 
the names containing <code>"lambda"</code>. Otherwise these variables will be 
dropped.
</p>
<p>It is possible to specify <code class="reqn">\zeta_{t}(\lambda_{i})</code> functions as the 
polynomial without interaction terms by using <code>degrees</code> argument.
Specifically, if <code>degrees[j] = t</code> then <code>lambdaj</code>, 
<code>I(lambdaj ^ 2)</code>,...,<code>I(lambdaj ^ t)</code> terms are added to
<code>formula2</code>. However, if <code>degrees</code> argument is used then no 
functions of <code>lambdaj</code> should be provided manually in <code>formula2</code>.
Otherwise it will be assumed that <code>degrees</code> is a vector of zeros.
Also if <code>estimator = "2step"</code>, there is not <code>lambdaj</code> terms in 
<code>formula2</code> and <code>degrees</code> is <code>NA</code> then <code>degrees</code> will be
converted in a vector of ones.
</p>
<p>If there are multiple continuous equations then <code>formula2</code> should be 
a list of formulas. Further, if <code>estimator = "2step"</code> then the second 
step is a <code class="reqn">V</code>-stage least squares estimator with <code>lambda</code> terms.
If they are provided via <code>degrees</code> argument then it should be a matrix 
which <code>v</code>-th row corresponds to the <code>v</code>-th continuous equation.
</p>
<p>For example, consider previous example with additional continuous equation 
for working hours
<code class="reqn">y_{i}^{(2)}</code> which does not vary with the satisfaction of the workers
<code class="reqn">z_{2i}</code> but observable only for the employed individuals 
<code class="reqn">z_{1i} = 1</code>. To estimate the system with this additional continuous 
equation simply substitute all <code class="reqn">y_{i}^{(2)}</code> (such that <code class="reqn">z_{1i}=0</code>) 
in <code>data</code> with <code>NA</code> and specify:
</p>
<p style="text-align: center;"><code class="reqn">\text{groups} =
\begin{bmatrix}
1 &amp; 2\\
1 &amp; 1\\
1 &amp; 0\\
0 &amp; -1                     
\end{bmatrix}, \text{groups2} =
\begin{bmatrix}
1 &amp; 0\\
0 &amp; 0\\
-1 &amp; 0\\
-1 &amp; -1                    
\end{bmatrix}.</code>
</p>

<p>Notice that <code>groups2[, 1]</code> describes the regimes of the wage equation 
<code class="reqn">y_{i}^{(1)}</code> while <code>groups[, 2]</code> contains the regimes of the hours 
equation <code class="reqn">y_{i}^{(2)}</code>. Note that formula of the first equation (wage)
should be specified in <code>formula2[[1]]</code> and formula of the second
equation should be provided via <code>formula2[[2]]</code> i.e., as the
first and the second elements in a <code>formula2</code> list correspondingly.
</p>
<p>If <code>marginal</code> argument is used then aforementioned formula of 
<code class="reqn">\lambda_{ji}</code> is slightly modified to address for the non-normal 
marginal distribution of <code class="reqn">u_{ji}</code>.
</p>
<p><strong>Estimation of the model with continuous outcomes and multinomial 
selection</strong>
</p>
<p>The only difference with the previous model is that the observable value of
the continuous equation depends on the value of the multinomial equation
described in <code>formula3</code>. Therefore <code class="reqn">g^{(2)}(z_{i}^{(o)})</code> is 
substituted with <code class="reqn">g^{(3)}(\tilde{z}_{i})</code>. Also <code>groups3</code> argument 
instead of <code>groups</code> is used. Since there is only a single multinomial 
equation argument <code>groups3</code> is a vector.
If <code>groups3[k] = q</code> and <code>groups2[k, v] = r</code> then
<code class="reqn">\tilde{z}_{i} = q</code> implies <code class="reqn">y_{i}^{(v)} = y_{ri}^{(v)}</code>. 
Remind that a special value <code>r = -1</code> implies that <code class="reqn">y_{i}^{(v)}</code> is
unobservable.
</p>
<p>Only two-step <code>estimator = "2step"</code> estimator of this model is 
available that is similar to the one described above. The only difference is 
the formula used to estimate selectivity terms. If <code>type = "logit"</code> then 
two-step estimator of Dubin-McFadden (1984) is used so selectivity terms
are as follows:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ji} = 
\begin{cases}
-\ln P(\tilde{z}_{i} = j)\text{, if }\tilde{z}_{i} = j\\
\frac{P(\tilde{z}_{i} = j)\ln P(\tilde{z}_{i} = j)}{1 - 
P(\tilde{z}_{i} = j)}\text{, otherwise}
\end{cases},
</code>
</p>

<p>where <code class="reqn">j\in\{0,...,\tilde{J} - 1\}</code> and:
</p>
<p style="text-align: center;"><code class="reqn">P(\tilde{z}_{i} = j) = 
\begin{cases}
\frac{e^{(\tilde{w}_{i}\tilde{\gamma}_{j})}}{1 + 
\sum\limits_{q=0}^{\tilde{J} - 2}e^{(\tilde{w}_{i}\tilde{\gamma}_{q})}}
\text{, if }j\ne \tilde{J} - 1\\
\frac{1}{1 + 
\sum\limits_{q=0}^{\tilde{J} - 2}e^{(\tilde{w}_{i}\tilde{\gamma}_{q})}}
\text{, otherwise}\\
\end{cases}.</code>
</p>

<p>If <code>type = "probit"</code> then two-step estimator of Kossova and 
Potanin (2022) is used with the selectivity terms of the form:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ji} = \left(A^{(\tilde{z}_{i})}\lambda_{i}^{*}\right)_{j},</code>
</p>

<p>where <code class="reqn">j\in\{0,...,\tilde{J} - 2\}</code> and:
</p>
<p style="text-align: center;"><code class="reqn">A^{(j)}_{t_{1}t_{2}} = 
\begin{cases}
1\text{, if }t_{1} = j + 1\\
-1\text{, if }t_{1} &lt; j + 1\text{ and }t_{1} = t_{2}\\
-1\text{, if }t_{1} &gt; j + 1\text{ and }t_{1} = t_{2} + 1\\
0\text{, otherwise }
\end{cases},
</code>
</p>

<p style="text-align: center;"><code class="reqn">t_{1},t_{2}\in\{1,...,\tilde{J} - 1\},</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda_{i}^{*} = 
\nabla \ln P\left(\tilde{z}_{i}\right) = 
      \nabla \ln F_{\tilde{u}^{(ji)}}\left(\tilde{z}_{1}^{(ji)},...,
      \tilde{z}_{\tilde{J}-1}^{(ji)}\right)=
      \left(\lambda_{1i}^{*},...,\lambda_{(\tilde{J}-1)i}^{*}  \right)^{T},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\tilde{u}^{(ji)} = 
\left(\tilde{u}_{0i}-\tilde{u}_{ji},\tilde{u}_{1i}-\tilde{u}_{ji},...,
      \tilde{u}_{(j-1)i}-\tilde{u}_{ji},\tilde{u}_{(j+1)i}-\tilde{u}_{ji},...,
      \tilde{u}_{(\tilde{J} - 1)i}-\tilde{u}_{ji}\right),
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\tilde{z}^{(ji)} = \tilde{w}_{i}\left(
   \left(\tilde{\gamma}_{j}-\tilde{\gamma}_{0}\right), 
   \left(\tilde{\gamma}_{j}-\tilde{\gamma}_{1}\right),...,
   \left(\tilde{\gamma}_{j}-\tilde{\gamma}_{j-1}\right),
   \left(\tilde{\gamma}_{j}-\tilde{\gamma}_{j+1}\right),...,
   \left(\tilde{\gamma}_{j}-\tilde{\gamma}_{\tilde{J} - 1}\right)\right).</code>
</p>

<p>Probabilities <code class="reqn">P(z_{i})</code> are calculated by using a cumulative 
distribution function of the multivariate normal distribution with zero mean
and the covariance matrix of <code class="reqn">\tilde{u}^{(ji)}</code>.
</p>
<p>In <code>formula2</code> selectivity terms associated with the 
multinomial equation should be named <code>lambdaj_mn</code> instead of 
<code>lambdaj</code>. Argument <code>degrees3</code> is similar to <code>degrees</code>.
</p>
<p>Consider a simple example of this model. Suppose that <code class="reqn">\tilde{z}_{i}</code>
is a multinomial variable for the employment status 
(0 - unemployed, 1 - working in IT sector, 2 - working in other sector). 
Wage <code class="reqn">y_{i}</code> is unobservable for unemployed <code class="reqn">\tilde{z}_{i} = 0</code>, 
equals to <code class="reqn">y_{0i}</code> in IT sector <code class="reqn">\tilde{z}_{i} = 1</code> and equals to 
<code class="reqn">y_{1i}</code> in other sectors <code class="reqn">\tilde{z}_{i} = 2</code>. 
To estimate this model set <code>groups3 = (0, 1, 2)</code> and 
<code>groups2 = (-1, 0, 1)</code>. Then substitute all <code class="reqn">y_{i}</code> such that 
<code class="reqn">\tilde{z}_{i} = 0</code> with <code>NA</code>.
</p>
<p><strong>Estimation of the model with continuous outcomes and mixed selection</strong>
</p>
<p>It is possible to consider the model with continuous outcomes and both 
multinomial and ordinal selection equations. Remind that it is assumed that
random errors of the ordered and multinomial equations are independent. 
Therefore if <code>formula</code> and <code>formula3</code> are provided then both 
<code>lambdaj</code> and <code>lambdaj_mn</code> are included in <code>formula2</code>. Only 
two-step estimator <code>estimator = "2step"</code> is available for this model.
</p>
<p><strong>Missing values</strong>
</p>
<p>If any of the left hand side variables (regressors) of <code>formula[[j]]</code>
is missing then the right hand side variable of <code>formula[[j]]</code> will
be set to <code>NA</code> in <code>data</code>. Similar is true for <code>formula2</code>
and <code>formula3</code>.
</p>
<p><strong>Additional information</strong>
</p>
<p>Functions <code><a href="mnorm.html#topic+pmnorm">pmnorm</a></code> and <code><a href="mnorm.html#topic+dmnorm">dmnorm</a></code> are 
used internally for calculation of multivariate normal probabilities, 
densities and their derivatives.
</p>
<p>Currently <code>control</code> has no input arguments intended for the users. 
This argument is used for some internal purposes of the package.
</p>
<p>Optimization always starts with <code><a href="stats.html#topic+optim">optim</a></code>. If
<code>opt_type = "gena"</code> or <code>opt_type = "pso"</code> then 
<code><a href="gena.html#topic+gena">gena</a></code> or <code><a href="gena.html#topic+pso">pso</a></code> is used
to proceed optimization starting
from initial point provided by <code>optim</code>. Manual arguments to 
<code><a href="stats.html#topic+optim">optim</a></code>
should be provided in a form of a list through <code>opt_args$optim</code>.
Similarly <code>opt_args$gena</code> and <code>opt_args$pso</code> provide manual
arguments to <code><a href="gena.html#topic+gena">gena</a></code> and <code><a href="gena.html#topic+pso">pso</a></code>.
For example to provide Nelder-Mead optimizer to 
<code><a href="stats.html#topic+optim">optim</a></code> and
restrict the number of genetic algorithm iterations to <code class="reqn">10</code> make
<code>opt_args = list(optim = list(method = "Nelder-Mead"), 
gena = list(maxiter = 10))</code>.
</p>
<p>If <code>estimator = "2step"</code> then it is possible to precalculate the first 
step model with <code><a href="#topic+msel">msel</a></code> function
and pass it through the <code>formula</code> argument. It allows to experiment
with various <code>formula2</code> and <code>degrees</code> specifications without
extra computational burden associated with the first step estimation.
</p>
<p>If <code>estimator = "2step"</code> then the method of moments estimator of the 
asymptotic covariance matrix is used as described in 
Meijer and Wansbeek (2007).
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>"msel"</code>. 
It is a list which may contain the following elements:
</p>

<ul>
<li> <p><code>par</code> - a vector of the estimates of the parameters.
</p>
</li>
<li> <p><code>estimator</code> - the same as the <code>estimator</code> input argument.
</p>
</li>
<li> <p><code>type3</code> - the same as the <code>type3</code> input argument.
</p>
</li>
<li> <p><code>formula</code> - the same as <code>formula</code> input argument but all
elements are coerced to <code>"formula"</code> type.
</p>
</li>
<li> <p><code>formula2</code> - the same as <code>formula2</code> input argument but all
elements are coerced to <code>"formula"</code> type.
</p>
</li>
<li> <p><code>formula3</code> - the same as <code>formula3</code> input argument but all
elements are coerced to <code>"formula"</code> type.
</p>
</li>
<li> <p><code>model1</code> - an object of class <code>"msel"</code> with the first step 
estimation results.
</p>
</li>
<li> <p><code>data</code> - the same as <code>data</code> input argument but
without missing (by random) values.
</p>
</li>
<li> <p><code>W_mean</code> - a list such that <code>W_mean[[j]]</code> is a matrix of the 
regressors <code class="reqn">w_{ji}</code> of the mean equation of <code class="reqn">z_{ji}^{*}</code>.
</p>
</li>
<li> <p><code>W_var</code> - a list such that <code>W_var[[j]]</code> is a matrix of the 
regressors <code class="reqn">w_{ji}^{*}</code> of the variance equation of <code class="reqn">z_{ji}^{*}</code>.
</p>
</li>
<li> <p><code>X</code> - a list such that <code>X[[v]]</code> is a numeric matrix of
regressors <code class="reqn">x_{i}^{(v)}</code> of the <code>v</code>-th continuous equation
<code class="reqn">y_{i}^{(v)}</code>.
</p>
</li>
<li> <p><code>W_mn</code> - a matrix of the regressors <code class="reqn">\tilde{w}_{i}</code> of the 
multinomial equation of <code class="reqn">\tilde{z}_{ji}^{*}</code>.
</p>
</li>
<li> <p><code>dependent</code> - a numeric matrix which <code class="reqn">j</code>-th column 
<code>dependent[, j]</code> is a vector of the ordinal dependent variable
<code class="reqn">z_{ji}^{(o)}</code> values.
</p>
</li>
<li> <p><code>dependent2</code> - a numeric matrix which <code class="reqn">v</code>-th column 
<code>dependent2[, v]</code> is a vector of the continuous dependent variable
<code class="reqn">y_{i}^{(v)}</code> values.
</p>
</li>
<li> <p><code>dependent3</code> - a numeric vector of values of the multinomial
dependent variable <code class="reqn">\tilde{z}_{j}</code>.
</p>
</li>
<li> <p><code>groups</code> - the same as <code>groups</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>groups2</code> - the same as <code>groups2</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>groups3</code> - the same as <code>groups3</code> input argument or 
automatically generated matrix representing the structure of the system 
of equations. Please, see 'Details' section above for more information.
</p>
</li>
<li> <p><code>marginal</code> - the same as <code>marginal</code> input argument.
</p>
</li>
<li> <p><code>ind</code> - a list containing some indexes partition of the 
model (not intended for the users).
</p>
</li>
<li> <p><code>start</code> - the same as the <code>start</code> input argument.
</p>
</li>
<li> <p><code>twostep</code> - a list such that <code>twostep[[v]][[r + 1]]</code> is an
object of class <code>"lm"</code> associated with the second step estimates
of the <code>v</code>-th equation in the regime <code>r</code>.
</p>
</li>
<li> <p><code>y_pred</code> - a numeric matrix such that <code>y_pred[, v]</code> is a 
second step prediction of the <code class="reqn">y_{i}^{(v)}</code>.
</p>
</li>
<li> <p><code>coef</code> - a list which <code class="reqn">j</code>-th element <code>coef[[j]]</code> is 
a numeric vector representing <code class="reqn">\hat{\gamma}_{j}</code>.
</p>
</li>
<li> <p><code>coef_var</code> - a list which <code class="reqn">j</code>-th element <code>coef_var[[j]]</code> 
is a numeric vector representing <code class="reqn">\hat{\gamma}_{j}^{*}</code>.
</p>
</li>
<li> <p><code>cuts</code> - a list which <code class="reqn">j</code>-th element <code>cuts[[j]]</code> is 
a numeric vector representing <code class="reqn">\hat{c}_{j}</code>.
</p>
</li>
<li> <p><code>coef2</code> - a list of numeric matrices such that 
<code>coef2[[v]][, r + 1]</code> is a numeric vector representing
<code class="reqn">\hat{\beta}_{r^{(v)}}^{(v)}</code>.
</p>
</li>
<li> <p><code>sigma</code> - a numeric matrix such that <code>sigma[j, t]</code> is a 
numeric value representing <code class="reqn">\widehat{Cov}(u_{ji}, u_{ti})</code>.
</p>
</li>
<li> <p><code>var2</code> - a list of numeric vectors such that 
<code>var2[[v]][r + 1]</code> represents 
<code class="reqn">\widehat{Var}(\varepsilon_{ri}^{(v)})</code>.
</p>
</li>
<li> <p><code>cov2</code> - a list of numeric matrices which element 
<code>sigma2[[v]][j, r + 1]</code> represents
<code class="reqn">\widehat{Cov}(u_{ji}, \varepsilon_{ri}^{(v)}))</code>.
</p>
</li>
<li> <p><code>sigma2</code> - a list of numeric matrices representing the estimates
of the covariances between random errors of the continuous equations in 
different regimes 
<code class="reqn">\widehat{Cov}(\varepsilon_{r^{(v)}i}^{(v)}, 
\varepsilon_{r^{(t)}i}^{(t)})</code>.
</p>
</li>
<li> <p><code>marginal_par</code> - a list such that <code>marginal_par[[j]]</code> is a 
numeric vector of estimates of the parameters of the marginal distribution 
of <code class="reqn">u_{ji}</code>.
</p>
</li>
<li> <p><code>coef3</code> - a numeric matrix such that <code>coef3[j + 1, ]</code> is 
a numerc vector representing <code class="reqn">\hat{\tilde{\gamma}}_{j}</code>.
</p>
</li>
<li> <p><code>sigma3</code> - a numeric matrix such that <code>sigma3[j + 1, t + 1]</code> 
is a numeric value representing 
<code class="reqn">\widehat{Cov}(\tilde{u}_{ji}, \tilde{u}_{ti})</code>.
</p>
</li>
<li> <p><code>lambda</code> - a numeric matrix such that <code>lambda[i, j]</code> 
corresponds to <code class="reqn">\hat{\lambda}_{ji}</code> of the ordinal equations.
</p>
</li>
<li> <p><code>lambda_mn</code> - a numeric matrix such that <code>lambda_mn[i, j]</code> 
corresponds to <code class="reqn">\hat{\lambda}_{ji}</code> of the multinomial equation.
</p>
</li>
<li> <p><code>H</code> - if <code>estimator = "ml"</code> then <code>H</code> is a Hessian matrix 
of the log-likelihood function. If <code>estimator = "2step"</code> then <code>H</code>
is a numeric matrix of the derivatives of mean sample scores respect to the 
estimated parameters.
</p>
</li>
<li> <p><code>J</code> - if <code>estimator = "ml"</code> then <code>J</code> is a Jacobian 
matrix of the log-likelihood function. If <code>estimator = "2step"</code> then
<code>J</code> is a numeric matrix such that <code>J[, s]</code> is a vector of sample 
scores associated with the parameter <code>par[s]</code>.
</p>
</li>
<li> <p><code>cov_type</code> - the same as <code>cov_type</code> input argument.
</p>
</li>
<li> <p><code>cov</code> - an estimate of the asymptotic covariance matrix of 
the parameters' estimator.
</p>
</li>
<li> <p><code>tbl</code> - a list of special tables used to create a summary 
(not intended for the users).
</p>
</li>
<li> <p><code>se</code> - a numeric vector of standard errors of the estimates.
</p>
</li>
<li> <p><code>p_value</code> - a numeric vectors of the p-values of the tests on 
the significance of the estimated parameters where the null hypothesis is 
that corresponding parameter is zero.
</p>
</li>
<li> <p><code>logLik</code> - the value of log-likelihood function at <code>par</code>.
</p>
</li>
<li> <p><code>other</code> - a list of additional variables not intended for the 
users.
</p>
</li></ul>

<p>It is highly recommended to get the estimates of the parameters via
<code><a href="#topic+coef.msel">coef.msel</a></code> function.
</p>


<h3>References</h3>

<p>W. K. Newey (2009). 
Two-step series estimation of sample selection models.
The Econometrics Journal, vol. 12(1), pages 217-229.
</p>
<p>E. Kossova, B. Potanin (2018). 
Heckman method and switching regression model multivariate generalization.
Applied Econometrics, vol. 50, pages 114-143.
</p>
<p>E. Kossova, L. Kupriianova, B. Potanin (2020). 
Parametric and semiparametric multivariate sample selection models 
estimators' accuracy: Comparative analysis on simulated data.
Applied Econometrics, vol. 57, pages 119-139.
</p>
<p>E. Kossova, B. Potanin (2022). 
Estimation of Gaussian multinomial endogenous switching model.
Applied Econometrics, vol. 67, pages 121-143.
</p>
<p>E. Meijer, T. Wansbeek (2007). 
The sample selection model from a method of moments perspecrive.
Econometric Reviews, vol. 26(1), pages 25-51.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------
# CPS data example
# ---------------------------------------

# Set seed for reproducibility
set.seed(123)

# Upload data
data(cps)

# Prepare the variable for education
cps$educ                    &lt;- NA
cps$educ[cps$basic == 1]    &lt;- 0
cps$educ[cps$bachelor == 1] &lt;- 1
cps$educ[cps$master == 1]   &lt;- 2

# Labor supply (probit) model
f_work &lt;- work ~ age + I(age ^ 2) + bachelor + master + health + 
                 slwage + nchild
model1 &lt;- msel(f_work, data = cps)
summary(model1)
    
# Education choice (ordered probit) model
f_educ &lt;- educ ~ age + I(age ^ 2) + sbachelor + smaster
model2 &lt;- msel(f_educ, data = cps)
summary(model2)   

# Education choice (multinomial logit) model
model3 &lt;- msel(formula3 = f_educ, data = cps, type3 = "logit")
summary(model3)  

# Education choice (multinomial probit) model
model4 &lt;- msel(formula3 = f_educ, data = cps, type3 = "probit")
summary(model4) 

# Labor supply with endogenous ordinal education 
# treatment (recursive or hierarchical ordered probit) model
model5 &lt;- msel(list(f_work, f_educ), data = cps)  
summary(model5)         

# Sample selection (on employment) Heckman's model
f_lwage                  &lt;- lwage ~ age + I(age ^ 2) + 
                                    bachelor + master + health
model6                   &lt;- msel(f_work, f_lwage, data = cps)
summary(model6)

# Ordinal endogenous education treatment with non-random 
# sample selection into employment
model7 &lt;- msel(list(f_work, f_educ), f_lwage, data = cps)
summary(model7)
 
# Ordinal endogenous switching on education model with 
# non-random selection into employment
groups   &lt;- cbind(c(1, 1, 1, 0, 0, 0),
                  c(0, 1, 2, 0, 1, 2))
groups2  &lt;- matrix(c(0, 1, 2, -1, -1, -1), ncol = 1)
f_lwage2 &lt;- lwage ~ age + I(age ^ 2) + health
model8   &lt;- msel(list(f_work, f_educ), f_lwage2,
                      groups = groups, groups2 = groups2,
                      data   = cps)
summary(model8)

# Multinomial endogenous switching on education model with 
# non-random selection into employment
groups  &lt;- matrix(c(1, 1, 1, 0, 0, 0), ncol = 1)
groups2 &lt;- matrix(c(0, 1, 2, -1, -1, -1), ncol = 1)
groups3 &lt;- c(0, 1, 2, 0, 1, 2)
model9  &lt;- msel(f_work, f_lwage2, f_educ,
                groups    = groups,  groups2 = groups2, 
                groups3   = groups3, data    = cps,
                estimator = "2step")
summary(model9)


# ---------------------------------------
# Simulated data example 1
# Ordered probit and other univariate
# ordered choice models
# --------------------------------------

# ---
# Step 1
# Simulation of the data
# ---

# Load required package
library("mnorm")

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
u &lt;- rnorm(n = n, mean = 0, sd = 1)

# Coefficients
gamma &lt;- c(-1, 2)

# Linear predictor (index)
li &lt;- gamma[1] * w1 + gamma[2] * w2

# Latent variable
z_star &lt;- li + u

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordinal outcome
z                                           &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]]                         &lt;- 3
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, z = z)

# ---
# Step 2
# Estimation of the parameters
# ---

# Estimation
model &lt;- msel(z ~ w1 + w2, data = data)
summary(model)

# Compare the estimates and true values of the parameters
  # regression coefficients
gamma_est &lt;- coef(model, type = "coef", eq = 1)
cbind(true = gamma, estimate = gamma_est)
  # cuts
cuts_est &lt;- coef(model, type = "cuts", eq = 1)
cbind(true = cuts, estimate = cuts_est)   

# ---
# Step 3
# Estimation of the probabilities and marginal effects
# ---

# Predict conditional probability of the dependent variable
# equals to 2 for every observation in a sample.
# P(z = 2 | w)
prob &lt;- predict(model, group = 2, type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on P(z = 1 | w)
mean(predict(model, group = 1, type = "prob", me = "w2"))

# Calculate probabilities and marginal effects
# for manually provided observations.
  # new data
newdata &lt;- data.frame(z = c(1, 1), 
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8))
  # probability P(z = 2 | w)
predict(model, group = 2, type = "prob", newdata = newdata)
  # linear predictor (index)
predict(model, type = "li", newdata = newdata)  
  # marginal effect of w1 on P(z = 2 | w)
predict(model, group = 2, type = "prob", newdata = newdata, me = "w1")
  # marginal effect of w1 and w2 on P(z = 3 | w)
predict(model, group   = 3,       type = "prob", 
               newdata = newdata, me   = c("w1", "w2"))
  # marginal effect of w2 on the linear predictor (index)
predict(model, group = 2, type = "li", newdata = newdata, me = "w2")
  # discrete marginal effect:
  # P(z = 2 | w1 = 0.5, w2) - P(z = 2 | w1 = 0.2, w2)
predict(model, group = 2,    type = "prob", newdata = newdata, 
               me    = "w2", eps  = c(0.2, 0.5))

# ---
# Step 4
# Ordered logit model
# ---

# Estimate ordered logit model with a unit variance
# that is just a matter of reparametrization i.e.,
# do not affect signs and significance of the coefficients
# and dot not affect at all the marginal effects
logit &lt;- msel(z ~ w1 + w2, data = data, marginal = list("logistic" = 0))
summary(logit)

# Compare ordered probit and ordered logit models
# using Akaike and Bayesian information criteria
  # AIC
c(probit = AIC(model), logit = AIC(logit))
  # BIC
c(probit = BIC(model), logit = BIC(logit))

# Estimate some probabilities and marginal effects
  # probability P(z = 1 | w)
predict(logit, group = 1, type = "prob", newdata = newdata)
  # marginal effect of w2 on P(z = 1 | w)
predict(logit, group = 1, type = "prob", newdata = newdata, me = "w2")

# ---
# Step 5
# Semiparametric ordered choice model with 
# Gallant and Nychka distribution
# ---

# Estimate semiparametric model
pgn &lt;- msel(z ~ w1 + w2, data = data, marginal = list("PGN" = 2))
summary(pgn)

# Estimate some probabilities and marginal effects
  # probability P(z = 3 | w)
predict(pgn, group = 3, type = "prob", newdata = newdata)
  # marginal effect of w2 on P(z = 3 | w)
predict(pgn, group = 3, type = "prob", newdata = newdata, me = "w2")

# Test the normality assumption via the likelihood ratio test
summary(lrtest_msel(model, pgn))

# Test the normality assumption via the Wald test
test_fn &lt;- function(object)
{
  marginal_par &lt;- coef(object, type = "marginal", eq = 1)
  return(marginal_par)
}
test_result &lt;- test_msel(object = pgn, test = "wald", fn = test_fn)
summary(test_result)

 

# ---------------------------------------
# Simulated data example 2
# Heteroscedastic ordered probit model
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
u &lt;- rnorm(n, mean = 0, sd = 1)

# Coefficients of the mean equation
gamma &lt;- c(-1, 2)

# Coefficients of the variance equation
gamma_het &lt;- c(0.5, -1)

# Linear predictor (index) of the mean equation
li &lt;- gamma[1] * w1 + gamma[2] * w2

# Linear predictor (index) of the variance equation
li_het &lt;- gamma_het[1] * w2 + gamma_het[2] * w3

# Heteroscedastic stdandard deviation
# i.e., value of the variance equation
sd_het &lt;- exp(li_het)

# Latent variable
z_star &lt;- li + u * sd_het

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordinal outcome
z                                           &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]]                         &lt;- 3
table(z)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, z = z)

# ---
# Step 2
# Estimation of the parameters
# ---

# Estimation
model &lt;- msel(z ~ w1 + w2 | w2 + w3,
                   data = data)
summary(model)

# Compare the estimates and true values of the parameters
  # regression coefficients of the mean equation
gamma_est &lt;- coef(model, type = "coef", eq = 1)
cbind(true = gamma, estimate = gamma_est)
  # regression coefficients of the variance equation
gamma_het_est &lt;- coef(model, type = "coef_var", eq = 1)
cbind(true = gamma_het, estimate = gamma_het_est)  
  # cuts
cuts_est &lt;- coef(model, type = "cuts", eq = 1)
cbind(true = cuts, estimate = cuts_est)   

# Likelihood-ratio test for the homoscedasticity
model0 &lt;- msel(z ~ w1 + w2, data = data)
summary(lrtest_msel(model, model0))

# Wald test for the homoscedasticity
test_fn &lt;- function(object)
{
  val &lt;- coef(object, type = "coef_var", eq = 1)
  return(val)
}
test_result &lt;- test_msel(model, test = "wald", fn = test_fn)
summary(test_result)

# ---
# Step 3
# Estimation of the probabilities and marginal effects
# ---

# Predict probability of the dependent variable
# equals to 2 for every observation in a sample
# P(z = 2 | w)
prob &lt;- predict(model, group = 2, type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on P(z = 1 | w)
mean(predict(model, group = 1, type = "prob", me = "w2"))

# Estimate conditional probabilities, linear predictors (indexes) and 
# heteroscedastic standard deviations for manually 
# provided observations.
  # new data
newdata &lt;- data.frame(z = c(1, 1), 
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8),
                      w3 = c(0.6, 0.1))
  # probability P(z = 2 | w)
predict(model, group = 2, type = "prob", newdata = newdata)
  # linear predictor (index)
predict(model, type = "li", newdata = newdata)
  # standard deviation
predict(model, type = "sd", newdata = newdata)
  # marginal effect of w3 on P(z = 3 | w)
predict(model, group = 3, type = "prob", newdata = newdata, me = "w3")
  # marginal effect of w2 on the standard error
predict(model, group = 2, type = "sd", newdata = newdata, me = "w2")
  # discrete marginal effect: 
  # P(Z = 2 | w1 = 0.5, w2) - P(Z = 2 | w1 = 0.2, w2)
predict(model, group = 2, type = "prob", newdata = newdata,
        me = "w2", eps = c(0.2, 0.5))



# ---------------------------------------
# Simulated data example 3
# Bivariate ordered probit model with 
# heteroscedastic second equation
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)

# Covariance matrix of random errors
rho &lt;- 0.5
sigma &lt;- matrix(c(1,   rho,
                  rho, 1), 
                nrow = 2)

# Random errors
u &lt;- mnorm::rmnorm(n = n, mean = c(0, 0), sigma = sigma)

# Coefficients
gamma1 &lt;- c(-1, 2)
gamma2 &lt;- c(1, 1.5)

# Coefficients of the variance equation
gamma2_het &lt;- c(0.5, -1)

# Linear predictors (indexes)
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w2 + gamma2[2] * w3

# Linear predictor (index) of the variance equation
li2_het &lt;- gamma2_het[1] * w2 + gamma2_het[2] * w4

# Heteroscedastic stdandard deviation
# i.e. value of variance equation
sd2_het &lt;- exp(li2_het)

# Latent variables
z1_star &lt;- li1 + u[, 1]
z2_star &lt;- li2 + u[, 2] * sd2_het

# Cuts
cuts1 &lt;- c(-1, 0.5, 2)
cuts2 &lt;- c(-2, 0)

# Observable ordinal outcome
  # first outcome
z1                                               &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[(z1_star &gt; cuts1[2]) &amp; (z1_star &lt;= cuts1[3])] &lt;- 2
z1[z1_star &gt; cuts1[3]]                           &lt;- 3
  # second outcome
z2                                               &lt;- rep(0, n)
z2[(z2_star &gt; cuts2[1]) &amp; (z2_star &lt;= cuts2[2])] &lt;- 1
z2[z2_star &gt; cuts2[2]]                           &lt;- 2
  # distribution
table(z1, z2)

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, 
                   w4 = w4, z1 = z1, z2 = z2)

# ---
# Step 2
# Estimation of the parameters
# ---

# Estimation
model &lt;- msel(list(z1 ~ w1 + w2,
                   z2 ~ w2 + w3 | w2 + w4),
              data = data)
summary(model)

# Compare the estimates and true values of parameters
  # regression coefficients of the first equation
gamma1_est &lt;- coef(model, type = "coef", eq = 1)
cbind(true = gamma1, estimate = gamma1_est)
  # regression coefficients of the second equation
gamma2_est &lt;- coef(model, type = "coef", eq = 2)
cbind(true = gamma2, estimate = gamma2_est)
  # cuts of the first equation
cuts1_est &lt;- coef(model, type = "cuts", eq = 1)
cbind(true = cuts1, estimate = cuts1_est)   
  # cuts of the second equation
cuts2_est &lt;- coef(model, type = "cuts", eq = 2)
cbind(true = cuts2, estimate = cuts2_est) 
  # correlation coefficients
rho_est &lt;- coef(model, type = "cov1", eq = c(1, 2))
cbind(true = rho, estimate = rho_est)  
  # regression coefficients of the variance equation
gamma2_het_est &lt;- coef(model, type = "coef_var", eq = 2)
cbind(true = gamma2_het, estimate = gamma2_het_est)

# ---
# Step 3
# Estimation of the probabilities and linear predictors (indexes)
# ---

# Predict probability P(z1 = 2, z2 = 0 | w)
prob &lt;- predict(model, group = c(2, 0), type = "prob")
head(prob)

# Calculate mean marginal effect of w2 on:
  # P(z1 = 1 | w)
mean(predict(model, group = c(1, -1), type = "prob", me = "w2"))
  # P(z1 = 1, z2 = 0 | w)
mean(predict(model, group = c(1, 0), type = "prob", me = "w2"))

# Calculate conditional probabilities and linear predictors (indexes)
# for the manually provided observations.
  # new data
newdata &lt;- data.frame(z1 = c(1, 1), 
                      z2 = c(1, 1),
                      w1 = c(0.5, 0.2), 
                      w2 = c(-0.3, 0.8),
                      w3 = c(0.6, 0.1),
                      w4 = c(0.3, -0.5))
  # probability P(z1 = 2, z2 = 0 | w)
predict(model, group = c(2, 0), type = "prob", newdata = newdata)
  # linear predictor (index)
predict(model, type = "li", newdata = newdata)  
  # marginal probability P(z2 = 1 | w)
predict(model, group = c(-1, 1), type = "prob", newdata = newdata) 
  # marginal probability P(z1 = 3 | w)
predict(model, group = c(3, -1), type = "prob", newdata = newdata)
  # conditional probability P(z1 = 2 | z2 = 0, w)
predict(model, group = c(2, 0), given_ind = 2,
        type = "prob", newdata = newdata) 
  # conditional probability P(z2 = 1 | z1 = 3, w)
predict(model, group = c(3, 1), given_ind = 1,
        type = "prob", newdata = newdata) 
  # marginal effect of w4 on P(Z2 = 2 | w)
predict(model, group = c(-1, 2),
        type = "prob", newdata = newdata, me = "w4")   
  # marginal effect of w4 on P(z1 = 3, Z2 = 2 | w)
predict(model, group = c(3, 2),
        type = "prob", newdata = newdata, me = "w4") 
  # marginal effect of w4 on P(z1 = 3 | z2 = 2, w)
predict(model, group = c(3, 2), given_ind = 2,
        type = "prob", newdata = newdata, me = "w4")         

# ---
# Step 4
# Replication under the non-random sample selection
# ---

# Suppose that z2 is unobservable when z1 = 1 or z1 = 3
z2[(z1 == 1) | (z1 == 3)] &lt;- -1
data$z2 &lt;- z2

# Replicate the estimation procedure
model &lt;- msel(list(z1 ~ w1 + w2,
                   z2 ~ w2 + w3 | w2 + w4),
              cov_type = "gop", data = data)
summary(model)

# Compare estimates and true values of the parameters
  # regression coefficients of the first equation
gamma1_est &lt;- coef(model, type = "coef", eq = 1)
cbind(true = gamma1, estimate = gamma1_est)
  # regression coefficients of the second equation
gamma2_est &lt;- coef(model, type = "coef", eq = 2)  
cbind(true = gamma2, estimate = gamma2_est)
  # cuts of the first equation
cuts1_est &lt;- coef(model, type = "cuts", eq = 1)  
cbind(true = cuts1, estimate = cuts1_est)   
  # cuts of the second equation
cuts2_est &lt;- coef(model, type = "cuts", eq = 2)  
cbind(true = cuts2, estimate = cuts2_est) 
  # correlation coefficient
rho_est &lt;- coef(model, type = "cov1", eq = c(1, 2))
cbind(true = rho, estimate = rho_est)  
  # regression coefficients of the variance equation
gamma2_het_est &lt;- coef(model, type = "coef_var", eq = 2)  
cbind(true = gamma2_het, estimate = gamma2_het_est)

# ---
# Step 5
# Semiparametric model with marginal logistic and PGN distributions
# ---

# Estimate the model
model &lt;- msel(list(z1 ~ w1 + w2,
                   z2 ~ w2 + w3 | w2 + w4),
              data = data, marginal = list(PGN = 3, logistic = NULL))
summary(model)



# ---------------------------------------
# Simulated data example 4
# Heckman model with ordinal 
# selection mechanism
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho    &lt;- 0.5
var.y  &lt;- 0.3
sd.y   &lt;- sqrt(var.y)
sigma  &lt;- matrix(c(1,          rho * sd.y,
                   rho * sd.y, var.y),
                 nrow = 2)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0), sigma = sigma)
u      &lt;- errors[, 1]
eps    &lt;- errors[, 2]

# Coefficients
gamma &lt;- c(-1, 2)
beta  &lt;- c(1, -1, 1)

# Linear predictor (index)
li   &lt;- gamma[1] * w1 + gamma[2] * w2
li.y &lt;- beta[1] + beta[2] * w1 + beta[3] * w3

# Latent variable
z_star &lt;- li + u
y_star &lt;- li.y + eps

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordered outcome
z                                           &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]]                         &lt;- 3
table(z)

# Observable continuous outcome such
# that outcome 'y' is observable only 
# when 'z &gt; 1' and unobservable otherwise
# i.e. when 'z &lt;= 1' we code 'y' as 'NA'
y         &lt;- y_star
y[z &lt;= 1] &lt;- NA

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, 
                   z = z, y = y)

# ---
# Step 2
# Estimation of parameters
# ---

# Estimation
model &lt;- msel(z ~ w1 + w2, y ~ w1 + w3, data = data)
summary(model)

# Compare estimates and true values of the parameters
  # regression coefficients of the ordinal equation
gamma_est &lt;- coef(model, type = "coef", eq = 1)
cbind(true = gamma, estimate = gamma_est)
  # cuts
cuts_est &lt;- coef(model, type = "cuts", eq = 1)
cbind(true = cuts, estimate = cuts_est)   
  # regression coefficients of the continuous equation
beta_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 0)
cbind(true = beta, estimate = beta_est)  
  # variance
var.y_est &lt;- coef(model, type = "var", eq2 = 1, regime = 0)
cbind(true = var.y, estimate = var.y_est)
  # covariance
cov_est &lt;- coef(model, type = "cov12", eq = 1, eq2 = 1)
cbind(true = rho * sd.y, estimate = cov_est)

# ---
# Step 3
# Estimation of the expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z = 1, 
                      y = 1,
                      w1 = 0.1, 
                      w2 = 0.2,
                      w3 = 0.3)

# Predict the unconditional expectation of the continuous outcome
# E(y | w)
predict(model, group = -1, group2 = 0, newdata = newdata)

# Predict the conditional expectations of the continuous outcome
  # E(y | z = 2, w)
predict(model, group = 2, group2 = 0, newdata = newdata)
  # E(y | z = 0, w)
predict(model, group = 0, group2 = 0, newdata = newdata)

# ---
# Step 4
# Classic Heckman's two-step estimation procedure
# ---

# Estimate the model by using the two-step estimator
model_ts &lt;- msel(z ~ w1 + w2, y ~ w1 + w3,
                 data = data, estimator = "2step")
summary(model_ts)

# Check the estimates accuracy
tbl &lt;- cbind(true    = beta, 
             ml      = model$coef2[[1]][1, ],
             twostep = model_ts$coef2[[1]][1, -4])  
print(tbl)

# ---
# Step 5
# Semiparametric estimation procedure
# ---

# Estimate the model using Lee's method 
# assuming logistic distribution of the
# random errors of the selection equation
model_Lee &lt;- msel(z ~ w1 + w2, 
                  y ~ w1 + w3,
                  data = data, estimator = "2step",
                  marginal = list(logistic = NULL))
summary(model_Lee)

# One step estimation is also available as well
# as more complex marginal distributions.
# Consider random errors in selection equation
# following PGN distribution with three parameters.
model_sp &lt;- msel(z ~ w1 + w2, 
                 y ~ w1 + w3,
                 data = data, marginal = list(PGN = 3))
summary(model_sp)

# To additionally relax normality assumption of
# random error of continuous equation it is possible
# to use Newey's two-step procedure.
model_Newey &lt;- msel(z ~ w1 + w2, 
                    y ~ w1 + w3,
                    data      = data,    marginal = list(logistic = 0),
                    estimator = "2step", degrees  = 2)
summary(model_Newey)



# ---------------------------------------
# Simulated data example 5
# Endogenous switching model with 
# heteroscedastic ordered selection 
# mechanism
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho_0    &lt;- -0.8
rho_1    &lt;- -0.7
var2_0   &lt;- 0.9
var2_1   &lt;- 1
sd_y_0   &lt;- sqrt(var2_0)
sd_y_1   &lt;- sqrt(var2_1)
cor_y_01 &lt;- 0.7
cov2_01  &lt;- sd_y_0 * sd_y_1 * cor_y_01
cov2_z_0 &lt;- rho_0 * sd_y_0
cov2_z_1 &lt;- rho_1 * sd_y_1
sigma    &lt;- matrix(c(1,        cov2_z_0, cov2_z_1,
                     cov2_z_0, var2_0,   cov2_01,
                     cov2_z_1, cov2_01,  var2_1),
                   nrow = 3)
errors   &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0), sigma = sigma)
u        &lt;- errors[, 1]
eps_0    &lt;- errors[, 2]
eps_1    &lt;- errors[, 3]

# Coefficients
gamma     &lt;- c(-1, 2)
gamma_het &lt;- c(0.5, -1)
beta_0    &lt;- c(1, -1, 1)
beta_1    &lt;- c(2, -1.5, 0.5)

# Linear predictor (index) of the ordinal equation
  # mean
li &lt;- gamma[1] * w1 + gamma[2] * w2
  # variance
li_het &lt;- gamma_het[1] * w2 + gamma_het[2] * w3

# Linear predictor (index) of the continuous equation
  # regime 0
li_y_0 &lt;- beta_0[1] + beta_0[2] * w1 + beta_0[3] * w3
  # regime 1
li_y_1 &lt;- beta_1[1] + beta_1[2] * w1 + beta_1[3] * w3

# Latent variable
z_star   &lt;- li + u * exp(li_het)
y_0_star &lt;- li_y_0 + eps_0
y_1_star &lt;- li_y_1 + eps_1

# Cuts
cuts &lt;- c(-1, 0.5, 2)

# Observable ordinal outcome
z                                           &lt;- rep(0, n)
z[(z_star &gt; cuts[1]) &amp; (z_star &lt;= cuts[2])] &lt;- 1
z[(z_star &gt; cuts[2]) &amp; (z_star &lt;= cuts[3])] &lt;- 2
z[z_star &gt; cuts[3]]                         &lt;- 3
table(z)

# Observable continuous outcome such that y' is 
# observable in regime 1 when 'z = 1', 
# observable in regime 0 when 'z &lt;= 1',
# unobservable           when 'z = 0'
y         &lt;- rep(NA, n)
y[z == 0] &lt;- NA
y[z == 1] &lt;- y_0_star[z == 1]
y[z &gt; 1]  &lt;- y_1_star[z &gt; 1]

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, 
                   z  = z,  y  = y)

# ---
# Step 2
# Estimation of the parameters
# ---

# Assign groups
groups &lt;- matrix(0:3, ncol = 1)
groups2 &lt;- matrix(c(-1, 0, 1, 1), ncol = 1)

# Estimation
model &lt;- msel(list(z ~ w1 + w2 | w2 + w3),
                   list(y ~ w1 + w3),
                   groups = groups, groups2 = groups2,
                   data = data)
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the ordinal equation
gamma_est     &lt;- coef(model, type = "coef",     eq = 1)
gamma_het_est &lt;- coef(model, type = "coef_var", eq = 1)
cbind(true = gamma,     estimate = gamma_est)
cbind(true = gamma_het, estimate = gamma_het_est)
  # cuts
cuts_est &lt;- coef(model, type = "cuts", eq = 1)
cbind(true = cuts, estimate = cuts_est)   
  # regression coefficients of the continuous equation
beta_0_test &lt;- coef(model, type = "coef2", eq2 = 1, regime = 0)
beta_1_test &lt;- coef(model, type = "coef2", eq2 = 1, regime = 1)
cbind(true = beta_0, estimate = beta_0_test) 
cbind(true = beta_1, estimate = beta_1_test)
  # variances
var2_0_est &lt;- coef(model, type = "var", eq2 = 1, regime = 0)
var2_1_est &lt;- coef(model, type = "var", eq2 = 1, regime = 1)
cbind(true = c(var2_0, var2_1), estimate = c(var2_0_est, var2_1_est)) 
  # covariances between the random errors
cov2_z_0_est &lt;- coef(model, type = "cov12", eq = 1, eq2 = 1, regime = 0)
cov2_z_1_est &lt;- coef(model, type = "cov12", eq = 1, eq2 = 1, regime = 1)
cbind(true     = c(cov2_z_0,     cov2_z_1), 
      estimate = c(cov2_z_0_est, cov2_z_1_est))

# ---
# Step 3
# Estimation of the expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z  = 1,   y  = 1,
                      w1 = 0.1, w2 = 0.2, w3 = 0.3)

# Predict the unconditional expectation of the 
# continuous outcome E(yr | w)
  # regime 0 
predict(model, group = -1, group2 = 0, newdata = newdata)
  # regime 1
predict(model, group = -1, group2 = 1, newdata = newdata)

# Predict the conditional expectations of the continuous outcome
# given condition 'z == 0' for regime 1 i.e., E(y1 | z = 0, w)
predict(model, group = 0, group2 = 1, newdata = newdata)



# ---------------------------------------
# Simulated data example 6
# Endogenous switching model with 
# multivariate heteroscedastic ordered 
# selection mechanism
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
rho_z1_z2 &lt;- 0.5
rho_y0_z1 &lt;- 0.6
rho_y0_z2 &lt;- 0.7
rho_y1_z1 &lt;- 0.65
rho_y1_z2 &lt;- 0.75
var20     &lt;- 0.9
var21     &lt;- 1
sd_y0     &lt;- sqrt(var20)
sd_y1     &lt;- sqrt(var21)
cor_y01   &lt;- 0.7
cov201    &lt;- sd_y0 * sd_y1 * cor_y01
cov20_z1  &lt;- rho_y0_z1 * sd_y0
cov21_z1  &lt;- rho_y1_z1 * sd_y1
cov20_z2  &lt;- rho_y0_z2 * sd_y0
cov21_z2  &lt;- rho_y1_z2 * sd_y1
sigma     &lt;- matrix(c(1,         rho_z1_z2,  cov20_z1,  cov21_z1, 
                      rho_z1_z2, 1,          cov20_z2,  cov21_z2,
                      cov20_z1,  cov20_z2,   var20,     cov201,
                      cov21_z1,  cov21_z2,   cov201,    var21),
                    nrow = 4)
errors    &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0, 0), sigma = sigma)
u1        &lt;- errors[, 1]
u2        &lt;- errors[, 2]
eps0      &lt;- errors[, 3]
eps1      &lt;- errors[, 4]

# Coefficients
gamma1     &lt;- c(-1, 2)
gamma1_het &lt;- c(0.5, -1)
gamma2     &lt;- c(1, 1)
beta0      &lt;- c(1, -1, 1, -1.2)
beta1      &lt;- c(2, -1.5, 0.5, 1.2)

# Linear index (predictor) of the ordinal equation
  # mean
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w1 + gamma2[2] * w3
  # variance
li1_het &lt;- gamma1_het[1] * w2 + gamma1_het[2] * w3

# Linear predictor (index) of the continuous equation
  # regime 0
li_y0 &lt;- beta0[1] + beta0[2] * w1 + beta0[3] * w3 + beta0[4] * w4
  # regime 1
li_y1 &lt;- beta1[1] + beta1[2] * w1 + beta1[3] * w3 + beta1[4] * w4

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0
y1_star &lt;- li_y1 + eps1

# Cuts
cuts1 &lt;- c(-1, 1)
cuts2 &lt;- c(0)

# Observable ordered outcome
  # first
z1                                               &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[z1_star &gt; cuts1[2]]                           &lt;- 2
  # second
z2                     &lt;- rep(0, n)
z2[z2_star &gt; cuts2[1]] &lt;- 1
table(z1, z2)

# Observable continuous outcome such
# that outcome 'y' is 
# in regime 0  when 'z1 == 1', 
# in regime 1  when 'z1 == 0' or 'z1 == 2',
# unobservable when 'z2 == 0'
y          &lt;- rep(NA, n)
y[z1 == 1] &lt;- y0_star[z1 == 1]
y[z1 != 1] &lt;- y1_star[z1 != 1]
y[z2 == 0] &lt;- NA

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, w4 = w4,
                   z1 = z1, z2 = z2, y  = y)

# ---
# Step 2
# Estimation of the parameters
# ---

# Assign groups
groups &lt;- matrix(c(0, 0,
                   0, 1,
                   1, 0,
                   1, 1,
                   2, 0,
                   2, 1), 
                 byrow = TRUE, ncol = 2)
groups2 &lt;- matrix(c(-1, 1, -1, 0, -1, 1), ncol = 1)

# Estimation
model &lt;- msel(list(z1 ~ w1 + w2 | w2 + w3,
                   z2 ~ w1 + w3),
              y ~ w1 + w3 + w4,
              groups = groups, groups2 = groups2,
              data   = data)
summary(model)

# Compare estimates and true values of the parameters
  # regression coefficients of the first ordered equation
gamma1_est      &lt;- coef(model, type = "coef",     eq = 1)
gamma1__het_est &lt;- coef(model, type = "coef_var", eq = 1)
cbind(true = gamma1,     estimate = gamma1_est)
cbind(true = gamma1_het, estimate = gamma1__het_est)
  # regression coefficients of the second ordered equation
gamma2_est &lt;- coef(model, type = "coef", eq = 2)
cbind(true = gamma2, estimate = gamma2_est)
  # cuts
cuts1_est &lt;- coef(model, type = "cuts", eq = 1)
cuts2_est &lt;- coef(model, type = "cuts", eq = 2)
cbind(true = cuts1, estimate = cuts1_est)   
cbind(true = cuts2, estimate = cuts2_est)  
  # regression coefficients of the continuous equation
beta0_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 0)
beta1_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 1)
cbind(true = beta0, estimate = beta0_est) 
cbind(true = beta1, estimate = beta1_est)
  # variances
var20_est &lt;- coef(model, type = "var", eq2 = 1, regime = 0)
var21_est &lt;- coef(model, type = "var", eq2 = 1, regime = 1)
cbind(true = c(var20, var21), estimate = c(var20_est, var21_est)) 
  # covariances
cov_y0_z1_est &lt;- coef(model, type = "cov12", eq = 1, eq2 = 1, regime = 0)
cov_y0_z2_est &lt;- coef(model, type = "cov12", eq = 2, eq2 = 1, regime = 0)
cov_y1_z1_est &lt;- coef(model, type = "cov12", eq = 1, eq2 = 1, regime = 1)
cov_y1_z2_est &lt;- coef(model, type = "cov12", eq = 2, eq2 = 1, regime = 1)
cbind(true     = c(cov20_z1, cov20_z2), 
      estimate = c(cov_y0_z1_est, cov_y0_z2_est))
cbind(true     = c(cov21_z1, cov21_z2), 
      estimate = c(cov_y1_z1_est,  cov_y1_z2_est))

# ---
# Step 3
# Estimation of the expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z1 = 1,   z2 = 1,   y  = 1,
                      w1 = 0.1, w2 = 0.2, w3 = 0.3, w4 = 0.4)

# Predict the unconditional expectation of the continuous outcome
  # regime 0 
predict(model, group = c(-1, -1), group2 = 0, newdata = newdata)
  # regime 1
predict(model, group = c(-1, -1), group2 = 1, newdata = newdata)

# Predict the conditional expectations of the continuous outcome
# E(y1 | z1 = 2, z2 = 1, w)
predict(model, group = c(2, 1), group2 = 1, newdata = newdata)

# Marginal effect of w3 on E(y1 | z1 = 2, z2 = 1, w)
predict(model, group = c(2, 1), group2 = 1, newdata = newdata, me = "w3")

# ---
# Step 4
# Two-step estimation procedure
# ---

# For a comparison reasons let's estimate the model
# via the least squares
model.ls.0 &lt;- lm(y ~ w1 + w3 + w4,
                 data = data[!is.na(data$y) &amp; (data$z1 == 1), ])
model.ls.1 &lt;- lm(y ~ w1 + w3 + w4,
                 data = data[!is.na(data$y) &amp; (data$z1 != 1), ])


# Apply the two-step procedure
model_ts &lt;-  msel(list(z1 ~ w1 + w2 | w2 + w3,
                       z2 ~ w1 + w3),
                  y ~ w1 + w3 + w4,
                  groups    = groups,  groups2 = groups2,
                  estimator = "2step", data    = data)
summary(model_ts)

# Use the two-step procedure with logistic marginal distributions
# that is multivariate generalization of the Lee's method
model_Lee &lt;-  msel(list(z1 ~ w1 + w2 | w2 + w3,
                        z2 ~ w1 + w3),
                   y ~ w1 + w3 + w4,
                   marginal = list(logistic = NULL, logistic = NULL),
                   groups    = groups,  groups2 = groups2,
                   estimator = "2step", data    = data)
                        
# Apply the Newey's method
model_Newey &lt;-  msel(list(z1 ~ w1 + w2 | w2 + w3,
                          z2 ~ w1 + w3),
                     y ~ w1 + w3 + w4,
                     marginal = list(logistic = NULL, logistic = NULL),
                     degrees = c(2, 3), groups = groups, groups2 = groups2,
                     estimator = "2step", data = data)

# Compare accuracy of the methods
  # beta0
tbl0 &lt;- cbind(true    = beta0, 
              ls      = coef(model.ls.0),
              ml      = model$coef2[[1]][1, 1:length(beta0)],
              twostep = model_ts$coef2[[1]][1, 1:length(beta0)],
              Lee     = model_Lee$coef2[[1]][1, 1:length(beta0)],
              Newey   = model_Newey$coef2[[1]][1, 1:length(beta0)])  
print(tbl0)
  # beta1
tbl1 &lt;- cbind(true    = beta1, 
              ls      = coef(model.ls.1),
              ml      = model$coef2[[1]][2, 1:length(beta1)],
              twostep = model_ts$coef2[[1]][2, 1:length(beta1)],
              Lee     = model_Lee$coef2[[1]][2, 1:length(beta1)],
              Newey   = model_Newey$coef2[[1]][2, 1:length(beta1)])  
print(tbl1)



# ---------------------------------------
# Simulated data example 7
# Endogenous multivariate switching model 
# with multivariate heteroscedastic
# ordered selection mechanism
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 1000

# Regressors (covariates)
w1 &lt;- runif(n = n, min = -1, max = 1)
w2 &lt;- runif(n = n, min = -1, max = 1)
w3 &lt;- runif(n = n, min = -1, max = 1)
w4 &lt;- runif(n = n, min = -1, max = 1)
w5 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
var_y0 &lt;- 0.9
var_y1 &lt;- 1
var_g0 &lt;- 1.1
var_g1 &lt;- 1.2
var_g2 &lt;- 1.3
A      &lt;- rWishart(1, 7, diag(7))[, , 1]
B      &lt;- diag(sqrt(c(1, 1, var_y0, var_y1, 
                      var_g0, var_g1, var_g2)))
sigma  &lt;-  B  %*% cov2cor(A) %*% B
errors &lt;- mnorm::rmnorm(n = n, mean = rep(0, nrow(sigma)), sigma = sigma)
u1     &lt;- errors[, 1]
u2     &lt;- errors[, 2]
eps0_y &lt;- errors[, 3]
eps1_y &lt;- errors[, 4]
eps0_g &lt;- errors[, 5]
eps1_g &lt;- errors[, 6]
eps2_g &lt;- errors[, 7]

# Coefficients
gamma1     &lt;- c(-1, 2)
gamma1_het &lt;- c(0.5, -1)
gamma2     &lt;- c(1, 1)
beta0_y    &lt;- c(1, -1, 1, -1.2)
beta1_y    &lt;- c(2, -1.5, 0.5, 1.2)
beta0_g    &lt;- c(-1, 1, 1, 1)
beta1_g    &lt;- c(1, -1, 1, 1)
beta2_g    &lt;- c(1, 1, -1, 1)

# Linear predictor (index) of the ordinal equation
  # mean
li1 &lt;- gamma1[1] * w1 + gamma1[2] * w2
li2 &lt;- gamma2[1] * w1 + gamma2[2] * w3
  # variance
li1_het &lt;- gamma1_het[1] * w2 + gamma1_het[2] * w3

# Linear predictor (index) of the first continuous equation
  # regime 0
li_y0 &lt;- beta0_y[1] + beta0_y[2] * w1 + beta0_y[3] * w3 + beta0_y[4] * w4
  # regime 1
li_y1 &lt;- beta1_y[1] + beta1_y[2] * w1 + beta1_y[3] * w3 + beta1_y[4] * w4

# Linear predictor (index) of the second continuous equation
  # regime 0
li_g0 &lt;- beta0_g[1] + beta0_g[2] * w2 + beta0_g[3] * w3 + beta0_g[4] * w5
  # regime 1
li_g1 &lt;- beta1_g[1] + beta1_g[2] * w2 + beta1_g[3] * w3 + beta1_g[4] * w5
  # regime 2
li_g2 &lt;- beta2_g[1] + beta2_g[2] * w2 + beta2_g[3] * w3 + beta2_g[4] * w5

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0_y
y1_star &lt;- li_y1 + eps1_y
g0_star &lt;- li_g0 + eps0_g
g1_star &lt;- li_g1 + eps1_g
g2_star &lt;- li_g2 + eps2_g

# Cuts
cuts1 &lt;- c(-1, 1)
cuts2 &lt;- c(0)

# Observable ordered outcome
  # first
z1                                               &lt;- rep(0, n)
z1[(z1_star &gt; cuts1[1]) &amp; (z1_star &lt;= cuts1[2])] &lt;- 1
z1[z1_star &gt; cuts1[2]]                           &lt;- 2
  # second
z2                     &lt;- rep(0, n)
z2[z2_star &gt; cuts2[1]] &lt;- 1
table(z1, z2)

# Observable continuous outcome such that outcome 'y' is 
# in regime 0  when 'z1 == 1', 
# in regime 1  when 'z1 == 0' or 'z1 == 2',
# unobservable when 'z2 == 0'
y          &lt;- rep(NA, n)
y[z1 == 1] &lt;- y0_star[z1 == 1]
y[z1 != 1] &lt;- y1_star[z1 != 1]
y[z2 == 0] &lt;- NA

#' # Observable continuous outcome such
# that outcome 'g' is 
# in regime 0 when 'z1 == z2', 
# in regime 1 when 'z1 &gt; z2',
# in regime 2 when 'z1 &lt; z2',
g           &lt;- rep(NA, n)
g[z1 == z2] &lt;- g0_star[z1 == z2]
g[z1 &gt; z2]  &lt;- g1_star[z1 &gt; z2]
g[z1 &lt; z2]  &lt;- g2_star[z1 &lt; z2]

# Data
data &lt;- data.frame(w1 = w1, w2 = w2, w3 = w3, w4 = w4, w5 = w5,
                   z1 = z1, z2 = z2, y  = y,  g  = g)

# ---
# Step 2
# Estimation of the parameters
# ---

# Assign groups
groups &lt;- matrix(c(0, 0,
                   0, 1,
                   1, 0,
                   1, 1,
                   2, 0,
                   2, 1), 
                 byrow = TRUE, ncol = 2)

# Assign groups 2
  # prepare the matrix
groups2 &lt;- matrix(NA, nrow = nrow(groups), ncol = 2)
  # fill the matrix
groups2[groups[, 1] == 1, 1]                        &lt;- 0
groups2[(groups[, 1] == 0) | (groups[, 1] == 2), 1] &lt;- 1
groups2[groups[, 2] == 0, 1]                        &lt;- -1
groups2[groups[, 1] == groups[, 2], 2]              &lt;- 0
groups2[groups[, 1] &gt; groups[, 2], 2]               &lt;- 1
groups2[groups[, 1] &lt; groups[, 2], 2]               &lt;- 2

# The structure of the model
cbind(groups, groups2)

# Estimation
model &lt;- msel(list(z1 ~ w1 + w2 | w2 + w3, z2 ~ w1 + w3),
              list(y ~ w1 + w3 + w4, g ~ w2 + w3 + w5),
              groups = groups, groups2 = groups2, data = data)
summary(model)

# Compare estimates and true values of the parameters
  # regression coefficients of the first ordered equation
gamma1_est     &lt;- coef(model, type = "coef", eq = 1)
gamma1_het_est &lt;- coef(model, type = "coef_var", eq = 1)
cbind(true = gamma1,     estimate = gamma1_est)
cbind(true = gamma1_het, estimate = gamma1_het_est)
  # regression coefficients of the second ordered equation
gamma2_est &lt;- coef(model, type = "coef", eq = 2)
cbind(true = gamma2, estimate = gamma2_est)
  # cuts
cuts1_est &lt;- coef(model, type = "cuts", eq = 1)
cuts2_est &lt;- coef(model, type = "cuts", eq = 2)
cbind(true = cuts1, estimate = cuts1_est)   
cbind(true = cuts2, estimate = cuts2_est)  
  # regression coefficients of the first continuous equation
beta0_y_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 0)
beta1_y_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 1)
cbind(true = beta0_y, estimate = beta0_y_est) 
cbind(true = beta1_y, estimate = beta1_y_est)
  # regression coefficients of the second continuous equation
beta0_g_est &lt;- coef(model, type = "coef2", eq2 = 2, regime = 0)
beta1_g_est &lt;- coef(model, type = "coef2", eq2 = 2, regime = 1)
beta2_g_est &lt;- coef(model, type = "coef2", eq2 = 2, regime = 2)
cbind(true = beta0_g, estimate = beta0_g_est) 
cbind(true = beta1_g, estimate = beta1_g_est)
cbind(true = beta2_g, estimate = beta2_g_est)
  # variances of the first continuous equation
var_y0_est &lt;- coef(model, type = "var", eq2 = 1, regime = 0)
var_y1_est &lt;- coef(model, type = "var", eq2 = 1, regime = 1)
cbind(true = c(var_y0, var_y1), estimate = c(var_y0_est, var_y1_est)) 
  # variances of the second continuous equation
var_g0_est &lt;- coef(model, type = "var", eq2 = 2, regime = 0)
var_g1_est &lt;- coef(model, type = "var", eq2 = 2, regime = 1)
var_g2_est &lt;- coef(model, type = "var", eq2 = 2, regime = 2)
cbind(true     = c(var_g0, var_g1, var_g2), 
      estimate = c(var_g0_est, var_g1_est, var_g2_est)) 
  # correlation between the ordinal equations
sigma12_est &lt;- coef(model, type = "cov1", eq = c(1, 2))
cbind(true = c(sigma[1, 2]), estimate = sigma12_est)
  # covariances between the continuous and ordinal equations
cbind(true = sigma[1:2, 3], estimate = model$cov2[[1]][1, ])
cbind(true = sigma[1:2, 4], estimate = model$cov2[[1]][2, ])
cbind(true = sigma[1:2, 5], estimate = model$cov2[[2]][1, ])
cbind(true = sigma[1:2, 6], estimate = model$cov2[[2]][2, ])
cbind(true = sigma[1:2, 7], estimate = model$cov2[[2]][3, ])
  # covariances between the continuous equations
sigma2_est &lt;- coef(model, type = "cov2")[[1]]
cbind(true     = c(sigma[4, 7], sigma[3, 5], sigma[4, 6]), 
      estimate = sigma2_est) 
      
# ---
# Step 3
# Estimation of the expectations and marginal effects
# ---

# New data
newdata &lt;- data.frame(z1 = 1,   z2 = 1,   y  = 1,   g  = 1,
                      w1 = 0.1, w2 = 0.2, w3 = 0.3, w4 = 0.4, w5 = 0.5)

# Predict unconditional expectation of the dependent variable
  # regime 0 for 'y' and regime 1 for 'g' i.e. E(y0 | w), E(g1 | w)
predict(model, group = c(-1, -1), group2 = c(0, 1), newdata = newdata)

# Predict conditional expectations of the dependent variable
# E(y0 | z1 = 2, z2 = 1, w), E(g1 | z1 = 2, z2 = 1, w)
predict(model, group = c(2, 1), group2 = c(0, 1), newdata = newdata)

# Marginal effect of w3 on 
# E(y1 | z1 = 2, z2 = 1, w) and E(g1 | z1 = 2, z2 = 1, w)
predict(model, group   = c(2, 1), group2 = c(0, 1), 
               newdata = newdata, me     = "w3")

# ---
# Step 4
# Two-step estimation procedure
# ---

# Provide manually selectivity terms
model2 &lt;- msel(list(z1 ~ w1 + w2 | w2 + w3, z2 ~ w1 + w3),
               list(y ~ w1 + w3 + w4 + 
                        lambda1 + lambda2 + I(lambda1 * lambda2), 
                    g ~ w2 + w3 + w5 + lambda1 + lambda2),
               groups = groups, groups2   = groups2,
               data   = data,   estimator = "2step")
summary(model2)



# ---------------------------------------
# Simulated data example 8
# Multinomial endogenous switching and 
# selection model (probit)
# ---------------------------------------

# Load required package
library("mnorm")

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 10000

# Random errors
  # variances and correlations
sd.z2    &lt;- sqrt(0.9)
cor.z    &lt;- 0.3
sd.y0    &lt;- sqrt(2)
cor.z1y0 &lt;- 0.4
cor.z2y0 &lt;- 0.7
sd.y1    &lt;- sqrt(1.8)
cor.z1y1 &lt;- 0.3
cor.z2y1 &lt;- 0.6
cor.y    &lt;- 0.8
  # the covariance matrix
sigma &lt;- matrix(c(
1,                cor.z * sd.z2,            cor.z1y0 * sd.y0,         cor.z1y1 * sd.y1,
cor.z * sd.z2,    sd.z2 ^ 2,                cor.z2y0 * sd.z2 * sd.y0, cor.z2y1 * sd.z2 * sd.y1,
cor.z1y0 * sd.y0, cor.z2y0 * sd.z2 * sd.y0, sd.y0 ^ 2,                cor.y * sd.y0 * sd.y1,
cor.z1y1 * sd.y1, cor.z2y1 * sd.z2 * sd.y1, cor.y * sd.y0 * sd.y1,    sd.y1 ^ 2),
                ncol = 4, byrow = TRUE)
colnames(sigma) &lt;- c("z1", "z2", "y0", "y1")
rownames(sigma) &lt;- colnames(sigma)

# Simulate the random errors
errors &lt;- rmnorm(n, c(0, 0, 0, 0), sigma)
u      &lt;- errors[, 1:2]
eps    &lt;- errors[, 3:4]

# Regressors (covariates)
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
x3 &lt;- (x2 + runif(n, -1, 1)) / 2
W  &lt;- cbind(1, x1, x2)
X  &lt;- cbind(1, x1, x3)

# Coefficients
gamma0 &lt;- c(0.1,    1,   1)
gamma1 &lt;- c(0.2, -1.2, 0.8)
beta0  &lt;- c(1,     -3,   4) 
beta1  &lt;- c(1,      4,  -3)

# Linear predictors (indexes)
z1.li &lt;- W %*% gamma0
z2.li &lt;- W %*% gamma1
y0.li &lt;- X %*% beta0
y1.li &lt;- X %*% beta1

# Latent variables
z1.star &lt;- z1.li + u[, 1]
z2.star &lt;- z2.li + u[, 2]
y0.star &lt;- y0.li + eps[, 1]
y1.star &lt;- y1.li + eps[, 2]

# Obvservable variable as a dummy
z1 &lt;- (z1.star &gt; z2.star) &amp; (z1.star &gt; 0)
z2 &lt;- (z2.star &gt; z1.star) &amp; (z2.star &gt; 0)
z3 &lt;- (z1 != 1) &amp; (z2 != 1)

# Observable multinomial variable
z     &lt;- rep(0, n)
z[z1] &lt;- 0
z[z2] &lt;- 1
z[z3] &lt;- 2
table(z)

# Make unobservable values of the continuous outcome
y         &lt;-  rep(NA, n)
y[z == 1] &lt;- y0.star[z == 1]
y[z == 2] &lt;- y1.star[z == 2]

# Data
data &lt;- data.frame(z = z, y = y, x1 = x1, x2 = x2, x3 = x3)
            
# ---
# Step 2
# Estimation of the parameters
# ---

# Define the groups
groups3 &lt;- c(0, 1, 2)
groups2 &lt;- matrix(c(-1, 0, 1), ncol = 1)

# Two-step method
model &lt;- msel(formula3  = z ~ x1 + x2, formula2 = y ~ x1 + x3, 
              groups3   = groups3,     groups2   = groups2,
              data      = data,        estimator = "2step",
              type3     = "probit")
summary(model)

# Compare estimates and true values of parameters
  # regression coefficients of the continuous equation
beta0_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 0)
beta1_est &lt;- coef(model, type = "coef2", eq2 = 1, regime = 1)
cbind(true = beta0, est = beta0_est[1:length(beta0)])
cbind(true = beta1, est = beta1_est[1:length(beta1)])
  # regression coefficients of the multinomial equations
gamma0_est &lt;- coef(model, type = "coef3", eq3 = 0)
gamma1_est &lt;- coef(model, type = "coef3", eq3 = 1)
cbind(true = gamma0, est = gamma0_est)
cbind(true = gamma1, est = gamma1_est)
  # compare the covariances between
  # z1 and z2
cbind(true = cor.z * sd.z2, 
      est  = coef(model, type = "cov3", eq3 = c(0, 1)))
  # z1 and y0
cbind(true = cor.z1y0 * sd.y0, 
      est  = beta0_est["lambda1_mn"]) 
  # z2 and y0
cbind(true = cor.z2y0 * sd.y0, 
      est  = beta0_est["lambda2_mn"])   
  # z1 and y1
cbind(true = cor.z1y1 * sd.y1, 
      est  = beta1_est["lambda1_mn"]) 
  # z2 and y1
cbind(true = cor.z2y1 * sd.y1, 
      est  = beta1_est["lambda2_mn"]) 
            
# ---
# Step 3
# Predictions and marginal effects
# ---  

# Unconditional expectation E(y1 | w) for every observation in a sample
predict(model, type = "val", group2 = 1, group3 = -1)

# Marginal effect of x1 on conditional expectation E(y0 | z = 1, w) 
# for every observation in a sample
predict(model, type = "val", group2 = 0, group3 = 1, me = "x1")    

# Calculate predictions and marginal effects
# for manually provided observations
# using aforementioned models.
newdata &lt;- data.frame(z  = c(1, 1), 
                      y  = c(1, 1), 
                      x1 = c(0.5, 0.2), 
                      x2 = c(-0.3, 0.8),
                      x3 = c(0.6, -0.7))
                      
# Unconditional expectation E(y0 | w)
predict(model, type = "val", group2 = 0, group3 = -1, newdata = newdata)

# Conditional expectation E(y1 | z=2, w)
predict(model, type = "val", group2 = 1, group3 = 2, newdata = newdata)

# Marginal effect of x2 on E(y0 | z = 1, w)
predict(model, type = "val", group2  = 0, group3 = 1, 
               me   = "x2",  newdata = newdata)
  
# ---
# Step 4
# Multinomial logit selection
# ---                
        
# Two-step method
model2 &lt;- msel(formula3  = z ~ x1 + x2, formula2 = y ~ x1 + x3, 
               groups3   = groups3,     groups2   = groups2,
               data      = data,        estimator = "2step",
               type3     = "logit")
summary(model2)    

# Compare the estimates
beta0_est2 &lt;- coef(model2, type = "coef2", eq2 = 1, regime = 0)[]
beta1_est2 &lt;- coef(model2, type = "coef2", eq2 = 1, regime = 1)

# beta0 coefficients
cbind(true = beta0, probit = beta0_est[1:3], logit = beta0_est2[1:3])
   
# beta1 coefficients
cbind(true = beta1, probit = beta1_est[1:3], logit = beta1_est2[1:3])            

             

# ---------------------------------------
# Simulated data example 9
# Multinomial endogenous switching and 
# selection model (logit)
# ---------------------------------------

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# The number of observations
n &lt;- 10000

# Random errors
u      &lt;- matrix(-log(-log(runif(n * 3))), nrow = n, ncol = 3)
tau0   &lt;- matrix(c(0.6, -0.4, 0.3), ncol = 1)
tau1   &lt;- matrix(c(-0.3, 0.5, 0.2), ncol = 1)
eps0   &lt;- (u - 0.57721656649) %*% tau0 + rnorm(n)
eps1   &lt;- (u - 0.57721656649) %*% tau1 + rnorm(n)

# Regressors (covariates)
x1 &lt;- runif(n = n, min = -1, max = 1)
x2 &lt;- runif(n = n, min = -1, max = 1)
x3 &lt;- runif(n = n, min = -1, max = 1)

# Coefficients
gamma.0 &lt;- c(0.2, -2,  2)
gamma.1 &lt;- c(0.1,  2, -2)
beta.0  &lt;- c(2,    2,  2)
beta.1  &lt;- c(1,   -2,  2)

# Linear predictors (indexes)
z0.li &lt;- gamma.0[1] + gamma.0[2] * x1 + gamma.0[3] * x2
z1.li &lt;- gamma.1[1] + gamma.1[2] * x1 + gamma.1[3] * x2

# Latent variables
z0.star &lt;- z0.li + u[, 1]
z1.star &lt;- z1.li + u[, 2]
z2.star &lt;- u[, 3]
y0.star &lt;- beta.0[1] + beta.0[2] * x1 + beta.0[3] * x3 + eps0
y1.star &lt;- beta.1[1] + beta.1[2] * x1 + beta.1[3] * x3 + eps1

# Observable multinomial variable
z                                            &lt;- rep(2, n)
z[(z0.star &gt; z1.star) &amp; (z0.star &gt; z2.star)] &lt;- 0
z[(z1.star &gt; z0.star) &amp; (z1.star &gt; z2.star)] &lt;- 1
table(z)

# Unobservable values of the continuous outcome
y         &lt;- rep(NA, n)
y[z == 0] &lt;- y0.star[z == 0]
y[z == 1] &lt;- y1.star[z == 1]

# Data
data &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, z = z, y = y)
            
# ---
# Step 2
# Estimation of the parameters
# ---

# Define the groups
groups3 &lt;- c(0, 1, 2)
groups2 &lt;- c(0, 1, -1)

# Two-step estimator of Dubin-McFadden
model &lt;- msel(formula3  = z ~ x1 + x2, formula2 = y ~ x1 + x3, 
              groups3   = groups3,     groups2   = groups2,
              data      = data,        estimator = "2step",
              type3     = "logit")
summary(model)

# Least squaes estimates (benchmark)
lm0 &lt;- lm(y ~ x1 + x3, data = data[data$z == 0, ])
lm1 &lt;- lm(y ~ x1 + x3, data = data[data$z == 1, ])


# Compare the estimates of beta0
cbind(true = beta.0,
      DMF  = coef(model, type = "coef2", eq2 = 1, regime = 0),
      LS   = coef(lm0))
      
# Compare the estimates of beta1
cbind(true = beta.1,
      DMF  = coef(model, type = "coef2", eq2 = 1, regime = 1),
      LS   = coef(lm1))

             
</code></pre>

<hr>
<h2 id='nobs.msel'>Extract the Number of Observations from a Fit of the msel Function.</h2><span id='topic+nobs.msel'></span>

<h3>Description</h3>

<p>Extract the number of observations from a model fit
of the <code><a href="#topic+msel">msel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.msel_+3A_object">object</code></td>
<td>
<p>object of class &quot;msel&quot;</p>
</td></tr>
<tr><td><code id="nobs.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unobservable values of continuous equations are included into
the number of observations.
</p>


<h3>Value</h3>

<p>A single positive integer number.
</p>

<hr>
<h2 id='predict.msel'>Predict method for msel function</h2><span id='topic+predict.msel'></span>

<h3>Description</h3>

<p>Predicted values based on the object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
predict(
  object,
  ...,
  newdata = NULL,
  given_ind = numeric(),
  group = NA,
  group2 = NA,
  group3 = NA,
  type = ifelse(any(is.na(group2)), "prob", "val"),
  me = NULL,
  eps = NULL,
  control = list(),
  test = FALSE,
  exogenous = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.msel_+3A_object">object</code></td>
<td>
<p>an object of class &quot;msel&quot;.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables 
with which to predict. If omitted, the original data frame used.
This data frame should contain values of dependent variables even if
they are not actually needed for prediction 
(simply assign them with 0 values).</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_given_ind">given_ind</code></td>
<td>
<p>a numeric vector of indexes of conditioned components.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_group">group</code></td>
<td>
<p>a numeric vector which i-th element represents a value of the
i-th dependent variable. If this value equals -1 then this component
will be ignored (useful for estimation of marginal probabilities).</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_group2">group2</code></td>
<td>
<p>a numeric vector which i-th element represents a value of the
i-th dependent variable of the continuous equation. 
If this value equals -1 then this component will be ignored.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_group3">group3</code></td>
<td>
<p>an integer representing the index of the alternative of the
multinomial equation. If this value equals -1 then this component will be 
ignored.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_type">type</code></td>
<td>
<p>a string representing a type of the prediction.
See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_me">me</code></td>
<td>
<p>a string representing the name of the variable for which marginal
effect should be estimated. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_eps">eps</code></td>
<td>
<p>a numeric vector of length 1 or 2 used for calculation of
the marginal effects. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_control">control</code></td>
<td>
<p>a list of additional arguments. Currently is not intended
for the users.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_test">test</code></td>
<td>
<p>a logical, function or integer. If <code>test = TRUE</code> then the 
output of the function is supplied to 
<code><a href="#topic+test_msel">test_msel</a></code> before return to perform a t-test.
If <code>test</code> is a function it will be applied to the output of the 
<code>predict</code> before <code><a href="#topic+test_msel">test_msel</a></code> is called.
If <code>test</code> is an integer then <code><a href="#topic+test_msel">test_msel</a></code>
will be applied only to the <code>test</code>-th column of the output.</p>
</td></tr>
<tr><td><code id="predict.msel_+3A_exogenous">exogenous</code></td>
<td>
<p>a list such that <code>exogenous[[i]]</code> represents the value 
(or a vector of values of the same size as <code>nrow(newdata)</code>) which will 
be exogenously assigned to the variable <code>names(exogenous)[[i]]</code> in 
<code>newdata</code> i.e., <code>newdata[, names(exogenous)[i]] &lt;- exogenous[[i]]</code>.
If <code>newdata</code> is <code>NULL</code> and <code>exogenous</code> is not <code>NULL</code> then
<code>newdata</code> is set to <code>object$data</code>.
This argument is especially useful for the casual inference when some 
endogenous (dependent) variables should be exogenously assigned with some 
values i.e., in the right hand side of the <code>formula</code>, <code>formula2</code> 
and <code>formula3</code>. The purpose of <code>exogeneous</code> argument is just a 
convenience so equivalently it is possible to exogenously provide the values
to variables via the <code>newdata</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'Examples' section of <code><a href="#topic+msel">msel</a></code>
for the examples of this function application.
</p>
<p><strong>Probabilities of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "prob"</code> then the function returns a joint probability that 
the ordinal outcomes will have values assigned in <code>group</code>. To calculate
marginal probabilities set unnecessary <code>group</code> values to <code>-1</code>. 
</p>
<p>To estimate conditional probabilities provide indexes of the conditioned 
outcomes through the <code>given_ind</code> argument. 
</p>
<p>For example, if <code class="reqn">z_{1i}</code>, <code class="reqn">z_{2i}</code> and <code class="reqn">z_{3i}</code> are the ordinal
outcomes then to estimate 
<code class="reqn">P(z_{1i}=2 | z_{3i} = 0, w_{1i}, w_{2i}, w_{3i})</code> set 
<code>given_ind = 3</code> and <code>groups = c(2, -1, 0)</code>.
</p>
<p><strong>Linear predictors (indexes) of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "li"</code> or <code>type = "lp"</code> then the function returns a 
matrix which columns are linear predictors (indexes) of the corresponding 
equations. If <code>group[j] = -1</code> then linear predictors (indexes) 
associated with the <code>j</code>-th ordinal equation will be omitted from the 
output.
</p>
<p>For example, if <code>group = c(0, -1, 1)</code> then the function returns a
matrix which first column is <code class="reqn">w_{1i}\hat{\gamma}_{1}</code> and the second 
column is <code class="reqn">w_{3i}\hat{\gamma}_{3}</code>.
</p>
<p><strong>Standard deviations of the multivariate ordinal equations</strong>
</p>
<p>If <code>type = "sd"</code> then the function returns a matrix which columns are
the estimates of the standard deviations of the random errors for 
the corresponding equations. 
If <code>group[j] = -1</code> then the standard deviations associated with the 
<code>j</code>-th ordinal equation will be omitted from the output.
</p>
<p>For example, if <code>group = c(0, -1, 1)</code> then the function returns a
matrix which first column is <code class="reqn">\hat{\sigma}_{1i}^{*}</code> and the second 
column is <code class="reqn">\hat{\sigma}_{3i}^{*}</code>.
</p>
<p><strong>Predictions of the continuous outcomes</strong>
</p>
<p>If <code>type = "val"</code> then the function returns the predictions of the 
conditional (on <code>group</code>) expectation of the continuous outcomes in the 
regimes determined by the <code>group2</code> argument. To predict unconditional 
expectations set <code>group</code> to a vector of <code>-1</code> values.
</p>
<p>For example, suppose that there is a single continuous equation <code class="reqn">y_{i}</code> 
and two ordinal equations <code class="reqn">z_{1i}</code> and <code class="reqn">z_{2i}</code>. 
To estimate <code class="reqn">E(y_{2i}|x_{i})</code> set <code>group = c(-1, -1)</code> and 
<code>group2 = 2</code>. 
To estimate <code class="reqn">E(y_{1i}|x_{i}, z_{1i} = 2, z_{2i} = 0)</code> set 
<code>group = c(2, 0)</code> and <code>group2 = 1</code>.
To estimate <code class="reqn">E(y_{0i}|x_{i}, z_{2i} = 1)</code> set 
<code>group = c(-1, 1)</code> and <code>group2 = 0</code>.
</p>
<p>Suppose that there are two continuous <code class="reqn">y_{i}^{(1)}</code>,
<code class="reqn">y_{i}^{(2)}</code> and two ordinal <code class="reqn">z_{1i}</code>, <code class="reqn">z_{2i}</code> equations.
If <code>group2 = c(1, 3)</code> and <code>group = c(3, 0)</code> then the function 
returns a matrix which first column are the estimates of 
<code class="reqn">E(y_{1i}^{(1)}|z_{1i} = 3, z_{2i} = 0, x_{i}^{(1)})</code> and the second 
column are the estimates of 
<code class="reqn">E(y_{3i}^{(2)}|z_{1i} = 3, z_{2i} = 0, x_{i}^{(2)})</code>.
</p>
<p><strong>Selectivity terms</strong>
</p>
<p>If <code>type = "lambda"</code> then the function returns a matrix which 
<code>j</code>-th column is a numeric vector of estimates of the selectivity terms 
<code class="reqn">\lambda_{ji}</code> associated with the ordinal equations. 
Similarly if <code>type = "lambda_mn"</code> then the
function returns a numeric matrix with the selectivity terms of the 
multinomial equations.
</p>
<p><strong>Probabilities of the multinomial equation</strong>
</p>
<p>If <code>type = "prob_mn"</code> and <code>group3 = j</code> then the function returns 
a vector of the estimates of the probabilities 
<code class="reqn">P(\tilde{z}_{i}=j|\tilde{w}_{i})</code>.
</p>
<p><strong>Linear indexes (predictors) of the multinomial equation</strong>
</p>
<p>If <code>type = "li_mn"</code> or <code>type = "lp_mn"</code> then the function returns a 
numeric matrix which <code>j</code>-th column is a numeric vector of estimates of 
the linear predictor (index) associated with the <code>(j-1)</code>-th alternative 
<code class="reqn">\tilde{w}_{i}\tilde{\gamma}_{(j-1)}</code>.
</p>
<p><strong>Estimation of the marginal effects</strong>
</p>
<p>If <code>me</code> is provided then the function returns marginal effect
of variable <code>me</code> respect to the statistic determined by the <code>type</code>
argument. 
</p>
<p>For example, if <code>me = "x1"</code> and <code>type = "prob"</code> then the function 
returns a marginal effect of <code>x1</code> on the corresponding probability 
i.e., one that would be estimated if <code>me</code> is <code>NULL</code>.
</p>
<p>If <code>length(eps) = 1</code> then <code>eps</code> is an increment in 
numeric differentiation procedure. 
If <code>eps</code> is <code>NULL</code> then this increment will be selected 
automatically taking into account scaling of variables. 
If <code>length(eps) = 2</code> then marginal effects will be estimated as the
difference of predicted value when variable <code>me</code> equals <code>eps[2]</code>
and <code>eps[1]</code> correspondingly. 
</p>
<p>For example, suppose that 
<code>type = "prob"</code>, <code>me = "x1"</code>, <code>given_ind = 3</code> and
<code>groups = c(2, -1, 0)</code>. Then if <code>eps</code> is a <code>NULL</code> or a 
small number (something like <code>eps = 0.0001</code>) then the following marginal
effect will be estimated (via the numeric differentiation):
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial P(z_{1i}=2 | z_{3i} = 0)}{\partial x_{1i}}.</code>
</p>

<p>If <code>eps = c(1, 3)</code> then the function estimates the following difference
(useful for estimation of marginal effects of ordered covariates):
</p>
<p style="text-align: center;"><code class="reqn">P(z_{1i}=2 | z_{3i} = 0, x_{1i} = 3) - 
      P(z_{1i}=2 | z_{3i} = 0, x_{1i} = 1).</code>
</p>

<p>Notice that the conditioning on <code class="reqn">w_{ji}</code> has been omitted for brevity.
</p>
<p><strong>Causal inference</strong>
</p>
<p>Argument <code>exogenous</code> is useful for the causal inference. 
For example, suppose that there are two binary outcomes <code class="reqn">z_{1i}</code> and
<code class="reqn">z_{2i}</code>. Also <code class="reqn">z_{1i}</code> is the endogenous regressor for <code class="reqn">z_{2i}</code>.
That is <code class="reqn">z_{1i}</code> appears both on the left hand side of
<code>formula[[1]]</code> and on the right hand side of <code>formula[[2]]</code>. 
Consider the estimation of the average treatment effect:
</p>
<p style="text-align: center;"><code class="reqn">ATE = P(z_{2i} = 1|do(z_{1i}) = 1) - 
P(z_{2i} = 1|do(z_{1i}) = 0),</code>
</p>

<p>where <code class="reqn">do</code> is a do-calculus operator.
The estimate of the average treatment effect is as follows:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{ATE} = \frac{1}{n}\sum\limits_{i=1}^{n}p_{1i}-p_{0i},</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">p_{1i} = \hat{P}(z_{2i} = 1|do(z_{1i}) = 1, w_{1i}, w_{2i}^{(*)}),</code>
</p>

<p style="text-align: center;"><code class="reqn">p_{0i} = \hat{P}(z_{2i} = 1|do(z_{1i}) = 0, w_{1i}, w_{2i}^{(*)}).</code>
</p>

<p>Vector <code class="reqn">w_{2i}^{(*)}</code> denotes all the regressors <code class="reqn">w_{2i}</code> except
the endogenous one <code class="reqn">z_{1i}</code>.
</p>
<p>To get <code class="reqn">\widehat{ATE}</code> it is sufficient to make the following steps. 
First, calculate <code class="reqn">p_{1i}</code> by setting <code>type = "prob"</code>, 
<code>group = c(-1, 1)</code> and providing the value <code>1</code> to <code class="reqn">z_{1i}</code> 
through the <code>exogenous</code> argument. 
Second, calculate <code class="reqn">p_{0i}</code> by setting <code>type = "prob"</code>, 
<code>group = c(-1, 0)</code> and providing the value <code>0</code> to <code class="reqn">z_{1i}</code> 
through the <code>exogenous</code> argument. Third, take the average value of 
<code class="reqn">p_{1i}-p_{0i}</code>.
</p>


<h3>Value</h3>

<p>This function returns predictions for each row of <code>newdata</code>
or for each observation in the model if <code>newdata</code> is <code>NULL</code>.
Structure of the output depends on the <code>type</code> argument
(see 'Details' section).
</p>

<hr>
<h2 id='print.lrtest_msel'>Print Method for Likelihood Ratio Test</h2><span id='topic+print.lrtest_msel'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'lrtest_msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lrtest_msel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lrtest_msel_+3A_x">x</code></td>
<td>
<p>object of class &quot;lrtest_msel&quot;.</p>
</td></tr>
<tr><td><code id="print.lrtest_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the input argument <code>x</code>.
</p>

<hr>
<h2 id='print.msel'>Print for an Object of Class msel</h2><span id='topic+print.msel'></span>

<h3>Description</h3>

<p>Prints information on the object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.msel_+3A_x">x</code></td>
<td>
<p>object of class 'msel'</p>
</td></tr>
<tr><td><code id="print.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>

<hr>
<h2 id='print.struct_msel'>Print for an Object of Class struct_msel</h2><span id='topic+print.struct_msel'></span>

<h3>Description</h3>

<p>Prints information on the object of class 'struct_msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'struct_msel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.struct_msel_+3A_x">x</code></td>
<td>
<p>object of class 'struct_msel'</p>
</td></tr>
<tr><td><code id="print.struct_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>

<hr>
<h2 id='print.summary.lrtest_msel'>Print Summary Method for Likelihood Ratio Test</h2><span id='topic+print.summary.lrtest_msel'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'lrtest_msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lrtest_msel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.lrtest_msel_+3A_x">x</code></td>
<td>
<p>object of class &quot;lrtest_msel&quot;</p>
</td></tr>
<tr><td><code id="print.summary.lrtest_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>x</code> changing
it's class to <code>lrtest_msel</code>.
</p>

<hr>
<h2 id='print.summary.msel'>Print summary for an Object of Class msel</h2><span id='topic+print.summary.msel'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.msel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.msel_+3A_x">x</code></td>
<td>
<p>object of class 'msel'</p>
</td></tr>
<tr><td><code id="print.summary.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>x</code>.
</p>

<hr>
<h2 id='print.summary.test_msel'>Print summary for an Object of Class test_msel</h2><span id='topic+print.summary.test_msel'></span>

<h3>Description</h3>

<p>Prints summary for an object of class 'test_msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.test_msel'
print(x, ..., is_legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.test_msel_+3A_x">x</code></td>
<td>
<p>object of class 'test_msel'</p>
</td></tr>
<tr><td><code id="print.summary.test_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="print.summary.test_msel_+3A_is_legend">is_legend</code></td>
<td>
<p>a logical; if <code>TRUE</code> then additional information
is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns input argument <code>x</code>.
</p>

<hr>
<h2 id='sigma.msel'>Extract Residual Standard Deviation 'Sigma'</h2><span id='topic+sigma.msel'></span>

<h3>Description</h3>

<p>Extract standard deviations of random errors of continuous
equations of <code><a href="#topic+msel">msel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
sigma(object, use.fallback = TRUE, ..., regime = NULL, eq2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma.msel_+3A_object">object</code></td>
<td>
<p>object of class &quot;msel&quot;.</p>
</td></tr>
<tr><td><code id="sigma.msel_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical, passed to <code>nobs</code> (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="sigma.msel_+3A_regime">regime</code></td>
<td>
<p>regime of continuous equation</p>
</td></tr>
<tr><td><code id="sigma.msel_+3A_eq2">eq2</code></td>
<td>
<p>index of continuous equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available only if <code>estimator = "ml"</code> or all <code>degrees</code>
values are equal to <code>1</code>.
</p>


<h3>Value</h3>

<p>Returns estimates of the standard deviations 
of <code class="reqn">\varepsilon_{i}</code>. 
If <code>eq2 = k</code> then estimates only for <code class="reqn">k</code>-th continuous equation are 
returned. If in addition <code>regime = r</code> then estimate of 
<code class="reqn">\sqrt{Var(\varepsilon_{ri})}</code> is returned. 
Herewith if <code>regime</code> is not <code>NULL</code> and <code>eq2</code> is <code>NULL</code> 
it is assumed that <code>eq2 = 1</code>.
</p>

<hr>
<h2 id='starsVector'>Stars for p-values</h2><span id='topic+starsVector'></span>

<h3>Description</h3>

<p>This function assigns stars 
(associated with different significance levels) to p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starsVector(p_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="starsVector_+3A_p_value">p_value</code></td>
<td>
<p>vector of values between 0 and 1 representing p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three stars are assigned to p-values not greater than 0.01.
Two stars are assigned to p-values greater than 0.01 and not greater 
than 0.05.
One star is assigned to p-values greater than 0.05 and not greater than 0.1.
</p>


<h3>Value</h3>

<p>The function returns a string vector of stars assigned according
to the rules described in 'Details' section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_value &lt;- c(0.002, 0.2, 0.03, 0.08)
starsVector(p_value)
</code></pre>

<hr>
<h2 id='struct_msel'>Structure of the Object of Class msel</h2><span id='topic+struct_msel'></span>

<h3>Description</h3>

<p>Prints information on the structure of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct_msel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struct_msel_+3A_x">x</code></td>
<td>
<p>object of class 'msel'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a numeric matrix which columns are 
<code>groups</code>, <code>groups2</code>, <code>groups3</code> correspondingly. It also has
additional (last) column with the number of observations associated with the
corresponding combinations of the groups.
</p>

<hr>
<h2 id='summary.lrtest_msel'>Summary Method for Likelihood Ratio Test</h2><span id='topic+summary.lrtest_msel'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'lrtest_msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lrtest_msel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lrtest_msel_+3A_object">object</code></td>
<td>
<p>object of class &quot;lrtest_msel&quot;</p>
</td></tr>
<tr><td><code id="summary.lrtest_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just changes the class of the 'lrtest_msel'
object to 'summary.lrtest_msel'.
</p>


<h3>Value</h3>

<p>Returns an object of class 'summary.lrtest_msel'.
</p>

<hr>
<h2 id='summary.msel'>Summary for an Object of Class msel</h2><span id='topic+summary.msel'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'msel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
summary(object, ..., vcov = NULL, show_ind = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.msel_+3A_object">object</code></td>
<td>
<p>object of class 'msel'</p>
</td></tr>
<tr><td><code id="summary.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="summary.msel_+3A_vcov">vcov</code></td>
<td>
<p>positively defined numeric matrix representing
asymptotic variance-covariance matrix of the estimator to be
used for calculation of standard errors and p-values. It may also be a 
character. Then <code><a href="#topic+vcov.msel">vcov.msel</a></code> function
will be used which input argument <code>type</code> will be set to <code>vcov</code>.
If <code>estimator = "2step"</code> then <code>vcov</code> should be an estimate of the 
asymptotic covariance matrix of the first step estimator.</p>
</td></tr>
<tr><td><code id="summary.msel_+3A_show_ind">show_ind</code></td>
<td>
<p>logical; if <code>TRUE</code> then indexes of parameters will be
shown. Particularly, these indexes may be used in <code>ind</code> element of
<code>regularization</code> parameter of <code><a href="#topic+msel">msel</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vcov</code> is <code>NULL</code> then this function just changes the 
class of the 'msel' object to 'summary.msel'. Otherwise it 
additionally changes <code>object$cov</code> to <code>vcov</code> and use it to
recalculate <code>object$se</code>, <code>object$p_value</code> and <code>object$tbl</code> 
values. It also adds the value of <code>ind</code> argument to the object.
</p>


<h3>Value</h3>

<p>Returns an object of class 'summary.msel'.
</p>

<hr>
<h2 id='summary.test_msel'>Summary for an Object of Class delta_method</h2><span id='topic+summary.test_msel'></span>

<h3>Description</h3>

<p>Provides summary for an object of class 'delta_method'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'test_msel'
summary(object, ..., is_legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.test_msel_+3A_object">object</code></td>
<td>
<p>object of class 'delta_method'</p>
</td></tr>
<tr><td><code id="summary.test_msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="summary.test_msel_+3A_is_legend">is_legend</code></td>
<td>
<p>a logical; if <code>TRUE</code> then additional information
is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'summary.delta_method'.
</p>

<hr>
<h2 id='test_msel'>Tests and confidence intervals for the parameters estimated by 
the msel function</h2><span id='topic+test_msel'></span>

<h3>Description</h3>

<p>This function conducts various statistical tests and calculates
confidence intervals for the parameters of the model estimated via the 
<code><a href="#topic+msel">msel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_msel(
  object,
  fn,
  fn_args = list(),
  test = "t",
  method = "classic",
  ci = "classic",
  cl = 0.95,
  se_type = "dm",
  trim = 0,
  vcov = object$cov,
  iter = 100,
  generator = rnorm,
  bootstrap = NULL,
  par_ind = 1:object$control_lnL$n_par,
  eps = max(1e-04, sqrt(.Machine$double.eps) * 10),
  n_sim = 1000,
  n_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_msel_+3A_object">object</code></td>
<td>
<p>an object of class 'msel'. It also may be a list of two 
objects. Then <code>object[[1]]</code> and <code>object[[2]]</code> are supplied to the
arguments <code>model1</code> and <code>model2</code> of the 
<code><a href="#topic+lrtest_msel">lrtest_msel</a></code> function.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_fn">fn</code></td>
<td>
<p>a function which returns a numeric vector and should depend on the 
elements of <code>object</code>. These elements should be accessed via 
<code><a href="#topic+coef.msel">coef.msel</a></code> or 
<code><a href="#topic+predict.msel">predict.msel</a></code> functions.
The first argument of <code>fn</code> should be an <code>object</code>.
Therefore <code>coef</code> and <code>predict</code> functions in <code>fn</code> should also
depend on <code>object</code>.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_fn_args">fn_args</code></td>
<td>
<p>a list of additional arguments of <code>fn</code>.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_test">test</code></td>
<td>
<p>a character representing the test to be used.
If <code>test = "t"</code> then t-test is used.
If <code>test = "wald"</code> then Wald test is applied.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_method">method</code></td>
<td>
<p>a character representing a method used to conduct a test.
If <code>test = "t"</code> or <code>test = "wald"</code> and <code>method = "classic"</code> 
then p-values are calculated by using the quantiles of the standard normal 
distribution.
If <code>test = "t"</code> or <code>test = "wald"</code> and <code>method = "bootstrap"</code> 
then p-values are calculated by using the bootstrap as described 
in Hansen (2022).
If <code>test = "wald"</code> and <code>method = "score"</code> then score 
bootstrap Wald test of P. Kline and A. Santos (2012) is used.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_ci">ci</code></td>
<td>
<p>a character representing the type of the confidence interval
used. Available only if <code>test = "t"</code>.
If <code>ci = "classic"</code> then quantiles of the standard normal distribution
are used to build an asymptotic confidence interval.
If <code>ci = "percentile"</code> then percentile bootstrap interval is applied.
If <code>ci = "bc"</code> then the function constructs a bias-corrected 
percentile bootstrap confidence interval of Efron (1982) as described in
Hansen (2022).</p>
</td></tr>
<tr><td><code id="test_msel_+3A_cl">cl</code></td>
<td>
<p>a numeric value between <code>0</code> and <code>1</code> representing
a confidence level of the confidence interval.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_se_type">se_type</code></td>
<td>
<p>a character representing a method used to estimate 
the standard errors of the outputs of <code>fn</code>. 
If <code>se_type = "dm"</code> then delta method is used.
If <code>se_type = "bootstrap"</code> then bootstrap is applied.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_trim">trim</code></td>
<td>
<p>a numeric value between <code>0</code> and <code>1</code> representing
the share of bootstrap estimates to be nullified when standard errors are
estimated for <code>se_type = "bootstrap"</code>.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_vcov">vcov</code></td>
<td>
<p>an estimate of the asymptotic covariance matrix of the 
parameters of the model.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_iter">iter</code></td>
<td>
<p>the number of iterations used by the score bootstrap Wald test.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_generator">generator</code></td>
<td>
<p>function which is used by the score bootstrap to generate
random weights. It should have an argument <code>n</code> representing the
number of random weights to generate. Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_bootstrap">bootstrap</code></td>
<td>
<p>an object of class <code>'bootstrap_msel'</code> which is an 
output of the <code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code> function.
This object is used to retrieve the estimates of the bootstrap samples.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_par_ind">par_ind</code></td>
<td>
<p>a vector of indexes of the model parameters used 
in the calculation of <code>fn</code>. If only necessary indexes are included then
in some cases estimation time may greatly decrease. Set <code>ind = TRUE</code>
in <code><a href="#topic+summary.msel">summary.msel</a></code> to see the indexes of the 
model parameters. If <code>eps</code> is a vector then <code>eps[i]</code> determines 
the increment used to differentiate <code>fn</code> respect to the parameter with 
<code>par_ind[i]</code>-th index.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_eps">eps</code></td>
<td>
<p>a positive numeric value representing the increment used for the
numeric differentiation of <code>fn</code>. It may also be a numeric vector
such that <code>eps[i]</code> is an increment used to differentiate the 
<code>fn</code> respect to the <code>par_ind[i]</code>-th parameter of the model.
Set <code>ind = TRUE</code> in <code><a href="#topic+summary.msel">summary.msel</a></code>, to see 
the indexes of the model parameters. If <code>eps[i] = 0</code> then derivative of 
<code>fn</code> respect to <code>par_ind[i]</code>-th parameter is assumed to be zero.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_n_sim">n_sim</code></td>
<td>
<p>the value passed to the <code>n_sim</code> argument of the
<code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
<tr><td><code id="test_msel_+3A_n_cores">n_cores</code></td>
<td>
<p>the value passed to the <code>n_cores</code> argument of the
<code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code class="reqn">\theta</code> is a vector of parameters of the model 
estimated via the <code><a href="#topic+msel">msel</a></code> function and 
<code class="reqn">g(\theta)</code> is a differentiable function representing <code>fn</code> which 
returns a <code class="reqn">m</code>-dimensional vector of real values:
</p>
<p style="text-align: center;"><code class="reqn">g(\theta) = (g_{1}(\theta),...,g_{m}(\theta))^{T}.</code>
</p>

<p><strong>Classic and bootstrap t-test</strong>
</p>
<p>If <code>test = "t"</code> then for each <code class="reqn">j\in \{1,...,m\}</code> the following 
hypotheses is tested:
</p>
<p style="text-align: center;"><code class="reqn">H_{0}:g_{j}(\theta) = 0,\qquad H_{1}:g_{j}(\theta)\ne 0.</code>
</p>

<p>The test statistic is: 
</p>
<p style="text-align: center;"><code class="reqn">T = g_{j}(\hat{\theta})/\hat{\sigma}_{j},</code>
</p>

<p>where <code class="reqn">\hat{\sigma}</code> is a standard error of <code class="reqn">g_{j}(\hat{\theta})</code>.
</p>
<p>If <code>se_type = "dm"</code> then delta method is used to estimate 
this standard error:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\sigma}_{j} = \sqrt{\nabla g_{j}(\hat{\theta})^{T} 
\widehat{As.Cov}(\hat{\theta})
\nabla g_{j}(\hat{\theta})},
</code>
</p>

<p>where <code class="reqn">\nabla g_{j}(\hat{\theta})</code> is a gradient as a column vector and
the estimate of the asymptotic covariance matrix of the estimates 
<code class="reqn">\widehat{As.Cov}(\hat{\theta})</code> is provided via the <code>vcov</code> 
argument. Numeric differentiation is used to calculate 
<code class="reqn">\nabla g_{j}(\hat{\theta})</code>.
</p>
<p>If <code>se_type = "bootstrap"</code> then bootstrap is 
applied to estimate the standard error:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\sigma}_{j} = \sqrt{\frac{1}{B - 1}\sum\limits_{b = 1}^{B} 
(g_{j}(\hat{\theta}^{(b)}) - \overline{g_{j}(\hat{\theta}^{(b)}}))^2},</code>
</p>

<p>where <code class="reqn">B</code> is the number of the bootstrap iterations 
<code>bootstrap$iter</code>, <code class="reqn">\hat{\theta}^{(b)}</code> is the estimate 
associated with the <code class="reqn">b</code>-th of these iterations <code>bootstrap$par[b, ]</code>,
and <code class="reqn">g_{j}(\overline{\hat{\theta}^{(b)}})</code> is a sample mean of the bootstrap 
estimates:
</p>
<p style="text-align: center;"><code class="reqn">\overline{g_{j}(\hat{\theta}^{(b)}}) = 
\frac{1}{B}\sum\limits_{b = 1}^{B}g_{j}(\hat{\theta}^{(b)}).</code>
</p>

<p>If <code>method = "classic"</code> it is assumed that if the null hypothesis is 
true then the asymptotic distribution of the test statistic is standard 
normal. This distribution is used for the calculation of the p-value:
</p>
<p style="text-align: center;"><code class="reqn">p-value = 2\min(\Phi(T), 1 - \Phi(T)),</code>
</p>

<p>where <code class="reqn">\Phi()</code> is a cumulative distribution function of the standard
normal distribution.
</p>
<p>If <code>method = "bootstrap"</code> then p-value is calculated via the bootstrap 
as suggested by Hansen (2022):
</p>
<p style="text-align: center;"><code class="reqn">
p-value = \frac{1}{B}\sum\limits_{b=1}^{B} I(|T_{b} - T| &gt; |T|),
</code>
</p>

<p>where <code class="reqn">T_{b} = g_{j}(\hat{\theta}^{(b)})/\hat{\sigma}_{j}</code> is the value of 
the test statistic estimated on the <code>b</code>-th bootstrap sample and 
<code class="reqn">I(q)</code> is an indicator function which equals <code class="reqn">1</code> when <code class="reqn">q</code> is a 
true statement and <code class="reqn">0</code> - otherwise.
</p>
<p><strong>Classic and bootstrap Wald test</strong>
</p>
<p>Suppose that <code>method = "classic"</code> or <code>method = "bootstrap"</code>.
If <code>test = "wald"</code> then the null hypothesis is:
</p>
<p style="text-align: center;"><code class="reqn">H_{0}:
\begin{cases}
g_{1}(\theta) = 0\\
g_{2}(\theta) = 0\\
\vdots\\
g_{m}(\theta) = 0\\
\end{cases}.
</code>
</p>

<p>The alternative hypothesis is that there is such <code class="reqn">j\in\{1,...,m\}</code> that:
</p>
<p style="text-align: center;"><code class="reqn">H_{1}:g_{j}(\theta)\ne 0.</code>
</p>

<p>The test statistic is:
</p>
<p style="text-align: center;"><code class="reqn">T = g(\hat{\theta})^{T}\widehat{As.Cov}(g(\hat{\theta}))^{-1}
g(\hat{\theta}),</code>
</p>

<p>where <code class="reqn">\widehat{As.Cov}(g(\hat{\theta}))</code> is the estimate of the 
asymptotic covariance matrix of <code class="reqn">g(\hat{\theta})</code>. 
</p>
<p>If <code>se_type = "dm"</code> then delta method is used to estimate this matrix:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{As.Cov}(g(\hat{\theta})) 
= g'(\hat{\theta})\widehat{As.Cov}(\hat{\theta}) g'(\hat{\theta})^{T},</code>
</p>

<p>where <code class="reqn">g'(\hat{\theta})</code> is a Jacobian matrix. A numeric differentiation
is used to calculate its elements:
</p>
<p style="text-align: center;"><code class="reqn">g'(\hat{\theta})_{ij} = 
\frac{\partial g_{i}(\theta)}{\partial \theta_{j}}|_{\theta = \hat{\theta}}.</code>
</p>

<p>If <code>se_type = "bootstrap"</code> then bootstrap is used to estimate this 
matrix:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{As.Cov}(g(\hat{\theta}))=
\frac{1}{B-1}\sum\limits_{i=1}^{B}q_{b}q_{b}^{T},</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">q_{b} = (g(\hat{\theta}^{(b)}) - 
\overline{g(\hat{\theta}^{(b)})}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\overline{g(\hat{\theta}^{(b)})} = \frac{1}{B}\sum\limits_{i=1}^{B}
g(\hat{\theta}^{(b)}).</code>
</p>

<p>If <code>method = "classic"</code> then it is assumed that if the null hypothesis 
is true then the asymptotic distribution of the test statistic is chi-squared
with <code class="reqn">m</code> degrees of freedom. This distribution is used for the 
calculation of the p-value:
</p>
<p style="text-align: center;"><code class="reqn">p-value = 1 - F_{m}(T),</code>
</p>

<p>where <code class="reqn">F_{m}</code> is a cumulative distribution function of the chi-squared
distribution with <code class="reqn">m</code> degrees of freedom.
</p>
<p>If <code>method = "bootstrap"</code> then p-value is calculated via the bootstrap 
as suggested by Hansen (2022):
</p>
<p style="text-align: center;"><code class="reqn">
p-value = \frac{1}{B}\sum\limits_{b=1}^{B} I(T_{b} &gt; T),
</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">T_{b} = s_{b}^{T}\widehat{As.Cov}(g(\hat{\theta}))^{-1}s_{b},</code>
</p>

<p style="text-align: center;"><code class="reqn">s_{b} = g(\hat{\theta}^{(b)}) - g(\hat{\theta}).</code>
</p>

<p><strong>Score bootstrap Wald test</strong>
</p>
<p>If <code>method = "score"</code> and <code>test = "Wald"</code> then score bootstrap
Wald test of Kline and Santos (2012) is used.
</p>
<p>Consider <code class="reqn">B</code> independent samples of <code class="reqn">n</code> independent identically 
distributed random weights with zero mean and unit variance. 
Let <code class="reqn">w_{ib}</code> denote the <code class="reqn">i</code>-th weight of the <code class="reqn">b</code>-th sample. 
Argument <code>generator</code> is used to supply a function which generates these 
weights <code class="reqn">w_{ib}</code> and <code>iter</code> argument represents <code class="reqn">B</code>. 
Also <code class="reqn">n</code> is the number of observations in the model 
<code>object$other$n_obs</code>.
</p>
<p>Let <code class="reqn">J</code> denote a matrix of sample scores <code>object$J</code>. 
Further, denote by <code class="reqn">J_{b}</code> a matrix such that its <code class="reqn">b</code>-th row is a 
product of the <code class="reqn">w_{ib}</code> and the <code class="reqn">b</code>-th row of <code class="reqn">J</code>. 
Also, denote by <code class="reqn">H</code> a matrix of mean values of the derivatives of 
sample scores respect to the estimated parameters <code>object$H</code>.
</p>
<p>In addition consider the following notations:
</p>
<p style="text-align: center;"><code class="reqn">A = g'(\theta) H^{-1}, \qquad S_{b} = A J^{(c)}_{b},</code>
</p>

<p>where <code class="reqn">J^{(c)}_{b}</code> is a vector of the column sums of <code class="reqn">J_{b}</code>.
</p>
<p>The test statistic is as follows:
</p>
<p style="text-align: center;"><code class="reqn">T = g(\hat{\theta})^{T}(A\widehat{Cov}(J)
A^{T})^{-1}g(\hat{\theta}) / n,</code>
</p>

<p>where <code class="reqn">\widehat{Cov}(J)</code> is a sample covariance matrix of the sample
scores of the model <code>cov(object$J)</code>.
</p>
<p>The test statistic on the <code class="reqn">b</code>-th bootstrap sample is similar:
</p>
<p style="text-align: center;"><code class="reqn">T_{b} = S^{T}(A\widehat{Cov}(J_{b})
A^{T})^{-1}S / n.</code>
</p>

<p>The p-value is estimated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
p-value = \frac{1}{B}\sum\limits_{b=1}^{B} I(T_{b} \geq T).
</code>
</p>

<p><strong>Confidence intervals</strong>
</p>
<p>If <code>test = "t"</code> then the function also returns the realizations of the 
lower and upper bounds of the <code class="reqn">100 \times</code><code>cl</code> percent symmetric 
asymptotic confidence interval of <code class="reqn">g_{j}(\theta)</code>.
</p>
<p>If <code>ci = "classic"</code> then classic confidence interval is used which
assumes asymptotic normality of <code class="reqn">g_{j}(\hat{\theta})</code>:
</p>
<p style="text-align: center;"><code class="reqn">(g_{j}(\hat{\theta}) + z_{(1 - cl) / 2}\hat{\sigma}_{j}, 
g_{j}(\hat{\theta}) + z_{1 - (1 - cl) / 2}\hat{\sigma}_{j}),</code>
</p>

<p>where <code class="reqn">z_{q}</code> is a <code class="reqn">q</code>-th quantile of the standard normal 
distribution and <code class="reqn">cl</code> is a confidence level <code>cl</code>. The method used 
to estimate <code class="reqn">\hat{\sigma}_{j}</code> depends on the <code>se_type</code> argument as 
described above.
</p>
<p>If <code>ci = "percentile"</code> then percentile bootstrap confidence interval 
is used. Therefore the sample quantiles of <code class="reqn">g_{j}(\hat{\theta}^{(b)})</code> 
are used as the realizations of the lower and upper bounds of the confidence 
interval.
</p>
<p>If <code>ci = "bc"</code> then bias corrected percentile bootstrap confidence 
interval of Efron (1982) is used as described in Hansen (2022). The default
percentile bootstrap confidence interval uses sample quantiles of levels 
<code class="reqn">(1 - cl)/2</code> and <code class="reqn">1 - (1 - cl)/2</code>. 
Bias corrected version uses the sample quantiles of the
following levels:
</p>
<p style="text-align: center;"><code class="reqn">(1 - cl)/2 + \Phi(\Phi^{-1}((1 - cl)/2) + s),</code>
</p>

<p style="text-align: center;"><code class="reqn">1 - (1 - cl)/2 + \Phi(\Phi^{-1}(1 - (1 - cl)/2) + s),</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">s = 2\Phi^{-1}(\frac{1}{B}\sum\limits_{b = 1}^{B}
I(g_{j}(\hat{\theta}^{(b)})\leq g_{j}(\hat{\theta}))).</code>
</p>

<p><strong>Trimming</strong>
</p>
<p>If <code>se_type = "bootstrap"</code> and <code>trim &gt; 0</code> then trimming is used as
described in Hansen (2022) to estimate <code class="reqn">\hat{\sigma}_{j}</code> and 
<code class="reqn">\widehat{As.Cov}(g(\hat{\theta}))</code>. The algorithm is as follows. 
First, nullify 100<code>trim</code> percent of <code class="reqn">g(\hat{\theta}^{(b)})</code> with the 
greatest values of the L2-norm of <code class="reqn">q_{b}</code> (defined above). 
Then use this 'trimmed' sample to estimate the standard error and the 
asymptotic covariance matrix.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>'test_msel'</code> which is
a list. It may have the following elements:
</p>

<ul>
<li> <p><code>tbl</code> - a list with the elements described below.
</p>
</li>
<li> <p><code>is_bootstrap</code> - a logical value which equals <code>TRUE</code> if 
bootstrap has been used.
</p>
</li>
<li> <p><code>is_ci</code> - a logical value which equals <code>TRUE</code> if
confidence intervals were used.
</p>
</li>
<li> <p><code>test</code> - the same as the input argument <code>test</code>.
</p>
</li>
<li> <p><code>method</code> - the same as the input argument <code>method</code>.
</p>
</li>
<li> <p><code>se_type</code> - the same as the input argument <code>method</code>.
</p>
</li>
<li> <p><code>ci</code> - the same as the input argument <code>ci</code>.
</p>
</li>
<li> <p><code>cl</code> - the same as the input argument <code>cl</code>.
</p>
</li>
<li> <p><code>iter</code> - the same as the input argument <code>iter</code>.
</p>
</li>
<li> <p><code>n_bootstrap</code> - an integer representing the number of the
bootstrap iterations used.
</p>
</li>
<li> <p><code>n_val</code> - the length of the vector returned by <code>fn</code>.
</p>
</li></ul>

<p>A list <code>tbl</code> may have the following elements:
</p>

<ul>
<li> <p><code>val</code> - an output of the <code>fn</code> function.
</p>
</li>
<li> <p><code>se</code> - a numeric vector such that <code>se[i]</code> represents 
a standard error associated with <code>val[i]</code>.
</p>
</li>
<li> <p><code>p_value</code> - a numeric vector of p-values.
</p>
</li>
<li> <p><code>lwr</code> - a numeric vector such that <code>lwr[i]</code> is the 
realization of the lower (left) bound of the confidence interval for the
true value of <code>val[i]</code>.
</p>
</li>
<li> <p><code>upr</code> - a numeric vector such that <code>upr[i]</code> is the 
realization of the upper (right) bound of the confidence interval for the
true value of <code>val[i]</code>.
</p>
</li>
<li> <p><code>stat</code> - a numeric vector of values of the test statistics.
</p>
</li></ul>

<p>An object of class <code>'test_msel'</code> has an implementation of the
<code>summary</code> method
<code><a href="#topic+summary.test_msel">summary.test_msel</a></code>.
</p>
<p>In a special case when <code>object</code> is a list of length <code>2</code> the 
function returns an object of class <code>'lrtest_msel'</code> since the function
<code><a href="#topic+lrtest_msel">lrtest_msel</a></code> is called internally.
</p>


<h3>References</h3>

<p>B. Efron (1982). The Jackknife, the Bootstrap, and Other 
Resampling Plans. Society for Industrial and Applied Mathematics.
</p>
<p>B. Hansen (2022). Econometrics. Princeton University Press.
</p>
<p>P. Kline, A. Santos (2012). 
A Score Based Approach to Wild Bootstrap Inference.
Journal of Econometric Methods, vol. 67, no. 1, pages 23-41.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# -------------------------------
# CPS data example
# -------------------------------

# Set seed for reproducibility
set.seed(123)

# Upload the data
data(cps)

# Estimate the employment model
model &lt;- msel(work ~ age + I(age ^ 2) + bachelor + master, data = cps)
summary(model)    

# Use Wald test to test the hypothesis that age has no 
# effect on the conditional probability of employment:
# H0: coef age     = 0
#     coef age ^ 2 = 0
age_fn &lt;- function(object)
{
  lwage_coef &lt;- coef(object, type = "coef")[[1]]
  val        &lt;- c(lwage_coef["age"], lwage_coef["I(age^2)"])
  return(val)
}
age_test &lt;- test_msel(object = model, fn = age_fn, test = "wald")
summary(age_test)

# Use t-test to test for each individual the hypothesis:
# P(work = 1 | x) = 0.8
prob_fn &lt;- function(object)
{
  prob &lt;- predict(object, group = 1, type = "prob")
  val  &lt;- prob - 0.8
  return(val)
}
prob_test &lt;- test_msel(object = model, fn = prob_fn, test = "t")
summary(prob_test)

# -------------------------------
# Simulated data example
# Model with continuous outcome
# and ordinal selection
# -------------------------------

# ---
# Step 1
# Simulation of the data
# ---

# Set seed for reproducibility
set.seed(123)

# Load required package
library("mnorm")

# The number of observations
n &lt;- 10000

# Regressors (covariates)
s1 &lt;- runif(n = n, min = -1, max = 1)
s2 &lt;- runif(n = n, min = -1, max = 1)
s3 &lt;- runif(n = n, min = -1, max = 1)
s4 &lt;- runif(n = n, min = -1, max = 1)

# Random errors
sigma &lt;- matrix(c(1,    0.4,  0.45, 0.7,
                  0.4,  1,    0.54, 0.8,
                  0.45, 0.54, 0.81, 0.81,
                  0.7,  0.8,  0.81, 1), nrow = 4)
errors &lt;- mnorm::rmnorm(n = n, mean = c(0, 0, 0, 0), sigma = sigma)
u1   &lt;- errors[, 1]
u2   &lt;- errors[, 2]
eps0 &lt;- errors[, 3]
eps1 &lt;- errors[, 4]

# Coefficients
gamma1     &lt;- c(-1, 2)
gamma2     &lt;- c(1, 1)
gamma1_het &lt;- c(0.5, -1)
beta0      &lt;- c(1, -1, 1, -1.2)
beta1      &lt;- c(2, -1.5, 0.5, 1.2)
# Linear index of the ordinal equations
# mean part
li1 &lt;- gamma1[1] * s1 + gamma1[2] * s2
li2 &lt;- gamma2[1] * s1 + gamma2[2] * s3
# variance part
li1_het &lt;- gamma1_het[1] * s2 + gamma1_het[2] * s3

# Linear index of the continuous equation
# regime 0
li_y0 &lt;- beta0[1] + beta0[2] * s1 + beta0[3] * s3 + beta0[4] * s4
# regime 1
li_y1 &lt;- beta1[1] + beta1[2] * s1 + beta1[3] * s3 + beta1[4] * s4

# Latent variables
z1_star &lt;- li1 + u1 * exp(li1_het)
z2_star &lt;- li2 + u2
y0_star &lt;- li_y0 + eps0
y1_star &lt;- li_y1 + eps1

# Cuts
cuts1 &lt;- c(-1)
cuts2 &lt;- c(0, 1)

# Observable ordinal outcome
# first
z1                     &lt;- rep(0, n)
z1[z1_star &gt; cuts1[1]] &lt;- 1
# second
z2                                               &lt;- rep(0, n)
z2[(z2_star &gt; cuts2[1]) &amp; (z2_star &lt;= cuts2[2])] &lt;- 1
z2[z2_star &gt; cuts2[2]]                           &lt;- 2
z2[z1 == 0]                                      &lt;- NA

# Observable continuous outcome
y                 &lt;- rep(NA, n)
y[which(z2 == 0)] &lt;- y0_star[which(z2 == 0)]
y[which(z2 != 0)] &lt;- y1_star[which(z2 != 0)]
y[which(z1 == 0)] &lt;- NA

# Data
data &lt;- data.frame(s1 = s1, s2 = s2, s3 = s3, s4 = s4,
                   z1 = z1, z2 = z2, y = y)

# ---
# Step 2
# Estimation of the parameters
# ---

# Assign the groups
groups  &lt;- matrix(c(1, 2,
                    1, 1,
                    1, 0,
                    0, -1), 
                  byrow = TRUE, ncol = 2)
groups2 &lt;- matrix(c(1, 1, 0, -1), ncol = 1)

# Estimate the model
model &lt;- msel(list(z1 ~ s1 + s2 | s2 + s3,
                   z2 ~ s1 + s3),
              list(y  ~ s1 + s3 + s4),
              groups = groups, groups2 = groups2, 
              data   = data)
                   
# ---
# Step 3
# Hypotheses testing
# ---

# Use t-test to test for each observation the hypothesis
# H0: P(z1 = 0, z2 = 2 | Xi) = 0 
prob02_fn &lt;- function(object)
{
   val &lt;- predict(object, group = c(1, 0))
   
   return(val)
}
prob02_test &lt;- test_msel(object = model, fn = prob02_fn, test = "t")
summary(prob02_test)

# Use t-test to test the hypothesis
# H0: E(y1|z1=0, z2=2) - E(y0|z1=0, z2=2)
ATE_fn &lt;- function(object)
{
   val1 &lt;- predict(object, group = c(0, 2), group2 = 1)
   val0 &lt;- predict(object, group = c(0, 2), group2 = 0)
   val &lt;- mean(val1 - val0)
   
   return(val)
}
ATE_test &lt;- test_msel(object = model, fn = ATE_fn)
summary(ATE_test)

# Use Wald to test the hypothesis
# H0: beta1 = beta0
coef_fn &lt;- function(object)
{
   coef1 &lt;- coef(object, regime = 1, type = "coef2")
   coef0 &lt;- coef(object, regime = 0, type = "coef2")
   coef_difference &lt;- coef1 - coef0
   
   return(coef_difference)
}
coef_test &lt;- test_msel(object = model, fn = coef_fn, test = "wald")
summary(coef_test)

# Use t-test to test for each 'k' the hypothesis
# H0: beta1k = beta0k
coef_test2 &lt;- test_msel(object = model, fn = coef_fn, test = "t")
summary(coef_test2)

# Use Wald test to test the hypothesis
# H0: beta11 + beta12 - 0.5 = 0
#     beta11 * beta13 - beta03 = 0
test_fn &lt;- function(object)
{
  coef1 &lt;- coef(object, regime = 1, type = "coef2")
  coef0 &lt;- coef(object, regime = 0, type = "coef2")
  val   &lt;- c(coef1[1] + coef1[2] - 0.5, 
  coef1[1] * coef1[3] - coef0[3])
     
  return(val)
}
# classic Wald test
wald1 &lt;- test_msel(object = model,  fn     = test_fn, 
                   test   = "wald", method = "classic")
summary(wald1)
# score bootstrap Wald test
wald2 &lt;- test_msel(object = model,  fn     = test_fn, 
                   test   = "wald", method = "score")
summary(wald2)

# Replicate the latter test with the 2-step estimator
model2 &lt;- msel(list(z1 ~ s1 + s2 | s2 + s3,
                         z2 ~ s1 + s3),
               list(y ~ s1 + s3 + s4),
               groups    = groups, groups2   = groups2, 
               data      = data,   estimator = "2step")
# classic Wald test
wald1_2step &lt;- test_msel(object = model2, fn     = test_fn, 
                         test   = "wald", method = "classic")
summary(wald1_2step)
# score bootstrap Wald test
wald2_2step &lt;- test_msel(object = model2, fn     = test_fn, 
                         test   = "wald", method = "score")
summary(wald2_2step)    

             
</code></pre>

<hr>
<h2 id='update_msel'>Update msel object with the new estimates</h2><span id='topic+update_msel'></span>

<h3>Description</h3>

<p>This function updates parameters of the model estimated via 
<code><a href="#topic+msel">msel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_msel(object, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_msel_+3A_object">object</code></td>
<td>
<p>an object of class <code>'msel'</code>.</p>
</td></tr>
<tr><td><code id="update_msel_+3A_par">par</code></td>
<td>
<p>a vector of parameters which substitutes <code>object$par</code> and
used to update the estimates i.e., <code>object$coef</code>, <code>object$cuts</code> and
others.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It may be useful to apply this function to the bootstrap
estimates of <code><a href="#topic+bootstrap_msel">bootstrap_msel</a></code>.
</p>


<h3>Value</h3>

<p>This function returns an object <code>object</code> of class <code>'msel'</code>
in which <code>object$par</code> is substituted with <code>par</code>. Also, <code>par</code> 
is used to update the estimates i.e., <code>object$coef</code>, <code>object$cuts</code> 
and others.
</p>

<hr>
<h2 id='vcov.msel'>Calculate Variance-Covariance Matrix for a msel Object.</h2><span id='topic+vcov.msel'></span>

<h3>Description</h3>

<p>Return the variance-covariance matrix of the parameters of
msel model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msel'
vcov(
  object,
  ...,
  type = object$cov_type,
  n_cores = object$other$n_cores,
  n_sim = object$other$n_sim,
  recalculate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.msel_+3A_object">object</code></td>
<td>
<p>an object of class <code>msel</code>.</p>
</td></tr>
<tr><td><code id="vcov.msel_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="vcov.msel_+3A_type">type</code></td>
<td>
<p>character representing the type of the asymptotic covariance 
matrix estimator. It takes the same values as <code>cov_type</code> parameter of
the <code><a href="#topic+msel">msel</a></code> function.</p>
</td></tr>
<tr><td><code id="vcov.msel_+3A_n_cores">n_cores</code></td>
<td>
<p>positive integer representing the number of CPU cores used for 
parallel computing. If possible it is highly recommend to set it equal to
the number of available physical cores especially when the system of
ordered equations has 2 or 3 equations.</p>
</td></tr>
<tr><td><code id="vcov.msel_+3A_n_sim">n_sim</code></td>
<td>
<p>integer representing the number of GHK draws when there are
more than 3 ordered equations. Otherwise alternative (much more efficient) 
algorithms will be used to calculate multivariate normal probabilities.</p>
</td></tr>
<tr><td><code id="vcov.msel_+3A_recalculate">recalculate</code></td>
<td>
<p>logical; if <code>TRUE</code> then covariance matrix will be
recalculated even if 'type' is the same as 'cov_type' input argument
of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>type</code> is closely related to the argument 
<code>cov_type</code> of <code><a href="#topic+msel">msel</a></code> function. 
See 'Details' and 'Usage' sections of <code><a href="#topic+msel">msel</a></code> 
for more information on <code>cov_type</code> argument.
</p>


<h3>Value</h3>

<p>Returns numeric matrix which represents estimate of the asymptotic 
covariance matrix of model's parameters.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
