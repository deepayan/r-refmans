<!DOCTYPE html><html lang="en"><head><title>Help for package pcvr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcvr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#awkHelper'><p>subset helper function for use reading in large data, called in pcv.sub.read</p></a></li>
<li><a href='#barg'><p>Function to help fulfill elements of the Bayesian Analysis Reporting Guidelines.</p></a></li>
<li><a href='#brmPlot'><p>Function to visualize brms models similar to those made using growthSS outputs.</p></a></li>
<li><a href='#brmSurvPlot'><p>Function to visualize brms survival models specified using growthSS.</p></a></li>
<li><a href='#brmViolin'><p>Function to visualize hypotheses tested on brms models similar to those made using growthSS outputs.</p></a></li>
<li><a href='#bw.outliers'><p>Remove outliers from bellwether data using cook's distance</p></a></li>
<li><a href='#bw.time'><p>Time conversion and plotting for bellwether data</p></a></li>
<li><a href='#bw.water'><p>Read in lemnatech watering data from metadata.json files</p></a></li>
<li><a href='#checkGroups'><p>Helper function to check groups in data.</p></a></li>
<li><a href='#combineDraws'><p>Combine Draws From brms Models</p></a></li>
<li><a href='#conjugate'><p>Bayesian testing using conjugate priors and method of moments for single or multi value traits.</p></a></li>
<li><a href='#cumulativePheno'><p>Reduce phenotypes in longitudinal data to cumulative sums of phenotypes.</p></a></li>
<li><a href='#distributionPlot'><p>Function for plotting iterations of posterior distributions</p></a></li>
<li><a href='#fitGrowth'><p>Ease of use wrapper function for fitting various growth models specified by growthSS</p></a></li>
<li><a href='#fitGrowthbrms'><p>Ease of use brms wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthflexsurv'><p>Ease of use wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthlm'><p>Ease of use lm wrapper function for fitting growth models specified by <code>mvSS</code></p></a></li>
<li><a href='#fitGrowthmgcvgam'><p>Ease of use mgcv wrapper function for fitting gams specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnlme'><p>Ease of use nlme wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnlmegam'><p>Ease of use lme wrapper function for fitting gams specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnlrq'><p>Ease of use nlrq wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnlrqgam'><p>Ease of use rq wrapper function for fitting gams specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnls'><p>Ease of use nls wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthnlsgam'><p>Ease of use lm wrapper function for fitting gams specified by <code>growthSS</code></p></a></li>
<li><a href='#fitGrowthrq'><p>Ease of use rq wrapper function for fitting models specified by <code>mvSS</code></p></a></li>
<li><a href='#fitGrowthsurvreg'><p>Ease of use wrapper function for fitting growth models specified by <code>growthSS</code></p></a></li>
<li><a href='#flexsurvregPlot'><p>Function to visualize <code>flexsurv::flexsurvreg</code> models fit by <code>fitGrowth</code>.</p></a></li>
<li><a href='#frem'><p>Variance partitioning using Full Random Effects Models</p></a></li>
<li><a href='#gam_diff'><p>Helper function for visualizing differences in GAMs fit with <code>mgcv::gam</code></p></a></li>
<li><a href='#growthPlot'><p>Function to visualize models made by fitGrowth.</p></a></li>
<li><a href='#growthSim'><p>Growth data simulating function</p></a></li>
<li><a href='#growthSS'><p>Ease of use growth model helper function.</p></a></li>
<li><a href='#mv_ag'><p>Multi Value Trait Aggregation function</p></a></li>
<li><a href='#mvSim'><p>Multi Value Trait simulating function</p></a></li>
<li><a href='#mvSS'><p>Ease of use multi-value trait model helper function.</p></a></li>
<li><a href='#net.plot'><p>Visualizing igraph networks</p></a></li>
<li><a href='#nlmePlot'><p>Function to visualize common <code>nlme::nlme</code> growth models.</p></a></li>
<li><a href='#nlrqPlot'><p>Function to visualize common <code>quantreg::nlrq</code> growth models.</p></a></li>
<li><a href='#nlsPlot'><p>Function to visualize common <code>stats::nls</code> growth models.</p></a></li>
<li><a href='#pcadf'><p>Function to run a PCA, plot and optionally return the data with PCA coordinates and pca object</p></a></li>
<li><a href='#pcv_theme'><p>Default theme for ggplots made by pcvr functions.</p></a></li>
<li><a href='#pcv.emd'><p>Earth Mover's Distance between spectral histograms</p></a></li>
<li><a href='#pcv.joyplot'><p>Make Joyplots for multi value trait plantCV data</p></a></li>
<li><a href='#pcv.net'><p>Network analysis of a distance matrix</p></a></li>
<li><a href='#pcv.plsr'><p>Run Partial Least Squares Regression on spectral data</p></a></li>
<li><a href='#pcvrss-class'><p>Class <code>pcvrss</code> for models specified in <code>pcvr</code>.</p></a></li>
<li><a href='#plotPrior'><p>Check priors used in ease of use brms functions</p></a></li>
<li><a href='#plotVIP'><p>Plot Variable Influence on Projection</p></a></li>
<li><a href='#print.pcvrss'><p>Print a <code>pcvrss</code> object.</p></a></li>
<li><a href='#print.pcvrsssummary'><p>Print a <code>pcvrsssummary</code> object.</p></a></li>
<li><a href='#pwue'><p>Calculate pseudo water use efficiency from phenotype and watering data</p></a></li>
<li><a href='#read.pcv'><p>Read in plantCV csv output in wide or long format</p></a></li>
<li><a href='#read.pcv.3'><p>Read in plantCV csv from bellwether phenotyper style experiments analyzed with plantCV versions &lt;4.</p></a></li>
<li><a href='#relativeTolerance'><p>Calculate relative tolerance of some phenotype(s) relative to control</p></a></li>
<li><a href='#rqPlot'><p>Function to visualize <code>quantreg::rq</code> general additive growth models.</p></a></li>
<li><a href='#summary.pcvrss'><p>Summarize a <code>pcvrss</code> object.</p></a></li>
<li><a href='#survregPlot'><p>Function to visualize <code>survival::survreg</code> models fit by <code>fitGrowth</code>.</p></a></li>
<li><a href='#testGrowth'><p>Hypothesis testing for fitGrowth models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plant Phenotyping and Bayesian Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josh Sumner &lt;jsumner@danforthcenter.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyse common types of plant phenotyping data, provide a simplified interface
	to longitudinal growth modeling and select Bayesian statistics,
	and streamline use of 'PlantCV' output.
	Several Bayesian methods and reporting guidelines for Bayesian methods are described in
	Kruschke (2018) &lt;<a href="https://doi.org/10.1177%2F2515245918771304">doi:10.1177/2515245918771304</a>&gt;,
	Kruschke (2013) &lt;<a href="https://doi.org/10.1037%2Fa0029146">doi:10.1037/a0029146</a>&gt;, and Kruschke (2021) &lt;<a href="https://doi.org/10.1038%2Fs41562-021-01177-7">doi:10.1038/s41562-021-01177-7</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>FactoMineR, rlang, stats, utils, methods, data.table, ggplot2,
ggridges, igraph, jsonlite, lme4, patchwork, extraDistr,
parallel, bayestestR, viridis, mgcv, quantreg, nlme, splines,
lmeSplines, scales, survival, car</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, brms, flexsurv, curl, cmdstanr, rstan,
caret, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/danforthcenter/pcvr">https://github.com/danforthcenter/pcvr</a>, <a href="https://plantcv.org/">https://plantcv.org/</a>,
<a href="https://danforthcenter.github.io/pcvr/">https://danforthcenter.github.io/pcvr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/danforthcenter/pcvr/issues">https://github.com/danforthcenter/pcvr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-06 20:16:05 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Josh Sumner <a href="https://orcid.org/0000-0002-3399-9063"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jeffrey Berry <a href="https://orcid.org/0000-0002-8064-9787"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Noah Fahlgren <a href="https://orcid.org/0000-0002-5597-4537"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Donald Danforth Plant Science Center [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-06 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='awkHelper'>subset helper function for use reading in large data, called in pcv.sub.read</h2><span id='topic+awkHelper'></span>

<h3>Description</h3>

<p>subset helper function for use reading in large data, called in pcv.sub.read
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awkHelper(inputFile, filters, awk = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="awkHelper_+3A_inputfile">inputFile</code></td>
<td>
<p>Path to csv file of plantCV output, should be provided internally in read.pcv</p>
</td></tr>
<tr><td><code id="awkHelper_+3A_filters">filters</code></td>
<td>
<p>filtering conditions, see read.pcv for details. Format as
list(&quot;trait in area, perimeter&quot;, &quot;other contains stringToMatch&quot;)</p>
</td></tr>
<tr><td><code id="awkHelper_+3A_awk">awk</code></td>
<td>
<p>Optional awk command to use instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>awkHelper attempts to make awk commands from human readable input.
Currently when filters are supplied the input file has quotes removed by 'sed'
then is piped into awk, so an equivalent command line statement may be:
<code>sed 's/\"//g' pcvrTest2.csv | awk -F ','  '{ if (NR==1 || $18=="area") { print } }'</code>
</p>


<h3>Value</h3>

<p>Returns a character string representing a unix style awk statement
which is typically passed to <code>pipe</code> or used as a connection in <code>data.table::fread</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch(
  { # in case offline
    link1 &lt;- "https://gist.githubusercontent.com/seankross/"
    link2 &lt;- "a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv"
    file &lt;- paste0(link1, link2)
    awkHelper(file, list("gear in 4, 3"), awk = NULL)
    awkHelper(file, "gear contains 3", awk = NULL)
    # note that to be filtered the file has to exist on your local system, this example only shows
    # the output of awkHelper, which would then be executed by read.pcv on a unix system
    awkHelper(file, list("gear in 4, 3"), awk = "existing_command")
  },
  error = function(e) {
    message(e)
  }
)
</code></pre>

<hr>
<h2 id='barg'>Function to help fulfill elements of the Bayesian Analysis Reporting Guidelines.</h2><span id='topic+barg'></span>

<h3>Description</h3>

<p>The Bayesian Analysis Reporting Guidelines were put forward by Kruschke
(https://www.nature.com/articles/s41562-021-01177-7) to aide in reproducibility and documentation
of Bayesian statistical analyses that are sometimes unfamiliar to reviewers or scientists.
The purpose of this function is to summarize goodness of fit metrics from one or more Bayesian models
made by <a href="#topic+growthSS">growthSS</a> and <a href="#topic+fitGrowth">fitGrowth</a>. See details for explanations of those metrics and
the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barg(fit, ss = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barg_+3A_fit">fit</code></td>
<td>
<p>The brmsfit object or a list of brmsfit objects in the case that you split models to run
on subsets of the data for computational simplicity.</p>
</td></tr>
<tr><td><code id="barg_+3A_ss">ss</code></td>
<td>
<p>The growthSS output used to specify the model. If fit is a list then this can either be one
growthSS list in which case the priors are assumed to be the same for each model or it can be a list
of the same length as fit. Note that the only parts of this which are used are the <code>call$start</code>
which is expected to be a call, <code>pcvrForm</code>, and <code>df</code> list elements,
so if you have a list of brmsfit objects and no ss object you can specify a stand-in list. This
can also be left NULL (the default) and posterior predictive plots and prior predictive plots will
not be made.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><b>General</b>: This includes chain number, length, and total divergent transitions per
model. Divergent transitions are a marker that the MCMC had something go wrong.
Conceptually it may be helpful to think about rolling a marble over a 3D curve then having the
marble suddenly jolt in an unexpected direction, something happened that suggests a
problem/misunderstood surface. In practice you want extremely few (ideally no) divergences.
If you do have divergences then consider specifying more control parameters
(see brms::brm or examples for <a href="#topic+fitGrowth">fitGrowth</a>). If the problem persists then the model may need
to be simplified. For more information on MCMC and divergence see the stan
manual (https://mc-stan.org/docs/2_19/reference-manual/divergent-transitions).
</p>
</li>
<li> <p><b>ESS</b>: ESS stands for Effective Sample Size and is a goodness of fit metric that
approximates the number of independent replicates that would equate to the same amount of
information as the (autocorrelated) MCMC iterations. ESS of 1000+ is often considered as a pretty
stable value, but more is better. Still, 100 per chain may be plenty depending on your
applications and the inference you wish to do. One of the benefits to using lots of chains and/or
longer chains is that you will get more complete information and that benefit will be shown by a
larger ESS. This is separated into &quot;bulk&quot; and &quot;tail&quot; to represent the middle and tails of the
posterior distribution, since those can sometimes have very different sampling behavior.
A summary and the total values are returned, with the summary being useful if several models are
included in a list for fit argument
</p>
</li>
<li> <p><b>Rhat</b>: Rhat is a measure of &quot;chain mixture&quot;. It compares the between vs within chain
values to assess how well the chains mixed. If chains did not mix well then Rhat will be greater
than 1, with 1.05 being a broadly
agreed upon cutoff to signify a problem. Running longer chains should result in lower Rhat
values. The default in brms is to run 4 chains, partially to ensure that there is a good chance
to check that the chains mixed well via Rhat. A summary and the total values are returned, with
the summary being useful if several models are included in a list for fit argument
</p>
</li>
<li> <p><b>NEFF</b>: NEFF is the NEFF ratio (Effective Sample Size over Total MCMC Sample Size).
Values greater than 0.5 are generally considered good, but there is a consensus that lower can be
fine down to about 0.1. A summary and the total values are returned, with the summary being
useful if several models are included in a list for fit argument
</p>
</li>
<li> <p><b>priorPredictive</b>: A plot of data simulated from the prior using <a href="#topic+plotPrior">plotPrior</a>.
This should generate data that is biologically plausible for your situation, but it will
probably be much more variable than your data. That is the effect of the mildly informative thick
tailed lognormal priors. If you specified non-default style priors then this currently will not
work.
</p>
</li>
<li> <p><b>posteriorPredictive</b>: A plot of each model's posterior predictive interval over time.
This is the same as plots returned from <a href="#topic+growthPlot">growthPlot</a> and shows 1-99
coming to a mean yellow trend line. These should encompass the overwhelming majority of your data
and ideally match the variance pattern that you see in your data. If parts of the predicted
interval are biologically impossible (area below 0, percentage about 100
model should be reconsidered.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list containing Rhat, ESS, NEFF, and Prior/Posterior Predictive plots.
See details for interpretation.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotPrior">plotPrior</a> for visual prior predictive checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group, sigma = "logistic",
  df = simdf, start = list(
    "A" = 130, "B" = 12, "C" = 3,
    "sigmaA" = 20, "sigmaB" = 10, "sigmaC" = 2
  ), type = "brms"
)
fit_test &lt;- fitGrowth(ss,
  iter = 600, cores = 1, chains = 1, backend = "cmdstanr",
  sample_prior = "only" # only sampling from prior for speed
)
barg(fit_test, ss)
fit_2 &lt;- fit_test
fit_list &lt;- list(fit_test, fit_2)
x &lt;- barg(fit_list, list(ss, ss))


</code></pre>

<hr>
<h2 id='brmPlot'>Function to visualize brms models similar to those made using growthSS outputs.</h2><span id='topic+brmPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a> (and similar models made through other
means) can be visualized easily using this function. This will generally be called by
<code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  hierarchy_value = NULL,
  vir_option = "plasma"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brmPlot_+3A_fit">fit</code></td>
<td>
<p>A brmsfit object, similar to those fit with <code><a href="#topic+growthSS">growthSS</a></code> outputs.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs specifying the outcome,
predictor, and grouping structure of the data as <code>outcome ~ predictor|individual/group</code>.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_df">df</code></td>
<td>
<p>An optional dataframe to use in plotting observed growth curves on top of the model.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the available data has not reached some point (such as asymptotic size),
although prediction using splines outside of the observed range is not necessarily reliable.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_hierarchy_value">hierarchy_value</code></td>
<td>
<p>If a hierarchical model is being plotted, what value should the
hiearchical predictor be? If left NULL (the default) the mean value is used.</p>
</td></tr>
<tr><td><code id="brmPlot_+3A_vir_option">vir_option</code></td>
<td>
<p>Viridis color scale to use for plotting credible intervals. Defaults to &quot;plasma&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing a brms model's credible
intervals and optionally the individual growth lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim(
  "logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group, sigma = "spline",
  list("A" = 130, "B" = 10, "C" = 3),
  df = simdf, type = "brms"
)
fit &lt;- fitGrowth(ss, backend = "cmdstanr", iter = 500, chains = 1, cores = 1)
growthPlot(fit = fit, form = y ~ time | group, groups = "a", df = ss$df)


</code></pre>

<hr>
<h2 id='brmSurvPlot'>Function to visualize brms survival models specified using growthSS.</h2><span id='topic+brmSurvPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means)
can be visualized easily using this function. This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmSurvPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brmSurvPlot_+3A_fit">fit</code></td>
<td>
<p>A brmsfit object, similar to those fit with <code><a href="#topic+growthSS">growthSS</a></code> outputs.</p>
</td></tr>
<tr><td><code id="brmSurvPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs specifying the outcome,
predictor, and grouping structure of the data as <code>outcome ~ predictor|individual/group</code>.</p>
</td></tr>
<tr><td><code id="brmSurvPlot_+3A_df">df</code></td>
<td>
<p>An optional dataframe to use in plotting observed growth curves on top of the model.</p>
</td></tr>
<tr><td><code id="brmSurvPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="brmSurvPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the available data has not reached some point (such as asymptotic size),
although prediction using splines outside of the observed range is not necessarily reliable.</p>
</td></tr>
<tr><td><code id="brmSurvPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing a brms model's credible
intervals and optionally the individual growth lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
df &lt;- growthSim("exponential",
  n = 20, t = 50,
  params = list("A" = c(1, 1), "B" = c(0.15, 0.1))
)
ss1 &lt;- growthSS(
  model = "survival weibull", form = y &gt; 100 ~ time | id / group,
  df = df, start = c(0, 5)
)
fit1 &lt;- fitGrowth(ss1, iter = 600, cores = 2, chains = 2, backend = "cmdstanr")
brmSurvPlot(fit1, form = ss1$pcvrForm, df = ss1$df)

# note that using the cumulative hazard to calculate survival is likely to underestimate
# survival in these plots if events do not start immediately.
ss2 &lt;- growthSS(
  model = "survival binomial", form = y &gt; 100 ~ time | id / group,
  df = df, start = c(-4, 3)
)
fit2 &lt;- fitGrowth(ss2, iter = 600, cores = 2, chains = 2, backend = "cmdstanr")
brmSurvPlot(fit2, form = ss2$pcvrForm, df = ss2$df)


</code></pre>

<hr>
<h2 id='brmViolin'>Function to visualize hypotheses tested on brms models similar to those made using growthSS outputs.</h2><span id='topic+brmViolin'></span>

<h3>Description</h3>

<p>Function to visualize hypotheses tested on brms models similar to those made using growthSS outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmViolin(fit, ss, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brmViolin_+3A_fit">fit</code></td>
<td>
<p>A brmsfit object or a dataframe of draws. If you need to combine multiple models then
use <a href="#topic+combineDraws">combineDraws</a> to merge their draws into a single dataframe for testing.</p>
</td></tr>
<tr><td><code id="brmViolin_+3A_ss">ss</code></td>
<td>
<p>A <code>pcvrss</code> object. The only component that is currently used is the pcvrForm.</p>
</td></tr>
<tr><td><code id="brmViolin_+3A_hypothesis">hypothesis</code></td>
<td>
<p>A hypothesis expressed as a character string in the style of that used by
<code>brms::hypothesis</code> and <a href="#topic+testGrowth">testGrowth</a>. Note that currently this only supports hypotheses
using two parameters from the model at a time (ie, &quot;groupA / groupB &gt; 1.05&quot; works but
&quot;(groupA / groupB) - (groupC / groupD) &gt; 1&quot; does not). In the hypothesis &quot;...&quot; can be used to mean
&quot;all groups for this parameter&quot; so that the hypothesis &quot;... / A_group1 &gt; 1.05&quot; would include all
the &quot;A&quot; coefficients for groups 1:N along the x axis, see examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing a brms model's posterior distributions
as violins and filled by posterior probability of some hypothesis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
simdf &lt;- growthSim(
  "logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 180, 190, 160), "B" = c(13, 11, 10, 10), "C" = c(3, 3, 3.25, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group, sigma = "int",
  list("A" = 130, "B" = 10, "C" = 3),
  df = simdf, type = "brms"
)

fit &lt;- fitGrowth(ss, backend = "cmdstanr", iter = 500, chains = 1, cores = 1)
brmViolin(fit, ss, ".../A_groupd &gt; 1.05") # all groups used
brmViolin(fit, ss, "A_groupa/A_groupd &gt; 1.05") # only these two groups


</code></pre>

<hr>
<h2 id='bw.outliers'>Remove outliers from bellwether data using cook's distance</h2><span id='topic+bw.outliers'></span>

<h3>Description</h3>

<p>Remove outliers from bellwether data using cook's distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.outliers(
  df = NULL,
  phenotype,
  naTo0 = FALSE,
  group = c(),
  cutoff = 3,
  outlierMethod = "cooks",
  plotgroup = c("barcode", "rotation"),
  plot = TRUE,
  x = NULL,
  traitCol = "trait",
  valueCol = "value",
  labelCol = "label",
  idCol = NULL,
  ncp = NULL,
  separate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw.outliers_+3A_df">df</code></td>
<td>
<p>Data frame to use. Can be in long or wide format.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_phenotype">phenotype</code></td>
<td>
<p>Column to use to classify outliers. If this is length &gt; 1 then
it is taken as the multi-value traits to use. See examples.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_nato0">naTo0</code></td>
<td>
<p>Logical, should NA values to changed to 0.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_group">group</code></td>
<td>
<p>Grouping variables to find outliers as a character vector.
This is typically time  and design variables (DAS, genotype, treatment, etc).
These are used as predictors for 'phenotype' in a generalized linear model.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff for something being an &quot;outlier&quot; expressed as a multiplier
on the mean of Cooks Distance for this data. This defaults to 5, with higher values
being more conservative (removing less of the data).</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_outliermethod">outlierMethod</code></td>
<td>
<p>Method to be used in detecting outliers.
Currently &quot;cooks&quot; and &quot;mahalanobis&quot; distances are supported, with &quot;mahalanobis&quot; only
being supported for multi-value traits.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_plotgroup">plotgroup</code></td>
<td>
<p>Grouping variables for drawing plots if plot=TRUE.
Typically this is an identifier for images of a plant
over time and defaults to c('barcode',&quot;rotation&quot;).</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_plot">plot</code></td>
<td>
<p>Logical, if TRUE then a list is returned with a ggplot and a dataframe.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_x">x</code></td>
<td>
<p>Optional specification for x axis variable if plot is true.
If left NULL (the default) then the first element of 'group' is used.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.
This should generally not need to be changed from the default.
If this and valueCol are present in colnames(df) then the data
is assumed to be in long format.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_labelcol">labelCol</code></td>
<td>
<p>Column with phenotype labels for long data, defaults to &quot;label&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_idcol">idCol</code></td>
<td>
<p>Column(s) that identify individuals over time.
Defaults to plotGroup.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_ncp">ncp</code></td>
<td>
<p>Optionally specify the number of principle components to be used for MV data outlier
detection with cooks distance. If left NULL (the default) then 3 will be used.</p>
</td></tr>
<tr><td><code id="bw.outliers_+3A_separate">separate</code></td>
<td>
<p>Optionally separate the data by some variable to speed up the modeling step.
If you have a design variable with
very many levels then it may be helpful to separate by that variable.
Note this will subset the data for each model so it will change
the outlier removal (generally to be more conservative).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe with outliers removed and optionally a plot
(if a plot is returned then output is a list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sv &lt;- growthSim("logistic",
  n = 5, t = 20,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
sv[130, ]$y &lt;- 500
sv_res &lt;- bw.outliers(
  df = sv, phenotype = "y", naTo0 = FALSE, cutoff = 15,
  group = c("time", "group"), outlierMethod = "cooks",
  plotgroup = "id", plot = TRUE
)
sv_res$plot

tryCatch(
  { # in case offline
    library(data.table)
    mvw &lt;- read.pcv(paste0(
      "https://media.githubusercontent.com/media/joshqsumner/",
      "pcvrTestData/main/pcv4-multi-value-traits.csv"
    ), mode = "wide", reader = "fread")
    mvw$genotype &lt;- substr(mvw$barcode, 3, 5)
    mvw$genotype &lt;- ifelse(mvw$genotype == "002", "B73",
      ifelse(mvw$genotype == "003", "W605S",
        ifelse(mvw$genotype == "004", "MM", "Mo17")
      )
    )
    mvw$fertilizer &lt;- substr(mvw$barcode, 8, 8)
    mvw$fertilizer &lt;- ifelse(mvw$fertilizer == "A", "100",
      ifelse(mvw$fertilizer == "B", "50", "0")
    )
    mvw &lt;- bw.time(mvw, timeCol = "timestamp", group = "barcode", plot = FALSE)

    phenotypes &lt;- which(grepl("hue_freq", colnames(mvw)))

    mvw2 &lt;- bw.outliers(
      df = mvw, phenotype = phenotypes, naTo0 = FALSE, outlierMethod = "cooks",
      group = c("DAS", "genotype", "fertilizer"), cutoff = 3, plotgroup = c("barcode", "rotation")
    )


    mvl &lt;- read.pcv(paste0(
      "https://media.githubusercontent.com/media/joshqsumner/",
      "pcvrTestData/main/pcv4-multi-value-traits.csv"
    ), mode = "long")
    mvl$genotype &lt;- substr(mvl$barcode, 3, 5)
    mvl$genotype &lt;- ifelse(mvl$genotype == "002", "B73",
      ifelse(mvl$genotype == "003", "W605S",
        ifelse(mvl$genotype == "004", "MM", "Mo17")
      )
    )
    mvl$fertilizer &lt;- substr(mvl$barcode, 8, 8)
    mvl$fertilizer &lt;- ifelse(mvl$fertilizer == "A", "100",
      ifelse(mvl$fertilizer == "B", "50", "0")
    )
    mvl &lt;- bw.time(mvl, timeCol = "timestamp", group = "barcode", plot = FALSE)

    mvl2 &lt;- bw.outliers(
      df = mvl, phenotype = "hue_frequencies", naTo0 = FALSE, outlierMethod = "cooks",
      group = c("DAS", "genotype", "fertilizer"), cutoff = 3, plotgroup = c("barcode", "rotation")
    )
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='bw.time'>Time conversion and plotting for bellwether data</h2><span id='topic+bw.time'></span>

<h3>Description</h3>

<p>Time conversion and plotting for bellwether data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.time(
  df = NULL,
  mode = c("DAS", "DAP", "DAE"),
  plantingDelay = NULL,
  phenotype = NULL,
  cutoff = 1,
  timeCol = "timestamp",
  group = "Barcodes",
  plot = TRUE,
  format = "%Y-%m-%d %H:%M:%S",
  traitCol = "trait",
  valueCol = "value",
  index = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw.time_+3A_df">df</code></td>
<td>
<p>Data frame to use, this can be in wide or long format.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_mode">mode</code></td>
<td>
<p>One of &quot;DAS&quot;, &quot;DAP&quot; or &quot;DAE&quot; (Days After Planting and Days After Emergence).
Defaults to adding all columns.
Note that if timeCol is not an integer then DAS is always returned.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_plantingdelay">plantingDelay</code></td>
<td>
<p>If 'mode' includes &quot;DAP&quot; then 'plantingDelay' is used to adjust &quot;DAS&quot;</p>
</td></tr>
<tr><td><code id="bw.time_+3A_phenotype">phenotype</code></td>
<td>
<p>If 'mode' includes &quot;DAE&quot; then this is the phenotype used to classify emergence.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_cutoff">cutoff</code></td>
<td>
<p>If 'mode' inlcludes &quot;DAE&quot; then this value is used to classify emergence.
Defaults to 1, meaning an image with a value of 1 or more for 'phenotype' has &quot;emerged&quot;.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_timecol">timeCol</code></td>
<td>
<p>Column of input time values, defaults to &quot;timestamp&quot;.
If this is not an integer then it is assumed to be
a timestamp in the format of the format argument.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_group">group</code></td>
<td>
<p>Grouping variables to specify unique plants as a character vector.
This defaults to &quot;Barcodes&quot;. These taken together should identify a unique plant across time,
although often &quot;angle&quot; or &quot;rotation&quot; should be added.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_plot">plot</code></td>
<td>
<p>Logical, should plots of the new time variables be printed?</p>
</td></tr>
<tr><td><code id="bw.time_+3A_format">format</code></td>
<td>
<p>An R POSIXct format, defaults to lemnatech standard format.
This is only used if timeCol is not an integer.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.
This should generally not need to be changed from the default.
If this and valueCol are present in colnames(df) then the data
is assumed to be in long format.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
<tr><td><code id="bw.time_+3A_index">index</code></td>
<td>
<p>Optionally a time to use as the beginning of the experiment. This
may be useful if you have multiple datasets or you are adding data from bw.water
and plants were watered before being imaged or if you want to index days off of
midnight. This defaults to NULL but will take any value coercible to POSIXct by
<code>as.POSIXct(... , tz="UTC")</code> such as &quot;2020-01-01 18:30:00&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe with new integer columns for different ways
of describing time in the experiment. If plot is TRUE then a ggplot is also returned as part of
a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- "https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/pcv4-single-value-traits.csv"
tryCatch(
  {
    sv &lt;- read.pcv(
      f,
      mode = "wide", reader = "fread"
    )
    sv$genotype = substr(sv$barcode, 3, 5)
    sv$genotype = ifelse(sv$genotype == "002", "B73",
      ifelse(sv$genotype == "003", "W605S",
        ifelse(sv$genotype == "004", "MM", "Mo17")
      )
    )
    sv$fertilizer = substr(sv$barcode, 8, 8)
    sv$fertilizer = ifelse(sv$fertilizer == "A", "100",
      ifelse(sv$fertilizer == "B", "50", "0")
    )
    sv &lt;- bw.time(sv,
      plantingDelay = 0, phenotype = "area_pixels", cutoff = 10,
      timeCol = "timestamp", group = c("barcode", "rotation"), plot = FALSE
    )

    svl &lt;- read.pcv(
      f,
      mode = "long", reader = "fread"
    )
    svl$genotype = substr(svl$barcode, 3, 5)
    svl$genotype = ifelse(svl$genotype == "002", "B73",
      ifelse(svl$genotype == "003", "W605S",
        ifelse(svl$genotype == "004", "MM", "Mo17")
      )
    )
    svl$fertilizer = substr(svl$barcode, 8, 8)
    svl$fertilizer = ifelse(svl$fertilizer == "A", "100",
      ifelse(svl$fertilizer == "B", "50", "0")
    )
    svl &lt;- bw.time(svl,
      plantingDelay = 0, phenotype = "area_pixels", cutoff = 10, timeCol = "timestamp",
      group = c("barcode", "rotation"), plot = FALSE
    )
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='bw.water'>Read in lemnatech watering data from metadata.json files</h2><span id='topic+bw.water'></span>

<h3>Description</h3>

<p>Read in lemnatech watering data from metadata.json files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.water(file = NULL, envKey = "environment")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw.water_+3A_file">file</code></td>
<td>
<p>Path to a json file of lemnatech metadata.</p>
</td></tr>
<tr><td><code id="bw.water_+3A_envkey">envKey</code></td>
<td>
<p>Character string representing the json key for environment data.
By default this is set to &quot;environment&quot;.
Currently there are no situations where this makes sense to change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the bellwether watering data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch(
  {
    w &lt;- bw.water("https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/metadata.json")
  },
  error = function(e) {
    message(e)
  }
)
</code></pre>

<hr>
<h2 id='checkGroups'>Helper function to check groups in data.</h2><span id='topic+checkGroups'></span>

<h3>Description</h3>

<p>Helper function to check groups in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGroups(df, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkGroups_+3A_df">df</code></td>
<td>
<p>Data frame to use.</p>
</td></tr>
<tr><td><code id="checkGroups_+3A_group">group</code></td>
<td>
<p>Set of variables to use in grouping observations.
These taken together should identify a unique plant (or unique plant at a unique angle) across time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If there are duplicates in the grouping then this will return a message with code to start
checking the duplicates in your data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- growthSim("linear",
  n = 10, t = 10,
  params = list("A" = c(2, 1.5))
)
checkGroups(df, c("time", "id", "group"))
df$time[12] &lt;- 3
checkGroups(df, c("time", "id", "group"))

</code></pre>

<hr>
<h2 id='combineDraws'>Combine Draws From brms Models</h2><span id='topic+combineDraws'></span>

<h3>Description</h3>

<p>Helper function for binding draws from several <code>brms</code> models to make a data.frame
for use with <code>brms::hypothesis()</code>. This will also check that the draws are comparable using
basic model metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDraws(..., message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineDraws_+3A_...">...</code></td>
<td>
<p>Some number of brmsfit objects and/or dataframes of draws
(should generally be the same type of model fit to different data)</p>
</td></tr>
<tr><td><code id="combineDraws_+3A_message">message</code></td>
<td>
<p>Logical, should messages about possible problems be printed? Default is TRUE.
This will warn if models may not have converged, if there are different numbers of draws in
the objects, or if models have different formulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe of posterior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note that this example will fit several bayesian models and may run for several minutes.

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list(
    "A" = c(200, 160, 220, 200, 140, 300),
    "B" = c(13, 11, 10, 9, 16, 12),
    "C" = c(3, 3.5, 3.2, 2.8, 3.3, 2.5)
  )
)
ss_ab &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  sigma = "logistic", df = simdf[simdf$group %in% c("a", "b"), ],
  start = list(
    "A" = 130, "B" = 12, "C" = 3,
    "sigmaA" = 15, "sigmaB" = 10, "sigmaC" = 3
  ), type = "brms"
)

ss_cd &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  sigma = "logistic", df = simdf[simdf$group %in% c("c", "d"), ],
  start = list(
    "A" = 130, "B" = 12, "C" = 3,
    "sigmaA" = 15, "sigmaB" = 10, "sigmaC" = 3
  ), type = "brms"
)

ss_ef &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  sigma = "logistic", df = simdf[simdf$group %in% c("e", "f"), ],
  start = list(
    "A" = 130, "B" = 12, "C" = 3,
    "sigmaA" = 15, "sigmaB" = 10, "sigmaC" = 3
  ), type = "brms"
)
ss_ef2 &lt;- growthSS(
  model = "gompertz", form = y ~ time | id / group,
  sigma = "logistic", df = simdf[simdf$group %in% c("e", "f"), ],
  start = list(
    "A" = 130, "B" = 12, "C" = 3,
    "sigmaA" = 15, "sigmaB" = 10, "sigmaC" = 3
  ), type = "brms"
)


fit_ab &lt;- fitGrowth(ss_ab, chains = 1, cores = 1, iter = 1000)
fit_ab2 &lt;- fitGrowth(ss_ab, chains = 1, cores = 1, iter = 1200)
fit_cd &lt;- fitGrowth(ss_cd, chains = 1, cores = 1, iter = 1000)
fit_ef &lt;- fitGrowth(ss_ef, chains = 1, cores = 1, iter = 1000)
fit_ef2 &lt;- fitGrowth(ss_ef2, chains = 1, cores = 1, iter = 1000)

x &lt;- combineDraws(fit_ab, fit_cd, fit_ef)
draws_ef &lt;- as.data.frame(fit_ef)
draws_ef &lt;- draws_ef[, grepl("^b_", colnames(draws_ef))]
x2 &lt;- combineDraws(fit_ab2, fit_cd, draws_ef)
x3 &lt;- combineDraws(fit_ab, fit_cd, fit_ef2)


</code></pre>

<hr>
<h2 id='conjugate'>Bayesian testing using conjugate priors and method of moments for single or multi value traits.</h2><span id='topic+conjugate'></span>

<h3>Description</h3>

<p>Function to perform bayesian tests and ROPE comparisons using single or multi value traits with
several distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugate(
  s1 = NULL,
  s2 = NULL,
  method = c("t", "gaussian", "beta", "binomial", "lognormal", "lognormal2", "poisson",
    "negbin", "vonmises", "vonmises2", "uniform", "pareto", "gamma", "bernoulli",
    "exponential", "bivariate_uniform", "bivariate_gaussian", "bivariate_lognormal"),
  priors = NULL,
  plot = FALSE,
  rope_range = NULL,
  rope_ci = 0.89,
  cred.int.level = 0.89,
  hypothesis = "equal",
  support = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjugate_+3A_s1">s1</code></td>
<td>
<p>A data.frame or matrix of multi value traits or a vector of single value traits.
If a multi value trait is used then column names should include a number representing the &quot;bin&quot;.
Alternatively for distributions other than &quot;binomial&quot; (which requires list data
with &quot;successes&quot; and &quot;trials&quot; as numeric vectors in the list, see examples)
this can be a formula specifying <code>outcome ~ group</code> where group has exactly 2
levels. If using wide MV trait data then the formula should specify column positions ~ grouping
such as <code>1:180 ~ group</code>.
This sample is shown in red if plotted.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_s2">s2</code></td>
<td>
<p>An optional second sample, or if s1 is a formula then this should be a dataframe.
This sample is shown in blue if plotted.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_method">method</code></td>
<td>
<p>The distribution/method to use.
Currently &quot;t&quot;, &quot;gaussian&quot;, &quot;beta&quot;, &quot;binomial&quot;, &quot;lognormal&quot;, &quot;lognormal2&quot;, &quot;poisson&quot;,
&quot;negbin&quot; (negative binomial), &quot;uniform&quot;, &quot;pareto&quot;, &quot;gamma&quot;, &quot;bernoulli&quot;, &quot;exponential&quot;,
&quot;vonmises&quot;, and &quot;vonmises2&quot; are supported.
The count (binomial, poisson and negative binomial), bernoulli, exponential,
and pareto distributions are only implemented for single value traits due to their updating
and/or the nature of the input data.
The &quot;t&quot; and &quot;gaussian&quot; methods both use a T distribution with &quot;t&quot; testing for a difference
of means and &quot;gaussian&quot; testing for a difference in the distributions (similar to a Z test).
Both Von Mises options are for use with circular data (for instance hue values when the circular
quality of the data is relevant). Note that non-circular distributions can be compared to each other.
This should only be done with caution. Make sure you understand the interpretation of any
comparison you are doing if you specify two methods (c(&quot;gaussian&quot;, &quot;lognormal&quot;) as an arbitrary
example).
There are also 3 bivariate conjugate priors that are supported for use with single value data.
Those are &quot;bivariate_uniform&quot;, &quot;bivariate_gaussian&quot; and &quot;bivariate_lognormal&quot;.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_priors">priors</code></td>
<td>
<p>Prior distributions described as a list of lists.
If this is a single list then it will be duplicated for the second sample,
which is generally a good idea if both
samples use the same distribution (method).
Elements in the inner lists should be named for the parameter they represent (see examples).
These names vary by method (see details).
By default this is NULL and weak priors (generally jeffrey's priors) are used.
The <code>posterior</code> part of output can also be recycled as a new prior if Bayesian
updating is appropriate for your use.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_plot">plot</code></td>
<td>
<p>Logical, should a ggplot be made and returned.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_rope_range">rope_range</code></td>
<td>
<p>Optional vector specifying a region of practical equivalence.
This interval is considered practically equivalent to no effect.
Kruschke (2018) suggests c(-0.1, 0.1) as a broadly reasonable ROPE for standardized parameters.
That range could also be rescaled by a standard deviation/magnitude for
non-standardized parameters, but ultimately this should be informed by your
setting and scientific question.
See Kruschke (2018) for details on ROPE and other Bayesian methods to aide
decision-making <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>
and <a href="https://doi.org/10.1037/a0029146">doi:10.1037/a0029146</a>.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_rope_ci">rope_ci</code></td>
<td>
<p>The credible interval probability to use for ROPE. Defaults to 0.89.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_cred.int.level">cred.int.level</code></td>
<td>
<p>The credible interval probability to use
in computing HDI for samples, defaults to 0.89.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_hypothesis">hypothesis</code></td>
<td>
<p>Direction of a hypothesis if two samples are provided.
Options are &quot;unequal&quot;, &quot;equal&quot;, &quot;greater&quot;, and &quot;lesser&quot;,
read as &quot;sample1 greater than sample2&quot;.</p>
</td></tr>
<tr><td><code id="conjugate_+3A_support">support</code></td>
<td>
<p>Optional support vector to include all possible values the random variable
(samples) might take. This defaults to NULL in which case each method will use default
behavior to attempt to calculate a dense support, but it is a good idea to supply this
with some suitable vector. For example, the Beta method uses <code>seq(0.0001, 0.9999, 0.0001)</code>
for support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior distributions default to be weakly informative and in some cases you may wish to change them.
</p>

<ul>
<li><p><strong>&quot;t&quot; and &quot;gaussian&quot;:</strong> <code>priors = list( mu=c(0,0),n=c(1,1),s2=c(20,20) ) </code>,
where mu is the mean, n is the number of prior observations, and s2 is variance
</p>
</li>
<li><p><strong>&quot;beta&quot;, &quot;bernoulli&quot;, and &quot;binomial&quot;:</strong>
<code>priors = list( a=c(0.5, 0.5), b=c(0.5, 0.5) )</code>,
where a and b are shape parameters of the beta distribution. Note that for the binomial
distribution this is used as the prior for success probability P,
which is assumed to be beta distributed as in a beta-binomial distribution.
</p>
</li>
<li><p><strong>&quot;lognormal&quot;: </strong> <code>priors = list(mu = 0, sd = 5) </code>,
where mu and sd describe the normal distribution of the mean parameter for lognormal data.
Note that these values are on the log scale.
</p>
</li>
<li><p><strong>&quot;lognormal2&quot;: </strong> <code>priors = list(a = 1, b = 1) </code>,
where a and b are the shape and scale parameters of the gamma distribution of lognormal data's
precision parameter (using the alternative mu, precision paramterization).

</p>
</li>
<li><p><strong>&quot;gamma&quot;: </strong> <code>priors = list(shape = 0.5, scale = 0.5, known_shape = 1)</code>,
where shape and scale are the respective parameters of the gamma distributed rate
(inverse of scale) parameter of gamma distributed data.
</p>
</li>
<li><p><strong>&quot;poisson&quot; and &quot;exponential&quot;: </strong> <code>priors = list(a=c(0.5,0.5),b=c(0.5,0.5))</code>,
where a and b are shape parameters of the gamma distribution.
</p>
</li>
<li><p><strong>&quot;negbin&quot;: </strong> <code>priors = list(r=c(10,10), a=c(0.5,0.5),b=c(0.5,0.5))</code>,
where r is the r parameter of the negative binomial distribution
(representing the number of successes required)
and where a and b are shape parameters of the beta distribution.
Note that the r value is not updated.
The conjugate beta prior is only valid when r is fixed and known,
which is a limitation for this method.
</p>
</li>
<li><p><strong>&quot;uniform&quot;: </strong> <code>list(scale = 0.5, location = 0.5)</code>, where scale is the
scale parameter of the pareto distributed upper boundary and location is the location parameter
of the pareto distributed upper boundary. Note that different sources will use different
terminology for these parameters. These names were chosen for consistency with the
<code>extraDistr</code> implementation of the pareto distribution. On Wikipedia the parameters are
called shape and scale, corresponding to extraDistr's scale and location respecitvely, which
can be confusing. Note that the lower boundary of the uniform is assumed to be 0.

</p>
</li>
<li><p><strong>&quot;pareto&quot;: </strong> <code>list(a = 1, b = 1, known_location = min(data))</code>, where
a and b are the shape and scale parameters of the gamma distribution of the pareto distribution's
scale parameter. In this case location is assumed to be constant and known, which is less of
a limitation than knowing r for the negative binomial method since location will generally be
right around/just under the minimum of the sample data. Note that the pareto method is only
implemented currently for single value traits since one of the statistics needed to update
the gamma distribution here is the product of the data and we do not currently have a method
to calculate a similar sufficient statistic from multi value traits.

</p>
</li>
<li><p><strong>&quot;vonmises&quot;: </strong> <code>list(mu = 0, kappa = 0.5, boundary = c(-pi, pi),
    known_kappa = 1, n = 1)</code>, where mu is the direction of the circular distribution (the mean),
kappa is the precision of the mean, boundary is a vector including the two values that are the
where the circular data &quot;wraps&quot; around the circle, known_kappa is the fixed value of precision
for the total distribution, and n is the number of prior observations. This Von Mises option
updates the conjugate prior for the mean direction, which is itself Von-Mises distributed. This
in some ways is analogous to the T method, but assuming a fixed variance when the mean is
updated. Note that due to how the rescaling works larger circular boundaries can be slow to
plot.

</p>
</li>
<li><p><strong>&quot;vonmises2&quot;: </strong> <code>priors = list(mu = 0, kappa = 0.5,
    boundary = c(-pi, pi), n = 1)</code>, where mu and kappa are mean direction and precision of the
von mises distribution, boundary is a vector including the two values that are the
where the circular data &quot;wraps&quot; around the circle, and n is the number of prior observations.
This Von-Mises implementation does not assume constant variance and instead uses MLE to estimate
kappa from the data and updates the kappa prior as a weighted average of the data and the prior.
The mu parameter is then updated per Von-Mises conjugacy.

</p>
</li>
<li><p><strong>&quot;bivariate_uniform&quot;: </strong>
<code>list(location_l = 1, location_u = 2, scale = 1)</code>, where scale is the
shared scale parameter of the pareto distributed upper and lower boundaries and location l and u
are the location parameters for the Lower (l) and Upper (u) boundaries of the uniform
distribution. Note this uses the same terminology for the pareto distribution's parameters
as the &quot;uniform&quot; method.

</p>
</li>
<li><p><strong>&quot;bivariate_gaussian&quot; and &quot;bivariate_lognormal&quot;: </strong>
<code>list(mu = 0, sd = 10, a = 1, b = 1)</code>, where mu and sd
are the mean and standard deviation of the Normal distribution of the data's mean and a and b
are the shape and scale of the gamma distribution on precision. Note that internally this uses
the Mu and Precision parameterization of the normal distribution and those are the parameters
shown in the plot and tested, but priors use Mu and SD for the normal distribution of the mean.

</p>
</li></ul>

<p>See examples for plots of these prior distributions.
</p>


<h3>Value</h3>

<p>A list with named elements:
</p>

<ul>
<li><p><strong>summary</strong>: A data frame containing HDI/HDE values for each sample and
the ROPE as well as posterior probability of the hypothesis and ROPE test (if specified).
The HDE is the &quot;Highest Density
Estimate&quot; of the posterior, that is the tallest part of the probability density function. The
HDI is the Highest Density Interval, which is an interval that contains X% of the posterior
distribution, so <code>cred.int.level = 0.8</code> corresponds to an HDI that includes 80 percent
of the posterior probability.
</p>
</li>
<li><p><strong>posterior</strong>: A list of updated parameters in the same format as the prior
for the given method. If desired this does allow for Bayesian updating.
</p>
</li>
<li><p><strong>plot_df</strong>: A data frame of probabilities along the support for each sample.
This is used for making the ggplot.
</p>
</li>
<li><p><strong>rope_df</strong>: A data frame of draws from the ROPE posterior.
</p>
</li>
<li><p><strong>plot</strong>: A ggplot showing the distribution of samples and optionally the
distribution of differences/ROPE
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mv_ln &lt;- mvSim(
  dists = list(
    rlnorm = list(meanlog = log(130), sdlog = log(1.2)),
    rlnorm = list(meanlog = log(100), sdlog = log(1.3))
  ),
  n_samples = 30
)

# lognormal mv
ln_mv_ex &lt;- conjugate(
  s1 = mv_ln[1:30, -1], s2 = mv_ln[31:60, -1], method = "lognormal",
  priors = list(mu = 5, sd = 2),
  plot = FALSE, rope_range = c(-40, 40), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal", support = NULL
)

# lognormal sv
ln_sv_ex &lt;- conjugate(
  s1 = rlnorm(100, log(130), log(1.3)), s2 = rlnorm(100, log(100), log(1.6)),
  method = "lognormal",
  priors = list(mu = 5, sd = 2),
  plot = FALSE, rope_range = NULL, rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal", support = NULL
)

# Z test mv example

mv_gauss &lt;- mvSim(
  dists = list(
    rnorm = list(mean = 50, sd = 10),
    rnorm = list(mean = 60, sd = 12)
  ),
  n_samples = 30
)

gauss_mv_ex &lt;- conjugate(
  s1 = mv_gauss[1:30, -1], s2 = mv_gauss[31:60, -1], method = "gaussian",
  priors = list(mu = 30, n = 1, s2 = 100),
  plot = FALSE, rope_range = c(-25, 25), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal", support = NULL
)

# T test sv example

gaussianMeans_sv_ex &lt;- conjugate(
  s1 = rnorm(10, 50, 10), s2 = rnorm(10, 60, 12), method = "t",
  priors = list(mu = 30, n = 1, s2 = 100),
  plot = FALSE, rope_range = c(-5, 8), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal", support = NULL
)

# beta mv example

set.seed(123)
mv_beta &lt;- mvSim(
  dists = list(
    rbeta = list(shape1 = 5, shape2 = 8),
    rbeta = list(shape1 = 10, shape2 = 10)
  ),
  n_samples = c(30, 20)
)

beta_mv_ex &lt;- conjugate(
  s1 = mv_beta[1:30, -1], s2 = mv_beta[31:50, -1], method = "beta",
  priors = list(a = 0.5, b = 0.5),
  plot = FALSE, rope_range = c(-0.1, 0.1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# beta sv example

beta_sv_ex &lt;- conjugate(
  s1 = rbeta(20, 5, 5), s2 = rbeta(20, 8, 5), method = "beta",
  priors = list(a = 0.5, b = 0.5),
  plot = FALSE, rope_range = c(-0.1, 0.1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# binomial sv example
# note that specifying trials = 20 would also work
# and the number of trials will be recycled to the length of successes

binomial_sv_ex &lt;- conjugate(
  s1 = list(successes = c(15, 14, 16, 11), trials = c(20, 20, 20, 20)),
  s2 = list(successes = c(7, 8, 10, 5), trials = c(20, 20, 20, 20)), method = "binomial",
  priors = list(a = 0.5, b = 0.5),
  plot = FALSE, rope_range = c(-0.1, 0.1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# poisson sv example

poisson_sv_ex &lt;- conjugate(
  s1 = rpois(20, 10), s2 = rpois(20, 8), method = "poisson",
  priors = list(a = 0.5, b = 0.5),
  plot = FALSE, rope_range = c(-1, 1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# negative binomial sv example
# knowing r (required number of successes) is an important caveat for this method.
# in the current implementation we suggest using the poisson method for data such as leaf counts

negbin_sv_ex &lt;- conjugate(
  s1 = rnbinom(20, 10, 0.5), s2 = rnbinom(20, 10, 0.25), method = "negbin",
  priors = list(r = 10, a = 0.5, b = 0.5),
  plot = FALSE, rope_range = c(-1, 1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# von mises mv example

mv_gauss &lt;- mvSim(
  dists = list(
    rnorm = list(mean = 50, sd = 10),
    rnorm = list(mean = 60, sd = 12)
  ),
  n_samples = c(30, 40)
)
vm1_ex &lt;- conjugate(
  s1 = mv_gauss[1:30, -1],
  s2 = mv_gauss[31:70, -1],
  method = "vonmises",
  priors = list(mu = 45, kappa = 1, boundary = c(0, 180), known_kappa = 1, n = 1),
  plot = FALSE, rope_range = c(-1, 1), rope_ci = 0.89,
  cred.int.level = 0.89, hypothesis = "equal"
)

# von mises 2 sv example
vm2_ex &lt;- conjugate(
  s1 = brms::rvon_mises(10, 2, 2),
  s2 = brms::rvon_mises(15, 3, 3),
  method = "vonmises2",
  priors = list(mu = 0, kappa = 0.5, boundary = c(-pi, pi), n = 1),
  cred.int.level = 0.95,
  plot = FALSE
)

</code></pre>

<hr>
<h2 id='cumulativePheno'>Reduce phenotypes in longitudinal data to cumulative sums of phenotypes.</h2><span id='topic+cumulativePheno'></span>

<h3>Description</h3>

<p>Often in bellwether experiments we are curious about the effect of
some treatment vs control. For certain routes in analysing the data this requires
considering phenotypes as relative differences compared to a control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulativePheno(
  df,
  phenotypes = NULL,
  group = "barcode",
  timeCol = "DAS",
  traitCol = "trait",
  valueCol = "value"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumulativePheno_+3A_df">df</code></td>
<td>
<p>Dataframe to use, this can be in long or wide format.</p>
</td></tr>
<tr><td><code id="cumulativePheno_+3A_phenotypes">phenotypes</code></td>
<td>
<p>A character vector of column names for the phenotypes
that should be compared against control.</p>
</td></tr>
<tr><td><code id="cumulativePheno_+3A_group">group</code></td>
<td>
<p>A character vector of column names that identify groups in the data.
Defaults to &quot;barcode&quot;. These groups will be calibrated separately, with the exception
of the group that identifies a control within the greater hierarchy.</p>
</td></tr>
<tr><td><code id="cumulativePheno_+3A_timecol">timeCol</code></td>
<td>
<p>Column name to use for time data.</p>
</td></tr>
<tr><td><code id="cumulativePheno_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.
This should generally not need to be changed from the default.
If this and valueCol are present in colnames(df) then the data
is assumed to be in long format.</p>
</td></tr>
<tr><td><code id="cumulativePheno_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with cumulative sum columns added for specified phenotypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- "https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/pcv4-single-value-traits.csv"
tryCatch(
  {
    sv &lt;- read.pcv(
      f,
      reader = "fread"
    )
    sv$genotype &lt;- substr(sv$barcode, 3, 5)
    sv$genotype &lt;- ifelse(sv$genotype == "002", "B73",
      ifelse(sv$genotype == "003", "W605S",
        ifelse(sv$genotype == "004", "MM", "Mo17")
      )
    )
    sv$fertilizer &lt;- substr(sv$barcode, 8, 8)
    sv$fertilizer &lt;- ifelse(sv$fertilizer == "A", "100",
      ifelse(sv$fertilizer == "B", "50", "0")
    )

    sv &lt;- bw.time(sv,
      plantingDelay = 0, phenotype = "area_pixels", cutoff = 10,
      timeCol = "timestamp", group = c("barcode", "rotation"), plot = TRUE
    )$data
    sv &lt;- bw.outliers(sv,
      phenotype = "area_pixels", group = c("DAS", "genotype", "fertilizer"),
      plotgroup = c("barcode", "rotation")
    )$data
    phenotypes &lt;- colnames(sv)[19:35]
    phenoForm &lt;- paste0("cbind(", paste0(phenotypes, collapse = ", "), ")")
    groupForm &lt;- "DAS+DAP+barcode+genotype+fertilizer"
    form &lt;- as.formula(paste0(phenoForm, "~", groupForm))
    sv &lt;- aggregate(form, data = sv, mean, na.rm = TRUE)
    pixels_per_cmsq &lt;- 42.5^2 # pixel per cm^2
    sv$area_cm2 &lt;- sv$area_pixels / pixels_per_cmsq
    sv$height_cm &lt;- sv$height_pixels / 42.5
    df &lt;- sv
    phenotypes &lt;- c("area_cm2", "height_cm")
    group &lt;- c("barcode")
    timeCol &lt;- "DAS"
    df &lt;- cumulativePheno(df, phenotypes, group, timeCol)


    sv_l &lt;- read.pcv(
      f,
      mode = "long", reader = "fread"
    )
    sv_l$genotype &lt;- substr(sv_l$barcode, 3, 5)
    sv_l$genotype &lt;- ifelse(sv_l$genotype == "002", "B73",
      ifelse(sv_l$genotype == "003", "W605S",
        ifelse(sv_l$genotype == "004", "MM", "Mo17")
      )
    )
    sv_l$fertilizer &lt;- substr(sv_l$barcode, 8, 8)
    sv_l$fertilizer &lt;- ifelse(sv_l$fertilizer == "A", "100",
      ifelse(sv_l$fertilizer == "B", "50", "0")
    )
    sv_l &lt;- bw.time(sv_l,
      plantingDelay = 0, phenotype = "area_pixels", cutoff = 10,
      timeCol = "timestamp", group = c("barcode", "rotation")
    )$data
    sv_l &lt;- cumulativePheno(sv_l,
      phenotypes = c("area_pixels", "height_pixels"),
      group = c("barcode", "rotation"), timeCol = "DAS"
    )
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='distributionPlot'>Function for plotting iterations of posterior distributions</h2><span id='topic+distributionPlot'></span>

<h3>Description</h3>

<p>Function for plotting iterations of posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distributionPlot(
  fits,
  form,
  df,
  priors = NULL,
  params = NULL,
  maxTime = NULL,
  patch = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distributionPlot_+3A_fits">fits</code></td>
<td>
<p>A list of brmsfit objects following the same data over time.
Currently checkpointing is not supported.</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_form">form</code></td>
<td>
<p>A formula describing the growth model similar to <code><a href="#topic+growthSS">growthSS</a></code>
and <code><a href="#topic+brmPlot">brmPlot</a></code> such as: outcome ~ predictor |individual/group</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_df">df</code></td>
<td>
<p>data used to fit models (this is used to plot each subject's trend line).</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_priors">priors</code></td>
<td>
<p>a named list of samples from the prior distributions for each parameter in
<code>params</code>. This is only used if sample_prior=FALSE in the brmsfit object.
If left NULL then no prior is included.</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_params">params</code></td>
<td>
<p>a vector of parameters to include distribution plots of.
Defaults to NULL which will use all parameters from the top level model.</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_maxtime">maxTime</code></td>
<td>
<p>Optional parameter to designate a max time not observed in the models so far</p>
</td></tr>
<tr><td><code id="distributionPlot_+3A_patch">patch</code></td>
<td>
<p>Logical, should a patchwork plot be returned or should lists of ggplots be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot or a list of ggplots (depending on patch).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- "https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/brmsFits.rdata"
tryCatch(
  {
    print(load(url(f)))
    library(brms)
    library(ggplot2)
    library(patchwork)
    fits &lt;- list(fit_3, fit_15)
    form &lt;- y~time | id / group
    priors &lt;- list(
      "phi1" = rlnorm(2000, log(130), 0.25),
      "phi2" = rlnorm(2000, log(12), 0.25),
      "phi3" = rlnorm(2000, log(3), 0.25)
    )
    params &lt;- c("A", "B", "C")
    d &lt;- simdf
    maxTime &lt;- NULL
    patch &lt;- TRUE
    from3to25 &lt;- list(
      fit_3, fit_5, fit_7, fit_9, fit_11,
      fit_13, fit_15, fit_17, fit_19, fit_21, fit_23, fit_25
    )
    distributionPlot(
      fits = from3to25, form = y ~ time | id / group,
      params = params, d = d, priors = priors, patch = FALSE
    )
    distributionPlot(
      fits = from3to25, form = y ~ time | id / group,
      params = params, d = d, patch = FALSE
    )
  },
  error = function(e) {
    message(e)
  }
)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitGrowth'>Ease of use wrapper function for fitting various growth models specified by <a href="#topic+growthSS">growthSS</a></h2><span id='topic+fitGrowth'></span>

<h3>Description</h3>

<p>Ease of use wrapper function for fitting various growth models specified by <a href="#topic+growthSS">growthSS</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowth(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowth_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowth_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to model fitting functions determined by <code>ss$type</code>.
For type = &quot;nlme&quot; these are passed to <code>nlme::nlmeControl</code>, not <code>nlme::nlme</code>.
Additional arguments are documented in <a href="#topic+fitGrowthbrms">fitGrowthbrms</a>, <a href="#topic+fitGrowthnlme">fitGrowthnlme</a>,
<a href="#topic+fitGrowthnls">fitGrowthnls</a>, <a href="#topic+fitGrowthnlrq">fitGrowthnlrq</a>, <a href="#topic+fitGrowthmgcvgam">fitGrowthmgcvgam</a>, <a href="#topic+fitGrowthsurvreg">fitGrowthsurvreg</a>,
<a href="#topic+fitGrowthflexsurv">fitGrowthflexsurv</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fit model from the selected type.
</p>


<h3>See Also</h3>

<p><a href="#topic+growthPlot">growthPlot</a> for model visualization, <a href="#topic+testGrowth">testGrowth</a> for hypothesis testing,
<a href="#topic+barg">barg</a> for Bayesian model reporting metrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | group,
  df = simdf, type = "nls"
)
fitGrowth(ss)
ss &lt;- growthSS(
  model = "gam", form = y ~ time | group,
  df = simdf, type = "nls"
)
fitGrowth(ss)

</code></pre>

<hr>
<h2 id='fitGrowthbrms'>Ease of use brms wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthbrms'></span><span id='topic+fitGrowthbrmsgam'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthbrms(
  ss,
  iter = 2000,
  cores = getOption("mc.cores", 1),
  chains = 4,
  prior = NULL,
  backend = "cmdstanr",
  silent = 0,
  ...
)

fitGrowthbrmsgam(
  ss,
  iter = 2000,
  cores = getOption("mc.cores", 1),
  chains = 4,
  prior = NULL,
  backend = "cmdstanr",
  silent = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthbrms_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_iter">iter</code></td>
<td>
<p>A number of iterations to sample for each chain.
By default half this length is taken as warm-up for the MCMC algorithm.
This defaults to 2000.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_cores">cores</code></td>
<td>
<p>A number of cores to run in parallel.
This defaults to 1 if the &quot;mc.cores&quot; option is not set.
Generally this is specified as one core per chain so that the model is fit in parallel.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_chains">chains</code></td>
<td>
<p>A number of markov chains to use, this defaults to 4.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_prior">prior</code></td>
<td>
<p>A <code>brmsprior</code> object if <code>growthSS</code> did not have priors specified.
If left NULL (the default) and ss does not contain priors then a warning is
issued but the model will still attempt to fit.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_backend">backend</code></td>
<td>
<p>A backend for brms to use Stan through.
This defaults to use &quot;cmdstanr&quot;.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_silent">silent</code></td>
<td>
<p>Passed to <code>brms::brm</code> to control verbosity.
This defaults to 0, the most verbose option so that messages and progress are printed.
With changes to <code>cmdstanr</code> and <code>brms</code> this may be removed, but the option
will be available through <code>...</code>. Note that this is likely to print lots of
messages during warmup iterations as the MCMC gets started.</p>
</td></tr>
<tr><td><code id="fitGrowthbrms_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>brms::brm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsfit</code> object, see <code>?`brmsfit-class`</code> for details.
</p>

<hr>
<h2 id='fitGrowthflexsurv'>Ease of use wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthflexsurv'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthflexsurv(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthflexsurv_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthflexsurv_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>flexsurv::flexsurvreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>survreg</code> object.
</p>

<hr>
<h2 id='fitGrowthlm'>Ease of use lm wrapper function for fitting growth models specified by <code>mvSS</code></h2><span id='topic+fitGrowthlm'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthlm(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthlm_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>mvSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthlm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::lm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lm</code> object, see <code>?lm</code> for details.
</p>

<hr>
<h2 id='fitGrowthmgcvgam'>Ease of use mgcv wrapper function for fitting gams specified by <code>growthSS</code></h2><span id='topic+fitGrowthmgcvgam'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthmgcvgam(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthmgcvgam_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthmgcvgam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>mgcv::gam</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>gam</code> object, see <code>?gam</code> for details.
</p>

<hr>
<h2 id='fitGrowthnlme'>Ease of use nlme wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthnlme'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnlme(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnlme_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnlme_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>nlme::nlmeControl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>nlme</code> object, see <code>?nlme</code> for details.
</p>

<hr>
<h2 id='fitGrowthnlmegam'>Ease of use lme wrapper function for fitting gams specified by <code>growthSS</code></h2><span id='topic+fitGrowthnlmegam'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnlmegam(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnlmegam_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnlmegam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>nlme::lmeControl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lme</code> object, see <code>?lme</code> for details.
</p>

<hr>
<h2 id='fitGrowthnlrq'>Ease of use nlrq wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthnlrq'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnlrq(ss, cores = getOption("mc.cores", 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnlrq_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnlrq_+3A_cores">cores</code></td>
<td>
<p>Optionally specify how many cores to run in parallel if ss$taus is &gt;1L.
Defaults to 1 if mc.cores option is not set globally.</p>
</td></tr>
<tr><td><code id="fitGrowthnlrq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>quantreg::nlrq</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>nlrqModel</code> object if tau is length of 1 or a list of such models for multiple taus,
see <code>?quantreg::nlrq</code> or <code>?nls::nlsModel</code> for details.
</p>

<hr>
<h2 id='fitGrowthnlrqgam'>Ease of use rq wrapper function for fitting gams specified by <code>growthSS</code></h2><span id='topic+fitGrowthnlrqgam'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnlrqgam(ss, cores = getOption("mc.cores", 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnlrqgam_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnlrqgam_+3A_cores">cores</code></td>
<td>
<p>number of cores to run in parallel</p>
</td></tr>
<tr><td><code id="fitGrowthnlrqgam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>quantreg::rq</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rq</code> object, see <code>?rq</code> for details.
</p>

<hr>
<h2 id='fitGrowthnls'>Ease of use nls wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthnls'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnls(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnls_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnls_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::nls</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>nls</code> object, see <code>?nls</code> for details.
</p>

<hr>
<h2 id='fitGrowthnlsgam'>Ease of use lm wrapper function for fitting gams specified by <code>growthSS</code></h2><span id='topic+fitGrowthnlsgam'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthnlsgam(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthnlsgam_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthnlsgam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::lm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lm</code> object, see <code>?lm</code> for details.
</p>

<hr>
<h2 id='fitGrowthrq'>Ease of use rq wrapper function for fitting models specified by <code>mvSS</code></h2><span id='topic+fitGrowthrq'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthrq(ss, cores = getOption("mc.cores", 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthrq_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>mvSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthrq_+3A_cores">cores</code></td>
<td>
<p>number of cores to run in parallel</p>
</td></tr>
<tr><td><code id="fitGrowthrq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>quantreg::rq</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rq</code> object, see <code>?rq</code> for details.
</p>

<hr>
<h2 id='fitGrowthsurvreg'>Ease of use wrapper function for fitting growth models specified by <code>growthSS</code></h2><span id='topic+fitGrowthsurvreg'></span>

<h3>Description</h3>

<p>Helper function generally called from <a href="#topic+fitGrowth">fitGrowth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGrowthsurvreg(ss, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGrowthsurvreg_+3A_ss">ss</code></td>
<td>
<p>A list generated by <code>growthSS</code>.</p>
</td></tr>
<tr><td><code id="fitGrowthsurvreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>survival::survreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>survreg</code> object.
</p>

<hr>
<h2 id='flexsurvregPlot'>Function to visualize <code>flexsurv::flexsurvreg</code> models fit by <code>fitGrowth</code>.</h2><span id='topic+flexsurvregPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means) can be visualized easily using this function.
This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvregPlot(
  fit,
  form,
  groups = NULL,
  df = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flexsurvregPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit returned by <code>fitGrowth</code> with type=&quot;nls&quot;.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs
(or the <code>pcvrForm</code> part of the output) specifying the outcome,
predictor, and grouping structure of the data as <code>outcome ~ predictor|individual/group</code>.
If the individual and group are specified then the observed growth lines are plotted.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for nls models.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_timerange">timeRange</code></td>
<td>
<p>Ignored, included for compatibility with other plotting functions.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE. If TRUE then
viridis colormaps are used in the order of virMaps</p>
</td></tr>
<tr><td><code id="flexsurvregPlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length.
Defaults to &quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an survival model's survival function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "survival weibull", form = y &gt; 100 ~ time | id / group,
  df = df, type = "flexsurv"
)
fit &lt;- fitGrowth(ss)
flexsurvregPlot(fit, form = ss$pcvrForm, df = ss$df, groups = "a")
flexsurvregPlot(fit,
  form = ss$pcvrForm, df = ss$df,
  facetGroups = FALSE, groupFill = TRUE
)

</code></pre>

<hr>
<h2 id='frem'>Variance partitioning using Full Random Effects Models</h2><span id='topic+frem'></span>

<h3>Description</h3>

<p>Variance partitioning for phenotypes (over time) using fully random effects models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frem(
  df,
  des,
  phenotypes,
  timeCol = NULL,
  cor = TRUE,
  returnData = FALSE,
  combine = TRUE,
  markSingular = FALSE,
  time = NULL,
  time_format = "%Y-%m-%d",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frem_+3A_df">df</code></td>
<td>
<p>Dataframe containing phenotypes and design variables, optionally over time.</p>
</td></tr>
<tr><td><code id="frem_+3A_des">des</code></td>
<td>
<p>Design variables to partition variance for as a character vector.</p>
</td></tr>
<tr><td><code id="frem_+3A_phenotypes">phenotypes</code></td>
<td>
<p>Phenotype column names (data is assumed to be in wide format)
as a character vector.</p>
</td></tr>
<tr><td><code id="frem_+3A_timecol">timeCol</code></td>
<td>
<p>A column of the data that denotes time for longitudinal experiments.
If left NULL (the default) then all data is assumed to be from one timepoint.</p>
</td></tr>
<tr><td><code id="frem_+3A_cor">cor</code></td>
<td>
<p>Logical, should a correlation plot be made? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="frem_+3A_returndata">returnData</code></td>
<td>
<p>Logical, should the used to make plots be returned? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="frem_+3A_combine">combine</code></td>
<td>
<p>Logical, should plots be combined with patchwork?
Defaults to TRUE, which works well when there is a single timepoint being used.</p>
</td></tr>
<tr><td><code id="frem_+3A_marksingular">markSingular</code></td>
<td>
<p>Logical, should singular fits be marked in the variance explained plot?
This is FALSE by default but it is good practice to check with TRUE in some situations.
If TRUE this will add white markings to the plot where models had singular fits,
which is the most common problem with this type of model.</p>
</td></tr>
<tr><td><code id="frem_+3A_time">time</code></td>
<td>
<p>If the data contains multiple timepoints then which should be used?
This can be left NULL which will use the maximum time if <code>timeCol</code> is specified.
If a single number is provided then that time value will be used.
Multiple numbers will include those timepoints.
The string &quot;all&quot; will include all timepoints.</p>
</td></tr>
<tr><td><code id="frem_+3A_time_format">time_format</code></td>
<td>
<p>Format for non-integer time, passed to <code>strptime</code>,
defaults to &quot;%Y-%m-%d&quot;.</p>
</td></tr>
<tr><td><code id="frem_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>lme4::lmer</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a plot (if returnData=FALSE) or a list with a plot and
data/a list of dataframes (depending on returnData and cor).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(data.table)
set.seed(456)
df &lt;- data.frame(
  genotype = rep(c("g1", "g2"), each = 10),
  treatment = rep(c("C", "T"), times = 10),
  time = rep(c(1:5), times = 2),
  date_time = rep(paste0("2024-08-", 21:25), times = 2),
  pheno1 = rnorm(20, 10, 1),
  pheno2 = sort(rnorm(20, 5, 1)),
  pheno3 = sort(runif(20))
)
out &lt;- frem(df, des = "genotype", phenotypes = c("pheno1", "pheno2", "pheno3"), returnData = TRUE)
lapply(out, class)
frem(df,
  des = c("genotype", "treatment"), phenotypes = c("pheno1", "pheno2", "pheno3"),
  cor = FALSE
)
frem(df,
  des = "genotype", phenotypes = c("pheno1", "pheno2", "pheno3"),
  combine = FALSE, timeCol = "time", time = "all"
)
frem(df,
  des = "genotype", phenotypes = c("pheno1", "pheno2", "pheno3"),
  combine = TRUE, timeCol = "time", time = 1
)
frem(df,
  des = "genotype", phenotypes = c("pheno1", "pheno2", "pheno3"),
  cor = FALSE, timeCol = "time", time = 3:5, markSingular = TRUE
)
df[df$time == 3, "genotype"] &lt;- "g1"
frem(df,
  des = "genotype", phenotypes = c("pheno1", "pheno2", "pheno3"),
  cor = FALSE, timeCol = "date_time", time = "all", markSingular = TRUE
)

</code></pre>

<hr>
<h2 id='gam_diff'>Helper function for visualizing differences in GAMs fit with <code>mgcv::gam</code></h2><span id='topic+gam_diff'></span>

<h3>Description</h3>

<p>Note that using GAMs will be less useful than fitting parameterized models as supported by
<code>growthSS</code> and <code>fitGrowth</code> for common applications in plant phenotyping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam_diff(
  model,
  newdata = NULL,
  g1,
  g2,
  byVar = NULL,
  smoothVar = NULL,
  cis = seq(0.05, 0.95, 0.05),
  unconditional = TRUE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gam_diff_+3A_model">model</code></td>
<td>
<p>A model fit with smooth terms by <code>mgcv::gam</code></p>
</td></tr>
<tr><td><code id="gam_diff_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame of new data to use to make predictions. If this is left NULL
(the default) then
an attempt is made to make newdata using the first smooth term in the formula.
See examples for guidance on making appropriate newdata</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_g1">g1</code></td>
<td>
<p>A character string for the level of byVar to use as the first group to compare,
if plot=TRUE then this will be shown in blue.</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_g2">g2</code></td>
<td>
<p>The second group to compare (comparison will be g1 - g2). If plot=TRUE then this will be
shown in red.</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_byvar">byVar</code></td>
<td>
<p>Categorical variable name used to separate splines as a string.</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_smoothvar">smoothVar</code></td>
<td>
<p>The variable that splines were used on. This will often be a time variable.</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_cis">cis</code></td>
<td>
<p>Confidence interval levels, can be multiple. For example, 0.95 would return Q_0.025 and
Q_0.975 columns, and c(0.9, 0.95) would return Q_0.025, Q_0.05, Q_0.95, and Q_0.975 columns.
Defaults to <code>seq(0.05, 0.95, 0.05)</code></p>
</td></tr>
<tr><td><code id="gam_diff_+3A_unconditional">unconditional</code></td>
<td>
<p>Logical, should unconditional variance-covariance be used in calculating
standard errors. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="gam_diff_+3A_plot">plot</code></td>
<td>
<p>Logical, should a plot of the difference be returned? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe or a list containing a ggplot and a dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- pcvr::growthSim("logistic",
  n = 20, t = 25,
  params = list(
    "A" = c(200, 160),
    "B" = c(13, 11),
    "C" = c(3, 3.5)
  )
)

m &lt;- mgcv::gam(y ~ group + s(time, by = factor(group)), data = ex)

support &lt;- expand.grid(
  time = seq(min(ex$time), max(ex$time), length = 400),
  group = factor(unique(ex$group))
)

out &lt;- gam_diff(
  model = m, newdata = support, g1 = "a", g2 = "b",
  byVar = "group", smoothVar = "time", plot = TRUE
)
dim(out$data)
out$plot
out2 &lt;- gam_diff(
  model = m, g1 = "a", g2 = "b", byVar = NULL, smoothVar = NULL, plot = TRUE
)
</code></pre>

<hr>
<h2 id='growthPlot'>Function to visualize models made by <a href="#topic+fitGrowth">fitGrowth</a>.</h2><span id='topic+growthPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means) can be visualized easily using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growthPlot(
  fit,
  form,
  groups = NULL,
  df = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = !facetGroups,
  hierarchy_value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growthPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit object (or a list of <code>nlrq</code> models) as returned by <code>fitGrowth</code>.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code> part of the
output) specifying the outcome, predictor, and grouping structure of the data as
<code>outcome ~ predictor|individual/group</code>. Generally this is given directly from
the growthSS output (<code>ss$pcvrForm</code>). If the formula does not include both individuals
and groups then lines from the data will not be plotted which may be best if your data does not
specify unique individuals and your model does not include autocorrelation.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model and for making
predictions.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the avaiable data has not reached some point (such as asymptotic size).</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to the opposite of
facetGroups. If TRUE then
viridis colormaps are used in the order c('plasma', 'mako', 'viridis', 'inferno', 'cividis', 'magma',
'turbo', 'rocket'). Alternatively this can be given as a vector of
viridis colormap names to use in a different order than above.
Note that for brms models this is ignored except if used to specify a different viridis color map
to use.</p>
</td></tr>
<tr><td><code id="growthPlot_+3A_hierarchy_value">hierarchy_value</code></td>
<td>
<p>If a hierarchical model is being plotted, what value should the
hiearchical predictor be? If left NULL (the default) the mean value is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing a brms model's credible
intervals and optionally the individual growth lines.
</p>


<h3>See Also</h3>

<p><a href="#topic+growthSS">growthSS</a> and <a href="#topic+fitGrowth">fitGrowth</a> for making compatible models, <a href="#topic+testGrowth">testGrowth</a>
for hypothesis testing on compatible models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  df = simdf, type = "nls"
)
fit &lt;- fitGrowth(ss)
growthPlot(fit, form = ss$pcvrForm, df = ss$df)

</code></pre>

<hr>
<h2 id='growthSim'>Growth data simulating function</h2><span id='topic+growthSim'></span>

<h3>Description</h3>

<p>growthSim can be used to help pick reasonable parameters for common
growth models to use in prior distributions or to simulate data for example models/plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growthSim(
  model = c("logistic", "gompertz", "double logistic", "double gompertz",
    "monomolecular", "exponential", "linear", "power law", "frechet", "weibull",
    "gumbel", "logarithmic", "bragg", "lorentz", "beta"),
  n = 20,
  t = 25,
  params = list(),
  D = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growthSim_+3A_model">model</code></td>
<td>
<p>One of &quot;logistic&quot;, &quot;gompertz&quot;, &quot;weibull&quot;, &quot;frechet&quot;, &quot;gumbel&quot;, &quot;monomolecular&quot;,
&quot;exponential&quot;, &quot;linear&quot;, &quot;power law&quot;, &quot;logarithmic&quot;, &quot;bragg&quot;,
&quot;double logistic&quot;, or &quot;double gompertz&quot;.
Alternatively this can be a pseudo formula to generate data from a segmented growth curve by
specifying &quot;model1 + model2&quot;, see examples and <code><a href="#topic+growthSS">growthSS</a></code>.
Decay can be specified by including &quot;decay&quot; as part of the model such as &quot;logistic decay&quot; or
&quot;linear + linear decay&quot;. Count data can be specified with the &quot;count: &quot; prefix,
similar to using &quot;poisson: model&quot; in <a href="#topic+growthSS">growthSS</a>.
While &quot;gam&quot; models are supported by <code>growthSS</code>
they are not simulated by this function.</p>
</td></tr>
<tr><td><code id="growthSim_+3A_n">n</code></td>
<td>
<p>Number of individuals to simulate over time per each group in params</p>
</td></tr>
<tr><td><code id="growthSim_+3A_t">t</code></td>
<td>
<p>Max time (assumed to start at 1) to simulate growth to as an integer.</p>
</td></tr>
<tr><td><code id="growthSim_+3A_params">params</code></td>
<td>
<p>A list of numeric parameters. A, B, C notation is used in the order that parameters
appear in the formula (see examples). Number of groups is inferred from the length of these vectors
of parameters. In the case of the &quot;double&quot; models there are also A2, B2, and C2 terms.
Changepoints should be specified as &quot;changePointX&quot; or &quot;fixedChangePointX&quot; as in
<code><a href="#topic+growthSS">growthSS</a></code>.</p>
</td></tr>
<tr><td><code id="growthSim_+3A_d">D</code></td>
<td>
<p>If decay is being simulated then this is the starting point for decay. This defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument requires some understanding of how each growth model is parameterized.
Examples of each are below should help, as will the examples.
</p>

<ul>
<li> <p><b>Logistic</b>: 'A / (1 + exp( (B-x)/C) )'
Where A is the asymptote, B is the inflection point, C is the growth rate.
</p>
</li>
<li> <p><b>Gompertz</b>: 'A * exp(-B * exp(-C*x))'
Where A is the asymptote, B is the inflection point, C is the growth rate.
</p>
</li>
<li> <p><b>Weibull</b>: 'A * (1-exp(-(x/C)^B))'
Where A is the asymptote, B is the weibull shape parameter, C is the weibull scale parameter.
</p>
</li>
<li> <p><b>Frechet</b>: 'A * exp(-((x-0)/C)^(-B))'
Where A is the asymptote, B is the frechet shape parameter, C is the frechet scale parameter.
Note that the location parameter (conventionally m) is 0 in these models for simplicity but is
still included in the formula.
</p>
</li>
<li> <p><b>Gumbel</b>: 'A * exp(-exp(-(x-B)/C))'
Where A is the asymptote, B is the inflection point (location), C is the growth rate (scale).
</p>
</li>
<li> <p><b>Double Logistic</b>: 'A / (1+exp((B-x)/C)) + ((A2-A) /(1+exp((B2-x)/C2)))'
Where A is the asymptote, B is the inflection point, C is the growth rate,
A2 is the second asymptote, B2 is the second inflection point, and C2 is the second
growth rate.
</p>
</li>
<li> <p><b>Double Gompertz</b>: 'A * exp(-B * exp(-C*x)) + ((A2-A) * exp(-B2 * exp(-C2*(x-B))))'
Where A is the asymptote, B is the inflection point, C is the growth rate,
A2 is the second asymptote, B2 is the second inflection point, and C2 is the second
growth rate.
</p>
</li>
<li> <p><b>Monomolecular</b>: 'A-A * exp(-B * x)'
Where A is the asymptote and B is the growth rate.
</p>
</li>
<li> <p><b>Exponential</b>: 'A * exp(B * x)'
Where A is the scale parameter and B is the growth rate.
</p>
</li>
<li> <p><b>Linear</b>: 'A * x'
Where A is the growth rate.
</p>
</li>
<li> <p><b>Logarithmic</b>: 'A * log(x)'
Where A is the growth rate.
</p>
</li>
<li> <p><b>Power Law</b>: 'A * x ^ (B)'
Where A is the scale parameter and B is the growth rate.
</p>
</li>
<li> <p><b>Bragg</b>: 'A * exp(-B * (x - C) ^ 2)'
This models minima and maxima as a dose-response curve where A is the max response,
B is the &quot;precision&quot; or slope at inflection, and C is the x position of the max response.
</p>
</li>
<li> <p><b>Lorentz</b>: 'A / (1 + B * (x - C) ^ 2)'
This models minima and maxima as a dose-response curve where A is the max response,
B is the &quot;precision&quot; or slope at inflection, and C is the x position of the max response.
Generally Bragg is preferred to Lorentz for dose-response curves.
</p>
</li>
<li> <p><b>Beta</b>: 'A * (((x - D) / (C - D)) * ((E - x) / (E - C)) ^ ((E - C) / (C - D))) ^ B'
This models minima and maxima as a dose-response curve where A is the Maximum Value,
B is a shape/concavity exponent similar to the sum of alpha and beta in a Beta distribution,
C is the position of maximum value, D is the minimum position where distribution &gt; 0,
E is the maximum position where distribution &gt; 0.
This is a difficult model to fit but can model non-symmetric dose-response relationships which
may sometimes be worth the extra effort.
</p>
</li></ul>

<p>Note that for these distributions parameters generally do not exist in a vacuum.
Changing one will make the others look different in the resulting data.
The examples are a good place to start if you are unsure what parameters to use.
</p>


<h3>Value</h3>

<p>Returns a dataframe of example growth data following the input parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Logistic")

simdf &lt;- growthSim("gompertz",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(0.2, 0.25))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Gompertz")

simdf &lt;- growthSim("weibull",
  n = 20, t = 25,
  params = list("A" = c(100, 100), "B" = c(1, 0.75), "C" = c(2, 3))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "weibull")

simdf &lt;- growthSim("frechet",
  n = 20, t = 25,
  params = list("A" = c(100, 110), "B" = c(2, 1.5), "C" = c(5, 2))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "frechet")

simdf &lt;- growthSim("gumbel",
  n = 20, t = 25,
  list("A" = c(120, 140), "B" = c(6, 5), "C" = c(4, 3))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "gumbel")

simdf &lt;- growthSim("double logistic",
  n = 20, t = 70,
  params = list(
    "A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5),
    "A2" = c(400, 300), "B2" = c(35, 40), "C2" = c(3.25, 2.75)
  )
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Double Logistic")

simdf &lt;- growthSim("double gompertz",
  n = 20, t = 100,
  params = list(
    "A" = c(180, 140), "B" = c(13, 11), "C" = c(0.2, 0.2),
    "A2" = c(400, 300), "B2" = c(50, 50), "C2" = c(0.1, 0.1)
  )
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Double Gompertz")

simdf &lt;- growthSim("monomolecular",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(0.08, 0.1))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Monomolecular")

simdf &lt;- growthSim("exponential",
  n = 20, t = 25,
  params = list("A" = c(15, 20), "B" = c(0.095, 0.095))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Exponential")

simdf &lt;- growthSim("linear",
  n = 20, t = 25,
  params = list("A" = c(1.1, 0.95))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Linear")

simdf &lt;- growthSim("logarithmic",
  n = 20, t = 25,
  params = list("A" = c(2, 1.7))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Logarithmic")

simdf &lt;- growthSim("power law",
  n = 20, t = 25,
  params = list("A" = c(16, 11), "B" = c(0.75, 0.7))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "Power Law")

simdf &lt;- growthSim("bragg",
  n = 20, t = 100,
  list("A" = c(10, 15), "B" = c(0.01, 0.02), "C" = c(50, 60))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "bragg")

# simulating models from segmented growth models

simdf &lt;- growthSim(
  model = "linear + linear", n = 20, t = 25,
  params = list("linear1A" = c(16, 11), "linear2A" = c(0.75, 0.7), "changePoint1" = c(11, 14))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "linear + linear")

simdf &lt;- growthSim(
  model = "linear + linear decay", n = 20, t = 25,
  params = list("linear1A" = c(16, 11), "linear2A" = c(3, 2), "changePoint1" = c(11, 14))
)
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "linear + linear decay")

simdf &lt;- growthSim(
  model = "linear + linear + logistic", n = 20, t = 50,
  params = list(
    "linear1A" = c(16, 11), "linear2A" = c(3, 4), # linear slopes, very intuitive
    "changePoint1" = c(11, 14), "changePoint2" = c(10, 12),
    # changepoint1 is standard, changepoint2 happens relative to changepoint 1
    "logistic3A" = c(200, 210), "logistic3B" = c(20, 25), "logistic3C" = c(3, 3)
  )
)
# similar to changepoint2, the asymptote and inflection point are relative to the starting
# point of the logistic growth component. This is different than the model output
# if you were to fit a curve to this model using `growthSS`.
ggplot(simdf, aes(time, y, group = interaction(group, id))) +
  geom_line(aes(color = group)) +
  labs(title = "linear + linear + logistic")

</code></pre>

<hr>
<h2 id='growthSS'>Ease of use growth model helper function.</h2><span id='topic+growthSS'></span>

<h3>Description</h3>

<p>Output from this should be passed to <a href="#topic+fitGrowth">fitGrowth</a> to fit the specified model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growthSS(
  model,
  form,
  sigma = NULL,
  df,
  start = NULL,
  pars = NULL,
  type = "brms",
  tau = 0.5,
  hierarchy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growthSS_+3A_model">model</code></td>
<td>
<p>The name of a model as a character string.
Supported options are c(&quot;logistic&quot;, &quot;gompertz&quot;, &quot;weibull&quot;, &quot;frechet&quot;, &quot;gumbel&quot;, &quot;monomolecular&quot;,
&quot;exponential&quot;, &quot;linear&quot;, &quot;power law&quot;, &quot;bragg&quot;, &quot;lorentz&quot;, &quot;beta&quot;,
&quot;double logistic&quot;, &quot;double gompertz&quot;, &quot;gam&quot;, &quot;int&quot;), with &quot;int&quot; representing an intercept only model
which is only used in brms (and is expected to only be used in threshold models or to model
homoskedasticity). Note that the dose response curves (bragg, lorentz, and beta) may be difficult
to fit using the <code>nlme</code> backend but should work well using other options.
See <code><a href="#topic+growthSim">growthSim</a></code> for examples of each type of single parameterized growth curve
(&quot;gam&quot; is not supported in <code>growthSim</code>).
You can also specify decay models by including the &quot;decay&quot; keyword with the model name. Note that
using &quot;decay&quot; is only necessary for the brms backend since otherwise the priors are strictly
positive.
In brms models the entire formula is negated for decay models so that lognormal priors can
still be used when at least some coefficients would be negative.
Additionally, the &quot;int_&quot; prefix may be added to a model name to specify that an intercept should
be included. By default these models are assumed to have intercepts at 0, which is often fine.
If you include an intercept in a brms model then you would specify the prior as you would for an
&quot;A&quot;, &quot;B&quot;, or &quot;C&quot; parameter but as &quot;I&quot;. By default growthSS will make student T priors for intercept
parameters in the same way that it will for estimated changepoints (see below).
With type=&quot;brms&quot; you can also specify segmented models by combining model names with a plus sign
such as &quot;linear + linear&quot;. In a segmented model the names for parameters do not follow the normal
&quot;A&quot;, &quot;B&quot;, &quot;C&quot; notation, instead they are named for the type of model, the position in the formula,
then for the parameter of that model. There will also be parameters to represent the time when
growth switches from one model to another called either &quot;changepointX&quot; or &quot;fixedChangePointX&quot;.
All &quot;changePointX&quot; terms are estimated as parameters of the model.
&quot;fixedChangePointX&quot; parameters are not estimated and are kept as the numeric value given in the
priors, this is useful if your experiment has an intervention at a set time which you expect to
change the growth process acutely.
For the &quot;linear + linear&quot; example this would yield parameters &quot;linear1A&quot;, &quot;changePoint1&quot;
(or &quot;fixedChangePoint1&quot;), and &quot;linear2A&quot;. A &quot;linear + gompertz&quot; model would have
&quot;linear1A&quot;, &quot;changePoint1&quot;, &quot;gompertz2A&quot;, &quot;gompertz2B&quot;, and &quot;gompertz2C&quot; for parameters.
Note that double sigmoid models are not supported as parts of segmented models and gams
can currently only be included as the last part of a segmented model. When using a changepoint model
it may be worth using segments that are simpler to fit
(gompertz instead of EVD options, for instance). Currently &quot;homo&quot; and &quot;int&quot; are treated the same
and &quot;spline&quot; and &quot;gam&quot; are interchangeable. Time-to-event models can be specified using the
&quot;survival&quot; keyword, see details for an explanation of the changes that entails.
Similarly, using the brms backend response distributions (see <code>brms::brmsfamily</code>)
can be specified in the model as &quot;family: model&quot; so that a model
of logistic increasing counts may be written as <code>model = "poisson: logistic"</code>.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_form">form</code></td>
<td>
<p>A formula describing the model. The left hand side should only be
the outcome variable (phenotype), and a cutoff if you are making a survival model (see details).
The right hand side needs at least the x variable
(typically time). Grouping is also described in this formula using roughly lme4
style syntax,with formulas like <code>y~time|individual/group</code> to show that predictors
should vary by <code>group</code> and autocorrelation between <code>individual:group</code>
interactions should be modeled. Note that autocorrelation is only modeled with the &quot;brms&quot;
backend in this way. &quot;nlme&quot; requires random effects and correlations to use the same grouping,
so autocorrelation using the &quot;nlme&quot; backend works at the group level, so will slightly underestimate
the autocorrelation at the individual level. If group has only one level or is not included then
it will be ignored in formulas for growth and variance (this may be the case if
you split data before fitting models to be able to run more smaller models each more quickly). To
include multiple grouping variables they should be separated with &quot;+&quot; as in
<code>y~time|individual/groupingVariable1 + groupingVariable2</code>. For some backends multiple grouping
variables will be combined into a single factor of their interaction.
Hierarchical models can be specified for the brms backend as
<code>y~time+other_covariate|individual/group</code> in which case the parameters of the main growth model
will themselves be estimated by models as specified in the <code>hierarchy</code> argument. For instance,
if normally &quot;A&quot; had an intercept for each <code>group</code>, now it would be predicted as
<code>A ~ AI + AA * covariate</code> where AI and AA now have an intercept for each <code>group</code>. Note
that if you specify a hierarchical model then priors are required for AI and AA in the previous
example.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_sigma">sigma</code></td>
<td>
<p>Other models for distributional parameters.
This argument is only used with &quot;brms&quot; and &quot;nlme&quot; models and is handled differently for each.
When type=&quot;brms&quot; this can be supplied as a model or as a list of models.
It is turned into a formula (or list of formulas) with an entry corresponding to each distributional
parameter (after the mean) of the growth model family.
If no family was specified (<code>model="logistic"</code> for instance) then the student T distribution
is used, with additional distributional parameters sigma and nu.
To check the naming of distributional parameters in each response family use
<code>brms::brmsfamily("family")$dpars</code>. The supported options are the same as the model options
(including threshold models).
For distributional parameters that do not have a formula specified they will be modeled as
intercept only (not by group).
Parameter names are the same as those in the main model but with the distributional parameter name
as a prefix. Additionally, if a linear model is used for sigma then it can be modeled with or without
a prior, if a prior is specified (&quot;sigmaA&quot;) then a non-linear formula is used and the &quot;sigmaA&quot;
parameter will be included in the output instead of the default &quot;sigma&quot; term.
In the rare case that you wish to model the mean and the 3rd distributional parameter but not
the 2nd then <code>sigma = list("not_estimated", "model")</code> would allow for that.
When type =&quot;nlme&quot; the options are more limited to c(&quot;none&quot;, &quot;power&quot;, &quot;exp&quot;), corresponding to using
<code>nlme::varIdent</code>, <code>nlme::varPower</code>, or <code>nlme::varExp</code> respectively where &quot;power&quot;
is the default.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_df">df</code></td>
<td>
<p>A dataframe to use. Must contain all the variables listed in the formula.
Note that rows with NA or infinite values in x, y, or hierarchical predictors are removed.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_start">start</code></td>
<td>
<p>An optional named list of starting values OR means for prior distributions.
If this is not provided then starting values are picked with <code>stats::selfStart</code>.
When type = &quot;brms&quot; these should be provided and are treated as the means of
lognormal priors for all growth model parameters and T_5(mu, 3) priors for changepoint parameters.
This is done because the values are strictly positive and the lognormal distribution
is easily interpreted. The changepoint priors are T distributions for symmetry, 5 DF
having been chosen for heavy but not unmanageable tails.
If this argument is not provided then priors are made using brms::get_prior.
Those priors are unlikely to be suitable and a different set of priors will need to be made
for the model using <code>brms::set_prior</code> for good convergence. When specifying starting
values/prior means think of this as being similar to the <code>params</code> argument
in <code>growthSim</code>. Names should correspond to parameter names from the
<code>model</code> argument. A numeric vector can also be used, but specifying
names is best practice for clarity. Additionally, due to a limitation in
<code>brms</code> currently lower bounds cannot be set for priors for specific groups.
If priors include multiple groups (<code>start = list(A = c(10,15), ...)</code>) then
you will see warnings after the model is fit about not having specified a lower
bound explicitly. Those warnings can safely be ignored and will be addressed if
the necessary features are added to <code>brms</code>. See details for guidance.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_pars">pars</code></td>
<td>
<p>Optionally specify which parameters should change by group. Not this is model
dependent and is not implemented for brms models due to their more flexible hypothesis testing.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_type">type</code></td>
<td>
<p>Type of model to fit, options are &quot;brms&quot;, &quot;nlrq&quot;, &quot;nlme&quot;, &quot;nls&quot;, and &quot;mgcv&quot;.
Note that the &quot;mgcv&quot; option only supports &quot;gam&quot; models.
Survival models can use the &quot;survreg&quot; model type
(this will be called if any non-brms/flexsurv type is given) or the &quot;flexsurv&quot; model type
which requires the flexsurv package to be installed.
Note that for non-brms models variables in the model will be labeled by the factor level of the
group, not necessarily by the group name.
This is done for ease of use with different modeling functions, the levels are alphabetically sorted
and can be checked using:
<code>table(ss$df$group, ss$df$group_numericLabel)</code>.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_tau">tau</code></td>
<td>
<p>A vector of quantiles to fit for nlrq models.</p>
</td></tr>
<tr><td><code id="growthSS_+3A_hierarchy">hierarchy</code></td>
<td>
<p>Optionally a list of model parameters that should themselves by modeled by another
predictor variable. This is only used with the brms backend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default priors are not provided, but these can serve as starting points for each distribution.
You are encouraged to use <code>growthSim</code> to consider what kind
of trendlines result from changes to your prior and for interpretation of each parameter.
The <a href="#topic+plotPrior">plotPrior</a> function can be used to do prior predictive checks.
You should not looking back and forth at your data trying to match your
observed growth exactly with a prior distribution,
rather this should be informed by an understanding of the plants you
are using and expectations based on previous research.
For the &quot;double&quot; models the parameter interpretation is the same
as for their non-double counterparts except that there are A and A2, etc.
It is strongly recommended to familiarize yourself with the double sigmoid
distributions using growthSim before attempting to model one. Additionally,
those distributions are intended for use with long delays in an experiment,
think stress recovery experiments, not for minor hiccups in plant growth.
</p>

<ul>
<li> <p><b>Logistic</b>: <code>list('A' = 130, 'B' = 12, 'C' = 3)</code>
</p>
</li>
<li> <p><b>Gompertz</b>: <code>list('A' = 130, 'B' = 12, 'C' = 1.25)</code>
</p>
</li>
<li> <p><b>Weibull</b>: <code>list('A' = 130, 'B' = 2, 'C' = 2)</code>
</p>
</li>
<li> <p><b>Frechet</b>: <code>list('A' = 130, 'B' = 5, 'C' = 6)</code>
</p>
</li>
<li> <p><b>Gumbel</b>: <code>list('A' = 130, 'B' = 6, 'C' = 4)</code>
</p>
</li>
<li> <p><b>Double Logistic</b>: <code>list('A' = 130, 'B' = 12, 'C' = 3,
    'A2' = 200, 'B2' = 25, 'C2' = 1)</code>
</p>
</li>
<li> <p><b>Double Gompertz</b>: <code>list('A' = 130, 'B' = 12, 'C' = 0.25,
    'A2' = 220, 'B2' = 30, 'C2' = 0.1)</code>
</p>
</li>
<li> <p><b>Monomolecular</b>: <code>list('A' = 130, 'B' = 2)</code>
</p>
</li>
<li> <p><b>Exponential</b>: <code>list('A' = 15, 'B' = 0.1)</code>
</p>
</li>
<li> <p><b>Linear</b>: <code>list('A' = 1)</code>
</p>
</li>
<li> <p><b>Power Law</b>: <code>list('A' = 13, 'B' = 2)</code>
</p>
</li></ul>

<p>See details below about parameterization for each model option.
</p>

<ul>
<li> <p><b>Logistic</b>: 'A / (1 + exp( (B-x)/C) )'
Where A is the asymptote, B is the inflection point, C is the growth rate.
</p>
</li>
<li> <p><b>Gompertz</b>: 'A * exp(-B * exp(-C*x))'
Where A is the asymptote, B is the inflection point, C is the growth rate.
</p>
</li>
<li> <p><b>Weibull</b>: 'A * (1-exp(-(x/C)^B))'
Where A is the asymptote, B is the weibull shape parameter, C is the weibull scale parameter.
</p>
</li>
<li> <p><b>Frechet</b>: 'A * exp(-((x-0)/C)^(-B))'
Where A is the asymptote, B is the frechet shape parameter, C is the frechet scale parameter.
Note that the location parameter (conventionally m) is 0 in these models for simplicity but is still
included in the formula.
</p>
</li>
<li> <p><b>Gumbel</b>: 'A * exp(-exp(-(x-B)/C))'
Where A is the asymptote, B is the inflection point (location), C is the growth rate (scale).
</p>
</li>
<li> <p><b>Double Logistic</b>: 'A / (1+exp((B-x)/C)) + ((A2-A) /(1+exp((B2-x)/C2)))'
Where A is the asymptote, B is the inflection point, C is the growth rate,
A2 is the second asymptote, B2 is the second inflection point, and C2 is the second
growth rate.
</p>
</li>
<li> <p><b>Double Gompertz</b>: 'A * exp(-B * exp(-C*x)) + ((A2-A) * exp(-B2 * exp(-C2*(x-B))))'
Where A is the asymptote, B is the inflection point, C is the growth rate,
A2 is the second asymptote, B2 is the second inflection point, and C2 is the second
growth rate.
</p>
</li>
<li> <p><b>Monomolecular</b>: 'A-A * exp(-B * x)'
Where A is the asymptote and B is the growth rate.
</p>
</li>
<li> <p><b>Exponential</b>: 'A * exp(B * x)'
Where A is the scale parameter and B is the growth rate.
</p>
</li>
<li> <p><b>Linear</b>: 'A * x'
Where A is the growth rate.
</p>
</li>
<li> <p><b>Power Law</b>: 'A * x^(B)'
Where A is the scale parameter and B is the growth rate.
</p>
</li>
<li> <p><b>Bragg</b>: 'A * exp(-B * (x - C) ^ 2)'
This models minima and maxima as a dose-response curve where A is the max response,
B is the &quot;precision&quot; or slope at inflection, and C is the x position of the max response.
</p>
</li>
<li> <p><b>Lorentz</b>: 'A / (1 + B * (x - C) ^ 2)'
This models minima and maxima as a dose-response curve where A is the max response,
B is the &quot;precision&quot; or slope at inflection, and C is the x position of the max response.
Generally Bragg is preferred to Lorentz for dose-response curves.
</p>
</li>
<li> <p><b>Beta</b>: 'A * (((x - D) / (C - D)) * ((E - x) / (E - C)) ^ ((E - C) / (C - D))) ^ B'
This models minima and maxima as a dose-response curve where A is the Maximum Value,
B is a shape/concavity exponent similar to the sum of alpha and beta in a Beta distribution,
C is the position of maximum value, D is the minimum position where distribution &gt; 0,
E is the maximum position where distribution &gt; 0.
This is a difficult model to fit but can model non-symmetric dose-response relationships which
may sometimes be worth the extra effort.
</p>
</li></ul>

<p>Note that for these distributions parameters do not exist in a vacuum.
Changing one will make the others look different in the resulting data.
The <code>growthSim</code> function can be helpful in familiarizing further with these distributions.
</p>
<p>Using the <code>brms</code> backend the <code>sigma</code> argument optionally specifies a sub model to account
for heteroskedasticity.
Any combination of models (except for decay models) can be specified in the <code>sigma</code> term.
If you need variance to raise and lower then a gam/spline is the most appropriate option.
</p>
<p>Using the <code>brms</code> backend a model with lots of parameters may be difficult to estimate if there
are lots of groups.
If you have very many levels of your &quot;group&quot; variable in a complex model then consider fitting models
to subsets of the &quot;group&quot; variable and using <a href="#topic+combineDraws">combineDraws</a> to make a data.frame for
hypothesis testing.
</p>
<p>Limits on the Y variable can be specified in the <code>brms</code> backend. This should generally be
unnecessary and will make the model slower to fit and potentially more difficult to set priors on.
If you do have a limited phenotype (besides the normal positive constraint for growth models)
then this may be helpful, one situation may be canopy coverage percentage which is naturally bounded
at an upper and lower limit.
To specify these limits add square brackets to the Y term with upper and lower limits such as
<code>"y[0,100] ~ time|id/group"</code>. Other &quot;Additional response information&quot; such as resp_weights or
standard errors can be specified using the <code>brms</code> backend, with those options documented fully
in the <code>brms::brmsformula</code> details.
</p>
<p>There are also three supported submodel options for <code>nlme</code> models, but a <code>varFunc</code> object
can also be supplied, see <code>?nlme::varClasses</code>.
</p>

<ul>
<li> <p><b>none</b>: <code>varIdent(1|group)</code>, which models a constant variance separately for each
group.
</p>
</li>
<li> <p><b>power</b>: <code>varPower(x|group)</code>, which models variance as a power of x per group.
</p>
</li>
<li> <p><b>exp</b>: <code>varExp(x|group)</code>, which models variance as an exponent of x per group.
</p>
</li></ul>

<p>Survival models can be fit using the &quot;survival&quot; keyword in the model specification.
Using the &quot;brms&quot; backend (type argument) you can specify &quot;weibull&quot; (the default) or &quot;binomial&quot; for
the distribution to use in that model so that the final model string would be &quot;survival binomial&quot; or
&quot;survival weibull&quot; which is equivalent to &quot;survival&quot;. Time to event data is very different than
standard phenotype data, so the formula argument should include a cutoff for the Y variable to count
as an &quot;event&quot;. For example, if you were checking germination using area and wanted to use 50 pixels
as a germinated plant your formula would be <code>area &gt; 50 ~ time|id/group</code>.
Internally the input dataframe will be converted to time-to-event data based on that formula.
Alternatively you can make your own time to event data and supply that to growthSS. In that case your
data should have columns called &quot;n_events&quot;
(number of individuals experiencing the event at this time) and &quot;n_eligible&quot;
(number of individuals who had not experienced the event at least up to this time)
for the binomial model family OR &quot;event&quot; (binary 1,0 for TRUE, FALSE) for the Weibull model family.
Note that since these are linear models using different model families the priors are handled
differently. For survival models the default priors are weak regularizing priors (Normal(0,5))
on all parameters. If you wish to specify your own priors you can supply them as brmsprior objects
or as a list such as <code>priors = list("group1" = c(0,3), "group2" = c(0,1))</code> where the order of
values is Mu, Sigma.
Any non-brms backend will instead use <code>survival::survreg</code> to fit the model unless the
&quot;flexsurv&quot; type is specified.
Distributions will be passed to <code>survreg</code> where options are &quot;weibull&quot;, &quot;exponential&quot;,
&quot;gaussian&quot;, &quot;logistic&quot;,&quot;lognormal&quot; and &quot;loglogistic&quot; if type = &quot;survreg&quot; or to
<code>flexsurv::flexsurvreg</code> if type = &quot;flexsurv&quot; where options are &quot;gengamma&quot;, &quot;gengamma.orig&quot;,
&quot;genf&quot;, &quot;genf.orig&quot;, &quot;weibull&quot;, &quot;gamma&quot;, &quot;exp&quot;, &quot;llogis&quot;, &quot;lnorm&quot;, &quot;gompertz&quot;, &quot;exponential&quot;,
and &quot;lognormal&quot;. In <code>flexsurvreg</code> distributional modeling is supported and additional
formula can be passed as a list to the sigma argument of growthSS in the same way as to the anc
argument of <code>flexsurv::flexsurvreg</code>.
Further additional arguments should be supplied via <code>fitGrowth</code> if desired.
</p>


<h3>Value</h3>

<p>A named list of elements to make it easier to fit non linear growth models with several R
packages.
</p>
<p>For <code>brms</code> models the output contains:
</p>
<p><code>formula</code>: A <code>brms::bf</code> formula specifying the growth model, autocorrelation,
variance submodel, and models for each variable in the growth model.
<code>prior</code>: A brmsprior/data.frame object.
<code>initfun</code>: A function to randomly initialize chains using a random draw from a gamma
distribution (confines initial values to positive and makes correct number
of initial values for chains and groups).
<code>df</code> The data input, with dummy variables added if needed and a column to link groups to their
factor levels.
<code>family</code> The model family, currently this will always be &quot;student&quot;.
<code>pcvrForm</code> The form argument unchanged. This is returned so that
it can be used later on in model visualization. Often it may be a good idea
to save the output of this function with the fit model, so having this can
be useful later on.
</p>
<p>For <code>quantreg::nlrq</code> models the output contains:
</p>
<p><code>formula</code>: An <code>nls</code> style formula specifying the growth model with groups if specified.
<code>taus</code>: The quantiles to be fit
<code>start</code>: The starting values, typically these will be generated from the growth model and your
data in a similar way as shown in <code>stats::selfStart</code> models.
<code>df</code> The input data for the model.
<code>pcvrForm</code> The form argument unchanged.
</p>
<p>For <code>nls</code> models the output is the same as for <code>quantreg::nlrq</code> models but without
<code>taus</code> returned.
</p>
<p>For <code>nlme::nlme</code> models the output contains:
</p>
<p><code>formula</code>: An list of <code>nlme</code> style formulas specifying the model, fixed and random effects,
random effect grouping, and variance model (weights).
<code>start</code>: The starting values, typically these will be generated from the growth model and your
data in a similar way as shown in <code>stats::selfStart</code> models.
<code>df</code> The input data for the model.
<code>pcvrForm</code> The form argument unchanged.
</p>
<p>For all models the type and model are also returned for simplicity downstream.
</p>


<h3>See Also</h3>

<p><a href="#topic+fitGrowth">fitGrowth</a> for fitting the model specified by this list and <a href="#topic+mvSS">mvSS</a>
for the multi-value trait equivalent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  sigma = "spline", df = simdf,
  start = list("A" = 130, "B" = 12, "C" = 3), type = "brms"
)
lapply(ss, class)
ss$initfun()
# the next step would typically be compiling/fitting the model
# here we use very few chains and very few iterations for speed, but more of both is better.

fit_test &lt;- fitGrowth(ss,
  iter = 500, cores = 1, chains = 1, backend = "cmdstanr",
  control = list(adapt_delta = 0.999, max_treedepth = 20)
)



# formulas and priors will look different if there is only one group in the data

ex &lt;- growthSim("linear", n = 20, t = 25, params = list("A" = 2))
ex_ss &lt;- growthSS(
  model = "linear", form = y ~ time | id / group, sigma = "spline",
  df = ex, start = list("A" = 1), type = "brms"
)

ex_ss$prior # no coef level grouping for priors
ex_ss$formula # intercept only model for A

ex2 &lt;- growthSim("linear", n = 20, t = 25, params = list("A" = c(2, 2.5)))
ex2_ss &lt;- growthSS(
  model = "linear", form = y ~ time | id / group, sigma = "spline",
  df = ex2, start = list("A" = 1), type = "brms"
)
ex2_ss$prior # has coef level grouping for priors
ex2_ss$formula # specifies an A intercept for each group and splines by group for sigma

</code></pre>

<hr>
<h2 id='mv_ag'>Multi Value Trait Aggregation function</h2><span id='topic+mv_ag'></span>

<h3>Description</h3>

<p>EMD can get very heavy with large datasets. For an example
lemnatech dataset filtering for images from every 5th day there are
6332^2 = 40,094,224 pairwise EMD values. In long format that's a 40 million row dataframe,
which is unwieldy. This function is to help reduce the size of datasets before
comparing histograms and moving on with matrix methods or network analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv_ag(
  df,
  group,
  mvCols = "frequencies",
  n_per_group = 1,
  outRows = NULL,
  keep = NULL,
  parallel = getOption("mc.cores", 1),
  traitCol = "trait",
  labelCol = "label",
  valueCol = "value",
  id = "image"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mv_ag_+3A_df">df</code></td>
<td>
<p>A dataframe with multi value traits. This can be in wide or long format,
data is assumed to be long if traitCol, valueCol, and labelCol are present.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_group">group</code></td>
<td>
<p>Vector of column names for variables which uniquely identify groups
in the data to summarize data over. Typically this would be the design variables
and a time variable.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_mvcols">mvCols</code></td>
<td>
<p>Either a vector of column names/positions representing multi value
traits or a character string that identifies the multi value trait columns as a
regex pattern. Defaults to &quot;frequencies&quot;.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_n_per_group">n_per_group</code></td>
<td>
<p>Number of rows to return for each group.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_outrows">outRows</code></td>
<td>
<p>Optionally this is a different way to specify how many rows to return.
This will often not be exact so that groups have the same number of observations each.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_keep">keep</code></td>
<td>
<p>A vector of single value traits to also average over groups, if there are
a mix of single and multi value traits in your data.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_parallel">parallel</code></td>
<td>
<p>Optionally the groups can be run in parallel with this number of cores,
defaults to 1 if the &quot;mc.cores&quot; option is not set globally.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_labelcol">labelCol</code></td>
<td>
<p>Column with phenotype labels (units), defaults to &quot;label&quot;.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="mv_ag_+3A_id">id</code></td>
<td>
<p>Column that uniquely identifies images if the data is in long format.
This is ignored when data is in wide format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe summarized by the specified groups over the multi-value traits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- mvSim(
  dists = list(runif = list(min = 15, max = 150)),
  n_samples = 10,
  counts = 1000,
  min_bin = 1,
  max_bin = 180,
  wide = TRUE
)
mv_ag(s1, group = "group", mvCols = "sim_", n_per_group = 2)

</code></pre>

<hr>
<h2 id='mvSim'>Multi Value Trait simulating function</h2><span id='topic+mvSim'></span>

<h3>Description</h3>

<p>mvSim can be used to simulate data for example models/plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvSim(
  dists = list(rnorm = list(mean = 100, sd = 15)),
  n_samples = 10,
  counts = 1000,
  min_bin = 1,
  max_bin = 180,
  wide = TRUE,
  binwidth = 1,
  t = NULL,
  model = "linear",
  params = list(A = 10)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvSim_+3A_dists">dists</code></td>
<td>
<p>A list of lists, with names corresponding to random deviate generating functions
and arguments to the function in the list values (see examples). Note that the n argument
does not need to be provided.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples per distribution to generate. Defaults to 10, can be &gt;1L.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_counts">counts</code></td>
<td>
<p>Number of counts per histogram, defaults to 1000.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_min_bin">min_bin</code></td>
<td>
<p>The minumum bin number. This can be thought of as the minimum value that will
be accepted in the distribution functions, with lower numbers being raised to this value.
Note that bin arguments are both ignored in the case of &quot;rbeta&quot; and treated as 0,1.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_max_bin">max_bin</code></td>
<td>
<p>The number of bins to return. Note that this is also the max value that will be
accepted in the distribution functions, with higher numbers being shrunk to this value.
Defaults to 180.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_wide">wide</code></td>
<td>
<p>Boolean, should data be returned in wide format (the default)?
If FALSE then long data is returned.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_binwidth">binwidth</code></td>
<td>
<p>How wide should bins be? Defaults to 1.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_t">t</code></td>
<td>
<p>Number of timepoints to simulate. Defaults to NULL in which case data is simulated as
non-longitudinal. Note that currently the first non <code>n</code> argument of the data simulating
function is assumed to be the parameter changing over time (ie, mean in rnorm, meanlog in rlnorm).</p>
</td></tr>
<tr><td><code id="mvSim_+3A_model">model</code></td>
<td>
<p>A type of growth model, passed to <a href="#topic+growthSim">growthSim</a>. This is only used if t is
specified.</p>
</td></tr>
<tr><td><code id="mvSim_+3A_params">params</code></td>
<td>
<p>Parameters for the growth model, passed to <a href="#topic+growthSim">growthSim</a>. This is also only used
if t is specified. Note growth will start from the values specified in dists. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe of example multi-value trait data simulated from specified distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(extraDistr) # for rmixnorm
library(ggplot2)
dists &lt;- list(
  rmixnorm = list(mean = c(70, 150), sd = c(15, 5), alpha = c(0.3, 0.7)),
  rnorm = list(mean = 90, sd = 3)
)
x &lt;- mvSim(dists = dists, wide = FALSE)
dim(x)
x2 &lt;- mvSim(dists = dists)
dim(x2)

ggplot(x, aes(
  x = as.numeric(sub("sim_", "", variable)),
  y = value, group = interaction(group, id), fill = group
)) +
  geom_col(position = "identity", alpha = 0.25) +
  pcv_theme() +
  labs(x = "bin")
dists = list(rnorm = list(mean = 30, sd = 15), rnorm = list(mean = 25, sd = 10))
x3 &lt;- mvSim(
  dists = dists, wide = FALSE, # here we make longitudinal data
  t = 10, model = "linear", params = list("A" = c(10, 5))
)
ggplot(x3, aes(
  x = as.numeric(sub("sim_", "", variable)),
  y = value, group = interaction(group, id), fill = group
)) +
  facet_wrap(~times) +
  geom_col(position = "identity", alpha = 0.25) +
  pcv_theme() +
  labs(x = "bin")

</code></pre>

<hr>
<h2 id='mvSS'>Ease of use multi-value trait model helper function.</h2><span id='topic+mvSS'></span>

<h3>Description</h3>

<p>This function provides a simplified interface to modeling multi-value traits using <a href="#topic+growthSS">growthSS</a>.
Output from this should be passed to <a href="#topic+fitGrowth">fitGrowth</a> to fit the specified model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvSS(
  model = "linear",
  form,
  sigma = NULL,
  df,
  start = NULL,
  pars = NULL,
  type = "brms",
  tau = 0.5,
  hierarchy = NULL,
  spectral_index = c("none", "ari", "ci_rededge", "cri550", "cri700", "egi", "evi",
    "gdvi", "mari", "mcari", "mtci", "ndre", "ndvi", "pri", "psnd_chlorophyll_a",
    "psnd_chlorophyll_b", "psnd_caroteniods", "psri", "pssr_chlorophyll_a",
    "pssr_chlorophyll_b", "pssr_caroteniods", "rgri", "rvsi", "savi", "sipi", "sr",
    "vari", "vi_green", "wi", "fvfm", "fqfm")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvSS_+3A_model">model</code></td>
<td>
<p>A model specification as in <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_form">form</code></td>
<td>
<p>A formula similar to <code>label | value ~ time + id/group</code> where label is a column
of histogram bins, value is the counts within those bins, time is an optional time variable,
id identifies an individual, and group contains the treatment groups. If the time variable
is not included then the individual variable should also not be included.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_sigma">sigma</code></td>
<td>
<p>Distributional models passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_df">df</code></td>
<td>
<p>Data passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_start">start</code></td>
<td>
<p>Starting values or priors, passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_pars">pars</code></td>
<td>
<p>Parameters to vary, passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_type">type</code></td>
<td>
<p>Backend to use, passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_tau">tau</code></td>
<td>
<p>Quantile to model, passed to <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_hierarchy">hierarchy</code></td>
<td>
<p>Formulae describing any hierarchical models, see <a href="#topic+growthSS">growthSS</a>.</p>
</td></tr>
<tr><td><code id="mvSS_+3A_spectral_index">spectral_index</code></td>
<td>
<p>Optionally, a spectral index
<a href="https://plantcv.readthedocs.io/en/stable/spectral_index/">from those calculated by PlantCV</a>.
If this is given then the appropriate truncation and model family (if applicable)
will be included for the index you are using without you having to write it in the formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of plots showing prior distributions that <code>growthSS</code> would use,
optionally with a plot of simulated growth curves using draws from those priors.
</p>


<h3>See Also</h3>

<p><a href="#topic+fitGrowth">fitGrowth</a> for fitting the model specified by this list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
mv_df &lt;- mvSim(dists = list(rnorm = list(mean = 100, sd = 30)), wide = FALSE)
mv_df$group &lt;- rep(c("a", "b"), times = 900)
mv_df &lt;- mv_df[mv_df$value &gt; 0, ]
mv_df$label &lt;- as.numeric(gsub("sim_", "", mv_df$variable))

ss1 &lt;- mvSS(
  model = "linear", form = label | value ~ group, df = mv_df,
  start = list("A" = 5), type = "brms", spectral_index = "none"
)

mod1 &lt;- fitGrowth(ss1, backend = "cmdstanr", iter = 1000, chains = 1, cores = 1)
growthPlot(mod1, ss1$pcvrForm, df = ss1$df)


# when the model is longitudinal the same model is possible with growthSS

m1 &lt;- mvSim(
  dists = list(
    rnorm = list(mean = 100, sd = 30),
    rnorm = list(mean = 110, sd = 25),
    rnorm = list(mean = 120, sd = 20),
    rnorm = list(mean = 135, sd = 15)
  ),
  wide = FALSE, n = 6
)
m1$time &lt;- rep(1:4, times = 6 * 180)
m2 &lt;- mvSim(
  dists = list(
    rnorm = list(mean = 85, sd = 25),
    rnorm = list(mean = 95, sd = 20),
    rnorm = list(mean = 105, sd = 15),
    rnorm = list(mean = 110, sd = 15)
  ),
  wide = FALSE, n = 6
)
m2$time &lt;- rep(1:4, times = 6 * 180)
mv_df2 &lt;- rbind(m1, m2)
mv_df2$group &lt;- rep(c("a", "b"), each = 4320)
mv_df2 &lt;- mv_df2[mv_df2$value &gt; 0, ]
mv_df2$label &lt;- as.numeric(gsub("sim_", "", mv_df2$variable))
ss_mv0 &lt;- mvSS(
  model = "linear", form = label | value ~ group, df = mv_df2,
  start = list("A" = 50), type = "brms", spectral_index = "ci_rededge"
)
ss_mv0 # non longitudinal model setup

ss_mv1 &lt;- mvSS(
  model = "linear", form = label | value ~ time | group, df = mv_df2,
  start = list("A" = 50), type = "brms", spectral_index = "ci_rededge"
)
ss_mv1
ss_mv2 &lt;- growthSS(
  model = "skew_normal: linear",
  form = label | resp_weights(value) + trunc(lb = -1, ub = Inf) ~ time | group,
  df = mv_df2, start = list("A" = 50)
)
ss_mv2
# ignoring environments and other such details these are identical except for the
# function call.
unlist(lapply(names(ss_mv1), function(nm) {
  if (!identical(ss_mv1[[nm]], ss_mv2[[nm]],
    ignore.environment = TRUE,
    ignore.srcref = TRUE
  )) {
    if (!identical(as.character(ss_mv1[[nm]]), as.character(ss_mv2[[nm]]))) {
      nm
    }
  }
}))


if (rlang::is_installed("mnormt")) {
  m2 &lt;- fitGrowth(ss_mv1, backend = "cmdstanr", iter = 1000, chains = 1, cores = 1)
  growthPlot(m2, ss_mv1$pcvrForm, df = ss_mv1$df)
}


</code></pre>

<hr>
<h2 id='net.plot'>Visualizing igraph networks</h2><span id='topic+net.plot'></span>

<h3>Description</h3>

<p>Easy igraph visualization with pcv.net output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.plot(
  net,
  fill = "strength",
  shape = NULL,
  size = 3,
  edgeWeight = "emd",
  edgeFilter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="net.plot_+3A_net">net</code></td>
<td>
<p>Network object similar to that returned from pcv.net, having dataframes named &quot;edges&quot;
and &quot;nodes&quot;</p>
</td></tr>
<tr><td><code id="net.plot_+3A_fill">fill</code></td>
<td>
<p>Variable name(s) from the nodes data to be used to color points. By default &quot;strength&quot;
is used.</p>
</td></tr>
<tr><td><code id="net.plot_+3A_shape">shape</code></td>
<td>
<p>Optional discrete variable name(s) from the nodes data to be used to change the shape
of points. If this variable is numeric it will be coerced to character.</p>
</td></tr>
<tr><td><code id="net.plot_+3A_size">size</code></td>
<td>
<p>Size of points, defaults to 3.</p>
</td></tr>
<tr><td><code id="net.plot_+3A_edgeweight">edgeWeight</code></td>
<td>
<p>Edge dataframe column to weight connections between nodes. Defaults to &quot;emd&quot;
for compatability with <code>pcv.emd</code>.</p>
</td></tr>
<tr><td><code id="net.plot_+3A_edgefilter">edgeFilter</code></td>
<td>
<p>How should edges be filtered? This can be either a numeric (0.5)
in which case it is taken as a filter where only edges with values greater than or equal to
that number are kept or a character string (&quot;0.5&quot;) in which case the strongest
X percentage of edges are kept. This defaults to NULL which does no filtering,
although that should not be considered the best standard behaviour. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot of a network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(extraDistr)
dists &lt;- list(
  rmixnorm = list(mean = c(70, 150), sd = c(15, 5), alpha = c(0.3, 0.7)),
  rnorm = list(mean = 90, sd = 3)
)
x &lt;- mvSim(
  dists = dists, n_samples = 5, counts = 1000,
  min_bin = 1, max_bin = 180, wide = TRUE
)
emd_df &lt;- pcv.emd(x,
  cols = "sim", reorder = c("group"), mat = FALSE,
  plot = FALSE, parallel = 1
)
net &lt;- pcv.net(emd_df, meta = "group")
net.plot(net)
net.plot(net, edgeFilter = "0.25")
net.plot(net,
  edgeFilter = 0.25, fill = c("degree", "group"),
  shape = c("degree", "group")
)
net.plot(net,
  edgeFilter = 0.25, fill = c("degree", "group"),
  shape = c("degree")
)

</code></pre>

<hr>
<h2 id='nlmePlot'>Function to visualize common <code>nlme::nlme</code> growth models.</h2><span id='topic+nlmePlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means)
can be visualized easily using this function. This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmePlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlmePlot_+3A_fit">fit</code></td>
<td>
<p>A model fit returned by <code>fitGrowth</code> with type=&quot;nlme&quot;.</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code> part of the
output) specifying the outcome, predictor, and grouping structure of the data as
<code>outcome ~ predictor|individual/group</code></p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for nlme models.</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the avaiable data has not reached some point (such as asymptotic size).</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE. If TRUE then
viridis colormaps are used in the order of virMaps.</p>
</td></tr>
<tr><td><code id="nlmePlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length.
Defaults to &quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an nlme model's credible
intervals and optionally the individual growth lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim("logistic",
  n = 10, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)

ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group, sigma = "none",
  df = simdf, start = NULL, type = "nlme"
)

fit &lt;- fitGrowth(ss)

nlmePlot(fit, form = ss$pcvrForm, groups = NULL, df = ss$df, timeRange = NULL)
nlmePlot(fit, form = ss$pcvrForm, groups = "a", df = ss$df, timeRange = 1:10, groupFill = TRUE)

</code></pre>

<hr>
<h2 id='nlrqPlot'>Function to visualize common <code>quantreg::nlrq</code> growth models.</h2><span id='topic+nlrqPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means)
can be visualized easily using this function. This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlrqPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlrqPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit, or list of model fits, returned by <code>fitGrowth</code> with type=&quot;nlrq&quot;.</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code> part of the
output) specifying the outcome, predictor, and grouping structure of the data as
<code>outcome ~ predictor|individual/group</code>. If the individual and group are specified then the
observed growth lines are plotted.</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for nlrq models.</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the avaiable data has not reached some point (such as asymptotic size).</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE.
If TRUE then viridis colormaps are used in the order of virMaps</p>
</td></tr>
<tr><td><code id="nlrqPlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length.
Defaults to &quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an nlrq model's quantiles
and optionally the individual growth lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  tau = c(0.5, 0.9), df = simdf, start = NULL, type = "nlrq"
)
fit &lt;- fitGrowth(ss)
nlrqPlot(fit, form = ss$pcvrForm, df = ss$df, groups = "a", timeRange = 1:20)
nlrqPlot(fit, form = ss$pcvrForm, df = ss$df, groupFill = TRUE, virMaps = c("plasma", "viridis"))

ss &lt;- growthSS(
  model = "logistic", form = y ~ time,
  tau = c(0.5, 0.9), df = simdf, start = NULL, type = "nlrq"
)
fit &lt;- fitGrowth(ss)
nlrqPlot(fit, form = ss$pcvrForm, df = ss$df)

</code></pre>

<hr>
<h2 id='nlsPlot'>Function to visualize common <code>stats::nls</code> growth models.</h2><span id='topic+nlsPlot'></span><span id='topic+gamPlot'></span><span id='topic+lmPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means) can be visualized easily using this function.
This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)

gamPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)

lmPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlsPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit returned by <code>fitGrowth</code> with type=&quot;nls&quot;.</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code>
part of the output) specifying the outcome, predictor, and grouping structure of the data as
<code>outcome ~ predictor|individual/group</code>.
If the individual and group are specified then the observed growth lines are plotted.</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for nls models.</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the avaiable data has not reached some point (such as asymptotic size).</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE.
If TRUE then viridis colormaps are used in the order of virMaps</p>
</td></tr>
<tr><td><code id="nlsPlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length.
Defaults to &quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an nls model's predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "logistic", form = y ~ time | id / group,
  df = simdf, start = NULL, type = "nls"
)
fit &lt;- fitGrowth(ss)
nlsPlot(fit, form = ss$pcvrForm, df = ss$df, groupFill = TRUE)
nlsPlot(fit, form = ss$pcvrForm, df = ss$df, groups = "a", timeRange = 1:10)

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "gam", form = y ~ time | id / group,
  df = simdf, start = NULL, type = "nls"
)
fit &lt;- fitGrowth(ss)
gamPlot(fit, form = ss$pcvrForm, df = ss$df, groupFill = TRUE)
gamPlot(fit, form = ss$pcvrForm, df = ss$df, groups = "a", timeRange = 1:10)
ss &lt;- growthSS(
  model = "gam", form = y ~ time | group,
  df = simdf, start = NULL, type = "nls"
)
fit &lt;- fitGrowth(ss)
gamPlot(fit, form = ss$pcvrForm, df = ss$df, groupFill = TRUE)

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "gam", form = y ~ time | id / group,
  df = simdf, start = NULL, type = "nls"
)
fit &lt;- fitGrowth(ss)
lmPlot(fit, form = ss$pcvrForm, df = ss$df)
</code></pre>

<hr>
<h2 id='pcadf'>Function to run a PCA, plot and optionally return the data with PCA coordinates and pca object</h2><span id='topic+pcadf'></span>

<h3>Description</h3>

<p>Function to run a PCA, plot and optionally return the data with PCA coordinates and pca object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcadf(
  df = NULL,
  cols = NULL,
  color = NULL,
  facet = NULL,
  returnData = TRUE,
  ncp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcadf_+3A_df">df</code></td>
<td>
<p>Dataframe to ordinate</p>
</td></tr>
<tr><td><code id="pcadf_+3A_cols">cols</code></td>
<td>
<p>columns to reduce dimensions of. Can be specified with names or positions.
If this is length of 1 then it is treated as regex pattern to match
the column names that should be used.</p>
</td></tr>
<tr><td><code id="pcadf_+3A_color">color</code></td>
<td>
<p>column name(s) used to color points in the pca plot.</p>
</td></tr>
<tr><td><code id="pcadf_+3A_facet">facet</code></td>
<td>
<p>Optional column or vector to facet plots on.</p>
</td></tr>
<tr><td><code id="pcadf_+3A_returndata">returnData</code></td>
<td>
<p>Logical, should data be returned?</p>
</td></tr>
<tr><td><code id="pcadf_+3A_ncp">ncp</code></td>
<td>
<p>Optional, number of principal components to return attached
to dataframe if data is returned. Defaults to all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is returned then it will contain the coordinates from the
PCA and will not contain the columns that were reduced.
</p>


<h3>Value</h3>

<p>A ggplot or list with a ggplot, a dataframe with the data and PCs, and the factominer
PCA object as elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dists &lt;- list(
  rlnorm = list(meanlog = log(40), sdlog = 0.5),
  rnorm = list(mean = 60, sd = 10)
)
mv &lt;- mvSim(
  dists = dists, n_samples = 100, counts = 1000,
  min_bin = 1, max_bin = 180, wide = TRUE
)
mv$otherGroup &lt;- sample(c("a", "b"), size = nrow(mv), replace = TRUE)
pcadf(mv, cols = "sim_", returnData = TRUE)
pcadf(mv, cols = 2:181, color = c("group", "otherGroup"), returnData = FALSE)

</code></pre>

<hr>
<h2 id='pcv_theme'>Default theme for ggplots made by pcvr functions.</h2><span id='topic+pcv_theme'></span>

<h3>Description</h3>

<p>Default theme for ggplots made by pcvr functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcv_theme()
</code></pre>


<h3>Value</h3>

<p>A ggplot theme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot2::ggplot() +
  pcv_theme()
</code></pre>

<hr>
<h2 id='pcv.emd'>Earth Mover's Distance between spectral histograms</h2><span id='topic+pcv.emd'></span><span id='topic+pcv.euc'></span>

<h3>Description</h3>

<p>pcv.emd can be used to calculate Earth Mover's Distance between pairwise histograms
in a wide dataframe of multi value traits. The is expected to be used with output from <code>mv_ag</code>.
See also <a href="#topic+pcv.euc">pcv.euc</a> for euclidean distance between histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcv.emd(
  df,
  cols = NULL,
  reorder = NULL,
  include = reorder,
  mat = FALSE,
  plot = TRUE,
  parallel = getOption("mc.cores", 1),
  trait = "trait",
  id = "image",
  value = "value",
  raiseError = TRUE,
  method = "emd"
)

pcv.euc(
  df,
  cols = NULL,
  reorder = NULL,
  include = reorder,
  mat = FALSE,
  plot = TRUE,
  parallel = getOption("mc.cores", 1),
  trait = "trait",
  id = "image",
  value = "value",
  raiseError = TRUE,
  method = "euc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcv.emd_+3A_df">df</code></td>
<td>
<p>Data frame to use with multi value traits in wide format or long format</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_cols">cols</code></td>
<td>
<p>Columns to use. Defaults to NULL in which case all columns are used.
Single strings will be used to regex a pattern in column names (see examples).
A vector of names, positions, or booleans will also work.
For long data this is taken as a regex pattern (or full name)
to use in filtering the trait column.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_reorder">reorder</code></td>
<td>
<p>Should data be reordered to put similar rows together in the resulting plot?
This takes a vector of column names of length 1 or more (see examples).</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_include">include</code></td>
<td>
<p>if a long dataframe is returned then these columns will be added to the dataframe,
labelled for i and j (the row positions for compared histograms).
If a matrix is returned then this information is stored in the row names.
This defaults to reorder.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_mat">mat</code></td>
<td>
<p>Logical, should data be returned as an nrow x nrow matrix or as a long dataframe?
By Default this is FALSE and a long dataframe is returned.
Both options are comparable in terms of speed,
although for large datasets the matrix version may be slightly faster.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_plot">plot</code></td>
<td>
<p>Logical, should a plot be returned? For a matrix this is made with heatmap(),
for a dataframe this uses ggplot.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_parallel">parallel</code></td>
<td>
<p>Number of cores to use. Defaults to 1 unless the &quot;mc.cores&quot; option is set.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_trait">trait</code></td>
<td>
<p>Column name for long data to identify traits. This defaults to &quot;trait&quot;. If this and
value are in the column names of the data then it is assumed to be in long format,
otherwise it is assumed to be in wide format.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_id">id</code></td>
<td>
<p>A vector of column names that uniquely identifies observations if the
data is in long format. Defaults to &quot;image&quot;.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_value">value</code></td>
<td>
<p>A column name for the values to be drawn from in long data.
Defaults to &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_raiseerror">raiseError</code></td>
<td>
<p>Logical, should warnings/errors be raised for potentially large output?
It is easy to ask for very many comparisons with this function so the goal of this argument
is to catch a few of those and give estimates of how much time something may take.
If the function is expected to take very long then a warning or an error is raised.
If this is set to FALSE then no time estimates are made.</p>
</td></tr>
<tr><td><code id="pcv.emd_+3A_method">method</code></td>
<td>
<p>Which method to use (one of &quot;emd&quot; or &quot;euc&quot;). Defaults to &quot;emd&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe/matrix (if plot=FALSE) or a list with a dataframe/matrix and\
a ggplot (if plot=TRUE). The returned data contains pairwise EMD values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(123)
test &lt;- mvSim(
  dists = list(
    runif = list(min = 0, max = 100),
    rnorm = list(mean = 90, sd = 20)
  ),
  n_samples = 10
)
test$meta1 &lt;- rep(LETTERS[1:3], length.out = nrow(test))
test$meta2 &lt;- rep(LETTERS[4:5], length.out = nrow(test))

x &lt;- pcv.emd(
  df = test, cols = "sim", reorder = "group",
  include = c("meta1", "meta2"), mat = FALSE,
  plot = FALSE, parallel = 1
)
head(x)
x2 &lt;- pcv.emd(
  df = test, cols = "sim", reorder = "group",
  include = c("meta1", "meta2"), mat = FALSE,
  plot = FALSE, parallel = 1, method = "euc"
)
head(x2)


tryCatch(
  {
    library(data.table)
    file &lt;- paste0(
      "https://media.githubusercontent.com/media/joshqsumner/",
      "pcvrTestData/main/pcv4-multi-value-traits.csv"
    )
    df1 &lt;- read.pcv(file, "wide", reader = "fread")

    df1$genotype &lt;- substr(df1$barcode, 3, 5)
    df1$genotype &lt;- ifelse(df1$genotype == "002", "B73",
      ifelse(df1$genotype == "003", "W605S",
        ifelse(df1$genotype == "004", "MM", "Mo17")
      )
    )
    df1$fertilizer &lt;- substr(df1$barcode, 8, 8)
    df1$fertilizer &lt;- ifelse(df1$fertilizer == "A", "100",
      ifelse(df1$fertilizer == "B", "50", "0")
    )

    w &lt;- pcv.emd(df1,
      cols = "hue_frequencies", reorder = c("fertilizer", "genotype"),
      mat = FALSE, plot = TRUE, parallel = 1
    )
  },
  error = function(err) {
    message(err)
  }
)

# Note on computational complexity
# This scales as O^2, see the plot below for some idea
# of the time for different input data sizes.
emdTime &lt;- function(x, n = 1) {
  x^2 / n * 0.0023
}
plot(
  x = c(18, 36, 54, 72, 108, 135), y = c(0.74, 2.89, 6.86, 10.99, 26.25, 42.44),
  xlab = "N Input Images", ylab = "time (seconds)"
) # benchmarked test data
lines(x = 1:150, y = emdTime(1:150)) # exponential function

plot(
  x = 1:1000, y = emdTime(1:1000), type = "l",
  xlab = "N Input Images", ylab = "time (seconds)"
)


</code></pre>

<hr>
<h2 id='pcv.joyplot'>Make Joyplots for multi value trait plantCV data</h2><span id='topic+pcv.joyplot'></span>

<h3>Description</h3>

<p>Make Joyplots for multi value trait plantCV data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcv.joyplot(
  df = NULL,
  index = NULL,
  group = NULL,
  y = NULL,
  id = NULL,
  bin = "label",
  freq = "value",
  trait = "trait",
  fillx = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcv.joyplot_+3A_df">df</code></td>
<td>
<p>Data frame to use. Long or wide format is accepted.</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_index">index</code></td>
<td>
<p>If the data is long then this is a multi value trait as a
character string that must be present in 'trait'.
If the data is wide then this is a string used to find column names to use from the wide data.
In the wide case this should include the entire
trait name (ie, &quot;hue_frequencies&quot; instead of &quot;hue_freq&quot;).</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_group">group</code></td>
<td>
<p>A length 1 or 2 character vector.
This is used for faceting the joyplot and identifying groups for testing.
If this is length 1 then no faceting is done.</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_y">y</code></td>
<td>
<p>Optionally a variable to use on the y axis. This is useful when you
have three variables to display. This argument will change faceting behavior to
add an additional layer of faceting (single length group will be faceted,
length 2 group will be faceted group1 ~ group2).</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_id">id</code></td>
<td>
<p>Optionally a variable to show the outline of different replicates.
Note that ggridges::geom_density_ridges_gradient does not support transparency,
so if fillx is TRUE then only the outer line will show individual IDs.</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_bin">bin</code></td>
<td>
<p>Column containing histogram (multi value trait) bins. Defaults to &quot;label&quot;.</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_freq">freq</code></td>
<td>
<p>Column containing histogram counts. Defaults to &quot;value&quot;</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_trait">trait</code></td>
<td>
<p>Column containing phenotype names. Defaults to &quot;trait&quot;.</p>
</td></tr>
<tr><td><code id="pcv.joyplot_+3A_fillx">fillx</code></td>
<td>
<p>Logical, whether or not to use <code>ggridges::geom_density_ridges_gradient</code>.
Default is T, if F then <code>ggridges::geom_density_ridges</code> is used instead,
with arbitrary fill. Note that <code>ggridges::geom_density_ridges_gradient</code>
may issue a message about deprecated ggplot2 features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(extraDistr)
dists &lt;- list(
  rmixnorm = list(mean = c(70, 150), sd = c(15, 5), alpha = c(0.3, 0.7)),
  rnorm = list(mean = 90, sd = 20),
  rlnorm = list(meanlog = log(40), sdlog = 0.5)
)
x_wide &lt;- mvSim(
  dists = dists, n_samples = 5, counts = 1000,
  min_bin = 1, max_bin = 180, wide = TRUE
)
pcv.joyplot(x_wide, index = "sim", group = "group")
x_long &lt;- mvSim(
  dists = dists, n_samples = 5, counts = 1000,
  min_bin = 1, max_bin = 180, wide = FALSE
)
x_long$trait &lt;- "x"
p &lt;- pcv.joyplot(x_long, bin = "variable", group = "group")
# we might want to display hues as their hue
p + ggplot2::scale_fill_gradientn(colors = scales::hue_pal(l = 65)(360))
x_long$group2 &lt;- "example"
pcv.joyplot(x_long, bin = "variable", y = "group", fillx = FALSE)

</code></pre>

<hr>
<h2 id='pcv.net'>Network analysis of a distance matrix</h2><span id='topic+pcv.net'></span>

<h3>Description</h3>

<p>Easy igraph use with pcv.emd output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcv.net(
  emd = NULL,
  meta = NULL,
  dissim = TRUE,
  distCol = "emd",
  filter = 0.5,
  direction = "greater"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcv.net_+3A_emd">emd</code></td>
<td>
<p>A long dataframe as returned by pcv.emd.
Currently this function is only made to work with dataframe output,
not distance matrix output.</p>
</td></tr>
<tr><td><code id="pcv.net_+3A_meta">meta</code></td>
<td>
<p>Metadata to be carried from pcv.emd output into the network,
defaults to NULL which will use all metadata.
Type conversion will be attempted for these columns.</p>
</td></tr>
<tr><td><code id="pcv.net_+3A_dissim">dissim</code></td>
<td>
<p>Logical, should the distCol be inverted to make a dissimilarity value?</p>
</td></tr>
<tr><td><code id="pcv.net_+3A_distcol">distCol</code></td>
<td>
<p>The name of the column containing distances/dissimilarities.
Defaults to &quot;emd&quot; for compatability with pcv.emd</p>
</td></tr>
<tr><td><code id="pcv.net_+3A_filter">filter</code></td>
<td>
<p>This can be either a numeric (0.5) in which case it is taken as
a filter where only edges with values greater than or equal to that number are
kept or a character string (&quot;0.5&quot;) in which case the strongest X percentage of edges are kept.
This defaults to 0.5 which does some filtering, although that should not be considered
the best behavior for every setting. If this is NULL then your network will be
almost always be a single blob, if set too high there will be very few nodes.
Note that this filtering happens after converting to dissimilarity if dissim=TRUE.</p>
</td></tr>
<tr><td><code id="pcv.net_+3A_direction">direction</code></td>
<td>
<p>Direction of filtering, can be either &quot;greater&quot; or &quot;lesser&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing three elements:
<code>nodes</code>: A dataframe of node data.
<code>edges</code>: A dataframe of edges between nodes.
<code>graph</code>: The network as an igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(extraDistr)
dists &lt;- list(
  rmixnorm = list(mean = c(70, 150), sd = c(15, 5), alpha = c(0.3, 0.7)),
  rnorm = list(mean = 90, sd = 3)
)
x &lt;- mvSim(
  dists = dists, n_samples = 5, counts = 1000,
  min_bin = 1, max_bin = 180, wide = TRUE
)
emd_df &lt;- pcv.emd(x,
  cols = "sim", reorder = c("group"), mat = FALSE,
  plot = FALSE, parallel = 1
)
net &lt;- pcv.net(emd_df, meta = "group")
net2 &lt;- pcv.net(emd_df, meta = "group", filter = "0.9", direction = "lesser")

</code></pre>

<hr>
<h2 id='pcv.plsr'>Run Partial Least Squares Regression on spectral data</h2><span id='topic+pcv.plsr'></span>

<h3>Description</h3>

<p>Partial Least Squares Regression (plsr) is often used to analyze spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcv.plsr(df, resps = NULL, spectra = NULL, train = 0.8, cv = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcv.plsr_+3A_df">df</code></td>
<td>
<p>Data frame containing metadata and spectral histogram data</p>
</td></tr>
<tr><td><code id="pcv.plsr_+3A_resps">resps</code></td>
<td>
<p>Vector of response variables.</p>
</td></tr>
<tr><td><code id="pcv.plsr_+3A_spectra">spectra</code></td>
<td>
<p>Either one column name (in the case of long data) or a set of columns in the case of
wide data. If a single character string is provided and it is not one of the column names then it is
taken to be a pattern that will match some set of column names in the data to use (see examples).</p>
</td></tr>
<tr><td><code id="pcv.plsr_+3A_train">train</code></td>
<td>
<p>Proportion of data to use as training data.</p>
</td></tr>
<tr><td><code id="pcv.plsr_+3A_cv">cv</code></td>
<td>
<p>Number of cross validation iterations.</p>
</td></tr>
<tr><td><code id="pcv.plsr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to caret::train.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that columns that sum to 0 in the training or test data will be removed.
This function also uses the 'pls' method from the pls package.
</p>


<h3>Value</h3>

<p>a list of lists each with model performance, prediction target, model, plot, N components,
and variable influence on projection components for each response variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (rlang::is_installed("pls")) {
  dists &lt;- list(
    rlnorm = list(meanlog = log(40), sdlog = 0.5),
    rlnorm = list(meanlog = log(60), sdlog = 0.35)
  )
  mv &lt;- mvSim(
    dists = dists, n_samples = 100, counts = 1000,
    min_bin = 1, max_bin = 180, wide = TRUE
  )
  sv &lt;- growthSim("logistic",
    n = 5, t = 20,
    params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
  )
  d &lt;- cbind(sv, mv[, -1])
  # note that this requires the "pls" package to be installed.
  x &lt;- pcv.plsr(df = d, resps = "y", spectra = grepl("^sim_", colnames(d)))
}

</code></pre>

<hr>
<h2 id='pcvrss-class'>Class <code>pcvrss</code> for models specified in <code>pcvr</code>.</h2><span id='topic+pcvrss-class'></span><span id='topic+pcvrss'></span>

<h3>Description</h3>

<p>Models specified by <a href="#topic+growthSS">growthSS</a> or <a href="#topic+mvSS">mvSS</a> are represented by a <code>pcvrss</code> object,
which contains the model type, formulas, starting values or priors, the data for the model
to use, and the model backend to use.
</p>


<h3>Details</h3>

<p>See <code>methods(class = "pcvrss")</code> for an overview of available methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>formula</code></dt><dd><p>The formula that will be used to fit the model.</p>
</dd>
<dt><code>prior</code></dt><dd><p>Priors if the model is a Bayesian model (ie using the brms backend).</p>
</dd>
<dt><code>initfun</code></dt><dd><p>Initialization function if the model is a Bayesian model.</p>
</dd>
<dt><code>df</code></dt><dd><p>The data that will be used to fit the model.</p>
</dd>
<dt><code>family</code></dt><dd><p>The model family, currently only used in the brms backend.</p>
</dd>
<dt><code>pcvrForm</code></dt><dd><p>The formula that was specified in <a href="#topic+growthSS">growthSS</a> and used in other pcvr functions.</p>
</dd>
<dt><code>type</code></dt><dd><p>The model backend.</p>
</dd>
<dt><code>model</code></dt><dd><p>The name of the main growth formula.</p>
</dd>
<dt><code>call</code></dt><dd><p>The call to <a href="#topic+growthSS">growthSS</a> or <a href="#topic+mvSS">mvSS</a>.</p>
</dd>
<dt><code>start</code></dt><dd><p>Starting values for frequentist models.</p>
</dd>
<dt><code>taus</code></dt><dd><p>Quantiles for nlrq/rq models.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+growthSS">growthSS</a></code>,
<code><a href="#topic+mvSS">mvSS</a></code>
</p>

<hr>
<h2 id='plotPrior'>Check priors used in ease of use brms functions</h2><span id='topic+plotPrior'></span>

<h3>Description</h3>

<p>Check priors used in ease of use brms functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPrior(priors, type = "density", n = 200, t = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPrior_+3A_priors">priors</code></td>
<td>
<p>A named list of means for prior distributions.
This takes the same input as the prior argument of <code><a href="#topic+growthSS">growthSS</a></code>.
Alternatively, if given the output of growthSS this will preform a prior predictive check
and return a plot from <code><a href="#topic+growthPlot">growthPlot</a></code> of that check ignoring all other arguments.
Note that all priors must be
proper in that case (non-flat) and the fit is likely to be strange looking due to how thick
tailed the default priors from <code><a href="#topic+growthSS">growthSS</a></code> are.</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_type">type</code></td>
<td>
<p>Either &quot;density&quot;, the default, or a model as would be specified in <code>growthSS</code>
or <code>growthSim</code> such as &quot;logistic&quot;, &quot;gompertz&quot;, &quot;monomolecular&quot;, &quot;exponential&quot;,
&quot;linear&quot;, &quot;power law&quot;, &quot;double logistic&quot;, or &quot;double gompertz&quot;.
If this is a model type then n draws from the prior will be simulated as growth
trendlines and densities will be plotted on margins for some distributions.</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_n">n</code></td>
<td>
<p>Numeric, if type is a model then how many draws from the prior should be simulated?</p>
</td></tr>
<tr><td><code id="plotPrior_+3A_t">t</code></td>
<td>
<p>Numeric, time passed to growthSim. Defaults to 25 (the growthSim default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of plots showing prior distributions that <code>growthSS</code> would use,
optionally with a plot of simulated growth curves using draws from those priors.
</p>


<h3>See Also</h3>

<p><a href="#topic+barg">barg</a> for Bayesian model reporting metrics, <a href="#topic+growthSim">growthSim</a> for simulating data using
similar specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
priors &lt;- list("A" = c(100, 130), "B" = c(10, 8), "C" = c(0.2, 0.1))
plotPrior(priors)

plotPrior(priors, "gompertz")[[1]]

</code></pre>

<hr>
<h2 id='plotVIP'>Plot Variable Influence on Projection</h2><span id='topic+plotVIP'></span>

<h3>Description</h3>

<p>This function is used to visualize variable influence on projection (vip) from a plsr
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVIP(plsrObject, i = 1, mean = FALSE, removePattern = ".*_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVIP_+3A_plsrobject">plsrObject</code></td>
<td>
<p>Output from pcv.plsr</p>
</td></tr>
<tr><td><code id="plotVIP_+3A_i">i</code></td>
<td>
<p>An index from the plsrObject to use if the plsrObject contains models for several outcomes.
Can be a name or a position. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plotVIP_+3A_mean">mean</code></td>
<td>
<p>Logical, should the mean be plotted (TRUE)
or should the components be shown individually (FALSE, the default).</p>
</td></tr>
<tr><td><code id="plotVIP_+3A_removepattern">removePattern</code></td>
<td>
<p>A pattern to remove to make the wavelength column into a numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot showing variable influence on projection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (rlang::is_installed("pls")) {
  dists &lt;- list(
    rlnorm = list(meanlog = log(40), sdlog = 0.5),
    rlnorm = list(meanlog = log(60), sdlog = 0.35)
  )
  mv &lt;- mvSim(
    dists = dists, n_samples = 100, counts = 1000,
    min_bin = 1, max_bin = 180, wide = TRUE
  )
  sv &lt;- growthSim("logistic",
    n = 5, t = 20,
    params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
  )
  d &lt;- cbind(sv, mv[, -1])
  x &lt;- pcv.plsr(df = d, resps = "y", spectra = grepl("^sim_", colnames(d)))
  plotVIP(x)
}

</code></pre>

<hr>
<h2 id='print.pcvrss'>Print a <code>pcvrss</code> object.</h2><span id='topic+print.pcvrss'></span>

<h3>Description</h3>

<p>Print a <code>pcvrss</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcvrss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pcvrss_+3A_x">x</code></td>
<td>
<p>An object of class <code>pcvrss</code>
to method <code>summary</code> of <code>pcvrss</code>.</p>
</td></tr>
<tr><td><code id="print.pcvrss_+3A_...">...</code></td>
<td>
<p>further arguments, passed to print.default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.pcvrss">summary.pcvrss</a></code>
</p>

<hr>
<h2 id='print.pcvrsssummary'>Print a <code>pcvrsssummary</code> object.</h2><span id='topic+print.pcvrsssummary'></span>

<h3>Description</h3>

<p>Print a <code>pcvrsssummary</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcvrsssummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pcvrsssummary_+3A_x">x</code></td>
<td>
<p>An object of class <code>pcvrsssummary</code>.</p>
</td></tr>
<tr><td><code id="print.pcvrsssummary_+3A_...">...</code></td>
<td>
<p>further arguments, which are currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.pcvrsssummary">print.pcvrsssummary</a></code>
</p>

<hr>
<h2 id='pwue'>Calculate pseudo water use efficiency from phenotype and watering data</h2><span id='topic+pwue'></span>

<h3>Description</h3>

<p>Rate based water use efficiency (WUE) is the change in biomass per unit of water
metabolized. Using image based phenotypes and watering data we can calculate pseudo-WUE (pwue) over
time. Here area_pixels is used as a proxy for biomass and transpiration is approximated using
watering data. The equation is then
<code class="reqn">
\frac{P_{t} - P_{t-1}}{W_{t_{end-1}}-W_{t_{start}} }</code>,
where P is the phenotype and W is the weight before watering.
</p>
<p>Absolute value based WUE is the amount of water used to sustain a plants biomass over a given period.
The equation is then
<code class="reqn">\frac{P_{t}}{W_{t_{end-1}}-W_{t_{start}} }</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwue(
  df,
  w,
  pheno = "area_pixels",
  time = "timestamp",
  id = "barcode",
  offset = 0,
  waterCol = "water_amount",
  method = "rate"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwue_+3A_df">df</code></td>
<td>
<p>Dataframe containing wide single-value phenotype data.
This should already be aggregated to one row per plant per day (angles/rotations combined).</p>
</td></tr>
<tr><td><code id="pwue_+3A_w">w</code></td>
<td>
<p>Watering data as returned from bw.water.</p>
</td></tr>
<tr><td><code id="pwue_+3A_pheno">pheno</code></td>
<td>
<p>Phenotype column name, defaults to &quot;area_pixels&quot;</p>
</td></tr>
<tr><td><code id="pwue_+3A_time">time</code></td>
<td>
<p>Variable(s) that identify a plant on a given day.
Defaults to <code>c("barcode", "DAS")</code>.</p>
</td></tr>
<tr><td><code id="pwue_+3A_id">id</code></td>
<td>
<p>Variable(s) that identify a plant over time. Defaults to <code>"barcode"</code>.</p>
</td></tr>
<tr><td><code id="pwue_+3A_offset">offset</code></td>
<td>
<p>Optionally you can specify how long before imaging a watering should not be taken into
account. This defaults to 0, meaning that if a plant were watered directly before being imaged then
that water would be counted towards WUE between the current image and the prior one.
This argument is taken to be in seconds.</p>
</td></tr>
<tr><td><code id="pwue_+3A_watercol">waterCol</code></td>
<td>
<p>Column containing watering amounts in <code>w</code>. This defaults to &quot;watering_amount&quot;.</p>
</td></tr>
<tr><td><code id="pwue_+3A_method">method</code></td>
<td>
<p>Which method to use, options are &quot;rate&quot; and &quot;abs&quot;. The &quot;rate&quot; method considers WUE as
the change in a phenotype divided by the amount of water added. The &quot;abs&quot; method considers WUE as
the amount of water used by a plant given its absolute size. The former is for questions more
related to efficiency in using water to grow while the latter is more suited to questions about
how efficient a plant is at maintaining size given some amount of water.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the bellwether watering data joined
to phenotype data with new columns for change in the phenotype,
change in the pre-watering weight, and pseudo-water use efficiency (pWUE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_water &lt;- data.frame(
  "barcode" = "exampleBarcode1",
  "timestamp" = as.POSIXct(c(
    "2023-04-13 23:28:17 UTC",
    "2023-04-22 05:30:42 UTC",
    "2023-05-04 18:55:38 UTC"
  )),
  "DAS" = c(0.000000, 8.251675, 20.810660),
  "water_amount" = c(98, 12, -1)
)
sim_df &lt;- data.frame(
  "barcode" = "exampleBarcode1",
  "timestamp" = as.POSIXct(c(
    "2023-04-13 23:28:17 UTC",
    "2023-04-22 05:30:42 UTC",
    "2023-05-04 18:55:38 UTC"
  )),
  "DAS" = c(0.000000, 8, 20),
  "area_pixels" = c(20, 1000, 1500)
)
pwue(
  df = sim_df, w = sim_water, pheno = "area_pixels",
  time = "timestamp", id = "barcode", offset = 0,
  waterCol = "water_amount", method = "rate"
)

pwue(
  df = sim_df, w = sim_water, pheno = "area_pixels",
  time = c("timestamp", "timestamp"), id = "barcode", offset = 0,
  waterCol = "water_amount", method = "abs"
)

</code></pre>

<hr>
<h2 id='read.pcv'>Read in plantCV csv output in wide or long format</h2><span id='topic+read.pcv'></span>

<h3>Description</h3>

<p>Read in plantCV csv output in wide or long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pcv(
  filepath,
  mode = NULL,
  traitCol = "trait",
  labelCol = "label",
  valueCol = "value",
  reader = NULL,
  filters = NULL,
  awk = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pcv_+3A_filepath">filepath</code></td>
<td>
<p>Path to csv file of plantCV output.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_mode">mode</code></td>
<td>
<p>NULL (the default) or one of &quot;wide&quot; or &quot;long&quot;, partial string matching is supported.
This controls whether data is <strong>returned</strong> in long or wide format. If left NULL then
the output format will be the same as the input format.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.
This should generally not need to be changed from the default. This,
labelCol, and valueCol are used to determine if data are in long format in their
raw state (the csv file itself).</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_labelcol">labelCol</code></td>
<td>
<p>Column with phenotype labels (units), defaults to &quot;label&quot;.
This should generally not need to be changed from the default.
This is used with traitCol when <code>mode="wide"</code> to identify
unique traits since some may be ambiguous
(ellipseCenter.x vs ellipseCenter.y, bins of histograms, etc)</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_reader">reader</code></td>
<td>
<p>The function to use to read in data,
defaults to NULL in which case <code>data.table::fread</code> is used if filters are in place
and <code>read.csv</code> is used otherwise.
Note that if you use <code>read.csv</code> with filters in place then you will need to specify
<code>header=FALSE</code> so that the piped output from awk is read correctly.
If fread is too slow for your needs then <code>vroom::vroom()</code> may be useful.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_filters">filters</code></td>
<td>
<p>If a very large pcv output file is read then it may be desireable
to subset it before reading it into R, either for ease of use or because of RAM limitations.
The filter argument works with &quot;COLUMN in VALUES&quot; syntax. This can either be a character vector
or a list of character vectors. In these vectors there needs to be a column name,
one of &quot; in &quot;, &quot; is &quot;, or &quot; = &quot; to match the string exactly, or &quot;contains&quot;
to match with awk style regex, then a set of comma delimited values to filter
that column for (see examples). Note that this and awk both use awk through <code>pipe()</code>.
This functionality will not work on a windows system.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_awk">awk</code></td>
<td>
<p>As an alternative to filters a direct call to awk can be supplied here,
in which case that call will be used through <code>pipe()</code>.</p>
</td></tr>
<tr><td><code id="read.pcv_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the reader function.
In the case of 'fread' there are several defaults provided already
which can be overwritten with these extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In plantCV version 4 the single value traits are returned in wide format from <code>json2csv</code>
and the multi value traits are returned in long format. Briefly plantCV data was returned as one
long table which sparked the emphasis in this function on reading data quickly and parsing it
outside of R. With the current plantCV output these options are largely unnecessary.
When data is read in using read.pcv the traitCol, valueCol, and labelCol arguments are checked
to determine if the data is in long format. This is done to keep compatibility with interim
versions of plantcv output where all outputs were in a single long format file.
</p>
<p>With the current implementation and plantcv output you can read wide or long format files into
wide or long format in R. Keep in mind that the 'mode' argument controls the format that will be
returned in R, not the format that the data saved as in your csv file.
</p>


<h3>Value</h3>

<p>Returns a data.frame in wide or long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch(
  {
    mv &lt;- paste0(
      "https://media.githubusercontent.com/media/joshqsumner/",
      "pcvrTestData/main/pcv4-multi-value-traits.csv"
    )
    sv &lt;- paste0(
      "https://raw.githubusercontent.com/joshqsumner/",
      "pcvrTestData/main/pcv4-single-value-traits.csv"
    )

    w2w &lt;- read.pcv(sv, mode = "wide", reader = "fread")
    dim(w2w)

    w2l &lt;- read.pcv(sv, mode = "long", reader = "fread")
    dim(w2l)

    l2w &lt;- read.pcv(mv, mode = "wide", reader = "fread")
    dim(l2w)

    l2l &lt;- read.pcv(mv, mode = "long", reader = "fread")
    dim(l2l)
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='read.pcv.3'>Read in plantCV csv from bellwether phenotyper style experiments analyzed with plantCV versions &lt;4.</h2><span id='topic+read.pcv.3'></span>

<h3>Description</h3>

<p>Read in plantCV csv from bellwether phenotyper style experiments analyzed with plantCV versions &lt;4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pcv.3(
  file = NULL,
  snapshotFile = NULL,
  designFile = NULL,
  metaCol = "meta",
  metaForm = "vis_view_angle_zoom_horizontal_gain_exposure_v_new_n_rep",
  joinSnapshot = "id",
  conversions = NULL,
  mode = "long",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pcv.3_+3A_file">file</code></td>
<td>
<p>Path to the version 3 plantCV output containing phenotypes.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_snapshotfile">snapshotFile</code></td>
<td>
<p>path to the snapshot info metadata file, typically called SnapshotInfo.csv.
This needs to have a column name corresponding to 'joinSnapshot' (defaults to &quot;id&quot;)
which can be used to join the snapshot data to the phenotype data.
Generally this joining will happen through a parsed section of the file path
to each image present in the phenotype data.
This means that including a duplicate name in 'metaForm' will be overwritten
by parsing image paths, so 'metaForm' and 'joinSnapshot' should not have duplicated names.
If there is a timestamp column in the snapshot data then it will
be converted to datetime (assuming a &quot;Y-m-d H:M:S&quot; format)
and used to calculate days after starting (DAS) and hours.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_designfile">designFile</code></td>
<td>
<p>path to a csv file which contains experimental design information
(treatments, genotypes, etc) and which will be joined to phenotype
and snapshot data through all shared columns.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_metacol">metaCol</code></td>
<td>
<p>a column name from the phenotype data read in with the 'file' argument.
Generally for bellwether experiments this will correspond to an image path.
The name is split on &quot;/&quot; characters with the last segment being taken and parsed into
some number of sections based on 'metaForm'.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_metaform">metaForm</code></td>
<td>
<p>A character string or character vector of column names to parse 'metaCol' into.
The number of names needs to match with length of 'metaCol' when parsed.
If a character string is provided then it is assumed to be underscore delimited,
so do if you need underscores in a column name then use 'c(&quot;column_one&quot;, &quot;column_two&quot;,...)'
instead of 'column_one_column_two_...'.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_joinsnapshot">joinSnapshot</code></td>
<td>
<p>Column name create in phenotype data to use in joining snapshot data.
By default this will attempt to make an &quot;id&quot; column, which is parsed from a snapshot
folder in 'metaCol' (&quot;/shares/sinc/data/Phenotyper/SINC1/ImagesNew/**snapshot1403**/&quot;).
An error will be raised if this column is not present in the snapshot data.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_conversions">conversions</code></td>
<td>
<p>A named list of phenotypes that should be rescaled by the value in the list.
For instance, at zoom 1  'list(area = 13.2 * 3.7/46856)'
will convert from pixels to square cm in the 5MP bellwether camera.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_mode">mode</code></td>
<td>
<p>The mode to read data in with through read.pcv.
The default is &quot;long&quot; because this function is built for pcv3 output,
which was generally a wider format to start with than pcv4 output.</p>
</td></tr>
<tr><td><code id="read.pcv.3_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>read.pcv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe potentially with several files merged into it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch(
  {
    base_url &lt;- "https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/"
    bw &lt;- read.pcv.3(
      file = paste0(base_url, "pcv3Phenos.csv"),
      metaCol = NULL,
      reader = "fread"
    )
    bw &lt;- read.pcv.3(
      file = paste0(base_url, "pcv3Phenos.csv"),
      metaCol = "meta", metaForm = "vis_view_angle_zoom_horizontal_gain_exposure_v_new_n_rep",
      joinSnapshot = "id",
      reader = "fread"
    )
    bw &lt;- read.pcv.3(
      file = paste0(base_url, "pcv3Phenos.csv"),
      snapshotFile = paste0(base_url, "pcv3Snapshot.csv"),
      designFile = paste0(base_url, "pcv3Design.csv"),
      metaCol = "meta", metaForm = "vis_view_angle_zoom_horizontal_gain_exposure_v_new_n_rep",
      joinSnapshot = "id", conversions = list(area = 13.2 * 3.7 / 46856),
      reader = "fread"
    )
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='relativeTolerance'>Calculate relative tolerance of some phenotype(s) relative to control</h2><span id='topic+relativeTolerance'></span>

<h3>Description</h3>

<p>Often in bellwether experiments we are curious about the effect of some
treatment vs control. For certain routes in analysing the data this requires considering
phenotypes as relative differences compared to a control. Note that the <code>conjugate</code>
function can also be useful in considering the relative tolerance to stress between groups and that
growth models are another suggested way to test relative tolerance questions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relativeTolerance(
  df,
  phenotypes = NULL,
  grouping = NULL,
  control = NULL,
  controlGroup = NULL,
  traitCol = "trait",
  valueCol = "value"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relativeTolerance_+3A_df">df</code></td>
<td>
<p>Dataframe to use, this can be in long or wide format.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_phenotypes">phenotypes</code></td>
<td>
<p>A character vector of column names for the phenotypes
that should be compared against control.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_grouping">grouping</code></td>
<td>
<p>A character vector of column names that identify groups in the data.
These groups will be calibrated separately,
with the exception of the group that identifies a control within the greater hierarchy.
Note that for levels of grouping where the control group does not exist the output will be NA.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_control">control</code></td>
<td>
<p>A column name for the variable to be used to select the control observations.
If left NULL (the default) then this will be taken as the first string in the group argument.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_controlgroup">controlGroup</code></td>
<td>
<p>The level of the control variable to compare groups against.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_traitcol">traitCol</code></td>
<td>
<p>Column with phenotype names, defaults to &quot;trait&quot;.
This should generally not need to be changed from the default.
If this and valueCol are present in colnames(df) then the data
is assumed to be in long format.</p>
</td></tr>
<tr><td><code id="relativeTolerance_+3A_valuecol">valueCol</code></td>
<td>
<p>Column with phenotype values, defaults to &quot;value&quot;.
This should generally not need to be changed from the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with relative tolerance columns added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- "https://raw.githubusercontent.com/joshqsumner/pcvrTestData/main/pcv4-single-value-traits.csv"
tryCatch(
  {
    sv &lt;- read.pcv(
      f,
      reader = "fread"
    )
    sv$genotype &lt;- substr(sv$barcode, 3, 5)
    sv$genotype &lt;- ifelse(sv$genotype == "002", "B73",
      ifelse(sv$genotype == "003", "W605S",
        ifelse(sv$genotype == "004", "MM", "Mo17")
      )
    )
    sv$fertilizer &lt;- substr(sv$barcode, 8, 8)
    sv$fertilizer &lt;- ifelse(sv$fertilizer == "A", "100",
      ifelse(sv$fertilizer == "B", "50", "0")
    )

    sv &lt;- bw.time(sv,
      plantingDelay = 0, phenotype = "area_pixels",
      cutoff = 10, timeCol = "timestamp", group = c("barcode", "rotation"), plot = FALSE
    )
    phenotypes &lt;- colnames(sv)[19:35]
    phenoForm &lt;- paste0("cbind(", paste0(phenotypes, collapse = ", "), ")")
    groupForm &lt;- "DAS+DAP+barcode+genotype+fertilizer"
    form &lt;- as.formula(paste0(phenoForm, "~", groupForm))
    sv &lt;- aggregate(form, data = sv, mean, na.rm = TRUE)
    sv &lt;- bw.outliers(sv,
      phenotype = "area_pixels",
      group = c("DAS", "genotype", "fertilizer"),
      plotgroup = c("barcode")
    )$data

    pixels_per_cmsq &lt;- 42.5^2 # pixel per cm^2
    sv$area_cm2 &lt;- sv$area_pixels / pixels_per_cmsq
    sv$height_cm &lt;- sv$height_pixels / 42.5

    df &lt;- sv
    phenotypes &lt;- c("area_cm2", "height_cm")
    grouping &lt;- c("fertilizer", "genotype", "DAS")
    controlGroup &lt;- "100"
    control &lt;- "fertilizer"

    rt &lt;- relativeTolerance(df, phenotypes, grouping, control, controlGroup)
    head(rt)
    sapply(rt, function(c) sum(is.na(c)))
  },
  error = function(e) {
    message(e)
  }
)


</code></pre>

<hr>
<h2 id='rqPlot'>Function to visualize <code>quantreg::rq</code> general additive growth models.</h2><span id='topic+rqPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means) can be visualized easily using this function.
This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqPlot(
  fit,
  form,
  df = NULL,
  groups = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit, or list of model fits, returned by <code>fitGrowth</code>
with type=&quot;nlrq&quot; and model=&quot;gam&quot;.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code>
part of the output) specifying the outcome,
predictor, and grouping structure of the data as <code>outcome ~ predictor|individual/group</code>.
If the individual and group are specified then the observed growth lines are plotted.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for rq models.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_timerange">timeRange</code></td>
<td>
<p>An optional range of times to use. This can be used to view predictions for
future data if the avaiable data has not reached some point (such as asymptotic size).</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE.
If TRUE then viridis colormaps are used in the order of virMaps</p>
</td></tr>
<tr><td><code id="rqPlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length.
Defaults to &quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an rq general additive model's quantiles
and optionally the individual growth lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "gam", form = y ~ time | id / group,
  tau = c(0.25, 0.5, 0.75), df = simdf, start = NULL, type = "nlrq"
)
fits &lt;- fitGrowth(ss)
rqPlot(fits, form = ss$pcvrForm, df = ss$df, groupFill = TRUE)
rqPlot(fits, form = ss$pcvrForm, df = ss$df, groups = "a", timeRange = 1:10)

ss &lt;- growthSS(
  model = "gam", form = y ~ time | group,
  tau = c(0.5), df = simdf, start = NULL, type = "nlrq"
)
fit &lt;- fitGrowth(ss)
rqPlot(fit, form = ss$pcvrForm, df = ss$df, groupFill = TRUE)

</code></pre>

<hr>
<h2 id='summary.pcvrss'>Summarize a <code>pcvrss</code> object.</h2><span id='topic+summary.pcvrss'></span>

<h3>Description</h3>

<p>Summarize a <code>pcvrss</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcvrss'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pcvrss_+3A_object">object</code></td>
<td>
<p>An object of class <code>pcvrss</code>
to method <code>summary</code> of <code>pcvrss</code>.</p>
</td></tr>
<tr><td><code id="summary.pcvrss_+3A_...">...</code></td>
<td>
<p>further arguments, passed to print.default.</p>
</td></tr>
</table>

<hr>
<h2 id='survregPlot'>Function to visualize <code>survival::survreg</code> models fit by <code>fitGrowth</code>.</h2><span id='topic+survregPlot'></span>

<h3>Description</h3>

<p>Models fit using <a href="#topic+growthSS">growthSS</a> inputs by <a href="#topic+fitGrowth">fitGrowth</a>
(and similar models made through other means) can be visualized easily using this function.
This will generally be called by <code>growthPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survregPlot(
  fit,
  form,
  groups = NULL,
  df = NULL,
  timeRange = NULL,
  facetGroups = TRUE,
  groupFill = FALSE,
  virMaps = c("plasma")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survregPlot_+3A_fit">fit</code></td>
<td>
<p>A model fit returned by <code>fitGrowth</code> with type=&quot;nls&quot;.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_form">form</code></td>
<td>
<p>A formula similar to that in <code>growthSS</code> inputs (or the <code>pcvrForm</code>
part of the output) specifying the outcome,
predictor, and grouping structure of the data as <code>outcome ~ predictor|individual/group</code>.
If the individual and group are specified then the observed growth lines are plotted.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_groups">groups</code></td>
<td>
<p>An optional set of groups to keep in the plot.
Defaults to NULL in which case all groups in the model are plotted.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_df">df</code></td>
<td>
<p>A dataframe to use in plotting observed growth curves on top of the model.
This must be supplied for nls models.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_timerange">timeRange</code></td>
<td>
<p>Ignored, included for compatibility with other plotting functions.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_facetgroups">facetGroups</code></td>
<td>
<p>logical, should groups be separated in facets? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_groupfill">groupFill</code></td>
<td>
<p>logical, should groups have different colors? Defaults to FALSE.
If TRUE then viridis colormaps are used in the order of virMaps</p>
</td></tr>
<tr><td><code id="survregPlot_+3A_virmaps">virMaps</code></td>
<td>
<p>order of viridis maps to use. Will be recycled to necessary length. Defaults to
&quot;plasma&quot;, but will generally be informed by growthPlot's default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot showing an survival model's survival function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

df &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- growthSS(
  model = "survival weibull", form = y &gt; 100 ~ time | id / group,
  df = df, type = "survreg"
)
fit &lt;- fitGrowth(ss)
survregPlot(fit, form = ss$pcvrForm, df = ss$df)
survregPlot(fit, form = ss$pcvrForm, df = ss$df, groups = "a")
survregPlot(fit,
  form = ss$pcvrForm, df = ss$df, facetGroups = FALSE,
  groupFill = TRUE, virMaps = c("plasma", "mako")
)

</code></pre>

<hr>
<h2 id='testGrowth'>Hypothesis testing for <a href="#topic+fitGrowth">fitGrowth</a> models.</h2><span id='topic+testGrowth'></span>

<h3>Description</h3>

<p>Hypothesis testing for <a href="#topic+fitGrowth">fitGrowth</a> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGrowth(ss = NULL, fit, test = "A")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testGrowth_+3A_ss">ss</code></td>
<td>
<p>A list output from <a href="#topic+growthSS">growthSS</a>. This is not required for nls, nlme, and brms models
if <code>test</code> is given in <code>brms::hypothesis</code> style as a written statement.</p>
</td></tr>
<tr><td><code id="testGrowth_+3A_fit">fit</code></td>
<td>
<p>A model (or list of nlrq models) output from <a href="#topic+fitGrowth">fitGrowth</a>. For brms models this
can also be a data.frame of draws.</p>
</td></tr>
<tr><td><code id="testGrowth_+3A_test">test</code></td>
<td>
<p>A description of the hypothesis to test. This can take two main forms,
either the parameter names to vary before comparing a nested model (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) using an anova
or a hypothesis test/list of hypothesis tests written as character strings.
The latter method is not implemented for <code>nlrq</code> models. If this is a vector of parameters
to test in the model then they should be parameters which vary by group in your original model
and that you want to test against a null model where they do not vary by group.
Alternatively for nlrq models this can be a comparison of model terms
written as <code>"group_X|tau|par - group_Y|tau|par"</code>, which uses a fat tailed T distribution to make
comparisons on the means of each quantile estimate. For GAMs these tests compare the model with
splines either by group or interacting with group to a model that ignores the grouping in the data.
If this is a list of hypothesis tests then they should describe tests similar to
&quot;A.group1 - A.group2*1.1&quot; and can be thought of as contrasts. For brms models the &quot;test&quot; argument
is passed to brms::hypothesis, which has extensive documentation and is very flexible.
Note that for survreg the <code>survival::survdiff</code> function is used so fewer hypothesis testing
options are available and flexsurv models are tested using contrasts via <code>flexsurv::standsurv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For nls and nlme models an anova is run and returned as part of a list along with the null model.
For nlrq models several assumptions are made and a likelihood ratio test for each tau
is run and returned as a list.
</p>


<h3>Value</h3>

<p>A list containing an anova object comparing non-linear growth models and the null model.
</p>


<h3>See Also</h3>

<p><a href="#topic+growthSS">growthSS</a> and <a href="#topic+fitGrowth">fitGrowth</a> for making compatible models, <a href="#topic+growthPlot">growthPlot</a>
for hypothesis testing on compatible models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
simdf &lt;- growthSim("logistic",
  n = 20, t = 25,
  params = list("A" = c(200, 160), "B" = c(13, 11), "C" = c(3, 3.5))
)
ss &lt;- suppressMessages(growthSS(
  model = "logistic", form = y ~ time | id / group,
  df = simdf, type = "nlrq"
))
fit &lt;- fitGrowth(ss)
testGrowth(ss, fit, "A")
testGrowth(ss, fit, "a|0.5|A &gt; b|0.5|A")

ss2 &lt;- suppressMessages(growthSS(
  model = "logistic", form = y ~ time | id / group,
  df = simdf, type = "nls"
))
fit2 &lt;- fitGrowth(ss2)
testGrowth(ss2, fit2, "A")$anova
coef(fit2) # check options for contrast testing
testGrowth(ss2, fit2, "A1 - A2*1.1")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
