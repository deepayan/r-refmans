<!DOCTYPE html><html><head><title>Help for package parseRPDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parseRPDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_ids_mi2b2'><p>Legacy function to create a vector of all possible IDs for mi2b2 workbench</p></a></li>
<li><a href='#convert_dia'><p>Searches diagnosis columns for given diseases.</p></a></li>
<li><a href='#convert_enc'><p>Searches columns for given diseases defined by ICD codes.</p></a></li>
<li><a href='#convert_lab'><p>Converts lab results to normal/abnormal based-on reference values.</p></a></li>
<li><a href='#convert_med'><p>Adds boolean columns corresponding to a group of medications whether it is present in the given row.</p></a></li>
<li><a href='#convert_notes'><p>Extracts information from notes free text.</p></a></li>
<li><a href='#convert_phy'><p>Searches health history data for given codes</p></a></li>
<li><a href='#convert_prc'><p>Searches procedures columns for given procedures.</p></a></li>
<li><a href='#convert_rfv'><p>Searches columns for given reason for visit defined by ERFV codes.</p></a></li>
<li><a href='#create_img_db'><p>Create a database of DICOM headers.</p></a></li>
<li><a href='#dcm_db'><p>Internal function to create a database of DICOM headers.</p></a></li>
<li><a href='#export_notes'><p>Exports free text notes to individual text files.</p></a></li>
<li><a href='#find_exam'><p>Find exam data within a given timeframe using parallel CPU computing.</p></a></li>
<li><a href='#find_exam_ram'><p>Find exam data within a given timeframe using parallel CPU computing without shared RAM management.</p></a></li>
<li><a href='#load_all'><p>Loads allergy data information into R.</p></a></li>
<li><a href='#load_all_data'><p>Loads all RPDR text outputs into R.</p></a></li>
<li><a href='#load_base'><p>Helper function for loading RPDR data into R.</p></a></li>
<li><a href='#load_bib'><p>Loads BiobankFile data into R.</p></a></li>
<li><a href='#load_con'><p>Loads contact information into R.</p></a></li>
<li><a href='#load_dem'><p>Loads demographic information into R for new demographic tables following changes in the beginning of 2022.</p></a></li>
<li><a href='#load_dem_old'><p>Loads demographic information into R for demographics tables before 2022.</p></a></li>
<li><a href='#load_dia'><p>Loads diagnoses into R.</p></a></li>
<li><a href='#load_enc'><p>Loads encounter information into R.</p></a></li>
<li><a href='#load_lab'><p>Loads laboratory results into R.</p></a></li>
<li><a href='#load_lno'><p>Loads LMR note documents into R.</p></a></li>
<li><a href='#load_mcm'><p>Loads match control data into R.</p></a></li>
<li><a href='#load_med'><p>Loads medication order detail into R.</p></a></li>
<li><a href='#load_mic'><p>Loads microbiology results into R.</p></a></li>
<li><a href='#load_mrn'><p>Loads MRN data into R.</p></a></li>
<li><a href='#load_notes'><p>Loads note documents into R.</p></a></li>
<li><a href='#load_phy'><p>Loads helath history information into R.</p></a></li>
<li><a href='#load_prc'><p>Loads procedures into R.</p></a></li>
<li><a href='#load_prv'><p>Loads providers information into R.</p></a></li>
<li><a href='#load_ptd'><p>Loads patient data information into R.</p></a></li>
<li><a href='#load_rdt'><p>Loads radiology procedures data into R.</p></a></li>
<li><a href='#load_rfv'><p>Loads reason for visit data into R.</p></a></li>
<li><a href='#load_trn'><p>Loads transfusion results into R.</p></a></li>
<li><a href='#parse_ids'><p>Parse IDs from a string of delimited list of values.</p></a></li>
<li><a href='#pretty_mrn'><p>Converts MRN integer to string compatible with RPDR.</p></a></li>
<li><a href='#pretty_numbers'><p>Converts numerical codes to universal format specified by length.</p></a></li>
<li><a href='#pretty_text'><p>Removes spaces, special characters and capitals from string vector.</p></a></li>
<li><a href='#remove_column'><p>Delete columns with all NA or all identical data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parse and Manipulate Research Patient Data Registry ('RPDR')
Text Queries</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-02</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marton Kolossvary &lt;mkolossvary@mgh.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to load Research Patient Data Registry ('RPDR') text queries from Partners Healthcare institutions into R.
             The package also provides helper functions to manipulate data and execute common procedures
             such as finding the closest radiological exams considering a given timepoint, or creating a DICOM header database
             from the downloaded images. All functionalities are parallelized for fast and efficient analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.1), stringr (&ge; 1.4.0), readr (&ge; 1.4.0),
parallelly (&ge; 1.36.0), foreach (&ge; 1.5.1), future (&ge; 1.33.1),
doFuture (&ge; 1.0.1), progressr (&ge; 0.14.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), reticulate (&ge; 1.20), knitr, rmarkdown,
covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/martonkolossvary/parseRPDR">https://github.com/martonkolossvary/parseRPDR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/martonkolossvary/parseRPDR/issues">https://github.com/martonkolossvary/parseRPDR/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>load_all_data, create_img_db, find_exam,
load_*, convert_*</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 09:13:09 UTC; mjk2</td>
</tr>
<tr>
<td>Author:</td>
<td>Marton Kolossvary [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 09:33:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_ids_mi2b2'>Legacy function to create a vector of all possible IDs for mi2b2 workbench</h2><span id='topic+all_ids_mi2b2'></span>

<h3>Description</h3>

<p>Legacy function to gather all possible MGH and BWH IDs from mrn.txt and con.txt input sources to provide a vector of all possible MGH or BWH IDs to be used as a data request for mi2b2 workbench.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_ids_mi2b2(type = "MGH", d_mrn, d_con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_ids_mi2b2_+3A_type">type</code></td>
<td>
<p>string, either <em>&quot;MGH&quot;</em> or <em>&quot;BWH&quot;</em> specifying which IDs to use.</p>
</td></tr>
<tr><td><code id="all_ids_mi2b2_+3A_d_mrn">d_mrn</code></td>
<td>
<p>data.table, parsed mrn dataset using the <em>load_mrn</em> function.</p>
</td></tr>
<tr><td><code id="all_ids_mi2b2_+3A_d_con">d_con</code></td>
<td>
<p>data.table, parsed con dataset using the <em>load_con</em> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, with all MGH or BWH IDs that occur in the con and mrn datasources for all patients. Previously this was required to for mi2b2 workbenches allowing access to
all possible images of the patients, even if the MGH or BWH changed over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
all_MGH_mrn &lt;- all_ids_mi2b2(type = "MGH", d_mrn = data_mrn, d_con = data_con)

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_dia'>Searches diagnosis columns for given diseases.</h2><span id='topic+convert_dia'></span>

<h3>Description</h3>

<p>Analyzes diagnosis data loaded using <em>load_dia</em>. Searches diagnosis columns for a specified set of diseases.
By default, the data.table is returned with new columns corresponding to boolean values, whether given group of diagnoses are present among the diagnoses.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given diagnosis is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_dia(
  d,
  code = "dia_code",
  code_type = "dia_code_type",
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_dia",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_dia_+3A_d">d</code></td>
<td>
<p>data.table, database containing diagnosis information data loaded using the <em>load_dia</em> function.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_code">code</code></td>
<td>
<p>string, column name of the diagnosis code column. Defaults to <em>dia_code</em>.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_code_type">code_type</code></td>
<td>
<p>string, column name of the code_type column. Defaults to <em>dia_code_type</em>.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of string arrays corresponding to sets of code types and codes separated by <em>:</em>, i.e.: &quot;ICD9:250.00&quot;.
The function searches for the given disease code type and code pair and adds new boolean columns with the name of each list element.
These columns are indicators whether any of the disease code type and code pair occurs in the set of codes.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess whether given disease codes are present within all the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_dia</em>. Used in case collapse is present to provide the earliest or latest instance of diagnosing the given disease.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple diagnoses are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_dia_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with indicator columns whether the any of the given diagnoses are reported.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Search for Hypertension and Stroke ICD codes
diseases &lt;- list(HT = c("ICD10:I10"), Stroke = c("ICD9:434.91", "ICD9:I63.50"))
data_dia_parse &lt;- convert_dia(d = data_dia, codes_to_find = diseases, nThread = 2)

#Search for Hypertension and Stroke ICD codes and summarize per patient providing earliest time
diseases &lt;- list(HT = c("ICD10:I10"), Stroke = c("ICD9:434.91", "ICD9:I63.50"))
data_dia_disease &lt;-  convert_dia(d = data_dia, codes_to_find = diseases, nThread = 2,
collapse = "ID_MERGE", aggr_type = "earliest")

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_enc'>Searches columns for given diseases defined by ICD codes.</h2><span id='topic+convert_enc'></span>

<h3>Description</h3>

<p>Analyzes encounter data loaded using <em>load_enc</em>. Converts columns with ICD codes and text to simple ICD codes.
If requested, the data.table is returned with new columns corresponding to boolean values, whether given group of diagnoses are present in the given columns.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given diagnosis is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_enc(
  d,
  code = c("enc_diag_admit", "enc_diag_princ", paste0("enc_diag_", 1:10)),
  keep = FALSE,
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_enc_admit",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_enc_+3A_d">d</code></td>
<td>
<p>data.table, database containing encounter information data loaded using the <em>load_enc</em> function.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_code">code</code></td>
<td>
<p>string vector, an array of column names to convert to simple ICD codes. The new column names will be the old one with <em>ICD_</em> added to the beginning of it.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_keep">keep</code></td>
<td>
<p>boolean, whether to keep original columns that were converted. Defaults to <em>FALSE</em>.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of arrays corresponding to sets of ICD codes. The function searches the columns in code and new boolean columns with the name of each list element will be created.
These columns are indicators whether the given disease is present in the set of ICD codes or not.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess whether given diagnoses are present within all the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_enc_admit</em>. Used in case collapse is present to provide the earliest or latest instance of diagnosing the given disease.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple diagnoses are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_enc_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with formatted ICD code columns and possibly indicator columns if provided.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Parse encounter ICD columns and keep original ones as well
data_enc_parse &lt;- convert_enc(d = data_enc, keep = TRUE, nThread = 2)

#Parse encounter ICD columns and discard original ones,
#and create indicator variable for the following diseases
diseases &lt;- list(HT = c("I10"), Stroke = c("434.91", "I63.50"))
data_enc_disease &lt;-  convert_enc(d = data_enc, keep = FALSE,
codes_to_find = diseases, nThread = 2)

#Parse encounter ICD columns and discard original ones
#and create indicator variables for the following diseases and summarize per patient,
#whether there are any encounters where the given diseases were registered
diseases &lt;- list(HT = c("I10"), Stroke = c("434.91", "I63.50"))
data_enc_disease &lt;-  convert_enc(d = data_enc, keep = FALSE,
codes_to_find = diseases, nThread = 2, collapse = "ID_MERGE")

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_lab'>Converts lab results to normal/abnormal based-on reference values.</h2><span id='topic+convert_lab'></span>

<h3>Description</h3>

<p>Analyzes laboratory data loaded using <em>load_lab</em>. Converts laboratory results to values without &quot;&gt;&quot; or &quot;&lt;&quot; by creating a column where these characters are removed.
Furthermore, adds two indicator columns where based-on the reference ranges or the Abnormal_Flag column in RPDR (lab_result_abn using load_lab), the value is considered normal or abnormal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_lab(
  d,
  code_results = "lab_result",
  code_reference = "lab_result_range",
  code_flag = "lab_result_abn"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_lab_+3A_d">d</code></td>
<td>
<p>data.table, database containing laboratory results data loaded using the <em>load_lab</em> function.</p>
</td></tr>
<tr><td><code id="convert_lab_+3A_code_results">code_results</code></td>
<td>
<p>string vector, column name containing the results. Defaults to: <em>&quot;lab_result&quot;</em>.</p>
</td></tr>
<tr><td><code id="convert_lab_+3A_code_reference">code_reference</code></td>
<td>
<p>string vector, column name containing the reference ranges. Defaults to: <em>&quot;lab_result_range&quot;</em>.</p>
</td></tr>
<tr><td><code id="convert_lab_+3A_code_flag">code_flag</code></td>
<td>
<p>string vector, column name containing the abnormal flags. Defaults to: <em>&quot;lab_result_abn&quot;</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with three additional columns: <em>&quot;lab_result_pretty&quot;</em> containing numerical results. In case of &quot;&gt;&quot; or &quot;&lt;&quot; notation,
the numeric value is returned, as we only have information that it is at least as much or not larger than a given value.
The other column: <em>&quot;lab_result_abn_pretty&quot;</em> can take values: NORMAL/ABNORMAL, depending on whether the value is within the reference range.
Please be aware that there can be very different representations of values, and in some cases this will result in misclassification of values.
The third column: <em>&quot;lab_result_abn_flag_pretty&quot;</em> gives abnormal if the original Abnormal_Flag column contains any information.
Borderline values are considered NORMAL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Convert loaded lab results
data_lab_pretty &lt;- convert_lab(d = data_lab)
data_lab_pretty[, c("lab_result", "lab_result_pretty", "lab_result_range",
"lab_result_abn_pretty", "lab_result_abn_flag_pretty")]

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_med'>Adds boolean columns corresponding to a group of medications whether it is present in the given row.</h2><span id='topic+convert_med'></span>

<h3>Description</h3>

<p>Analyzes medication data loaded using <em>load_med</em>.
By default, the data.table is returned with new columns corresponding to boolean values, whether given group of medications are present.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given medication is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_med(
  d,
  code = "med",
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_med",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_med_+3A_d">d</code></td>
<td>
<p>data.table, database containing medication data loaded using the <em>load_med</em> function.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_code">code</code></td>
<td>
<p>string, column name of the medication column. Defaults to <em>med</em>.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of arrays corresponding to sets of medication names. New boolean columns with the name of each list element will be created.
These columns are indicators whether the given medication is present in the set of medication names or not.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess whether given medications are present within all the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_med</em>. Used in case collapse is present to provide the earliest or latest instance of diagnosing the given disease.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple occurences of the medications are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_med_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with indicator columns whether given group of codes_to_find is present or not.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Define medication group and add an indicator column whether
#the given medication group was administered
meds &lt;- list(statin = c("Simvastatin", "Atorvastatin"),
             NSAID  = c("Acetaminophen", "Paracetamol"))

data_med_indic &lt;- convert_med(d = data_med, codes_to_find = meds, nThread = 1)

#Summarize per patient if they ever had the given medication groups registered
data_med_indic_any &lt;- convert_med(d = data_med,
codes_to_find = meds, collapse = "ID_MERGE", nThread = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_notes'>Extracts information from notes free text.</h2><span id='topic+convert_notes'></span>

<h3>Description</h3>

<p>Analyzes notes loaded using <em>load_notes</em> or <em>load_lno</em>. Extracts information from the free text present in <em>abc_rep_txt</em>,
where <em>abc</em> stands for the three letter abbreviation of the given type of note.
An array of string is provided using the <em>anchors</em> argument. The function will return as many columns as there are anchor points.
Each column will contain the text between the given anchor point and the next following anchor point.
This way the free text report is split into corresponding smaller texts. By default, these are the common standard elements of given note types.
Here are provided potential anchor points for the given types of notes:
</p>

<dl>
<dt>Cardiology: </dt><dd><p>c(&quot;Report Number:&quot;, &quot;Report Status:&quot;, &quot;Type:&quot;, &quot;Date:&quot;, &quot;Ordering Provider:&quot;, &quot;SYSTOLIC BLOOD PRESSURE&quot;,  &quot;DIASTOLIC BLOOD PRESSURE&quot;, &quot;VENTRICULAR RATE EKG/MIN&quot;, &quot;ATRIAL RATE&quot;, &quot;PR INTERVAL&quot;, &quot;QRS DURATION&quot;, &quot;QT INTERVAL&quot;, &quot;QTC INTERVAL&quot;,  &quot;P AXIS&quot;, &quot;R AXIS&quot;, &quot;T WAVE AXIS&quot;, &quot;LOC&quot;, &quot;DX:&quot;, &quot;REF:&quot;, &quot;Electronically Signed&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Discharge: </dt><dd><p>c(&quot;***This text report&quot;, &quot;Patient Information&quot;, &quot;Physician Discharge Summary&quot;, &quot;Surgeries this Admission&quot;, &quot;Items for Post-Hospitalization Follow-Up:&quot;, &quot;Pending Results&quot;, &quot;Hospital Course&quot;, &quot;ED Course:&quot;, &quot;Diagnosis&quot;, &quot;Prescriptions prior to admission&quot;, &quot;Family History:&quot;, &quot;Physical Exam on Admission:&quot;, &quot;Discharge Exam&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Endoscopy: </dt><dd><p>c(&quot;NAME:&quot;, &quot;DATE:&quot;, &quot;Patient Information&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>History &amp; Physical: </dt><dd><p>c(&quot;***This text report&quot;, &quot;Patient Information&quot;, &quot;H&amp;P by&quot;, &quot;Author:&quot;, &quot;Service:&quot;, &quot;Author Type:&quot;, &quot;Filed:&quot;, &quot;Note Time:&quot;, &quot;Status:&quot;, &quot;Editor:&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Operative: </dt><dd><p>c(&quot;NAME:&quot;, &quot;UNIT NO:, &quot;DATE:&quot;, &quot;SURGEON:&quot;, &quot;ASST:&quot;, &quot;PREOPERATIVE DIAGNOSIS:&quot;, &quot;POSTOPERATIVE DIAGNOSIS:&quot;, &quot;NAME OF OPERATION:&quot;, &quot;ANESTHESIA:&quot;, &quot;INDICATIONS&quot;, &quot;OPERATIVE FINDINGS:&quot;, &quot;DESCRIPTION OF PROCEDURE:&quot;, &quot;Electronically Signed&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Pathology: </dt><dd><p>c(&quot;Accession Number:&quot;, &quot;Report Status:&quot;, &quot;Type:&quot;, &quot;Report:&quot;, &quot;CASE:&quot;, &quot;PATIENT:&quot;, &quot;Date&quot;, &quot;Source Care Unit:&quot;, &quot;Path Subspecialty Service:&quot;, &quot;Results To:&quot;, &quot;Signed Out by:&quot;, &quot;CLINICAL DATA:&quot;, &quot;FINAL DIAGNOSIS:&quot;, &quot;GROSS DESCRIPTION:&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Progress: </dt><dd><p>c(&quot;***This text report&quot;, &quot;Patient Information&quot;, &quot;History&quot;, &quot;Overview&quot;, &quot;Progress Notes&quot;, &quot;Medications&quot;, &quot;Relevant Orders&quot;, &quot;Level of Service&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Pulmonary: </dt><dd><p>c(&quot;The Pulmonary document&quot;, &quot;Name:&quot;, &quot;Unit #:&quot;, &quot;Date:&quot;, &quot;Location:&quot;, &quot;Smoking Status:&quot;, &quot;Pack Years:&quot;, &quot;SPIROMETRY:&quot;, &quot;LUNG VOLUMES:&quot;, &quot;DIFFUSION:&quot;, &quot;PLETHYSMOGRAPHY:&quot; &quot;Pulmonary Function Test Interpretation&quot;, &quot;Spirometry&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Radiology: </dt><dd><p>c(&quot;Exam Code&quot;, &quot;Ordering Provider&quot;, &quot;HISTORY&quot;, &quot;Associated Reports&quot;, &quot;Report Below&quot;, &quot;REASON&quot;, &quot;REPORT&quot;,  &quot;TECHNIQUE&quot;, &quot;COMPARISON&quot;, &quot;FINDINGS&quot;, &quot;IMPRESSION&quot;, &quot;RECOMMENDATION&quot;, &quot;SIGNATURES&quot;, &quot;report_end&quot;)</p>
</dd>
<dt>Visit: </dt><dd><p>c(&quot;***This text report&quot;, &quot;Reason for Visit&quot;, &quot;Reason for Visit&quot;, &quot;Vital Signs&quot;, &quot;Chief Complaint&quot;, &quot;History&quot;, &quot;Overview&quot;, &quot;Medications&quot;, &quot;Relevant Orders&quot;, &quot;Level of Service&quot;, &quot;report_end&quot;</p>
</dd>
<dt>LMR: </dt><dd><p>c(&quot;Subject&quot;, &quot;Patient Name:&quot;, &quot;Reason for visit&quot;, &quot;report_end&quot;</p>
</dd>
</dl>

<p>However, these may be modified and extended to include sections of interest, i.e. if a given score is reported in a standard fashion, then adding this phrase (i.e. &quot;CAD-RADS&quot;)
would create a column where the text following this statement is returned. After this the resulting columns can be easily cleaned up if needed.
Be aware to always include <em>&quot;report_end&quot;</em> in the anchors array, to provide the function of the last occurring statement in the report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_notes(
  d,
  code = NULL,
  anchors = NULL,
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_notes_+3A_d">d</code></td>
<td>
<p>data.table, database containing notes loaded using the <em>load_notes</em> function.</p>
</td></tr>
<tr><td><code id="convert_notes_+3A_code">code</code></td>
<td>
<p>string vector, column name containing the results, which should be <em>&quot;abc_rep_txt&quot;</em>, where <em>abc</em> stands for the three letter abbreviation of the given type of note.</p>
</td></tr>
<tr><td><code id="convert_notes_+3A_anchors">anchors</code></td>
<td>
<p>string array, elements to search for in the text report.</p>
</td></tr>
<tr><td><code id="convert_notes_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with new columns corresponding to elements in <em>anchors</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create columns with specific parts of the radiological report defined by anchors
data_rad_parsed &lt;- convert_notes(d = data_rad, code = "rad_rep_txt",
anchors = c("Exam Code", "Ordering Provider", "HISTORY", "Associated Reports",
"Report Below", "REASON", "REPORT", "TECHNIQUE", "COMPARISON", "FINDINGS",
"IMPRESSION", "RECOMMENDATION", "SIGNATURES", "report_end"), nThread = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_phy'>Searches health history data for given codes</h2><span id='topic+convert_phy'></span>

<h3>Description</h3>

<p>Analyzes health history data loaded using <em>load_phy</em>. Searches health history columns for a specified set of codes.
By default, the data.table is returned with new columns corresponding to boolean values, whether given group of health history data are present within the respective columns.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given diagnosis is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_phy(
  d,
  code = "phy_code",
  code_type = "phy_code_type",
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_phy",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_phy_+3A_d">d</code></td>
<td>
<p>data.table, database containing health history information data loaded using the <em>load_phy</em> function.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_code">code</code></td>
<td>
<p>string, column name of the diagnosis code column. Defaults to <em>phy_code</em>.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_code_type">code_type</code></td>
<td>
<p>string, column name of the code_type column. Defaults to <em>phy_code_type</em>.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of string arrays corresponding to sets of code types and codes separated by <em>:</em>, i.e.: &quot;LMR:3688&quot;.
The function searches for the given health history code type and code pair and adds new boolean columns with the name of each list element.
These columns are indicators whether any of the health history code type and code pair occurs in the set of codes.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess whether multiple health history codes are present within all the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_phy</em>. Used in case collapse is present to provide the earliest or latest instance of health history information.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple health histories are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_phy_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with indicator columns whether the any of the given health histories are reported.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Search for Height and Weight codes
anthropometrics &lt;- list(Weight = c("LMR:3688", "EPIC:WGT"), Height = c("LMR:3771", "EPIC:HGT"))
data_phy_parse &lt;- convert_phy(d = data_phy, codes_to_find = anthropometrics, nThread = 2)

#Search for for Height and Weight codes and summarize per patient providing earliest time
anthropometrics &lt;- list(Weight = c("LMR:3688", "EPIC:WGT"), Height = c("LMR:3771", "EPIC:HGT"))
data_phy_parse &lt;- convert_phy(d = data_phy, codes_to_find = anthropometrics, nThread = 2,
collapse = "ID_MERGE", aggr_type = "earliest")

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_prc'>Searches procedures columns for given procedures.</h2><span id='topic+convert_prc'></span>

<h3>Description</h3>

<p>Analyzes procedure data loaded using <em>load_prc</em>. Searches procedures columns for a specified set of procedures.
By default, the data.table is returned with new columns corresponding to boolean values, whether given group of procedures are present in the given procedure.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given procedure is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_prc(
  d,
  code = "prc_code",
  code_type = "prc_code_type",
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_prc",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_prc_+3A_d">d</code></td>
<td>
<p>data.table, database containing procedure information data loaded using the <em>load_prc</em> function.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_code">code</code></td>
<td>
<p>string, column name of the procedure code column. Defaults to <em>prc_code</em>.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_code_type">code_type</code></td>
<td>
<p>string, column name of the code_type column. Defaults to <em>prc_code_type</em>.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of string arrays corresponding to sets of code types and codes separated by <em>:</em>, i.e.: &quot;CPT:00104&quot;.
The function searches for the given procedure code type and code pair and adds new boolean columns with the name of each list element.
These columns are indicators whether any of the procedure code type and code pair occurs in the set of codes.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess multiple procedure codes are present within all the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_prc</em>. Used in case collapse is present to provide the earliest or latest instance of the given procedure.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple procedures are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_prc_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with indicator columns whether the any of the given procedures are reported.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Search for Anesthesia CPT codes
procedures &lt;- list(Anesthesia = c("CTP:00410", "CPT:00104"))
data_prc_parse &lt;- convert_prc(d = data_prc, codes_to_find = procedures, nThread = 2)

#Search for Anesthesia CPT codes
procedures &lt;- list(Anesthesia = c("CTP:00410", "CPT:00104"))
data_prc_procedures &lt;- convert_prc(d = data_prc, codes_to_find = procedures,
nThread = 2, collapse = "ID_MERGE", aggr_type = "earliest")

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_rfv'>Searches columns for given reason for visit defined by ERFV codes.</h2><span id='topic+convert_rfv'></span>

<h3>Description</h3>

<p>Analyzes reason for visit data loaded using <em>load_rfv</em>.
If requested, the data.table is returned with new columns corresponding to boolean values, whether given group of ERFV are present in the given columns.
If <em>collapse</em> is given, then the information is aggregated based-on the <em>collapse</em> column and the earliest of latest time of the given reason for visit is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rfv(
  d,
  code = "rfv_concept_id",
  codes_to_find = NULL,
  collapse = NULL,
  code_time = "time_rfv_start",
  aggr_type = "earliest",
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_rfv_+3A_d">d</code></td>
<td>
<p>data.table, database containing reason for visit information data loaded using the <em>load_rfv</em> function.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_code">code</code></td>
<td>
<p>string vector, an array of column names to search.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_codes_to_find">codes_to_find</code></td>
<td>
<p>list, a list of arrays corresponding to sets of ERFV codes. The function searches the columns in code and the name of each list element will be created.
These columns are indicators whether the given disease is present in the set of ERFV codes or not.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_collapse">collapse</code></td>
<td>
<p>string, a column name on which to collapse the data.table.
Used in case we wish to assess whether multiple ERFV are present within  the same instances of <em>collapse</em>. See vignette for details.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_code_time">code_time</code></td>
<td>
<p>string, column name of the time column. Defaults to <em>time_rfv_start</em>. Used in case collapse is present to provide the earliest or latest instance of reason for visit.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_aggr_type">aggr_type</code></td>
<td>
<p>string, if multiple reason for visits are present within the same case of <em>collapse</em>, which timepoint to return. Supported are: &quot;earliest&quot; or &quot;latest&quot;. Defaults to <em>earliest</em>.</p>
</td></tr>
<tr><td><code id="convert_rfv_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with indicator columns if provided.
If <em>collapse</em> is present, then only unique ID and the summary columns are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Parse reason for visit columns
#and create indicator variables for the following reasons and summarize per patient,
#whether there are any encounters where the given reasons were registered
reasons &lt;- list(Pain = c("ERFV:160357", "ERFV:140012"), Visit = c("ERFV:501"))
data_rfv_disease &lt;-  convert_rfv(d = data_rfv, keep = FALSE,
codes_to_find = reasons, nThread = 2, collapse = "ID_MERGE")

## End(Not run)
</code></pre>

<hr>
<h2 id='create_img_db'>Create a database of DICOM headers.</h2><span id='topic+create_img_db'></span>

<h3>Description</h3>

<p>The function creates a database of DICOM headers present in a folder structure. Each series should be in its own folder,
but they can be in a nested folder structure. Files where there are also folder present next to them at the same level will not be parsed.
That is the folder structure needs to comply with the DICOM standard.
Be aware that the function requires <a href="https://www.python.org">python</a> and <a href="https://pydicom.github.io">pydicom</a> to be installed!
The function cycles through all folders present in the provided path and recursively goes through them,
every subfolder, and extracts the DICOM header information from the files using the
<a href="https://pydicom.github.io/pydicom/dev/reference/generated/pydicom.filereader.dcmread.html">dcmread</a>
function of the <a href="https://pydicom.github.io">pydicom</a> package.
The extension of the files can be provided by the <em>ext</em> argument,
as DICOM files may have different extensions then that of .dcm. Also, using the <em>all</em> boolean argument, you can specify whether
the function provides output for each file, or only for the first file, which is beneficial if you are analyzing multi-slice series,
as all instances have almost all the same header information. Furthermore, using the <em>keywords</em> argument you can manually specify
which DICOM keywords you wish to extract. These need to be a valid keyword specified in the
<a href="https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_6.html">DICOM standard</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_img_db(
  path,
  ext = c(".dcm", ".dicom", ".ima", ".tmp", ""),
  all = TRUE,
  keywords = c("StudyDate", "StudyTime", "SeriesDate", "SeriesTime", "AcquisitionDate",
    "AcquisitionTime", "ConversionType", "Manufacturer", "InstitutionName",
    "InstitutionalDepartmentName", "ReferringPhysicianName", "Modality",
    "ManufacturerModelName", "StudyDescription", "SeriesDescription", "StudyComments",
    "ProtocolName", "RequestedProcedureID", "ViewPosition", "StudyInstanceUID",
    "SeriesInstanceUID", "SOPInstanceUID", "AccessionNumber", "PatientName", "PatientID",
    "IssuerOfPatientID", "PatientBirthDate", 
     "PatientSex", "PatientAge",
    "PatientSize", "PatientWeight", "StudyID", "SeriesNumber", "AcquisitionNumber",
    "InstanceNumber", "BodyPartExamined", "SliceThickness", "SpacingBetweenSlices",
    "PixelSpacing", "PixelAspectRatio", "Rows", "Columns", "FieldOfViewDimensions",
    "RescaleIntercept", "RescaleSlope", "WindowCenter", "WindowWidth", "BitsAllocated",
    "BitsStored", "PhotometricInterpretation", "KVP", "ExposureTime", "XRayTubeCurrent",
    "ExposureInuAs", "ImageAndFluoroscopyAreaDoseProduct", "FilterType", 
    
    "ConvolutionKernel", "CTDIvol", "ReconstructionFieldOfView"),
  nThread = parallel::detectCores() - 1,
  na = TRUE,
  identical = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_img_db_+3A_path">path</code></td>
<td>
<p>string vector, full folder path to folder that contains the images.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_ext">ext</code></td>
<td>
<p>string array, possible file extensions to parse. It is advised to add <em>.</em> before the extensions as the given character patterns
may be present elsewhere in the file names. Furthermore, if DICOM files without an extension should also be parsed, then add <em>&quot;&quot;</em> to the
extensions as then the script will try to read all files without an extension. Also, the file names and the extensions are converted to lower case
before matching to avoid mismatches due to capitals.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_all">all</code></td>
<td>
<p>boolean, whether all files in a series should be parsed, or only the first one.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_keywords">keywords</code></td>
<td>
<p>string array, of valid DICOM keywords.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parsing data.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="create_img_db_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with DICOM header information return unchanged. However, the function also provides additional new columns
which help further data manipulations, these are:
</p>

<dl>
<dt>time_study</dt><dd><p>POSIXct, StudyDate and StudyTime concatentated together to POSIXct.</p>
</dd>
<dt>time_series</dt><dd><p>POSIXct, SeriesDate and SeriesTime concatentated together to POSIXct.</p>
</dd>
<dt>time_acquisition</dt><dd><p>POSIXct, AcquisitionDate and AcquisitionTime concatentated together to POSIXct.</p>
</dd>
<dt>name_img</dt><dd><p>string, PatientName with special characters removed.</p>
</dd>
<dt>time_date_of_birth_img</dt><dd><p>POSIXct, PatientBirthDate as POSIXct.</p>
</dd>
<dt>img_pixel_spacing</dt><dd><p>numeric, PixelSpacing value of the first element in the array returned as numerical value.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create a database with DICOM header information
all_dicom_headers &lt;- create_img_db(path = "/Users/Test/Data/DICOM/")
all_dicom_headers &lt;- create_img_db(path = "/Users/Test/Data/DICOM/", ext = c(".dcm", ".DICOM"))
#Create a database with DICOM header information for only IDs and accession numbers
all_dicom_headers &lt;- create_img_db(path = "/Users/Test/Data/DICOM/",
keywords = c("PatientID", "AccessionNumber"))

## End(Not run)
</code></pre>

<hr>
<h2 id='dcm_db'>Internal function to create a database of DICOM headers.</h2><span id='topic+dcm_db'></span>

<h3>Description</h3>

<p>The function creates a database of DICOM headers present in a folder structure. Each series should be in its own folder,
but they can be in a nested folder structure. Files where there are also folder present next to them at the same level will not be parsed.
That is the folder structure needs to comply with the DICOM standard.
Be aware that the function requires <a href="https://www.python.org">python</a> and <a href="https://pydicom.github.io">pydicom</a> to be installed!
The function cycles through all folders present in the provided path and recursively goes through them,
every subfolder, and extracts the DICOM header information from the files using the
<a href="https://pydicom.github.io/pydicom/dev/reference/generated/pydicom.filereader.dcmread.html">dcmread</a>
function of the <a href="https://pydicom.github.io">pydicom</a> package.
The extension of the files can be provided by the <em>ext</em> argument,
as DICOM files may have different extensions then that of .dcm. Also, using the <em>all</em> boolean argument, you can specify whether
the function provides output for each file, or only for the first file, which is beneficial if you are analyzing multi-slice series,
as all instances have almost all the same header information. Furthermore, using the <em>keywords</em> argument you can manually specify
which DICOM keywords you wish to extract. These need to be a valid keyword specified in the
<a href="https://dicom.nema.org/medical/dicom/current/output/chtml/part06/chapter_6.html">DICOM standard</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcm_db(path, ext, all, keywords, nThread, pydicom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcm_db_+3A_path">path</code></td>
<td>
<p>string vector, full folder path to folder that contains the images.</p>
</td></tr>
<tr><td><code id="dcm_db_+3A_ext">ext</code></td>
<td>
<p>string array, possible file extensions to parse. It is advised to add <em>.</em> before the extensions as the given character patterns
may be present elsewhere in the file names. Furthermore, if DICOM files without an extension should also be parsed, then add <em>&quot;&quot;</em> to the
extensions as then the script will try to read all files without an extension. Also, the file names and the extensions are converted to lower case
before matching to avoid mismatches due to capitals.</p>
</td></tr>
<tr><td><code id="dcm_db_+3A_all">all</code></td>
<td>
<p>boolean, whether all files in a series should be parsed, or only the first one.</p>
</td></tr>
<tr><td><code id="dcm_db_+3A_keywords">keywords</code></td>
<td>
<p>string array, of valid DICOM keywords.</p>
</td></tr>
<tr><td><code id="dcm_db_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parsing data.</p>
</td></tr>
<tr><td><code id="dcm_db_+3A_pydicom">pydicom</code></td>
<td>
<p>package, pydicom package initiated from parent environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table, with  DICOM header information. This is then used by <em>create_img_db</em> which formats the output.
</p>

<hr>
<h2 id='export_notes'>Exports free text notes to individual text files.</h2><span id='topic+export_notes'></span>

<h3>Description</h3>

<p>Exports out the contents of a given cell per row into individual text files. Can be used to export out
reports into individual text files for further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_notes(d, folder, code, name1 = "ID_MERGE", name2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_notes_+3A_d">d</code></td>
<td>
<p>data.table, database containing notes loaded using the <em>load_notes</em> function. Theoretically any other data.table can be given
and the contents of the specified cell will be exported into the corresponding files. In case of notes, it is advised to load them
with <em>format_orig = TRUE</em>, as then the output will retain the original format of the report making it easier to read.</p>
</td></tr>
<tr><td><code id="export_notes_+3A_folder">folder</code></td>
<td>
<p>string, full folder path to folder where the files should be exported. If folder does not exist, the function stops.</p>
</td></tr>
<tr><td><code id="export_notes_+3A_code">code</code></td>
<td>
<p>string vector, column name containing the data that should be exported. Generally should be <em>&quot;abc_rep_txt&quot;</em>, where <em>abc</em> stands for the three letter abbreviation of the given type of note.</p>
</td></tr>
<tr><td><code id="export_notes_+3A_name1">name1</code></td>
<td>
<p>string, the first part of the file names. Defaults to <em>ID_MERGE</em>.</p>
</td></tr>
<tr><td><code id="export_notes_+3A_name2">name2</code></td>
<td>
<p>string, the second part of the file names. name1 and name2 will be separated using &quot;_&quot;.
Generally should be <em>&quot;abc_rep_num&quot;</em>, where <em>abc</em> stands for the three letter abbreviation of the given type of note.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, files are exported to given folder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Output all cardiology notes to given folder
d &lt;- load_notes("Car.txt", type = "car", nThread = 2, format_orig = TRUE)
export_notes(d, folder = "/Users/Test/Notes/", code = "car_rep_txt",
name1 = "ID_MERGE", name2 = "car_rep_num")

## End(Not run)
</code></pre>

<hr>
<h2 id='find_exam'>Find exam data within a given timeframe using parallel CPU computing.</h2><span id='topic+find_exam'></span>

<h3>Description</h3>

<p>Finds all, earliest or closest examination to a given timepoints using parallel computing. A progress bar is also reported in the terminal to show the progress of the computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_exam(
  d_from,
  d_to,
  d_from_ID = "ID_MERGE",
  d_to_ID = "ID_MERGE",
  d_from_time = "time_rad_exam",
  d_to_time = "time_enc_admit",
  time_diff_name = "timediff_exam_to_db",
  before = TRUE,
  after = TRUE,
  time = 1,
  time_unit = "days",
  multiple = "closest",
  add_column = NULL,
  keep_data = FALSE,
  nThread = parallel::detectCores() - 1,
  shared_RAM = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_exam_+3A_d_from">d_from</code></td>
<td>
<p>data table, the database which is searched to find examinations within the timeframe.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_d_to">d_to</code></td>
<td>
<p>data table, the database to which we wish to find examinations within the timeframe.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_d_from_id">d_from_ID</code></td>
<td>
<p>string, column name of the patient ID column in d_from. Defaults to <em>ID_MERGE</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_d_to_id">d_to_ID</code></td>
<td>
<p>string, column name of the patient ID column in d_to. Defaults to <em>ID_MERGE</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_d_from_time">d_from_time</code></td>
<td>
<p>string, column name of the time variable column in d_from. Defaults to <em>time_rad_exam</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_d_to_time">d_to_time</code></td>
<td>
<p>string, column name of the time variable column in d_to. Defaults to <em>time_enc_admit</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_time_diff_name">time_diff_name</code></td>
<td>
<p>string, column name of the new column created which holds the time difference between the exam and the time provided by d_to. Defaults to <em>timediff_exam_to_db</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_before">before</code></td>
<td>
<p>boolean, should times before the given time be considered. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_after">after</code></td>
<td>
<p>boolean, should times after the given time be considered. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_time">time</code></td>
<td>
<p>integer, the timeframe considered between the exam and the d_to timepoints. Defaults to <em>1</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_time_unit">time_unit</code></td>
<td>
<p>string, the unit of time used. Time variables are in d_to and d_from are truncated to the supplied time unit.
For example: &quot;2005-09-18 08:15:01 PDT&quot; would be truncated to &quot;2005-09-18 PDT&quot; if <em>time_unit</em> is set to days.
Then the time differences is calculated using <em>difftime</em> passing the argument to <em>units</em>.
The following time units are supported: &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;months&quot;  and &quot;years&quot; are supported. Defautls to <em>days</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_multiple">multiple</code></td>
<td>
<p>string, which exams to give back. <em>closest</em> gives back the exam closest to the time provided by d_to.
<em>all</em> gives back all occurrences within the timeframe. <em>earliest</em> the earliest exam within the timeframe.
In case of ties for <em>closest</em> or <em>earliest</em>, all are returned. Defaults to <em>closest</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_add_column">add_column</code></td>
<td>
<p>string, a column name in d_to to add to the output. Defaults to <em>NULL</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_keep_data">keep_data</code></td>
<td>
<p>boolean, whether to include empty rows with only the <em>d_from_ID</em> column filed out for cases that have data in the <em>d_from</em>, but not within the time range. Defaults to <em>FALSE</em>.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
<tr><td><code id="find_exam_+3A_shared_ram">shared_RAM</code></td>
<td>
<p>boolean, depreciated from version 1.1.0 onwards, only kept for compatibility, as Bigmemory package has issues on running on different operating systems.
Now all computations are run using the memory usage specifications of the paralellization strategy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with <em>d_from</em> filtered to ones only within the timeframe. The columns of <em>d_from</em> are returned with the corresponding time column in <em>data_to</em>
where the rows are instances which comply with the time constraints specified by the function. An additional column specified in <em>time_diff_name</em> is also returned,
which shows the time difference between the time column in <em>d_from</em> and <em>d_to</em> for that given case.
Also the time column from <em>d_to</em> specified by <em>d_to_time</em> is returned under the name of <em>time_to_db</em>.
An additional column specified in <em>add_column</em> may be added from <em>data_to</em> to the data table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Filter encounters for first emergency visits at one of MGH's ED departments
data_enc_ED &lt;- data_enc[enc_clinic == "MGH EMERGENCY 10020010608"]
data_enc_ED &lt;- data_enc_ED[!duplicated(data_enc_ED$ID_MERGE)]

#Find all radiological examinations within 3 day of the ED registration
rdt_ED &lt;- find_exam(d_from = data_rdt, d_to = data_enc_ED,
d_from_ID = "ID_MERGE", d_to_ID = "ID_MERGE",
d_from_time = "time_rdt_exam", d_to_time = "time_enc_admit", time_diff_name = "time_diff_ED_rdt",
before = TRUE, after = TRUE, time = 3, time_unit = "days", multiple = "all",
nThread = 2)

#Find earliest radiological examinations within 3 day of the ED registration
rdt_ED &lt;- find_exam(d_from = data_rdt, d_to = data_enc_ED,
d_from_ID = "ID_MERGE", d_to_ID = "ID_MERGE",
d_from_time = "time_rdt_exam", d_to_time = "time_enc_admit", time_diff_name = "time_diff_ED_rdt",
before = TRUE, after = TRUE, time = 3, time_unit = "days", multiple = "earliest",
nThread = 2)

#Find closest radiological examinations on or after 1 day of the ED registration
#and add primary diagnosis column from encounters
rdt_ED &lt;- find_exam(d_from = data_rdt, d_to = data_enc_ED,
d_from_ID = "ID_MERGE", d_to_ID = "ID_MERGE",
d_from_time = "time_rdt_exam", d_to_time = "time_enc_admit", time_diff_name = "time_diff_ED_rdt",
before = FALSE, after = TRUE, time = 1, time_unit = "days", multiple = "earliest",
add_column = "enc_diag_princ", nThread = 2)

#Find closest radiological examinations on or after 1 day of the ED registration
#but also provide empty rows for patients with exam data but not within the timeframe
rdt_ED &lt;- find_exam(d_from = data_rdt, d_to = data_enc_ED,
d_from_ID = "ID_MERGE", d_to_ID = "ID_MERGE",
d_from_time = "time_rdt_exam", d_to_time = "time_enc_admit", time_diff_name = "time_diff_ED_rdt",
before = FALSE, after = TRUE, time = 1, time_unit = "days", multiple = "earliest",
add_column = "enc_diag_princ", keep_data = TRUE nThread = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='find_exam_ram'>Find exam data within a given timeframe using parallel CPU computing without shared RAM management.</h2><span id='topic+find_exam_ram'></span>

<h3>Description</h3>

<p>Finds all, earliest or closest examination to a given timepoints using parallel computing. A progress bar is also reported in the terminal to show the progress of the computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_exam_ram(
  d_from,
  d_to,
  d_from_ID = "ID_MERGE",
  d_to_ID = "ID_MERGE",
  d_from_time = "time_rad_exam",
  d_to_time = "time_enc_admit",
  time_diff_name = "timediff_exam_to_db",
  before = TRUE,
  after = TRUE,
  time = 1,
  time_unit = "days",
  multiple = "closest",
  add_column = NULL,
  keep_data = FALSE,
  nThread = parallel::detectCores() - 1
)
</code></pre>

<hr>
<h2 id='load_all'>Loads allergy data information into R.</h2><span id='topic+load_all'></span>

<h3>Description</h3>

<p>Loads allergy information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_all(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_all_+3A_file">file</code></td>
<td>
<p>string, full file path to All.txt.</p>
</td></tr>
<tr><td><code id="load_all_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_all_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_all_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_all_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_all_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_all_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_all_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_all_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with allergy information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_all_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>all</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_all_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>all</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_all_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_all</dt><dd><p>POSIXct, Date when the allergy was first noted, corresponds to Noted_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>all_all</dt><dd><p>string, Name of the allergen, corresponds to Allergen in RPDR.</p>
</dd>
<dt>all_all_code</dt><dd><p>string, Epic internal identifier for the specific allergen, corresponds to Allergen_Code in RPDR.</p>
</dd>
<dt>all_all_type</dt><dd><p>string, Hierarchy for the type of allergy noted. Denotes known level of specificity of allergen, corresponds to Allergen_Type in RPDR.</p>
</dd>
<dt>all_reac</dt><dd><p>string, Noted reactions to the allergen, corresponds to Reactions in RPDR.</p>
</dd>
<dt>all_reac_type</dt><dd><p>string, Category of reaction to the allergen, corresponds to Reaction_Type in RPDR.</p>
</dd>
<dt>all_severity</dt><dd><p>string, Degree of severity of noted reactions, corresponds to Severity in RPDR.</p>
</dd>
<dt>all_status</dt><dd><p>string, Last known status of allergen, either active or deleted from the patient's allergy record, corresponds to Status in RPDR.</p>
</dd>
<dt>all_system</dt><dd><p>string, The source system where the data was collected, corresponds to System in RPDR.</p>
</dd>
<dt>all_comment</dt><dd><p>string, Free-text information about the allergen, corresponds to Comments in RPDR.</p>
</dd>
<dt>all_del_reason</dt><dd><p>string, Free-text information about why the allergen was removed from the patient's allergy list, corresponds to Deleted_Reason in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_all &lt;- load_all(file = "test_All.txt")

#Use sequential processing
d_all &lt;- load_all(file = "test_All.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_all &lt;- load_all(file = "test_All.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_all_data'>Loads all RPDR text outputs into R.</h2><span id='topic+load_all_data'></span>

<h3>Description</h3>

<p>Loads all RPDR text outputs into R and returns a list of data tables processed. If multiple text files of the same type are available (if the query is larger than 25000 patients),
then add a <em>&quot;_&quot;</em> and a number to merge the same data sources into a single output in the order of the provided number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_all_data(
  folder,
  which_data = c("mrn", "con", "dem", "all", "bib", "dia", "enc", "lab", "lno", "mcm",
    "med", "mic", "phy", "prc", "prv", "ptd", "rdt", "rfv", "trn", "car", "dis", "end",
    "hnp", "opn", "pat", "prg", "pul", "rad", "vis"),
  old_dem = FALSE,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  many_sources = TRUE,
  load_report = TRUE,
  format_orig = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_all_data_+3A_folder">folder</code></td>
<td>
<p>string, full folder path to RPDR text files.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_which_data">which_data</code></td>
<td>
<p>string vector, an array of abbreviation corresponding to the datasources wished to load.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_old_dem">old_dem</code></td>
<td>
<p>boolean, should old <em>load_dem</em> function be used for loading demographic data. Defaults to <em>TRUE</em>, should be set to <em>FALSE</em> for Dem.txt datasets prior to 2022.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EMPI</em>,
as it is the preferred MRN in the RPDR system. In case of mrn dataset, leave at EMPI, as it is automatically converted to: &quot;Enterprise_Master_Patient_Index&quot;.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use for parallelization.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_many_sources">many_sources</code></td>
<td>
<p>boolean, if <em>TRUE</em>, then parallelization is done on the level of the datasources. If <em>FALSE</em>, then parallelization is done within the datasources.
If there are many datasources, then it is advised to set this TRUE, as then each different datasource will be processed in parallel.
However, if there are only a few datasources selected to load, but many files per datasource (result of large queries), then it may be faster to parallelize within each datasource and therefore should be set to <em>FALSE</em>.
If there are only a few sources each with one file then set to TRUE.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_load_report">load_report</code></td>
<td>
<p>boolean, should the report text be returned for notes. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_all_data_+3A_format_orig">format_orig</code></td>
<td>
<p>boolean, should report be returned in its original formatting or should white spaces used for formatting be removed. Defaults to <em>FALSE</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of parsed data tables containing the information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Load all Con, Dem and Mrn datasets processing all files within given datasource in parallel
load_all_data(folder = folder_rpdr, which_data = c("con", "dem", "mrn"),
nThread = 2, many_sources = FALSE)

#Load all supported file types parallelizing on the level of datasources
load_all_data(folder = folder_rpdr, nThread = 2, many_sources = TRUE,
format_orig = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_base'>Helper function for loading RPDR data into R.</h2><span id='topic+load_base'></span>

<h3>Description</h3>

<p>Helper function to load different datasources from RPDR. Should not be used on its own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_base(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE,
  src = "mrn",
  fill = FALSE,
  sep_load = "|"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_base_+3A_file">file</code></td>
<td>
<p>string, full file path to given RPDR txt.</p>
</td></tr>
<tr><td><code id="load_base_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EMPI</em>,
as it is the preferred MRN in the RPDR system. In case of mrn dataset, leave at EMPI, as it is automatically converted to: &quot;Enterprise_Master_Patient_Index&quot;.</p>
</td></tr>
<tr><td><code id="load_base_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_base_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_base_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_base_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_base_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_base_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_base_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
<tr><td><code id="load_base_+3A_src">src</code></td>
<td>
<p>string, what is the three letter source ID of the file, such as  <em>dem</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with minimally parsed data and the raw data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_src_EMPI</dt><dd><p>string, EMPI IDs from <em>src</em> datasource, if the datasource is not mrn. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_src_PMRN</dt><dd><p>string, PMRN IDs from <em>src</em> datasource, if the datasource is not mrn. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_scr_loc</dt><dd><p>string, from datasource <em>src</em>, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
</dl>


<hr>
<h2 id='load_bib'>Loads BiobankFile data into R.</h2><span id='topic+load_bib'></span>

<h3>Description</h3>

<p>Loads Biobank file data into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_bib(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_bib_+3A_file">file</code></td>
<td>
<p>string, full file path to Bib.txt.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept. Not used for loading mrn data.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_bib_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with BiobankFile data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_bib_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information, corresponds to Enterprise_Master_Patient_Index in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_MGH</dt><dd><p>string, Unique Medical Record Number for Mass General Hospital, corresponds to MGH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_BWH</dt><dd><p>string, Unique Medical Record Number for Brigham and Women's Hospital, corresponds to BWH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_FH</dt><dd><p>string, Unique Medical Record Number for Faulkner Hospital, corresponds to FH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_SRH</dt><dd><p>string, Unique Medical Record Number for Spaulding Rehabilitation Hospital, corresponds to SRH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_NWH</dt><dd><p>string, Unique Medical Record Number for Newton-Wellesley Hospital, corresponds to NWH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_NSMC</dt><dd><p>string, Unique Medical Record Number for North Shore Medical Center, corresponds to NSMC_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_MCL</dt><dd><p>string, Unique Medical Record Number for McLean Hospital, corresponds to MCL_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_MEE</dt><dd><p>string, Unique Medical Record Number for Mass Eye and Ear, corresponds to MEE_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_bib_DFC</dt><dd><p>string, Unique Medical Record Number for Dana Farber Cancer center, corresponds to DFC_MRN in RPDR. Data is formatted using pretty_mrn(). Legacy data.</p>
</dd>
<dt>ID_bib_WDH</dt><dd><p>string, Unique Medical Record Number for Wentworth-Douglass Hospital, corresponds to WDH_MRN in RPDR. Data is formatted using pretty_mrn(). Legacy data.</p>
</dd>
<dt>bib_subject_ID</dt><dd><p>string, Biobank unique patient identifier, corresponds to Subject_ID in RPDR. ID is not formatted.</p>
</dd>
<dt>bib_subject_ID</dt><dd><p>string, This will always default to Biobank, corresponds to Registry Name in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_bib &lt;- load_bib(file = "test_Bib.txt")

#Use sequential processing
d_bib &lt;- load_bib(file = "test_Bib.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_bib &lt;- load_bib(file = "test_Bib.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_con'>Loads contact information into R.</h2><span id='topic+load_con'></span>

<h3>Description</h3>

<p>Loads patient contact, insurance, and PCP information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_con(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_con_+3A_file">file</code></td>
<td>
<p>string, full file path to Con.txt.</p>
</td></tr>
<tr><td><code id="load_con_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_con_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_con_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_con_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_con_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_con_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_con_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_con_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>TURE</em> only for Con.txt, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with contact information data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_con_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>con</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_con_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>con</em>datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_con_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_con_loc_list</dt><dd><p>string, if prevalence of IDs in <em>Patient_ID_List</em> &gt; <em>perc</em>, then they are included in the output. Data is formatted using pretty_mrn().</p>
</dd>
<dt>name_last</dt><dd><p>string, Patient's last name, corresponds to Last_Name in RPDR.</p>
</dd>
<dt>name_first</dt><dd><p>string, Patient's first name, corresponds to First_Name in RPDR.</p>
</dd>
<dt>name_middle</dt><dd><p>string, Patient's middle name or initial, corresponds to Middle_Name in RPDR.</p>
</dd>
<dt>name_previous</dt><dd><p>string, Any alternate names on record for this patient, corresponds to Previous_Name in RPDR.</p>
</dd>
<dt>SSN</dt><dd><p>string, Social Security Number, corresponds to SSN in RPDR.</p>
</dd>
<dt>VIP</dt><dd><p>character, Special patient statuses as defined by the EMPI group, corresponds to VIP in RPDR.</p>
</dd>
<dt>address1</dt><dd><p>string, Patient's current address, corresponds to address1 in RPDR.</p>
</dd>
<dt>address2</dt><dd><p>string, Additional address information, corresponds to address2 in RPDR.</p>
</dd>
<dt>city</dt><dd><p>string, City of residence, corresponds to City in RPDR.</p>
</dd>
<dt>state</dt><dd><p>string, State of residence, corresponds to State in RPDR.</p>
</dd>
<dt>country_con</dt><dd><p>string, Country of residence from con datasource, corresponds to Country in RPDR.</p>
</dd>
<dt>zip_con</dt><dd><p>numeric, Mailing zip code of primary residence from con datasource, corresponds to Zip in RPDR. Formatted to 5 character zip codes using <em>pretty_numbers()</em>.</p>
</dd>
<dt>direct_contact_consent</dt><dd><p>boolean, Indicates whether the patient has given permission to contact them directly through the RODY program, corresponds to Direct_Contact_Consent in RPDR. Legacy variable.</p>
</dd>
<dt>research_invitations</dt><dd><p>boolean, Indicates if a patient can be invited to participate in research, corresponds to Research_Invitations in RPDR.</p>
</dd>
<dt>phone_home</dt><dd><p>number, Patient's home phone number, corresponds to Home_Phone in RPDR. Formatted to 10 digit phone numbers using <em>pretty_numbers()</em>.</p>
</dd>
<dt>phone_day</dt><dd><p>number, Phone number where the patient can be reached during the day, corresponds to Day_Phone in RPDR. Formatted to 10 digit phone numbers using <em>pretty_numbers()</em>.</p>
</dd>
<dt>insurance1</dt><dd><p>string, Patient's primary health insurance carrier and subscriber ID information, corresponds to Insurance_1 in RPDR.</p>
</dd>
<dt>insurance2</dt><dd><p>string, Patient's secondary health insurance carrier and subscriber ID information, if any, corresponds to Insurance_2 in RPDR.</p>
</dd>
<dt>insurance3</dt><dd><p>string, Patient's tertiary health insurance carrier and subscriber ID information, if any, corresponds to Insurance_3 in RPDR.</p>
</dd>
<dt>primary_care_physician</dt><dd><p>string, Comma-delimited list of all primary care providers on record for this patient per institution, along with contact information (if available),
corresponds to Primary_Care_Physician in RPDR.</p>
</dd>
<dt>primary_care_physician_resident</dt><dd><p>string, Comma-delimited list of any Resident primary care providers on record for this patient per institution, along with contact information (if available),
corresponds to Resident _Primary_Care_Physician in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_con &lt;- load_con(file = "test_Con.txt")

#Use sequential processing
d_con &lt;- load_con(file = "test_Con.txt", nThread = 1)

#Use parallel processing and parse data in
#MRN_Type and MRN columns (default in load_con) and keep all IDs
d_con &lt;- load_con(file = "test_Con.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_dem'>Loads demographic information into R for new demographic tables following changes in the beginning of 2022.</h2><span id='topic+load_dem'></span>

<h3>Description</h3>

<p>Loads patient demographic  and vital status information into the R environment. Since version 0.2.2 of the software this function supports the new demographics table data definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_dem(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_dem_+3A_file">file</code></td>
<td>
<p>string, full file path to Dem.txt.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_dem_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with demographic information data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_dem_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information.
from <em>dem</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dem_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network.
from <em>dem</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dem_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>gender_legal_sex</dt><dd><p>string, Patient's legal sex, corresponds to Gender_Legal_Sex in RPDR.</p>
</dd>
<dt>sex_at_birth</dt><dd><p>string, Patient’s sex at time of birth, corresponds to Sex_at_Birth in RPDR.</p>
</dd>
<dt>gender_identity</dt><dd><p>string, Patient's personal conception of their gender, corresponds to Gender_Identity in RPDR.</p>
</dd>
<dt>time_date_of_birth</dt><dd><p>POSIXct, Patient's date of birth, corresponds to Date_of_Birth. Converted to POSIXct format.</p>
</dd>
<dt>age</dt><dd><p>string, Patient's current age (or age at death), corresponds to Age in RPDR.</p>
</dd>
<dt>language</dt><dd><p>string, Patient's preferred spoken language, corresponds to Language in RPDR.</p>
</dd>
<dt>language_group</dt><dd><p>string, Patient's preferred language: English or Non-English, corresponds to Language_Group in RPDR.</p>
</dd>
<dt>race_1</dt><dd><p>string, Patient's primary race, corresponds to Race1 in RPDR.</p>
</dd>
<dt>race_2</dt><dd><p>string, Patient's primary race if more than one race, corresponds to Race2 in RPDR.</p>
</dd>
<dt>race_group</dt><dd><p>string, Patient's Race Group as determined by Race1 and Race2, corresponds to Race_Group in RPDR.</p>
</dd>
<dt>ethnic_group</dt><dd><p>string, Patient's Ethnicity: Hispanic or Non Hispanic, corresponds to Ethnic_Group in RPDR.</p>
</dd>
<dt>marital</dt><dd><p>string, Patient's current marital status, corresponds to Marital_Status in RPDR.</p>
</dd>
<dt>religion</dt><dd><p>string, Patient-identified religious preference, corresponds to Religion in RPDR.</p>
</dd>
<dt>veteran</dt><dd><p>string, Patient's current military veteran status, corresponds to Is_a_veteran in RPDR.</p>
</dd>
<dt>country_dem</dt><dd><p>string, Patient's current country of residence from dem datasource, corresponds to Country in RPDR.</p>
</dd>
<dt>zip_dem</dt><dd><p>string, Mailing zip code of patient's primary residence from dem datasource, corresponds to Zip_code in RPDR.Formatted to 5 character zip codes.</p>
</dd>
<dt>vital_status</dt><dd><p>string, Identifies if the patient is living or deceased.
This data is updated monthly from the Partners registration system and the Social Security Death Master Index, corresponds to Vital_Status in RPDR. Punctuation marks are removed.</p>
</dd>
<dt>time_date_of_death</dt><dd><p>POSIXct, Recorded date of death from source in 'Vital_Status'.
Date of death information obtained solely from the Social Security Death Index will not be reported until 3 years after death due to privacy concerns.
If the value is independently documented by a Partners entity within the 3 year window then the date will be displayed. corresponds to Date_of_Death in RPDR. Converted to POSIXct format.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_dem &lt;- load_dem(file = "test_Dem.txt")

#Use sequential processing
d_dem &lt;- load_dem(file = "test_Dem.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_dem &lt;- load_dem(file = "test_Dem.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_dem_old'>Loads demographic information into R for demographics tables before 2022.</h2><span id='topic+load_dem_old'></span>

<h3>Description</h3>

<p>Loads patient demographic  and vital status information into the R environment. Since version 0.2.2 of the software, this function supports the old demographics table data definitions
and is identical to the <em>load_dem</em> function of previous versions of the software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_dem_old(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_dem_old_+3A_file">file</code></td>
<td>
<p>string, full file path to Dem.txt.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_dem_old_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with demographic information data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_dem_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information.
from <em>dem</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dem_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network.
from <em>dem</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dem_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>gender</dt><dd><p>string, Patient's legal sex, corresponds to Gender in RPDR.</p>
</dd>
<dt>time_date_of_birth</dt><dd><p>POSIXct, Patient's date of birth, corresponds to Date_of_Birth in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>age</dt><dd><p>string, Patient's current age (or age at death), corresponds to Age in RPDR.</p>
</dd>
<dt>language</dt><dd><p>string, Patient's preferred spoken language, corresponds to Language in RPDR.</p>
</dd>
<dt>race</dt><dd><p>string, Patient's primary race, corresponds to Race in RPDR.</p>
</dd>
<dt>marital</dt><dd><p>string, Patient's current marital status, corresponds to Marital_Status in RPDR.</p>
</dd>
<dt>religion</dt><dd><p>string, Patient-identified religious preference, corresponds to Religion in RPDR.</p>
</dd>
<dt>veteran</dt><dd><p>string, Patient's current military veteran status, corresponds to Is_a_veteran in RPDR.</p>
</dd>
<dt>country_dem</dt><dd><p>string, Patient's current country of residence from dem datasource, corresponds to Country in RPDR.</p>
</dd>
<dt>zip_dem</dt><dd><p>string, Mailing zip code of patient's primary residence from dem datasource, corresponds to Zip_code in RPDR.Formatted to 5 character zip codes.</p>
</dd>
<dt>vital_status</dt><dd><p>string, Identifies if the patient is living or deceased.
This data is updated monthly from the Partners registration system and the Social Security Death Master Index, corresponds to Vital_Status in RPDR. Punctuation marks are removed.</p>
</dd>
<dt>time_date_of_death</dt><dd><p>POSIXct, Recorded date of death from source in 'Vital_Status'.
Date of death information obtained solely from the Social Security Death Index will not be reported until 3 years after death due to privacy concerns.
If the value is independently documented by a Partners entity within the 3 year window then the date will be displayed. corresponds to Date_of_Death in RPDR. Converted to POSIXct format.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_dem &lt;- load_dem_old(file = "test_Dem.txt")

#Use sequential processing
d_dem &lt;- load_dem_old(file = "test_Dem.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_dem &lt;- load_dem_old(file = "test_Dem.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_dia'>Loads diagnoses into R.</h2><span id='topic+load_dia'></span>

<h3>Description</h3>

<p>Loads diagnoses information into the R environment, both Dia and Dea files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_dia(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_dia_+3A_file">file</code></td>
<td>
<p>string, full file path to Dia.txt or Dea.txt.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_dia_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with diagnoses information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_dia_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>dia</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dia_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>dia</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_dia_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_dia</dt><dd><p>POSIXct, Date when the diagnosis was noted, corresponds to Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>dia_name</dt><dd><p>string, Name of the diagnosis, diagnosis-related group, or phenotype. For more information on available
Phenotypes visit https://phenotypes.partners.org/phenotype_list.html, corresponds to Diagnosis_Name in RPDR.</p>
</dd>
<dt>dia_code</dt><dd><p>string, Diagnosis, diagnosis-related group, or phenotype code, corresponds to Code in RPDR.</p>
</dd>
<dt>dia_code_type</dt><dd><p>string, Standardized classification system or custom grouping associated with the diagnosis code, corresponds to Code_type in RPDR.</p>
</dd>
<dt>dia_flag</dt><dd><p>string, Qualifier for the diagnosis, if any, corresponds to Diagnosis_flag in RPDR.</p>
</dd>
<dt>dia_enc_num</dt><dd><p>string, Unique identifier of the record/visit. This values includes the source system, hospital, and a unique identifier within the source system, corresponds to Encounter_number in RPDR.</p>
</dd>
<dt>dia_provider</dt><dd><p>string, Provider of record for the encounter where the diagnosis was entered, corresponds to Provider in RPDR.</p>
</dd>
<dt>dia_clinic</dt><dd><p>string, Specific department/location where the patient encounter took place, corresponds to Clinic in RPDR.</p>
</dd>
<dt>dia_hosp</dt><dd><p>string, Facility where the encounter occurred, corresponds to Hospital in RPDR.</p>
</dd>
<dt>dia_inpatient</dt><dd><p>string, Identifies whether the diagnosis was noted during an inpatient or outpatient encounter, corresponds to Inpatient_Outpatient in RPDR. Punctuation marks removed.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_dia &lt;- load_dia(file = "test_Dia.txt")

#Use sequential processing
d_dia &lt;- load_dia(file = "test_Dia.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_dea &lt;- load_dia(file = "test_Dea.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_enc'>Loads encounter information into R.</h2><span id='topic+load_enc'></span>

<h3>Description</h3>

<p>Loads encounter-level detail information into the R environment, both Enc and Exc files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_enc(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_enc_+3A_file">file</code></td>
<td>
<p>string, full file path to Enc.txt or Exc.txt</p>
</td></tr>
<tr><td><code id="load_enc_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_enc_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with encounter information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_enc_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>enc</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_enc_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>enc</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_enc_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>enc_numb</dt><dd><p>string, Unique identifier of the record/visit. This values includes the source system, hospital, and a unique identifier within the source system, corresponds to Encounter_number in RPDR.</p>
</dd>
<dt>time_enc_admit</dt><dd><p>POSIXct, Date when the patient was admitted or entered the facility, corresponds to Admit_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>time_enc_disch</dt><dd><p>POSIXct, Date when the patient was discharged or left the facility, corresponds to Discharge_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>enc_status</dt><dd><p>string, Billing account-related notes about the encounter. This will not be populated for all encounters, corresponds to Encounter_Status in RPDR.</p>
</dd>
<dt>enc_hosp</dt><dd><p>string, Facility where the encounter occurred, corresponds to Hospital in RPDR.</p>
</dd>
<dt>enc_inpatient</dt><dd><p>string, Classifies the type of encounter as either Inpatient or Outpatient. ED visits are currently classified under the 'Outpatient' label, corresponds to Inpatient_or_Outpatient in RPDR.</p>
</dd>
<dt>enc_service</dt><dd><p>string, Hospital service line assigned to the encounter, corresponds to Service_Line in RPDR.</p>
</dd>
<dt>enc_attending</dt><dd><p>string, The attending provider associated with the encounter. For Epic professional billing, this is the billing provider, corresponds to Attending_MD in RPDR.</p>
</dd>
<dt>enc_length</dt><dd><p>numeric, Length of stay for the encounter, corresponds to LOS_days in RPDR.</p>
</dd>
<dt>enc_clinic</dt><dd><p>string, Specific department/location where the encounter occured, corresponds to Clinic_Name in RPDR.</p>
</dd>
<dt>enc_admit_src</dt><dd><p>string, Location where the patient was admitted when entering the hospital/clinic, corresponds to Admit_Source in RPDR.</p>
</dd>
<dt>enc_pat_type</dt><dd><p>string, Provides information regarding the specific patient classifications and status of the patient visit. This field is only populated for McLean Hospital encounters, corresponds to Patient_Type in RPDR.</p>
</dd>
<dt>enc_ref_disp</dt><dd><p>string, Location where the patient has been directed for treatment or follow-up by a staff member. This field is only populated for McLean Hospital encounters, corresponds to Referrer_Discipline in RPDR.</p>
</dd>
<dt>enc_disch_disp</dt><dd><p>string, Patient's anticipated location or status following the encounter, corresponds to Discharge_Disposition in RPDR.</p>
</dd>
<dt>enc_pay</dt><dd><p>string, Payors responsible for the hospital account. Multiple payors (primary, secondary, etc.) may be listed, corresponds to Payor in RPDR.</p>
</dd>
<dt>enc_diag_admit</dt><dd><p>string, Initial working diagnosis documented by the admitting or attending physician, corresponds to Admitting_Diagnosis in RPDR.</p>
</dd>
<dt>enc_diag_princ</dt><dd><p>string, Condition established, after study, to be chiefly responsible for occasioning the admission of the patient to the hospital for care, corresponds to Principle_Diagnosis in RPDR.</p>
</dd>
<dt>enc_diag_1</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_1 in RPDR.</p>
</dd>
<dt>enc_diag_2</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_2 in RPDR.</p>
</dd>
<dt>enc_diag_3</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_3 in RPDR.</p>
</dd>
<dt>enc_diag_4</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_4 in RPDR.</p>
</dd>
<dt>enc_diag_5</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_5 in RPDR.</p>
</dd>
<dt>enc_diag_6</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_6 in RPDR.</p>
</dd>
<dt>enc_diag_7</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_7 in RPDR.</p>
</dd>
<dt>enc_diag_8</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_8 in RPDR.</p>
</dd>
<dt>enc_diag_9</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_9 in RPDR.</p>
</dd>
<dt>enc_diag_10</dt><dd><p>string, Additional diagnoses associated with this encounter or visit, corresponds to Diagnosis_10 in RPDR.</p>
</dd>
<dt>enc_diag_group</dt><dd><p>string, Diagnosis-Related Group for the encounter, in the following format: SYSTEM:CODE - Description, corresponds to DRG in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_enc &lt;- load_enc(file = "test_Enc.txt")

#Use sequential processing
d_enc &lt;- load_enc(file = "test_Enc.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_exc &lt;- load_enc(file = "test_Exc.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_lab'>Loads laboratory results into R.</h2><span id='topic+load_lab'></span>

<h3>Description</h3>

<p>Loads laboratory results into the R environment, both Lab and Clb files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_lab(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_lab_+3A_file">file</code></td>
<td>
<p>string, full file path to Lab.txt or Clb.txt.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_lab_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with laboratory exam information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_lab_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>lab</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_lab_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>lab</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_lab_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_lab_result</dt><dd><p>POSIXct, Date when the specimen was collected, corresponds to Seq_Date_Time in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>lab_group</dt><dd><p>string, Higher-level grouping concept used to consolidate similar tests across hospitals, corresponds to Group_ID in RPDR.</p>
</dd>
<dt>lab_loinc</dt><dd><p>string, Standardized LOINC code for the laboratory test, corresponds to Loinc_Code in RPDR.</p>
</dd>
<dt>lab_testID</dt><dd><p>string, Internal identifier for the test used by the source system, corresponds to Test_ID in RPDR.</p>
</dd>
<dt>lab_descript</dt><dd><p>string, Name of the lab test, corresponds to Test_Description in RPDR.</p>
</dd>
<dt>lab_result</dt><dd><p>string, Result value for the test, corresponds to Result in RPDR.</p>
</dd>
<dt>lab_result_txt</dt><dd><p>string, Additional information included with the result. This can include instructions for interpretation or comments from the laboratory, corresponds to Result_Text in RPDR.</p>
</dd>
<dt>lab_result_abn</dt><dd><p>string, Flag for identifying if values are outside of normal ranges or represent a significant deviation from previous values, corresponds to Abnormal_Flag in RPDR.</p>
</dd>
<dt>lab_result_unit</dt><dd><p>string, Units associated with the result value, corresponds to Reference_Unit in RPDR.</p>
</dd>
<dt>lab_result_range</dt><dd><p>string, Normal or therapeutic range for this value, corresponds to Reference_Range in RPDR.</p>
</dd>
<dt>lab_result_toxic</dt><dd><p>string, Reference range of values defined as being toxic to the patient, corresponds to Toxic_Range in RPDR.</p>
</dd>
<dt>lab_spec</dt><dd><p>string, Type of specimen collected to perform the test, corresponds to Specimen_Type in RPDR.</p>
</dd>
<dt>lab_spec_txt</dt><dd><p>string, Free-text information about the specimen, its collection or its integrity, corresponds to Specimen_Text in RPDR.</p>
</dd>
<dt>lab_correction</dt><dd><p>string, Free-text information about any changes made to the results, corresponds to Correction_Flag in RPDR.</p>
</dd>
<dt>lab_status</dt><dd><p>string, Flag which indicates whether the procedure is pending or complete, corresponds to Test_Status in RPDR.</p>
</dd>
<dt>lab_ord_pys</dt><dd><p>string, Name of the ordering physician, corresponds to Ordering_Doc in RPDR.</p>
</dd>
<dt>lab_accession</dt><dd><p>string, Internal tracking number assigned to the specimen for identification in the lab, corresponds to Accession in RPDR.</p>
</dd>
<dt>lab_source</dt><dd><p>string, Database source, either CDR (Clinical Data Repository) or RPDR (internal RPDR database), corresponds to Source in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_lab &lt;- load_lab(file = "test_Lab.txt")

#Use sequential processing
d_lab &lt;- load_lab(file = "test_Lab.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_clb &lt;- load_lab(file = "test_Clb.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_lno'>Loads LMR note documents into R.</h2><span id='topic+load_lno'></span>

<h3>Description</h3>

<p>Loads notes from the LMR legacy EHR system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_lno(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_lno_+3A_file">file</code></td>
<td>
<p>string, full file path to Lno.txt.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_lno_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with LMR notes information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_lno_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>lno</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_lno_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>lno</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_lno_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_lno</dt><dd><p>POSIXct, Date when the report was filed, corresponds to LMRNote_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>lno_rec_id</dt><dd><p>string, Internal identifier for this report within the LMR system, corresponds to Record_Id in RPDR.</p>
</dd>
<dt>lno_status</dt><dd><p>string, Completion status of the note, corresponds to Status in RPDR.</p>
</dd>
<dt>lno_author</dt><dd><p>string, Name of user who created the note, corresponds to Author in RPDR.</p>
</dd>
<dt>lno_author_mrn</dt><dd><p>string, Author's user identifier within the LMR system, corresponds to Author_MRN in RPDR.</p>
</dd>
<dt>lno_COD</dt><dd><p>string, Hospital-specific user code of the note author. The first character is a hospital-specific prefix, corresponds to COD in RPDR.</p>
</dd>
<dt>lno_hosp</dt><dd><p>string, Facility where the encounter occurred, corresponds to Institution in RPDR.</p>
</dd>
<dt>lno_subject</dt><dd><p>string, Type of note. This value is derived from the &quot;Subject&quot; line of the narrative text, corresponds to Subject in RPDR.</p>
</dd>
<dt>lno_rep_txt</dt><dd><p>string, Full narrative text of the note, corresponds to Comments in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_lno &lt;- load_lno(file = "test_Lno.txt")

#Use sequential processing
d_lno &lt;- load_lno(file = "test_Lno.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_lno &lt;- load_lno(file = "test_Lno.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_mcm'>Loads match control data into R.</h2><span id='topic+load_mcm'></span>

<h3>Description</h3>

<p>Loads match control tables into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_mcm(
  file,
  sep = ":",
  id_length = "standard",
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_mcm_+3A_file">file</code></td>
<td>
<p>string, full file path to Mcm.txt.</p>
</td></tr>
<tr><td><code id="load_mcm_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_mcm_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.</p>
</td></tr>
<tr><td><code id="load_mcm_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mcm_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mcm_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with matching data.
</p>

<dl>
<dt>ID_case_PMRN</dt><dd><p>string, Epic PMRN value for a patient in the index cohort, corresponds to Case_Patient_EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_case_EMPI</dt><dd><p>string, EMPI value for a patient in the index cohort, corresponds to Case_Patient_EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_control_PMRN</dt><dd><p>string, Epic PMRN value for a patient matched to a case in the index cohort, corresponds to Control_Patient_EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_control_EMPI</dt><dd><p>string, EMPI value for a control patient matched to a case in the index cohort, corresponds to Control_Patient_EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>match_strength</dt><dd><p>string, Number of similar data points between the index patient and the control patient. This number corresponds to the number of controls (Age, Gender, etc.) chosen during the match control query creation process, corresponds to Match_Strength in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_mcm &lt;- load_mcm(file = "test_Mcm.txt")

#Use sequential processing
d_mcm &lt;- load_mcm(file = "test_Mcm.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_mcm &lt;- load_mcm(file = "test_Mcm.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_med'>Loads medication order detail into R.</h2><span id='topic+load_med'></span>

<h3>Description</h3>

<p>Loads medication order detail information into the R environment, both Med and Mee files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_med(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_med_+3A_file">file</code></td>
<td>
<p>string, full file path to Med.txt or Mee.txt</p>
</td></tr>
<tr><td><code id="load_med_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_med_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_med_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_med_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_med_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_med_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_med_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_med_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with medication order information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_med_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>enc</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_med_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>enc</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_med_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>med_enc_numb</dt><dd><p>string, Unique identifier of the record/visit, displayed in the following format: Source System - Institution Number, corresponds to Encounter_number in RPDR.</p>
</dd>
<dt>time_med</dt><dd><p>POSIXct, Completion status of the requested test/transfusion. Converted to POSIXct format, corresponds to Medication_Date in RPDR.</p>
</dd>
<dt>time_med_detail</dt><dd><p>string, To clarify when patients may have stopped taking a medication, this column provides the statuses of 'Listed' or 'Removed'. This is provided on pre-Epic (LMR) medication dates (1997-2017).
The 'Listed' value denotes that a medication was on the patient's medication list on the date indicated.
The 'Removed' value denotes that a medication was removed from a patient's medication list on the date indicated. Corresponds to Medication_Date_Detail in RPDR.</p>
</dd>
<dt>med</dt><dd><p>string, Name of the medication. This may be appended with the source system in the case of OnCall and LMR medications, corresponds to Medication in RPDR.</p>
</dd>
<dt>med_code</dt><dd><p>string, Medication code associated with the &quot;Code_type&quot; value, corresponds to Code in RPDR.</p>
</dd>
<dt>med_code_type</dt><dd><p>string, Standardized classification system or custom source value used to identify the medication, corresponds to Code_Type in RPDR.</p>
</dd>
<dt>med_quant</dt><dd><p>string, Number of units of the medication ordered, corresponds to Quantity in RPDR.</p>
</dd>
<dt>med_prov</dt><dd><p>string, Ordering provider for the medication, corresponds to Provider in RPDR.</p>
</dd>
<dt>med_clinic</dt><dd><p>string, Specific department/location where the medication was ordered or administered, corresponds to Clinic in RPDR.</p>
</dd>
<dt>med_hosp</dt><dd><p>string, Facility where the medication was ordered or administered, corresponds to Hospital in RPDR.</p>
</dd>
<dt>med_inpatient</dt><dd><p>string, Identifies whether the medication was ordered with an Inpatient or Outpatient indication, corresponds to Inpatient_Outpatient in RPDR.</p>
</dd>
<dt>med_add_info</dt><dd><p>string, Additional administration information about the medication, corresponds to Additional_Info in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_med &lt;- load_med(file = "test_Med.txt")

#Use sequential processing
d_med &lt;- load_med(file = "test_Med.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_mee &lt;- load_med(file = "test_Mee.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_mic'>Loads microbiology results into R.</h2><span id='topic+load_mic'></span>

<h3>Description</h3>

<p>Loads microbiology results into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_mic(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE,
  format_orig = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_mic_+3A_file">file</code></td>
<td>
<p>string, full file path to Mic.txt</p>
</td></tr>
<tr><td><code id="load_mic_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
<tr><td><code id="load_mic_+3A_format_orig">format_orig</code></td>
<td>
<p>boolean, should report be returned in its original formatting or should white spaces used for formatting be removed. Defaults to <em>FALSE</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with microbiology information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_mic_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>mic</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mic_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>mic</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mic_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_mic</dt><dd><p>POSIXct, Date when the specimen was received by the laboratory, corresponds to Microbiology_Date_Time in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>mic_org_code</dt><dd><p>string, Internal identifier for the organism used by the source system, corresponds to Organism_Code in RPDR.</p>
</dd>
<dt>mic_org_name</dt><dd><p>string, Name of the organism identified or tested, corresponds to Organism_Name in RPDR.</p>
</dd>
<dt>mic_org_text</dt><dd><p>string, Full narrative text of the test and results, including sensitivities, corresponds to Organism_Text in RPDR.</p>
</dd>
<dt>mic_org_comment</dt><dd><p>string, Free-text information about the organism or result, corresponds to Organism_Comment in RPDR.</p>
</dd>
<dt>mic_test_code</dt><dd><p>string, Internal identifier for the test used by the source system, corresponds to Test_Code in RPDR.</p>
</dd>
<dt>mic_test_name</dt><dd><p>string, Name of the assay to be performed, or the results of a culture, corresponds to Test_Name in RPDR.</p>
</dd>
<dt>mic_test_status</dt><dd><p>string, Status of the results, i.e. preliminary or final, corresponds to Test_Status in RPDR.</p>
</dd>
<dt>mic_test_comment</dt><dd><p>string, Free-text information about the test and results, corresponds to Test_Comments in RPDR.</p>
</dd>
<dt>mic_spec</dt><dd><p>string, Type of specimen collected to perform the test, corresponds to Specimen_Type in RPDR.</p>
</dd>
<dt>mic_spec_txt</dt><dd><p>string, Free-text information about the specimen, its collection or its integrity, corresponds to Specimen_Comments in RPDR.</p>
</dd>
<dt>mic_accession</dt><dd><p>string, Internal tracking number assigned to the specimen for identification in the microbiology lab, corresponds to Microbiology_Number in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_mic &lt;- load_mic(file = "test_Mic.txt")

#Use sequential processing
d_mic &lt;- load_mic(file = "test_Mic.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_mic &lt;- load_mic(file = "test_Mic.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_mrn'>Loads MRN data into R.</h2><span id='topic+load_mrn'></span>

<h3>Description</h3>

<p>Loads patient identifiers for Partners institutions, including hospital-specific MRNs into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_mrn(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_mrn_+3A_file">file</code></td>
<td>
<p>string, full file path to Mrn.txt.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept. Not used for loading mrn data.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_mrn_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with MRN data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_mrn_INCOMING</dt><dd><p>string, Patient identifier, usually the EMPI, corresponds to IncomingId in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_INCOMING_SITE</dt><dd><p>string, Source of identifier, e.g. EMP for Enterprise Master Patient Index, MGH for Mass General Hospital, corresponds to IncomingSite in RPDR.</p>
</dd>
<dt>ID_mrn_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information, corresponds to Enterprise_Master_Patient_Index in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_MGH</dt><dd><p>string, Unique Medical Record Number for Mass General Hospital, corresponds to MGH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_BWH</dt><dd><p>string, Unique Medical Record Number for Brigham and Women's Hospital, corresponds to BWH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_FH</dt><dd><p>string, Unique Medical Record Number for Faulkner Hospital, corresponds to FH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_SRH</dt><dd><p>string, Unique Medical Record Number for Spaulding Rehabilitation Hospital, corresponds to SRH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_NWH</dt><dd><p>string, Unique Medical Record Number for Newton-Wellesley Hospital, corresponds to NWH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_NSMC</dt><dd><p>string, Unique Medical Record Number for North Shore Medical Center, corresponds to NSMC_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_MCL</dt><dd><p>string, Unique Medical Record Number for McLean Hospital, corresponds to MCL_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_MEE</dt><dd><p>string, Unique Medical Record Number for Mass Eye and Ear, corresponds to MEE_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_DFC</dt><dd><p>string, Unique Medical Record Number for Dana Farber Cancer center, corresponds to DFC_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_WDH</dt><dd><p>string, Unique Medical Record Number for Wentworth-Douglass Hospital, corresponds to WDH_MRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_mrn_STATUS</dt><dd><p>string, Status of the record, corresponds to Status in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_mrn &lt;- load_mrn(file = "test_Mrn.txt")

#Use sequential processing
d_mrn &lt;- load_mrn(file = "test_Mrn.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_mrn &lt;- load_mrn(file = "test_Mrn.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_notes'>Loads note documents into R.</h2><span id='topic+load_notes'></span>

<h3>Description</h3>

<p>Loads documents information into the R environment, which are:
</p>

<dl>
<dt>Cardiology: </dt><dd><p>&quot;car&quot;</p>
</dd>
<dt>Discharge: </dt><dd><p>&quot;dis&quot;</p>
</dd>
<dt>Endoscopy: </dt><dd><p>&quot;end&quot;</p>
</dd>
<dt>History &amp; Physical: </dt><dd><p>&quot;hnp&quot;</p>
</dd>
<dt>Operative: </dt><dd><p>&quot;opn&quot;</p>
</dd>
<dt>Pathology: </dt><dd><p>&quot;pat&quot;</p>
</dd>
<dt>Progress: </dt><dd><p>&quot;prg&quot;</p>
</dd>
<dt>Pulmonary: </dt><dd><p>&quot;pul&quot;</p>
</dd>
<dt>Radiology: </dt><dd><p>&quot;rad&quot;</p>
</dd>
<dt>Visit: </dt><dd><p>&quot;vis&quot;</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>load_notes(
  file,
  type,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE,
  load_report = TRUE,
  format_orig = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_notes_+3A_file">file</code></td>
<td>
<p>string, full file path to given type of note i.e. Hnp.txt.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_type">type</code></td>
<td>
<p>string, the type of note to be loaded. May be on of: &quot;car&quot;, &quot;dis&quot;, &quot;end&quot;, &quot;hnp&quot;, &quot;opn&quot;, &quot;pat&quot;, &quot;prg&quot;, &quot;pul&quot;, &quot;rad&quot; or &quot;vis&quot;.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_load_report">load_report</code></td>
<td>
<p>boolean, should the report text be returned in the data table. Defaults to <em>TRUE</em>. However, be aware that some notes may take up more memory than available on the machine.</p>
</td></tr>
<tr><td><code id="load_notes_+3A_format_orig">format_orig</code></td>
<td>
<p>boolean, should report be returned in its original formatting or should white spaces used for formatting be removed. Defaults to <em>FALSE</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with notes information. <em>abc</em> stands for the three letter abbreviation of the given type of note.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_abc_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>abc</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_abc_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>abc</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_abc_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>abc_rep_num</dt><dd><p>string, Source-specific identifier used to reference the report, corresponds to Report_Number in RPDR.</p>
</dd>
<dt>time_abc</dt><dd><p>POSIXct, Date when the report was filed, corresponds to Report_Date_Time in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>abc_rep_desc</dt><dd><p>string, Type of report or procedure documented in the report, corresponds to Report_Description in RPDR.</p>
</dd>
<dt>abc_rep_status</dt><dd><p>string, Completion status of the note/report, corresponds to Report_Status in RPDR.</p>
</dd>
<dt>abc_rep_type</dt><dd><p>string, See specification in RPDR data dictionary, corresponds to Report_Type in RPDR.</p>
</dd>
<dt>abc_rep_txt</dt><dd><p>string, Full narrative text contained in the note/report, corresponds to Report_Text in RPDR. Only provided if <em>load_report</em> is TRUE.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_hnp &lt;- load_notes(file = "test_Hnp.txt", type = "hnp")

#Use sequential processing
d_hnp &lt;- load_notes(file = "test_Hnp.txt", type = "hnp", nThread = 1, format_orig = TRUE)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_hnp &lt;- load_notes(file = "test_Hnp.txt", type = "hnp", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_phy'>Loads helath history information into R.</h2><span id='topic+load_phy'></span>

<h3>Description</h3>

<p>Loads vital signs, social history, immunizations, and various other health history details into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_phy(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_phy_+3A_file">file</code></td>
<td>
<p>string, full file path to Phy.txt.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_phy_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with health history information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_phy_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>phy</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_phy_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>phy</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_phy_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_phy</dt><dd><p>POSIXct, Date when the diagnosis was noted, corresponds to Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>phy_name</dt><dd><p>string, Type of clinical value/observation recorded, corresponds to Concept_Name in RPDR.</p>
</dd>
<dt>phy_code</dt><dd><p>string, Source-specific identifier for the specific type of clinical observation, corresponds to Code in RPDR.</p>
</dd>
<dt>phy_code_type</dt><dd><p>string, Source system for the value, corresponds to Code_type in RPDR.</p>
</dd>
<dt>phy_result</dt><dd><p>string, Value associated with the clinical observation. Note: BMI results are calculated internally in the RPDR, corresponds to Results in RPDR.</p>
</dd>
<dt>phy_unit</dt><dd><p>string, Units associated with the clinical observation, corresponds to Units in RPDR.</p>
</dd>
<dt>phy_provider</dt><dd><p>string, Provider of record for the encounter where the observation was recorded, corresponds to Providers in RPDR.</p>
</dd>
<dt>phy_clinic</dt><dd><p>string, Specific department/location where the patient observation was recorded, corresponds to Clinic in RPDR.</p>
</dd>
<dt>phy_hosp</dt><dd><p>string, Facility where the observation was recorded, corresponds to Hospital in RPDR.</p>
</dd>
<dt>phy_inpatient</dt><dd><p>string, Classifies the type of encounter where the observation was entered, corresponds to Inpatient_Outpatient in RPDR.</p>
</dd>
<dt>phy_enc_num</dt><dd><p>string, Unique identifier of the record/visit. This values includes the source system and a unique identifier within the source system, corresponds to Encounter_number in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_phy &lt;- load_phy(file = "test_Phy.txt")

#Use sequential processing
d_phy &lt;- load_phy(file = "test_Phy.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_phy &lt;- load_phy(file = "test_Phy.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_prc'>Loads procedures into R.</h2><span id='topic+load_prc'></span>

<h3>Description</h3>

<p>Loads Clinical procedure information into the R environment, both Prc and Pec files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_prc(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_prc_+3A_file">file</code></td>
<td>
<p>string, full file path to Prc.txt or Pec.txt.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_prc_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with procedural information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_prc_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>prc</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_prc_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>prc</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_prc_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_prc</dt><dd><p>POSIXct, Date when the procedure was performed, corresponds to Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>prc_name</dt><dd><p>string, Name of the procedure or operation performed, corresponds to Procedure_Name in RPDR.</p>
</dd>
<dt>prc_code</dt><dd><p>string, Procedure code associated with the &quot;Code_type&quot; value, corresponds to Code in RPDR.</p>
</dd>
<dt>prc_code_type</dt><dd><p>string, Standardized classification system or custom source value associated with the procedure code, corresponds to Code_type in RPDR.</p>
</dd>
<dt>prc_flag</dt><dd><p>string, Qualifier for the diagnosis, corresponds to Procedure_Flag in RPDR.</p>
</dd>
<dt>prc_quantity</dt><dd><p>string, Number of the procedures that were ordered for this record, corresponds to Quantity in RPDR.</p>
</dd>
<dt>prc_provider</dt><dd><p>string, Provider identifies the health care clinician performing the procedure, corresponds to Provider in RPDR.</p>
</dd>
<dt>prc_clinic</dt><dd><p>string, Specific department/location where the procedure was ordered or performed, corresponds to Clinic in RPDR.</p>
</dd>
<dt>prc_hosp</dt><dd><p>string, Facility where the procedure was ordered or performed, corresponds to Hospital in RPDR.</p>
</dd>
<dt>prc_inpatient</dt><dd><p>string, classifies the type of encounter where the procedure was performed or ordered.</p>
</dd>
<dt>prc_enc_num</dt><dd><p>string, Unique identifier of the record/visit, displayed in the following format: Source System - Institution Number, corresponds to Encounter_number in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_prc &lt;- load_prc(file = "test_Prc.txt")

#Use sequential processing
d_prc &lt;- load_prc(file = "test_Prc.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_pec &lt;- load_prc(file = "test_Pec.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_prv'>Loads providers information into R.</h2><span id='topic+load_prv'></span>

<h3>Description</h3>

<p>Loads providers information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_prv(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_prv_+3A_file">file</code></td>
<td>
<p>string, full file path to Prv.txt.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_prv_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>TURE</em> only for Con.txt, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with provider information data.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_con_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>con</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_con_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>con</em>datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_con_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_prv_last_seen</dt><dd><p>POSIXct, Date when the patient was last seen by the provider, corresponds to Last_Seen_Date in RPDR.</p>
</dd>
<dt>prv_name</dt><dd><p>string, Full name of the provider, corresponds to Provider_Name in RPDR.</p>
</dd>
<dt>prv_rank</dt><dd><p>string, Provides a quantitative value of provider's level of interaction with the patient.
This is calculated using the number of CPT codes for face-to-face visits that the provider has billed for in relation to the patient, corresponds to Provider_Rank in RPDR.</p>
</dd>
<dt>prv_ID</dt><dd><p>string, Identification code for the provider, including the source institution, corresponds to Provider_ID in RPDR.</p>
</dd>
<dt>prv_ID_CMP</dt><dd><p>string, Corporate Provider Master ID. This is the unique identifier for a provider across the MGB network, corresponds to CPM_Id in RPDR.</p>
</dd>
<dt>prv_spec</dt><dd><p>string, Comma-delimited list of the provider's specialties, corresponds to Specialties in RPDR.</p>
</dd>
<dt>prv_pcp</dt><dd><p>string, Available for BWH and MGH PCPs only. Flag indicating whether the provider is listed as the
patient's Primary Care Physician, corresponds to Is_PCP in RPDR.</p>
</dd>
<dt>prv_dep</dt><dd><p>string, Provider's department, corresponds to Enterprise_service in RPDR.</p>
</dd>
<dt>prv_address1</dt><dd><p>string, Address of the provider's primary practice, corresponds to Address_1 in RPDR.</p>
</dd>
<dt>prv_address2</dt><dd><p>string, Additional address information, corresponds to Address_2 in RPDR.</p>
</dd>
<dt>prv_city</dt><dd><p>string, City of the provider's primary practice, corresponds to City in RPDR.</p>
</dd>
<dt>prv_state</dt><dd><p>string, State of the provider's primary practice, corresponds to State in RPDR.</p>
</dd>
<dt>prv_zip</dt><dd><p>string, Mailing zip code of provider's primary practice, corresponds to Zip in RPDR.</p>
</dd>
<dt>prv_phone</dt><dd><p>string, Telephone number of the provider's primary practice, corresponds to Phone_Ext in RPDR.</p>
</dd>
<dt>prv_fax</dt><dd><p>string, Fax number of the provider's primary practice, corresponds to Fax in RPDR.</p>
</dd>
<dt>prv_email</dt><dd><p>string, Primary e-mail address for the provider, corresponds to Email in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_prv &lt;- load_prv(file = "test_Prv.txt")

#Use sequential processing
d_prv &lt;- load_prv(file = "test_Prv.txt", nThread = 1)

#Use parallel processing and parse data in
#MRN_Type and MRN columns (default in load_con) and keep all IDs
d_prv &lt;- load_prv(file = "test_Prv.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_ptd'>Loads patient data information into R.</h2><span id='topic+load_ptd'></span>

<h3>Description</h3>

<p>Loads patient data information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ptd(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_ptd_+3A_file">file</code></td>
<td>
<p>string, full file path to Ptd.txt.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_ptd_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with patient data information information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_ptd_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>ptd</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_ptd_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>ptd</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_ptd_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_ptd_start</dt><dd><p>POSIXct, Date item was initiated in the record, corresponds to Start_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>time_ptd_end</dt><dd><p>POSIXct, Date item was finalized in the record, corresponds to End_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>ptd_desc</dt><dd><p>string, Name of the item being reported, corresponds to Description in RPDR.</p>
</dd>
<dt>ptd_result</dt><dd><p>string, Result of the item being reported, corresponds to Result in RPDR.</p>
</dd>
<dt>ptd_type</dt><dd><p>string, Describes the type of data being reported, corresponds to Patient_Data_Type in RPDR.</p>
</dd>
<dt>ptd_enc_num</dt><dd><p>string, Unique identifier of the record/visit. This values includes the source system and a unique identifier within the source system, corresponds to Encounter_number in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_ptd &lt;- load_ptd(file = "test_Phy.txt")

#Use sequential processing
d_ptd &lt;- load_ptd(file = "test_Phy.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_ptd &lt;- load_ptd(file = "test_Phy.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_rdt'>Loads radiology procedures data into R.</h2><span id='topic+load_rdt'></span>

<h3>Description</h3>

<p>Loads radiology procedures information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_rdt(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_rdt_+3A_file">file</code></td>
<td>
<p>string, full file path to Rdt.txt.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_rdt_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with radiological exam information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_rdt_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>rdt</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_rdt_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>rdt</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_rdt_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_rdt_exam</dt><dd><p>POSIXct, Date of the radiology exam, corresponds to Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>rdt_mode</dt><dd><p>string, Modality of the exam, corresponds to Mode in RPDR.</p>
</dd>
<dt>rdt_group</dt><dd><p>string, Higher-level grouping concept used to consolidate similar procedures across hospitals, corresponds to Group in RPDR.</p>
</dd>
<dt>rdt_test_code</dt><dd><p>string, Internal identifier for the procedure used by the source system, corresponds to Test_Code in RPDR.</p>
</dd>
<dt>rdt_test_desc</dt><dd><p>string, Full name of the exam/study performed, corresponds to Test_Description in RPDR.</p>
</dd>
<dt>rdt_accession</dt><dd><p>string, Identifier assigned to the report or procedure for Radiology tracking purposes, corresponds to Accession_Number in RPDR.</p>
</dd>
<dt>rdt_provider</dt><dd><p>string, Ordering or authorizing provider for the study, corresponds to Provider in RPDR.</p>
</dd>
<dt>rdt_clinic</dt><dd><p>string, Specific department/location where the procedure was ordered or performed, corresponds to Clinic in RPDR.</p>
</dd>
<dt>rdt_hosp</dt><dd><p>string, Facility where the order was entered, corresponds to Hospital in RPDR.</p>
</dd>
<dt>rdt_inpatient</dt><dd><p>string, Classifies the type of encounter where the procedure was performed, corresponds to Inpatient_Outpatient in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_rdt &lt;- load_rdt(file = "test_Rdt.txt")

#Use sequential processing
d_rdt &lt;- load_rdt(file = "test_Rdt.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_rdt &lt;- load_rdt(file = "test_Rdt.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_rfv'>Loads reason for visit data into R.</h2><span id='topic+load_rfv'></span>

<h3>Description</h3>

<p>Loads reason for visit information into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_rfv(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_rfv_+3A_file">file</code></td>
<td>
<p>string, full file path to Rfv.txt.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_rfv_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with reason for visit information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_rfv_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>dia</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_rfv_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>rfv</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_rfv_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_rfv_start</dt><dd><p>POSIXct, Start date of the encounter, corresponds to Start_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>time_rfv_end</dt><dd><p>POSIXct, End date of the encounter, corresponds to End_Date in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>rfv_provider</dt><dd><p>string, Primary provider for the encounter, corresponds to Provider in RPDR.</p>
</dd>
<dt>rfv_hosp</dt><dd><p>string, Facility where the encounter occurred, corresponds to Hospital in RPDR.</p>
</dd>
<dt>rfv_clinic</dt><dd><p>string, Specific department/location where the patient encounter took place, corresponds to Clinic in RPDR.</p>
</dd>
<dt>rfv_chief_complaint</dt><dd><p>string, Description of the chief complaint/reason for visit, corresponds to Chief_Complaint in RPDR.</p>
</dd>
<dt>rfv_concept_id</dt><dd><p>string, Epic identifier for the chief complaint/reason for visit, corresponds to Concept_id in RPDR.</p>
</dd>
<dt>rfv_comment</dt><dd><p>string, Free-text comments regarding the chief complain/reason for visit, corresponds to Comments in RPDR.</p>
</dd>
<dt>rfv_enc_numb</dt><dd><p>string, Unique identifier of the record/visit. This values includes the source system, hospital, and a unique identifier within the source system, corresponds to Encounter_number in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_rfv &lt;- load_rfv(file = "test_Rfv.txt")

#Use sequential processing
d_rfv &lt;- load_rfv(file = "test_Rfv.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_rfv &lt;- load_rfv(file = "test_Rfv.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_trn'>Loads transfusion results into R.</h2><span id='topic+load_trn'></span>

<h3>Description</h3>

<p>Loads transfusion results into the R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_trn(
  file,
  merge_id = "EMPI",
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  na = TRUE,
  identical = TRUE,
  nThread = parallel::detectCores() - 1,
  mrn_type = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_trn_+3A_file">file</code></td>
<td>
<p>string, full file path to Trn.txt</p>
</td></tr>
<tr><td><code id="load_trn_+3A_merge_id">merge_id</code></td>
<td>
<p>string, column name to use to create <em>ID_MERGE</em> column used to merge different datasets. Defaults to <em>EPIC_PMRN</em>,
as it is the preferred MRN in the RPDR system.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Data present in <em>perc x 100%</em> of patients are kept.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_na">na</code></td>
<td>
<p>boolean, whether to remove columns with only NA values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_identical">identical</code></td>
<td>
<p>boolean, whether to remove columns with identical values. Defaults to <em>TRUE</em>.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use to load data.</p>
</td></tr>
<tr><td><code id="load_trn_+3A_mrn_type">mrn_type</code></td>
<td>
<p>boolean, should data in <em>MRN_Type</em> and <em>MRN</em> be parsed. Defaults to <em>FALSE</em>, as it is not advised to parse these for all data sources as it takes considerable time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with transfusion information.
</p>

<dl>
<dt>ID_MERGE</dt><dd><p>numeric, defined IDs by <em>merge_id</em>, used for merging later.</p>
</dd>
<dt>ID_trn_EMPI</dt><dd><p>string, Unique Partners-wide identifier assigned to the patient used to consolidate patient information
from <em>trn</em> datasource, corresponds to EMPI in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_trn_PMRN</dt><dd><p>string, Epic medical record number. This value is unique across Epic instances within the Partners network
from <em>trn</em> datasource, corresponds to EPIC_PMRN in RPDR. Data is formatted using pretty_mrn().</p>
</dd>
<dt>ID_trn_loc</dt><dd><p>string, if mrn_type == TRUE, then the data in <em>MRN_Type</em> and <em>MRN</em> are parsed into IDs corresponding to locations <em>(loc)</em>. Data is formatted using pretty_mrn().</p>
</dd>
<dt>time_trn</dt><dd><p>POSIXct, Date when the transfusion was administered or test was performed, corresponds to Transaction_Date_Time in RPDR. Converted to POSIXct format.</p>
</dd>
<dt>trn_descript</dt><dd><p>string, The type of procedure or product administered, corresponds to Test_Description in RPDR.</p>
</dd>
<dt>trn_result</dt><dd><p>string, Results of the test or transaction/lot number of transfusion, corresponds to Results in RPDR.</p>
</dd>
<dt>trn_result_abn</dt><dd><p>string, Denotes an abnormal finding or value, corresponds to Abnormal_Flag in RPDR.</p>
</dd>
<dt>trn_comment</dt><dd><p>string, Free-text comments about the status of the test/transfusion, corresponds to Comments in RPDR.</p>
</dd>
<dt>trn_status</dt><dd><p>string, Completion status of the requested test/transfusion, corresponds to Status_Flag in RPDR.</p>
</dd>
<dt>trn_accession</dt><dd><p>string, Identifier assigned to the test/transfusion for tracking purposes by the blood bank, corresponds to Accession in RPDR.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Using defaults
d_trn &lt;- load_trn(file = "test_Trn.txt")

#Use sequential processing
d_trn &lt;- load_trn(file = "test_Trn.txt", nThread = 1)

#Use parallel processing and parse data in MRN_Type and MRN columns and keep all IDs
d_trn &lt;- load_trn(file = "test_Trn.txt", nThread = 20, mrn_type = TRUE, perc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_ids'>Parse IDs from a string of delimited list of values.</h2><span id='topic+parse_ids'></span>

<h3>Description</h3>

<p>Creates columns corresponding to MRNs in the string of delimited list of values. If the string and the numeric part of the MRN
are present in the same column, then supply the column to <em>str</em>. If the string portion and the numeric portion is in different columns, then
supply the string part to <em>str</em> and the numeric part to <em>num</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_ids(
  str,
  num = NULL,
  sep = ":",
  id_length = "standard",
  perc = 0.6,
  nThread = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_ids_+3A_str">str</code></td>
<td>
<p>vector, delimited list of MRN string values.</p>
</td></tr>
<tr><td><code id="parse_ids_+3A_num">num</code></td>
<td>
<p>vector, delimited list of MRN numeric values.</p>
</td></tr>
<tr><td><code id="parse_ids_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="parse_ids_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="parse_ids_+3A_perc">perc</code></td>
<td>
<p>numeric, a number between 0-1 indicating which parsed ID columns to keep. Columns present in <em>perc x 100%</em> of patients have are kept.</p>
</td></tr>
<tr><td><code id="parse_ids_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use by <em>dopar</em> for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with columns corresponding to MRNs in the string of delimited list of values.
</p>

<hr>
<h2 id='pretty_mrn'>Converts MRN integer to string compatible with RPDR.</h2><span id='topic+pretty_mrn'></span>

<h3>Description</h3>

<p>Adds or removes zeros from integers to comply with MRN code standards for given institution and adds institution prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_mrn(v, prefix = "MGH", sep = ":", id_length = "standard", nThread = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_mrn_+3A_v">v</code></td>
<td>
<p>vector, integer or sting vector with MRNs.</p>
</td></tr>
<tr><td><code id="pretty_mrn_+3A_prefix">prefix</code></td>
<td>
<p>string or vector, hospital ID from where the MRNs are from. Defaults to <em>MGH</em>. If a vector is provided then it must be the same length as <em>v</em>.
This allows to potentially use different prefixes for different IDs using the same vector of values.</p>
</td></tr>
<tr><td><code id="pretty_mrn_+3A_sep">sep</code></td>
<td>
<p>string, divider between hospital ID and MRN. Defaults to <em>:</em>.</p>
</td></tr>
<tr><td><code id="pretty_mrn_+3A_id_length">id_length</code></td>
<td>
<p>string, indicating whether to modify MRN length based-on required values <em>id_length = standard</em>, or to keep lengths as is <em>id_length = asis</em>.
If <em>id_length = standard</em> then in case of <em>MGH, BWH, MCL, EMPI and PMRN</em> the length of the MRNs are corrected accordingly by adding zeros, or removing numeral from the beginning.
In other cases the lengths are unchanged. Defaults to <em>standard</em>.</p>
</td></tr>
<tr><td><code id="pretty_mrn_+3A_nthread">nThread</code></td>
<td>
<p>integer, number of threads to use by <em>dopar</em> for parallelization. If it is set to 1, then no parallel backends are created and the function is executed sequentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, with characters formatted to specified lengths. If length of the ID does not match the required length, then leading zeros are added to the ID.
If the ID is longer then the required length, then numerals from the beginning of the ID are cut off until it is the required length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mrns &lt;- sample(1e4:1e7, size = 10) #Simulate MRNs

#MGH format
pretty_mrn(v = mrns, prefix = "MGH")

#BWH format
pretty_mrn(v = mrns, prefix = "BWH")

#Multiple sources using space as a separator
pretty_mrn(v = mrns[1:3], prefix = c("MGH", "BWH", "EMPI"), sep = " ")

#Keeping the length of the IDs despite not adhering to the requirements
pretty_mrn(v = mrns, prefix = "EMPI", id_length = "asis")

## End(Not run)
</code></pre>

<hr>
<h2 id='pretty_numbers'>Converts numerical codes to universal format specified by length.</h2><span id='topic+pretty_numbers'></span>

<h3>Description</h3>

<p>Creates numerical strings with given lengths by removing additional characters from the back and adding leading zeros if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_numbers(v, length_final = 5, remove_from_back = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_numbers_+3A_v">v</code></td>
<td>
<p>vector, integer or sting vector with numerical values.</p>
</td></tr>
<tr><td><code id="pretty_numbers_+3A_length_final">length_final</code></td>
<td>
<p>numeric, the length of the final string. Defaults to <em>5</em> for zip code conversions.</p>
</td></tr>
<tr><td><code id="pretty_numbers_+3A_remove_from_back">remove_from_back</code></td>
<td>
<p>numeric, the number of digits to remove from the back of the string. If <em>NULL</em>, then removes characters from back more than specified in <em>length_final</em>.
Defaults to <em>4</em> for zip code conversions by removing the add-on codes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, with characters formatted accordingly.
</p>

<hr>
<h2 id='pretty_text'>Removes spaces, special characters and capitals from string vector.</h2><span id='topic+pretty_text'></span>

<h3>Description</h3>

<p>Removes paces, special characters and capitals from string vector and converts unknowns to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_text(
  v,
  remove_after = FALSE,
  remove_punc = FALSE,
  remove_white = FALSE,
  add_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_text_+3A_v">v</code></td>
<td>
<p>vector, integer or sting vector with numerical values.</p>
</td></tr>
<tr><td><code id="pretty_text_+3A_remove_after">remove_after</code></td>
<td>
<p>boolean whether to remove text after <em>-</em>. Defaults to <em>FALSE</em>.</p>
</td></tr>
<tr><td><code id="pretty_text_+3A_remove_punc">remove_punc</code></td>
<td>
<p>boolean, whether to remove punctuation marks. Defaults to <em>FALSE</em>.</p>
</td></tr>
<tr><td><code id="pretty_text_+3A_remove_white">remove_white</code></td>
<td>
<p>boolean, whether to remove white spaces. Defaults to <em>FALSE</em>.</p>
</td></tr>
<tr><td><code id="pretty_text_+3A_add_na">add_na</code></td>
<td>
<p>boolean, whether to change text indicating NA to NA values in R. Defaults to <em>TRUE</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, with characters formatted accordingly.
</p>

<hr>
<h2 id='remove_column'>Delete columns with all NA or all identical data.</h2><span id='topic+remove_column'></span>

<h3>Description</h3>

<p>Delete columns where all data elements are NA or the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_column(dt, na = TRUE, identical = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_column_+3A_dt">dt</code></td>
<td>
<p>data.table, to manipulate.</p>
</td></tr>
<tr><td><code id="remove_column_+3A_na">na</code></td>
<td>
<p>boolean, to delete columns where all data elements are NA.</p>
</td></tr>
<tr><td><code id="remove_column_+3A_identical">identical</code></td>
<td>
<p>boolean, to delete columns where all data elements are the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data table, with data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
