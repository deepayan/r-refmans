<!DOCTYPE html><html lang="en"><head><title>Help for package epicmodel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epicmodel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#epicmodel-package'><p>epicmodel: Causal Modeling in Epidemiology</p></a></li>
<li><a href='#are_sufficient'><p>Check if a certain set of component causes is suffcient</p></a></li>
<li><a href='#check_steplist'><p>Check <code>epicmodel_steplist</code> class objects</p></a></li>
<li><a href='#create_scc'><p>Creating SCC models</p></a></li>
<li><a href='#effect_size'><p>Determine standardized effect size of component causes</p></a></li>
<li><a href='#export_mechanism'><p>Export mechanisms</p></a></li>
<li><a href='#intervene'><p>Explore effect of interventions</p></a></li>
<li><a href='#launch_steplist_creator'><p>Launch steplist creator <code>shiny</code> app</p></a></li>
<li><a href='#mechanism'><p>Investigate mechanisms</p></a></li>
<li><a href='#necessary_causes'><p>Extract necessary causes</p></a></li>
<li><a href='#new_scc'><p>SCC model objects</p></a></li>
<li><a href='#new_steplist'><p>Steplist objects</p></a></li>
<li><a href='#plot_dag'><p>Plot DAG</p></a></li>
<li><a href='#prevent'><p>Explore effect of prevention</p></a></li>
<li><a href='#remove_all_modules'><p>Remove all modules</p></a></li>
<li><a href='#remove_na'><p>Removing NA in <code>icc</code> and <code>outc</code></p></a></li>
<li><a href='#remove_segment'><p>Remove segments</p></a></li>
<li><a href='#sc_contain_steps'><p>Do steps appear in sufficient causes?</p></a></li>
<li><a href='#scc_cause_sets'><p>Extracting component causes from SCC model</p></a></li>
<li><a href='#scc_rain'><p>Rain example SCC model</p></a></li>
<li><a href='#scc_to_dag'><p>Transform SCC to DAG</p></a></li>
<li><a href='#show_steps'><p>Show all steps of a SCC model</p></a></li>
<li><a href='#steplist_party'><p>Birthday party example steplist</p></a></li>
<li><a href='#steplist_rain'><p>Rain example steplist</p></a></li>
<li><a href='#uncheck_steplist'><p>Unchecking <code>epicmodel_steplist</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Causal Modeling in Epidemiology</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Create causal models for use in epidemiological studies, 
    including sufficient-component cause models as introduced by 
    Rothman (1976) &lt;<a href="https://doi.org/10.1093%2Foxfordjournals.aje.a112335">doi:10.1093/oxfordjournals.aje.a112335</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, dagitty, DiagrammeR, dplyr, DT, ggplot2,
gtools, methods, prompter, purrr, rlang, shiny, shinyalert,
shinyjs, shinythemes, spsUtil, stringr, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggdag, ggforce, ggraph, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), magrittr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://forsterepi.github.io/epicmodel/">https://forsterepi.github.io/epicmodel/</a>,
<a href="https://github.com/forsterepi/epicmodel">https://github.com/forsterepi/epicmodel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/forsterepi/epicmodel/issues">https://github.com/forsterepi/epicmodel/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-11 18:50:38 UTC; ffors</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Forster <a href="https://orcid.org/0000-0002-3670-9244"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Forster &lt;felix.forster@med.uni-muenchen.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-11 19:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='epicmodel-package'>epicmodel: Causal Modeling in Epidemiology</h2><span id='topic+epicmodel'></span><span id='topic+epicmodel-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Create causal models for use in epidemiological studies, including sufficient-component cause models as introduced by Rothman (1976) <a href="https://doi.org/10.1093/oxfordjournals.aje.a112335">doi:10.1093/oxfordjournals.aje.a112335</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Felix Forster <a href="mailto:felix.forster@med.uni-muenchen.de">felix.forster@med.uni-muenchen.de</a> (<a href="https://orcid.org/0000-0002-3670-9244">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://forsterepi.github.io/epicmodel/">https://forsterepi.github.io/epicmodel/</a>
</p>
</li>
<li> <p><a href="https://github.com/forsterepi/epicmodel">https://github.com/forsterepi/epicmodel</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/forsterepi/epicmodel/issues">https://github.com/forsterepi/epicmodel/issues</a>
</p>
</li></ul>


<hr>
<h2 id='are_sufficient'>Check if a certain set of component causes is suffcient</h2><span id='topic+are_sufficient'></span>

<h3>Description</h3>

<p>Provide a SCC model and a set of component causes and evaluate if the provided set of causes fulfills any sufficient cause, i.e., is sufficient
for the outcome to occur based on the provided SCC model. Fulfilling a sufficient cause means that all component causes of a certain sufficient
cause are in the provided set of causes. Unknown causes are ignored by this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_sufficient(scc, causes = NULL, type = c("status", "binary"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="are_sufficient_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="are_sufficient_+3A_causes">causes</code></td>
<td>
<p>NULL (default) or a character vector containing IDs of a set of component causes. If NULL, prints a list of all available
component causes.</p>
</td></tr>
<tr><td><code id="are_sufficient_+3A_type">type</code></td>
<td>
<p>Either &quot;status&quot; (default) or &quot;binary&quot;. If &quot;status&quot;, returns one of &quot;always&quot;, &quot;depends&quot;, &quot;never&quot;. If &quot;binary&quot;, returns TRUE or FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the value of <code>type</code>, the following values are possible:
</p>

<ul>
<li> <p><code>type = "status"</code>: If the provided set of <code>causes</code> contains all component causes of a sufficient cause with status &quot;always&quot;, returns &quot;always&quot;.
If the provided set of <code>causes</code> only fulfills sufficient cause with status &quot;depends&quot; or &quot;depends (potential order implausibilities)&quot;, returns
&quot;depends&quot;. If no sufficient causes are fulfilled, returns &quot;never&quot;.
</p>
</li>
<li> <p><code>type = "binary"</code>: If the returned status would have been &quot;always&quot; or &quot;depends&quot;, TRUE is returned. If the returned status would have been
&quot;never&quot;, returns FALSE.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code style="white-space: pre;">&#8288;type = "binary&#8288;</code>, returns TRUE if all component causes for at least one sufficient cause are in <code>causes</code> and FALSE otherwise. For
<code>type = status</code>, returns &quot;always&quot; if at least one sufficient cause with sufficiency status &quot;always&quot; is fulfilled. If not, returns &quot;depends&quot; if
at least one sufficient cause with sufficiency status &quot;depends&quot; or &quot;depends (potential order implausibilities)&quot; is fulfilled. If no sufficient
cause is fulfilled, returns &quot;never&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Check sufficiency for a certain set of component causes
are_sufficient(scc_model, c("THENa1","THENa5"), type = "status")
are_sufficient(scc_model, c("THENa1","THENa5"), type = "binary")
</code></pre>

<hr>
<h2 id='check_steplist'>Check <code>epicmodel_steplist</code> class objects</h2><span id='topic+check_steplist'></span>

<h3>Description</h3>

<p>Check if <code>epicmodel_steplist</code> class objects fulfill the conditions for being inputed in <code><a href="#topic+create_scc">create_scc()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_steplist(steplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_steplist_+3A_steplist">steplist</code></td>
<td>
<p>An object of class <code>epicmodel_steplist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following checks are conducted:
</p>


<h4>Errors</h4>


<ul>
<li><p> Correct ID format in WHAT segments
</p>
</li>
<li><p> No duplicated IDs in WHAT segments
</p>
</li>
<li><p> Correct ID format in DOES segments
</p>
</li>
<li><p> No duplicated IDs in DOES segments
</p>
</li>
<li><p> Correct ID format in WHERE segments
</p>
</li>
<li><p> No duplicated IDs in WHERE segments
</p>
</li>
<li><p> Correct ID format in Modules
</p>
</li>
<li><p> No duplicated IDs in Modules
</p>
</li>
<li><p> Correct ID format in ICC
</p>
</li>
<li><p> No duplicated IDs in ICC
</p>
</li>
<li><p> All WHAT segments used in data.frame <code>step</code> must be listed in data.frame <code>what</code>
</p>
</li>
<li><p> All DOES segments used in data.frame <code>step</code> must be listed in data.frame <code>does</code>
</p>
</li>
<li><p> All WHERE segments used in data.frame <code>step</code> must be listed in data.frame <code>where</code>
</p>
</li>
<li><p> All modules used in data.frame <code>step</code> must be listed in data.frame <code>modules</code>
</p>
</li>
<li><p> Either all steps or no steps have modules specified in data.frame <code>step</code>
</p>
</li>
<li><p> All step IDs used in ICC definition must be specified in data.frame <code>step</code>
</p>
</li>
<li><p> Starting steps, i.e., steps without IF condition, must not have <code>end_step == 1</code> in data.frame <code>step</code>
</p>
</li>
<li><p> A steplist must contain component causes
</p>
</li>
<li><p> In case there are two steps with identical THEN statements, they cannot have both <code>end_step == 1</code> and <code>end_step == 0</code> in data.frame <code>step</code>
</p>
</li>
<li><p> THEN statements used in IF/IFNOT conditions must be available for chaining, i.e., there must be a step with this statement as its THEN part
and this step must not be defined as end step
</p>
</li>
<li><p> For all steps, their THEN statement must be available in data.frame <code>then</code>
</p>
</li>
<li><p> A step must not have identical IF and IFNOT conditions
</p>
</li>
<li><p> A step’s THEN statement must not be part of its own IF/IFNOT condition
</p>
</li>
<li><p> All steps used in the outcome definition must be in data.frame <code>step</code> with <code>end_step == 1</code>
</p>
</li></ul>




<h4>Warnings</h4>


<ul>
<li><p> No duplicated keywords in WHAT segments
</p>
</li>
<li><p> No duplicated keywords in DOES segments
</p>
</li>
<li><p> No duplicated keywords in WHERE segments
</p>
</li>
<li><p> No duplicated keywords in Modules
</p>
</li>
<li><p> All WHAT segments in data.frame <code>what</code> should be used in data.frame <code>step</code>
</p>
</li>
<li><p> All DOES segments in data.frame <code>does</code> should be used in data.frame <code>step</code>
</p>
</li>
<li><p> All WHERE segments in data.frame <code>where</code> should be used in data.frame <code>step</code>
</p>
</li>
<li><p> All modules in data.frame <code>modules</code> should be used in data.frame <code>step</code>
</p>
</li>
<li><p> All steps should have references
</p>
</li>
<li><p> There should not be any steps with identical THEN statements
</p>
</li>
<li><p> All steps with <code>end_step == 1</code>in data.frame <code>step</code> should be used in the outcome definition
</p>
</li>
<li><p> Outcome definitions should not be contained in each other, e.g., for outcome definition <code style="white-space: pre;">&#8288;(A and B) or (A and B and C)&#8288;</code>, <code style="white-space: pre;">&#8288;A and B&#8288;</code> is contained,
i.e., a subset of, <code style="white-space: pre;">&#8288;A and B and C&#8288;</code>, which makes <code style="white-space: pre;">&#8288;A and B and C&#8288;</code> redundant
</p>
</li></ul>




<h3>Value</h3>

<p>Prints information about successful and unsuccessful checks in the console. Returns the input steplist. If checks were successful,
returns a steplist of class <code>epicmodel_steplist_checked</code> that can be used in building SCC models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>steplist_checked &lt;- check_steplist(steplist_rain)
</code></pre>

<hr>
<h2 id='create_scc'>Creating SCC models</h2><span id='topic+create_scc'></span>

<h3>Description</h3>

<p>Creates a sufficient-components cause (SCC) model from a steplist, which is a list of IF/THEN statements describing the causal mechanism behind
an outcome of interest. The steplist needs to meet certain structural requirements. Therefore, for steplist creation, use the Steplist Creator
<code>shiny</code> app launched by <code><a href="#topic+launch_steplist_creator">launch_steplist_creator()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_scc(steplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_scc_+3A_steplist">steplist</code></td>
<td>
<p>An object of class <code>epicmodel_steplist_checked</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following algorithm is used to create a sufficient-component cause (SCC) model from a steplist.
</p>

<ul>
<li><p> Check inputs: The steplist needs to be checked by <code><a href="#topic+check_steplist">check_steplist()</a></code> before input
</p>
</li>
<li><p> Are modules used: Evaluate if the steplist contains modules
</p>
</li>
<li><p> Process steplist: Process steplist and outcome definition so that they can be used by the procedure
</p>
</li>
<li><p> Get all combinations of component causes in the steplist: Component causes are steps, which themselves have no IF condition but appear
in IF conditions of other steps (and maybe additionally in IFNOT conditions). Interventions are not considered to be component causes.
Interventions are as well steps without IF condition, but they only appear in IFNOT conditions of other steps. Invalid combinations of
component causes as specified in the ICC part of the steplist are excluded, as well as every component cause being absent.
</p>
</li>
<li><p> Check sufficiency: Sufficiency is checked for every combination of component causes. First, based on a specific set of component causes,
it is derived, which steps can be caused by this set, i.e., which IF conditions are fulfilled. For this, a current set of included steps is
defined, which in the beginning includes only the corresponding set of component causes. Then, it is iteratively checked, for which other
steps with IF condition (i.e., excluding non-selected component causes and interventions) this IF condition is fulfilled. These steps are
added to the current set of included steps and the process is repeated until for no new steps the IF condition is fulfilled. Second, this
final list of steps is compared against the outcome definitions. If it is fulfilled, the set of component causes is sufficient.
</p>
</li>
<li><p> Check IFNOT conditions: Please note that IFNOT conditions were ignored up to this point. Now, all sets of component causes that were found
to be sufficient previously, are re-checked for IFNOT conditions. First, it is checked if there are any IFNOT conditions in the final list of
steps derived above and if those are fulfilled based only on the other steps in this list. If no, checking is complete and the corresponding
set of component causes is always sufficient. If yes, further checking is required. In these cases, sufficiency depends on the order in which
individual steps occur. In principle, a step with both IF and IFNOT conditions fulfilled, occurs if the IF condition is fulfilled before the
IFNOT condition, similar to how I do not care if a door is closed if I already went through it when it was still open. Please note that this
approach extends SCC models by an additional time component. Sufficiency is therefore re-checked for all possible sequences of IF and IFNOT
conditions of all steps that include IFNOT conditions that can be fulfilled by the final set of steps. It is possible to have component causes
with IFNOT conditions. Since they do not have an IF condition, the THEN statement is used instead. For every sequence, it is evaluated if the
IF (or THEN for component causes) occurs before or after the IFNOT. If IF/THEN occur after the corresponding IFNOT, this step is removed from
the final list of steps. Sufficieny is now re-checked based on the updated list. If some orderings do not fulfill the outcome definition,
the sufficiency status of the corresponding set of component causes is changed to &quot;depends&quot;, as it depends on the sequence of events. Please
note that currently, all sequences are checked even though some of them might be implausible, e.g., when two steps with IFNOT conditions are
chained together. In this case, there will be a warning displayed, but the user ultimately needs to check plausibility of the sequence of
events.
</p>
</li>
<li><p> Minimize: Sufficient causes must be minimal by definition, i.e., every component cause must be necessary within its sufficient cause, i.e.,
the absence of one component cause of a sufficient set means that the outcome does not occur anymore. Therefore, the list of sufficient (both
always and depends) sets of component causes is reduced to minimal ones.
</p>
</li>
<li><p> Add unknown causes: It is possible/likely that unknown causes, both component causes and sufficient causes, are not part of the model yet.
Therefore, every sufficient cause gets an additional individual (i.e., a different one for each sufficient cause) unknown component cause
representing additional unknown components, and one unknown sufficient cause is added to the model consisting of a single unknown component
cause and representing all unknown sufficient causes. If relevant, the user can decide in functions with the SCC model as input if unknown
causes should be included or not.
</p>
</li>
<li><p> Output preparation: Combines all outputs to an object of class <code>epicmodel_scc</code> for further analysis.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>epicmodel_scc</code>. If no sufficient causes are found, no object is returned but instead a corresponding message
is displayed in the console.
</p>


<h3>References</h3>

<p>Rothman KJ (1976): Causes. American Journal of Epidemiology 104 (6): 587–592.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+new_scc">SCC models</a></code> for information on <code>epicmodel_scc</code> objects
</p>
</li>
<li> <p><code><a href="#topic+new_steplist">Steplist</a></code> for information on <code>epicmodel_steplist</code> objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># First, create a steplist in the shiny app
# Launch the app with launch_steplist_creator()
# Then load your steplist using readRDS()
# In this example we use the built-in steplist_rain

# Check the steplist before running create_scc()
steplist_checked &lt;- check_steplist(steplist_rain)

# Use the checked steplist in create_scc()
scc_model &lt;- create_scc(steplist_checked)
</code></pre>

<hr>
<h2 id='effect_size'>Determine standardized effect size of component causes</h2><span id='topic+effect_size'></span>

<h3>Description</h3>

<p>SCC models teach us that effect strength, e.g., a risk ratio, is no natural constant but depends on the prevalence of component causes and,
therefore, differs between populations. However, even without any population, this function derives effect sizes for every component cause by
comparing how many sets of component causes with and without a certain cause are sufficient to cause the outcome of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_size(scc, depends = TRUE, output = c("nice", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_size_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="effect_size_+3A_depends">depends</code></td>
<td>
<p>TRUE (default) or FALSE. If FALSE, only includes sufficient causes with suffciency status &quot;always&quot;.</p>
</td></tr>
<tr><td><code id="effect_size_+3A_output">output</code></td>
<td>
<p>A single element of type character, either &quot;nice&quot; (default) or &quot;table&quot;. If &quot;table&quot;, returns a data.frame. If &quot;nice&quot;, a nicely
formated output is printed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following algorithm is used to derive effect sizes from SCC models:
</p>

<ul>
<li><p> The effect size is derived for one specific component cause. The following steps are repeated for all of them.
</p>
</li>
<li><p> Get all potential combinations of component causes
</p>
</li>
<li><p> Remove combinations that contain incompatible component causes (ICC), as specified in the steplist
</p>
</li>
<li><p> Split the set of possible combinations of component causes into two parts: Sets, in which the component cause of interest is present &amp; sets,
in which the component cause of interest is absent. The numbers are recorded and returned in the output table (output = &quot;table&quot;) as variables
<code>num_combos_true</code> (cause is present) and <code>num_combos_false</code> (cause is absent). If there are no incompatible component causes (ICC), both
values should be the same.
</p>
</li>
<li><p> Check for all possible combinations of component causes, if they are sufficient for the outcome to occur. The number of sufficient combinations
are counted separately for combinations with the component cause of interest present and combinations with the component cause of interest
absent. The numbers are recorded and returned in the output table (output = &quot;table&quot;) as variables <code>suff_true</code> (cause is present) and
<code>suff_false</code> (cause is absent).
</p>
</li>
<li><p> A ratio is calculated using the following formula: <code>(suff_true / num_combos_true) / (suff_false / num_combos_false)</code>. In the output table
(output = &quot;table&quot;), this value is stored in variable <code>ratio</code>. In the nice output (output = &quot;nice&quot;), it is reported in the column <code>Impact</code>,
which shows: <code style="white-space: pre;">&#8288;ratio [suff_true/num_combos_true vs. suff_false/num_combos_false]&#8288;</code>
</p>
</li>
<li><p> There are two special cases when calculating the <code>ratio</code>. When <code>suff_true &gt; 0</code> but <code>suff_false == 0</code>, the outcome only occurs if the
corresponding component cause is present. The <code>ratio</code> then gets value <code>necessary</code>. When <code>suff_true == 0</code> and <code>suff_false == 0</code>, the <code>ratio</code>
gets value <code style="white-space: pre;">&#8288;not a cause&#8288;</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Either a dataframe (<code>output</code> = &quot;table&quot;) with one row for every component cause and with variables <code>id</code> (step ID), <code>desc</code> (step
description), <code>suff_true</code>, <code>suff_false</code>, <code>num_combos_true</code>, <code>num_combos_false</code>, and <code>ratio</code>, or a nicely formated output in the console
(<code>output</code> = &quot;nice&quot;). See Details for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Use the SCC model in effect_size()
effect_size(scc_model)
</code></pre>

<hr>
<h2 id='export_mechanism'>Export mechanisms</h2><span id='topic+export_mechanism'></span>

<h3>Description</h3>

<p>Exports one or all sufficient cause mechanisms as PNG, PDF, SVG, or PostScript using <code>DiagrammeR::export_graph()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_mechanism(
  mechanism,
  sc = NULL,
  file_name = NULL,
  file_type = "png",
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_mechanism_+3A_mechanism">mechanism</code></td>
<td>
<p>An object of class <code>epicmodel_mechanism</code>.</p>
</td></tr>
<tr><td><code id="export_mechanism_+3A_sc">sc</code></td>
<td>
<p>A single integer value (can be specified as numeric, e.g., 2 instead of 2L). If provided, a graph is only exported for the specified
sufficient cause, e.g., for SC2 if sc = 2. If sc = NULL (default), graphs for all sufficient causes are exported.</p>
</td></tr>
<tr><td><code id="export_mechanism_+3A_file_name">file_name</code></td>
<td>
<p>The name of the exported file (including it's extension).</p>
</td></tr>
<tr><td><code id="export_mechanism_+3A_file_type">file_type</code></td>
<td>
<p>The type of file to be exported. Options for graph files
are: <code>png</code>, <code>pdf</code>, <code>svg</code>, and <code>ps</code>.</p>
</td></tr>
<tr><td><code id="export_mechanism_+3A_title">title</code></td>
<td>
<p>An optional title for the output graph.</p>
</td></tr>
<tr><td><code id="export_mechanism_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="DiagrammeR.html#topic+export_graph">DiagrammeR::export_graph</a></code>
</p>

<dl>
<dt><code>width</code></dt><dd><p>Output width in pixels or <code>NULL</code> for default. Only useful for
export to image file formats <code>png</code>, <code>pdf</code>, <code>svg</code>, and <code>ps</code>.</p>
</dd>
<dt><code>height</code></dt><dd><p>Output height in pixels or <code>NULL</code> for default. Only useful for
export to image file formats <code>png</code>, <code>pdf</code>, <code>svg</code>, and <code>ps</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Saves the mechanisms as PNG, PDF, SVG, or PostScript.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="DiagrammeR.html#topic+export_graph">DiagrammeR::export_graph()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mechanism">mechanism()</a></code> for information on sufficient cause mechanisms
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Derive mechanisms
mech &lt;- mechanism(scc_rain)

# Export mechanism plot of sufficient cause (sc) 1
if(interactive()){
tmp &lt;- tempfile(fileext = ".png")
export_mechanism(mech, sc = 1, file_name = tmp, title = "Sufficient Cause 1")
unlink(tmp) # delete saved file
}
</code></pre>

<hr>
<h2 id='intervene'>Explore effect of interventions</h2><span id='topic+intervene'></span>

<h3>Description</h3>

<p>Interventions are steps without IF condition (start steps) that only appear in other IFNOT conditions, i.e., that can only prevent steps but not
cause them. Interventions are not considered when creating SCC models using <code><a href="#topic+create_scc">create_scc()</a></code>. <code>intervene()</code> evaluates their impact in two
directions: 1) which sufficient causes can be prevented by certain (sets of) interventions and 2) which set of interventions is at least needed
to prevent the outcome in an individual with a given set of component causes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervene(scc, causes = NULL, intervention = NULL, output = c("nice", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intervene_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="intervene_+3A_causes">causes</code></td>
<td>
<p>A character vector containing step IDs of component causes. If &quot;all&quot;, investigates all sufficient causes, i.e., all minimally
sufficient sets of component causes. If NULL (default), prints a list of all available component causes in the console. If a set of step IDs is
specified, only the specified set is investigated.</p>
</td></tr>
<tr><td><code id="intervene_+3A_intervention">intervention</code></td>
<td>
<p>A character vector containing step IDs of interventions. If &quot;all&quot;, investigates all possible combinations of available
interventions. If NULL (default), prints a list of all available interventions in the console. If a set of step IDs is specified, investigates
all possible combinations of the specified interventions.</p>
</td></tr>
<tr><td><code id="intervene_+3A_output">output</code></td>
<td>
<p>Either &quot;nice&quot; (default) or &quot;table&quot;. If &quot;nice&quot;, prints a nicely formatted summary in the console. If &quot;table&quot;, returns a list of
several elements described in detail in section &quot;Value&quot; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following algorithm is used to evaluate the effect of interventions:
</p>

<ul>
<li><p> Derive the list of intervention sets to evaluate
</p>
</li>
<li><p> Derive the list of sets of component causes to evaluate
</p>
</li>
<li><p> Evaluate sufficiency without intervention for every set of component causes
</p>
</li>
<li><p> Evaluate sufficiency for every combination of intervention set and set of componen causes: First, check which steps are prevented by the
corresponding set of interventions, i.e., for which steps the IFNOT condition is fulfilled by the intervention set. These steps are removed
from the list of available steps. Second, evaluate sufficiency based on the remaining steps similar to <code><a href="#topic+create_scc">create_scc()</a></code> (Check sufficiency &amp;
Check IFNOT conditions).
</p>
</li>
<li><p> Evaluate, which intervention sets are minimal, i.e., at least necessary to prevent the outcome
</p>
</li></ul>



<h3>Value</h3>



<h4>Output</h4>

<p>If <code>output = "nice"</code> (default), prints a nicely formatted output in the console. If <code>output = "table"</code>, returns a list with the following
elements:
</p>

<dl>
<dt><code>cause_set</code></dt><dd><p>A list of character vectors with one element for every investigated set of component causes. The character vectors contain the
step IDs of the component causes that are part of the corresponding set. Sets are named in a format similar to cc1, cc2, etc.</p>
</dd>
<dt><code>intv</code></dt><dd><p>A list of character vectors with one element for every investigated set of interventions. The character vectors contain the step IDs of
the interventions that are part of the corresponding set. Sets are named as intv1, intv2, etc.</p>
</dd>
<dt><code>status</code></dt><dd><p>A data.frame with one row per set of component causes and one column per set of intervention. In addition, contains one column
representing no interventions (<code>intv0</code>). Each cell contains the sufficiency status of the corresponding set of component causes when the
corresponding set of interventions is applied. Possible values are &quot;always&quot;, &quot;depends&quot;, and &quot;never&quot;. See below for an interpretation.</p>
</dd>
<dt><code>minimal</code></dt><dd><p>A data.frame with one row per set of component causes and one column per set of intervention. Each cell is either TRUE or FALSE
indicating if the set of interventions is minimal. For non-minimal sets of interventions, a smaller set which is contained within the
corresponding set exists and has the same preventive power. Minimality is defined separately for every set of component causes. If both the
larger non-minimal and the smaller minimal set sometimes prevent the outcome (status &quot;depends&quot; in <code>status</code> (see above)), the non-minimal set
might actually prevent more sufficient orders of occurrence than the minimal set. In this case, please inspect and compare element <code>order</code>
(see next), for all minimal and non-minimal sets of interventions with status &quot;depends&quot;.</p>
</dd>
<dt><code>order</code></dt><dd><p>A 2-level list, i.e., a list with one element per intervention set, for which each element is another list with one element per
evaluated set of component causes. Each intervention/component causes combination contains a data.frame, similar to the data.frames in the
<code>sc_order</code> element of <code>epicmodel_scc</code> objects, if the corresponding status is &quot;depends&quot;, or is NA otherwise (for &quot;always&quot; or
&quot;never&quot;). The data.frames contain two columns, which are called &quot;order&quot; and &quot;suff&quot; (short for &quot;sufficient&quot;), and one row for every order of
occurrence. The order of occurrence is summarized in &quot;order&quot; (as character), while &quot;suff&quot; is either TRUE or FALSE indicating if the
corresponding order of occurrence is sufficient, i.e., leads to the outcome, or not. Please note that the prevented orders of occurrence
have <code>suff == FALSE</code>.</p>
</dd>
</dl>




<h4>How to interpret <code>status</code></h4>

<p>If the sufficiency status for a certain intervention in column <code>intv0</code> is <code>always</code>, the three sufficiency status options for a certain
intervention have the following interpretations:
</p>

<ul>
<li> <p><code>always</code>: The corresponding set of inteventions never prevents the outcome, because after applying the intervention, the corresponding set of
component causes is still always sufficient.
</p>
</li>
<li> <p><code>depends</code>: The corresponding set of interventions sometimes prevents the outcome, because after applying the intervention, sufficiency for the
corresponding set of component causes depends on the order of occurrence.
</p>
</li>
<li> <p><code>never</code>: The corresponding set of interventions always prevents the outcome, because after applying the intervention, the corresponding set of
component causes is never sufficient.
</p>
</li></ul>

<p>If the sufficiency status for a certain intervention in column <code>intv0</code> is <code>depends</code>, the sufficiency status options for a certain
intervention have the following interpretations:
</p>

<ul>
<li> <p><code>depends</code>: The corresponding set of interventions sometimes or never prevents the outcome, because after applying the intervention,
sufficiency for the corresponding set of component causes depends on the order of occurrence. Further inspection and comparison
of sufficient orders of occurrence is necessary to determine if the intervention actually prevents anything.
</p>
</li>
<li> <p><code>never</code>: The corresponding set of interventions always prevents the outcome, because after applying the intervention, the corresponding set of
component causes is never sufficient.
</p>
</li></ul>

<p>If the sufficiency status for a certain intervention in column <code>intv0</code> is <code>never</code>, no intervention is necessary, because the corresponding set of
component causes is never sufficient.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># Derive SCC model
scc_model &lt;- scc_rain

# Inspect the effect of interventions
intervene(scc_model, causes = "all", intervention = "all")
intv &lt;- intervene(scc_model, causes = "all", intervention = "all", output = "table")
</code></pre>

<hr>
<h2 id='launch_steplist_creator'>Launch steplist creator <code>shiny</code> app</h2><span id='topic+launch_steplist_creator'></span>

<h3>Description</h3>

<p>Run this function to start the Steplist Creator <code>shiny</code> app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_steplist_creator()
</code></pre>


<h3>Value</h3>

<p>The <code>launch_steplist_creator</code> function is used for the side effect of starting the Steplist Creator <code>shiny</code> app.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
launch_steplist_creator()
}
</code></pre>

<hr>
<h2 id='mechanism'>Investigate mechanisms</h2><span id='topic+mechanism'></span><span id='topic+new_mechanism'></span><span id='topic+validate_mechanism'></span><span id='topic+plot.epicmodel_mechanism'></span><span id='topic+print.epicmodel_mechanism'></span>

<h3>Description</h3>

<p>Creates graphs that visiualize the mechanisms behind each sufficient cause using the <code>DiagrammeR</code> package.
</p>
<p><code>new_mechanism()</code> and <code>validate_mechanism()</code> define the <code>epicmodel_mechanism</code> S3 class, which is created by <code>mechanism()</code>.
</p>
<p><code>plot()</code> renders the graphs in the RStudio Viewer.
</p>
<p><code>print()</code> prints the legend for node labels in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mechanism(scc, modules = TRUE, module_colors = NULL)

new_mechanism(x = list())

validate_mechanism(x)

## S3 method for class 'epicmodel_mechanism'
plot(x, reverse = TRUE, ...)

## S3 method for class 'epicmodel_mechanism'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mechanism_+3A_scc">scc</code></td>
<td>
<p>For <code>mechanism()</code>, an object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="mechanism_+3A_modules">modules</code></td>
<td>
<p>For <code>mechanism()</code>, TRUE (default) or FALSE, indicating if nodes in the same module should be colored equally (TRUE) or if all
nodes have white background (FALSE). Colors are only applied, if modules have actually been specified in the <code>epicmodel_steplist</code>. If modules
are considered by <code>mechanism()</code>, the module keywords are added to the legend (accessable via <code>print()</code>).</p>
</td></tr>
<tr><td><code id="mechanism_+3A_module_colors">module_colors</code></td>
<td>
<p>For <code>mechanism()</code>, if nodes are colored by module, colors can be provided via this argument. Colors must be provided as a
character vector. Both named colors and hexadecimal color codes are allowed. The function has 8 colors stored internally.
If <code>module_colors</code> = NULL (default), these colors are used. If the model has more than 8 modules, <code>module_colors</code> must be specified. If more
colors than necessary are specified, the function takes as many as necessary from the start of the vector.</p>
</td></tr>
<tr><td><code id="mechanism_+3A_x">x</code></td>
<td>
<p><code>x</code> is used in several functions:
</p>

<ul>
<li> <p><code>new_mechanism()</code>: A list to be converted to class <code>epicmodel_mechanism</code>.
</p>
</li>
<li> <p><code>validate_mechanism()</code>: An object of class <code>epicmodel_mechanism</code> to be validated.
</p>
</li>
<li> <p><code>plot.epicmodel_mechanism()</code>: An object of class <code>epicmodel_mechanism</code>.
</p>
</li>
<li> <p><code>print.epicmodel_mechanism()</code>: An object of class <code>epicmodel_mechanism</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mechanism_+3A_reverse">reverse</code></td>
<td>
<p>For <code>plot.epicmodel_mechanism()</code>, TRUE or FALSE indicating if the output should be displayed in reverse order. Since graphs
rendered later show up first in the viewer pane, reverse = T leads to SC1 being the last rendered and the one displayed on top.</p>
</td></tr>
<tr><td><code id="mechanism_+3A_...">...</code></td>
<td>
<p>Additional arguments for generics <code>print()</code> and <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>The graphs</h4>

<p>One graph per sufficient cause is created. The graphs display steps as nodes and IF/IFNOT relations as edges. Nodes will not be
labeled with their IDs or descriptions due to limited space, but with newly created labels. These labels are based on the type of node and are
listed together with the step description in the <code>legend</code> (accessed by <code>print()</code>). Step descriptions are also accessible via tooltips in the
graph. Just put your cursor on the node labels.
</p>
<p>There are 4 different types of nodes:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Component causes&#8288;</code>: Labeled <code>"CC"</code>, squares, gray border
</p>
</li>
<li> <p><code>Interventions</code>: Labeled <code>"I"</code>, triangles, gray border
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;End steps&#8288;</code>: Labeled <code>"E"</code>, circles, black border
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Other steps&#8288;</code>: Labeled <code>"S"</code>, circles, gray border
</p>
</li></ul>

<p>There are 2 types of edges:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;IF conditions&#8288;</code>: gray arrows
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;IFNOT conditions&#8288;</code>: red and T-shaped
</p>
</li></ul>




<h4><code>epicmodel_mechanism</code> objects</h4>

<p><code>epicmodel_mechanism</code> objects are created by <code>mechanism()</code>. They are lists containing 2 elements:
</p>

<dl>
<dt><code>legend</code></dt><dd><p>A data.frame with up to 3 variables:
</p>

<ul>
<li> <p><code>Label</code>: Contains the labels used in the graphs.
</p>
</li>
<li> <p><code>Module</code>: Contains the name of the module to which this step belongs. Only available if <code>modules = TRUE</code> in <code>mechanism()</code> and if the SCC
model actually uses modules (specified in element <code>sc_use_modules</code> of <code>epicmodel_scc</code> objects).
</p>
</li>
<li> <p><code>Step</code>: A description of the corresponding step.</p>
</li></ul>

</dd>
<dt><code>graph</code></dt><dd><p>A list of length equal to the number of sufficient causes. Each element contains another list with 2 elements:
</p>

<ul>
<li> <p><code>ndf</code>: A data.frame containing information about nodes in the graph (see <code><a href="DiagrammeR.html#topic+node_aes">DiagrammeR::node_aes()</a></code>).
</p>
</li>
<li> <p><code>edf</code>: A data.frame containing information about edges in the graph (see <code><a href="DiagrammeR.html#topic+edge_aes">DiagrammeR::edge_aes()</a></code>).</p>
</li></ul>

</dd>
<dt><code>ndf</code></dt><dd><p>Data.frames containing the following variables:
</p>

<ul>
<li> <p><code>id</code>: Node ID used internally by <code>DiagrammeR</code> to define edges (<code>from</code> and <code>to</code> in <code>edf</code> data.frames).
</p>
</li>
<li> <p><code>type</code>: Type of node as defined by <code>epicmodel</code>. Possible options are: <code>cc</code> (component cause), <code>int</code> (intervention), <code>end</code> (step that is part
of an outcome definition), <code>other</code> (all other steps).
</p>
</li>
<li> <p><code>label</code>: The label displayed in the graph and listed in variable <code>Label</code> of <code>legend</code>.
</p>
</li>
<li> <p><code>tooltip</code>: The text displayed when putting the cursor on top of the node label. Corresponds to the step descriptions in variable <code>Step</code> of
<code>legend</code>.
</p>
</li>
<li> <p><code>shape</code>: The shape of the node. <code>square</code> for type <code>cc</code>, <code>triangle</code> for type <code>int</code>, and <code>circle</code> for types <code>end</code> and <code>other</code>.
</p>
</li>
<li> <p><code>color</code>: Color of the node border. Gray for types <code>cc</code>, <code>int</code>, and <code>other</code>, and black for type <code>end</code>.
</p>
</li>
<li> <p><code>fillcolor</code>: Color of the background, which is similar for all steps in the same module. If modules are not considered, <code>fillcolor</code> is white
for all nodes.
</p>
</li>
<li> <p><code>fontcolor</code>: Color of the node label. Always black.</p>
</li></ul>

</dd>
<dt><code>edf</code></dt><dd><p>Data.frames containing the following variables:
</p>

<ul>
<li> <p><code>id</code>: Edge ID used internally by <code>DiagrammeR</code>.
</p>
</li>
<li> <p><code>from</code>: Node ID of the node from which the edge starts.
</p>
</li>
<li> <p><code>to</code>: Node ID of the node at which the edge ends.
</p>
</li>
<li> <p><code>rel</code>: Type of edge as defined by <code>epicmodel</code>. Possible options are: <code>if</code> (<code>from</code> node is in IF condition of <code>to</code> node), <code>ifnot</code> (<code>from</code> node
is in IFNOT condition of <code>to</code> node).
</p>
</li>
<li> <p><code>arrowhead</code>: Type of arrow. <code>normal</code> for rel <code>if</code> and <code>tee</code> for rel <code>ifnot</code>.
</p>
</li>
<li> <p><code>arrowsize</code>: Size of arrow. 1 for rel <code>if</code> and 1.2 for rel <code>ifnot</code>.
</p>
</li>
<li> <p><code>color</code>: Color of arrow. Gray for rel <code>if</code> and <code style="white-space: pre;">&#8288;#A65141&#8288;</code> for rel <code>ifnot</code>.</p>
</li></ul>

</dd>
</dl>




<h3>Value</h3>


<ul>
<li> <p><code>mechanism()</code>: An object of class <code>epicmodel_mechanism</code>. Use <code>plot()</code> to plot the graphs in the RStudio Viewer. Use <code>print()</code> to print the
legend in the console. Use <code><a href="#topic+export_mechanism">export_mechanism()</a></code> to save the graphs as PNG, PDF, SVG, or PostScript.
</p>
</li>
<li> <p><code>new_mechanism()</code>: An object of class <code>epicmodel_mechanism</code>.
</p>
</li>
<li> <p><code>validate_mechanism()</code>: An object of class <code>epicmodel_mechanism</code> that has been checked to have the correct structure.
</p>
</li>
<li> <p><code>plot.epicmodel_mechanism()</code>: Renders the graphs in the RStudio Viewer.
</p>
</li>
<li> <p><code>print.epicmodel_mechanism()</code>: Prints the legend of the <code>epicmodel_mechanism</code> object in the console.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+export_mechanism">export_mechanism()</a></code> for saving the plots
</p>
</li>
<li> <p><code><a href="DiagrammeR.html#topic+node_aes">DiagrammeR::node_aes()</a></code> for a list of node-related variables in <code>DiagrammeR</code>
</p>
</li>
<li> <p><code><a href="DiagrammeR.html#topic+edge_aes">DiagrammeR::edge_aes()</a></code> for a list of edge-related variables in <code>DiagrammeR</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Derive mechanisms
mech &lt;- mechanism(scc_model)

# new_mechanism() and validate_mechanism() are used inside mechanism()
# nonetheless, you can check its structure using validate_mechanism()
validate_mechanism(mech)

# Plot the mechanisms
plot(mech)

# Print the legend
print(mech)
mech

</code></pre>

<hr>
<h2 id='necessary_causes'>Extract necessary causes</h2><span id='topic+necessary_causes'></span>

<h3>Description</h3>

<p>Necessary causes are component causes, which are part of every sufficient cause and, therefore, have to be present in order for the outcome
to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>necessary_causes(scc, output = c("id", "desc", "desc_no_start"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="necessary_causes_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="necessary_causes_+3A_output">output</code></td>
<td>
<p>A single element of type character determining the type of output. Either <code>id</code> (default), <code>desc</code>, or <code>desc_no_start</code>. See
section &quot;Value&quot; below for a description of the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing all necessary causes. Depending on the value of <code>output</code>, the vector contains either step IDs
(<code>output = "id"</code>), step descriptions (<code>output = "desc"</code>), or step descriptions but with the &quot;Start: &quot; in the beginning removed
(<code>output = "desc_no_start"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>necessary_causes(scc_rain)
</code></pre>

<hr>
<h2 id='new_scc'>SCC model objects</h2><span id='topic+new_scc'></span><span id='topic+validate_scc'></span><span id='topic+empty_scc'></span><span id='topic+print.epicmodel_scc'></span><span id='topic+summary.epicmodel_scc'></span><span id='topic+plot.epicmodel_scc'></span>

<h3>Description</h3>

<p>The S3 class <code>epicmodel_scc</code> is used to store information on sufficient-component cause (SCC) models created by <code><a href="#topic+create_scc">create_scc()</a></code>.
</p>
<p><code>new_scc()</code>, <code>validate_scc()</code>, and <code>empty_scc()</code> define the S3 class.
</p>
<p><code>print()</code> prints a summary of SCC models in the console. <code>summary()</code> and <code>print()</code> are identical.
</p>
<p><code>plot()</code> creates the familiar causal pie charts from an object of class <code>epicmodel_scc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_scc(x = list())

validate_scc(x)

empty_scc()

## S3 method for class 'epicmodel_scc'
print(x, ...)

## S3 method for class 'epicmodel_scc'
summary(object, ...)

## S3 method for class 'epicmodel_scc'
plot(
  x,
  remove_sc = NULL,
  sc_label = NULL,
  unknown = TRUE,
  names = TRUE,
  text_color = NULL,
  pie_color = NULL,
  border_color = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_scc_+3A_x">x</code></td>
<td>
<p><code>x</code> is used in several functions:
</p>

<ul>
<li> <p><code>new_scc()</code>: A list to be converted to class <code>epicmodel_scc</code>.
</p>
</li>
<li> <p><code>validate_scc()</code>: An object of class <code>epicmodel_scc</code> to be validated.
</p>
</li>
<li> <p><code>print.epicmodel_scc()</code>: An object of class <code>epicmodel_scc</code>.
</p>
</li>
<li> <p><code>plot.epicmodel_scc()</code>: An object of class <code>epicmodel_scc</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="new_scc_+3A_...">...</code></td>
<td>
<p>Additional arguments for generics <code>print()</code>, <code>summary()</code>, and <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_object">object</code></td>
<td>
<p>For <code>summary.epicmodel_scc()</code>, an object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_remove_sc">remove_sc</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, a vector of integerish numbers, i.e., integers that can be specified as numeric, i.e., <code>1</code> and <code>1L</code>
are both possible. Removes the sufficient cause (SC) with the specified index from the plot, i.e., for <code>remove_sc = 2</code>, removes SC 2, and for
<code>remove_sc = c(2,3)</code>, removes SC 2 and SC 3. If there are x sufficient causes in the model, x is the highest allowed value. At least one
sufficient cause needs to remain, i.e., not all sufficient causes can be removed. If NULL (default), all sufficient causes are plotted.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_sc_label">sc_label</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, a character vector with the labels written above the pies, i.e., sufficient causes. If NULL
(default), &quot;Sufficient Cause 1&quot;, &quot;Sufficient Cause 2&quot;, etc. are used. If specified, try to provide as many labels as there are pies in the plot.
Duplicates are not allowed.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_unknown">unknown</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, TRUE (default) or FALSE. If TRUE, unknown causes are added to the SCC model: every sufficient cause
gets an additional individual unknown component cause representing additional unknown components; an unknown sufficient cause is added to
the model consisting of a single unknown component cause and representing all unknown sufficient causes.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_names">names</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, TRUE (default) or FALSE. If TRUE, includes the translation of pie segment names to descriptions of
component causes in the plot.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_text_color">text_color</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, a single element of type character, which is a valid color description. Valid color descriptions
can be named colors (&quot;white&quot;) or hexadecimal color codes (&quot;#FFFFFF&quot;). <code>text_color</code> will be used for the pie segment names. If NULL (default),
&quot;white&quot; is used.</p>
</td></tr>
<tr><td><code id="new_scc_+3A_pie_color">pie_color</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, a character vector of length 3 containing valid color descriptions. Valid color descriptions
can be named colors (&quot;white&quot;) or hexadecimal color codes (&quot;#FFFFFF&quot;). The first element of <code>pie_color</code> is used to color sufficient causes,
which are always sufficient. The second element is used to color sufficient causes, for which sufficiency depends on the order of occurrence.
The third element is used to color the unknown sufficient cause, which is present if <code>unknown</code> is TRUE. If NULL (default), the following colors
are used: &quot;#B1934A&quot;, &quot;#A65141&quot;, &quot;#394165&quot;</p>
</td></tr>
<tr><td><code id="new_scc_+3A_border_color">border_color</code></td>
<td>
<p>For <code>plot.epicmodel_scc()</code>, a single element of type character, which is a valid color description. Valid color
descriptions can be named colors (&quot;white&quot;) or hexadecimal color codes (&quot;#FFFFFF&quot;). <code>border_color</code> will be used for all pie borders apart from
the unknown sufficient cause. Therefore, only specify <code>border_color</code> if <code>unknown</code> is FALSE. If NULL (default), &quot;white&quot; is used. (Borders
for the unknown sufficient cause have the same color as the pie.)</p>
</td></tr>
</table>


<h3>Details</h3>



<h4><code>epicmodel_scc</code> objects</h4>

<p><code>epicmodel_scc</code> objects are lists containing 10 elements. These elements are described below:
</p>

<dl>
<dt><code>sc_cc</code></dt><dd><p>A data.frame with one column for every component cause and one row for every sufficient cause. Colnames are the step IDs from
the corresponding steplist. Rownames are sufficient cause IDs (see below). Each cell contains either TRUE or FALSE indicating if the component
cause in the column is part of a set of component causes described by the row.</p>
</dd>
<dt><code>sc_status</code></dt><dd><p>A named character vector with one element for every sufficient cause. The names are sufficient cause IDs (see below). The
elements contain the status of the sufficient cause (see below). Here, only &quot;always&quot;, &quot;depends&quot;, and &quot;depends (potential order
implausibilities)&quot; appear.</p>
</dd>
<dt><code>sc_steps</code></dt><dd><p>A list of character vectors with one list element for every sufficient cause. The list is named using sufficient cause IDs
(see below). Every character vector contains the step IDs of all steps that are part of the corresponding sufficient cause, i.e., that can be
caused by the corresponding set of component causes.</p>
</dd>
<dt><code>sc_order</code></dt><dd><p>A list with one list element for every sufficient cause. The list is named using sufficient cause IDs (see below). List
elements are either NA (if a sufficient cause's status is &quot;always&quot;) or a data.frame (if a sufficient cause's status is &quot;depends&quot; or &quot;depends
(potential order implausibilities)&quot;. Data.frames contain two columns, which are called &quot;order&quot; and &quot;suff&quot; (short for &quot;sufficient&quot;), and one row
for every order of occurrence. The order of occurrence is summarized in &quot;order&quot; (as character), while &quot;suff&quot; is either TRUE or FALSE indicating
if the corresponding order of occurrence is sufficient, i.e., leads to the outcome, or not.</p>
</dd>
<dt><code>sc_implausibilities</code></dt><dd><p>A named vector of TRUE and FALSE with length equal to the number of sufficient causes. The names are sufficient
cause IDs (see below). Is TRUE if for the corresponding sufficient cause there are potential order implausibilities, i.e., if its status is
&quot;depends (potential order implausibilities)&quot;, and is FALSE otherwise.</p>
</dd>
<dt><code>sc_implausibilities_detail</code></dt><dd><p>A list with one list element for every sufficient cause. The list is named using sufficient cause IDs
(see below). List elements are either NA (if the corresponding element in <code>sc_implausibilities</code> is FALSE) or a character vector (if the
corresponding element in <code>sc_implausibilities</code> is TRUE) with the THEN statements of the steps that might be involved in implausible orders of
occurrence.</p>
</dd>
<dt><code>sc_use_modules</code></dt><dd><p>Either TRUE or FALSE indicating if modules have been specified in the steplist.</p>
</dd>
<dt><code>unknown_cc</code></dt><dd><p>Similar to <code>sc_cc</code> but includes unknown component causes and an unknown sufficient cause (see &quot;Unknown causes&quot; below).
It therefore additionally contains:
</p>

<ul>
<li><p> one column to the right for every sufficient cause with name &quot;U<code>rownumber</code>&quot; (U1, U2, etc.) and all values equal to FALSE appart from row
<code>rownumber</code>, which is TRUE
</p>
</li>
<li><p> one additional column to the right with name &quot;USC&quot; and all values equal to FALSE for all sufficient causes
</p>
</li>
<li><p> one additional row with name &quot;cc0&quot; and all values equal to FALSE apart from column &quot;USC&quot;, which is TRUE</p>
</li></ul>

</dd>
<dt><code>unknown_status</code></dt><dd><p>Similar to <code>sc_status</code> but has one additional element with value &quot;unknown&quot; and name &quot;cc0&quot; (see &quot;Unknown causes&quot; below).</p>
</dd>
<dt><code>steplist</code></dt><dd><p>The object of class <code>epicmodel_steplist_checked</code> that has been the input to function <code><a href="#topic+create_scc">create_scc()</a></code>, from which the
<code>epicmodel_scc</code> object has been created.</p>
</dd>
</dl>




<h4>Other details:</h4>


<dl>
<dt><code style="white-space: pre;">&#8288;Sufficient cause IDs&#8288;</code></dt><dd><p><code><a href="#topic+create_scc">create_scc()</a></code> checks every combination of component causes for sufficiency. Every combination is assigned an
ID of the format &quot;cc<code>number</code>&quot; (cc1, cc2, etc.). <code>epicmodel_scc</code> only contains information about minimally sufficient combinations of component
causes, but the initial IDs are kept. The IDs are used throughout the different elements of <code>epicmodel_scc</code> to link information that belongs to
the same sufficient cause. The unknown sufficient cause used in elements <code>unknown_cc</code> and <code>unknown_status</code> has ID cc0.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Unknown causes&#8288;</code></dt><dd><p>Since many causes might be unknown, it is reasonable for some applications to include these unknown causes in a SCC
model (see, e.g., Rothman et al. (2008)). They are also useful to remind us of our limited knowledge. In a suffcient-component cause model,
unknown causes come in two flavors:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Unknown component causes&#8288;</code>: These are additional component causes within a sufficient cause, which are necessary for sufficiency. Please note
that each sufficient cause has its own set of unknown component causes. In <code>unknown_cc</code>, unknown component causes are called U1, U2, etc.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Unknown sufficient causes&#8288;</code>: There might be unknown mechanisms that lead to outcome occurrence. These sufficient causes are summarized in one
additional sufficient cause, which has only a single component cause called <code>USC</code> in <code>unknown_cc</code>. This set of component causes has
sufficient cause ID <code>cc0</code>.
</p>
</li></ul>

<p>Please note that in <code><a href="#topic+plot_dag">plot_dag()</a></code> an ellipse represents a <strong>determinative set</strong> of sufficient causes, as suggested and defined by VanderWeele &amp;
Robins (2007). A determinative set contains all sufficient causes and, therefore, in most cases, an unknown sufficient cause is necessary to
at least achieve a theoretical determinative set. Determinative sets are important for creating causal diagrams (in the form of directed
acyclic graphs) from SCC models. VanderWeele and Robins (2007) write (p. 1099, D refers to the outcome):
</p>
<p><em>&quot;To ensure that the DAG with the sufficient causation structure is itself a causal DAG, it is important that the set of sufficient causes for</em>
<em>D on the graph be a determinative set of sufficient causes — that is, that the sufficient causes represent all of the pathways by which the</em>
<em>outcome D may occur. Otherwise certain nodes may have common causes which are not on the graph, and the graph will then not be a causal DAG.&quot;</em>
</p>
<p>It can of course be argued that an unknown sufficient cause in the described form is hardly of any use when creating a causal graph (as a DAG)
from a SCC model. Nonetheless, it can be, as mentioned, a placeholder and reminder of limited knowledge.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sufficiency status&#8288;</code></dt><dd><p>The sufficiency status describes under which circumstances a certain set of component causes is sufficient. There
are 5 possible values:
</p>

<ul>
<li> <p><code>always</code>: The set of component causes is always sufficient.
</p>
</li>
<li> <p><code>depends</code>: The set of component causes is sometimes sufficient and sufficiency depends on the order of occurrence of the involved steps,
because some of them contain IFNOT conditions. However, if an IFNOT condition prevents the step from happening depends on the order of
occurrence: if the IF condition is fulfilled before the IFNOT condition, the step (usually) occurs anyways, similar to how I do not care if
a door is closed if I already went through it when it was still open.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;depends (potential order implausibilities)&#8288;</code>: Same as &quot;depends&quot;, but in the list of potential orders of occurrence of the involved steps,
there might be some that do not make sense in practice, e.g., when two steps with IFNOT conditions are chained together: Imagine Step1
having IF condition If1 and IFNOT condition Ifnot1, and Step2 having IF condition If2 and IFNOT condition Step1. The order Step1 -&gt; Ifnot1
-&gt; If1 -&gt; If2 is not plausible because Ifnot1 occurred before If1 and therefore Step1 did never occur. The user needs to discard these orders
of occurrence (as I am currently not confident to correctly remove only implausible ones with code).
</p>
</li>
<li> <p><code>never</code>: The set of component causes is never sufficient. This status is not used in <code>epicmodel_scc</code>. It's only used when investigating the
effect of interventions (see <code><a href="#topic+intervene">intervene()</a></code>).
</p>
</li>
<li> <p><code>unknown</code>: This is the status of the unknown sufficient cause, which is added to the SCC model. It's only used in element <code>unknown_status</code> of
<code>epicmodel_scc</code> objects.</p>
</li></ul>

</dd>
</dl>




<h3>Value</h3>


<ul>
<li> <p><code>new_scc()</code>: An object of class <code>epicmodel_scc</code>.
</p>
</li>
<li> <p><code>validate_scc()</code>: An object of class <code>epicmodel_scc</code> that has been checked to have the correct structure.
</p>
</li>
<li> <p><code>empty_scc()</code>: A (realtively) empty object of class <code>epicmodel_scc</code> with correct structure.
</p>
</li>
<li> <p><code>print.epicmodel_scc()</code>: Prints a summary of the object of class <code>epicmodel_scc</code> in the console.
</p>
</li>
<li> <p><code>summary.epicmodel_scc()</code>: Same as <code>print.epicmodel_scc()</code>.
</p>
</li>
<li> <p><code>plot.epicmodel_scc()</code>: A <code>ggplot</code> object.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Rothman KJ, Greenland S, Poole C, Lash TL (2008): Causation and Causal Inference. In: Rothman KJ, Greenland S, Lash TL (Ed.): Modern
epidemiology. Third edition. Philadelphia, Baltimore, New York: Wolters Kluwer Health Lippincott Williams &amp; Wilkins, pp. 5–31.
</p>
</li>
<li><p> VanderWeele TJ, Robins JM (2007): Directed acyclic graphs, sufficient causes, and the properties of conditioning on
a common effect. American Journal of Epidemiology 166 (9): 1096–1104.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+create_scc">create_scc()</a></code> for information on the algorithm for creating SCC models
</p>
</li>
<li> <p><code><a href="#topic+plot_dag">plot_dag()</a></code> for how determinative sets of component causes are displayed in a DAG
</p>
</li>
<li> <p><code><a href="#topic+intervene">intervene()</a></code> for the use of sufficiency status &quot;never&quot;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># epicmodel_scc object are created by create_scc()

# first, check your steplist of choice
steplist_checked &lt;- check_steplist(steplist_rain)
# then, use it in create_scc()
scc_model &lt;- create_scc(steplist_checked)

# new_scc() and validate_scc() are used inside create_scc()
# nonetheless, you can check its structure with validate_scc()
validate_scc(scc_model)

# print() and summary() both summarize the model in the console
print(scc_model)
scc_model
summary(scc_model)

# plot causal pies with plot()
plot(scc_model)

</code></pre>

<hr>
<h2 id='new_steplist'>Steplist objects</h2><span id='topic+new_steplist'></span><span id='topic+validate_steplist'></span><span id='topic+empty_steplist'></span><span id='topic+print.epicmodel_steplist'></span><span id='topic+print.epicmodel_steplist_checked'></span><span id='topic+summary.epicmodel_steplist'></span><span id='topic+summary.epicmodel_steplist_checked'></span><span id='topic+plot.epicmodel_steplist'></span><span id='topic+plot.epicmodel_steplist_checked'></span>

<h3>Description</h3>

<p>The S3 classes <code>epicmodel_steplist</code> and <code>epicmodel_steplist_checked</code> store the input information for SCC model creation. They are created from
the Steplist Creator <code>shiny</code> app, which can be launched with <code><a href="#topic+launch_steplist_creator">launch_steplist_creator()</a></code>.
</p>
<p><code>new_steplist()</code>, <code>validate_steplist()</code>, and <code>empty_steplist()</code> define the S3 class.
</p>
<p><code>print()</code> prints a summary of the steplist entries in the console.
</p>
<p><code>summary()</code> prints a list of steps sorted by type of step in the console.
</p>
<p><code>plot()</code> renders a graph of the complete network of mechanisms in the RStudio Viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_steplist(x = list())

validate_steplist(x)

empty_steplist()

## S3 method for class 'epicmodel_steplist'
print(x, ...)

## S3 method for class 'epicmodel_steplist_checked'
print(x, ...)

## S3 method for class 'epicmodel_steplist'
summary(object, ...)

## S3 method for class 'epicmodel_steplist_checked'
summary(object, ...)

## S3 method for class 'epicmodel_steplist'
plot(x, ...)

## S3 method for class 'epicmodel_steplist_checked'
plot(x, modules = TRUE, module_colors = NULL, render = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_steplist_+3A_x">x</code></td>
<td>
<p><code>x</code> is used in several functions:
</p>

<ul>
<li> <p><code>new_steplist()</code>: A list to be converted to class <code>epicmodel_steplist</code>.
</p>
</li>
<li> <p><code>validate_steplist()</code>: An object of class <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code> to be validated.
</p>
</li>
<li> <p><code>print.epicmodel_steplist()</code>: An object of class <code>epicmodel_steplist</code>.
</p>
</li>
<li> <p><code>print.epicmodel_steplist_checked()</code>: An object of class <code>epicmodel_steplist_checked</code>.
</p>
</li>
<li> <p><code>plot.epicmodel_steplist()</code>: An object of class <code>epicmodel_steplist</code>.
</p>
</li>
<li> <p><code>plot.epicmodel_steplist_checked()</code>: An object of class <code>epicmodel_steplist_checked</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="new_steplist_+3A_...">...</code></td>
<td>
<p>Additional arguments for generics <code>print()</code>, <code>summary()</code>, and <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="new_steplist_+3A_object">object</code></td>
<td>
<p>For <code>summary.epicmodel_steplist()</code>, an object of class <code>epicmodel_steplist</code>. For <code>summary.epicmodel_steplist_checked()</code>, an object
of class <code>epicmodel_steplist_checked</code>.</p>
</td></tr>
<tr><td><code id="new_steplist_+3A_modules">modules</code></td>
<td>
<p>For <code>plot.epicmodel_steplist_checked</code>, TRUE (default) or FALSE, indicating if nodes in the same module should be colored equally
(TRUE) or if all nodes have white background (FALSE). Colors are only applied, if modules have actually been specified in the
<code>epicmodel_steplist</code>.</p>
</td></tr>
<tr><td><code id="new_steplist_+3A_module_colors">module_colors</code></td>
<td>
<p>For <code>plot.epicmodel_steplist_checked</code>, if nodes are colored by module, colors can be provided via this argument. Colors
must be provided as a character vector. Both named colors and hexadecimal color codes are allowed. The function has 8 colors stored internally.
If <code>module_colors</code> = NULL (default), these colors are used. If the model has more than 8 modules, <code>module_colors</code> must be specified. If more
colors than necessary are specified, the function takes as many as necessary from the start of the vector.</p>
</td></tr>
<tr><td><code id="new_steplist_+3A_render">render</code></td>
<td>
<p>For <code>plot.epicmodel_steplist_checked</code>, if TRUE (default), graph is directly rendered. IF FALSE, the output contains the
non-rendered graph.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4><code>epicmodel_steplist</code> objects</h4>

<p><code>epicmodel_steplist</code> objects are lists containing 8 data.frames. These data.frames are described below:
</p>

<dl>
<dt><code>what</code></dt><dd><p>A list of subjects and objects (WHAT segments) appearing in the step descriptions, e.g., cells, interleukins, symptoms, etc.,
with the following variables:
</p>

<ul>
<li><p> id_what: Automatically created ID for WHAT segments. Starts with &quot;a&quot; followed by a number, e.g., a1. Used in creating automatic step IDs.
</p>
</li>
<li><p> key_what: Keyword describing the WHAT segment. Used in steplist_creator shiny app dropdown menus.
</p>
</li>
<li><p> desc_what: Text used in step descripiton.
</p>
</li>
<li><p> plural_what: Indicates if plural (1) or singular (0) version of the DOES description should be used, if this WHAT segment is used as subject,
i.e., WHAT segment before the DOES segment.</p>
</li></ul>

</dd>
<dt><code>does</code></dt><dd><p>A list of actions or verbs (DOES segments), with which the WHAT segments interact, e.g., is present, produce, migrate,
exposed to, with the following variables:
</p>

<ul>
<li><p> id_does: Automatically created ID for DOES segments. Starts with &quot;d&quot; followed by a number, e.g., d1. Used in creating automatic step IDs.
</p>
</li>
<li><p> key_does: Keyword describing the DOES segment. Used in steplist_creator shiny app dropdown menus.
</p>
</li>
<li><p> subject_singular_does: Description used if subject (WHAT segment in front) has been specified as singular (plural_what=0).
</p>
</li>
<li><p> subject_plural_does: Description used if subject (WHAT segment in front) has been specified as plural (plural_what=1).
</p>
</li>
<li><p> no_subject_does: Description used if no subject (WHAT segment in front) has been specified.
</p>
</li>
<li><p> then_object_does: Indicates if the object for this DOES segment is a WHAT segment (0) or a THEN statement (1).</p>
</li></ul>

</dd>
<dt><code>where</code></dt><dd><p>A list of locations (WHERE segments), where the specified actions take place, e.g., in the airways, with the following
variables:
</p>

<ul>
<li><p> id_where: Automatically created ID for WHERE segments. Starts with &quot;e&quot; followed by a number, e.g., e1. Used in creating automatic step IDs.
</p>
</li>
<li><p> key_where: Keyword describing the WHERE segment. Used in steplist_creator shiny app dropdown menus.
</p>
</li>
<li><p> desc_where: Text used in step descripiton. Please include the corresponding preposition, e.g., 'in', 'into', 'on', etc.</p>
</li></ul>

</dd>
<dt><code>then</code></dt><dd><p>A list of combinations of WHAT, DOES and WHERE segments (THEN statements). A THEN statement can contain up to 4 segments: WHAT
(subject), DOES, WHAT (object), WHERE. Not all 4 of them need to be specified. For some DOES segments, the corresponding object is not a WHAT
segment but a THEN statement (see <code>then_object_does</code>). In general, all combinations are possible, although only DOES, only WHERE, and WHAT WHAT
do not make a lot of sense. <code>then</code> exists to store the THEN statements that are later used in IF and IFNOT conditions. It contains the following
variables:
</p>

<ul>
<li><p> id_then: Automatically created ID based on segment IDs, e.g., a4, a1d5a15e9, d2a3.
</p>
</li>
<li><p> desc_then: Automatically created description based on segment descriptions.</p>
</li></ul>

</dd>
<dt><code>module</code></dt><dd><p>Modules are groups, into which the steps are sorted, e.g., immune system, lung, etc., as it is sometimes of interest to see
which groups are involved in the sufficient causes. It contains the following variables:
</p>

<ul>
<li><p> id_module: Automatically created ID for modules. Starts with &quot;m&quot; followed by a number, e.g., m1.
</p>
</li>
<li><p> key_module: Keyword describing the module.
</p>
</li>
<li><p> desc_module: Module description.</p>
</li></ul>

</dd>
<dt><code>step</code></dt><dd><p>Main table of interest and the one further processed to create sufficient-component cause models. It contains the following
variables:
</p>

<ul>
<li><p> id_step: Automatically created step ID based on IDs of included THEN statements, e.g., IFd6a10IFNOTd6a18+d1a8THENa11d3a12.
</p>
</li>
<li><p> desc_step: Automatically created step description based on descriptions of included THEN statements.
</p>
</li>
<li><p> end_step: Indicator variable that describes if this step is at the end of a certain sub-mechanism, e.g., symptom x occured.
</p>
</li>
<li><p> module_step: Module, i.e., group, into which this step has been sorted.
</p>
</li>
<li><p> note_step: Additional notes that are important for future users, e.g., if there are conflicting results or if the result is from a mouse
model.
</p>
</li>
<li><p> ref_step: References on which this step is based.</p>
</li></ul>

</dd>
<dt><code>icc</code></dt><dd><p>ICC is short for incompatibel component causes. It contains pairs of component causes, i.e., steps without IF or IFNOT condition,
that are not compatible with each other, i.e., cannot appear in the same sufficient cause. It contains the following variables:
</p>

<ul>
<li><p> id_icc: Automatically created ID for ICC pairs. Starts with &quot;i&quot; followed by a number, e.g., i1.
</p>
</li>
<li><p> id1: Step ID of first component cause.
</p>
</li>
<li><p> id2: Step ID of second component cause.
</p>
</li>
<li><p> desc1: Step description of first component cause.
</p>
</li>
<li><p> desc2: Step description of second component cause.</p>
</li></ul>

</dd>
<dt><code>outc</code></dt><dd><p>A list that contains conditions under which the outcome of interest is assumed to occur. Each line might contain one or more THEN
statements, that have been marked as end steps by setting step$end_step to 1. If more than one THEN statement is selected, they are combined
with AND logic. All lines in this table are combined with OR logic, i.e., any of the specified conditions is assumed to represent outcome
occurrence. The table contains the following variables:
</p>

<ul>
<li><p> id_outc: Automatically created ID for outcome definitions as a combination of the THEN statement IDs connected by '+'.
</p>
</li>
<li><p> desc_outc: Automatically created description for the outcome definitions as a combination of the THEN statement descriptions.</p>
</li></ul>

</dd>
</dl>




<h4><code>epicmodel_steplist_checked</code> objects</h4>

<p>Before using <code>epicmodel_steplist</code> object for SCC model creation in <code><a href="#topic+create_scc">create_scc()</a></code>, they need to be checked for any structures that might make
SCC model creation impossible. Checking is performed by <code><a href="#topic+check_steplist">check_steplist()</a></code> and if successful, the returned object is of type
<code>epicmodel_steplist_checked</code>. When changing the steplist in the Steplist Creator <code>shiny</code> app or by functions <code><a href="#topic+remove_all_modules">remove_all_modules()</a></code>,
<code><a href="#topic+remove_na">remove_na()</a></code>, or <code><a href="#topic+remove_segment">remove_segment()</a></code>, the steplist is &quot;un-checked&quot; and returned as class <code>epicmodel_steplist</code>. Apart from that, both classes
have similar structure, which can be validated by <code>validate_steplist()</code>.
</p>



<h3>Value</h3>


<ul>
<li> <p><code>new_steplist()</code>: An object of class <code>epicmodel_steplist</code>.
</p>
</li>
<li> <p><code>validate_steplist()</code>: An object of class <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code>, that has been checked to have the correct
structure.
</p>
</li>
<li> <p><code>empty_steplist()</code>: An empty object of class <code>epicmodel_steplist</code> object with correct structure.
</p>
</li>
<li> <p><code>print.epicmodel_steplist()</code>: Prints the number of entries in each data.frame in the console and the information that the steplist is
<code>unchecked</code>.
</p>
</li>
<li> <p><code>print.epicmodel_steplist_checked()</code>: Same as <code>print.epicmodel_steplist()</code> but with the information the the steplist has been checked
successfully.
</p>
</li>
<li> <p><code>summary.epicmodel_steplist()</code>: Prints an allert that the steplist needs to be checked with <code>check_steplist()</code> before using <code>summary()</code>.
</p>
</li>
<li> <p><code>summary.epicmodel_steplist_checked()</code>: Prints a list of steps by type of step in the console.
</p>
</li>
<li> <p><code>plot.epicmodel_steplist()</code>: Prints an allert that the steplist needs to be checked with <code>check_steplist()</code> before using <code>plot()</code>.
</p>
</li>
<li> <p><code>plot.epicmodel_steplist_checked()</code>: Prints a graph of the complete network of mechanisms in the RStudio Viewer and the corresponding legend
in the console.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create steplists in the Steplist Creator `shiny` app
if(interactive()){
launch_steplist_creator()
}

# Download the steplist from the `shiny` app
# Load the steplist into R
path &lt;- system.file("extdata", "steplist_rain.rds", package = "epicmodel")
steplist &lt;- readRDS(path)

# new_steplist(), validate_steplist(), and empty_steplist() are used in the `shiny` app
# nonetheless, you can check steplist structures with validate_steplist()
validate_steplist(steplist)

# print() provides a summary of steplist entries and if it's checked or unchecked
print(steplist)

# Check steplist before using `summary()` and `plot()`
steplist_checked &lt;- check_steplist(steplist)
summary(steplist_checked)
plot(steplist_checked)
</code></pre>

<hr>
<h2 id='plot_dag'>Plot DAG</h2><span id='topic+plot_dag'></span>

<h3>Description</h3>

<p>Creates a ggplot from a <code>dagitty</code> object, using packages <code>dagitty</code> and <code>ggdag</code>. Mimics format and colors used on the <code>dagitty</code> homepage
https://www.dagitty.net. Please note the recommendation in argument <code>label_shift</code> below: Getting the values for <code>label_shift</code> right can be an iterative
and slightly tedious procedure. It is highly recommended to evaluate the result of the current values already in the saved plot using,
e.g., <code>ggsave</code> and not in the RStudio Viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dag(
  dag,
  node_outc = NULL,
  node_expo = NULL,
  node_adj = NULL,
  node_latent = NULL,
  path_causal = NULL,
  path_biased = NULL,
  label = NULL,
  label_shift = NULL,
  label_size = 2.5,
  node_size = 7,
  node_stroke = 1,
  e_w = 0.4,
  cap_mm = 4,
  scc = FALSE,
  scc_size = c(0.1, 0.35),
  scc_shift = c(0, 0),
  scc_angle = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dag_+3A_dag">dag</code></td>
<td>
<p>An object of class <code>dagitty</code>. Can be created by using <code>dagitty::dagitty('[model_code]')</code> or <code><a href="#topic+scc_to_dag">scc_to_dag()</a></code>. If your DAG has
been created by <code><a href="#topic+scc_to_dag">scc_to_dag()</a></code>, make sure to pass only the first element (named <code>dag</code>) to <code>plot_dag</code>.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_outc">node_outc</code></td>
<td>
<p>A single element of type character or NULL (default). If the outcome has not yet been specified in <code>dag</code>, it can be done here by
specifiying the name of the corresponding node.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_expo">node_expo</code></td>
<td>
<p>A single element of type character or NULL (default). If the exposure has not yet been specified in <code>dag</code>, it can be done here
by specifiying the name of the corresponding node.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_adj">node_adj</code></td>
<td>
<p>A character vector or NULL (default). Specify the names of nodes that should be defined as &quot;adjusted&quot;.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_latent">node_latent</code></td>
<td>
<p>A character vector or NULL (default). Specify the names of nodes that should be defined as &quot;latent&quot;.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_path_causal">path_causal</code></td>
<td>
<p>A character vector or NULL (default). Specify the names of the paths in format &quot;V1-&gt;V2&quot; that should be defined as &quot;causal&quot;.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_path_biased">path_biased</code></td>
<td>
<p>A character vector or NULL (default). Specify the names of the paths in format &quot;V1-&gt;V2&quot; that should be defined as &quot;biased&quot;.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_label">label</code></td>
<td>
<p>A named character vector or NULL (default). Change the name of nodes in the graph, i.e., labels. The vector elements correspond to
the new names, the vector names correspond to the old node names, i.e., <code style="white-space: pre;">&#8288;label = c(old_name = "new_name").&#8288;</code></p>
</td></tr>
<tr><td><code id="plot_dag_+3A_label_shift">label_shift</code></td>
<td>
<p>A named list (with all elements being numerical vectors of length 2) or NULL (default). Numerical values are used to move the
labels of the corresponding nodes in x and y direction, respectively. The list names correspond to the nodes to which the values apply. Possible
list names are the node names (initial names prior to changing them via <code>label</code>), node types, i.e., <code>outcome</code>, <code>exposure</code>, <code>adjusted</code>, <code>latent</code>,
and <code>other</code>, as well as <code>all</code>, which applies to all nodes. If a node is addressed by several entries, e.g., its name and <code>all</code>, all entries are
summed up. See the example below. Getting the values for <code>label_shift</code> right can be an iterative and slightly tedious procedure. It is highly
recommended to evaluate the result of the current values already in the saved plot using, e.g., <code>ggsave</code> and not in the RStudio Viewer.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_label_size">label_size</code></td>
<td>
<p>A single numeric value, which controls the font size of the label. Default is 2.5.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_size">node_size</code></td>
<td>
<p>A single numeric value, which controls the size of the circle that represents the node. Default is 7.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_node_stroke">node_stroke</code></td>
<td>
<p>A single numeric value, which controls the size of the black border around the node circles. Default is 1.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_e_w">e_w</code></td>
<td>
<p>A single numeric value, which controls edge width. Default is 0.4.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_cap_mm">cap_mm</code></td>
<td>
<p>A single numeric value, which controls the distance, i.e., white space, between when the node ends and the edge begins/ the edge
ends and the node begins. Higher values correspond to shorter edges/arrows. Default is 4.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_scc">scc</code></td>
<td>
<p>TRUE or FALSE (default). Only applies to DAGs that are based on sufficient-component cause (SCC) models. If TRUE, an ellipse is
added to the DAG, which should surround all sufficient cause variables, if they are a determinative set of sufficient causes, as suggested by
VanderWeele and Robins (2007). If the DAG is not based on a SCC, leave <code>scc</code> at FALSE.</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_scc_size">scc_size</code></td>
<td>
<p>A numeric vector of length 2, which controls the size of the ellipse. Default is c(0.1, 0.35).</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_scc_shift">scc_shift</code></td>
<td>
<p>A numeric vector of length 2, which controls the shift of the complete ellipse in x and y direction. Default is c(0, 0).</p>
</td></tr>
<tr><td><code id="plot_dag_+3A_scc_angle">scc_angle</code></td>
<td>
<p>A single numeric value, which controls rotiation of the ellipse in degree units. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>VanderWeele TJ, Robins JM (2007): Directed acyclic graphs, sufficient causes, and the properties of conditioning on
a common effect. American Journal of Epidemiology 166 (9): 1096–1104.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="dagitty.html#topic+dagitty">dagitty::dagitty()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+scc_to_dag">scc_to_dag()</a></code> for creating DAGs from SCC models
</p>
</li>
<li> <p><code><a href="#topic+new_scc">SCC models</a></code> for more information on SCC models
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Transform SCC model into a DAG
dag &lt;- scc_to_dag(scc_rain)[["dag"]]

# Plot DAG
plot_dag(dag, label_shift = list(all = c(0,0.15), outcome = c(0.05,0)))

# plot_dag() works also with dagitty objects created in other ways
dag_to_plot &lt;- dagitty::dagitty('dag {
bb="-2.628,-2.412,2.659,2.378"
V1 [pos="-2.128,-1.912"]
V2 [pos="-0.031,0.035"]
V3 [pos="2.159,1.878"]
V1 -&gt; V2
V2 -&gt; V3
}')
plot_dag(dag_to_plot, node_outc = "V3", node_expo = "V1", label = c(V3 = "outcome"))

</code></pre>

<hr>
<h2 id='prevent'>Explore effect of prevention</h2><span id='topic+prevent'></span>

<h3>Description</h3>

<p>Prevention refers to the avoidance of component causes, i.e., of elements of sufficient causes. For a given set of component causes, <code>prevent()</code>
derives, which of them need to be &quot;removed&quot; in order to avoid outcome occurrence. Reported are the smallest prevention sets, i.e., with the
fewest component causes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevent(scc, causes = NULL, output = c("nice", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prevent_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="prevent_+3A_causes">causes</code></td>
<td>
<p>A character vector containing step IDs of component causes. If NULL (default), prints a list of all available component causes in
the console.</p>
</td></tr>
<tr><td><code id="prevent_+3A_output">output</code></td>
<td>
<p>Either &quot;nice&quot; (default) or &quot;table&quot;. If &quot;nice&quot;, prints a nicely formatted summary in the console. If &quot;table&quot;, returns a data.frame
(described in section &quot;Value&quot; below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following algorithm is used to evaluate the effect of prevention:
</p>

<ul>
<li><p> Evaluate if <code>causes</code> is sufficient for outcome occurrence. If not, report so and stop.
</p>
</li>
<li><p> Derive a list of all combinations of the component causes provided in <code>causes</code>. The set &quot;all causes present&quot; is not evaluated as it is
already known to be sufficient. In addition, the set &quot;all causes absent&quot;, i.e., &quot;all causes prevented&quot; is considered.
</p>
</li>
<li><p> Evaluate sufficiency for every set
</p>
</li>
<li><p> Subset the list of cause sets to the ones, which are <code>not</code> sufficient, because for them prevention was successful.
</p>
</li>
<li><p> Turn all FALSE to TRUE and all TRUE to FALSE. Now, FALSE indicates present and TRUE indicates absent, i.e., prevented.
</p>
</li>
<li><p> Evaluate, which prevention sets are minimal, i.e., the smallest set to prevent the outcome.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>output = "nice"</code> (default), prints a nicely formatted output in the console. If <code>output = "table"</code>, returns a data.frame with one
row for every prevention set and one column for every component cause provided in argument <code>causes</code>. All cells are either TRUE or FALSE with TRUE
indicating that the corresponding variable needs to be prevented in the corresponding set, and FALSE indicating that prevention in the corresponding
set is not necessary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Derive SCC model
scc_model &lt;- scc_rain

# Derive prevention sets
prevent(scc_model, causes = c("IFNOTd6a6THENd5a6","THENa5","THENa1","THENd2a3"))
</code></pre>

<hr>
<h2 id='remove_all_modules'>Remove all modules</h2><span id='topic+remove_all_modules'></span>

<h3>Description</h3>

<p>Removes all entries in data.frame <code>module</code> from an <code>epicmodel_steplist</code> object. Also turns all values of variable <code>module_step</code> in data.frame
<code>step</code> from an <code>epicmodel_steplist</code> to empty strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_all_modules(steplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_all_modules_+3A_steplist">steplist</code></td>
<td>
<p>An <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>epicmodel_steplist</code> object with empty data.frame <code>module</code> and empty strings in variable <code>module_step</code> in data.frame <code>step</code>. When
continuing with this steplist, SCC models cannot be inspected by module. If you made any changes, you need to call <code><a href="#topic+check_steplist">check_steplist()</a></code> again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- remove_all_modules(steplist_party)
</code></pre>

<hr>
<h2 id='remove_na'>Removing NA in <code>icc</code> and <code>outc</code></h2><span id='topic+remove_na'></span>

<h3>Description</h3>

<p>Remove any entries that only consist of NA from data.frames <code>icc</code> (Incompatible Component Causes) and <code>outc</code> (outcome definition) from an
<code>epicmodel_steplist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_na(steplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_na_+3A_steplist">steplist</code></td>
<td>
<p>An <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>epicmodel_steplist</code> object without entries in data.frame <code>icc</code>, which contain 'NA' in either <code>id1</code> or <code>id2</code> as well as entries in
data.frame <code>outc</code> that contain 'NA' in <code>id_outc</code>. If you made any changes, you need to call <code><a href="#topic+check_steplist">check_steplist()</a></code> again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- remove_na(steplist_party)
</code></pre>

<hr>
<h2 id='remove_segment'>Remove segments</h2><span id='topic+remove_segment'></span>

<h3>Description</h3>

<p>Removes individual entries from data.frames <code>what</code>, <code>does</code>, <code>where</code>, <code>module</code>, or <code>icc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_segment(steplist, id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_segment_+3A_steplist">steplist</code></td>
<td>
<p>An <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code> object.</p>
</td></tr>
<tr><td><code id="remove_segment_+3A_id">id</code></td>
<td>
<p>A single non-missing element of type character describing the ID of the entry you want deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>epicmodel_steplist</code> class object. If you made any changes, you need to call <code><a href="#topic+check_steplist">check_steplist()</a></code> again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>steplist_party &lt;- remove_segment(steplist_party, "d4")
</code></pre>

<hr>
<h2 id='sc_contain_steps'>Do steps appear in sufficient causes?</h2><span id='topic+sc_contain_steps'></span>

<h3>Description</h3>

<p>Extracts from a SCC model, if certain steps are part of the mechanism of sufficient causes. If you want a list of all steps, ignore argument
<code>steps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_contain_steps(scc, steps = NULL, output = c("nice", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_contain_steps_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="sc_contain_steps_+3A_steps">steps</code></td>
<td>
<p>A character vector containing step IDs. IF NULL (default), provides a list of all steps.</p>
</td></tr>
<tr><td><code id="sc_contain_steps_+3A_output">output</code></td>
<td>
<p>A single element of type character, either &quot;nice&quot; (default) or &quot;table&quot;. If &quot;table&quot;, returns a list (or data.frame if steps = NULL).
If &quot;nice&quot;, a nicely formated output is printed in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list (<code>output</code> = &quot;table&quot;) with length equal to the number of sufficient causes and each element being a named vector of
TRUE/FALSE with the variables in <code>steps</code> as names and TRUE indicating that the step appears in the corresponding sufficient cause, or a nicely
formated output in the console (<code>output</code> = &quot;nice&quot;). If steps = NULL and output = &quot;table&quot;, returns a data.frame, which contains variables
<code>id_step</code> and <code>desc_step</code> from the <code>epicmodel_steplist_checked</code> data.frame <code>step</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Check if one or more steps are part of the mechanism for each sufficient cause
sc_contain_steps(scc_model, c("THENa1","THENa5"))
</code></pre>

<hr>
<h2 id='scc_cause_sets'>Extracting component causes from SCC model</h2><span id='topic+scc_cause_sets'></span>

<h3>Description</h3>

<p>Extracting component causes by sufficient cause from an <code>epicmodel_scc</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scc_cause_sets(
  scc,
  output = c("id", "desc", "desc_no_start", "all"),
  depends = TRUE,
  unknown = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scc_cause_sets_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="scc_cause_sets_+3A_output">output</code></td>
<td>
<p>A single element of type character, which determines the type of output. Options are &quot;id&quot;, &quot;desc&quot;, &quot;desc_no_start&quot;, and &quot;all&quot;.
See returns-part below for description.</p>
</td></tr>
<tr><td><code id="scc_cause_sets_+3A_depends">depends</code></td>
<td>
<p>TRUE (default) or FALSE. If FALSE, only includes sufficient causes with sc_status &quot;always&quot;.</p>
</td></tr>
<tr><td><code id="scc_cause_sets_+3A_unknown">unknown</code></td>
<td>
<p>TRUE or FALSE (default). If TRUE, unknown causes are added to the SCC model: every sufficient cause gets an additional
individual unknown component cause representing additional unknown components; an unknown sufficient cause is added to the model consisting of
a single unknown component cause and representing all unknown sufficient causes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list but its content depends on parameter &quot;output&quot;. The names correspond to the component cause set IDs, i.e., <code style="white-space: pre;">&#8288;cc[[:digit:]]+&#8288;</code>.
</p>

<ul>
<li><p> id: Returns a named list of character vectors. Each vector contains the step IDs of its component causes.
</p>
</li>
<li><p> desc: Returns a named list of character vectors. Each vector contains the step descriptions of its component causes.
</p>
</li>
<li><p> desc_no_start: Returns a named list of character vectors. Each vector contains the step descriptions of its component causes, but with the
&quot;Start: &quot; in the beginning removed.
</p>
</li>
<li><p> all: A named list of the three lists above. The names correspond to the corresponding option for parameter &quot;output&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Get sets of component causes that form the sufficient causes
scc_cause_sets(scc_model, output = "all")
</code></pre>

<hr>
<h2 id='scc_rain'>Rain example SCC model</h2><span id='topic+scc_rain'></span>

<h3>Description</h3>

<p>An example SCC model created from <code>steplist_rain</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scc_rain
</code></pre>


<h3>Format</h3>

<p>An object of class <code>epicmodel_scc</code>, which is a list of 10 elements. See <code><a href="#topic+new_scc">new_scc()</a></code> for the detailed structure of
<code>epicmodel_scc</code> class objects.
</p>

<hr>
<h2 id='scc_to_dag'>Transform SCC to DAG</h2><span id='topic+scc_to_dag'></span>

<h3>Description</h3>

<p>Creates an object of class <code>dagitty</code> (<code>dagitty</code> package) from a SCC model, following VanderWeele and Robins (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scc_to_dag(scc, unknown = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scc_to_dag_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="scc_to_dag_+3A_unknown">unknown</code></td>
<td>
<p>TRUE (default) or FALSE. If TRUE, unknown causes are added to the SCC model: every sufficient cause gets an additional
individual unknown component cause representing additional unknown components; an unknown sufficient cause is added to the model consisting
of a single unknown component cause and representing all unknown sufficient causes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2 containing an object of class <code>dagitty</code> (named <code>dag</code>) and a data.frame containing the information, which label in the
DAG corresponds to which component cause (named <code>legend</code>).
</p>


<h3>References</h3>

<p>VanderWeele TJ, Robins JM (2007): Directed acyclic graphs, sufficient causes, and the properties of conditioning
on a common effect. American Journal of Epidemiology 166 (9): 1096–1104.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="dagitty.html#topic+dagitty">dagitty::dagitty()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+new_scc">SCC models</a></code> for more information on unknown causes and SCC models in general
</p>
</li>
<li> <p><code><a href="#topic+plot_dag">plot_dag()</a></code> to create a <code>ggplot</code> object from <code>dagitty</code> model code
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Transform it into a DAG
scc_to_dag(scc_model)
</code></pre>

<hr>
<h2 id='show_steps'>Show all steps of a SCC model</h2><span id='topic+show_steps'></span>

<h3>Description</h3>

<p>Prints all steps that are part of a sufficient-component cause model. The function wraps <code><a href="#topic+sc_contain_steps">sc_contain_steps()</a></code> with <code>steps = NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_steps(scc, output = c("nice", "table"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_steps_+3A_scc">scc</code></td>
<td>
<p>An object of class <code>epicmodel_scc</code>.</p>
</td></tr>
<tr><td><code id="show_steps_+3A_output">output</code></td>
<td>
<p>A single element of type character, either &quot;nice&quot; (default) or &quot;table&quot;. If &quot;table&quot;, returns a data.frame. If &quot;nice&quot;, a nicely
formated output is printed in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a data.frame (<code>output</code> = &quot;table&quot;) with variables <code>id_step</code> (step ID) and <code>desc_step</code> (step description) and one row for every
step in the model, i.e., from the <code>epicmodel_steplist_checked</code> data.frame <code>step</code>, or a nicely formated output in the console (<code>output</code> = &quot;nice&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some SCC model
steplist_checked &lt;- check_steplist(steplist_rain)
scc_model &lt;- create_scc(steplist_checked)

# Show all steps
show_steps(scc_model)
</code></pre>

<hr>
<h2 id='steplist_party'>Birthday party example steplist</h2><span id='topic+steplist_party'></span>

<h3>Description</h3>

<p>An example steplist, which contains the steps that tell Clara, under which conditions her birthday party will be a success.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steplist_party
</code></pre>


<h3>Format</h3>

<p>An object of class <code>epicmodel_steplist</code>, which is a list of 8 data.frames. See <code><a href="#topic+new_steplist">new_steplist()</a></code> for the detailed structure of
<code>epicmodel_steplist</code> class objects.
</p>

<hr>
<h2 id='steplist_rain'>Rain example steplist</h2><span id='topic+steplist_rain'></span>

<h3>Description</h3>

<p>An example steplist, which contains a rain-themed example to illustrate intervention functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steplist_rain
</code></pre>


<h3>Format</h3>

<p>An object of class <code>epicmodel_steplist</code>, which is a list of 8 data.frames. See <code><a href="#topic+new_steplist">new_steplist()</a></code> for the detailed structure of
<code>epicmodel_steplist</code> class objects.
</p>

<hr>
<h2 id='uncheck_steplist'>Unchecking <code>epicmodel_steplist</code> objects</h2><span id='topic+uncheck_steplist'></span>

<h3>Description</h3>

<p>Putting a checked <code>epicmodel_steplist</code> back to an unchecked status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncheck_steplist(steplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncheck_steplist_+3A_steplist">steplist</code></td>
<td>
<p>An <code>epicmodel_steplist</code> or <code>epicmodel_steplist_checked</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>epicmodel_steplist</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- uncheck_steplist(scc_rain$steplist)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
