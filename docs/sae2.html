<!DOCTYPE html><html lang="en"><head><title>Help for package sae2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sae2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sae2-package'>
<p>Small Area Estimation: Time-Series Models.</p></a></li>
<li><a href='#dynRYfit'><p>Internal fitting function for Dynamic and Rao-Yu models</p></a></li>
<li><a href='#eblupDyn'><p>EBLUP Fit of the Dynamic and Rao-Yu Time Series Models</p></a></li>
<li><a href='#geo_ratios'><p>Compute rates or ratios for a set of geographic entities over a set</p>
of years</a></li>
<li><a href='#mvrnormSeries'><p>Generate data under the Dynamic or Rao-Yu Time Series Models</p></a></li>
<li><a href='#vcovgen'><p>Estimate variance/covariance matrices using linear substitutes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Small Area Estimation: Time-Series Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Fay [aut, cre],
  Mamadou Diallo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Fay &lt;bobfay@hotmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), MASS, survey, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sae</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series area-level models for small area estimation. 
      The package supplements the functionality of the sae package.
      Specifically, it includes EBLUP fitting of the original Rao-Yu model, 
      which in the original form did not have a spatial component. The 
      package also offers a modified ('dynamic') version of the Rao-Yu model, 
      replacing the assumption of stationarity. Both univariate and 
      multivariate applications are supported. Of particular note is the 
      allowance for covariance of the area-level sample estimates over time, 
      as encountered in rotating panel designs such as the U.S. National 
      Crime Victimization Survey or present in a time-series of 5-year 
      estimates from the American Community Survey. Key references to the 
      methods include
      J.N.K. Rao and I. Molina (2015, ISBN:9781118735787),
      J.N.K. Rao and M. Yu (1994) &lt;<a href="https://doi.org/10.2307%2F3315407">doi:10.2307/3315407</a>&gt;, and
      R.E. Fay and R.A. Herriot (1979) &lt;<a href="https://doi.org/10.1080%2F01621459.1979.10482505">doi:10.1080/01621459.1979.10482505</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 20:40:11 UTC; bobfa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sae2-package'>
Small Area Estimation: Time-Series Models.
</h2><span id='topic+sae2-package'></span><span id='topic+sae2'></span>

<h3>Description</h3>

<p>Time series are-level models for small area estimation. 
The package supplements the functionality of the package <code>sae</code>. 
Specifically, it includes EBLUP fitting of the original 
Rao-Yu model, which did not have a spatial component. It also offers 
a modified (&quot;dynamic&quot;) version of the Rao-Yu model, replacing the 
assumption of stationarity. Both univariate and multivariate applications 
are supported. Of particular note is the allowance for covariance of
the area-level sample estimates over time, as encountered in
rotating panel designs such as the U.S. National Crime Victimization
Survey or present in a time-series of 5-year estimates from the 
American Community Survey.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sae2</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package provides two primary functions, <code>eblupRY</code> and <code>eblupDyn</code>, 
to fit non-spatial time-series small area models to area-level data. The 
function <code>mvrnormSeries</code> provides simulated data under either model. 
Functions <code>geo_ratios</code> and <code>vcovgen</code> can assist in preparing the
input.
</p>


<h3>Author(s)</h3>

<p>Robert E. Fay, Mamadou S. Diallo
</p>
<p>Maintainer: Robert E. Fay &lt;bobfay@hotmail.com&gt;
</p>


<h3>References</h3>

<p>- Fay, R.E. and Herriot, R.A. (1979). Estimation of income from small places: An application of James-Stein procedures to census data. Journal of the American Statistical Association 74, 269-277.
</p>
<p>- Fay, R.E., Planty, M. and Diallo, M.S. (2013). Small area estimates from the National Crime Victimization Survey. Proceedings of the Joint Statistical Meetings. American Statistical Association, pp. 1544-1557.
</p>
<p>- Rao, J.N.K. and Molina, I. (2015). Small Area Estimation, 2nd ed. Wiley, Hoboken, NJ.
</p>
<p>- Rao, J.N.K. and Yu, M. (1994). Small area estimation by combining time series and cross-sectional data. Canadian Journal of Statistics 22, 511-528.
</p>


<h3>See Also</h3>

<p><code><a href="sae.html#topic+sae-package">sae</a></code>
</p>

<hr>
<h2 id='dynRYfit'>Internal fitting function for Dynamic and Rao-Yu models</h2><span id='topic+dynRYfit'></span>

<h3>Description</h3>

<p>Function designed to be called by either <code>eblupDyn</code> or <code>eblupRY</code>
to produce EBLUP small area estimates of the dynamic or Rao-Yu time 
series models through either ML or REML estimation of the variance 
components. For completeness, the function is documented here, but
users are encouraged to base applications on calls to the more
convenient <code>eblupDyn</code> or <code>eblupRY</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynRYfit(y,  X,  M,  TI,  NV=1,  vcov_e,  maxiter=100, 
         iter.tol=.1e-5,  ncolx=NULL,  sig2_u=1,  sig2_v=1, 
         rho=.8,  rho_u =.4,  delta=NULL,  rho.fixed=NULL, 
         y.include=NULL, ids=NULL,  contrast.matrix=NULL,  
         baby.steps=TRUE,  dampening=NULL,  iter.history=NULL,  
         sig2.min.factor=.0001,  max.rho_u=.98,  max.rho=NULL, 
         tol=.Machine$double.eps, y.rescale=NULL, 
         llike.only=FALSE,  method=c("REML", "ML"), 
         model=c("dyn", "RY"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynRYfit_+3A_y">y</code></td>
<td>
<p>For a univariate model, the dependent variable sorted in
ascending order by time within domain. For a multivariate model, the 
dependent variables sorted in ascending order by time within variable
within domain.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_x">X</code></td>
<td>
<p>A matrix of independent variables with the same number of 
rows as the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_m">M</code></td>
<td>
<p>The total number of domains, equivalent to <code>D</code> in 
<code>eblupDyn</code> and <code>eblupRY</code>.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_ti">TI</code></td>
<td>
<p>The number of time instances (constant for all domains).</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_nv">NV</code></td>
<td>
<p>The number of dependent variables.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_vcov_e">vcov_e</code></td>
<td>
<p>For the univariate model, the sampling covariance matrix 
for the direct estimates of the <code>M*TI</code> elements of the dependent 
variable. The covariance matrix should be in the form of a square
matrix with <code>M*TI</code> rows and columns. Non-zero covariances between 
domains are not allowed, so the matrix must have block
diagonal form with <code>M</code> blocks, each of which is a square matrix
with <code>TI</code> rows and columns. Note that within domain, non-zero 
covariances are allowed over time.
</p>
<p>For the multivariate model, the square covariance matrix for the 
<code>M*NV*TI</code> elements of the dependent variables. The matrix should be 
in the form of a square matrix with <code>M*NV*TI</code> rows and columns. Time 
should vary within variable, which should vary within domain.
Non-zero covariances between domains are not allowed, but non-zero 
covariances may be present across time and between variables.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations allowed for the 
Fisher-scoring algorithm, with a default value of 100.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_iter.tol">iter.tol</code></td>
<td>
<p>The convergence tolerance limit for the 
Fisher-scoring algorithm, with a default value of .000001.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_ncolx">ncolx</code></td>
<td>
<p>For a univariate model, the number of columns of X. For a 
multivariate model, a vector of length NV must be specified giving the
number of columns of X used for each dependent variable.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_sig2_u">sig2_u</code></td>
<td>
<p>An initial starting value or values for the variance of the
random increments.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_sig2_v">sig2_v</code></td>
<td>
<p>An initial starting value or values for a domain level
random effect. In the Rao-Yu model, the random effect is constant over
time, whereas in the dynamic model it is an initial effect subject to 
dampening over time.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_rho">rho</code></td>
<td>
<p>The correlation across time. This correlation is assumed to
be the same for the dependent variables in the multivariate model.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_rho_u">rho_u</code></td>
<td>
<p>For <code>NV &gt; 1</code> only, the (NV*(NV-1))/2 starting values for
the correlations between the random effects of the different dependent
variables. If a single value is given, it will be used for the 
(NV*(NV-1))/2 components. The sort order corresponds to a lower triangle
of the covariance matrix.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_delta">delta</code></td>
<td>
<p>The random effect components in the preferred internal order.
Specification of <code>delta</code> will override any specification of 
<code>sig2_u</code>, <code>sig2_v</code>, <code>rho</code>, or <code>rho_u</code>. In the 
univariate case, delta should contain <code>sig2_u</code>, <code>sig2_v</code>, and 
<code>rho</code>. In the bivariate case, <code>delta</code> should be of length 6 with
<code>sig2_u</code> and <code>sig2_v</code>, each of length 2, <code>rho</code>, and 
<code>rho_u</code>. Similarly, for 3 dependent variables, the length of 
<code>delta</code> is 10, with the last 3 elements <code>rho_u</code> in lower
triangular form.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_rho.fixed">rho.fixed</code></td>
<td>
<p>If TRUE, the value of <code>rho</code> imbedded in <code>delta</code>,
if specified, or else given by <code>rho</code> will remain fixed during the
iterations. Among other features, this allows the likelihood function
for trial values of <code>rho</code> to be computed at the maximum over the
other random effect parameters.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_y.include">y.include</code></td>
<td>
<p>If specified, vector of length <code>M</code> to indicate 
which domains to include in the estimation, with 1 signalling inclusion
and 0 exclusion. Estimates for the excluded domains will be based on
the fixed effects model only.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_ids">ids</code></td>
<td>
<p>A data frame with <code>M</code> rows giving ids for each of the
domains. The data frame is copied into the returned object.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_contrast.matrix">contrast.matrix</code></td>
<td>
<p>A matrix of coefficients of contrasts. The matrix
must have <code>TI*NV</code> rows, but it can contain an arbitrary number
of columns. Within each domain, the coefficients are applied
to the <code>TI*NV</code> EBLUP estimates.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_baby.steps">baby.steps</code></td>
<td>
<p>Unless specified as FALSE, the first five iterations of the
Fisher scoring algorithm are dampened by factors of 
<code>c(.0625, .125, .25, .5, .75)</code>. These heuristically derived 
factors appear to lessen drastic overshooting of the true maximum
in the initial iterations.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_dampening">dampening</code></td>
<td>
<p>A factor used to dampen the changes in the random
effect parameters. Unlike <code>baby.steps</code>, its effect persists
during all of the iterations until convergence. Note that the 
&quot;factory setting&quot; of this parameter is 1 for the dynamic model but
.9 for the Rao-Yu model.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_iter.history">iter.history</code></td>
<td>
<p>If TRUE, key values are saved during each  
iteration and included as additional items, described below,
in the returned list: <code>delta.hist</code>, <code>llikelihood.hist</code>,
<code>adj.hist</code>, <code>s.hist</code>, <code>ix.hist</code>, 
<code>adj.factor.hist</code>, and <code>warning.hist</code>.
</p>
<p>If <code>iter.history</code> is not specified, these items will be 
returned only if the calculations are begun but not successfully 
completed.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_sig2.min.factor">sig2.min.factor</code></td>
<td>
<p>A factor to multiply the minimum direct variance to
use as a minimum value for any of the variance components. The 
iterations will be constrained not to go below the resulting bounds.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_max.rho_u">max.rho_u</code></td>
<td>
<p>A maximum allowed value for the estimated <code>rho_u</code>. The
default value is .98.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_max.rho">max.rho</code></td>
<td>
<p>A maximum allowed value for <code>rho</code>. By default, 
<code><a href="#topic+eblupRY">eblupRY</a></code> sets this value to .98.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_tol">tol</code></td>
<td>
<p>A tolerance value used by matrix routines to prevent numerical
instability. The value may be set to a lower value to encourage
covergence, but appropriate caution should be applied.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_y.rescale">y.rescale</code></td>
<td>
<p>In the univariate case, a scaler multiplier for all of
the <code>y</code> values. If the <code>y</code> values are either too small or 
too large, the information matrix may become unstable. Setting this
value to 1 has no effect; setting it to 10 or 100 rescales very 
small <code>y</code> values to a more appropriate range. Similarly, 
positive values less than 1 may be used to rescale large <code>y</code> 
values. The effect of rescaling is removed before normal return 
from the function, within the limits of normal precision.
</p>
<p>In the multivariate case, <code>y.rescale</code> may be a vector of 
length <code>NV</code> to rescale each component separately.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_llike.only">llike.only</code></td>
<td>
<p>Compute the log-likelihood (ML) or restricted 
log-likelihood (REML) without further iteration, typically from
values specified by <code>delta</code>.</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_method">method</code></td>
<td>
<p>Use restricted maximum likelihood (<code>"REML"</code>) or 
maximum likelihood (<code>"ML"</code>).</p>
</td></tr>
<tr><td><code id="dynRYfit_+3A_model">model</code></td>
<td>
<p>Dynamic (<code>"dyn"</code>) or Rao-Yu (<code>"RY"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many of arguments can be used to control the iterations if the 
defaults lead to convergence difficulties. 
</p>
<p><code>llike.only</code> in combination with <code>delta</code> permits a 
point-by-point investigation of the likelihood surface. 
</p>
<p>The primary functions <code>eblupDyn</code> and <code>eblupRY</code> determine <code>X</code>, 
<code>NV</code>, <code>colx</code>, and <code>model</code>, but the remaining parameters can 
be passed to <code>dynRYfit</code> through <code>eblupDyn</code> or <code>eblupRY</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eblup</code></td>
<td>
<p>In the univariate case, a vector of length <code>M*TI</code> with 
the eblup estimates in the same sort order as <code>y</code>. In the multivariate
case, a matrix of M*TI rows and NV columns.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list summarizing the fit of the model with the following:
</p>
 
<ul>
<li> <p><code>model:</code> form of the model: TI - Dynamic or RaoYu; REML
or ML.
</p>
</li>
<li> <p><code>covergence:</code> a logical value indicating whether the 
convergence criterion was met.
</p>
</li></ul>

</td></tr>
<tr><td><code>parm</code></td>
<td>
<p>A labelled vector with the estimated variance components, 
correlations, and number of iterations.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>A labelled vector of coefficients for the fixed effects of 
the model or models.</p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p>A data frame with <code>D</code> rows and one or more columns of 
numeric or character domain identifiers.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>An ordered vector of the variance components (see above). 
It may be used as starting values for additional iterations.</p>
</td></tr>
<tr><td><code>eblup.mse</code></td>
<td>
<p>MSE estimates for eblup.</p>
</td></tr>
<tr><td><code>eblup.g1</code></td>
<td>
<p>The g1 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>eblup.g2</code></td>
<td>
<p>The g2 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>eblup.g3</code></td>
<td>
<p>The g3 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>est.fixed</code></td>
<td>
<p>Estimates based on fixed effects only.</p>
</td></tr>
<tr><td><code>est.fixed.var</code></td>
<td>
<p>The variance-covariance matrix for the estimates in 
<code>coef</code>.</p>
</td></tr>
<tr><td><code>eblup.wt1</code></td>
<td>
<p>Weights given to the direct estimate in forming <code>eblup</code>.</p>
</td></tr>
<tr><td><code>eblup.wt2</code></td>
<td>
<p>Weights given to the direct estimate, including
effects through estimating the fixed effect coefficients.</p>
</td></tr>
<tr><td><code>contrast.est</code></td>
<td>
<p>Estimates requested by the specified contrasts.</p>
</td></tr>
<tr><td><code>contrast.mse</code></td>
<td>
<p>MSE estimates for <code>contrast.est</code>.</p>
</td></tr>
<tr><td><code>contrast.g1</code></td>
<td>
<p>The g1 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.g2</code></td>
<td>
<p>The g2 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.g3</code></td>
<td>
<p>The g3 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.fixed.est</code></td>
<td>
<p>Contrast estimates based on the fixed effect 
model.</p>
</td></tr>
<tr><td><code>contrast.fixed.var</code></td>
<td>
<p>Variance estimates for the fixed effect model.</p>
</td></tr>
<tr><td><code>contrast.wt1</code></td>
<td>
<p>Weight wt1 given to the direct estimate in estimating 
the contrasts.</p>
</td></tr>
<tr><td><code>contrast.wt2</code></td>
<td>
<p>Weight wt2 in estimating the contrasts.</p>
</td></tr>
<tr><td><code>inf.mat</code></td>
<td>
<p>Information matrix for the components of <code>delta</code>.</p>
</td></tr>
<tr><td><code>var.coef</code></td>
<td>
<p>Variance covariance matrix for <code>coef</code>.</p>
</td></tr>
<tr><td><code>delta.hist</code></td>
<td>
<p>Values of <code>delta</code> at each iteration.</p>
</td></tr>
<tr><td><code>llikelihood.hist</code></td>
<td>
<p>Values of the log-likelihood (ML) or
restricted log-likelihood (REML) at each iteration.</p>
</td></tr>
<tr><td><code>adj.hist</code></td>
<td>
<p>Number of cycles in the internal loop to determine 
<code>adj.factor</code> within each iteration.</p>
</td></tr>
<tr><td><code>inf.mat.hist</code></td>
<td>
<p>Values of <code>inf.mat</code> at each iteration.</p>
</td></tr>
<tr><td><code>s.hist</code></td>
<td>
<p>Vector to be multiplied by the inverse information matrix
to determine the change in the parameters.</p>
</td></tr>
<tr><td><code>ix.hist</code></td>
<td>
<p>List of parameters eligible for change at each iteration.
Parameters with estimated changes out of bounds will not be 
eligible.</p>
</td></tr>
<tr><td><code>adj.factor.hist</code></td>
<td>
<p>Adjustment to the vector change in the parameters 
at each iteration.</p>
</td></tr>
<tr><td><code>warning.hist</code></td>
<td>
<p>A 4-row matrix of warnings at each iteration, where
warning 1 is set to 1 for the iteration if the algorithm has not found 
an increase in the restricted log likelihood or log likelihood, 
warning 2 is set to 1 if the maximum number of iterations is reached, 
warning 3 is set to 1 if the estimated variance-covariance matrix 
becomes singular, and warning 4 is set to 1 if the coefficients of the
fixed effects cannot be estimated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert E. Fay, Mamadou Diallo
</p>

<hr>
<h2 id='eblupDyn'>EBLUP Fit of the Dynamic and Rao-Yu Time Series Models</h2><span id='topic+eblupDyn'></span><span id='topic+eblupRY'></span>

<h3>Description</h3>

<p>Functions for producing EBLUP small area estimates of the dynamic or
Rao-Yu time series models through either ML or REML estimation of the variance
components. The functions can fit univariate or multivariate models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eblupDyn(formula,  D,  TI,  vardir,  method = c("REML", "ML"),
         MAXITER = 1000,  PRECISION = .1e-05,  data, 
         max.rho = NULL,  dampening = 1, ...) 
         
         
eblupRY(formula,  D,  TI,  vardir,  method = c("REML", "ML"),
         MAXITER = 1000,  PRECISION = .1e-05,  data, 
         max.rho = .98, dampening = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eblupDyn_+3A_formula">formula</code></td>
<td>
<p>For a univariate model, a <code>formula</code> for the linear
regression relationship between the dependent variable and the
independent variable(s). The variables included in formula must have
length equal to <code>D*TI</code> and be sorted in ascending order by time 
within each domain.
</p>
<p>For a multivariate model, a list of formulas, one for each 
dependent variable. The number of dependent variables, <code>NV</code>, is 
determined from the length of the list. The dependent variables included 
in the formulas must each have length equal to <code>D*TI</code> and be sorted
in ascending order by time within each component within each domain,
which is an extension of the sorting requirement for the univariate 
model. Further details of the model specification are given under 
Details.
</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_d">D</code></td>
<td>
<p>The total number of domains.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_ti">TI</code></td>
<td>
<p>The number of time instances, typically years (constant for all 
domains).</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_vardir">vardir</code></td>
<td>
<p>For the univariate model, the sampling covariance matrix 
for the direct estimates of the <code>D*TI</code> elements of the dependent 
variable. The covariance matrix should be in the form of a square
matrix with <code>D*TI</code> rows and columns. Non-zero covariances between 
domains are not allowed, so the matrix must have a block diagonal form 
with <code>D</code> blocks, each of which is a square matrix with <code>TI</code> 
rows and columns. Note that within domain, non-zero covariances are
allowed over time. 
</p>
<p>Alternatively, <code>vardir</code> can be a list of 
<code>D</code> covariance matrices, each with <code>TI</code> rows and columns.  
</p>
<p>For the multivariate model, the square covariance matrix for the 
<code>D*NV*TI</code> elements of the dependent variables. The matrix must be
in the form of a square matrix with <code>D*NV*TI</code> rows and columns. The 
variances and covariances should be in the sort order of time within
dependent variable within domain. Non-zero covariances between domains 
are not allowed, but non-zero covariances may be present across time 
and between components. 
</p>
<p>Alternatively, <code>vardir</code> can be a list of
<code>D</code> covariance matrices, each with <code>NV*TI</code> rows and columns.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_method">method</code></td>
<td>
<p>Whether restricted maximum likelihood <code>REML</code> or 
maximum likelihood <code>ML</code> should be used.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_maxiter">MAXITER</code></td>
<td>
<p>The maximum number of iterations allowed for the 
Fisher-scoring algorithm.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_precision">PRECISION</code></td>
<td>
<p>The convergence tolerance limit for the 
Fisher-scoring algorithm.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables named in 
<code>formula</code>. By default the variables are taken from the 
environment from which <code>eblupDyn</code> is called. Because 
<code>vardir</code> will be of a different size than the variables
in <code>formula</code>, <code>data</code> will not be searched for
<code>vardir</code>.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_max.rho">max.rho</code></td>
<td>
<p>If not <code>NULL</code>, the maximum value allowed for 
<code>rho</code>. Note the different defaults for <code>eblupDyn</code> and
<code>eblupRY</code>.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_dampening">dampening</code></td>
<td>
<p>A multiplier of the computed update to parameters
after iteration 5. A value less than 1 may slow the iterations but 
lessens the chance of overshooting the optimum choice. The default 
values were determined experimentally, but may be modified.</p>
</td></tr>
<tr><td><code id="eblupDyn_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>dynRYfit</code> that affect
convergence, provide starting values, or request specific results. 
The exceptions are <code>y</code>, <code>X</code>, <code>NV</code>, <code>M</code>, 
<code>ncolx</code>, and <code>model</code>, which will be set by either
<code>eblupDyn</code> or <code>eblupRY</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical model has the form <code>response ~ terms</code> where <code>response</code>
is the (numeric) response vector and <code>terms</code> is a series of terms that
specifies a linear predictor for response. 
</p>
<p>A formula has an implied intercept term. To remove this use either 
y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> for more details of 
allowed formulae.
</p>
<p><code>eblupDyn</code> and <code>eblupRY</code> parse <code>formula</code> by calling core
R functions to determine <code>X</code>, then calling <code><a href="#topic+dynRYfit">dynRYfit</a></code>.
As a last step, <code>eblupDyn</code> or <code>eblupRY</code> finalize the list that 
they return.
</p>
<p>The additional parameters passed to <code><a href="#topic+dynRYfit">dynRYfit</a></code> may  
include <code>contrast.matrix</code>, which  specifies linear combinations 
of estimates within domains, such as the sum over dependent variables 
or moving averages across time. Corresponding MSE estimates are provided 
for the contrasts.
</p>
<p>The argument <code>ids</code> accepts a data frame with <code>D</code>
rows of domain identifiers. These ids are returned in the list from
<code>eblupDyn</code> or <code>eblupRY</code>. 
</p>
<p>If <code>iter.history</code> is set to <code>TRUE</code>, the returned object will 
include additional items with values of statistics at each step of the 
iteration; see <code><a href="#topic+dynRYfit">dynRYfit</a></code> for details on <code>delta.hist</code>, 
<code>llikelihood.hist</code>, <code>adj.hist</code>, <code>inf.mat.hist</code>,
<code>s.hist</code>, <code>ix.hist</code>, <code>adj.factor.hist</code>, and 
<code>warning.hist</code>. The default action
is to include the history only if the iterations fail, in which case
the history might suggest what went wrong. In the case of convergence,
the history is usually not of interest, in which case omitting it
reduces the size of the returned object.
</p>
<p>MSE estimation for REML for both the Rao-Yu and dynamic models follows
the results summarized in Rao and Molina (2015, pp. 98-111). The MSE estimates 
incorporate g1, g2, and g3 terms. Our simulations show that the REML estimates
have somewhat smaller MSEs than the ML estimates, but this is not reflected in 
the comparison of the estimated MSEs returned by the functions. The MSE 
estimates under REML perform quite well on average. The MSE estimates for ML 
use the same estimator as for REML, but they are modest underestimates of the 
true MSE in the same simulations.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eblup</code></td>
<td>
<p>In the univariate case, a vector of length <code>D*TI</code> with 
the eblup estimates. In the multivariate case, a data frame of D*TI rows 
and NV columns.</p>
</td></tr> 
<tr><td><code>fit</code></td>
<td>
<p>A list summarizing the fit of the model with the following:
</p>

<ul>
<li> <p><code>model:</code> form of the model: T - Dynamic or Rao-Yu; REML
or ML.
</p>
</li>
<li> <p><code>covergence:</code> a logical value indicating whether the 
convergence criterion was met.
</p>
</li>
<li> <p><code>iterations:</code> number of iterations performed by the 
Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef:</code> a data frame with the estimated model 
coefficients (<code>beta</code>) in the first column , 
their asymptotic standard errors (<code>std.error</code>) in the 
second column, the t statistics (<code>tvalue</code>) in the third column, 
and the p-values (<code>pvalue</code>) of the significance of each 
coefficient in last column.
</p>
</li>
<li> <p><code>estvarcomp:</code>  a data frame with the estimated values 
of the variances and correlation coefficients in the first column
(<code>estimate</code>) and their asymptotic standard errors in the 
second column (<code>std.error</code>).
</p>
</li>
<li> <p><code>goodness:</code> the log-likelihood and, if REML, the restricted 
log-likelihood.
</p>
</li></ul>

</td></tr>
<tr><td><code>parm</code></td>
<td>
<p>A labelled vector with the estimated variance components, 
correlations, and number of iterations.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>A labelled vector of coefficients of the model or models.</p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p>A data frame with <code>D</code> rows and one or more columns of 
numeric or character domain identifiers.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>An ordered vector of the variance components, which may be 
used as starting values for additional iterations, see 
<code>dynRYfit</code>.</p>
</td></tr>
<tr><td><code>eblup.mse</code></td>
<td>
<p>MSE estimates for eblup.</p>
</td></tr>
<tr><td><code>eblup.g1</code></td>
<td>
<p>The g1 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>eblup.g2</code></td>
<td>
<p>The g2 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>eblup.g3</code></td>
<td>
<p>The g3 term of the MSE estimate.</p>
</td></tr>
<tr><td><code>est.fixed</code></td>
<td>
<p>Estimates based on fixed effects only.</p>
</td></tr>
<tr><td><code>est.fixed.var</code></td>
<td>
<p>The variance-covariance matrix for the estimates in 
<code>coef</code>.</p>
</td></tr>
<tr><td><code>eblup.wt1</code></td>
<td>
<p>Weights given to the direct estimate in forming <code>eblup</code>.</p>
</td></tr>
<tr><td><code>eblup.wt2</code></td>
<td>
<p>Weights given to the direct estimate, including
effects through estimating the fixed effect coefficients.</p>
</td></tr>
<tr><td><code>contrast.est</code></td>
<td>
<p>Estimates requested by the specified contrasts.</p>
</td></tr>
<tr><td><code>contrast.mse</code></td>
<td>
<p>MSE estimates for <code>contrast.est</code>.</p>
</td></tr>
<tr><td><code>contrast.g1</code></td>
<td>
<p>The g1 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.g2</code></td>
<td>
<p>The g2 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.g3</code></td>
<td>
<p>The g3 term in the estimation of <code>contrast.mse</code>.</p>
</td></tr>
<tr><td><code>contrast.fixed.est</code></td>
<td>
<p>Contrast estimates based on the fixed effect 
model.</p>
</td></tr>
<tr><td><code>contrast.fixed.var</code></td>
<td>
<p>Variance estimates for the fixed effect model.</p>
</td></tr>
<tr><td><code>contrast.wt1</code></td>
<td>
<p>Weight wt1 given to the direct estimate in estimating 
the contrasts.</p>
</td></tr>
<tr><td><code>contrast.wt2</code></td>
<td>
<p>Weight wt2 in estimating the contrasts.</p>
</td></tr>
<tr><td><code>inf.mat</code></td>
<td>
<p>Information matrix for the components of <code>delta</code>.</p>
</td></tr>
<tr><td><code>var.coef</code></td>
<td>
<p>Variance covariance matrix for <code>coef</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The formula or list of formulas implemented.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert E. Fay, Mamadou Diallo
</p>


<h3>References</h3>

<p>- Fay, R.E. and Herriot, R.A. (1979). Estimation of income from small places: An application of James-Stein procedures to census data. Journal of the American Statistical Association 74, 269-277.
</p>
<p>- Fay, R.E., Planty, M. and Diallo, M.S. (2013). Small area estimates from the National Crime Victimization Survey. Proceedings of the Joint Statistical Meetings. American Statistical Association, pp. 1544-1557.
</p>
<p>- Rao, J.N.K. and Molina, I. (2015). Small Area Estimation, 2nd ed. Wiley, Hoboken, NJ.
</p>
<p>- Rao, J.N.K. and Yu, M. (1994). Small area estimation by combining time series and cross-sectional data. Canadian Journal of Statistics 22, 511-528.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- 20 # number of domains
TI &lt;- 5 # number of years
set.seed(1)
data &lt;- data.frame(Y= mvrnormSeries(D=D, TI=TI, rho.dyn=.9, sigma.v.dyn=1, 
   sigma.u.dyn=.19, sigma.e=diag(5)), X=rep(1:TI, times=D))
result.dyn  &lt;- eblupDyn(Y ~ X, D, TI, vardir = diag(100), data=data)
result.dyn$fit

require(sae)
data(spacetime)      # Load data set from sae package
data(spacetimeprox)  # Load proximity matrix 

D &lt;- nrow(spacetimeprox)            # number of domains
TI &lt;- length(unique(spacetime$Time)) # number of time instants
# Fit model ST with AR(1) time effects for each domain
resultST &lt;- eblupSTFH(Y ~ X1 + X2, D, TI, Var, spacetimeprox,
                      data=spacetime)
resultT  &lt;- eblupDyn(Y ~ X1 + X2, D, TI, vardir = diag(spacetime$Var),
                      data=spacetime, ids=spacetime$Area)
resultT.RY  &lt;- eblupRY(Y ~ X1 + X2, D, TI, vardir = diag(spacetime$Var),
                      data=spacetime, ids=spacetime$Area)
resultST$fit
resultT$fit
resultT.RY$fit
rowsT &lt;- seq(TI, TI*D, by=TI)
data.frame(Domain=spacetime$Area[rowsT], Y=spacetime$Y[rowsT], 
              EBLUP_ST=resultST$eblup[rowsT],
              EBLUB_Dyn=resultT$eblup[rowsT],
              EBLUP_RY=resultT.RY$eblup[rowsT])
</code></pre>

<hr>
<h2 id='geo_ratios'>Compute rates or ratios for a set of geographic entities over a set 
of years
</h2><span id='topic+geo_ratios'></span>

<h3>Description</h3>

<p>The function computes rates or ratios by a geographic code and 
the variable <code>Year</code>. If <code>designvars</code> is specified, the function 
also returns a data frame with linear substitutes to compute Taylor 
series variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_ratios(data,  geocode,  numerators,  denominators,  geonames, 
           new.names,  designvars)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geo_ratios_+3A_data">data</code></td>
<td>
<p>A data frame with the required variables, including a variable 
named <code>Year</code>.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_geocode">geocode</code></td>
<td>
<p>A character variable with the name of the geographic 
variable for which separate estimates are of interest.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_numerators">numerators</code></td>
<td>
<p>A character vector listing the names in <code>data</code> of the
numerators of the ratios.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_denominators">denominators</code></td>
<td>
<p>A character vector listing the names in <code>data</code> of 
the denominators of the ratios. If a single value is given,
it  will be used for all of the ratios.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_geonames">geonames</code></td>
<td>
<p>An optional data frame containing <code>geocode</code> and one or
more geographic variables, such as names, that will be merged
into the results. There should be only one row for each
value of <code>geocode</code>.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_new.names">new.names</code></td>
<td>
<p>An optional character vector of the same length as 
<code>numerators</code> naming the resulting ratios. 
If <code>new.names</code> is not specified, the output ratios
will have the same names as <code>numerators</code>.
</p>
</td></tr>
<tr><td><code id="geo_ratios_+3A_designvars">designvars</code></td>
<td>
<p>Optional. If given, a character vector naming one or more 
survey design variables in <code>data</code> to use in forming 
linear substitutes for variance calculation of the ratios 
cross-classified by <code>Year</code> and the variable named by 
<code>geocode</code>. The vector should not include the 
<code>geocode</code> variable or <code>Year</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For programming simplicity, the function enforces the requirement that names 
should not be repeated in either <code>numerators</code> or <code>new.names</code>. Names 
may be repeated in <code>denominators</code>.
</p>
<p>Rather than a typical survey file, the function expects the data frame 
<code>data</code> to contain weighted estimates for each analytic variable. As a 
simple example, to find the variance of the weighted mean of <code>y</code> with
weights <code>w</code>, <code>data</code> should contain <code>w</code> and 
<code>y * w</code>. For convenience, the weighted estimates can still be 
assigned their original names in <code>data</code>, such as <code>y</code>. In this 
case,
</p>
<p><code>numerators = y, denominators=w</code>
</p>
<p>would create the appropriate linear substitutes for the variance of the 
weighted mean.
</p>
<p>This design of the function allows complex possibilities, such as estimating
the variance of a rate where the numerator is based on one weight and the 
denominator is based on another. For example, estimation for the National 
Crime Victimization Survey requires this capability.
</p>


<h3>Value</h3>

<p>If <code>designvars</code> is not specified, a named list with one element,
a data frame containing the ratios sorted by <code>geocode</code>
and <code>Year</code>. 
</p>
<p>If <code>designvars</code> is specified, a second element is added 
to the list, a data frame giving the totals of the linear 
substitutes by <code>Year</code>, <code>geocode</code>, and 
<code>designvars</code>. The elements of the list are named 
<code>estimates</code> and <code>linear.subs</code>.               
</p>


<h3>Author(s)</h3>

<p>Robert E. Fay
</p>


<h3>References</h3>

<p>- Woodruff, R.S. (1971). A simple method for approximating the variance of a complex estimate. Journal of the American Statistical Association 66, 411-414.
</p>


<h3>See Also</h3>

<p><code>vcovgen</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survey)
require(MASS)
D &lt;- 20 # number of domains
T &lt;- 5 # number of years
samp &lt;- 16 # number of sample cases per domain
set.seed(1)
# use conditional.mean=TRUE to generate true small area values
# without sampling error
Y.list &lt;- mvrnormSeries(D=D, T=T, rho.dyn=.9, sigma.v.dyn=1, 
   sigma.u.dyn=.19, sigma.e=diag(5), conditional.mean=TRUE)
# generate sampling errors
e &lt;- rnorm(samp * T * D, mean=0, sd=4)
Y &lt;- Y.list[[2]] + tapply(e, rep(1:100, each=16), mean) 
data &lt;- data.frame(Y=Y, X=rep(1:T, times=D))
# model fit with the true sampling variances
result.dyn  &lt;- eblupDyn(Y ~ X, D, T, vardir = diag(100), data=data)
# individual level observations consistent with Y
Y2 &lt;- rep(Y.list[[2]], each=16) + e 
data2 &lt;- data.frame(Y=Y2, X=rep(rep(1:T, each=samp), times=D), 
                   Year=rep(rep(1:T, each=samp), times=D), 
                   weight=rep(1, times=samp*T*D),
                   d=rep(1:D, each=samp*T), 
                   strata=rep(1:(D*T), each=samp),
                   ids=1:(D*T*samp))
# geo_ratios with designvars specified
geo.results &lt;- geo_ratios(data2, geocode="d", numerators="Y",
                          denominators="weight",
                          designvars=c("strata", "ids"))
# illustrative check                          
max(abs(geo.results[[1]]$Y - Y))
vcov.list &lt;- vcovgen(geo.results[[2]], year.list=1:5, geocode="d", 
      designvars=c("strata", "ids"))
vcov.list[[1]]
# model fitted with directly estimated variance-covariances
result2.dyn &lt;- eblupDyn(Y ~ X, D, T, vardir=vcov.list, data=data)
cor(result.dyn$eblup, result2.dyn$eblup)
</code></pre>

<hr>
<h2 id='mvrnormSeries'>Generate data under the Dynamic or Rao-Yu Time Series Models</h2><span id='topic+mvrnormSeries'></span>

<h3>Description</h3>

<p>Function to generate data under a Rao-Yu time series model, a
dynamic model, or a mixture of both. The function can produce either
univariate or multivariate observations. All components of the returned
random variable have unconditional mean zero. The function calls 
<code>mvrnorm</code> in <span class="pkg">MASS</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrnormSeries(NV=1,  D,  TI,  sigma.e, 
   rho.dyn,  sigma.v.dyn,  sigma.u.dyn, rho.u.dyn, 
   rho.RY,   sigma.v.RY,   sigma.u.RY,   rho.u.RY,  tol=1e-6,
   conditional.mean=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrnormSeries_+3A_nv">NV</code></td>
<td>
<p>The number of variables.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_d">D</code></td>
<td>
<p>The number of domains.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_ti">TI</code></td>
<td>
<p>The number of time instances (constant for all domains).</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_sigma.e">sigma.e</code></td>
<td>
<p>The covariance matrix for the variation due to sampling,
specified either as a single square matrix with <code>NV*TI</code> rows and 
columns, or as a list of <code>D</code> matrices, each with <code>NV*TI</code> rows 
and columns. The rows should vary over <code>TI</code> more quickly than over
<code>NV</code>. Sampling covariances between domains are assumed to be zero.
</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_rho.dyn">rho.dyn</code></td>
<td>
<p>The temporal correlation parameter in the dynamic model.
This parameter is not a true correlation, however, and it may exceed 1.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_sigma.v.dyn">sigma.v.dyn</code></td>
<td>
<p>A vector of length <code>NV</code> with the v (nu) component
of the variance under the dynamic model. This component measures the
variance of the random effect at the beginning of the series.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_sigma.u.dyn">sigma.u.dyn</code></td>
<td>
<p>A vector of length <code>NV</code> with the u component
of the variance under the dynamic model.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_rho.u.dyn">rho.u.dyn</code></td>
<td>
<p>For <code>NV&gt;1</code>, the cross-sectional correlation(s) under
the model. The vector should specify <code>(NV*(NV-1))/2</code> correlations, in 
lower triangular form. For example, for <code>NV=3</code>, the 
correlations should be specified in the order (2,1), (3,1), (3,2).</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_rho.ry">rho.RY</code></td>
<td>
<p>The temporal correlation parameter in the Rao-Yu model. This
is a true correlation, unlike the parameter in the dynamic model.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_sigma.v.ry">sigma.v.RY</code></td>
<td>
<p>A vector of length <code>NV</code> with the v (nu) component
of the variance under the Rao-Yu model. This component reflects a constant
random effect for each domain unchanging over time.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_sigma.u.ry">sigma.u.RY</code></td>
<td>
<p>A vector of length <code>NV</code> with the u component
of the variance under the Rao-Yu model.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_rho.u.ry">rho.u.RY</code></td>
<td>
<p>For <code>NV&gt;1</code>, the cross-sectional correlation under
the model. The vector should specify <code>(NV*(NV-1))/2</code> correlations, in 
lower triangular form. For example, for <code>NV=3</code>, the 
correlations should be specified in the order (2,1), (3,1), (3,2).</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_tol">tol</code></td>
<td>
<p>A tolerance parameter used by <code>mvrnorm</code> in <span class="pkg">MASS</span> to
determine if the covariance matrix is non-singular.</p>
</td></tr>
<tr><td><code id="mvrnormSeries_+3A_conditional.mean">conditional.mean</code></td>
<td>
<p>If true, the function will also return the 
generated values of the random effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assembles the covariance matrix from the covariance matrix 
under the dynamic model (if specified), the Rao-Yu model (if specified)
and a required sampling covariance matrix.
</p>


<h3>Value</h3>

<p>If <code>conditional.mean=FALSE</code>, then for <code>NV=1</code>, a multivariate 
normal random vector with mean zero and length <code>D*TI</code>. 
For <code>NV&gt;1</code>, a matrix with <code>D*TI</code> rows and <code>NV</code> 
columns.
</p>
<p>If <code>conditional.mean=TRUE</code>, a list with the first element as above 
and a second element that is the sum of the random effects without
the sampling error. Simulation studies can evaluate the small area
estimates using the first element of the list as input against
the second element of the list, which is the target of the small area
estimation.            
</p>


<h3>Author(s)</h3>

<p>Robert E. Fay
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
mvrnormSeries(D=2, TI=5, sigma.e=diag(5), rho.dyn=.8,
    sigma.v.dyn=2, sigma.u.dyn=.72, conditional.mean=TRUE)
mvrnormSeries(NV=2, D=2, TI=5, sigma.e=diag(10), rho.dyn=.8,
    sigma.v.dyn=2, sigma.u.dyn=.72, rho.u.dyn=.8)
</code></pre>

<hr>
<h2 id='vcovgen'>Estimate variance/covariance matrices using linear substitutes 
</h2><span id='topic+vcovgen'></span>

<h3>Description</h3>

<p>The function computes estimates of variance/covariance 
matrices for sampling with replacement at the first stage
from a stratified sample, using the linear substitutes
produced by <code><a href="#topic+geo_ratios">geo_ratios</a></code>. The function produces a 
list of estimated covariance matrices corresponding the 
geographic areas identified by <code>geocode</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovgen(linear.subs, year.list, geocode, designvars)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcovgen_+3A_linear.subs">linear.subs</code></td>
<td>
<p>A data frame with linear substitutes for each
Y variable, <code>Year</code>, and the variables with
the names given by <code>geocode</code> and 
<code>designvars</code>.
</p>
</td></tr>
<tr><td><code id="vcovgen_+3A_year.list">year.list</code></td>
<td>
<p>A character or numeric vector of the years to 
include.
</p>
</td></tr>
<tr><td><code id="vcovgen_+3A_geocode">geocode</code></td>
<td>
<p>A character variable with the name of the geographic 
variable for which separate estimates are of interest.
</p>
</td></tr>
<tr><td><code id="vcovgen_+3A_designvars">designvars</code></td>
<td>
<p>A character vector of length 2, naming the strata 
and first-stage units.                    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reformats the second element of the list output from
<code>geo_ratios</code> in order to estimate covariances across time for 
each separate geographic area identified by the variable with the
name indicated by <code>geocode</code>. It then calls functions from the
<span class="pkg">survey</span> package to estimate covariances.
</p>
<p>See the example in <code><a href="#topic+geo_ratios">geo_ratios</a></code>.
</p>


<h3>Value</h3>

<p>A list of estimated covariance matrices, sorted by the geographic
names. The list may be used by <code>eblupDyn</code> or <code>eblupRY</code>, although
many applications require the estimated variance/covariance matrices to
be smoothed.
</p>


<h3>Author(s)</h3>

<p>Robert E. Fay
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
