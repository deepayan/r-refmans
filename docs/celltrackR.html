<!DOCTYPE html><html><head><title>Help for package celltrackR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {celltrackR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate.tracks'><p>Compute Summary Statistics of Subtracks</p></a></li>
<li><a href='#analyzeCellPairs'><p>Find Distances and Angles for all Pairs of Tracks</p></a></li>
<li><a href='#analyzeStepPairs'><p>Find Distances and Angles for all Pairs of Steps</p></a></li>
<li><a href='#AngleAnalysis'><p>Angle Analysis</p></a></li>
<li><a href='#angleCells'><p>Angle between Two Tracks</p></a></li>
<li><a href='#angleSteps'><p>Angle between Two Steps</p></a></li>
<li><a href='#angleToDir'><p>Angle with a Reference Direction</p></a></li>
<li><a href='#angleToPlane'><p>Angle with a Reference Plane</p></a></li>
<li><a href='#angleToPoint'><p>Angle with a Reference Point</p></a></li>
<li><a href='#applyStaggered'><p>Compute a Measure on a Track in a Staggered Fashion</p></a></li>
<li><a href='#as.data.frame.tracks'><p>Convert Tracks to Data Frame</p></a></li>
<li><a href='#as.list.tracks'><p>Convert from Tracks to List</p></a></li>
<li><a href='#as.tracks.data.frame'><p>Convert from Data Frame to Tracks</p></a></li>
<li><a href='#BCells'><p>Two-Photon Data: B Cells in a Lymph Node</p></a></li>
<li><a href='#beaucheminTrack'><p>Simulate a 3D Cell Track Using the Beauchemin Model</p></a></li>
<li><a href='#bootstrapTrack'><p>Simulate Tracks via Bootstrapping of Speed and Turning Angle from a Real Track Dataset</p></a></li>
<li><a href='#boundingBox'><p>Bounding Box of a Tracks Object</p></a></li>
<li><a href='#brownianTrack'><p>Simulate an Uncorrelated Random Walk</p></a></li>
<li><a href='#cellPairs'><p>Find Pairs of Tracks</p></a></li>
<li><a href='#celltrackR'><p>celltrackR: Quantitative analysis of motion.</p></a></li>
<li><a href='#cheatsheet'><p>Open the package cheat sheet</p></a></li>
<li><a href='#clusterTracks'><p>Cluster Tracks</p></a></li>
<li><a href='#distanceCells'><p>Minimum Distance between Two Cells</p></a></li>
<li><a href='#distanceSteps'><p>Distance between Two Steps</p></a></li>
<li><a href='#distanceToPlane'><p>Distance to a Reference Plane</p></a></li>
<li><a href='#distanceToPoint'><p>Distance to a Reference Point</p></a></li>
<li><a href='#filterTracks'><p>Filter Tracks</p></a></li>
<li><a href='#get.immap.metadata'><p>Get  Track Metadata from ImmuneMap</p></a></li>
<li><a href='#getFeatureMatrix'><p>Obtaining A Feature Matrix</p></a></li>
<li><a href='#hotellingsTest'><p>Test Unbiasedness of Motion</p></a></li>
<li><a href='#interpolateTrack'><p>Interpolate Track Positions</p></a></li>
<li><a href='#maxTrackLength'><p>Length of Longest Track</p></a></li>
<li><a href='#Neutrophils'><p>Two-Photon Data: Neutrophils responding to an infection in the ear</p></a></li>
<li><a href='#normalizeToDuration'><p>Normalize a Measure to Track Duration</p></a></li>
<li><a href='#normalizeTracks'><p>Normalize Tracks</p></a></li>
<li><a href='#pairsByTime'><p>Distance between pairs of tracks at every timepoint</p></a></li>
<li><a href='#plot.tracks'><p>Plot Tracks in 2D</p></a></li>
<li><a href='#plot3d'><p>Plot Tracks in 3D</p></a></li>
<li><a href='#plotTrackMeasures'><p>Bivariate Scatterplot of Track Measures</p></a></li>
<li><a href='#prefixes'><p>Get Track Prefixes</p></a></li>
<li><a href='#projectDimensions'><p>Extract Spatial Dimensions</p></a></li>
<li><a href='#read.tracks.csv'><p>Read Tracks from Text File</p></a></li>
<li><a href='#ReadImmuneMap'><p>Read tracks from ImmuneMap</p></a></li>
<li><a href='#repairGaps'><p>Process Tracks Containing Gaps</p></a></li>
<li><a href='#selectSteps'><p>Get Single Steps Starting at a Specific Time from a Subset of Tracks</p></a></li>
<li><a href='#selectTracks'><p>Select Tracks by Measure Values</p></a></li>
<li><a href='#simulateTracks'><p>Generate Tracks by Simulation</p></a></li>
<li><a href='#sort.tracks'><p>Sort Track Positions by Time</p></a></li>
<li><a href='#splitTrack'><p>Split Track into Multiple Tracks</p></a></li>
<li><a href='#staggered'><p>Staggered Version of a Function</p></a></li>
<li><a href='#stepPairs'><p>Find Pairs of Steps Occurring at the Same Time</p></a></li>
<li><a href='#subsample'><p>Subsample Track by Constant Factor</p></a></li>
<li><a href='#subtracks'><p>Decompose Track(s) into Subtracks</p></a></li>
<li><a href='#subtracksByTime'><p>Extract Subtracks Starting at a Specific Time</p></a></li>
<li><a href='#TCells'><p>Two-Photon Data: T Cells in a Lymph Node</p></a></li>
<li><a href='#timePoints'><p>Find All Unique Time Points in a Track Dataset</p></a></li>
<li><a href='#timeStep'><p>Compute Time Step of Tracks</p></a></li>
<li><a href='#trackFeatureMap'><p>Dimensionality Reduction on Track Features</p></a></li>
<li><a href='#TrackMeasures'><p>Track Measures</p></a></li>
<li><a href='#tracks'><p>Tracks Objects</p></a></li>
<li><a href='#vecAngle'><p>Angle Between Two Vectors</p></a></li>
<li><a href='#wrapTrack'><p>Create Track Object from Single Track</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Motion Trajectory Analysis</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-25</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Johannes Textor [aut, cre],
  Katharina Dannenberg [aut],
  Jeffrey Berry [aut],
  Gerhard Burger [aut],
  Annie Liu [aut],
  Mark Miller [aut],
  Inge Wortel [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johannes Textor &lt;johannes.textor@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for analyzing (cell) motion in two or three dimensions.
	Available measures include displacement, confinement ratio, autocorrelation,
	straightness, turning angle, and fractal dimension. Measures can be applied to entire tracks,
	steps, or subtracks with varying length. While the methodology has been developed for
	cell trajectory analysis, it is applicable to anything that moves including animals,
	people, or vehicles.
	Some of the methodology implemented in this packages was described by: 
	Beauchemin, Dixit, and Perelson (2007) &lt;<a href="https://doi.org/10.4049%2Fjimmunol.178.9.5505">doi:10.4049/jimmunol.178.9.5505</a>&gt;, 
	Beltman, Maree, and de Boer (2009) &lt;<a href="https://doi.org/10.1038%2Fnri2638">doi:10.1038/nri2638</a>&gt;,
	Gneiting and Schlather (2004) &lt;<a href="https://doi.org/10.1137%2FS0036144501394387">doi:10.1137/S0036144501394387</a>&gt;,
	Mokhtari, Mech, Zitzmann, Hasenberg, Gunzer, and Figge (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0080808">doi:10.1371/journal.pone.0080808</a>&gt;,
	Moreau, Lemaitre, Terriac, Azar, Piel, Lennon-Dumenil, and Bousso (2012) &lt;<a href="https://doi.org/10.1016%2Fj.immuni.2012.05.014">doi:10.1016/j.immuni.2012.05.014</a>&gt;,
	Textor, Peixoto, Henrickson, Sinn, von Andrian, and Westermann (2011) &lt;<a href="https://doi.org/10.1073%2Fpnas.1102288108">doi:10.1073/pnas.1102288108</a>&gt;,
  Textor, Sinn, and de Boer (2013) &lt;<a href="https://doi.org/10.1186%2F1471-2105-14-S6-S10">doi:10.1186/1471-2105-14-S6-S10</a>&gt;,
  Textor, Henrickson, Mandl, von Andrian, Westermann, de Boer, and Beltman (2014) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1003752">doi:10.1371/journal.pcbi.1003752</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.motilitylab.net">http://www.motilitylab.net</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics, utils, ellipse, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scatterplot3d, fractaldim, testthat, wordspace, knitr,
rmarkdown, RSpectra, uwot, dendextend, ggplot2, ggbeeswarm,
gridExtra, mvtnorm, rjson</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 10:30:04 UTC; ingewortel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate.tracks'>Compute Summary Statistics of Subtracks</h2><span id='topic+aggregate.tracks'></span><span id='topic+aggregate'></span>

<h3>Description</h3>

<p>Computes a given measure on subtracks of a given track set, applies a summary
statistic for each subtrack length, and returns the results in a convenient form.
This important workhorse function facilitates many common motility analyses
such as mean square displacement, turning angle, and autocorrelation plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tracks'
aggregate(
  x,
  measure,
  by = "subtracks",
  FUN = mean,
  subtrack.length = seq(1, (maxTrackLength(x) - 1)),
  max.overlap = max(subtrack.length),
  na.rm = FALSE,
  filter.subtracks = NULL,
  count.subtracks = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.tracks_+3A_x">x</code></td>
<td>
<p>the tracks object whose subtracks are to be considered.
If a single track is given, it will be coerced to a tracks object
using <code><a href="#topic+wrapTrack">wrapTrack</a></code> (but note that this requires an explicit call
<code>aggregate.tracks</code>).</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_measure">measure</code></td>
<td>
<p>the measure that is to be computed on the subtracks.</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_by">by</code></td>
<td>
<p>a string that indicates how grouping is performed. Currently, two
kinds of grouping are supported:
</p>

<ul>
<li><p> &quot;subtracks&quot;  Apply <code>measure</code> to all subtracks according to
the parameters <code>subtrack.length</code> and <code>max.overlap</code>.
</p>
</li>
<li><p> &quot;prefixes&quot;   Apply <code>measure</code> to all prefixes (i.e., subtracks starting
from a track's initial position) according to the parameter <code>subtrack.length</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_fun">FUN</code></td>
<td>
<p>a summary statistic to be computed on the measures of subtracks with the
same length. Can be a function or a string.
If a string is given, it is first matched to the following builtin values:
</p>

<ul>
<li><p> &quot;mean.sd&quot;  Outputs the mean and <code class="reqn">mean - sd</code> as lower and
<code class="reqn">mean + sd</code> as upper bound 
</p>
</li>
<li><p> &quot;mean.se&quot; Outputs the mean and <code class="reqn">mean - se</code> as lower and
<code class="reqn">mean + se</code> as upper bound 
</p>
</li>
<li><p> &quot;mean.ci.95&quot; Outputs the mean and upper and lower bound of a
parametric 95 percent confidence interval.
</p>
</li>
<li><p> &quot;mean.ci.99&quot; Outputs the mean and upper and lower bound of a
parametric 95 percent confidence intervall.
</p>
</li>
<li><p> &quot;iqr&quot; Outputs the interquartile range, that is, the median, and the
25-percent-quartile as a lower and and the 75-percent-quartile as an
upper bound
</p>
</li></ul>

<p>If the string is not equal to any of these, it is passed on to
<code><a href="base.html#topic+match.fun">match.fun</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_subtrack.length">subtrack.length</code></td>
<td>
<p>an integer or a vector of integers defining which subtrack
lengths are considered. In particular, <code>subtrack.length=1</code>
corresponds to a &quot;step-based analysis&quot; (Beltman et al, 2009).</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_max.overlap">max.overlap</code></td>
<td>
<p>an integer controlling what to do with overlapping subtracks.
A maximum overlap of <code>max(subtrack.length)</code> will imply
that all subtracks are considered. For a maximum overlap of 0, only non-overlapping
subtracks are considered. A negative overlap can be used to ensure that only subtracks
a certain distance apart are considered. In general, for non-Brownian motion there will
be correlations between subsequent steps, such that a negative overlap may be necessary
to get a proper error estimate.</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then <code>NA</code>'s and <code>NaN</code>'s
are removed prior to computing the summary statistic.</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_filter.subtracks">filter.subtracks</code></td>
<td>
<p>a function that can be supplied to exclude certain subtracks
from an analysis. For instance, one may wish to compute angles only between steps of
a certain minimum length (see Examples).</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_count.subtracks">count.subtracks</code></td>
<td>
<p>logical. If <code>TRUE</code>, the returned dataframe contains an
extra column <code>ntracks</code> showing the number of subtracks of each length. This is 
useful to keep track of since the returned <code>value</code> estimates for high 
<code>i</code> are often based on very few subtracks.</p>
</td></tr>
<tr><td><code id="aggregate.tracks_+3A_...">...</code></td>
<td>
<p>further arguments passed to or used by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every number of segments <code class="reqn">i</code> in the set defined by
<code>subtrack.length</code>, all subtracks of any track in the input
<code>tracks</code> object that consist of exactly <code class="reqn">i</code> segments are
considered. The input <code>measure</code> is applied to the subtracks individually,
and the <code>statistic</code> is applied to the resulting values.
</p>


<h3>Value</h3>

<p>A data frame with one row for every <code class="reqn">i</code>
specified by <code>subtrack.length</code>. The first column contains the values
of <code class="reqn">i</code> and the remaining columns contain the values of the summary statistic
of the measure values of tracks having exactly <code class="reqn">i</code> segments.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A mean square displacement plot with error bars.
dat &lt;- aggregate(TCells, squareDisplacement, FUN="mean.se")
with( dat ,{
  plot( mean ~ i, xlab="time step",
  	ylab="mean square displacement", type="l" )
  segments( i, lower, y1=upper )
} )

## Note that the values at high i are often based on very few subtracks:
msd &lt;- aggregate( TCells, squareDisplacement, count.subtracks = TRUE )
tail( msd )

## Compute a turning angle plot for the B cell data, taking only steps of at least
## 1 micrometer length into account
check &lt;- function(x) all( sapply( list(head(x,2),tail(x,2)), trackLength ) &gt;= 1.0 )
plot( aggregate( BCells, overallAngle, subtrack.length=1:10,
  filter.subtracks=check )[,2], type='l' )

## Compare 3 different variants of a mean displacement plot
# 1. average over all subtracks
plot( aggregate( TCells, displacement ), type='l' )
# 2. average over all non-overlapping subtracks
lines( aggregate( TCells, displacement, max.overlap=0 ), col=2 )
# 3. average over all subtracks starting at 1st position
lines( aggregate( TCells, displacement, by="prefixes" ), col=3 )

</code></pre>

<hr>
<h2 id='analyzeCellPairs'>Find Distances and Angles for all Pairs of Tracks</h2><span id='topic+analyzeCellPairs'></span>

<h3>Description</h3>

<p>Find all pairs of cells and return the shortest distance between them at any
point in time (if they share any time points), as well as the angle between 
their overall displacement vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeCellPairs(X, searchRadius = Inf, quietly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeCellPairs_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="analyzeCellPairs_+3A_searchradius">searchRadius</code></td>
<td>
<p>if specified, only return analysis for pairs of cells that
are within distance searchRadius from each other at least at one point in time.</p>
</td></tr>
<tr><td><code id="analyzeCellPairs_+3A_quietly">quietly</code></td>
<td>
<p>(default FALSE) if TRUE, suppress warnings</p>
</td></tr>
<tr><td><code id="analyzeCellPairs_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>angleCells</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analyzing track angles at different distances can be useful to detect
directional bias or local crowding effects; see (Beltman et al, 2009).
</p>
<p>Internally, the function uses <code><a href="#topic+cellPairs">cellPairs</a></code>, <code><a href="#topic+angleCells">angleCells</a></code>,
and <code><a href="#topic+distanceCells">distanceCells</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe with four columns: two for the indices of cellpairs,
one for the distance between them, and one for their angle. Note that the 
distance will be NA for pairs of tracks that do not share time points, but
their angle will still be computed.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyzeStepPairs">analyzeStepPairs</a></code> to do something similar for single steps
rather than entire tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot distance versus angle for all cell pairs. Sample T-cell data here for speed.
pairs &lt;- analyzeCellPairs( sample( TCells, 100 ) )
scatter.smooth( pairs$dist, pairs$angle )
</code></pre>

<hr>
<h2 id='analyzeStepPairs'>Find Distances and Angles for all Pairs of Steps</h2><span id='topic+analyzeStepPairs'></span>

<h3>Description</h3>

<p>Find cell indices and timepoints where these cells both have a step, then return
angles and distances for each pair of steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeStepPairs(
  X,
  filter.steps = NULL,
  searchRadius = Inf,
  quietly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeStepPairs_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="analyzeStepPairs_+3A_filter.steps">filter.steps</code></td>
<td>
<p>optional: a function used to filter steps on. See examples.</p>
</td></tr>
<tr><td><code id="analyzeStepPairs_+3A_searchradius">searchRadius</code></td>
<td>
<p>if specified, only return analysis for pairs of steps that
start within distance searchRadius from each other</p>
</td></tr>
<tr><td><code id="analyzeStepPairs_+3A_quietly">quietly</code></td>
<td>
<p>(default FALSE) if TRUE, suppress warnings</p>
</td></tr>
<tr><td><code id="analyzeStepPairs_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>angleSteps</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analyzing step angles at different distances can be useful to detect
directional bias or local crowding effects; see (Beltman et al, 2009).
</p>
<p>Internally, the function uses <code><a href="#topic+stepPairs">stepPairs</a></code>, <code><a href="#topic+angleSteps">angleSteps</a></code>,
and <code><a href="#topic+distanceSteps">distanceSteps</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe with five columns: two for the indices of cellpairs that
share a step, one for the timepoint at which they do so, one for the distance
between them, and one for their angle.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyzeCellPairs">analyzeCellPairs</a></code> to do something similar for entire tracks
rather than single steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot distance versus angle for all step pairs, filtering for those that
## displace at least 2 microns. Sample dataset in this example for speed.
pairs &lt;- analyzeStepPairs( sample( TCells, 100), filter.steps = function(t) displacement(t) &gt; 2 )
scatter.smooth( pairs$dist, pairs$angle )
</code></pre>

<hr>
<h2 id='AngleAnalysis'>Angle Analysis</h2><span id='topic+AngleAnalysis'></span>

<h3>Description</h3>

<p>Analyzing angles to reference directions, points, or planes can be useful to detect
artefacts and/or directionality in tracking datasets (Beltman et al, 2009). All these
functions take a track and a reference (point/direction/plane)
as input and return a distance or angle as output. Angles/distances are by default
computed to the first step in the given track.
</p>


<h3>Details</h3>

<p><code><a href="#topic+angleToPoint">angleToPoint</a></code> and <code><a href="#topic+distanceToPoint">distanceToPoint</a></code> return the angle/distance of the track to the
reference point. The distance returned is between the first coordinate in the track and the
reference point. The angle is between the overall displacement vector of the track and the
vector from its first coordinate to the reference point. Angles are by default returned in
degrees, use <code>degrees=FALSE</code> to obtain radians. These functions are useful to detect
directional bias towards a point of interest, which would result in an average angle of less
than 90 degrees with the reference point (especially for tracks at a small distance to the
reference point).
</p>
<p><code><a href="#topic+angleToPlane">angleToPlane</a></code> and <code><a href="#topic+distanceToPlane">distanceToPlane</a></code> return the angle/distance of the track to a
plane of interest. This plane must be specified by three points lying on it.
The distance returned is between the first coordinate in the track and the
reference point. The angle is between the overall displacement vector of the track and the
plane of interest. These functions are useful to detect tracking artefacts near the borders
of the imaging volume. Use <code><a href="#topic+boundingBox">boundingBox</a></code> to guess where those borders are.
Angles are by default returned in
degrees, use <code>degrees=FALSE</code> to obtain radians.
</p>
<p><code><a href="#topic+angleToDir">angleToDir</a></code> returns the angle of a track's overall displacement vector 
to a direction of interest.
This function is useful to detect directionality in cases where the direction of the bias is
known in advance (e.g. when cells are known to move up a chemotactic gradient): in that case,
the average angle to the reference direction should be less than 90 degrees. Angles are
by default returned in degrees, use <code>degrees=FALSE</code> to obtain radians.
</p>
<p><code><a href="#topic+angleSteps">angleSteps</a></code> and <code><a href="#topic+distanceSteps">distanceSteps</a></code> return the angle/distance between a pair
of steps in the data that occur at the same timepoint. Angles are in degrees by default,
use <code>degrees=FALSE</code> to obtain radians. Use <code><a href="#topic+stepPairs">stepPairs</a></code> to extract all pairs of
steps that occur at the same timepoint, and use <code><a href="#topic+analyzeStepPairs">analyzeStepPairs</a></code> to do this and then
also obtain the angles and distances for each of these pairs.
</p>
<p><code><a href="#topic+angleCells">angleCells</a></code> and <code><a href="#topic+distanceCells">distanceCells</a></code> return the angle/distance between a pair
of tracks in the data. The computed angles are between the overall displacement vectors of the
tracks, the distance is the shortest distance between them at any timepoint they share.
Angles are in degrees by default, use <code>degrees=FALSE</code> to obtain radians.
Use <code><a href="#topic+cellPairs">cellPairs</a></code> to extract all pairs of
cells in the data, and use <code><a href="#topic+analyzeCellPairs">analyzeCellPairs</a></code> to do this and then
also obtain the angles and distances for each of these pairs.
</p>


<h3>Value</h3>

<p>This page is for documentation only and provides an overview of angle analysis functions
and their use cases. The return values of each of these functions are documented separately;
please follow the link to the documentation page of that specific function.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TrackMeasures">TrackMeasures</a></code> for other measures that can be used to quantify tracks.
</p>
<p>See the vignettes on Quality Control and Track Analysis for more detailed examples of
angle analyses.
<code>browseVignettes( package = "celltrackR" )</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting the angle versus the distance to a reference point can be informative to
## detect biased movement towards that point. We should be suspicious especially
## when small angles are more frequent at lower distances.
steps &lt;- subtracks( sample( Neutrophils, 50 ), 1 )
bb &lt;- boundingBox( Neutrophils )
angles &lt;- sapply( steps, angleToPoint, p = bb["max",-1] )
distances &lt;- sapply( steps, distanceToPoint, p = bb["max",-1] )
scatter.smooth( distances, angles )
abline( h = 90, col = "red" )

## Get a distribution of Neutrophil step angles with the reference direction
## in positive y direction. The histogram is enriched for low angles, suggesting
## directed movement:
hist( sapply( steps, angleToDir, dvec=c(1,-1) ) )

## Plotting the angle versus the distance to a reference plane can be informative to
## detect tracking artefacts near the border of the imaging volume.
## We should be suspicious especially when small angles are more frequent at low distances
## to the border planes; as is the case in the z-dimension for the raw data:
load( system.file("extdata", "TCellsRaw.rda", package="celltrackR" ) )
steps &lt;- subtracks( sample( TCellsRaw, 50 ), 1 )
minz &lt;- boundingBox( TCellsRaw )["min","z"]
## Compute angles and distances to the lower plane in z-dimension
angles &lt;- sapply( steps, angleToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
distances &lt;- sapply( steps, distanceToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
scatter.smooth( distances, angles )
abline( h = 32.7, col = "red" )

## Plot distance versus angle for all cell pairs (here in only a sample to speed things up)
pairs &lt;- analyzeCellPairs( sample( TCells, 50 ) )
scatter.smooth( pairs$dist, pairs$angle )
abline( h = 90, col = "red" )

## Plot distance versus angle for all step pairs, filtering for those that
## displace at least 2 microns
pairs &lt;- analyzeStepPairs( sample( TCells, 50 ), filter.steps = function(t) displacement(t) &gt; 2 )
scatter.smooth( pairs$dist, pairs$angle )
abline( h = 90, col = "red" )


</code></pre>

<hr>
<h2 id='angleCells'>Angle between Two Tracks</h2><span id='topic+angleCells'></span>

<h3>Description</h3>

<p>Compute the angle between the displacement vectors of two tracks in the dataset,
or of several such pairs at once.
Note that in contrast to <code><a href="#topic+distanceCells">distanceCells</a></code>, this angle is computed even
when the two tracks do not share any time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleCells(X, cellids, degrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angleCells_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="angleCells_+3A_cellids">cellids</code></td>
<td>
<p>a vector of two indices specifying the tracks to get steps from, or
a dataframe/matrix of two columns (where every row contains a pair of cellids to compute 
an angle for)</p>
</td></tr>
<tr><td><code id="angleCells_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angle be returned in degrees instead of radians? (defaults to <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single angle (if two cellids given), or a vector of angles (if multiple pairs of cellids are supplied).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceCells">distanceCells</a></code> to compute the minimum distance between the tracks,
and <code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find the angle between the tracks with ids 1 and 3
angleCells( TCells, c("1","3") )

## Find the angles of several cell pairs at once
pairs &lt;- data.frame( cell1 = c("1","1"), cell2 = c( "3","4" ) )
angleCells( TCells, pairs )
</code></pre>

<hr>
<h2 id='angleSteps'>Angle between Two Steps</h2><span id='topic+angleSteps'></span>

<h3>Description</h3>

<p>Compute the angle between two steps in the dataset that occur at the same timepoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleSteps(X, trackids, t, degrees = TRUE, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angleSteps_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="angleSteps_+3A_trackids">trackids</code></td>
<td>
<p>a vector of two indices specifying the tracks to get steps from, or
a dataframe/matrix of two columns (where every row contains a pair of trackids to compute 
a step angle for)</p>
</td></tr>
<tr><td><code id="angleSteps_+3A_t">t</code></td>
<td>
<p>the timepoint at which the steps should start, or a vector of timepoints if trackids
is a matrix with multiple step pairs to compute angles for.</p>
</td></tr>
<tr><td><code id="angleSteps_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angle be returned in degrees instead of radians? (defaults to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="angleSteps_+3A_quietly">quietly</code></td>
<td>
<p>logical; should a warning be returned if one or both of the steps are missing
in the data and the function returns NA?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single angle, or NA if the desired step is missing for one or both
of the tracks. If trackids is a matrix with multiple step pairs to compute angles for,
the output is a numeric vector of angles (or NA values).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceSteps">distanceSteps</a></code> to compute the distance between the step starting
points, <code><a href="#topic+timePoints">timePoints</a></code> to list all timepoints in a dataset,
and <code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find the angle between the steps of the tracks with ids 1 and 2, at the 3rd
## timepoint in the dataset.
t &lt;- timePoints( TCells )[3]
angleSteps( TCells, c("1","3"), t )

## Do this for multiple pairs and times at once: between cells 1 and 3 at the
## 3rd timepoint, and between 1 and 4 at the fourth timepoint.
pairs &lt;- data.frame( cell1 = c("1","1"), cell2 = c("3","4"))
times &lt;- timePoints(TCells)[3:4]
angleSteps( TCells, pairs, times )
</code></pre>

<hr>
<h2 id='angleToDir'>Angle with a Reference Direction</h2><span id='topic+angleToDir'></span>

<h3>Description</h3>

<p>Compute the angle between a track's overall displacement and a reference direction.
Useful to detect biased movement when the directional bias is known (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleToDir(x, dvec = c(1, 1, 1), from = 1, degrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angleToDir_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="angleToDir_+3A_dvec">dvec</code></td>
<td>
<p>numeric vector specifying a reference direction to compute angles to.</p>
</td></tr>
<tr><td><code id="angleToDir_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track. If
<code>from</code> is a vector, angles are returned for all steps starting at
the indices in <code>from</code>.</p>
</td></tr>
<tr><td><code id="angleToDir_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angles be returned in degrees rather than radians? (default = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average angle of steps to a reference direction should be 90 degrees if there is
no bias towards movement in the direction of the reference point. If there is such a bias,
there should be an enrichment of smaller angles. The expected distribution without bias
is a uniform distribution in 2D or a sine distribution in 3D (Beltman et al, 2009).
</p>


<h3>Value</h3>

<p>A single angle.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get a distribution of Neutrophil step angles with the reference direction in positive
## y direction. The histogram is enriched for low angles, suggesting directed movement:
steps &lt;- subtracks( Neutrophils, 1 )
hist( sapply( steps, angleToDir, dvec=c(1,-1) ) )
</code></pre>

<hr>
<h2 id='angleToPlane'>Angle with a Reference Plane</h2><span id='topic+angleToPlane'></span>

<h3>Description</h3>

<p>Compute the angle between a track's overall displacement and a reference plane.
Useful to detect directed movement and/or tracking artefacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleToPlane(
  x,
  p1 = c(0, 0, 0),
  p2 = c(0, 1, 0),
  p3 = c(1, 0, 0),
  from = 1,
  degrees = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angleToPlane_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="angleToPlane_+3A_p1">p1</code>, <code id="angleToPlane_+3A_p2">p2</code>, <code id="angleToPlane_+3A_p3">p3</code></td>
<td>
<p>numeric vectors of coordinates of three points specifying a reference plane to
compute distances to.</p>
</td></tr>
<tr><td><code id="angleToPlane_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track. If
<code>from</code> is a vector, angles are returned for all steps starting at
the indices in <code>from</code>.</p>
</td></tr>
<tr><td><code id="angleToPlane_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angles be returned in degrees rather than radians? (default = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average angle of steps to a reference plane should be roughly 32.7 degrees.
Lower angles to the border planes of an imaging volume can be indicative of tracking
artefacts, and systematic deviations from 32.7 can indicate a directional bias
(Beltman et al, 2009).
</p>


<h3>Value</h3>

<p>A single angle.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceToPlane">distanceToPlane</a></code> to compute the distance to the reference plane, and
<code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting the angle versus the distance to a reference plane can be informative to
## detect tracking artefacts near the border of the imaging volume.
## We should be suspicious especially when small angles are more frequent at low distances
## to the border planes.
load( system.file("extdata", "TCellsRaw.rda", package="celltrackR" ) )
steps &lt;- subtracks( TCellsRaw, 1 )
minz &lt;- boundingBox( TCellsRaw )["min","z"]
## Compute angles and distances to the lower plane in z-dimension
angles &lt;- sapply( steps, angleToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
distances &lt;- sapply( steps, distanceToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
scatter.smooth( distances, angles )
abline( h = 32.7, col = "red" )
</code></pre>

<hr>
<h2 id='angleToPoint'>Angle with a Reference Point</h2><span id='topic+angleToPoint'></span>

<h3>Description</h3>

<p>Compute the angle between a track's overall displacement vector and the vector from
it's first coordinate to a reference point. Useful to
detect directed movement towards a point (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleToPoint(x, p = c(1, 1, 1), from = 1, degrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angleToPoint_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="angleToPoint_+3A_p">p</code></td>
<td>
<p>numeric vector of coordinates of the reference point p to compute angles/distances to.</p>
</td></tr>
<tr><td><code id="angleToPoint_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track. If
<code>from</code> is a vector, angles are returned for all steps starting at
the indices in <code>from</code>.</p>
</td></tr>
<tr><td><code id="angleToPoint_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angles be returned in degrees rather than radians? (default = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average angle of steps to a reference point should be 90 degrees if there is
no bias towards movement in the direction of the reference point. If there is such a bias,
there should be an enrichment of smaller angles. The expected distribution without bias
is a uniform distribution in 2D or a sine distribution in 3D (Beltman et al, 2009).
</p>


<h3>Value</h3>

<p>A single angle.
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceToPoint">distanceToPoint</a></code> to compute the distance to the reference point, and
<code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get a distribution of step angles with a reference point
## Use bb to get the corner with highest x,y (,z) value
## The histogram is enriched for low angles, suggesting directed movement:
steps &lt;- subtracks( Neutrophils, 1 )
bb &lt;- boundingBox( Neutrophils )
hist( sapply( steps, angleToPoint, p = bb["max",-1] ) )

## The same does not hold for movement of T cells towards the point (0,0)
steps &lt;- subtracks( TCells, 1 )
hist( sapply( steps, angleToPoint, p = c(0,0) ) )

## Plotting the angle versus the distance to the reference point can also be informative,
## especially when small angles are more frequent at lower distances.
angles &lt;- sapply( steps, angleToPoint, p = bb["max",-1] )
distances &lt;- sapply( steps, distanceToPoint, p = bb["max",-1] )
scatter.smooth( distances, angles )
abline( h = 90, col = "red" )
</code></pre>

<hr>
<h2 id='applyStaggered'>Compute a Measure on a Track in a Staggered Fashion</h2><span id='topic+applyStaggered'></span>

<h3>Description</h3>

<p>Computes a measure on all subtracks of a track and return them either
as a matrix or return their mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyStaggered(x, measure, matrix = FALSE, min.segments = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyStaggered_+3A_x">x</code></td>
<td>
<p>the track for which the measure is to be computed.</p>
</td></tr>
<tr><td><code id="applyStaggered_+3A_measure">measure</code></td>
<td>
<p>the measure that is to be computed.</p>
</td></tr>
<tr><td><code id="applyStaggered_+3A_matrix">matrix</code></td>
<td>
<p>a logical indicating whether the whole matrix of values for
the measure for each of the input track's subtracks is to be returned.
Otherwise only the mean is returned.</p>
</td></tr>
<tr><td><code id="applyStaggered_+3A_min.segments">min.segments</code></td>
<td>
<p>the number of segments that each regarded subtrack
should at least consist of. Typically, this value would be set to the
minimum number of segments that a (sub)track must have in order for the
measure to be decently computed. For example, at least two segments are needed
to compute the <code><a href="#topic+overallAngle">overallAngle</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure is computed for each of the input track's subtracks of
length at least <code>min.segments</code>, and the resulting values are either
returned in a matrix (if <code>matrix</code> is set), or their mean is returned.
The computed matrix is symmetric since the direction along which a
track is traversed is assumed not to matter. The values at
<code>[i, i + j]</code>, where j is a nonnegative integer with
<code class="reqn">j &lt; </code><code>min.segments</code>, (with the default value <code>min.segments=1</code>
this is exactly the main diagonal) are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>If <code>matrix</code> is set, a matrix with the values of the measure for
all the input track's subtracks is returned. The value of this matrix at
position <code>[i, j]</code> corresponds to the subtrack that starts with the input track's
<code class="reqn">j</code>th point and ends at its <code class="reqn">i</code>th. Thus, with increasing column number,
the regarded subtrack's starting point is advanced on the original track,
and the values for increasingly long subtracks starting from this point can
be found columnwise below the main diagonal, respectively.
If 'matrix' is not set, the mean over the values of the measure for all
subtracks of at least 'min.segments' segments is retruned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the staggered matrix for overallAngle applied to all long enough
## subtracks of the first T cell track
applyStaggered(TCells[[1]], overallAngle, matrix=TRUE, min.segments = 2)
</code></pre>

<hr>
<h2 id='as.data.frame.tracks'>Convert Tracks to Data Frame</h2><span id='topic+as.data.frame.tracks'></span>

<h3>Description</h3>

<p>Converts tracks from the list-of-matrices format, which is good
for efficient processing and therefore the default in this package, to a
single dataframe which is convenient for plotting or saving the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tracks'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  include.timepoint.column = FALSE,
  idsAsFactors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.tracks_+3A_x">x</code></td>
<td>
<p>the <code>tracks</code> object to be coerced to a data frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.tracks_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving row names for the
data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.tracks_+3A_optional">optional</code></td>
<td>
<p>logical. Required for S3 consistency, but
has no effect: column names are always assigned to the resulting
data frame regardless of the setting of this option.</p>
</td></tr>
<tr><td><code id="as.data.frame.tracks_+3A_include.timepoint.column">include.timepoint.column</code></td>
<td>
<p>logical. If set to <code>TRUE</code>, then the resulting
dataframe will contain a column that consecutively numbers the positions according
to their time. Note that this information is anyway implicitly present in the time
information.</p>
</td></tr>
<tr><td><code id="as.data.frame.tracks_+3A_idsasfactors">idsAsFactors</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the id column of the resulting
dataframe will be a factor column, otherwise a characeter column.</p>
</td></tr>
<tr><td><code id="as.data.frame.tracks_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single data frame containing all individual tracks from the input with a
prepended column named &quot;id&quot; containing each track's identifier in 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Display overall average position of the T cell data
colMeans( as.data.frame( TCells )[-c(1,2)] )
</code></pre>

<hr>
<h2 id='as.list.tracks'>Convert from Tracks to List</h2><span id='topic+as.list.tracks'></span>

<h3>Description</h3>

<p>Coerces a <code>tracks</code> object to a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tracks'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.tracks_+3A_x">x</code></td>
<td>
<p>the <code>tracks</code> object to be coerced to a list.</p>
</td></tr>
<tr><td><code id="as.list.tracks_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generic list of single tracks, where each track is a matrix with 
<code>t/delta.t</code> rows and 4 columns. This looks a lot like a tracks object,
except that its class is not &quot;tracks&quot; anymore.
</p>

<hr>
<h2 id='as.tracks.data.frame'>Convert from Data Frame to Tracks</h2><span id='topic+as.tracks.data.frame'></span>

<h3>Description</h3>

<p>Get cell tracks from a data.frame. Data are expected to be organized as
follows.
One column contains a track identifier, which can be numeric or a string, and
determines which points belong to the same track.
Another column is expected to contain a time index or a time period (e.g. number of
seconds elapsed since the beginning of the track, or since the beginning of the
experiment). Input of dates is not (yet) supported, as absolute time information is
frequently not available.
Further columns contain the spatial coordinates. If there are three or less spatial
coordinates, their names will by &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;
(depending on whether the tracks are 1D, 2D or 3D). If there are four or more spatial
coordinates, their names will be &quot;x1&quot;, &quot;x2&quot;, and so on.
The names or indices of these columns in the data.frame are given using the
corresponding parameters (see below). Names and indices can be mixed, e.g. you can
specify <code>id.column="Parent"</code> and <code>pos.columns=1:3</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as.tracks(
  x,
  id.column = 1,
  time.column = 2,
  pos.columns = 3:ncol(x),
  scale.t = 1,
  scale.pos = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tracks.data.frame_+3A_x">x</code></td>
<td>
<p>the data frame to be coerced to a <code>tracks</code> object.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_id.column">id.column</code></td>
<td>
<p>index or name of the column that contains the track ID.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_time.column">time.column</code></td>
<td>
<p>index or name of the column that contains elapsed time.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_pos.columns">pos.columns</code></td>
<td>
<p>vector containing indices or names of the columns that contain
the spatial coordinates. If this vector has two entries and the second entry is NA,
e.g. <code>c('x',NA)</code> or <code>c(5,NA)</code> then all columns from the indicated column
to the last column are used. This is useful when reading files where the exact number
of spatial dimensions is not known beforehand.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_scale.t">scale.t</code></td>
<td>
<p>a value by which to multiply each time point. Useful for changing units,
or for specifying the time between positions if this is not contained in the file
itself.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_scale.pos">scale.pos</code></td>
<td>
<p>a value, or a vector of values, by which to multiply each spatial
position. Useful for changing units.</p>
</td></tr>
<tr><td><code id="as.tracks.data.frame_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>read.csv</code>, for instance
<code>sep="\t"</code> can be useful for tab-separated files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tracks</code> object.
</p>

<hr>
<h2 id='BCells'>Two-Photon Data: B Cells in a Lymph Node</h2><span id='topic+BCells'></span>

<h3>Description</h3>

<p>GFP-labelled B cells were injected retro-orbitally in healthy CD11c-YFP mice, and 
intravitally imaged (using two-photon microscopy) inside a cervical lymph
node. These data illustrate the characteristic &quot;random-walk-like&quot; motion pattern 
of B cells in lymph nodes. For full method details, see references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BCells")
</code></pre>


<h3>Format</h3>

<p>## 'BCells'
An S3 object of class &quot;tracks&quot;; a list with 74 elements. Each 
element name identifies a cell track. Each element is a matrix
containing the following three columns.
</p>

<dl>
<dt><code>t</code></dt><dd><p>the time (in seconds)</p>
</dd>
<dt><code>x</code></dt><dd><p>The X coordinate (in micrometers)</p>
</dd>
<dt><code>y</code></dt><dd><p>The Y coordinate (in micrometers)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were generated in 2021 in the Mark J. Miller Lab, Department of Medicine, Washington University in St Louis, USA.
</p>


<h3>References</h3>

<p>Miller MJ and Wei SH and Parker I and Cahalan MD (2002), 
Two-photon imaging of lymphocyte motility and antigen response in intact lymph node.
<em>Science</em>, <b>296</b>(5574):1869&ndash;1873. doi:10.1126/science.1070051
</p>
<p>Wortel IMN and Liu AY and Dannenberg K and Berry JC and Miller MJ and Textor J (2021),
CelltrackR: an R package for fast and flexible analysis of immune cell migration data.
<em>ImmunoInformatics</em>, <b>1-2</b>:100003. doi:10.1016/j.immuno.2021.100003
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## load the tracks
  data(BCells)

  ## visualize the tracks (calls function plot.tracks)
  plot(BCells)

</code></pre>

<hr>
<h2 id='beaucheminTrack'>Simulate a 3D Cell Track Using the Beauchemin Model</h2><span id='topic+beaucheminTrack'></span>

<h3>Description</h3>

<p>The Beauchemin model is a simple, particle-based description of T cell motion in lymph
node in the absence of antigen, which is similar to a random walk (Beauchemin et al,
2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beaucheminTrack(
  sim.time = 10,
  delta.t = 1,
  p.persist = 0,
  p.bias = 0.9,
  bias.dir = c(0, 0, 0),
  taxis.mode = 1,
  t.free = 2,
  v.free = 18.8,
  t.pause = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beaucheminTrack_+3A_sim.time">sim.time</code></td>
<td>
<p>specifies the duration of the track to be generated</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_delta.t">delta.t</code></td>
<td>
<p>change in time between each timepoint.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_p.persist">p.persist</code></td>
<td>
<p>indicates how probable a change in direction is. With p.persist = 1,
the direction never changes between steps and with p.persist = 0, a new direction is
sampled at every step.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_p.bias">p.bias</code></td>
<td>
<p>strength of movement in the direction of <code>bias.dir</code>.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_bias.dir">bias.dir</code></td>
<td>
<p>a 3D vector indicating the direction along which there is a
preference for movement.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_taxis.mode">taxis.mode</code></td>
<td>
<p>specified mode of movement. 1 := orthotaxis, 2 := topotaxis,
3 := klinotaxis.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_t.free">t.free</code></td>
<td>
<p>time interval for how long the cell is allowed to move between turns.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_v.free">v.free</code></td>
<td>
<p>speed of the cell during the free motion.</p>
</td></tr>
<tr><td><code id="beaucheminTrack_+3A_t.pause">t.pause</code></td>
<td>
<p>time that it takes the cell to adjust movement to new direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the Beauchemin model, cells move into a fixed direction for a fixed time <code>t.free</code>
at a fixed speed <code>v.free</code>. They then switch to a different direction, which is
sampled at uniform from a sphere. The change of direction takes a fixed time <code>t.pause</code>,
during which the cell does not move. Thus, the Beauchemin model is identical to the
freely jointed chain model of polymer physics, except for the explicit &quot;pause phase&quot;
between subsequent steps.
</p>
<p>The default parameters implemented in this function
were found to most accurately describe 'default' T
cell motion in lymph nodes using least-squares fitting to the mean displacement plot
(Beauchemin et al, 2007).
</p>
<p>This function implements an extended version of the Beauchemin model, which can also
simulate directionally biased motion. For details, see Textor et al (2013).
</p>


<h3>Value</h3>

<p>A track, i.e., a matrix with <code>t/delta.t</code> rows and 4 columns.
</p>


<h3>References</h3>

<p>Catherine Beauchemin, Narendra M. Dixit and Alan S. Perelson (2007), Characterizing
T cell movement within lymph nodes in the absence of antigen. <em>Journal of Immunology</em>
<b>178</b>(9), 5505-5512. doi:10.4049/jimmunol.178.9.5505
</p>
<p>Johannes Textor, Mathieu Sinn and Rob J. de Boer (2013), Analytical results on the
Beauchemin model of lymphocyte migration. <em>BMC Bioinformatics</em> <b>14</b>(Suppl 6), S10.
doi:10.1186/1471-2105-14-S6-S10
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create track with model parameters and return matrix of positions
out &lt;- beaucheminTrack(sim.time=20,p.persist = 0.3,taxis.mode = 1)
## Plot X-Y projection
plot( wrapTrack(out) )

## Create 20 tracks and plot them all
out &lt;- simulateTracks( 20, beaucheminTrack(sim.time=10,
  bias.dir=c(-1,1,0),p.bias=10,taxis.mode = 2,
  p.persist = 0.1,delta.t = 1) )
plot( out )

</code></pre>

<hr>
<h2 id='bootstrapTrack'>Simulate Tracks via Bootstrapping of Speed and Turning Angle from a Real Track Dataset</h2><span id='topic+bootstrapTrack'></span>

<h3>Description</h3>

<p>Returns a simulated dataset by sampling from the speed and turning angle distributions from an
original track dataset (only in 2 or 3 dimensions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapTrack(nsteps, trackdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapTrack_+3A_nsteps">nsteps</code></td>
<td>
<p>desired number of steps (e.g. 10 steps generates a track with 11 positions).</p>
</td></tr>
<tr><td><code id="bootstrapTrack_+3A_trackdata">trackdata</code></td>
<td>
<p>a tracks object to extract speeds and turning angles from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of dimensions is kept the same as in the original data (if data is 3D but
simulated tracks should be 2D, consider calling <code><a href="#topic+projectDimensions">projectDimensions</a></code> on the input
data before supplying it to <code>bootstrapTrack</code>). The time interval between &quot;measurements&quot;
of the simulated track equals that in the real data and is found via <code><a href="#topic+timeStep">timeStep</a></code>.
The first step starts at the origin in a random direction, with a speed sampled from the
speed distribution to determine its displacement. All subsequent steps also have their
turning angles sampled from the turning angle distribution in the data.
</p>


<h3>Value</h3>

<p>A data frame  containing in cell track with <code>nsteps</code> steps in
the same number of dimensions as the original data is returned.
</p>
<p>## Generate bootstrapped tracks of the TCell data; compare its speed distribution to the
## original data (should be the same).
T.bootstrap &lt;- bootstrapTrack( 100, TCells )
step.speeds.real &lt;- sapply( subtracks(TCells,1), speed )
step.speeds.bootstrap &lt;- sapply( subtracks( T.bootstrap, 1), speed )
qqplot( step.speeds.real, step.speeds.bootstrap )
</p>

<hr>
<h2 id='boundingBox'>Bounding Box of a Tracks Object</h2><span id='topic+boundingBox'></span>

<h3>Description</h3>

<p>Computes the minimum and maximum coordinates per dimension (including time)
for all positions in a given list of tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundingBox(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundingBox_+3A_x">x</code></td>
<td>
<p>the input <code>tracks</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with two rows and <code class="reqn">d+1</code> columns, where <code class="reqn">d</code> is
the number of spatial dimensions of the tracks. The first row contains the minimum
and the second row the maximum value of any track in the dimension given by
the column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use bounding box to set up plot window
bb &lt;- boundingBox(c(TCells,BCells,Neutrophils))
plot( Neutrophils, xlim=bb[,"x"], ylim=bb[,"y"], col=1 )
plot( BCells, col=2, add=TRUE )
plot( TCells, col=3, add=TRUE )

</code></pre>

<hr>
<h2 id='brownianTrack'>Simulate an Uncorrelated Random Walk</h2><span id='topic+brownianTrack'></span>

<h3>Description</h3>

<p>Generates a random track with <code>nsteps</code> steps in <code>dim</code> dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brownianTrack(nsteps = 100, dim = 3, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brownianTrack_+3A_nsteps">nsteps</code></td>
<td>
<p>desired number of steps (e.g. 10 steps generates a track with 11 positions).</p>
</td></tr>
<tr><td><code id="brownianTrack_+3A_dim">dim</code></td>
<td>
<p>desired number of dimensions.</p>
</td></tr>
<tr><td><code id="brownianTrack_+3A_mean">mean</code></td>
<td>
<p>stepwise mean drift per dimension; use 0 for an
unbiased Brownian motion and other values for Brownian motion with drift.</p>
</td></tr>
<tr><td><code id="brownianTrack_+3A_sd">sd</code></td>
<td>
<p>stepwise standard deviation per dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In in every step an for each dimension, a normally distributed
value with mean <code>mean</code> and standard deviation <code>sd</code> is
added to the previous cell position.
</p>


<h3>Value</h3>

<p>A data frame  containing in cell track with <code>nsteps</code> steps in
<code>dim</code> dimensions is returned.
</p>
<p>## The Hurst exponent of a 1D Brownian track should be near 0.5
hurstExponent( brownianTrack( 100, 1 ) )
</p>

<hr>
<h2 id='cellPairs'>Find Pairs of Tracks</h2><span id='topic+cellPairs'></span>

<h3>Description</h3>

<p>Get all unique combinations of two track ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellPairs(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellPairs_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with two columns: one for each of the track ids in the pair.
Each row represents a pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find all pairs of cells in the T cell data
pairs &lt;- cellPairs( TCells )
</code></pre>

<hr>
<h2 id='celltrackR'>celltrackR: Quantitative analysis of motion.</h2><span id='topic+celltrackR'></span><span id='topic+celltrackR-package'></span>

<h3>Description</h3>

<p>The CelltrackR package is designed for analyzing cell tracks acquired by
time-lapse microscopy (like those provided in the included datasets
<code><a href="#topic+TCells">TCells</a></code>, <code><a href="#topic+BCells">BCells</a></code> and <code><a href="#topic+Neutrophils">Neutrophils</a></code>).
But it can of course process any x-y-(z)-t data, and we hope that it may be useful
for other purposes as well.
</p>


<h3>Details</h3>

<p>For a complete list of functions, use <code>help( package="celltrackR" )</code>.
A handy cheat sheet is available in pdf. You can open it by calling
the function <code><a href="#topic+cheatsheet">cheatsheet</a></code>.
</p>


<h3>Data structure</h3>

<p>The basic data structure that most functions in this package operate on is a set of
<em>tracks</em>. A track is a list of spatial coordinates that are recorded at
<em>fixed</em> time intervals; the function <code><a href="#topic+timeStep">timeStep</a></code> can be used to check
for fluctuations of the recording intervals.
</p>
<p>We expect tracks to be stored in a matrix (or data frame, but this is discouraged
for efficiency reasons) whose first column denotes a time interval
(e.g. seconds elapsed since the beginning
of the experiment), and whose remaining columns denote a spatial coordinate. A set of
tracks is stored as a <code><a href="base.html#topic+list">list</a></code> with S3 class <code>tracks</code>. CelltrackR provides
some S3 methods for this class, which are explained in <code><a href="#topic+tracks">tracks</a></code> as well as
<code><a href="#topic+plot.tracks">plot.tracks</a></code>, <code><a href="#topic+sort.tracks">sort.tracks</a></code> and <code><a href="#topic+as.list.tracks">as.list.tracks</a></code>.
</p>


<h3>Track analysis in celltrackR</h3>

<p>A wide range of common track measures are included in the package. These are all functions
that take a single track as an input, and output one or several numbers.
For instance, the function <code><a href="#topic+speed">speed</a></code> estimates
the average instantaneous speed of the track by linear interpolation, and
<code><a href="#topic+straightness">straightness</a></code> computes the start-to-end distance divided by the trajectory
length (a number between 0 and 1, where 1 indicates a perfectly straight track).
See <code><a href="#topic+TrackMeasures">TrackMeasures</a></code> for an overview of measures that can be analyzed on tracks.
Also see <code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for an overview of functions that can help detect
directional bias and tracking artefacts (see Beltman et al, 2009).
</p>
<p>CelltrackR is designed to support various flavors of track analysis that have been
suggested in the literature. The simplest kind is a <em>track-based</em> analysis, where
we compute a single statistic for each track in a dataset (Beltman et al, 2009). Because
track sets are lists, this is achieved simply by using <code>lapply</code> or
<code>sapply</code> together with the track measure (see Examples).
</p>
<p>In <em>step-based</em> analyses (Beltman et al, 2009), we
chop each track up into segments of the same length and then apply our measures to those
segments. This can help to avoid biases that arise from variations
in track length (which are always present in cell tracking experiments).
In CelltrackR, step-based analyses are performed by using the <code><a href="#topic+subtracks">subtracks</a></code>
function. Often we want to perform such step-based analyses for all possible subtrack
lengths simultaneously, and plot the result as a function of the subtrack length;
a famous example is the <em>mean square displacement plot</em>. This can be
achieved by using the <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code> function, which has options
to control which subtrack lengths are considered and whether overlapping subtracks are
considered.
</p>
<p>In a <em>staggered</em> <em>staggered</em> analysis (Mokhtari et al, 2013), we analyse all
subtracks (of any length) of a single track, and typically plot the result as a matrix.
This can reveal dynamic patterns along a single track,
e.g. turning behaviour or local slowdowns. Staggered analyses can be performed using the
<code><a href="#topic+applyStaggered">applyStaggered</a></code> function.
</p>


<h3>Simulating tracks in celltrackR</h3>

<p>Lastly, in addition to data analysis, the package contains some function to generate
cell tracks by simulation. This is useful to develop and benchmark track analysis
methodology (Textor et al, 2011), and for computational biology studies that try to
extrapolate the long-term consequences of observed cell migration behaviour. Alongside
a simple uncorrelated random walk (<code><a href="#topic+brownianTrack">brownianTrack</a></code>), this package implements
a simulation model proposed by Beauchemin et al (2007)
in the function <code><a href="#topic+beaucheminTrack">beaucheminTrack</a></code>. That model can also simulate
directionally biased motion.
</p>


<h3>Author(s)</h3>

<p>Johannes Textor, Katharina Dannenberg, Jeffrey Berry, Gerhard Burger, Inge Wortel
Maintainer: Johannes Textor &lt;johannes.textor@gmx.de&gt;
</p>


<h3>References</h3>

<p>Joost B. Beltman, Athanasius F.M. Maree and Rob. J. de Boer (2009),
Analysing immune cell migration. <em>Nature Reviews Immunology</em> <b>9</b>,
789&ndash;798. doi:10.1038/nri2638
</p>
<p>Zeinab Mokhtari, Franziska Mech, Carolin Zitzmann, Mike Hasenberg, Matthias Gunzer
and Marc Thilo Figge (2013), Automated Characterization and
Parameter&ndash;Free Classification of Cell Tracks Based on Local Migration
Behavior. <em>PLoS ONE</em> <b>8</b>(12), e80808. doi:10.1371/journal.pone.0080808
</p>
<p>Johannes Textor, Antonio Peixoto, Sarah E. Henrickson, Mathieu
Sinn, Ulrich H. von Andrian and Juergen Westermann (2011),
Defining the Quantitative Limits of Intravital Two-Photon Lymphocyte Tracking.
<em>PNAS</em> <b>108</b>(30):12401&ndash;12406. doi:10.1073/pnas.1102288108
</p>
<p>Catherine Beauchemin, Narendra M. Dixit and Alan S. Perelson (2007), Characterizing
T cell movement within lymph nodes in the absence of antigen. <em>Journal of Immunology</em>
<b>178</b>(9), 5505-5512. doi:10.4049/jimmunol.178.9.5505
</p>


<h3>See Also</h3>

<p>The package vignettes, available from <code>browseVignettes( package="celltrackR" )</code>.
Make sure you have installed the package with option <code>build_vignettes = TRUE</code>, or
vignettes will not be visible. Also check out the package cheat sheet, which is available by
calling the function <code><a href="#topic+cheatsheet">cheatsheet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## track-based speed comparison
  boxplot(sapply( Neutrophils, straightness ), sapply( BCells, straightness ))

  ## step-based turning angle comparison
  boxplot(sapply(subtracks(Neutrophils, 2), overallAngle),
    sapply(subtracks(BCells, 2), overallAngle))

 ## mean square displacement plot; a step-based displacement analysis for all step lengths
 plot(aggregate(TCells, squareDisplacement)[,"value"])

 ## 'staggered' analysis of displacement over whole track. Reveals that this track
 ## slows down near its beginning and near its end.
 filled.contour(applyStaggered(TCells[[4]], displacement, matrix=TRUE))

 ## a simple hierarchical clustering based on 2D asphericity

 ## tag track IDs so we can identify them later
 names(TCells) &lt;- paste0("T",names(TCells))
 names(BCells) &lt;- paste0("B",names(BCells))
 names(Neutrophils) &lt;- paste0("N",names(Neutrophils))
 ## project all tracks down to 2D
 cells &lt;-  projectDimensions(c(TCells,BCells,Neutrophils), c("x","y"))

 ## compute asphericity
 asph &lt;- lapply(cells, asphericity)

 ## plot clustering
 plot(hclust(dist(asph)))

</code></pre>

<hr>
<h2 id='cheatsheet'>Open the package cheat sheet</h2><span id='topic+cheatsheet'></span>

<h3>Description</h3>

<p>Running this function will open the package cheat sheet (a pdf) via a call to
<code>system()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheatsheet(opencmd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheatsheet_+3A_opencmd">opencmd</code></td>
<td>
<p>The command used to open pdfs from the command line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='clusterTracks'>Cluster Tracks</h2><span id='topic+clusterTracks'></span>

<h3>Description</h3>

<p>Perform a quick clustering visualization of a set of tracks according to a given vector
of track measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTracks(
  tracks,
  measures,
  scale = TRUE,
  labels = NULL,
  method = "hclust",
  return.clust = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTracks_+3A_tracks">tracks</code></td>
<td>
<p>the tracks that are to be clustered.</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_measures">measures</code></td>
<td>
<p>a function, or a vector of functions (see <a href="#topic+TrackMeasures">TrackMeasures</a>).
Each function is expected to
return a single number given a single track.</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether the measures values shall be scaled
using the function <code><a href="base.html#topic+scale">scale</a></code> before the clustering.</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_labels">labels</code></td>
<td>
<p>optional: a vector of labels of the same length as the track object.
These are used to color points in the visualization.</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_method">method</code></td>
<td>
<p><code>"hclust"</code> for hierarchical clustering, or
<code>"kmeans"</code> for k-means clustering.</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_return.clust">return.clust</code></td>
<td>
<p>logical: return the clustering object instead of only the plot?
(defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="clusterTracks_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the corresponding clustering
function: <code><a href="stats.html#topic+hclust">hclust</a></code> or  <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measures are applied to each of the tracks in the given
<em>tracks</em> object. According to the resulting values, the tracks are
clustered using the chosen clustering method.
If <code>scale</code> is <code>TRUE</code>, the measure values are scaled to mean value
<code class="reqn">0</code> and standard deviation <code class="reqn">1</code> (per measure) before the clustering.
</p>
<p>Method hclust plots a dendrogram of the clustering.
</p>
<p>Method kmeans plots each computed cluster (x-axis) versus each of the track
measures in the <code>measures</code> vector, producing one panel per measure.
If labels are given, points are colored according to their &quot;true&quot; label.
</p>


<h3>Value</h3>

<p>By default, only returns a plot. If <code>return.clust=TRUE</code>, also returns
a clustering object as returned by <code><a href="stats.html#topic+hclust">hclust</a></code> or  <code><a href="stats.html#topic+kmeans">kmeans</a></code>.
output object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFeatureMatrix">getFeatureMatrix</a></code> to obtain a feature matrix that can be
used for manual clustering and plotting, and <code><a href="#topic+trackFeatureMap">trackFeatureMap</a></code> to
visualize high-dimensional track feature data via dimensionality reduction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cluster tracks according to the mean of their Hust exponents along X and Y
## using hierarchical clustering

cells &lt;- c(TCells,Neutrophils)
real.celltype &lt;- rep(c("T","N"),c(length(TCells),length(Neutrophils)))
## Prefix each track ID with its cell class to evaluate the clustering visually
names(cells) &lt;- paste0(real.celltype,seq_along(cells))
clust &lt;- clusterTracks( cells, hurstExponent, method = "hclust",
 return.clust = TRUE  )

## How many cells are "correctly" clustered?
sum( real.celltype == c("T","N")[cutree(clust,2)] )

</code></pre>

<hr>
<h2 id='distanceCells'>Minimum Distance between Two Cells</h2><span id='topic+distanceCells'></span>

<h3>Description</h3>

<p>Compute the minimum distance between two cells in the dataset (minimum over all)
the timepoints where they were both measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceCells(X, cellids, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceCells_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="distanceCells_+3A_cellids">cellids</code></td>
<td>
<p>a vector of two indices specifying the tracks to compute distance between, or
a dataframe/matrix of two columns (where every row contains a pair of cellids to compute 
a distance for)</p>
</td></tr>
<tr><td><code id="distanceCells_+3A_quietly">quietly</code></td>
<td>
<p>if TRUE, suppress warnings about returning NA distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single distance (NA if the the tracks do not have overlapping timepoints), or 
a vector of such distances if multiple pairs are supplied in <code>cellids</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angleCells">angleCells</a></code> to compute the angle between the track displacement vectors,
and <code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find the minimum distance between the tracks with ids 1 and 3
distanceCells( TCells, c("1","3") )
</code></pre>

<hr>
<h2 id='distanceSteps'>Distance between Two Steps</h2><span id='topic+distanceSteps'></span>

<h3>Description</h3>

<p>Compute the distance between two steps in the dataset that occur at the same timepoint.
The distance is the distance between the step starting points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceSteps(X, trackids, t, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceSteps_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="distanceSteps_+3A_trackids">trackids</code></td>
<td>
<p>a vector of two indices specifying the tracks to get steps from, or
a dataframe/matrix of two columns (where every row contains a pair of trackids to compute 
a step angle for)</p>
</td></tr>
<tr><td><code id="distanceSteps_+3A_t">t</code></td>
<td>
<p>the timepoint at which the steps should start, or a vector of such timepoints if
multiple step pairs are supplied in <code>trackids</code>.</p>
</td></tr>
<tr><td><code id="distanceSteps_+3A_quietly">quietly</code></td>
<td>
<p>logical; should a warning be returned if one or both of the steps are missing
in the data and the function returns NA?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single distance (NA if the desired timepoint is missing for one or both
of the tracks), or a vector of such distances if multiple step pairs are supplied in <code>trackids</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angleSteps">angleSteps</a></code> to compute the angle between the steps,
<code><a href="#topic+timePoints">timePoints</a></code> to list all timepoints in a dataset,
and <code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find the distance between the steps of the tracks with ids 1 and 3, at the 3rd
## timepoint in the dataset.
t &lt;- timePoints( TCells )[3]
distanceSteps( TCells, c("1","3"), t )

## Do this for multiple pairs and times at once: between cells 1 and 3 at the
## 3rd timepoint, and between 1 and 4 at the fourth timepoint.
pairs &lt;- data.frame( cell1 = c("1","1"), cell2 = c("3","4"))
times &lt;- timePoints(TCells)[3:4]
distanceSteps( TCells, pairs, times )
</code></pre>

<hr>
<h2 id='distanceToPlane'>Distance to a Reference Plane</h2><span id='topic+distanceToPlane'></span>

<h3>Description</h3>

<p>Compute the (shortest) distance between the starting point of a track and a reference plane.
Useful to detect directed movement and/or tracking artefacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceToPlane(x, p1 = c(0, 0, 0), p2 = c(0, 1, 0), p3 = c(1, 0, 0), from = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceToPlane_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="distanceToPlane_+3A_p1">p1</code>, <code id="distanceToPlane_+3A_p2">p2</code>, <code id="distanceToPlane_+3A_p3">p3</code></td>
<td>
<p>numeric vectors of coordinates of three points specifying a reference plane to
compute distances to.</p>
</td></tr>
<tr><td><code id="distanceToPlane_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track. If
<code>from</code> is a vector, distances are returned for all steps starting at
the indices in <code>from</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angleToPlane">angleToPlane</a></code> to compute the angle to the plane, and
<code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting the angle versus the distance to a reference plane can be informative to
## detect tracking artefacts near the border of the imaging volume.
## We should be suspicious especially when small angles are more frequent at low distances
## to the border planes.
load( system.file("extdata", "TCellsRaw.rda", package="celltrackR" ) )
steps &lt;- subtracks( TCellsRaw, 1 )
minz &lt;- boundingBox( TCellsRaw )["min","z"]
## Compute angles and distances to the lower plane in z-dimension
angles &lt;- sapply( steps, angleToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
distances &lt;- sapply( steps, distanceToPlane, p1 = c(0,0,minz), p2 = c(1,0,minz), p3 = c(0,1,minz) )
scatter.smooth( distances, angles )
abline( h = 32.7, col = "red" )
</code></pre>

<hr>
<h2 id='distanceToPoint'>Distance to a Reference Point</h2><span id='topic+distanceToPoint'></span>

<h3>Description</h3>

<p>Compute the distance between the starting point of a track and a reference point.
Useful to
detect directed movement towards a point (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceToPoint(x, p = c(0, 0, 0), from = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceToPoint_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="distanceToPoint_+3A_p">p</code></td>
<td>
<p>numeric vector of coordinates of the reference point p to compute distances to.</p>
</td></tr>
<tr><td><code id="distanceToPoint_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track. If
<code>from</code> is a vector, distances are returned for all steps starting at
the indices in <code>from</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angleToPoint">angleToPoint</a></code> to compute the angle to the reference point, and
<code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for other methods to compute angles and distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting the angle versus the distance to a reference point can be informative to
## detect biased movement towards that point. We should be suspicious especially
## when small angles are more frequent at lower distances.
steps &lt;- subtracks( Neutrophils, 1 )
bb &lt;- boundingBox( Neutrophils )
angles &lt;- sapply( steps, angleToPoint, p = bb["max",-1] )
distances &lt;- sapply( steps, distanceToPoint, p = bb["max",-1] )
scatter.smooth( distances, angles )
abline( h = 90, col = "red" )
</code></pre>

<hr>
<h2 id='filterTracks'>Filter Tracks</h2><span id='topic+filterTracks'></span>

<h3>Description</h3>

<p>Extracts subtracks based on a given function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterTracks(f, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterTracks_+3A_f">f</code></td>
<td>
<p>a function that accepts a single track as its first argument and returns a
logical value (or a value that can be coerced to a locical).</p>
</td></tr>
<tr><td><code id="filterTracks_+3A_x">x</code></td>
<td>
<p>a tracks object.</p>
</td></tr>
<tr><td><code id="filterTracks_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tracks</code> object containing only those tracks from <code>x</code> for which
<code>f</code> evaluates to <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Remove short tracks from the T cells data
plot( filterTracks( function(t) nrow(t)&gt;10, TCells ) )
</code></pre>

<hr>
<h2 id='get.immap.metadata'>Get  Track Metadata from ImmuneMap</h2><span id='topic+get.immap.metadata'></span>

<h3>Description</h3>

<p>Get metadata from tracks obtained from <a href="https://immunemap.org">https://immunemap.org</a> and import into celltrackR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.immap.metadata(
  input,
  warn.exclude = TRUE,
  exclude.names = c("points", "cellTypeObject", "date")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.immap.metadata_+3A_input">input</code></td>
<td>
<p>a parsed json file obtained with <code><a href="#topic+parse.immap.json">parse.immap.json</a></code></p>
</td></tr>
<tr><td><code id="get.immap.metadata_+3A_warn.exclude">warn.exclude</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), warn when key-value pairs in the json 
(other than those in exclude.names) are being ignored while parsing immunemap json.</p>
</td></tr>
<tr><td><code id="get.immap.metadata_+3A_exclude.names">exclude.names</code></td>
<td>
<p>if the json contains keys with these names, they are ignored when reading
the metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with metadata. This function currently only handles metadata with a single
value for each track and ignores others (with a warning when <code>warn.exclude=TRUE</code>).
column names in the dataframe correspond to the keys in the original json, and values to
the values for each track.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read tracks from immunemap online
input &lt;- parse.immap.json( url = "https://api.immunemap.org/video/14/tracks" )
meta.df &lt;- get.immap.metadata( input )

## Repeat but ignore also the 'color' column:
exclude &lt;-  c("points", "cellTypeObject","date", "color")
meta.df &lt;- get.immap.metadata( input, exclude.names = exclude )

</code></pre>

<hr>
<h2 id='getFeatureMatrix'>Obtaining A Feature Matrix</h2><span id='topic+getFeatureMatrix'></span>

<h3>Description</h3>

<p>Applies a given vector of track measures directly on a set of tracks, returning
output in a matrix with a column for each measure and a row for each track. Can
also return a distance matrix, which some clustering methods require.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFeatureMatrix(tracks, measures, dist = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFeatureMatrix_+3A_tracks">tracks</code></td>
<td>
<p>the tracks that are to be analyzed.</p>
</td></tr>
<tr><td><code id="getFeatureMatrix_+3A_measures">measures</code></td>
<td>
<p>a function, or a vector of functions (see <a href="#topic+TrackMeasures">TrackMeasures</a>).
Each function is expected to return a single number given a single track.</p>
</td></tr>
<tr><td><code id="getFeatureMatrix_+3A_dist">dist</code></td>
<td>
<p>should a distance matrix rather than a feature matrix be returned?</p>
</td></tr>
<tr><td><code id="getFeatureMatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed on to &quot;dist&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with a row for each track and a column for each measure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterTracks">clusterTracks</a></code> for a quick method to compute the feature
matrix and a clustering, and <code><a href="#topic+trackFeatureMap">trackFeatureMap</a></code> to perform
dimensionality reduction methods on a set of track features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get speed, meanTurningAngle, and straightness for T cell tracks
fm &lt;- getFeatureMatrix( TCells, c(speed,meanTurningAngle,straightness))
str(fm)

</code></pre>

<hr>
<h2 id='hotellingsTest'>Test Unbiasedness of Motion</h2><span id='topic+hotellingsTest'></span>

<h3>Description</h3>

<p>Test the null hypothesis that a given set of tracks originates from an uncorrelated
and unbiased type of motion (e.g., a random walk without drift). This is done by
testing whether the mean step vector is equal to the null vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotellingsTest(
  tracks,
  dim = c("x", "y"),
  step.spacing = 0,
  plot = FALSE,
  add = FALSE,
  ellipse.col = "blue",
  ellipse.border = "black",
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotellingsTest_+3A_tracks">tracks</code></td>
<td>
<p>the tracks whose biasedness is to be determined.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_dim">dim</code></td>
<td>
<p>vector with the names of the track's
dimensions that are to be considered. By default c(&quot;x&quot;, &quot;y&quot;).</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_step.spacing">step.spacing</code></td>
<td>
<p>How many positions are to be left out between
the steps that are considered for the test. For persistent motion, subsequent
steps will be correlated, which leads to too low p-values because Hotelling's
test assumes that the input data is independent. To avoid this, the resulting
p-value should either be corrected for this dependence (e.g. by adjusting
the degrees of freedom accordingly), or 'step.spacing' should be set to a value
high enough to ensure that the considered steps are approximately independent.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether the scatter of the step's directions,
origin of ordinates (green circle) and the mean of the data points (green
cross) are to be plotted. (In one dimension also the bounds of the
condfidence interval are given.) Plot works only in one or two dimensions.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_add">add</code></td>
<td>
<p>whether to add the plot to the current plot (<code>TRUE</code>) or create a</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_ellipse.col">ellipse.col</code></td>
<td>
<p>color with which to draw the confidence ellipse of the mean (for
1D, this corresponds to the confidence interval of the mean).
Use <code>NA</code> to omit the confidence ellipse.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_ellipse.border">ellipse.border</code></td>
<td>
<p>color of the confidence ellipse border. Use <code>NA</code> to omit
the border.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_conf.level">conf.level</code></td>
<td>
<p>the desired confidence level for the confidence ellipse.</p>
</td></tr>
<tr><td><code id="hotellingsTest_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the displacement vectors of all segments in the tracks
given in <code>tracks</code>, and performs Hotelling's T-square Test on that vector.
</p>


<h3>Value</h3>

<p>A list with class <code>htest</code>.
</p>


<h3>References</h3>

<p>Johannes Textor, Antonio Peixoto, Sarah E. Henrickson, Mathieu
Sinn, Ulrich H. von Andrian and Juergen Westermann (2011),
Defining the Quantitative Limits of Intravital Two-Photon Lymphocyte Tracking.
<em>PNAS</em> <b>108</b>(30):12401&ndash;12406. doi:10.1073/pnas.1102288108
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test H_0: T-cells migrate by uncorrelated random walk on x and y coordinates,
## and report the p-value.
hotellingsTest( TCells )$p.value

</code></pre>

<hr>
<h2 id='interpolateTrack'>Interpolate Track Positions</h2><span id='topic+interpolateTrack'></span>

<h3>Description</h3>

<p>Approximates the track positions at given time points using linear interpolation
(via the <code><a href="stats.html#topic+approxfun">approx</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolateTrack(x, t, how = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolateTrack_+3A_x">x</code></td>
<td>
<p>the input track (a matrix or data frame).</p>
</td></tr>
<tr><td><code id="interpolateTrack_+3A_t">t</code></td>
<td>
<p>the times at which to approximate track positions. These must lie
within the interval spanned by the track timepoints.</p>
</td></tr>
<tr><td><code id="interpolateTrack_+3A_how">how</code></td>
<td>
<p>specifies how to perform the interpolation. Possible values are
<code>"linear"</code> (which uses <code><a href="stats.html#topic+approxfun">approx</a></code> with default values) and
<code>"spline"</code> (which uses <code><a href="stats.html#topic+splinefun">spline</a></code> with default values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interpolated track (a matrix or data frame).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare interpolated and non-interpolated versions of a track
bb &lt;- boundingBox( TCells[2] )
plot( TCells[2] )
t2i &lt;- interpolateTrack(TCells[[2]], seq(bb[1,"t"],bb[2,"t"],length.out=100),"spline")
plot( tracks( t2i ), add=TRUE, col=2 )

</code></pre>

<hr>
<h2 id='maxTrackLength'>Length of Longest Track</h2><span id='topic+maxTrackLength'></span>

<h3>Description</h3>

<p>Determines the maximum number of positions over the tracks in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxTrackLength(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxTrackLength_+3A_x">x</code></td>
<td>
<p>the <code>tracks</code> object the tracks in which are to be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum number of rows of a track in <code>x</code>
</p>

<hr>
<h2 id='Neutrophils'>Two-Photon Data: Neutrophils responding to an infection in the ear</h2><span id='topic+Neutrophils'></span>

<h3>Description</h3>

<p>LysM-GFP mice were infected with S. aureus on their ear, and intravitally
imaged using two-photon microscopy proximal to the infection. 
These cells display a fairly directed kind of motion, as they move towards 
infection foci. For method details, see the references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Neutrophils")
</code></pre>


<h3>Format</h3>

<p>## 'Neutrophils'
An S3 object of class &quot;tracks&quot;; a list with 411 elements. Each 
element name identifies a cell track. Each element is a matrix
containing the following three columns.
</p>

<dl>
<dt><code>t</code></dt><dd><p>the time (in seconds)</p>
</dd>
<dt><code>x</code></dt><dd><p>The X coordinate (in micrometers)</p>
</dd>
<dt><code>y</code></dt><dd><p>The Y coordinate (in micrometers)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were generated in 2021 in the Mark J. Miller Lab, Department of Medicine, Washington University in St Louis, USA.
</p>


<h3>References</h3>

<p>Lin A and Loughman JA and Zinselmeyer BH and Miller MJ and Caparon MG (2009), 
Streptolysin S inhibits neutrophil recruitment during the early stages of streptococcus pyogenes infection.
<em>Infect Immun</em>, <b>77</b>(11):5190&ndash;5201. doi:10.1128/IAI.00420-09
</p>
<p>Wang B and Zinselmeyer BH and McDole JR and Gieselman PA and Miller MJ (2010), 
Non-invasive imaging of leukocyte homing and migration in vivo.
<em>J Vis Exp</em>, <b>46</b>:e2062. doi:10.3791/2062
</p>
<p>Graham DB and Zinselmeyer BH and Mascarenhas F and Delgado R and Miller MJ and Swat W (2009), 
Itam signaling by Vav family Rho Guanine nucleotide exchange factors regulates interstitial transit rates of neutrophils in vivo.
<em>PLOS ONE</em>, <b>2</b>(2):1&ndash;5. doi:10.1371/journal.pone.0004652
</p>
<p>Wortel IMN and Liu AY and Dannenberg K and Berry JC and Miller MJ and Textor J (2021),
CelltrackR: an R package for fast and flexible analysis of immune cell migration data.
<em>ImmunoInformatics</em>, <b>1-2</b>:100003. doi:10.1016/j.immuno.2021.100003
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## load the tracks
  data(Neutrophils)

  ## visualize the tracks (calls function plot.tracks)
  plot(Neutrophils)

</code></pre>

<hr>
<h2 id='normalizeToDuration'>Normalize a Measure to Track Duration</h2><span id='topic+normalizeToDuration'></span>

<h3>Description</h3>

<p>Returns a measure that divides the input measure by the duration of its
input track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeToDuration(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeToDuration_+3A_x">x</code></td>
<td>
<p>a track measure (see <a href="#topic+TrackMeasures">TrackMeasures</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that computes the input measure for a given track
and returns the result divided by the track's duration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalizeToDuration(displacement) can be used as an indicator
## for the motion's efficiency
sapply(TCells, normalizeToDuration(displacement))
</code></pre>

<hr>
<h2 id='normalizeTracks'>Normalize Tracks</h2><span id='topic+normalizeTracks'></span>

<h3>Description</h3>

<p>Translates each track in a given set of tracks such that the
first position is the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeTracks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeTracks_+3A_x">x</code></td>
<td>
<p>the input <code>tracks</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an output <code>tracks</code> object with all tracks shifted such that their
starting position lies at the origin of the coordinate system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalization of Neutrophil data reveals upward motion
plot( normalizeTracks( Neutrophils ) )

</code></pre>

<hr>
<h2 id='pairsByTime'>Distance between pairs of tracks at every timepoint</h2><span id='topic+pairsByTime'></span>

<h3>Description</h3>

<p>For every timepoint in the dataset, compute pairwise distances between coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairsByTime(X, searchRadius = Inf, times = timePoints(X), quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsByTime_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="pairsByTime_+3A_searchradius">searchRadius</code></td>
<td>
<p>if specified, return only pairs that are within this distance of each other. 
Defaults to <code>Inf</code>, so if left unspecified, all pairs are returned.</p>
</td></tr>
<tr><td><code id="pairsByTime_+3A_times">times</code></td>
<td>
<p>(optional) a vector of timePoints to check pairs at; by default this is just everything.</p>
</td></tr>
<tr><td><code id="pairsByTime_+3A_quietly">quietly</code></td>
<td>
<p>(default FALSE) if TRUE, suppress warnings when there are no tracks with
overlapping timepoints and an empty dataframe is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with the following columns:
</p>

<dl>
<dt>cell1</dt><dd><p>the id of the track to which the first coordinate belongs</p>
</dd>
<dt>cell2</dt><dd><p>the id of the track to which the second coordinate belongs</p>
</dd>
<dt>t</dt><dd><p>the time point at which their distance is assessed</p>
</dd>
<dt>dist</dt><dd><p>the distance between the coordinates at this time</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## compute find timepoints where two t cells are within 1 micron of each other.
pairsByTime( TCells, searchRadius = 1 )

## indeed, the following two cells nearly touch:
plot( TCells[ c("24","9258") ] )
</code></pre>

<hr>
<h2 id='plot.tracks'>Plot Tracks in 2D</h2><span id='topic+plot.tracks'></span>

<h3>Description</h3>

<p>Plots tracks contained in a &quot;tracks&quot; object into a twodimensional space
pallelel to the data's axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tracks'
plot(
  x,
  dims = c("x", "y"),
  add = F,
  col = order(names(x)),
  pch.start = 1,
  pch.end = NULL,
  cex = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tracks_+3A_x">x</code></td>
<td>
<p>the tracks to be plotted.</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_dims">dims</code></td>
<td>
<p>a vector giving the dimensions of the track data that shall be
plotted, e.g. <code>c('x','y')</code> for the <code class="reqn">x</code> and <code class="reqn">y</code> dimension.</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_add">add</code></td>
<td>
<p>boolean value indicating whether the tracks are to be added to the
current plot.</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_col">col</code></td>
<td>
<p>a specification of the color(s) to be used. This can be a vector
of size <code>length(x)</code>, where each entry specififes the color for the
corresponding track.</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_pch.start">pch.start</code></td>
<td>
<p>point symbol with which to label the first position of the track
(see <code><a href="graphics.html#topic+points">points</a></code>).</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_pch.end">pch.end</code></td>
<td>
<p>point symbol with which to label the last position of the track</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_cex">cex</code></td>
<td>
<p>point size for positions on the tracks.</p>
</td></tr>
<tr><td><code id="plot.tracks_+3A_...">...</code></td>
<td>
<p>additional parameters (e.g. xlab, ylab).
to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>
(for <code>add=FALSE</code>) or <code><a href="graphics.html#topic+points">points</a></code> (for <code>add=TRUE</code>),
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One dimension of the data (by default <code class="reqn">y</code>) is plotted against
another (by default <code class="reqn">x</code>). The dimesions can be chosen by means of the
parameter <code>dims</code> and the axes can be labeled accordingly with the aid
of <code>xlab</code> and <code>ylab</code>. The color can be set through <code>col</code>.
If the tracks should be added to an existing plot, <code>add</code> is to be set
to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d">plot3d</a></code>
</p>

<hr>
<h2 id='plot3d'>Plot Tracks in 3D</h2><span id='topic+plot3d'></span>

<h3>Description</h3>

<p>Takes an input tracks object and plots them in 3D using the
<a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_+3A_x">x</code></td>
<td>
<p>the tracks which will be plotted in 3d</p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to
<a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( require("scatterplot3d",quietly=TRUE) ){
  plot3d( TCells )
}

</code></pre>

<hr>
<h2 id='plotTrackMeasures'>Bivariate Scatterplot of Track Measures</h2><span id='topic+plotTrackMeasures'></span>

<h3>Description</h3>

<p>Plots the values of two measures applied on the given tracks against each
other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrackMeasures(
  x,
  measure.x,
  measure.y,
  add = FALSE,
  xlab = deparse(substitute(measure.x)),
  ylab = deparse(substitute(measure.y)),
  ellipse.col = "red",
  ellipse.border = "black",
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrackMeasures_+3A_x">x</code></td>
<td>
<p>the input <code>tracks</code> object.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_measure.x">measure.x</code></td>
<td>
<p>the measure to be shown on the X axis (see <a href="#topic+TrackMeasures">TrackMeasures</a>).</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_measure.y">measure.y</code></td>
<td>
<p>the measure to be shown on the Y axis.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_add">add</code></td>
<td>
<p>a logical indicating whether the tracks are to be added to an
existing plot via <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_xlab">xlab</code></td>
<td>
<p>label of the x-axis. By default the name of the input function
<code>measure.x</code>.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_ylab">ylab</code></td>
<td>
<p>label of the y-axis. By default the name of the input function
<code>measure.y</code>.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_ellipse.col">ellipse.col</code></td>
<td>
<p>color with which to draw the confidence ellipse of the mean (for
1D, this corresponds to the confidence interval of the mean).
Use <code>NA</code> to omit the confidence ellipse.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_ellipse.border">ellipse.border</code></td>
<td>
<p>color of the confidence ellipse border. Use <code>NA</code> to omit
the border.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_conf.level">conf.level</code></td>
<td>
<p>the desired confidence level for the confidence ellipse.</p>
</td></tr>
<tr><td><code id="plotTrackMeasures_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>
(in case <code>add=FALSE</code>) or <code><a href="graphics.html#topic+points">points</a></code> (<code>add=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the value of <code>measurey</code> applied to <code>x</code> against the
value of <code>measurey</code> applied to <code>y</code>. This is useful for &quot;FACS-like&quot;
motility analysis, where clusters of cell tracks are identified based on their
motility parameters (Moreau et al, 2012; Textor et al, 2014).
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Moreau HD, Lemaitre F, Terriac E, Azar G, Piel M, Lennon-Dumenil AM,
Bousso P (2012), Dynamic In Situ Cytometry Uncovers
T Cell Receptor Signaling during Immunological Synapses and Kinapses In Vivo.
<em>Immunity</em> <b>37</b>(2), 351&ndash;363. doi:10.1016/j.immuni.2012.05.014
</p>
<p>Johannes Textor, Sarah E. Henrickson, Judith N. Mandl, Ulrich H. von Andrian,
J\&quot;urgen Westermann, Rob J. de Boer and Joost B. Beltman (2014),
Random Migration and Signal Integration Promote Rapid and Robust T Cell Recruitment.
<em>PLoS Computational Biology</em> <b>10</b>(8), e1003752.
doi:10.1371/journal.pcbi.1003752
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare speed and straightness of 3 example population tracks.
## To make the comparison fair, analyze subtracks of fixed length.
plotTrackMeasures( subtracks(TCells,4,0), speed, straightness, ellipse.col="black" )
plotTrackMeasures( subtracks(BCells,4,0), speed, straightness,
  col=2, ellipse.col=2, pch=2, add=TRUE )
plotTrackMeasures( subtracks(Neutrophils,4,0), speed, straightness,
  col=3, ellipse.col=3, pch=3, add=TRUE )

</code></pre>

<hr>
<h2 id='prefixes'>Get Track Prefixes</h2><span id='topic+prefixes'></span>

<h3>Description</h3>

<p>Creates a <code>tracks</code> object consisting of all prefixes (i.e., subtracks
starting with the first position of a track) of 'x'
with 'i' segments (i.e., 'i'+1 positions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefixes(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prefixes_+3A_x">x</code></td>
<td>
<p>a single track or a <code>tracks</code> object.</p>
</td></tr>
<tr><td><code id="prefixes_+3A_i">i</code></td>
<td>
<p>subtrack length. A single integer, lists are not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves exactly like <code><a href="#topic+subtracks">subtracks</a></code> except
that only subtracks starting from the first position are considered.
</p>


<h3>Value</h3>

<p>A <em>tracks</em> object is returned which contains all the subtracks
of any track in the input <em>tracks</em> object that consist of exactly 'i'
segments and start at the first registered coordinate of the given track.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subtracks">subtracks</a></code> to extract all subtracks of a given length,
<code><a href="#topic+subtracksByTime">subtracksByTime</a></code> to extract all subtracks of a given length
starting at some fixed timepoint, and <code><a href="#topic+selectSteps">selectSteps</a></code> to extract
single steps starting at a fixed timepoint from a subset of trackids.
</p>

<hr>
<h2 id='projectDimensions'>Extract Spatial Dimensions</h2><span id='topic+projectDimensions'></span>

<h3>Description</h3>

<p>Projects tracks onto the given spatial dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectDimensions(x, dims = c("x", "y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectDimensions_+3A_x">x</code></td>
<td>
<p>the input tracks object.</p>
</td></tr>
<tr><td><code id="projectDimensions_+3A_dims">dims</code></td>
<td>
<p>a character vector (for column names) or an integer vector (for column
indices) giving the dimensions to extract from each track.
The time dimension (i.e., the first column of all tracks) is always included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tracks object is returned that contains only those dimensions
of the input <code>tracks</code> that are given in <code>dims</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare 2D and 3D speeds
load( system.file("extdata", "TCellsRaw.rda", package="celltrackR" ) )
speed.2D &lt;- mean( sapply( subtracks( projectDimensions( TCellsRaw, c("x","z") ), 2 ), speed ) )
speed.3D &lt;- mean( sapply( TCellsRaw, speed ) )

</code></pre>

<hr>
<h2 id='read.tracks.csv'>Read Tracks from Text File</h2><span id='topic+read.tracks.csv'></span>

<h3>Description</h3>

<p>Reads cell tracks from a CSV or other text file. Data are expected to be organized as
follows.
One column contains a track identifier, which can be numeric or a string, and
determines which points belong to the same track.
Another column is expected to contain a time index or a time period (e.g. number of
seconds elapsed since the beginning of the track, or since the beginning of the
experiment). Input of dates is not (yet) supported, as absolute time information is
frequently not available.
Further columns contain the spatial coordinates. If there are three or less spatial
coordinates, their names will by &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;
(depending on whether the tracks are 1D, 2D or 3D). If there are four or more spatial
coordinates, their names will be &quot;x1&quot;, &quot;x2&quot;, and so on.
The names or indices of these columns in the CSV files are given using the
corresponding parameters (see below). Names and indices can be mixed, e.g. you can
specify <code>id.column="Parent"</code> and <code>pos.columns=1:3</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.tracks.csv(
  file,
  id.column = 1,
  time.column = 2,
  pos.columns = c(3, 4, 5),
  scale.t = 1,
  scale.pos = 1,
  header = TRUE,
  sep = "",
  track.sep.blankline = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tracks.csv_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from, a
readable text-mode connection or a complete URL
(see <code><a href="utils.html#topic+read.table">read.table</a></code>).</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_id.column">id.column</code></td>
<td>
<p>index or name of the column that contains the track ID.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_time.column">time.column</code></td>
<td>
<p>index or name of the column that contains elapsed time.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_pos.columns">pos.columns</code></td>
<td>
<p>vector containing indices or names of the columns that contain
the spatial coordinates. If this vector has two entries and the second entry is NA,
e.g. <code>c('x',NA)</code> or <code>c(5,NA)</code> then all columns from the indicated column
to the last column are used. This is useful when reading files where the exact number
of spatial dimensions is not known beforehand.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_scale.t">scale.t</code></td>
<td>
<p>a value by which to multiply each time point. Useful for changing units,
or for specifying the time between positions if this is not contained in the file
itself.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_scale.pos">scale.pos</code></td>
<td>
<p>a value, or a vector of values, by which to multiply each spatial
position. Useful for changing units.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains the
names of the variables as its first line. See <code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_sep">sep</code></td>
<td>
<p>a character specifying how the colums of the data are separated.
The default value <code>""</code> means columns are separated by tabs or other spaces.
See <code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_track.sep.blankline">track.sep.blankline</code></td>
<td>
<p>logical. If set to <code>TRUE</code>, then tracks are expected
to be separated by one or more blank lines in the input file instead of being
designated by a track ID column. In this case, numerical track IDs are automatically
generated.</p>
</td></tr>
<tr><td><code id="read.tracks.csv_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>read.csv</code>, for instance
<code>sep="\t"</code> can be useful for tab-separated files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file's first four fields are interpreted as <code class="reqn">id</code>,
<code class="reqn">pos</code>, <code class="reqn">t</code> and <code class="reqn">x</code>, respectively, and, if available, the fifth
as <code class="reqn">y</code> and the sixth as <code class="reqn">z</code>. The returned object has the class
<em>tracks</em>, which is a list of data frames representing the single
tracks and having columns <code class="reqn">t</code> and <code class="reqn">x</code>, plus <code class="reqn">y</code> and <code class="reqn">z</code>, if
necessary. The tracks' ids are retained in their position in the list, while
the field <code class="reqn">pos</code> will be unmaintained.
</p>


<h3>Value</h3>

<p>An object of class <em>tracks</em> is returned, which is a list of
matrices, each containing the positions of one track. The matrices
have a column <code class="reqn">t</code>, followed by one column for each of the input track's
coordinates.
</p>

<hr>
<h2 id='ReadImmuneMap'>Read tracks from ImmuneMap</h2><span id='topic+ReadImmuneMap'></span><span id='topic+read.immap.json'></span><span id='topic+parse.immap.json'></span><span id='topic+get.immap.tracks'></span>

<h3>Description</h3>

<p>Reads tracks from <a href="https://immunemap.org">https://immunemap.org</a> for import into celltrackR. 
This produces both tracks object(s) and a dataframe with metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.immap.json(
  url,
  tracks.url = NULL,
  keep.id = TRUE,
  scale.auto = TRUE,
  scale.t = NULL,
  scale.pos = NULL,
  warn.scaling = TRUE,
  simplify.2D = TRUE,
  warn.celltypes = TRUE,
  split.celltypes = FALSE,
  ...
)

parse.immap.json(url)

get.immap.tracks(
  input,
  keep.id = TRUE,
  scale.t = NULL,
  scale.pos = NULL,
  warn.scaling = TRUE,
  simplify.2D = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadImmuneMap_+3A_url">url</code></td>
<td>
<p>of the json file to download from immunemap; this should be the url to the
video metadata without the &quot;/tracks&quot; suffix. With this method, the metadata will
be used to automatically scale time to seconds and coordinates to microns if
<code>scale.auto=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_tracks.url">tracks.url</code></td>
<td>
<p>optional: alternatively, provide directly the url of the tracks (ending with &quot;/tracks&quot;),
or an url of a local json file with tracks. With this method, scales must be set
manually. If not specified, it is assumed that adding the suffix &quot;/tracks&quot; to the
supplied <code>url</code> will provide the track data.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_keep.id">keep.id</code></td>
<td>
<p>logical: keep track ids from immunemap? If false, new unique ids are
generated. Defaults to <code>TRUE</code>. If there are no ids in the input json, a warning
will be returned; this can be suppressed by setting keep.id = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_scale.auto">scale.auto</code></td>
<td>
<p>logical: if <code>TRUE</code> (the default), scales will be set automatically using
the metadata found in <code>url</code>. This works only if the <code>url</code> is given, not
if only <code>tracks.url</code> is supplied.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_scale.t">scale.t</code></td>
<td>
<p>optional: multiply timepoints with constant factor to rescale time.
By default, immunemap returns time in # frames.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_scale.pos">scale.pos</code></td>
<td>
<p>optional: multiply coordinates with constant factor to rescale lengths.
By default, immunemap measures coordinates in pixels.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_warn.scaling">warn.scaling</code></td>
<td>
<p>logical: if <code>scale.t</code> and <code>scale.pos</code> are not set,
warn the user that units are pixels and #frames instead of microns and min/sec. 
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_simplify.2d">simplify.2D</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), automatically project to 2D when the
z-coordinate has only one value.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_warn.celltypes">warn.celltypes</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), warn when the user is either 
trying to return a single tracks object while the metadata indicates there are 
multiple celltypes in the data, or when the user is trying to set <code>split.celltypes = TRUE</code> 
when there is only one celltype present.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_split.celltypes">split.celltypes</code></td>
<td>
<p>logical: if <code>TRUE</code> (default = <code>FALSE</code>), return not one
tracks object but a list of tracks objects for each celltype in the data (as 
determined from the metadata in the immunemap json).</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code><a href="#topic+get.immap.metadata">get.immap.metadata</a></code>.</p>
</td></tr>
<tr><td><code id="ReadImmuneMap_+3A_input">input</code></td>
<td>
<p>the output of <code>parse.immap.json</code> serves as input for <code>get.immap.tracks</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.immap.json</code> internally uses <code>parse.immap.json</code> to parse the json file,
<code>get.immap.tracks</code> to extract the tracks, and  <code><a href="#topic+get.immap.metadata">get.immap.metadata</a></code>
to read the metadata.
</p>


<h3>Value</h3>

<p><code>read.immap.json</code>  returns a list with:
</p>
<table>
<tr><td><code>tracks</code></td>
<td>
<p>either a single tracks object or a named list of tracks objects per cell type (if <code>split.celltypes = TRUE</code></p>
</td></tr>
<tr><td><code>metadata</code></td>
<td>
<p>a dataframe with metadata for all the track.ids; this is read from the immunemap json file.</p>
</td></tr>
</table>
<p><code>parse.immap.json</code> simply returns the R list generated from the input json file.
</p>
<p><code>get.immap.tracks</code> returns a single tracks object.
</p>


<h3>Note</h3>

<p>This functionality requires the rjson package to be installed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.immap.metadata">get.immap.metadata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read tracks from immunemap online, using the video info for automatic scaling
tr &lt;- read.immap.json( url = "https://api.immunemap.org/video/14" )

## Read tracks and rescale time (.5min/frame) and coordinates (2microns/pixel)
tracksUrl &lt;- "https://api.immunemap.org/video/14/tracks"
tr &lt;- read.immap.json( tracks.url = tracksUrl, scale.auto = FALSE, scale.t = .5, scale.pos = 2 )

## End(Not run)

## Read tracks from a file 
# tr &lt;- read.immap.json( tracks.url = "my-file.json", warn.scaling = FALSE )

</code></pre>

<hr>
<h2 id='repairGaps'>Process Tracks Containing Gaps</h2><span id='topic+repairGaps'></span>

<h3>Description</h3>

<p>Many common motility analyses, such as mean square displacement plots, assume that
object positions are recorded at constant time intervals. For some application domains,
such as intravital imaging, this may not always be the case. This function can be
used to pre-process data imaged at nonconstant intervals, provided the deviations are
not too extreme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairGaps(x, how = "split", tol = 0.05, split.min.length = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repairGaps_+3A_x">x</code></td>
<td>
<p>the input tracks object.</p>
</td></tr>
<tr><td><code id="repairGaps_+3A_how">how</code></td>
<td>
<p>string specifying what do with tracks that contain gaps. Possible
values are:
</p>

<ul>
<li><p> &quot;drop&quot;: the simplest option &ndash; discard all tracks that contain gaps.
</p>
</li>
<li><p> &quot;split&quot;:  split tracks around the gaps, e.g. a track for which the step
between the 3rd and 4th positions is too long or too short is split into one
track corresponding to positions 1 to 3 and another track corresponding to
position 3 onwards.
</p>
</li>
<li><p> &quot;interpolate&quot;:  approximate the track positions using linear
interpolation (see <code><a href="#topic+interpolateTrack">interpolateTrack</a></code>). The result is a tracks
object with constant step durations.
</p>
</li></ul>
</td></tr>
<tr><td><code id="repairGaps_+3A_tol">tol</code></td>
<td>
<p>nonnegative number specifying by which fraction each step may deviate
from the average step duration without being considered a gap. For instance, if
the average step duration (see <code><a href="#topic+timeStep">timeStep</a></code>) is 100 seconds and <code>tol</code>
is 0.05 (the default), then step durations between 95 and 105 seconds (both inclusive)
are not considered gaps. This option is ignored for <code>how="interpolate"</code>.</p>
</td></tr>
<tr><td><code id="repairGaps_+3A_split.min.length">split.min.length</code></td>
<td>
<p>nonnegative integer. For <code>how="split"</code>, this
discards all resulting tracks shorter than
this many positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+tracks">tracks</a></code> object with gaps fixed according to the chosen method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The Neutrophil data are imaged at rather nonconstant intervals
print( length( Neutrophils ) )
print( length( repairGaps( Neutrophils, tol=0.01 ) ) )

</code></pre>

<hr>
<h2 id='selectSteps'>Get Single Steps Starting at a Specific Time from a Subset of Tracks</h2><span id='topic+selectSteps'></span>

<h3>Description</h3>

<p>Obtain all single steps starting at a given timepoint t from a subset of tracks of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSteps(X, trackids, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSteps_+3A_x">X</code></td>
<td>
<p>Tracks object to obtain subtracks from</p>
</td></tr>
<tr><td><code id="selectSteps_+3A_trackids">trackids</code></td>
<td>
<p>Character vector with the ids of tracks of interest</p>
</td></tr>
<tr><td><code id="selectSteps_+3A_t">t</code></td>
<td>
<p>Timepoint at which the subtracks should start</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>tracks</em> object is returned which contains all the extracted steps.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subtracks">subtracks</a></code> to extract all subtracks of a given length,
<code><a href="#topic+prefixes">prefixes</a></code> to extract all subtracks of a given length starting
from the first coordinate in each track, <code><a href="#topic+subtracksByTime">subtracksByTime</a></code> to
extract all subtracks of a given length starting at some fixed timepoint, and
<code><a href="#topic+timePoints">timePoints</a></code> to return all timepoints occurring in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get and plot all steps starting at the third timepoint in tracks 1 and 3 of
## the T cell dataset
subT &lt;- selectSteps( TCells, c("1","5"), timePoints(TCells)[3] )
plot( subT )

</code></pre>

<hr>
<h2 id='selectTracks'>Select Tracks by Measure Values</h2><span id='topic+selectTracks'></span>

<h3>Description</h3>

<p>Given a tracks object, extract a subset based on upper and lower bounds of a certain
measure. For instance, extract all tracks with a certain minimum length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectTracks(x, measure, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectTracks_+3A_x">x</code></td>
<td>
<p>the input tracks.</p>
</td></tr>
<tr><td><code id="selectTracks_+3A_measure">measure</code></td>
<td>
<p>measure on which the selection is based (see <a href="#topic+TrackMeasures">TrackMeasures</a>).</p>
</td></tr>
<tr><td><code id="selectTracks_+3A_lower">lower</code></td>
<td>
<p>specifies the lower bound (inclusive) of the allowable measure.</p>
</td></tr>
<tr><td><code id="selectTracks_+3A_upper">upper</code></td>
<td>
<p>specifies the upper bound (inclusive) of the allowable measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+tracks">tracks</a></code> object with the selected subset of tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Slower half of T cells
slow.tcells &lt;- selectTracks( TCells, speed, -Inf, median( sapply(TCells,speed) ) )

</code></pre>

<hr>
<h2 id='simulateTracks'>Generate Tracks by Simulation</h2><span id='topic+simulateTracks'></span>

<h3>Description</h3>

<p>Generic function that executes <code>expr</code>, which is expected to
return a track, <code>n</code> times and stores the output in a <code>tracks</code>
object. Basically, this works like <code><a href="base.html#topic+replicate">replicate</a></code> but for tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateTracks(n, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateTracks_+3A_n">n</code></td>
<td>
<p>number of tracks to be generated.</p>
</td></tr>
<tr><td><code id="simulateTracks_+3A_expr">expr</code></td>
<td>
<p>the expression, usually a call, that generates a single track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tracks</code> object containing <code>n</code> tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate 10 tracks, 100 steps each, from a random walk with standard normally
## distributed increments and plot them
plot( simulateTracks( 10, brownianTrack(100,3) ) )

</code></pre>

<hr>
<h2 id='sort.tracks'>Sort Track Positions by Time</h2><span id='topic+sort.tracks'></span>

<h3>Description</h3>

<p>Sorts the positions in each track in a <em>tracks</em> object by time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tracks'
sort(x, decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.tracks_+3A_x">x</code></td>
<td>
<p>the <em>tracks</em> object whose tracks are to be sorted by time.</p>
</td></tr>
<tr><td><code id="sort.tracks_+3A_decreasing">decreasing</code></td>
<td>
<p>logical.  Should the sort be increasing or decreasing?
Provided only for consistency with the generic sort method. The positions in
each track should be sorted in increasing time order.</p>
</td></tr>
<tr><td><code id="sort.tracks_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>order</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sorts the positions of each track (represented as a data frame) in the
<em>tracks</em> object by time (given in the column t).
</p>


<h3>Value</h3>

<p>A <em>tracks object</em> that contains the tracks from the input object
sorted by time is returned.
</p>

<hr>
<h2 id='splitTrack'>Split Track into Multiple Tracks</h2><span id='topic+splitTrack'></span>

<h3>Description</h3>

<p>Split Track into Multiple Tracks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitTrack(x, positions, id = NULL, min.length = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitTrack_+3A_x">x</code></td>
<td>
<p>the input track (a data frame or a matrix).</p>
</td></tr>
<tr><td><code id="splitTrack_+3A_positions">positions</code></td>
<td>
<p>a vector of positive integers, given in ascending order.</p>
</td></tr>
<tr><td><code id="splitTrack_+3A_id">id</code></td>
<td>
<p>a string used to identify the resulting tracks; for instance,
if <code>id="X"</code>, then the resulting tracks are named X_1, X_2 and so forth.
Otherwise, they are simply labelled with integer numbers.</p>
</td></tr>
<tr><td><code id="splitTrack_+3A_min.length">min.length</code></td>
<td>
<p>nonnegative integer. Resulting tracks that have fewer positions than
the value of this parameter are dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <em>tracks</em> with the resulting splitted tracks.
</p>

<hr>
<h2 id='staggered'>Staggered Version of a Function</h2><span id='topic+staggered'></span>

<h3>Description</h3>

<p>Returns the &quot;staggered&quot; version of a track measure. That is, instead of
computing the measure on the whole track, the measure is averaged over
all subtracks (of any length) of the track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>staggered(measure, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="staggered_+3A_measure">measure</code></td>
<td>
<p>a track measure (see <a href="#topic+TrackMeasures">TrackMeasures</a>).</p>
</td></tr>
<tr><td><code id="staggered_+3A_...">...</code></td>
<td>
<p>further parameters passed on to <code><a href="#topic+applyStaggered">applyStaggered</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper mainly designed to provide a convenient interface
for track-based staggered computations with <code>lapply</code>, see example.
</p>


<h3>Value</h3>

<p>Returns a function that computes
the given measure in a staggered fashion on that track.
</p>


<h3>References</h3>

<p>Zeinab Mokhtari, Franziska Mech, Carolin Zitzmann, Mike Hasenberg, Matthias Gunzer
and Marc Thilo Figge (2013), Automated Characterization and
Parameter&ndash;Free Classification of Cell Tracks Based on Local Migration
Behavior. <em>PLoS ONE</em> <b>8</b>(12), e80808. doi:10.1371/journal.pone.0080808
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist( sapply( TCells, staggered( displacement ) ) )

</code></pre>

<hr>
<h2 id='stepPairs'>Find Pairs of Steps Occurring at the Same Time</h2><span id='topic+stepPairs'></span>

<h3>Description</h3>

<p>Find cell indices and timepoints where these cells both have a step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepPairs(X, filter.steps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepPairs_+3A_x">X</code></td>
<td>
<p>a tracks object</p>
</td></tr>
<tr><td><code id="stepPairs_+3A_filter.steps">filter.steps</code></td>
<td>
<p>optional: a function used to filter steps on. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with three columns: two for the indices of cellpairs that
share a step, and one for the timepoint at which they do so.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find all pairs of steps in the T cell data that displace at least 2 microns.
pairs &lt;- stepPairs( TCells, filter.steps = function(t) displacement(t) &gt; 2 )

</code></pre>

<hr>
<h2 id='subsample'>Subsample Track by Constant Factor</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>Make tracks more coarse-grained by keeping only every <em>k</em>th position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(x, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_x">x</code></td>
<td>
<p>an input track or tracks object.</p>
</td></tr>
<tr><td><code id="subsample_+3A_k">k</code></td>
<td>
<p>a positive integer. Every <code class="reqn">k</code>th position of each
input track is kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+tracks">tracks</a></code> object with the new, more coarse-grained tracks.
</p>


<h3>See Also</h3>

<p><code>interpolateTrack</code>, which can be used for more flexible track
coarse-graining.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare original and subsampled versions of the T cell tracks
plot( TCells, col=1 )
plot( subsample( TCells, 3 ), col=2, add=TRUE, pch.start=NULL )

</code></pre>

<hr>
<h2 id='subtracks'>Decompose Track(s) into Subtracks</h2><span id='topic+subtracks'></span>

<h3>Description</h3>

<p>Creates a <em>tracks</em> object consisting of all subtracks of 'x'
with 'i' segments (i.e., 'i'+1 positions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtracks(x, i, overlap = i - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtracks_+3A_x">x</code></td>
<td>
<p>a single track or a <code>tracks</code> object.</p>
</td></tr>
<tr><td><code id="subtracks_+3A_i">i</code></td>
<td>
<p>subtrack length. A single integer, lists are not supported.</p>
</td></tr>
<tr><td><code id="subtracks_+3A_overlap">overlap</code></td>
<td>
<p>the number of segments in which each subtrack shall overlap
with the previous and next subtrack. The default <code>i - 1</code> returns all
subtracks. Can be negative, which means that space will be left between
subtracks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is always a single <em>tracks</em> object, which is
convenient for many common analyses. If subtracks are to be considered separately
for each track, use the function <code><a href="#topic+staggered">staggered</a></code> together with
<code>lapply</code>. Subtrack extraction always starts at the first position of the
input track.
</p>


<h3>Value</h3>

<p>A <em>tracks</em> object is returned which contains all the subtracks
of any track in the input <em>tracks</em> object that consist of exactly 'i'
segments and overlap adjacent subtracks in 'overlap' segments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prefixes">prefixes</a></code> to extract all subtracks of a given length starting
from the first coordinate in each track, <code><a href="#topic+subtracksByTime">subtracksByTime</a></code> to extract
all subtracks of a given length  starting at some fixed timepoint,
and <code><a href="#topic+selectSteps">selectSteps</a></code> to extract single steps starting at a fixed timepoint
from a subset of trackids.
</p>

<hr>
<h2 id='subtracksByTime'>Extract Subtracks Starting at a Specific Time</h2><span id='topic+subtracksByTime'></span>

<h3>Description</h3>

<p>Obtain all subtracks of i steps (i+1 positions) starting at a given timepoint t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtracksByTime(X, t, i = 1, epsilon = 1e-04, tlo = t, thi = t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtracksByTime_+3A_x">X</code></td>
<td>
<p>Tracks object to obtain subtracks from.</p>
</td></tr>
<tr><td><code id="subtracksByTime_+3A_t">t</code></td>
<td>
<p>Timepoint at which the subtracks should start. This value is ignored if
tlo and thi are specified, see below.</p>
</td></tr>
<tr><td><code id="subtracksByTime_+3A_i">i</code></td>
<td>
<p>Subtrack length (in number of steps). Set this to NULL to obtain subtracks
of varying length but within a specified interval [tlo, thi] (see below).</p>
</td></tr>
<tr><td><code id="subtracksByTime_+3A_epsilon">epsilon</code></td>
<td>
<p>Small error allowed when comparing timepoints because of numerical
inaccuracies, see details. Timepoints in tracks are returned if they are within
[tlo-epsilon, thi+epsilon].</p>
</td></tr>
<tr><td><code id="subtracksByTime_+3A_tlo">tlo</code>, <code id="subtracksByTime_+3A_thi">thi</code></td>
<td>
<p>Interval specifying the timepoints to be returned. By default, these
are not used and tracks starting at timepoint t with exactly i steps are returned;
see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If i is specified, the given t is retrieved for all tracks in X that contain that
timepoint, and any subtracks starting from that time that have exactly i steps are
returned. For numerical reasons, timepoints in the data are allowed to deviate
a small amount epsilon from t (because otherwise, equal timepoints can seem unequal
because of very small deviations).
</p>
<p>If i is set to NULL, subtracks are returned with all timepoints lying in the interval
[ tlo - epsilon, thi + epsilon ]. These subtracks do NOT have to be of equal length.
</p>


<h3>Value</h3>

<p>A <em>tracks</em> object is returned which contains all the subtracks
of any track in the input <em>tracks</em> object that consist of exactly 'i'
segments and start at the given timepoint t, OR a
<em>tracks</em> object with all the timepoints
of any track in the input <em>tracks</em> object that are between tlo and thi.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subtracks">subtracks</a></code> to extract all subtracks of a given length,
<code><a href="#topic+prefixes">prefixes</a></code> to extract all subtracks of a given length starting
from the first coordinate in each track, <code><a href="#topic+selectSteps">selectSteps</a></code> to extract
single steps starting at a fixed timepoint from a subset of trackids, and
<code><a href="#topic+timePoints">timePoints</a></code> to return all timepoints occurring in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get all the single steps (i=1) starting at the third timepoint in the T cell tracks.
subT &lt;- subtracksByTime( TCells, timePoints(TCells)[3], 1 )

## These all have the same number of steps:
sapply( subT, nrow )

## Or set i to NULL and return all subtracks within the five first timepoints:
subT2 &lt;- subtracksByTime( TCells, NULL, i = NULL,
  tlo = timePoints( TCells )[1], thi = timePoints( TCells )[5] )

## These are not all the same length:
sapply( subT2, nrow )

</code></pre>

<hr>
<h2 id='TCells'>Two-Photon Data: T Cells in a Lymph Node</h2><span id='topic+TCells'></span>

<h3>Description</h3>

<p>RFP-labelled T cells were injected retro-orbitally in healthy CD11c-YFP mice, and 
intravitally imaged (using two-photon microscopy) inside a cervical lymph
node. These data illustrate the characteristic &quot;random-walk-like&quot; motion pattern 
of T cells in lymph nodes. For full method details, see references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("TCells")
</code></pre>


<h3>Format</h3>

<p>## 'TCells'
An S3 object of class &quot;tracks&quot;; a list with 199 elements. Each 
element name identifies a cell track. Each element is a matrix
containing the following three columns.
</p>

<dl>
<dt><code>t</code></dt><dd><p>the time (in seconds)</p>
</dd>
<dt><code>x</code></dt><dd><p>The X coordinate (in micrometers)</p>
</dd>
<dt><code>y</code></dt><dd><p>The Y coordinate (in micrometers)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were generated in 2021 in the Mark J. Miller Lab, Department of Medicine, Washington University in St Louis, USA.
</p>


<h3>References</h3>

<p>Miller MJ and Wei SH and Parker I and Cahalan MD (2002), 
Two-photon imaging of lymphocyte motility and antigen response in intact lymph node.
<em>Science</em>, <b>296</b>(5574):1869&ndash;1873. doi:10.1126/science.1070051
</p>
<p>Wortel IMN and Liu AY and Dannenberg K and Berry JC and Miller MJ and Textor J (2021),
CelltrackR: an R package for fast and flexible analysis of immune cell migration data.
<em>ImmunoInformatics</em>, <b>1-2</b>:100003. doi:10.1016/j.immuno.2021.100003
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## load the tracks
  data(TCells)

  ## visualize the tracks (calls function plot.tracks)
  plot(TCells)

</code></pre>

<hr>
<h2 id='timePoints'>Find All Unique Time Points in a Track Dataset</h2><span id='topic+timePoints'></span>

<h3>Description</h3>

<p>Return a vector of all the timepoints t found in any of the matrices in the
tracks object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timePoints(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timePoints_+3A_x">X</code></td>
<td>
<p>a tracks object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of unique timepoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get all timepoints in the T cell dataset
tp &lt;- timePoints( TCells )

</code></pre>

<hr>
<h2 id='timeStep'>Compute Time Step of Tracks</h2><span id='topic+timeStep'></span>

<h3>Description</h3>

<p>Applies a summary statistics on the time intervals between pairs of consecutive
positions in a track dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeStep(x, FUN = median, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeStep_+3A_x">x</code></td>
<td>
<p>the input tracks.</p>
</td></tr>
<tr><td><code id="timeStep_+3A_fun">FUN</code></td>
<td>
<p>the summary statistic to be applied.</p>
</td></tr>
<tr><td><code id="timeStep_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates whether to remove missing values before applying FUN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most track quantification depends on the assumption that track positions are
recorded at constant time intervals. If this is not the case, then most of the statistics
in this package (except for some very simple ones like <code><a href="#topic+duration">duration</a></code>) will not work.
In reality, at least small fluctuations of the time steps can be expected. This
function provides a means for quality control with respect to the tracking time.
</p>


<h3>Value</h3>

<p>Summary statistic of the time intervals between two consecutive positions in a track
dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Show tracking time fluctuations for the T cell data
d &lt;- timeStep( TCells )
plot( sapply( subtracks( TCells, 1 ) , duration ) - d, ylim=c(-d,d) )

</code></pre>

<hr>
<h2 id='trackFeatureMap'>Dimensionality Reduction on Track Features</h2><span id='topic+trackFeatureMap'></span>

<h3>Description</h3>

<p>Perform a quick dimensionality reduction visualization of a set of tracks according to a given vector
of track measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackFeatureMap(
  tracks,
  measures,
  scale = TRUE,
  labels = NULL,
  method = "PCA",
  return.mapping = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackFeatureMap_+3A_tracks">tracks</code></td>
<td>
<p>the tracks that are to be clustered.</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_measures">measures</code></td>
<td>
<p>a function, or a vector of functions (see <a href="#topic+TrackMeasures">TrackMeasures</a>).
Each function is expected to
return a single number given a single track.</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether the measures values shall be scaled
using the function <code><a href="base.html#topic+scale">scale</a></code> before the mapping is performed.</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_labels">labels</code></td>
<td>
<p>optional: a vector of labels of the same length as the track object.
These are used to color points in the visualization.</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_method">method</code></td>
<td>
<p><code>"PCA"</code> for a
scatterplot along principal components, <code>"MDS"</code> for multidimensional scaling,
<code>"UMAP"</code> for a UMAP. Note that for
<code>"UMAP"</code>, the <code>uwot</code> package must be installed.</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_return.mapping">return.mapping</code></td>
<td>
<p>logical: return the mapping object instead of only the plot?
(defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="trackFeatureMap_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the corresponding
function: <code><a href="stats.html#topic+prcomp">prcomp</a></code> (for <code>method="PCA"</code>),
<code><a href="stats.html#topic+cmdscale">cmdscale</a></code> (for <code>method="MDS"</code>),
or  <code><a href="uwot.html#topic+umap">umap</a></code> (for <code>method="UMAP"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measures are applied to each of the tracks in the given
<em>tracks</em> object. According to the resulting values, the tracks are
mapped to fewer dimensions using the chosen method.
If <code>scale</code> is <code>TRUE</code>, the measure values are scaled to mean value
<code class="reqn">0</code> and standard deviation <code class="reqn">1</code> (per measure) before the mapping.
</p>
<p>The dimensionality reduction methods PCA, MDS, and UMAP each produce a
scatterplot of all tracks as points, plotted along the principal component
axes generated by the corresponding method.
</p>


<h3>Value</h3>

<p>By default, only returns a plot. If <code>return.clust=TRUE</code>, also returns
a clustering object as returned by <code><a href="stats.html#topic+hclust">hclust</a></code>,  <code><a href="stats.html#topic+kmeans">kmeans</a></code>,
<code><a href="stats.html#topic+prcomp">prcomp</a></code> (returns <code>$x</code>), <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>,
or  <code><a href="uwot.html#topic+umap">umap</a></code> (returns <code>$layout</code>). See the documentation of those functions for details on the
output object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFeatureMatrix">getFeatureMatrix</a></code> to obtain a feature matrix that can be
used for manual clustering and plotting, and <code><a href="#topic+clusterTracks">clusterTracks</a></code> to
perform hierarchical or k-means clustering on a tracks dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Map tracks according to speed, mean turning angle, straightness, and asphericity
## using multidimensional scaling, and store output.

cells &lt;- c(TCells,Neutrophils)
real.celltype &lt;- rep(c("T","N"),c(length(TCells),length(Neutrophils)))
## Prefix each track ID with its cell class to evaluate the clustering visually
names(cells) &lt;- paste0(real.celltype,seq_along(cells))
map &lt;- trackFeatureMap( cells, c(speed,meanTurningAngle,straightness, asphericity),
 method = "MDS",  return.mapping = TRUE  )

</code></pre>

<hr>
<h2 id='TrackMeasures'>Track Measures</h2><span id='topic+TrackMeasures'></span><span id='topic+trackLength'></span><span id='topic+duration'></span><span id='topic+speed'></span><span id='topic+displacement'></span><span id='topic+squareDisplacement'></span><span id='topic+displacementVector'></span><span id='topic+maxDisplacement'></span><span id='topic+displacementRatio'></span><span id='topic+outreachRatio'></span><span id='topic+straightness'></span><span id='topic+overallAngle'></span><span id='topic+meanTurningAngle'></span><span id='topic+overallDot'></span><span id='topic+overallNormDot'></span><span id='topic+asphericity'></span><span id='topic+hurstExponent'></span><span id='topic+fractalDimension'></span>

<h3>Description</h3>

<p>Statistics that can be used to quantify tracks. All of these functions take a single
track as input and give a single number as output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackLength(x)

duration(x)

speed(x)

displacement(x, from = 1, to = nrow(x))

squareDisplacement(x, from = 1, to = nrow(x))

displacementVector(x)

maxDisplacement(x)

displacementRatio(x)

outreachRatio(x)

straightness(x)

overallAngle(x, from = 1, to = nrow(x), xdiff = diff(x), degrees = FALSE)

meanTurningAngle(x, degrees = FALSE)

overallDot(x, from = 1, to = nrow(x), xdiff = diff(x))

overallNormDot(x, from = 1, to = nrow(x), xdiff = diff(x))

asphericity(x)

hurstExponent(x)

fractalDimension(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrackMeasures_+3A_x">x</code></td>
<td>
<p>a single input track; a matrix whose first column is time and whose
remaining columns are a spatial coordinate.</p>
</td></tr>
<tr><td><code id="TrackMeasures_+3A_from">from</code></td>
<td>
<p>index, or vector of indices, of the first row of the track.</p>
</td></tr>
<tr><td><code id="TrackMeasures_+3A_to">to</code></td>
<td>
<p>index, or vector of indices, of last row of the track.</p>
</td></tr>
<tr><td><code id="TrackMeasures_+3A_xdiff">xdiff</code></td>
<td>
<p>row differences of x.</p>
</td></tr>
<tr><td><code id="TrackMeasures_+3A_degrees">degrees</code></td>
<td>
<p>logical; should angles be returned in degrees rather than radians?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some track measures consider only the first and last position (or steps) of a track,
and are most useful in conjunction with <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>; for instance,
<code>squareDisplacement</code> combined with <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code> gives a mean
square displacement plot, and <code>overallAngle</code> combined with
<code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code> gives a turning angle plot (see the examples for
<code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>). To speed up computation of these measures on
subtracks of the same track, the arguments <code>from</code>, <code>to</code> and
possibly <code>xdiff</code> are exploited by <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>.
</p>


<h3>Value</h3>

<p><code>trackLength</code> sums up the distances between subsequent positsion; in other words,
it estimates the length of the underlying track by linear interpolation (usually
an underestimation). The estimation could be improved in some circumstances by using
<code><a href="#topic+interpolateTrack">interpolateTrack</a></code>. The function returns a single, non-negative number.
</p>
<p><code>duration</code> returns the time elapsed between <code>x</code>'s first and last
positions (a single, non-negative number).
</p>
<p><code>speed</code> simply divides <code><a href="#topic+trackLength">trackLength</a></code> by <code><a href="#topic+duration">duration</a></code>
</p>
<p><code>displacement</code> returns the Euclidean distance between the track endpoints
and <code>squareDisplacement</code> returns the squared Euclidean distance.
</p>
<p><code>displacementVector</code> returns the vector between the track endpoints. This
vector has an element (can be negative) for each (x,y,z) dimension of the coordinates
in the track.
</p>
<p><code>maxDisplacement</code> computes the maximal Euclidean distance of any position
on the track from the first position.
</p>
<p><code>displacementRatio</code> divides the <code>displacement</code> by the <code>maxDisplacement</code>;
<code>outreachRatio</code> divides the <code>maxDisplacement</code> by the <code>trackLength</code>
(Mokhtari et al, 2013). Both measures return
values between 0 and 1, where 1 means a perfectly straight track.
If the track has <code>trackLength</code> 0, then <code>NaN</code> is returned.
</p>
<p><code>straightness</code> divides the <code>displacement</code> by the <code>trackLength</code>.
This gives a number between 0 and 1, with 1 meaning a perfectly straight track.
If the track has <code>trackLength</code> 0, then <code>NaN</code> is returned.
</p>
<p><code>asphericity</code> is a different appraoch to measure straightness
(Mokhtari et al, 2013): it computes the asphericity of the set of positions on the
track _via_ the length of its principal components. Again this gives a number between 0
and 1, with higher values indicating straighter tracks.
Unlike <code><a href="#topic+straightness">straightness</a></code>, however, asphericity ignores
back-and-forth motion of the object, so something that bounces between two positions
will have low <code>straightness</code> but high <code>asphericity</code>. We define the
asphericity of every track with two or fewer positions to be 1. For one-dimensional
tracks with one or more positions, <code>NA</code> is returned.
</p>
<p><code>overallAngle</code> Computes the angle (in radians) between the first and the last
segment of the given track. Angles are measured symmetrically, thus the return values
range from 0 to pi; for instance, both a 90 degrees left and right turns yield the
value pi/2. This function is useful to generate autocorrelation plots
(together with <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>). Angles can also be returned in degrees,
in that case: set <code>degrees = TRUE</code>.
</p>
<p><code>meanTurningAngle</code> averages the <code>overallAngle</code> over all
adjacent segments of a given track; a low <code>meanTurningAngle</code> indicates high
persistence of orientation, whereas for an uncorrelated random walk we expect
90 degrees. Note that angle measurements will yield <code>NA</code> values for tracks
in which two subsequent positions are identical. By default returns angles in
radians; use <code>degrees = TRUE</code> to return angles in degrees instead.
</p>
<p><code>overallDot</code> computes the dot product between the first and the last
segment of the given track. This function is useful to generate autocovariance plots
(together with <code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>).
</p>
<p><code>overallNormDot</code> computes the dot product between the unit vectors along
the first and the last segment of the given track. This function is useful to
generate autocorrelation plots (together with
<code><a href="#topic+aggregate.tracks">aggregate.tracks</a></code>).
</p>
<p><code>hurstExponent</code> computes the corrected empirical Hurst exponent of the track.
This uses the function <code><a href="pracma.html#topic+hurstexp">hurstexp</a></code> from the 'pracma' package.
If the track has less than two positions, NA is returned.
<code>fractalDimension</code> estimates the fractal dimension of a track using the function
<code><a href="fractaldim.html#topic+fd.estim.boxcount">fd.estim.boxcount</a></code> from the
'fractaldim' package. For self-affine processes in <code class="reqn">n</code> dimensions,
fractal dimension and Hurst exponent
are related by the formula <code class="reqn">H=n+1-D</code>.
For non-Brownian motion, however, this relationship
need not hold. Intuitively, while the Hurst exponent takes a global approach to the
track's properties, fractal dimension is a local approach to the track's properties
(Gneiting and Schlather, 2004).
</p>


<h3>References</h3>

<p>Zeinab Mokhtari, Franziska Mech, Carolin Zitzmann, Mike Hasenberg, Matthias Gunzer
and Marc Thilo Figge (2013), Automated Characterization and
Parameter&ndash;Free Classification of Cell Tracks Based on Local Migration
Behavior. <em>PLoS ONE</em> <b>8</b>(12), e80808. doi:10.1371/journal.pone.0080808
</p>
<p>Tillmann Gneiting and Martin Schlather (2004), Stochastic Models That Separate Fractal
Dimension and the Hurst Effect. <em>SIAM Review</em> <b>46</b>(2), 269&ndash;282.
doi:10.1137/S0036144501394387
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AngleAnalysis">AngleAnalysis</a></code> for methods to compute angles and distances
between pairs of tracks, or of tracks to a reference point, direction, or plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show a turning angle plot with error bars for the T cell data.
with( (aggregate(BCells,overallDot,FUN="mean.se",na.rm=TRUE)),{
  plot( mean ~ i, xlab="time step",
  	ylab="turning angle (rad)", type="l" )
  segments( i, lower, y1=upper )
} )

</code></pre>

<hr>
<h2 id='tracks'>Tracks Objects</h2><span id='topic+tracks'></span><span id='topic+as.tracks'></span><span id='topic+as.tracks.list'></span><span id='topic+is.tracks'></span><span id='topic+c.tracks'></span>

<h3>Description</h3>

<p>The function <code>tracks</code> is used to create tracks objects. <code>as.tracks</code> coerces
its argument to a tracks object, and <code>is.tracks</code> tests for tracks objects.
<code>c</code> can be used to combine (concatenate) tracks objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tracks(x, ...)

## S3 method for class 'list'
as.tracks(x, ...)

is.tracks(x)

## S3 method for class 'tracks'
c(...)

tracks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracks_+3A_x">x</code></td>
<td>
<p>an object to be coerced or tested.</p>
</td></tr>
<tr><td><code id="tracks_+3A_...">...</code></td>
<td>
<p>for <code>tracks</code>, numeric matrices or objects that can be coerced to
numeric matrices. Each
matrix contains the data of one track. The first column is the time, and the remaining
columns define a spatial position. Every given matrix has to contain the same number
of columns, and at least two columns are necessary.
</p>
<p>For <code>c</code>, tracks objects to be combined.
</p>
<p>For <code>as.tracks</code>, further arguments passed to methods (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tracks objects are lists of matrices. Each matrix contains at least two
columns; the first column is time, and the remaining columns are a spatial coordinate.
The following naming conventions are used (and enforced by <code>tracks</code>): The time
column has the name 't', and spatial coordinate columns have names 'x','y','z' if there
are three or less coordinates, and 'x1',...,'xk' if there are <code class="reqn">k \ge 4</code>
coordinates. All tracks in an object must have the same number of dimensions. The
positions in a track are expected to be sorted by time (and the constructor
<code>tracks</code> enforces this).
</p>


<h3>Value</h3>

<p>A <code>tracks</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A single 1D track
x &lt;- tracks( matrix(c(0, 8,
10, 9,
20, 7,
30, 7,
40, 6,
50, 5), ncol=2, byrow=TRUE ) )

## Three 3D tracks
x2 &lt;- tracks( rbind(
 c(0,5,0), c(1,5,3), c(2,1,3), c(3,5,6) ),
 rbind( c(0,1,1),c(1,1,4),c(2,5,4),c(3,5,1),c(4,-3,1) ),
 rbind( c(0,7,0),c(1,7,2),c(2,7,4),c(3,7,7) ) )

</code></pre>

<hr>
<h2 id='vecAngle'>Angle Between Two Vectors</h2><span id='topic+vecAngle'></span>

<h3>Description</h3>

<p>Compute the angle between two vectors a and b, which can be numeric vectors
or matrices in which each row represents a  numeric vector.
In the last case, one angle is returned for each row. By default, angles
are returned in degrees &ndash; set <code>degrees = TRUE</code> to return radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecAngle(a, b, degrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecAngle_+3A_a">a</code></td>
<td>
<p>the first vector or set of vectors. Must be a numeric vector or a
matrix where each row represents a numeric vector.</p>
</td></tr>
<tr><td><code id="vecAngle_+3A_b">b</code></td>
<td>
<p>the second vector or set of vectors, for which angles with the
vector (set) a must be computed. Must have the same dimensions as a.</p>
</td></tr>
<tr><td><code id="vecAngle_+3A_degrees">degrees</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), return angles in degrees instead of radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single angle (if a and b are single vectors) or a numeric vector of
angles (if a and b are matrices; in that case, the output vector contains one
angle for each row in matrices a and b).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The angle between the vectors [0,1] and [1,0] is 90 degrees:
vecAngle( c(0,1), c(1,0) )
## The same holds for 3D angles:
vecAngle( c(0,1,0), c(1,0,0) )
</code></pre>

<hr>
<h2 id='wrapTrack'>Create Track Object from Single Track</h2><span id='topic+wrapTrack'></span>

<h3>Description</h3>

<p>Makes a <code>tracks</code> object containing the given track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapTrack(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapTrack_+3A_x">x</code></td>
<td>
<p>the input track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>tracks</code> containing only the input track <code>x</code>, which
is assigned the name &quot;1&quot;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
