<!DOCTYPE html><html lang="en-US"><head><title>Help for package fgeo.analyze</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fgeo.analyze}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fgeo.analyze-package'><p>fgeo.analyze: Analyze ForestGEO Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#abundance'><p>Abundance and basal area, optionally by groups.</p></a></li>
<li><a href='#abundance_byyr'><p>Create tables of abundance and basal area by year.</p></a></li>
<li><a href='#fgeo_habitat'><p>Create habitat data from measures of topography.</p></a></li>
<li><a href='#fgeo_topography'><p>Create topography data: convexity, slope, and mean elevation.</p></a></li>
<li><a href='#recruitment_ctfs'><p>Recruitment, mortality, and growth.</p></a></li>
<li><a href='#reexports'><p>Coerce objects different fgeo classes &quot;data.frame&quot; or &quot;tbl&quot; (tibble).</p></a></li>
<li><a href='#summary.tt_df'><p>Summary of <code>tt_test()</code> results.</p></a></li>
<li><a href='#tt_test'><p>Torus Translation Test to determine habitat associations of tree species.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analyze ForestGEO Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.14</td>
</tr>
<tr>
<td>Description:</td>
<td>To help you access, transform, analyze, and
    visualize ForestGEO data, we developed a collection of R packages
    (<a href="https://forestgeo.github.io/fgeo/">https://forestgeo.github.io/fgeo/</a>). This package, in particular,
    helps you to implement analyses of plot species distributions,
    topography, demography, and biomass. It also includes a torus
    translation test to determine habitat associations of tree species as
    described by Zuleta et al. (2018) &lt;<a href="https://doi.org/10.1007%2Fs11104-018-3878-0">doi:10.1007/s11104-018-3878-0</a>&gt;. To
    learn more about ForestGEO visit <a href="https://forestgeo.si.edu/">https://forestgeo.si.edu/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/forestgeo/fgeo.analyze">https://github.com/forestgeo/fgeo.analyze</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/forestgeo/fgeo.analyze/issues">https://github.com/forestgeo/fgeo.analyze/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.0.1), fgeo.tool (&ge; 1.2.4), glue (&ge; 1.3.1),
graphics, lubridate (&ge; 1.7.4), magrittr (&ge; 1.5), MASS, purrr
(&ge; 0.3.2), rlang (&ge; 0.3.4), stats, tibble (&ge; 2.1.1), tidyr
(&ge; 0.8.3), withr (&ge; 2.1.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.2.1), fgeo.plot (&ge; 1.1.8), fgeo.x (&ge; 1.1.3),
ggplot2 (&ge; 3.1.1), knitr (&ge; 1.22), measurements (&ge; 1.3.0),
readr (&ge; 1.3.1), rmarkdown (&ge; 1.12), spelling (&ge; 2.1),
testthat (&ge; 2.1.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-05 01:03:53 UTC; mauro</td>
</tr>
<tr>
<td>Author:</td>
<td>Mauro Lepore <a href="https://orcid.org/0000-0002-1986-7988"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctr, cre],
  Gabriel Arellano [aut, rev],
  Richard Condit [aut],
  Matteo Detto [aut],
  Kyle Harms [aut],
  Suzanne Lao [aut, rev],
  KangMin Ngo [rev],
  Haley Overstreet [rev],
  Sabrina Russo [aut, rev],
  Daniel Zuleta [aut, rev],
  CTFS-ForestGEO [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mauro Lepore &lt;maurolepore@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-05 05:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='fgeo.analyze-package'>fgeo.analyze: Analyze ForestGEO Data</h2><span id='topic+fgeo.analyze'></span><span id='topic+fgeo.analyze-package'></span>

<h3>Description</h3>

<p>To help you access, transform, analyze, and
visualize ForestGEO data, we developed a collection of R packages
(&lt;https://forestgeo.github.io/fgeo/&gt;). This package, in particular,
helps you to implement analyses of plot species distributions,
topography, demography, and biomass. It also includes a torus
translation test to determine habitat associations of tree species as
described by Zuleta et al. (2018) &lt;doi:10.1007/s11104-018-3878-0&gt;. To
learn more about ForestGEO visit &lt;https://forestgeo.si.edu/&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mauro Lepore <a href="mailto:maurolepore@gmail.com">maurolepore@gmail.com</a> (<a href="https://orcid.org/0000-0002-1986-7988">ORCID</a>) [contractor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Gabriel Arellano <a href="mailto:gabriel.arellano.torres@gmail.com">gabriel.arellano.torres@gmail.com</a> [reviewer]
</p>
</li>
<li><p> Richard Condit <a href="mailto:richardcondit@gmail.com">richardcondit@gmail.com</a>
</p>
</li>
<li><p> Matteo Detto <a href="mailto:teoparaglider@gmail.com">teoparaglider@gmail.com</a>
</p>
</li>
<li><p> Kyle Harms <a href="mailto:kharms@lsu.edu">kharms@lsu.edu</a>
</p>
</li>
<li><p> Suzanne Lao <a href="mailto:laoz@si.edu">laoz@si.edu</a> [reviewer]
</p>
</li>
<li><p> Sabrina Russo <a href="mailto:srusso2@unl.edu">srusso2@unl.edu</a> [reviewer]
</p>
</li>
<li><p> Daniel Zuleta <a href="mailto:dfzuleta@gmail.com">dfzuleta@gmail.com</a> [reviewer]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> KangMin Ngo <a href="mailto:ngokangmin@gmail.com">ngokangmin@gmail.com</a> [reviewer]
</p>
</li>
<li><p> Haley Overstreet <a href="mailto:OverstreetH@si.edu">OverstreetH@si.edu</a> [reviewer]
</p>
</li>
<li><p> CTFS-ForestGEO <a href="mailto:ForestGEO@si.edu">ForestGEO@si.edu</a> [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/forestgeo/fgeo.analyze">https://github.com/forestgeo/fgeo.analyze</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/forestgeo/fgeo.analyze/issues">https://github.com/forestgeo/fgeo.analyze/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='abundance'>Abundance and basal area, optionally by groups.</h2><span id='topic+abundance'></span><span id='topic+basal_area'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+abundance">abundance()</a></code> counts the number of rows in a dataset, optionally by groups
created with <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> (similar to <code><a href="dplyr.html#topic+context">dplyr::n()</a></code>). It warns if it
detects duplicated values of treeid.
</p>
</li>
<li> <p><code><a href="#topic+basal_area">basal_area()</a></code> sums the basal area of
all stems in a dataset, optionally by groups created with <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. It
warns if it detects duplicated values of stemid. It does not convert units
(but see examples).
</p>
</li></ul>

<p>Both <code><a href="#topic+abundance">abundance()</a></code> and <code><a href="#topic+basal_area">basal_area()</a></code> warn if they detect
multiple censusid and multiple plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundance(data)

basal_area(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abundance_+3A_data">data</code></td>
<td>
<p>A dataframe. <code><a href="#topic+basal_area">basal_area()</a></code> requires a column named <code>dbh</code> (case
insensitive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You may want to calculate the abundance or basal area for a specific subset
of data (e.g. &quot;alive&quot; stems or stems which <code>dbh</code> is within some range).
Subsetting data is not the job of these functions. Instead see
<code><a href="base.html#topic+subset">base::subset()</a></code>, <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>, or <code>[</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+context">dplyr::n()</a></code>, <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>
<p>Other functions for abundance and basal area: 
<code><a href="#topic+abundance_byyr">abundance_byyr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fgeo.tool)

# abundance() -------------------------------------------------------------

abundance(data.frame(1))

# One stem per tree
tree &lt;- tribble(
  ~TreeID, ~StemID, ~DBH,
  "1", "1.1", 11,
  "2", "2.1", 21
)

abundance(tree)

# One tree with multiple stems
stem &lt;- tribble(
  ~TreeID, ~StemID, ~DBH,
  "1", "1.1", 11,
  "1", "1.2", 12
)

abundance(stem)

# Skip R CMD check for speed

# Similar but more realistic
assert_is_installed("fgeo.x")
stem &lt;- fgeo.x::download_data("luquillo_stem5_random")

abundance(stem)

abundance(pick_main_stem(stem))


vft &lt;- tribble(
  ~PlotName, ~CensusID, ~TreeID, ~StemID, ~DBH,
  "p", 1, "1", "1.1", 10,
  "q", 2, "1", "1.1", 10
)

# * Warns if it detects multiple values of censusid or plotname
# * Also warns if it detects duplicated values of treeid
abundance(vft)

# If trees have buttressess, the data may have multiple stems per treeid or
# multiple measures per stemid.
vft2 &lt;- tribble(
  ~CensusID, ~TreeID, ~StemID, ~DBH, ~HOM,
  1, "1", "1.1", 88, 130,
  1, "1", "1.1", 10, 160,
  1, "2", "2.1", 20, 130,
  1, "2", "2.2", 30, 130,
)

# You should count only the main stem of each tree
(main_stem &lt;- pick_main_stem(vft2))

abundance(main_stem)

vft3 &lt;- tribble(
  ~CensusID, ~TreeID, ~StemID, ~DBH, ~HOM,
  1, "1", "1.1", 20, 130,
  1, "1", "1.2", 10, 160, # Main stem
  2, "1", "1.1", 12, 130,
  2, "1", "1.2", 22, 130 # Main stem
)

# You can compute by groups
by_census &lt;- group_by(vft3, CensusID)
(main_stems_by_census &lt;- pick_main_stem(by_census))

abundance(main_stems_by_census)

# basal_area() ------------------------------------------------------------

# Data must have a column named dbh (case insensitive)
basal_area(data.frame(dbh = 1))

# * Warns if it detects multiple values of censusid or plotname
# * Also warns if it detects duplicated values of stemid
basal_area(vft)

# First you may pick the main stemid of each stem
(main_stemids &lt;- pick_main_stemid(vft2))

basal_area(main_stemids)

# You can compute by groups
basal_area(by_census)

# Skip R CMD check for speed

measurements_is_installed &lt;- requireNamespace("measurements", quietly = TRUE)
if (measurements_is_installed) {
  library(measurements)

  # Convert units
  ba &lt;- basal_area(by_census)
  ba$basal_area_he &lt;- conv_unit(
    ba$basal_area,
    from = "mm2",
    to = "hectare"
  )

  ba
}


</code></pre>

<hr>
<h2 id='abundance_byyr'>Create tables of abundance and basal area by year.</h2><span id='topic+abundance_byyr'></span><span id='topic+basal_area_byyr'></span>

<h3>Description</h3>


<ul>
<li> <p><code>abundance_byyr()</code> first picks the main stem of each tree (see
?<code><a href="fgeo.tool.html#topic+pick_main_stem">fgeo.tool::pick_main_stem()</a></code>). Then, for each species and each
round-mean-year of measurement, it counts the number of trees. The result
includes <strong>main stems</strong> within a given dbh range.
</p>
</li>
<li> <p><code>basal_area_byyr()</code> first sums the basal basal area of all stems of each
tree. Then, for each species and each round-mean-year of measurement,
it sums the basal area of all trees. The result includes all stems within a
given dbh range (notice the difference with <code>abundance_byyr()</code>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>abundance_byyr(vft, ...)

basal_area_byyr(vft, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abundance_byyr_+3A_vft">vft</code></td>
<td>
<p>A ForestGEO-like dataframe; particularly a ViewFullTable. As such,
it should contain columns <code>PlotName</code>, <code>CensusID</code>, <code>TreeID</code>, <code>StemID</code>,
<code>Status</code>, <code>DBH</code>, <code>Genus</code>, <code>SpeciesName</code>, <code>ExactDate</code>, <code>PlotCensusNumber</code>,
<code>Family</code>, <code>Tag</code>, and <code>HOM</code>. <code>ExactDate</code> should contain dates from
1980-01-01 to the present day in the format yyyy-mm-dd.</p>
</td></tr>
<tr><td><code id="abundance_byyr_+3A_...">...</code></td>
<td>
<p>Expressions to pick main stems of a specific <code>dbh</code> range (e.g.
<code>DBH &gt;= 10</code> or <code style="white-space: pre;">&#8288;DBH &gt;= 10, DBH &lt; 20&#8288;</code>, or <code>DBH &gt;= 10 &amp; DBH &lt; 20</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You don't need to pick stems by status before feeding data to these
functions. Doing so may make your code more readable but it should not affect
the result. This is because the expressions passed to <code>...</code> pick data by
<code>dbh</code> and exclude the missing <code>dbh</code> values associated to non-alive stems,
including dead, missing, and gone stems.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="fgeo.tool.html#topic+pick_main_stem">fgeo.tool::pick_main_stem()</a></code>.
</p>
<p>Other functions for abundance and basal area: 
<code><a href="#topic+abundance">abundance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fgeo.tool)

# Example data
vft &lt;- tibble(
  PlotName = c("luq", "luq", "luq", "luq", "luq", "luq", "luq", "luq"),
  CensusID = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L),
  TreeID = c(1L, 1L, 2L, 2L, 1L, 1L, 2L, 2L),
  StemID = c(1.1, 1.2, 2.1, 2.2, 1.1, 1.2, 2.1, 2.2),
  Status = c(
    "alive", "dead", "alive", "alive", "alive", "gone",
    "dead", "dead"
  ),
  DBH = c(10L, NA, 20L, 30L, 20L, NA, NA, NA),
  Genus = c("Gn", "Gn", "Gn", "Gn", "Gn", "Gn", "Gn", "Gn"),
  SpeciesName = c("spp", "spp", "spp", "spp", "spp", "spp", "spp", "spp"),
  ExactDate = c(
    "2001-01-01", "2001-01-01", "2001-01-01", "2001-01-01",
    "2002-01-01", "2002-01-01", "2002-01-01",
    "2002-01-01"
  ),
  PlotCensusNumber = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L),
  Family = c("f", "f", "f", "f", "f", "f", "f", "f"),
  Tag = c(1L, 1L, 2L, 2L, 1L, 1L, 2L, 2L),
  HOM = c(130L, 130L, 130L, 130L, 130L, 130L, 130L, 130L)
)

vft

abundance_byyr(vft, DBH &gt;= 10, DBH &lt; 20)

abundance_byyr(vft, DBH &gt;= 10)

basal &lt;- basal_area_byyr(vft, DBH &gt;= 10)
basal

# Skip R CMD check for speed

measurements_is_installed &lt;- requireNamespace("measurements", quietly = TRUE)
if (measurements_is_installed) {
  # Convert units
  years &lt;- c("yr_2001", "yr_2002")
  basal_he &lt;- basal %&gt;%
    purrr::modify_at(
      years,
      ~ measurements::conv_unit(.x, from = "mm2", to = "hectare")
    )
  basal_he

  # Standardize
  number_of_hectares &lt;- 50
  basal_he %&gt;%
    purrr::map_at(years, ~ .x / number_of_hectares)
}

</code></pre>

<hr>
<h2 id='fgeo_habitat'>Create habitat data from measures of topography.</h2><span id='topic+fgeo_habitat'></span>

<h3>Description</h3>

<p>This function constructs habitat data based on elevation data. It calculates
habitats in two steps:
</p>

<ol>
<li><p> It calculates mean elevation, convexity and slope for each quadrat.
</p>
</li>
<li><p> It calculates habitats based on hierarchical clustering of the topographic
metrics from step 1.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>fgeo_habitat(elev, gridsize, n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fgeo_habitat_+3A_elev">elev</code></td>
<td>
<p>One of these:
</p>

<ul>
<li><p> A dataframe containing elevation data, with columns <code>gx</code>, <code>gy</code>, and
<code>elev</code>, or <code>x</code>, <code>y</code>, and <code>elev</code> (e.g. <code>fgeo.x::elevation$col</code>).
</p>
</li>
<li><p> A ForestGEO-like elevation list with elements <code>xdim</code> and <code>ydim</code> giving
plot dimensions, and element <code>col</code> containing a dataframe as described in
the previous item (e.g. <code>fgeo.x::elevation</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fgeo_habitat_+3A_gridsize">gridsize</code></td>
<td>
<p>Number giving the size of each quadrat for which a habitat
is calculated. Commonly, <code>gridsize = 20</code>.</p>
</td></tr>
<tr><td><code id="fgeo_habitat_+3A_n">n</code></td>
<td>
<p>Integer. Number of cluster-groups to construct (passed to the
argument <code>k</code> to <code><a href="stats.html#topic+cutree">stats::cutree()</a></code>).</p>
</td></tr>
<tr><td><code id="fgeo_habitat_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+fgeo_topography">fgeo_topography()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of subclass fgeo_habitat, with columns <code>gx</code> and <code>gy</code>,
rounded with accuracy determined by <code>gridsize</code>, and column <code>habitats</code>, with
as many distinct integer values as determined by the argument <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Richard Condit.
</p>


<h3>See Also</h3>

<p><code>fgeo.plot::autoplot.fgeo_habitat()</code>, <code><a href="#topic+fgeo_topography">fgeo_topography()</a></code>.
</p>
<p>Other habitat functions: 
<code><a href="#topic+fgeo_topography">fgeo_topography</a>()</code>,
<code><a href="#topic+tt_test">tt_test</a>()</code>
</p>
<p>Other functions to construct fgeo classes: 
<code><a href="#topic+fgeo_topography">fgeo_topography</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

# Input a ForestGEO-like elevation list or dataframe
elevation_ls &lt;- fgeo.x::elevation
habitats &lt;- fgeo_habitat(
  elevation_ls,
  gridsize = 20, n = 4
)

str(habitats)

# Habitat data is useful for calculating species-habitat associations
census &lt;- fgeo.x::tree6_3species
as_tibble(
  tt_test(census, habitats)
)
</code></pre>

<hr>
<h2 id='fgeo_topography'>Create topography data: convexity, slope, and mean elevation.</h2><span id='topic+fgeo_topography'></span><span id='topic+fgeo_topography.data.frame'></span><span id='topic+fgeo_topography.list'></span>

<h3>Description</h3>

<p>Create topography data: convexity, slope, and mean elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgeo_topography(elev, ...)

## S3 method for class 'data.frame'
fgeo_topography(
  elev,
  gridsize,
  xdim = NULL,
  ydim = NULL,
  edgecorrect = TRUE,
  ...
)

## S3 method for class 'list'
fgeo_topography(elev, gridsize, edgecorrect = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fgeo_topography_+3A_elev">elev</code></td>
<td>
<p>One of these:
</p>

<ul>
<li><p> A dataframe containing elevation data, with columns <code>gx</code>, <code>gy</code>, and
<code>elev</code>, or <code>x</code>, <code>y</code>, and <code>elev</code> (e.g. <code>fgeo.x::elevation$col</code>).
</p>
</li>
<li><p> A ForestGEO-like elevation list with elements <code>xdim</code> and <code>ydim</code> giving
plot dimensions, and element <code>col</code> containing a dataframe as described in
the previous item (e.g. <code>fgeo.x::elevation</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fgeo_topography_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="fgeo_topography_+3A_gridsize">gridsize</code></td>
<td>
<p>Number giving the size of each quadrat for which a habitat
is calculated. Commonly, <code>gridsize = 20</code>.</p>
</td></tr>
<tr><td><code id="fgeo_topography_+3A_xdim">xdim</code>, <code id="fgeo_topography_+3A_ydim">ydim</code></td>
<td>
<p>(Required if <code>elev</code> is a dataframe) <code>x</code> and <code>y</code>
dimensions of the plot.</p>
</td></tr>
<tr><td><code id="fgeo_topography_+3A_edgecorrect">edgecorrect</code></td>
<td>
<p>Correct convexity in edge quadrats?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of subclass fgeo_topography.
</p>


<h3>Acknowledgment</h3>

<p>Thanks to Jian Zhang for reporting a bug (issue 59).
</p>


<h3>Author(s)</h3>

<p>This function wraps code by Richard Condit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fgeo_habitat">fgeo_habitat()</a></code>.
</p>
<p>Other habitat functions: 
<code><a href="#topic+fgeo_habitat">fgeo_habitat</a>()</code>,
<code><a href="#topic+tt_test">tt_test</a>()</code>
</p>
<p>Other functions to construct fgeo classes: 
<code><a href="#topic+fgeo_habitat">fgeo_habitat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

elev_list &lt;- fgeo.x::elevation
fgeo_topography(elev_list, gridsize = 20)

elev_df &lt;- elev_list$col
fgeo_topography(elev_df, gridsize = 20, xdim = 320, ydim = 500)
</code></pre>

<hr>
<h2 id='recruitment_ctfs'>Recruitment, mortality, and growth.</h2><span id='topic+recruitment_ctfs'></span><span id='topic+mortality_ctfs'></span><span id='topic+growth_ctfs'></span>

<h3>Description</h3>

<p>These functions are adapted from the CTFS-R package. Compared to the
original functions, these ones have a similar interface but use more
conservative defaults and allow suppressing messages. These functions also
feature formal tests, bug fixes, additional assertions, and improved
messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recruitment_ctfs(
  census1,
  census2,
  mindbh = NULL,
  alivecode = NULL,
  split1 = NULL,
  split2 = NULL,
  quiet = FALSE
)

mortality_ctfs(
  census1,
  census2,
  alivecode = NULL,
  split1 = NULL,
  split2 = NULL,
  quiet = FALSE
)

growth_ctfs(
  census1,
  census2,
  rounddown = FALSE,
  method = "I",
  stdev = FALSE,
  dbhunit = "mm",
  mindbh = NULL,
  growthcol = "dbh",
  err.limit = 1000,
  maxgrow = 1000,
  split1 = NULL,
  split2 = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recruitment_ctfs_+3A_census1">census1</code>, <code id="recruitment_ctfs_+3A_census2">census2</code></td>
<td>
<p>Two census tables, each being a ForestGEO-like <em>tree</em>
table (dataframe). A <em>stem</em> table won't fail, but you should use a <em>tree</em>
table because demography analyses make more sense at the scale of trees
than at the scale of stems.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_mindbh">mindbh</code></td>
<td>
<p>The minimum diameter above which the counts are done. Trees
smaller than <code>mindbh</code> are excluded. By default all living trees of any size
are included.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_alivecode">alivecode</code></td>
<td>
<p>Character; valid values of <code>status</code> indicating that a tree
is alive. The default, 'A', is the standard CTFS designation for living
trees or stems.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_split1">split1</code>, <code id="recruitment_ctfs_+3A_split2">split2</code></td>
<td>
<p>Optional vector(s) to aggregate results by. Each vector
should be a column of either <code>census1</code> or <code>census2</code>. The default aggregates
the result across the entire census datasets.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_quiet">quiet</code></td>
<td>
<p>Use <code>TRUE</code> to suppress messages.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_rounddown">rounddown</code></td>
<td>
<p>If <code>TRUE</code>, all <code>dbh &lt; 55</code> are rounded down to the nearest
multiple of 5.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_method">method</code></td>
<td>
<p>Either &quot;I&quot; or &quot;E&quot;:
</p>

<ul>
<li><p> Use &quot;I&quot; to calculate annual dbh increment as <code>(dbh2 - dbh1)/time</code>
</p>
</li>
<li><p> Use &quot;E&quot; to calculate the relative growth rate as
<code>(log(dbh2) - log(dbh1)) / time</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_stdev">stdev</code></td>
<td>
<p>Logical:
</p>

<ul>
<li> <p><code>FALSE</code> returns confidence limits.
</p>
</li>
<li> <p><code>TRUE</code> returns the SD in growth rate per group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_dbhunit">dbhunit</code></td>
<td>
<p>&quot;cm&quot; or &quot;mm&quot;.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_growthcol">growthcol</code></td>
<td>
<p>Either &quot;dbh&quot; or &quot;agb&quot; to define how growth is measured.</p>
</td></tr>
<tr><td><code id="recruitment_ctfs_+3A_err.limit">err.limit</code>, <code id="recruitment_ctfs_+3A_maxgrow">maxgrow</code></td>
<td>
<p>A number. Numbers such as 10000 are high and will
return all measures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Survivors are all individuals alive in both censuses, with <code>status == A</code> in
the first census, and a diameter greater than <code>mindbh</code> in the first census.
The total population in the second census includes all those alive plus any
other survivors. Individuals whose status is <code>NA</code> in either census are
deleted from all calculations.
</p>


<h3>Value</h3>

<p>Metrics of recruitment: Similar to metrics of mortality.
</p>
<p>Metrics of mortality:
</p>

<ul>
<li> <p><code>N</code>: the number of individuals alive in the census 1 per category
selected.
</p>
</li>
<li> <p><code>D</code>: the number of individuals no longer alive in census 2.
</p>
</li>
<li> <p><code>rate</code>: the mean annualized mortality rate constant per category
selected, calculated as (log(N)-log(S))/time.
</p>
</li>
<li> <p><code>upper</code>: upper confidence limit of mean rate.
</p>
</li>
<li> <p><code>lower</code>: lower confidence limit of mean rate.
</p>
</li>
<li> <p><code>time</code>: mean time interval in years.
</p>
</li>
<li> <p><code>date1</code>: mean date included individuals were measured in census 1, as
julian object (R displays as date, but treats as integer).
</p>
</li>
<li> <p><code>date2</code>: mean date in census 2.
</p>
</li>
<li> <p><code>dbhmean</code>: mean dbh in census 1 of individuals included.
</p>
</li></ul>

<p>Metrics of growth:
</p>

<ul>
<li> <p><code>rate</code>, the mean annualized growth rate per category selected, either dbh
increment, or relative growth.
</p>
</li>
<li> <p><code>N</code>, the number of individuals included in the mean (not counting any
excluded).
</p>
</li>
<li> <p><code>clim</code> (or sd with <code>stdev = TRUE</code>), width of confidence interval; add this
number to the mean rate to get upper confidence limit, substract to get
lower.
</p>
</li>
<li> <p><code>dbhmean</code>, mean dbh in census 1 of individuals included.
</p>
</li>
<li> <p><code>time</code>, mean time interval in years.
</p>
</li>
<li> <p><code>date1</code>, mean date included individuals were measured in census 1, as
julian object (R displays as date, but treats as integer).
</p>
</li>
<li> <p><code>date2</code>, mean date in census 2.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Richard Condit, Suzanne Lao.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

census1 &lt;- fgeo.x::tree5
census2 &lt;- fgeo.x::tree6

as_tibble(
  recruitment_ctfs(census1, census2)
)

# Use `interaction(...)` to aggregate by any number of grouping variables
sp_quadrat &lt;- interaction(census1$sp, census1$quadrat)

recruitment &lt;- recruitment_ctfs(
  census1, census2,
  split1 = sp_quadrat,
  quiet = TRUE
)
as_tibble(recruitment)

mortality &lt;- mortality_ctfs(
  census1, census2,
  split1 = sp_quadrat, quiet = TRUE
)
as_tibble(mortality)

growth &lt;- growth_ctfs(census1, census2, split1 = sp_quadrat, quiet = TRUE)
as_tibble(growth)

# Easy way to separate grouping variables
tidyr_is_installed &lt;- requireNamespace("tidyr", quietly = TRUE)
if (tidyr_is_installed) {
  library(tidyr)

  as_tibble(growth) %&gt;%
    separate(groups, into = c("sp", "quadrat"))
}
</code></pre>

<hr>
<h2 id='reexports'>Coerce objects different fgeo classes &quot;data.frame&quot; or &quot;tbl&quot; (tibble).</h2><span id='topic+reexports'></span><span id='topic+as_tibble'></span><span id='topic+assert_is_installed'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>fgeo.tool</dt><dd><p><code><a href="fgeo.tool.html#topic+assert_is_installed">assert_is_installed</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
</dl>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reexports_+3A_x">x</code></td>
<td>
<p>An object of class tt_lst.</p>
</td></tr>
<tr><td><code id="reexports_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code> (not used in
<code><a href="#topic+as_tibble">as_tibble()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code>, <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code>.
</p>

<hr>
<h2 id='summary.tt_df'>Summary of <code>tt_test()</code> results.</h2><span id='topic+summary.tt_df'></span><span id='topic+summary.tt_lst'></span>

<h3>Description</h3>

<p>Summary of <code>tt_test()</code> results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tt_df'
summary(object, ...)

## S3 method for class 'tt_lst'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tt_df_+3A_object">object</code></td>
<td>
<p>An object of class &quot;tt_df&quot; or &quot;tt_lst&quot;.</p>
</td></tr>
<tr><td><code id="summary.tt_df_+3A_...">...</code></td>
<td>
<p>Not used (included only for compatibility with <code>summary</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>Author(s)</h3>

<p>Adapted from code contributed by Daniel Zuleta.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tt_test">tt_test()</a></code>, <code><a href="base.html#topic+summary">base::summary()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_is_installed("fgeo.x")

tt_result &lt;- tt_test(fgeo.x::tree6_3species, fgeo.x::habitat)

summary(tt_result)

# Same
summary(as_tibble(tt_result))

# You may want to add the explanation to the result of `tt_test()`

dplyr::left_join(as_tibble(tt_result), summary(tt_result))

# You may prefer a wide matrix
Reduce(rbind, tt_result)

# You may prefer a wide dataframe
tidyr::spread(summary(tt_result), "habitat", "association")
</code></pre>

<hr>
<h2 id='tt_test'>Torus Translation Test to determine habitat associations of tree species.</h2><span id='topic+tt_test'></span>

<h3>Description</h3>

<p>Determine habitat-species associations with code developed by Sabrina Russo,
Daniel Zuleta, Matteo Detto, and Kyle Harms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_test(tree, habitat, sp = NULL, plotdim = NULL, gridsize = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tt_test_+3A_tree">tree</code></td>
<td>
<p>A dataframe; a ForestGEO <em>tree</em> table (see details).</p>
</td></tr>
<tr><td><code id="tt_test_+3A_habitat">habitat</code></td>
<td>
<p>Object giving the habitat designation for each
plot partition defined by <code>gridsize</code>. See <code><a href="#topic+fgeo_habitat">fgeo_habitat()</a></code>.</p>
</td></tr>
<tr><td><code id="tt_test_+3A_sp">sp</code></td>
<td>
<p>Character sting giving any number of species-names.</p>
</td></tr>
<tr><td><code id="tt_test_+3A_plotdim">plotdim</code>, <code id="tt_test_+3A_gridsize">gridsize</code></td>
<td>
<p>Plot dimensions and gridsize. If <code>NULL</code> (default)
they will be guessed, and a message will inform you of the chosen values.
If the guess is wrong, you should provide the correct values manually (and
check that your habitat data is correct).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test only makes sense at the population level. We are interested in
knowing whether or not individuals of a species are aggregated on a habitat.
Multiple stems of an individual do not represent population level processes
but individual level processes. Thus, you should use data of individual trees
&ndash; i.e. use a <em>tree</em> table, and not a <em>stem</em> table with potentially multiple
stems per tree.
</p>
<p>You should only try to determine the habitat association for sufficiently
abundant species. In a 50-ha plot, a minimum abundance of 50 trees/species
has been used.
</p>


<h3>Value</h3>

<p>A list of matrices.
</p>


<h3>Acknowledgments</h3>

<p>Nestor Engone Obiang, David Kenfack, Jennifer Baltzer, and Rutuja
Chitra-Tarak provided feedback. Daniel Zuleta provided guidance.
</p>


<h3>Interpretation of Output</h3>


<ul>
<li> <p><code>N.Hab.1</code>: Count of stems of the focal species in habitat 1.
</p>
</li>
<li> <p><code>Gr.Hab.1</code>: Count of instances the observed relative density of the focal
species on habitat 1 was greater than the relative density based on the TT
habitat map.
</p>
</li>
<li> <p><code>Ls.Hab.1</code>: Count of instances the observed relative density of the focal
species on habitat 1 was less than the relative density based on the TT
habitat map.
</p>
</li>
<li> <p><code>Eq.Hab.1</code>: Count of instances the observed relative density of the focal
species on habitat 1 was equal to the relative density based on the TT
habitat map.
The sum of the <code>Gr.Hab.x</code>, <code>Ls.Hab.x</code>, and <code>Eq.Hab.x</code> columns for one habitat
equals the number of 20 x20 quads in the plot.
The <code>Rep.Agg.Neut</code> columns for each habitat indicate whether the species is
significantly repelled (-1), aggregated (1), or neutrally distributed (0) on
the habitat in question.
</p>
</li></ul>

<p>The probabilities associated with the test for whether these patterns are
statistically significant are in the <code>Obs.Quantile</code> columns for each habitat.
Note that to calculate the probability for <em>repelled</em>, it is <em>the value
given</em>, but to calculate the probability for <em>aggregated</em>, it is <em>one minus
the value given</em>.
</p>
<p>Values of the <code>Obs.Quantile &lt; 0.025</code> means that the species is repelled from
that habitat, while values of the <code>Obs.Quantile &gt; 0.975</code> means that the
species is aggregated on that habitat.
</p>


<h3>References</h3>

<p>Zuleta, D., Russo, S.E., Barona, A. et al. Plant Soil (2018).
<a href="https://doi.org/10.1007/s11104-018-3878-0">https://doi.org/10.1007/s11104-018-3878-0</a>.
</p>


<h3>Author(s)</h3>

<p>Sabrina Russo, Daniel Zuleta, Matteo Detto, and Kyle Harms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.tt_lst">summary.tt_lst()</a></code>, <code><a href="#topic+summary.tt_df">summary.tt_df()</a></code>, <code><a href="#topic+as_tibble">as_tibble()</a></code>,
<code><a href="#topic+fgeo_habitat">fgeo_habitat()</a></code>.
</p>
<p>Other habitat functions: 
<code><a href="#topic+fgeo_habitat">fgeo_habitat</a>()</code>,
<code><a href="#topic+fgeo_topography">fgeo_topography</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fgeo.tool)
assert_is_installed("fgeo.x")

# Example data
tree &lt;- fgeo.x::tree6_3species
elevation &lt;- fgeo.x::elevation

# Pick alive trees, of 10 mm or more
census &lt;- filter(tree, status == "A", dbh &gt;= 10)

# Pick sufficiently abundant species
pick &lt;- filter(dplyr::add_count(census, sp), n &gt; 50)

# Use your habitat data or create it from elevation data
habitat &lt;- fgeo_habitat(elevation, gridsize = 20, n = 4)

# Defaults to using all species
as_tibble(
  tt_test(census, habitat)
)

Reduce(rbind, tt_test(census, habitat))

some_species &lt;- c("CASARB", "PREMON")
result &lt;- tt_test(census, habitat, sp = some_species)
summary(result)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
