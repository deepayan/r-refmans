<!DOCTYPE html><html><head><title>Help for package npcurePK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {npcurePK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#controlpars
'><p>Control Values for the Bootstrap</p></a></li>
<li><a href='#latency_curepk
'><p>Compute Estimator of Latency Function  when Cure Status is Partially</p>
Known</a></li>
<li><a href='#npcurePK-internal
'><p>Internal npcurePK Functions</p></a></li>
<li><a href='#prob_curepk
'><p>Compute Estimator of Cure Probability when Cure Status is Partially Known</p></a></li>
<li><a href='#prodlim_curepk
'><p>Compute Product-Limit Estimator of Conditional Survival Function when</p>
Cure Status is Partially Known</a></li>
<li><a href='#sarcoma
'><p>Sarcoma Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mixture Cure Model Estimation with Cure Status Partially Known</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wende Clarence Safari &lt;wende.safari@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs nonparametric estimation in mixture cure models when the cure status is partially known. For details, see Safari et al (2021) &lt;<a href="https://doi.org/10.1002%2Fbimj.202100156">doi:10.1002/bimj.202100156</a>&gt;, Safari et al (2022) &lt;<a href="https://doi.org/10.1177%2F09622802221115880">doi:10.1177/09622802221115880</a>&gt; and Safari et al (2023) &lt;<a href="https://doi.org/10.1007%2Fs10985-023-09591-x">doi:10.1007/s10985-023-09591-x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>DescTools, data.table, parallel, doParallel, foreach, npcure</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, pinp, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-05 18:11:14 UTC; ilu</td>
</tr>
<tr>
<td>Author:</td>
<td>Wende Clarence Safari
    <a href="https://orcid.org/0000-0003-4639-7552"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ignacio López-de-Ullibarri
    <a href="https://orcid.org/0000-0002-3438-6621"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  María Amalia Jácome
    <a href="https://orcid.org/0000-0001-7000-9623"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-07 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='controlpars+0A'>Control Values for the Bootstrap
</h2><span id='topic+controlpars'></span>

<h3>Description</h3>

<p>This function returns a list of values for the control parameters
of the functions that will be used for the bootstrap bandwidth
selector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    controlpars(b = 100L, hbound = c(0.1, 3), hl = 30L, hgrid_save = FALSE,
                nnfrac = 0.25, fpilot = NULL, qt = 0.9, ncores = 1L,
                seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlpars+2B0A_+3A_b">b</code></td>
<td>
<p>An integer giving the number of bootstrap resamples, <code>100</code> by
default.
</p>
</td></tr>   
<tr><td><code id="controlpars+2B0A_+3A_hbound">hbound</code></td>
<td>
<p>A numeric vector of length 2 specifying the minimum
(default, <code>0.1</code>) and maximum (default, <code>3</code>), respectively,
of the initial grid of bandwidths as a multiple of the standardized
interquartile range of the covariate values.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_hl">hl</code></td>
<td>
<p>A numeric value giving the length of the initial grid of
bandwidths. The default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_hgrid_save">hgrid_save</code></td>
<td>
<p>A logical value specifying if the grids of bandwidths
must be saved as a component of the list returned by the
<code>prodlim_curepk_boot</code> function. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_nnfrac">nnfrac</code></td>
<td>
<p>A numeric value giving the fraction of the sample size that
determines the order of the nearest neighbor used when choosing the
pilot bandwidth. The default is <code>0.25</code>.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_fpilot">fpilot</code></td>
<td>
<p>A function name or <code>NULL</code>. If <code>NULL</code>, the default,
the <code>hpilot</code> function is used for computing a pilot bandwidth in
case that one is needed. If not <code>NULL</code>, it must be the name of a
user-defined function, given as a function name or as a character
string. This function must necessarily have an argument <code>x0</code>,
playing the same role than in <code>hpilot</code>, and must return a value of
the same length than <code>x0</code>. If <code>fpilot</code> has more arguments,
they are passed through the ... argument (see below).
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_qt">qt</code></td>
<td>
<p>In bandwidth selection for the product-limit estimator, a numeric
value specifying the order of a quantile of the observed times. It
determines the right boundary of the integration interval in the
computation of the ISE (the lower limit is <code class="reqn">0</code>). The default is
<code>0.9</code> (90th quantile).
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores used in parallel computations.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_seed">seed</code></td>
<td>
<p>An optional integer passed to <code>set.seed()</code> to set the
randomization seed.
</p>
</td></tr>
<tr><td><code id="controlpars+2B0A_+3A_...">...</code></td>
<td>
<p>Arguments of <code>fpilot</code>, if <code>fpilot</code> is not
<code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code>controlpars</code> is a list of control parameters
required by the functions which use the bootstrap. This is mainly the case
of the <code>prodlimcurePKhboot</code> function, which compute the bootstrap
bandwidth selectors of the estimators of the survival, latency and the
probability of cure. Since these functions are indirectly called by
<code>prodlimcurePKhboot</code> function when their <code>h</code> argument is missing,
the output of <code>controlpars</code> is also the expected (and default) way of
passing to them the parameters for bandwidth selection.
</p>

<hr>
<h2 id='latency_curepk+0A'>Compute Estimator of Latency Function  when Cure Status is Partially
Known
</h2><span id='topic+latency_curepk'></span>

<h3>Description</h3>

<p>This function computes the nonparametric estimator of the latency
function when cure status is partially known proposed by Safari <em>et al</em>
(2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    latency_curepk(x, t, d, xinu, dataset, x0, h, local = TRUE,
                   bootpars = if (!missing(h)) NULL else controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latency_curepk+2B0A_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the covariate in the data
frame.</p>
</td></tr>    
<tr><td><code id="latency_curepk+2B0A_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the observed
times. If <code>dataset</code> is a data frame, it is interpreted as the name
of the variable corresponding to the observed times in the data frame.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the values
of the uncensoring indicator. Censored observations must be coded as 0,
uncensored ones as 1. If dataset is a data frame, it is interpreted as
the name of the variable corresponding to the uncensoring indicator in
the data frame.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_xinu">xinu</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the cure status indicator. Uncensored and unknown censored
observations must be coded as 0, known to be cured censored ones as 1.
If <code>dataset</code> is a data frame, it is interpreted as the name of the
variable corresponding to the cure status indicator in the data frame.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x, t, d</code> and <code>xinu</code> are interpreted. If it is missing,
<code>x, t, d</code> and <code>xinu</code> must be objects of the workspace.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the estimates of the
latency function will be computed.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_h">h</code></td>
<td>
<p>A numeric matrix of bandwidths.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_local">local</code></td>
<td>
<p>A logical value, TRUE by default, specifying whether
<code>local</code> or <code>global</code> bandwidths are used.</p>
</td></tr>
<tr><td><code id="latency_curepk+2B0A_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing the bootstrap bandwidths of the product-limit estimator.
<code>B</code>, the number of bootstrap resamples, and <code>nnfrac</code>,
the fraction of the sample size that determines the order of the nearest
neighbor used for choosing a pilot bandwidth. If <code>h</code> is missing
the list of parameters is extended to be the same used for computing the
bootstrap bandwidth. The default is the value returned by the
<code>controlpars</code> function called without arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an estimator of the latency function
<code class="reqn">S_0(t\mid x)=P(Y&gt;t\mid Y&lt;\infty, X=x)</code>
when the cure status is partially known, introduced in Safari <em>et al</em>
(2023). It is based on the relationship </p>
<p style="text-align: center;"><code class="reqn">S(t\mid x)=1-p(x)+p(x)S_0(t\mid x)</code>
</p>
<p>,
using the kernel estimator of the cure rate <code class="reqn">1-p(x)</code> in Safari
<em>et al</em> (2022) and the survival function <code class="reqn">S(t\mid x)</code>
in Safari <em>et al</em> (2021), with Nadaraya-Watson weights and bandwidth
<code class="reqn">h_1</code> for the cure rate and <code class="reqn">h_2</code> for the survival function. If
there are not individuals known to be cured (<code>xinu=0</code>), then the
kernel estimator of the cure rate in López-Cheda <em>et al</em> (2017) is
computed.
</p>
<p>The latency estimator is computed with the pair of bandwidths in <code>h</code>.
One bandwidth <code>h[1, ]</code> is used for the estimation of <code class="reqn">1-p(x)</code> and
another bandwidth <code>h[2, ]</code> is used for the estimation of
<code class="reqn">S(t\mid x)</code>. If the smoothing parameter <code>h</code> is not
provided, then the bootstrap bandwidth selector in Safari <em>et al</em>
(2023) is used. The kernel considered is Epanechnikov kernel. The function
is available only for one continuous covariate <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>A list of components:
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>The numeric matrix <code>(2 x length(x0))</code> of bandwidths used in
the estimation. One bandwidth <code>h[1, ]</code> is used for the estimation
of <code class="reqn">1-p(x)</code> and another bandwidth <code>h[2, ]</code> is used for the
estimation of <code class="reqn">S(t \mid x)</code>. If <code>h</code> argument is
missing, the bootstrap bandwidth computed with the control parameters
in argument <code>bootpars</code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The numeric vector of covariate values where the estimate of the
latency function is computed.</p>
</td></tr>
<tr><td><code>prob_cure</code></td>
<td>
<p>The estimate of the cure probability <code>1 - p(x0)</code>
with bandwidth <code>h[1, ]</code>. It is a vector of the same length as
<code>x0</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The observed time values, where the latency function is estimated.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>Estimates of the survival function for each one of the
covariate values specified by the <code>x0</code> argument and the bandwidths
in <code>h[2, ]</code>. It is a matrix of dimension <code class="reqn">n\times length(x0)</code>
if local bandwidths or bootstrap bandwidths are used, or an array for
global bandwidths instead.</p>
</td></tr>
<tr><td><code>latency</code></td>
<td>
<p>Estimates of the latency for each one of the covariate
values specified by the <code>x0</code> argument and the bandwidths in
<code>h</code>. It is a matrix of dimension <code class="reqn">n\times length(x0)</code>
if local bandwidths or bootstrap bandwidths are used, or an array for
global bandwidths instead.</p>
</td></tr>
</table>


<h3>References</h3>

<p>López-Cheda, A., Jácome, M.A., Cao, R. (2017). Nonparametric latency
estimation for mixture cure models. TEST 26:353-376.
<a href="https://doi.org/10.1007/s11749-016-0515-1">doi:10.1007/s11749-016-0515-1</a>.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2021). A product-limit
estimator of the conditional survival function when cure status is
partially known. Biometrical Journal, 63(5): 984-1005.
<a href="https://doi.org/10.1002/bimj.202000173">doi:10.1002/bimj.202000173</a>.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2022). Nonparametric
kernel estimation of the probability of cure in a mixture cure model when
the cure status is partially observed. Statistical Methods in Medical
Research, 31(11):2164-2188.
<a href="https://doi.org/10.1177/09622802221115880">doi:10.1177/09622802221115880</a>.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2023). Latency
function estimation under the mixture cure model when the cure status is
available. Lifetime Data Analysis.
<a href="https://doi.org/10.1007/s10985-023-09591-x">doi:10.1007/s10985-023-09591-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(npcurePK)

## Data-generating function
## n: sample size
## x_cov_range: range of covariate values
## p_knowncure: probability of known cure
data_gen &lt;- function(n, x_cov_range, p_knowncure) {
    ## probability of being susceptible
    p0 &lt;- function(x) exp(2*x)/(1 + exp(2*x))
    ## covariate values
    x &lt;- runif(n, x_cov_range[1], x_cov_range[2])
    ## censoring times
    c &lt;- rexp(n)
    u &lt;- runif(n)
    v &lt;- runif(n)
    data &lt;- data.frame(matrix(0, nrow = n, ncol = 4L,
                              dimnames = list(NULL, c("x", "t", "d", "xinu"))))
    data[, "x"] &lt;- x
    for (i in 1:n) {
        if (u[i] &gt; p0(x[i])) {
            ## Cured individuals (all of them are censored: Yi = infty,
            ## Ti = Ci, delta = 0, nu = 1)
            data[i, "t"] &lt;- c[i]
            if (v[i] &lt; p_knowncure)
                data[i, "xinu"]  &lt;- 1 
        } else {
            ## Uncured individual (Yi &lt; infty, Ti = min(Yi, Ci),
            ## delta = 1(Yi &lt; Ci), nu = 0)
            ## Uncensored individual (d = 1): cure status is
            ## observed (xi = 1), i.e., xinu = 0
            ## Censored individual (d = 0): cure status is
            ## unknown (xi = 0), i.e., xi.nu = 0
            y &lt;- rweibull(1, shape = 0.5 * (x[i] + 4))
            data[i, "t"]  &lt;- ifelse(v[i] &lt; p_knowncure, y, min(y, c[i]))
            if (data[i, "t"] == y) data[i, "d"] &lt;- 1
        }
    }
    return(data)
}

set.seed(123)
data &lt;- data_gen(n = 100, x_cov_range = c(-2, 2), p_knowncure = 0.8)

## Latency estimates for one single covariate value x0 = 0 and using...
x0 &lt;- 0

## ... (a) one single fixed bandwidth h = [1.1, 1] 
## h[1,] = 1.1 is used for estimating p(x) at x0 = 0
## h[2,] = 1 is used for estimating S(t|x) at x0 = 0
## The latency estimates are saved in an array (n × 1)
S0_1 &lt;- latency_curepk(x, t, d, xinu, data, x0 = 0, 
                       h = matrix(c(1.1, 1), nrow = 2, ncol = 1, byrow = TRUE),
                       local = TRUE)
## Plot predicted latency curve for covariate value x0 = 0 and bandwidths
## h = [1.1, 1]
plot(S0_1$t, S0_1$latency, type = "s", xlab = "Time",
     ylab = "Latency function", ylim = c(0, 1))
## The true latency function is included as reference     
lines(S0_1$t, 1 - pweibull(S0_1$t, shape = 0.5 * (x0 + 4)))

## ... (b) two fixed bandwidths h = [1.1, 1] and h = [1.5, 2]
## One estimate of the latency S0(t|x0 = 0) is obtained using h[1, 1] = 1.1
## for estimating p(x) and h[2,1] = 1 for estimating S(t|x)
## Second estimate of the latency S0(t|x0 = 0) is obtained using h[1, 2] = 1.5
## using h[1,2] = 1.5 for estimating p(x) and h[2,2] = 2 for estimating S(t|x)
## The estimates are saved in an array (n × 2)
S0_2 &lt;- latency_curepk(x, t, d, xinu, data, x0 = c(0, 0), 
                       h = matrix(c(1.1, 1, 1.5, 2), nrow = 2, ncol = 2,
                                  byrow = FALSE), local = TRUE)
## Plot predicted latency curve for covariate value x0 = 0 and bandwidths
## h = [1.1, 1] and and h = [1.5, 2]
plot(S0_2$t, S0_2$latency[, 1], type = "s", xlab = "Time",
     ylab = "Latency function", ylim = c(0, 1))
lines(S0_2$t, S0_2$latency[, 2], type = "s", lwd = 2)
## The true latency function is included as reference     
lines(S0_2$t, 1 - pweibull(S0_2$t, shape = 0.5 * (x0 + 4)))


    ## ... (c) with the bootstrap bandwidth selector (the default when the 
    ## bandwidth argument h is not provided).
    ## The bootstrap bandwidth is searched with parallel computation 
    ## (ncores = 2) in a grid of 9 bandwidths (hl = 9) between 0.2 and 2 times
    ## the standardized interquartile range of the covariate values
    ## (hbound = c(0.1, 2)). The latency estimates are saved in an array of
    ## dimension (n, 1)
    library(doParallel)
    (S0_3 &lt;- latency_curepk(x, t, d, xinu, data, x0 = 0,
                            bootpars = controlpars(b = 50, hl = 9, 
                            hbound = c(0.1, 2), ncores = 2)))
    plot(S0_3$t, S0_3$latency[, 1], type = "s", xlab = "Time",
         ylab = "Latency function", ylim = c(0, 1))                      
    ## The true latency function is included as reference     
    lines(S0_3$t, 1 - pweibull(S0_3$t, shape = 0.5 * (x0 + 4)))

</code></pre>

<hr>
<h2 id='npcurePK-internal+0A'>Internal npcurePK Functions
</h2><span id='topic+latency_curepk_boot'></span><span id='topic+prob_curepk_boot'></span><span id='topic+prodlim_curepk_boot'></span>

<h3>Description</h3>

<p>Internal functions of the package.
</p>


<h3>Details</h3>

<p>Internal functions not to be called by the user.
</p>

<hr>
<h2 id='prob_curepk+0A'>Compute Estimator of Cure Probability when Cure Status is Partially Known
</h2><span id='topic+prob_curepk'></span>

<h3>Description</h3>

<p>This function computes the nonparametric estimator of the cure
probability when cure status is partially known proposed by Safari
<em>et al</em> (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    prob_curepk(x, t, d, xinu, dataset, x0, h, local = TRUE,
                bootpars = if (!missing(h)) NULL else controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_curepk+2B0A_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the covariate
values. If <code>dataset</code> is a data frame, it is interpreted as the name
of the variable corresponding to the covariate in the data frame.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the observed
times. If <code>dataset</code> is a data frame, it is interpreted as the name
of the variable corresponding to the observed times in the data frame.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the values
of the uncensoring indicator. Censored observations must be coded as 0,
uncensored ones as 1. If dataset is a data frame, it is interpreted as
the name of the variable corresponding to the uncensoring indicator in
the data frame.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_xinu">xinu</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the cure status indicator. Uncensored and unknown censored
observations must be coded as 0, known to be cured censored ones as 1.
If <code>dataset</code> is a data frame, it is interpreted as the name of the
variable corresponding to the cure status indicator in the data frame.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x, t, d</code> and <code>xinu</code> are interpreted. If it is missing,
<code>x, t, d</code> and <code>xinu</code> must be objects of the workspace.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the estimates of the
cure probability will be computed.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_h">h</code></td>
<td>
<p>A numeric vector of bandwidths.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_local">local</code></td>
<td>
<p>A logical value, <code>TRUE</code> by default, specifying whether
<code>local</code> or <code>global</code> bandwidths are used.</p>
</td></tr>
<tr><td><code id="prob_curepk+2B0A_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing the bootstrap bandwidths of the cure probability estimator.
<code>B</code>, the number of bootstrap resamples, and <code>nnfrac</code>,
the fraction of the sample size that determines the order of the nearest
neighbor used for choosing a pilot bandwidth. If <code>h</code> is missing
the list of parameters is extended to be the same used for computing the
bootstrap bandwidth. The default is the value returned by the
<code>controlpars</code> function called without arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture cure model writes the conditional survival function
<code class="reqn">S(t\mid x)=P(Y&gt;t\mid X=x)</code> as
</p>
<p style="text-align: center;"><code class="reqn">S(t\mid x)=1-p(x)+p(x)S_0(t\mid x)</code>
</p>
<p> where
<code class="reqn">1-p(x)=P(Y=\infty\mid X=x)</code> is the
probability of cure.
</p>
<p>This function computes the kernel estimator of the probability of cure
<code class="reqn">1-p(x)</code> in Safari <em>et al</em> (2022). It is based on the previous
relationship and the generalized product-limit estimator of the  conditional
survival function <code class="reqn">S(t\mid x)</code> in Safari <em>et al</em> (2021),
using the Nadaraya-Watson weights, when the cure status is partially known.
If there are not individuals known to be cured (<code>xinu=0</code>), then the
nonparametric estimator of the cure rate in López-Cheda <em>et al</em> (2017)
is computed.
</p>
<p>The Epanechnikov kernel is used. If the smoothing parameter <code>h</code> is not
provided, then the bootstrap bandwidth selector in Safari <em>et al</em>
(2022) is used. The function is available only for one continuous covariate
<code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>A list of components:   
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>The numeric vector of bandwidths used in the estimation. If
<code>h</code> argument is missing, the bootstrap bandwidth computed with the
control parameters in argument <code>bootpars</code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The numeric vector of covariate values where the estimate of the
cure probability is computed.</p>
</td></tr>
<tr><td><code>prob_cure</code></td>
<td>
<p>The estimate of the cure probability <code>1-p(x0)</code> with
bandwidth <code>h</code>. It is a vector of the same length as <code>x0</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Beran, R. (1981). Nonparametric regression with randomly censored survival
data. Technical Report. Berkeley, University of California.
</p>
<p>López-Cheda, A. Cao, R., Jácome, M.A., Van Keilegom, I. (2017).
Nonparametric incidence estimation and bootstrap bandwidth selection in
mixture cure models. Computational Statistics and Data Analysis 105:144-165.
<a href="https://doi.org/10.1016/j.csda.2016.08.002">doi:10.1016/j.csda.2016.08.002</a>.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2021). A product-limit
estimator of the conditional survival function when cure status is
partially known. Biometrical Journal, 63(5): 984-1005.
<a href="https://doi.org/10.1002/bimj.202000173">doi:10.1002/bimj.202000173</a>.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2022). Nonparametric
kernel estimation of the probability of cure in a mixture cure model when
the cure status is partially observed. Statistical Methods in Medical
Research, 31(11):2164-2188. 
<a href="https://doi.org/10.1177/09622802221115880">doi:10.1177/09622802221115880</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(npcurePK)
    
## Data-generating function
## n: sample size
## x_cov_range: range of covariate values
## p_knowncure: probability of known cure
data_gen &lt;- function(n, x_cov_range, p_knowncure) {
    ## probability of being susceptible
    p0 &lt;- function(x) exp(2*x)/(1 + exp(2*x))
    ## covariate values
    x &lt;- runif(n, x_cov_range[1], x_cov_range[2])
    ## censoring times
    c &lt;- rexp(n)
    u &lt;- runif(n)
    v &lt;- runif(n)
    data &lt;- data.frame(matrix(0, nrow = n, ncol = 4L,
                              dimnames = list(NULL, c("x", "t", "d", "xinu"))))
    data[, "x"] &lt;- x
    for (i in 1:n) {
        if (u[i] &gt; p0(x[i])) {
            ## Cured individuals (all of them are censored: Yi = infty,
            ## Ti = Ci, delta = 0, nu = 1)
            data[i, "t"] &lt;- c[i]
            if (v[i] &lt; p_knowncure)
                data[i, "xinu"]  &lt;- 1 
        } else {
            ## Uncured individual (Yi &lt; infty, Ti = min(Yi, Ci),
            ## delta = 1(Yi &lt; Ci), nu = 0)
            ## Uncensored individual (d = 1): cure status is
            ## observed (xi = 1), i.e., xinu = 0
            ## Censored individual (d = 0): cure status is
            ## unknown (xi = 0), i.e., xi.nu = 0
            y &lt;- rweibull(1, shape = 0.5 * (x[i] + 4))
            data[i, "t"]  &lt;- ifelse(v[i] &lt; p_knowncure, y, min(y, c[i]))
            if (data[i, "t"] == y) data[i, "d"] &lt;- 1
        }
    }
    return(data)
}

set.seed(123)
data &lt;- data_gen(n = 100, x_cov_range = c(-2, 2), p_knowncure = 0.8)

## Cure rate estimates for one single covariate value x0 = 0 and using ...
## ... (a) one single fixed bandwidth h = 0.5 
p1 &lt;- prob_curepk(x, t, d, xinu, data, x0 = 0, 
                  h = 0.5, local = TRUE)

## ... (b) a vector of bandwidths h = c(0.25, 0.5, 0.75, 1) 
p2 &lt;- prob_curepk(x, t, d, xinu, data, x0 = c(0, 0, 0, 0), 
                  h = c(0.25, 0.5, 0.75, 1), local = TRUE)

## ... (c) a bootstrap bandwidth (the default when the bandwidths
## argument h is not provided).
## The bootstrap bandwidth is searched in a grid of 10 bandwidths (hl = 10)
## between 0.2 and 2 times the standardized interquartile range of the
## covariate values (hbound = c(0.1, 3)).
(p3 &lt;- prob_curepk(x, t, d, xinu, data, x0 = 0))
## Equivalently
    
    (p3 &lt;- prob_curepk(x, t, d, xinu, data, x0 = 0,
                       bootpars = controlpars(hl = 10, hbound = c(0.1, 3))))


## Cure rate estimates for a vector of 20 covariate values and using ...
x0 = seq(from = min(data$x), to = max(data$x), length.out = 15)
## ... (a) one single fixed bandwidth h = 0.5 
p4 &lt;- prob_curepk(x, t, d, xinu, data, x0 = x0, h = 0.5, local = FALSE)
## Plot predicted cure probabilities for covariate values x0 and bandwidths
## h = 0.5
plot(p4$x0, p4$prob_cure, xlab = "Covariate X", type = "l",
     ylab = "Probability of cure", ylim = c(0, 1))
## The true cure rate is included as reference
lines(p4$x0, 1 - exp(2*x0)/(1 + exp(2*x0)), lwd = 2)

## ... (b) a vector of bandwidths h = c(0.5, 0.75, 1) 
p5 &lt;- prob_curepk(x, t, d, xinu, data, x0 = x0, h = c(0.5, 0.75, 1),
                  local = FALSE)
## Plot predicted cure probabilities for covariate values x0 and bandwidths
## h = 0.5
plot(p5$x0, p5$prob_cure[1, ], xlab = "Covariate X", type = "l",
     ylab = "Probability of cure", ylim = c(0, 1))
## The estimates with bandwidth h = 0.75 and h = 1 are added
lines(p5$x0, p5$prob_cure[2, ])
lines(p5$x0, p5$prob_cure[3, ])
## The true cure rate is included as reference
lines(p5$x0, 1 - exp(2*x0)/(1 + exp(2*x0)), lwd = 2)


    ## ... (c) the bootstrap bandwidth
    (p6 &lt;- prob_curepk(x, t, d, xinu, data, x0 = x0,
                       bootpars = controlpars(b = 50, ncores = 2, seed = 123)))
    ## Plot predicted cure probabilities for covariate values x0 and bootstrap
    ## bandwidths
    plot(p6$x0, p6$prob_cure, xlab = "Covariate X", type = "l",
         ylab = "Probability of cure", ylim = c(0, 1))
    ## The true cure rate is included as reference
    lines(p6$x0, 1 - exp(2*x0)/(1 + exp(2*x0)), lwd = 2)

</code></pre>

<hr>
<h2 id='prodlim_curepk+0A'>Compute Product-Limit Estimator of Conditional Survival Function when
Cure Status is Partially Known
</h2><span id='topic+prodlim_curepk'></span>

<h3>Description</h3>

<p>This function computes the nonparametric estimator of the
conditional survival function when cure status is partially known
proposed by Safari <em>et al</em> (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    prodlim_curepk(x, t, d, xinu, dataset, x0, h, local = TRUE,
                   bootpars = if (!missing(h)) NULL else controlpars())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodlim_curepk+2B0A_+3A_x">x</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the
covariate values. If <code>dataset</code> is a data frame, it is interpreted
as the name of the variable corresponding to the covariate in the data
frame.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_t">t</code></td>
<td>
<p>If <code>dataset</code> is missing, a numeric object giving the observed
times. If <code>dataset</code> is a data frame, it is interpreted as the name
of the variable corresponding to the observed times in the data frame.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_d">d</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the values
of the uncensoring indicator. Censored observations must be coded as 0,
uncensored ones as 1. If dataset is a data frame, it is interpreted as
the name of the variable corresponding to the uncensoring indicator in
the data frame.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_xinu">xinu</code></td>
<td>
<p>If <code>dataset</code> is missing, an integer object giving the
values of the cure status indicator. Uncensored and unknown censored
observations must be coded as 0, known to be cured censored ones as 1.
If <code>dataset</code> is a data frame, it is interpreted as the name of the
variable corresponding to the cure status indicator in the data frame.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_dataset">dataset</code></td>
<td>
<p>An optional data frame in which the variables named in
<code>x, t, d</code> and <code>xinu</code> are interpreted. If it is missing,
<code>x, t, d</code> and <code>xinu</code> must be objects of the workspace.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_x0">x0</code></td>
<td>
<p>A numeric vector of covariate values where the estimates of the
conditional survival function will be computed.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_h">h</code></td>
<td>
<p>A numeric vector of bandwidths.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_local">local</code></td>
<td>
<p>A logical value, TRUE by default, specifying whether
<code>local</code> or <code>global</code> bandwidths are used.</p>
</td></tr>
<tr><td><code id="prodlim_curepk+2B0A_+3A_bootpars">bootpars</code></td>
<td>
<p>A list of parameters controlling the bootstrap when
computing the bootstrap bandwidths of the product-limit estimator.
<code>B</code>, the number of bootstrap resamples, and <code>nnfrac</code>,
the fraction of the sample size that determines the order of the nearest
neighbor used for choosing a pilot bandwidth. If <code>h</code> is missing
the list of parameters is extended to be the same used for computing the
bootstrap bandwidth. The default is the value returned by the
<code>controlpars</code> function called without arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture cure model writes the conditional survival function
<code class="reqn">S(t\mid x)=P(Y&gt;t\mid X=x)</code> as
<code class="reqn">S(t\mid x)=1-p(x)+p(x)S_0(t\mid x)</code>. 
This function computes the generalized product-limit estimator of the
conditional survival function <code class="reqn">S(t \mid x)</code>, using the
Nadaraya-Watson weights, when the cure status is partially known,
introduced in Safari <em>et al</em> (2021). If there are not individuals
known to be cured (<code>xinu=0</code>), then the usual generalized product-limit
estimator in Beran (1981) is computed.
</p>
<p>The Epanechnikov kernel is used. If the smoothing parameter <code>h</code> is not
provided, then the bootstrap bandwidth selector in Safari <em>et al</em>
(2021) is used. The function is available only for one continuous covariate
<code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>A list of components:
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>The numeric vector of bandwidths used in the estimation. If
<code>h</code> argument is missing, the bootstrap bandwidth computed with the
control parameters in argument <code>bootpars</code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The numeric vector of covariate values where the estimate of the
conditional survival function is computed.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The observed time values, where the conditional survival function
is estimated.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>Estimates of the survival function for each one of the covariate
values specified by the <code>x0</code> argument and the bandwidths in
<code>h</code>. It is a matrix of dimension <code class="reqn">n\times length(x0)</code>
if local bandwidths or bootstrap bandwidths are used, or an array of
dimension <code class="reqn">n\times length(x0)\times length(h)</code>
for global bandwidths instead.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Beran, R. (1981). Nonparametric regression with randomly censored survival
data. Technical Report. Berkeley, University of California.
</p>
<p>Safari, W. C., López-de-Ullibarri I., Jácome, M. A. (2021). A product-limit
estimator of the conditional survival function when cure status is partially
known. Biometrical Journal, 63(5): 984-1005. <a href="https://doi.org/10.1002/bimj.202000173">doi:10.1002/bimj.202000173</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+controlpars">controlpars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(npcurePK)

## Data-generating function
## n: sample size
## x_cov_range: range of covariate values
## p_knowncure: probability of known cure
data_gen &lt;- function(n, x_cov_range, p_knowncure) {
  ## probability of being susceptible
  p0 &lt;- function(x) exp(2*x)/(1 + exp(2*x))
  ## covariate values
  x &lt;- runif(n, x_cov_range[1], x_cov_range[2])
  ## censoring times
  c &lt;- rexp(n)
  u &lt;- runif(n)
  v &lt;- runif(n)
  data &lt;- data.frame(matrix(0, nrow = n, ncol = 4L,
                            dimnames = list(NULL, c("x", "t", "d", "xinu"))))
  data[, "x"] &lt;- x
  for (i in 1:n) {
    if (u[i] &gt; p0(x[i])) {
      ## Cured individuals (all of them are censored: Yi = infty,
      ## Ti = Ci, delta = 0, nu = 1)
      data[i, "t"] &lt;- c[i]
      if (v[i] &lt; p_knowncure)
        data[i, "xinu"]  &lt;- 1 
    } else {
      ## Uncured individual (Yi &lt; infty, Ti = min(Yi, Ci),
      ## delta = 1(Yi &lt; Ci), nu = 0)
      ## Uncensored individual (d = 1): cure status is
      ## observed (xi = 1), i.e., xinu = 0
      ## Censored individual (d = 0): cure status is
      ## unknown (xi = 0), i.e., xi.nu = 0
      y &lt;- rweibull(1, shape = 0.5 * (x[i] + 4))
      data[i, "t"]  &lt;- ifelse(v[i] &lt; p_knowncure, y, min(y, c[i]))
      if (data[i, "t"] == y) data[i, "d"] &lt;- 1
    }
  }
  return(data)
}

set.seed(123)
data &lt;- data_gen(n = 100, x_cov_range = c(-2, 2), p_knowncure = 0.8)

## Covariate values where the conditional survival function is estimated
x0 &lt;- c(0, 0.5)

## Survival estimates for covariate values x0 = c(0, 0.5)
## ... (a) with 3 global bandwidths (0.5, 1, 1.25)
## The survival function S(t|x) is estimated for each value of x0 with the three
## bandwidths (local == FALSE).
## The estimates are saved in an array (n x length(x0) x length(h))
S1 &lt;- prodlim_curepk(x, t, d, xinu, data, x0 = x0, h = c(0.5, 1, 1.25), local = FALSE)

## Plot predicted survival curve for covariate value x0 = 0.5 and bandwidth
## h = 0.5
x0 &lt;- 0.5
plot(S1$t, S1$surv[, 2, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
## The true survival curve is included as reference
lines(S1$t, 1 - exp(2*x0)/(1 + exp(2*x0)) + exp(2*x0)/(1 + exp(2*x0))*
            (1 - pweibull(S1$t, shape = 0.5 * (x0 + 4))), lwd = 2)     
       
## Plot predicted survival curve for covariate value x0 = 0.5 and all
## bandwidths 
plot(S1$t, S1$surv[, 2, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
lines(S1$t, S1$surv[, 2, 2], type = "s", lwd = 2)
lines(S1$t, S1$surv[, 2, 3],  type = "s", lwd = 3)
# The true survival curve is included as reference
lines(S1$t, 1 - exp(2*x0)/(1 + exp(2*x0)) + exp(2*x0)/(1 + exp(2*x0))*
            (1 - pweibull(S1$t, shape = 0.5 * (x0 + 4))), lwd = 2)     
     
## ... (b) with local bandwidths h = (3, 1)
## The survival function S(t|x) is estimated for each value of x0 with the
## corresponding assigned bandwidth (local == TRUE).
## Note that the length of the vector x0 and the bandwidth h must be the same.
## The estimates are saved in a matrix of dimension (n, length(x0))
x0 &lt;- c(0, 0.5)
h  &lt;- c(3, 1)
S3 &lt;- prodlim_curepk(x, t, d, xinu, data, x0 = x0, h = h, local = TRUE)
## Plot predicted survival curve for covariate value x = 0 and its bandwidth
## (h = 3)
plot(S3$t, S3$surv[, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
## The true survival curve is included as reference     
x0 &lt;- 0 
lines(S3$t, 1 - exp(2*x0)/(1 + exp(2*x0)) + exp(2*x0)/(1 + exp(2*x0))*
            (1 - pweibull(S3$t, shape = 0.5 * (x0 + 4))), lwd = 2)

## ... (c) with the bootstrap bandwidth selector in x0 = 0 (the default
## when the bandwidth argument h is not provided).
## The bootstrap bandwidth is searched in a grid of 10 bandwidths (hl = 10)
## between 0.2 and 2 times the standardized interquartile range of the
## covariate values (hbound = c(0.1, 2)).
x0 &lt;- 0
(S4 &lt;- prodlim_curepk(x, t, d, xinu, data, x0 = x0))
## Equivalently
(S4 &lt;- prodlim_curepk(x, t, d, xinu, data, x0 = x0,
                      bootpars = controlpars(hl = 10, hbound = c(0.1, 2))))
## Plot predicted survival curve for covariate value x = 0 and the bootstrap
## bandwidth
plot(S4$t, S4$surv[, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
## The true survival curve is included as reference     
lines(S4$t, 1 - exp(2*x0)/(1 + exp(2*x0)) + exp(2*x0)/(1 + exp(2*x0))*
            (1 - pweibull(S4$t, shape = 0.5 * (x0 + 4))), lwd = 2)

## ... (d) with parallel computation (The bootstrap bandwidth is searched with
## b = 100 bootstrap resamples and 2 cores)
library(doParallel)
(S5 &lt;- prodlim_curepk(x, t, d, xinu, data, x0 = x0,
                      bootpars = controlpars(b = 100, ncores = 2)))
## Plot predicted survival curve for covariate value x = 0 and the bootstrap
## bandwidth
plot(S5$t, S5$surv[, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
## The true survival curve is included as reference     
lines(S5$t, 1 - exp(2*x0)/(1 + exp(2*x0)) + exp(2*x0)/(1 + exp(2*x0))*
            (1 - pweibull(S5$t, shape = 0.5 * (x0 + 4))), lwd = 2)
    
</code></pre>

<hr>
<h2 id='sarcoma+0A'>Sarcoma Dataset
</h2><span id='topic+sarcoma'></span>

<h3>Description</h3>

<p>Sarcoma is a rare type of cancer that represents 1% of all adult solid malignancies (Choy, 2014). If a tumor can be surgically removed to render the patient with sarcoma free of detectable disease, 5 years is the survival time at which sarcoma oncologists assume long-term remissions.
<code>sarcoma</code> dataset contains the observed survival time of 232 patients until death from sarcoma, and covariates such as the age at diagnosis. Patients tumor free for more than 5 years were assumed to be long-term survivors (known to be cured, <code>xinu = 1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    sarcoma
    data(sarcoma, package = "npcurePK")
</code></pre>


<h3>Format</h3>

<p>A data frame with 232 rows and 4 variables:
</p>

<dl>
<dt><code>x</code></dt><dd><p>Age (years) of patients at diagnosis.</p>
</dd>
<dt><code>t</code></dt><dd><p>Observed time until death from sarcoma.</p>
</dd>
<dt><code>d</code></dt><dd><p>Censoring status (0 = censored, 1 = death from sarcoma).
</p>
</dd>
<dt><code>xinu</code></dt><dd><p>Cure status (0 = dead or unknown, 1 = tumor free for
more than 5 years).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Provided by the authors to serve as an example.
</p>


<h3>References</h3>

<p>Choy, E. (2014). Sarcoma after 5 years of progression-free survival: Lessons from the French sarcoma group. Cancer, 120(19), 2942-2943.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
## Survival estimates of patients aged 40 and 90 years old
## computed with bootstrap bandwidths
## (seed is used for bootstrap resampling)
(S1 &lt;- prodlim_curepk(x, t, d, xinu, sarcoma, x0 = c(40, 90),
                      bootpars = controlpars(b = 100, ncores = 2, seed = 123)))
plot(S1$t, S1$surv[, 1], type = "s", xlab = "Time",
     ylab = "Survival probability", ylim = c(0, 1))
lines(S1$t, S1$surv[, 2], type = "s")
    
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
