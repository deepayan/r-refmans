<!DOCTYPE html><html><head><title>Help for package RcppSMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppSMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockpfGaussianOpt'><p>Block Sampling Particle Filter (Linear Gaussian Model; Optimal Proposal)</p></a></li>
<li><a href='#compareNCestimates'><p>Conditional Sequential Monte Carlo Examples</p></a></li>
<li><a href='#LinReg'><p>Simple Linear Regression</p></a></li>
<li><a href='#nonLinPMMH'><p>Particle marginal Metropolis-Hastings for a non-linear state space model.</p></a></li>
<li><a href='#pfLineartBS'><p>Particle Filter Example</p></a></li>
<li><a href='#pfNonlinBS'><p>Nonlinear Bootstrap Particle Filter (Univariate Non-Linear State Space Model)</p></a></li>
<li><a href='#radiata'><p>Radiata pine dataset (linear regression example)</p></a></li>
<li><a href='#RcppSMC.package.skeleton'>
<p>Create a skeleton for a new package that intends to use RcpSMCp</p></a></li>
<li><a href='#simNonlin'><p>Simulates from a simple nonlinear state space model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Rcpp Bindings for Sequential Monte Carlo</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel, Adam M. Johansen, Leah F. South and Ilya Zarubin</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R access to the Sequential Monte Carlo Template Classes
 by Johansen &lt;<a href="https://doi.org/10.18637%2Fjss.v030.i06">doi:10.18637/jss.v030.i06</a>&gt; is provided. At present, four
 additional examples have been added, and the first example from the JSS
 paper has been extended. Further integration and extensions are planned.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), methods, FKF</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pkgKitten (&ge; 0.2.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rcppsmc/rcppsmc">https://github.com/rcppsmc/rcppsmc</a>,
<a href="https://dirk.eddelbuettel.com/code/rcpp.smc.html">https://dirk.eddelbuettel.com/code/rcpp.smc.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rcppsmc/rcppsmc/issues">https://github.com/rcppsmc/rcppsmc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 12:08:18 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockpfGaussianOpt'>Block Sampling Particle Filter (Linear Gaussian Model; Optimal Proposal)</h2><span id='topic+blockpfGaussianOpt'></span><span id='topic+simGaussian'></span>

<h3>Description</h3>

<p>The <code>blockpfGaussianOpt</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. It is based on a block sampling particle filter for a linear
Gaussian model. This is intended only to illustrate the potential of block
sampling; one would not ordinarily use a particle filter for a model in
which analytic solutions are available. The 'optimal' block sampler in the
sense of Doucet, Briers and Senecal (2006) can be implemented in this case.
</p>
<p>The <code>simGaussian</code> function simulates data from the associated linear
Gaussian state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  blockpfGaussianOpt(data, particles=1000, lag=5, plot=FALSE) 
  simGaussian(len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockpfGaussianOpt_+3A_data">data</code></td>
<td>
<p>A vector variable containing the sequence of observations.</p>
</td></tr>
<tr><td><code id="blockpfGaussianOpt_+3A_particles">particles</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
<tr><td><code id="blockpfGaussianOpt_+3A_lag">lag</code></td>
<td>
<p>An integer specifying the length of block to use.</p>
</td></tr>
<tr><td><code id="blockpfGaussianOpt_+3A_plot">plot</code></td>
<td>
<p>A boolean variable describing whether plot should
illustrate the estimated path along with the uncertainty.</p>
</td></tr>
<tr><td><code id="blockpfGaussianOpt_+3A_len">len</code></td>
<td>
<p>The length of the data sequence to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>blockpfGaussianOpt</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. It is based on a simple linear Gaussian state space model in
which the state evolution and observation equations are:
x(n) = x(n-1) + e(n) and 
y(n) = x(n) + f(n)
where e(n) and f(n) are mutually-independent standard normal random
variables. The 'optimal' block-sampling proposal described by Doucet
et al (2006) is employed. 
</p>
<p>The <code>simGaussian</code> function simulates from the same model returning both
the state and observation vectors.
</p>


<h3>Value</h3>

<p>The <code>blockpfGaussianOpt</code> function returns a matrix containing the final
sample paths and a vector containing their weights. The logarithm of the
estimated ratio of normalising constants between the final and initial
distributions is also returned.
</p>
<p>The <code>simGaussian</code> function returns a list containing the state and data
sequences. 
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen and Dirk Eddelbuettel</p>


<h3>References</h3>

<p>A. Doucet, M. Briers, and S. Senecal. Efficient Block Sampling Strategies
for sequential Monte Carlo methods. Journal of Computational and Graphical
Statistics, 15(3):693-711, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sim &lt;- simGaussian(len=250)
  res &lt;- blockpfGaussianOpt(sim$data,lag=5,plot=TRUE)
</code></pre>

<hr>
<h2 id='compareNCestimates'>Conditional Sequential Monte Carlo Examples</h2><span id='topic+compareNCestimates'></span><span id='topic+simGaussianSSM'></span><span id='topic+kalmanFFBS'></span>

<h3>Description</h3>

<p>The <code>compareNCestimates</code> function generates a Monte Carlo study to
compare log-likelihood (normalizing constant) estimates in the standard linear
Gaussian state space (LGSS) model: Kalman filter estimates, as the benchmark,
are compared to the standard bootstrap particle filter and the conditional
bootstrap particle filter estimates (see <code>Details</code>).
</p>
<p>The <code>simGaussianSSM</code> function simulates data from a LGSS model (can be
used manually to simulate <code>data</code> or runs as a default, if no <code>data</code> is provided, with a default parameter setup, see <code>parameters</code>).
</p>
<p>The <code>kalmanFFBS</code> function runs a Kalman (exact) forward filter, computes
a log-likelihood estimate and generates a joint smoothing state trajectory
via a backward simulation pass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  compareNCestimates(dataY,
                     trueStates = NULL,
                     numParticles = 1000L,
                     simNumber = 100L,
                     modelParameters = list(stateInit = 0,
                                            phi = 0.7,
                                            varStateEvol = 1,
                                            varObs = 1),
                     plot = FALSE)
  simGaussianSSM(len = 100,
                 stateInit = 0,
                 phi = 0.7,
                 varStateEvol = 1,
                 varObs = 1)
  kalmanFFBS(dataY,
             stateInit,
             phi,
             varStateEvol,
             varObs,
             simNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareNCestimates_+3A_datay">dataY</code></td>
<td>
<p>A one-column matrix or dataframe or vector containing
measurements (y values) from a standard linear Gaussian SSM. If not provided, defaults to a LGSS model with time series lenght <code>len=250</code> and parameter
setup specified with default values in the <code>parameters</code> argument, see <code><a href="#topic+simGaussianSSM">simGaussianSSM</a></code> or <code><a href="#topic+compareNCestimates">compareNCestimates</a></code>.</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_truestates">trueStates</code></td>
<td>
<p>defaults to <code>NULL</code> for a real dataset as the true state
values are not observed; for simulated data, these can be passed and then will alse be plotted if <code>plot=TRUE</code></p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_numparticles">numParticles</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_simnumber">simNumber</code></td>
<td>
<p>An integer specifying the number of repeated simulation runs of each of which produces 2x4=8 normalizing constant esimtates: BPF and conditional BPF esimates under four conditional resampling schemes, as well as
a ground truth Kalman forward filter estimate and a backward filter output
required for the reference trajectory of the conditional sampler.</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_modelparameters">modelParameters</code></td>
<td>
<p>a named <code>list</code> of parameters of the LGSSM model
in the following order:
</p>

<ul>
<li> <p><code>phi:</code> autoregressive parameter
</p>
</li>
<li> <p><code>stateInit:</code> initial state value (i.e. <code class="reqn">X_0</code>)
</p>
</li>
<li> <p><code>varStateEvol:</code> state process variance
</p>
</li>
<li> <p><code>varObs:</code> measurement/observation process variance
</p>
</li></ul>

<p>These parameters are used to for the Kalman forward filtering and backward
simulation pass, and, if no <code>data</code> argument is provided, to simulate
data from a linear Gaussian state space model internally via
<code>simGaussianSSM</code>.</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_phi">phi</code></td>
<td>
<p>autoregressive parameter</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_stateinit">stateInit</code></td>
<td>
<p>initial state value (i.e. <code class="reqn">X_0</code>)</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_varstateevol">varStateEvol</code></td>
<td>
<p>state process variance</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_varobs">varObs</code></td>
<td>
<p>measurement/observation process variance</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_plot">plot</code></td>
<td>
<p>A boolean variable describing whether plot should
illustrate the estimated results along with the data.</p>
</td></tr>
<tr><td><code id="compareNCestimates_+3A_len">len</code></td>
<td>
<p>Length of data series to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compareNCestimates</code> runs a simulation study that provides
log-likelihood (normalizing constant) estimates; there are <code>simNumber</code>
runs of the standard BPF and the conditional BPF under four resampling schmes:
</p>

<ul>
<li><p> multinomial
</p>
</li>
<li><p> stratified
</p>
</li>
<li><p> systematic
</p>
</li>
<li><p> residual
</p>
</li></ul>

<p>The &quot;ground truth&quot; Kalman forward filter estimate of the normalizing constant
is compared to the BPF normalizing constant estimates, which are unbiased for
all above schemes; specifically the conditional BPF estimate is unbiased if
the reference trajectory is simulated from the target distribution which is obtained here as a backward simulation run of the Kalman
filter.
</p>
<p>Box plots illustrate the unbiasedness of standard BPF and conditional BPF
estimates for the normailizing constant estimate in the linear Gaussian SSM, and serve as an small example for to illustrate conditional SMC
algorithms (in their most basic BPF version) with different conditonal resampling schemes as implemented within <span class="pkg">RcppSMC</span>.
</p>
<p><code>simGaussianSSM</code> simulates from a Linear Gaussian state space model of
the following form:
</p>
<p style="text-align: center;"><code class="reqn">x_t=\phi x_{t-1} + u_t</code>
</p>

<p style="text-align: center;"><code class="reqn">y_t= x_{t} + w_t</code>
</p>

<p>where <code class="reqn">\phi</code> is set via the <code>phi</code> argument,
<code class="reqn">u_t \sim N(0, \sigma_x^2)</code>, <code class="reqn">w_t \sim N(0, \sigma_y^2)</code> for which the
innovation (<code class="reqn">\sigma_x^2</code>) and measurement (<code class="reqn">\sigma_y^2</code>) variances are
set via arguments <code>varStateEvol</code> and <code>varObs</code>, respectively.
</p>


<h3>Value</h3>

<p><code>compareNCestimates</code> returns a named list of two
</p>

<ul>
<li><p><code>outSMC</code> a named list of two:
</p>

<ul>
<li><p><code>smcOut</code>: a matrix of dimension <code>simNum x 4</code> which
contains single log-likelihood estimates of the standard BPF for each of
the 4 resampling schemes and for each simulation run
</p>
</li>
<li><p><code>csmcOut</code>: a matrix of dimension <code>simNum x 4</code> which
contains single log-likelihood estimates of the conditional BPF for each
of the 4 resampling schemes and for each simulation run
</p>
</li></ul>

</li>
<li><p><code>outKalman</code> the output of <code>kalmanFFBS</code>, see below
</p>
</li></ul>

<p><code>kalmanFFBS</code> returns a named list of two:
</p>

<ul>
<li><p><code>logLikeliEstim: </code>(exact) estimate of the log-likelihood
</p>
</li>
<li><p><code>xBackwardSimul: </code>a backward simulation (joint smoothing) trajectory of latent states given parameters and measurement
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adam M. Johansen, Dirk Eddelbuettel, Leah South and Ilya Zarubin</p>


<h3>References</h3>

<p>A. M. Johansen. SMCTC: Sequential Monte Carlo in C++.
Journal of Statistical Software, 30(6):1-41, April
2009. <a href="https://www.jstatsoft.org/article/view/v030i06">https://www.jstatsoft.org/article/view/v030i06</a>
</p>


<h3>See Also</h3>

<p>The SMCTC paper and code at <a href="https://www.jstatsoft.org/article/view/v030i06">https://www.jstatsoft.org/article/view/v030i06</a>.</p>

<hr>
<h2 id='LinReg'>Simple Linear Regression</h2><span id='topic+LinReg'></span><span id='topic+LinRegLA'></span><span id='topic+LinRegLA_adapt'></span>

<h3>Description</h3>

<p>A simple example based on estimating the parameters of a linear regression model
using
</p>
<p>* Data annealing sequential Monte Carlo (<code>LinReg</code>).
</p>
<p>* Likelihood annealing sequential Monte Carlo (<code>LinRegLA</code>).
</p>
<p>* Likelihood annealing sequential Monte Carlo with the temperature schedule,
number of MCMC repeats and random walk covariance matrices adapted online (<code>LinRegLA_adapt</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinReg(model, particles = 1000, plot = FALSE)

LinRegLA(model, particles = 1000, temperatures = seq(0, 1, 0.05)^5)

LinRegLA_adapt(model, particles = 1000, resampTol = 0.5, tempTol = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinReg_+3A_model">model</code></td>
<td>
<p>Choice of regression model (1 for density as the predictor
and 2 for adjusted density as the predictor).</p>
</td></tr>
<tr><td><code id="LinReg_+3A_particles">particles</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
<tr><td><code id="LinReg_+3A_plot">plot</code></td>
<td>
<p>A boolean variable to determine whether to plot the posterior estimates.</p>
</td></tr>
<tr><td><code id="LinReg_+3A_temperatures">temperatures</code></td>
<td>
<p>In likelihood annealing SMC the targets are defined as <code class="reqn">P(y|\theta)^{\gamma_t}P(\theta)</code>
where <code class="reqn">0=\gamma_0\le \ldots \le \gamma_T = 1</code> can be referred to
as the temperatures, <code class="reqn">P(y|\theta)</code> is the likelihood and <code class="reqn">P(\theta)</code>
is the prior.</p>
</td></tr>
<tr><td><code id="LinReg_+3A_resamptol">resampTol</code></td>
<td>
<p>The adaptive implementation of likelihood annealing SMC allows for
the resampling tolerance to be specified. This parameter can be set to a value in
the range [0,1) corresponding to a fraction of the size of the particle set or it
may be set to an integer corresponding to an actual effective sample size.</p>
</td></tr>
<tr><td><code id="LinReg_+3A_temptol">tempTol</code></td>
<td>
<p>A tolerance for adaptive choice of the temperature schedule such
that the conditional ESS is maintained at tempTol*particles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Williams (1959) considers two competing linear regression models
for the maximum compression strength parallel to the grain for radiata
pine. Both models are of the form
</p>
<p><code class="reqn">y_i = \alpha + \beta (x_i - \bar{x}) + \epsilon_i</code>,
</p>
<p>where <code class="reqn">\epsilon_i ~ N(0,\sigma^2)</code> and <code class="reqn">i=1,\ldots,42</code>.
Here <code class="reqn">y</code> is the maximum compression strength in pounds per square
inch. The density (in pounds per cubic foot) of the radiata pine
is considered a useful predictor, so model 1 uses density for <code class="reqn">x</code>.
Model 2 instead considers the density adjusted for resin content, which
is associated with high density but not with strength.
</p>
<p>This example is frequently used as a test problem in model choice
(see for example Carlin and Chib (1995) and Friel and Pettitt (2008)).
We use the standard uninformative normal and inverse gamma priors for this example
along with the transformation <code class="reqn">\phi=log(\sigma^2)</code> so that all parameters
are on the real line and <code class="reqn">\theta = [\alpha,\beta,\phi]</code>.
The evidence can be computed using numerical estimation
for both of the competing models. The log evidence is -309.9 for model 1 and
-301.4 for model 2.
</p>
<p>The <code>LinReg</code> function implements a data annealing approach to this example.
</p>
<p>The <code>LinRegLA</code> function implements a likelihood annealing approach to this example.
</p>
<p>The <code>LinRegLA_adapt</code> function implements a likelihood annealing approach to this example
with adaptation of the temperature schedule, number of MCMC repeats and random walk covariance
matrices.
</p>


<h3>Value</h3>

<p>The <code>LinReg</code> function returns a <code>list</code> containing the final particle
approximation to the target (<code class="reqn">\theta</code> and the corresponding weights) as well as the logarithm
of the estimated model evidence.
</p>
<p>The <code>LinRegLA</code> function returns a <code>list</code> containing the population
of particles and their associates log likelihoods, log priors and weights at each iteration. The
effective sample size at each of the iterations and several different
estimates of the logarithm of the model evidence are also returned.
</p>
<p>The <code>LinRegLA_adapt</code> function returns a <code>list</code> containing all of the same
output as <code>LinRegLA</code>, in addition to the adaptively chosen temperature schedule
and number of MCMC repeats.
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen, Dirk Eddelbuettel and Leah F. South
</p>


<h3>References</h3>

<p>B. P. Carlin and S. Chib. Bayesian model choice via Markov chain
Monte Carlo. Journal of the Royal Statistical Society: Series B
(Statistical Methodology). 57(3):473-484, 1995.
</p>
<p>N. Friel and A. N. Pettitt. Marginal likelihood estimation via power posteriors.
Journal of the Royal Statistical Society: Series B (Statistical Methodology).
70(3):589-607, 2008.
</p>
<p>Williams, E. (1959). Regression analysis. Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- LinReg(model=1, particles=1000, plot=TRUE)

res &lt;- LinRegLA(model=1, particles=1000)

res &lt;- LinRegLA_adapt(model=1, particles=1000)

</code></pre>

<hr>
<h2 id='nonLinPMMH'>Particle marginal Metropolis-Hastings for a non-linear state space model.</h2><span id='topic+nonLinPMMH'></span>

<h3>Description</h3>

<p>The <code>nonLinPMMH</code> function implements particle marginal Metropolis Hastings
for the non-linear state space model described in Section 3.1 of
Andrieu et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonLinPMMH(data, particles = 5000, iterations = 10000, burnin = 0,
  verbose = FALSE, msg_freq = 100, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonLinPMMH_+3A_data">data</code></td>
<td>
<p>A vector of the observed data.</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_particles">particles</code></td>
<td>
<p>An integer specifying the number of particles in the particle
filtering estimates of the likelihood.</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_burnin">burnin</code></td>
<td>
<p>The number of iterations to remove from the beginning of the MCMC chain
(for plotting purposes only).</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code> convergence diagnostics are printed to 
the console (each <code>msg_freq</code> iterations) displaying the running means of 
parameters, the log-prior, the log-likelihood and the MH acceptance rates up to 
the current iteration; defaults to <code>FALSE</code> in which case only percentage 
completion of the procedure is printed.</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_msg_freq">msg_freq</code></td>
<td>
<p>Specifies the printing frequency of percentage completion or, if
<code>verbose = TRUE</code>, percentage completion as well as convergence
diagnostics.</p>
</td></tr>
<tr><td><code id="nonLinPMMH_+3A_plot">plot</code></td>
<td>
<p>A boolean variable to determine whether to plot the posterior estimates
and MCMC chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This example uses particle marginal Metropolis Hastings to estimate
the standard deviation of the evolution and observation noise in the following
non-linear state space model:
</p>
<p><code class="reqn">x(n) = 0.5 x(n-1) + 25 x(n-1) / (1+x(n-1)^2) + 8 cos(1.2n)+ e(n)</code> and 
</p>
<p><code class="reqn">y(n) = x(n)^2 / 20 + f(n)</code>
</p>
<p>where e(n) and f(n) are mutually-independent normal random
variables of variances var_evol and var_obs, respectively,
and <code class="reqn">x(0) ~ N(0,5)</code>.
</p>
<p>Following Andrieu, Doucet and Holenstein (2010), the priors are
<code class="reqn">var_evol ~ IG(0.01,0.01)</code> and <code class="reqn">var_obs ~ IG(0.01,0.01)</code> where IG
is the inverse gamma distribution.
</p>
<p>Data can be simulated from the model using <code><a href="#topic+simNonlin">simNonlin</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the chain
of simulated <code class="reqn">\sigma_v</code> and <code class="reqn">\sigma_w</code> values, as well as the
corresponding log likelihood estimates and log prior values.
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen, Dirk Eddelbuettel and Leah F. South
</p>


<h3>References</h3>

<p>C. Andrieu, A. Doucet, and R. Holenstein. Particle Markov chain Monte Carlo methods.
Journal of the Royal Statistical Society: Series B (Statistical Methodology),
72(3):269-342, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simNonlin">simNonlin</a></code> for a function to simulate from the model and
<code><a href="#topic+pfNonlinBS">pfNonlinBS</a></code> for a simple bootrap particle filter
applied to a similar non-linear state space model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- simNonlin(len=500,var_init=5,var_evol=10,var_obs=1,cosSeqOffset=0)
res &lt;- nonLinPMMH(sim$data,particles=5000,iterations=50000,burnin=10000,plot=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='pfLineartBS'>Particle Filter Example</h2><span id='topic+pfLineartBS'></span><span id='topic+pfLineartBSOnlinePlot'></span><span id='topic+simLineart'></span>

<h3>Description</h3>

<p>The <code>pfLineartBS</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. It is based on the first example in <code>SMCTC</code> and
the discussion in Section 5.1 of Johansen (2009). A simple 'vehicle
tracking' problem of 100 observations is solved with 1000 particles.
</p>
<p>The <code>pfLineartBSOnlinePlot</code> function provides a simple default
&lsquo;online&rsquo; plotting function that is invoked during the
estimation process.
</p>
<p>The <code>simLineart</code> function simulates data from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pfLineartBS(data, particles=1000, plot=FALSE, onlinePlot)
  pfLineartBSOnlinePlot(xm, ym)
  simLineart(len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfLineartBS_+3A_data">data</code></td>
<td>
<p>A two-column matrix or dataframe containing x and y
values. The default data set from Johansen (2009) is used as the
default if no data is supplied.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_particles">particles</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_plot">plot</code></td>
<td>
<p>A boolean variable describing whether plot should
illustrate the estimated path along with the data.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_onlineplot">onlinePlot</code></td>
<td>
<p>A user-supplied callback function which is called with the
x and y position vectors during each iteration of the algorithm; see
pfExOnlinePlot for a simple example.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_xm">xm</code></td>
<td>
<p>Vector with x position.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_ym">ym</code></td>
<td>
<p>Vector with y position.</p>
</td></tr>
<tr><td><code id="pfLineartBS_+3A_len">len</code></td>
<td>
<p>Length of sequence to simulate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pfLineartBS</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. The model is linear with t-distributed innovations.
It is based on the <code>pf</code> example in the
<code>SMCTC</code> library, and discussed in the Section 5.1 of his
corresponding paper (Johansen, 2009).   <code>simLineart</code> simulates from the
model.
</p>
<p>Using the simple <code>pfExOnlinePlot</code> function illustrates how
callbacks into R, for example for plotting,  can be made during the
operation of SMC algorithm.
</p>


<h3>Value</h3>

<p>The <code>pfLineartBS</code> function returns a <code>data.frame</code> containing as many rows as in
the input data, and four columns corresponding to the estimated <code class="reqn">x</code> and
<code class="reqn">y</code> coordinates as well as the estimated velocity in these two
directions.
</p>
<p>The <code>simLineart</code> function returns a list containing the vector of
states and the associated vector of observations.
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen and Dirk Eddelbuettel</p>


<h3>References</h3>

<p>A. M. Johansen. SMCTC: Sequential Monte Carlo in C++.
Journal of Statistical Software, 30(6):1-41, April
2009, <a href="https://doi.org/10.18637/jss.v030.i06">doi:10.18637/jss.v030.i06</a>.
</p>


<h3>See Also</h3>

<p>The SMCTC paper and code at <a href="https://doi.org/10.18637/jss.v030.i06">doi:10.18637/jss.v030.i06</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  res &lt;- pfLineartBS(plot=TRUE)
  if (interactive()) ## if not running R CMD check etc
     res &lt;- pfLineartBS(onlinePlot=pfLineartBSOnlinePlot)
</code></pre>

<hr>
<h2 id='pfNonlinBS'>Nonlinear Bootstrap Particle Filter (Univariate Non-Linear State Space Model)</h2><span id='topic+pfNonlinBS'></span>

<h3>Description</h3>

<p>The <code>pfNonlinBS</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. It is a simple &ldquo;bootstrap&rdquo; particle filter which employs
multinomial resampling after each iteration applied to the ubiquitous &quot;nonlinear
state space model&quot; following Gordon, Salmond and Smith (1993).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pfNonlinBS(data, particles=500, plot=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfNonlinBS_+3A_data">data</code></td>
<td>
<p>A vector variable containing the sequence of observations.</p>
</td></tr>
<tr><td><code id="pfNonlinBS_+3A_particles">particles</code></td>
<td>
<p>An integer specifying the number of particles.</p>
</td></tr>
<tr><td><code id="pfNonlinBS_+3A_plot">plot</code></td>
<td>
<p>A boolean variable describing whether a plot should
illustrate the (posterior mean) estimated path along with one and two
standard deviation intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pfNonlinbs</code> function provides a simple example for
<span class="pkg">RcppSMC</span>. It is based on a simple nonlinear state space model in
which the state evolution and observation equations are:
x(n) = 0.5 x(n-1) + 25 x(n-1) / (1+x(n-1)^2) + 8 cos(1.2(n-1))+ e(n) and 
y(n) = x(n)^2 / 20 + f(n)
where e(n) and f(n) are mutually-independent normal random
variables of variances 10.0 and 1.0, respectively. A boostrap proposal
(i.e. sampling from the state equation) is used, together with multinomial
resampling after each iteration.
</p>


<h3>Value</h3>

<p>The <code>pfNonlinBS</code> function returns two vectors, the first containing the posterior
filtering means; the second the posterior filtering standard deviations.
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen, Dirk Eddelbuettel and Leah F. South</p>


<h3>References</h3>

<p>N. J. Gordon, S. J. Salmond, and A. F. M. Smith. Novel approach to
nonlinear/non-Gaussian Bayesian state estimation. IEE Proceedings-F, 
140(2):107-113, April 1993.	
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simNonlin">simNonlin</a></code> for a function to simulate from the model and
<code><a href="#topic+nonLinPMMH">nonLinPMMH</a></code> for an example of particle
marginal Metropolis Hastings applied to a non-linear state space model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sim &lt;- simNonlin(len=50)
  res &lt;- pfNonlinBS(sim$data,particles=500,plot=TRUE)
</code></pre>

<hr>
<h2 id='radiata'>Radiata pine dataset (linear regression example)</h2><span id='topic+radiata'></span>

<h3>Description</h3>

<p>This dataset was originally presented in Table 5.1 of Williams (1959) where
two non-nested linear regression models were considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiata
</code></pre>


<h3>Format</h3>

<p>A data frame with 42 rows and three variables:
</p>

<dl>
<dt>y</dt><dd><p>Maximum compression strength (response) in pounds per square inch</p>
</dd>
<dt>x1</dt><dd><p>Density (predictor 1) in pounds per cubic foot</p>
</dd>
<dt>x2</dt><dd><p>Adjusted density (predictor 2) in pounds per cubic foot</p>
</dd>
</dl>


<h3>Source</h3>

<p>E. Williams. Regression analysis. Wiley, 1959.
</p>

<hr>
<h2 id='RcppSMC.package.skeleton'>
Create a skeleton for a new package that intends to use RcpSMCp
</h2><span id='topic+RcppSMC.package.skeleton'></span>

<h3>Description</h3>

<p><code>RcppSMC.package.skeleton</code> automates the creation of
a new source package that intends to use features of RcppSMC.
</p>
<p>It is based on the <a href="utils.html#topic+package.skeleton">package.skeleton</a> and
<a href="pkgKitten.html#topic+kitten">kitten</a> (from <a href="pkgKitten.html#topic+pkgKitten">pkgKitten</a>) functions, the
latter being a Wrapper around <a href="utils.html#topic+package.skeleton">package.skeleton</a> to make a
package pass &lsquo;<span class="samp">&#8288;R CMD check&#8288;</span>&rsquo;	without	complaints. If
<a href="pkgKitten.html#topic+pkgKitten">pkgKitten</a> is not installed,
<a href="utils.html#topic+package.skeleton">package.skeleton</a> is executed instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RcppSMC.package.skeleton(name = "anRpackage", list = character(),
	environment = .GlobalEnv, path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RcppSMC.package.skeleton_+3A_name">name</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="RcppSMC.package.skeleton_+3A_list">list</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="RcppSMC.package.skeleton_+3A_environment">environment</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="RcppSMC.package.skeleton_+3A_path">path</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to <a href="utils.html#topic+package.skeleton">package.skeleton</a> :
</p>
<p>The &lsquo;<span class="samp">&#8288;DESCRIPTION&#8288;</span>&rsquo; file gains a Depends line requesting that
the package depends on Rcpp, RcppArmadillo and RcppSMC and
a LinkingTo line so that the package finds the associated header files.
</p>
<p>The &lsquo;<span class="samp">&#8288;NAMESPACE&#8288;</span>&rsquo;, if any, gains a <code>useDynLib</code> directive.
</p>
<p>The &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo; directory is created if it does not exists and
a &lsquo;<span class="samp">&#8288;Makevars&#8288;</span>&rsquo; file is added setting the environment variable
&lsquo;<span class="samp">&#8288;PKG_LIBS&#8288;</span>&rsquo; to accomodate the necessary flags
to link with the Rcpp library.
</p>
<p>An example file &lsquo;<span class="samp">&#8288;rcppsmc_hello_world.cpp&#8288;</span>&rsquo; is created in the &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo;. An R file &lsquo;<span class="samp">&#8288;rcppsmc_hello_world.R&#8288;</span>&rsquo; is
expanded in the &lsquo;<span class="samp">&#8288;R&#8288;</span>&rsquo; directory, the <code>rcppsmc_hello_world</code> function
defined in this files makes use of the C++ function &lsquo;<span class="samp">&#8288;rcppsmc_hello_world&#8288;</span>&rsquo;
defined in the C++ file. These files are given as an example and should
eventually by removed from the generated package.
</p>


<h3>Value</h3>

<p>Nothing, used for its side effects
</p>


<h3>References</h3>

<p>Read the <em>Writing R Extensions</em> manual for more details.
</p>
<p>Once you have created a <em>source</em> package you need to install it:
see the <em>R Installation and Administration</em> manual,
<code><a href="utils.html#topic+INSTALL">INSTALL</a></code> and <code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+package.skeleton">package.skeleton</a>
<a href="pkgKitten.html#topic+kitten">kitten</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
RcppSMC.package.skeleton( "foobar" )

## End(Not run)
</code></pre>

<hr>
<h2 id='simNonlin'>Simulates from a simple nonlinear state space model.</h2><span id='topic+simNonlin'></span>

<h3>Description</h3>

<p>The <code>simNonlin</code> function simulates data from the models used
in <code>link{pfNonlinBS}</code> and <code>link{nonLinPMMH}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNonlin(len = 50, var_init = 10, var_evol = 10, var_obs = 1,
  cosSeqOffset = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNonlin_+3A_len">len</code></td>
<td>
<p>The length of data sequence to simulate.</p>
</td></tr>
<tr><td><code id="simNonlin_+3A_var_init">var_init</code></td>
<td>
<p>The variance of the noise for the initial state.</p>
</td></tr>
<tr><td><code id="simNonlin_+3A_var_evol">var_evol</code></td>
<td>
<p>The variance of the noise for the state evolution .</p>
</td></tr>
<tr><td><code id="simNonlin_+3A_var_obs">var_obs</code></td>
<td>
<p>The variance of the observation noise.</p>
</td></tr>
<tr><td><code id="simNonlin_+3A_cosseqoffset">cosSeqOffset</code></td>
<td>
<p>This is related to the indexing in the
cosine function in the evoluation equation. A value of -1
can be used to follow the specification of Gordon, Salmond
and Smith (1993) and 0 can be used to follow
Andrieu, Doucet and Holenstein (2010).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simNonlin</code> function simulates from
a simple nonlinear state space model with
state evolution and observation equations:
</p>
<p><code class="reqn">x(n) = 0.5 x(n-1) + 25 x(n-1) / (1+x(n-1)^2) + 8 cos(1.2(n+cosSeqOffset))+ e(n)</code> and 
</p>
<p><code class="reqn">y(n) = x(n)^2 / 20 + f(n)</code>
</p>
<p>where <code class="reqn">e(n)</code> and <code class="reqn">f(n)</code> are mutually-independent normal random
variables of variances var_evol and var_obs, respectively,
and <code class="reqn">x(0) ~ N(0,var_init)</code>.
</p>
<p>Different variations of this model can be found in
Gordon, Salmond and Smith (1993) and
Andrieu, Doucet and Holenstein (2010). A cosSeqOffset
of -1 is consistent with the former and
0 is consistent with the latter.
</p>


<h3>Value</h3>

<p>The <code>simNonlin</code> function returns a list containing the state and data sequences.
</p>


<h3>Author(s)</h3>

<p>Adam M. Johansen, Dirk Eddelbuettel and Leah F. South
</p>


<h3>References</h3>

<p>C. Andrieu, A. Doucet, and R. Holenstein. Particle Markov chain Monte Carlo methods.
Journal of the Royal Statistical Society: Series B (Statistical Methodology),
72(3):269-342, 2010.
</p>
<p>N. J. Gordon, S. J. Salmond, and A. F. M. Smith. Novel approach to
nonlinear/non-Gaussian Bayesian state estimation. IEE Proceedings-F, 
140(2):107-113, April 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfNonlinBS">pfNonlinBS</a></code> for a simple bootrap particle filter
applied to this model and <code><a href="#topic+nonLinPMMH">nonLinPMMH</a></code> for particle
marginal Metropolis Hastings applied to estimating the standard
deviation of the state evolution and observation noise.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
