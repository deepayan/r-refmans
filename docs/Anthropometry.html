<!DOCTYPE html><html><head><title>Help for package Anthropometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Anthropometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anthrCases'>
<p>Helper generic function for obtaining the anthropometric cases</p></a></li>
<li><a href='#Anthropometry-internalArchetypoids'>
<p>Several internal functions to compute and represent archetypes and archetypoids</p></a></li>
<li><a href='#Anthropometry-internalHipamAnthropom'>
<p>Several internal functions used by both $HIPAM_MO$ and $HIPAM_IMO$ algorithms</p></a></li>
<li><a href='#Anthropometry-internalPlotTree'>
<p>Several internal functions used to build the HIPAM plot tree</p></a></li>
<li><a href='#Anthropometry-internalTDDclust'>
<p>Several internal functions to clustering based on the L1 data depth</p></a></li>
<li><a href='#Anthropometry-package'>
<p>Statistical Methods for Anthropometric Data</p></a></li>
<li><a href='#archetypesBoundary'>
<p>Archetypal analysis in multivariate accommodation problem</p></a></li>
<li><a href='#archetypoids'>
<p>Finding archetypoids</p></a></li>
<li><a href='#array3Dlandm'>
<p>Helper function for the 3D landmarks</p></a></li>
<li><a href='#bustSizesStandard'>
<p>Helper function for defining the bust sizes</p></a></li>
<li><a href='#CCbiclustAnthropo'>
<p>Cheng and Church biclustering algorithm applied to anthropometric data</p></a></li>
<li><a href='#cdfDissWomenPrototypes'>
<p>CDF for the dissimilarities between women and computed medoids and standard prototypes</p></a></li>
<li><a href='#checkBranchLocalIMO'>
<p>Evaluation of the candidate clustering partition in $HIPAM_IMO$</p></a></li>
<li><a href='#checkBranchLocalMO'>
<p>Evaluation of the candidate clustering partition in $HIPAM_MO$</p></a></li>
<li><a href='#computSizesHipamAnthropom'>
<p>Computation of the hipamAnthropom elements for a given number of sizes defined by the EN</p></a></li>
<li><a href='#computSizesTrimowa'>
<p>Computation of the trimowa elements for a given number of sizes defined by the EN</p></a></li>
<li><a href='#cube34landm'>
<p>Cube of 34 landmarks</p></a></li>
<li><a href='#cube8landm'>
<p>Cube of 8 landmarks</p></a></li>
<li><a href='#descrDissTrunks'>
<p>Description of the dissimilarities between women's trunks</p></a></li>
<li><a href='#figures8landm'>
<p>Figures of 8 landmarks with labelled landmarks</p></a></li>
<li><a href='#getBestPamsamIMO'>
<p>Generation of the candidate clustering partition in $HIPAM_IMO$</p></a></li>
<li><a href='#getBestPamsamMO'>
<p>Generation of the candidate clustering partition in $HIPAM_MO$</p></a></li>
<li><a href='#getDistMatrix'>
<p>Dissimilarity matrix between individuals and prototypes</p></a></li>
<li><a href='#HartiganShapes'>
<p>Hartigan-Wong k-means for 3D shapes</p></a></li>
<li><a href='#hipamAnthropom'>
<p>HIPAM algorithm for anthropometric data</p></a></li>
<li><a href='#landmarksSampleSpaSurv'>
<p>Landmarks of the sampled women of the Spanish Survey</p></a></li>
<li><a href='#LloydShapes'>
<p>Lloyd k-means for 3D shapes</p></a></li>
<li><a href='#nearestToArchetypes'>
<p>Nearest individuals to archetypes</p></a></li>
<li><a href='#optraShapes'>
<p>Auxiliary optra subroutine of the Hartigan-Wong k-means for 3D shapes</p></a></li>
<li><a href='#overlapBiclustersByRows'>
<p>Overlapped biclusters by rows</p></a></li>
<li><a href='#parallelep34landm'>
<p>Parallelepiped of 34 landmarks</p></a></li>
<li><a href='#parallelep8landm'>
<p>Parallelepiped of 8 landmarks</p></a></li>
<li><a href='#percentilsArchetypoid'>
<p>Helper function for computing percentiles of a certain archetypoid</p></a></li>
<li><a href='#plotPrototypes'>
<p>Prototypes representation</p></a></li>
<li><a href='#plotTreeHipamAnthropom'>
<p>HIPAM dendogram</p></a></li>
<li><a href='#plotTrimmOutl'>
<p>Trimmed or outlier observations representation</p></a></li>
<li><a href='#preprocessing'>
<p>Data preprocessing before computing archetypal observations</p></a></li>
<li><a href='#projShapes'>
<p>Helper function for plotting the shapes</p></a></li>
<li><a href='#qtranShapes'>
<p>Auxiliary qtran subroutine of the Hartigan-Wong k-means for 3D shapes</p></a></li>
<li><a href='#sampleSpanishSurvey'>
<p>Sample database of the Spanish anthropometric survey</p></a></li>
<li><a href='#screeArchetypal'>
<p>Screeplot of archetypal individuals</p></a></li>
<li><a href='#shapes3dShapes'>
<p>3D shapes plot</p></a></li>
<li><a href='#skeletonsArchetypal'>
<p>Skeleton plot of archetypal individuals</p></a></li>
<li><a href='#stepArchetypesRawData'>
<p>Archetype algorithm to raw data</p></a></li>
<li><a href='#stepArchetypoids'>
<p>Run the archetypoid algorithm several times</p></a></li>
<li><a href='#TDDclust'>
<p>Trimmed clustering based on L1 data depth</p></a></li>
<li><a href='#trimmedLloydShapes'>
<p>Trimmed Lloyd k-means for 3D shapes</p></a></li>
<li><a href='#trimmedoid'>
<p>Trimmed k-medoids algorithm</p></a></li>
<li><a href='#trimmOutl'>
<p>Helper generic function for obtaining the trimmed and outlier observations</p></a></li>
<li><a href='#trimowa'>
<p>Trimmed PAM with OWA operators</p></a></li>
<li><a href='#USAFSurvey'>
<p>USAF 1967 survey</p></a></li>
<li><a href='#weightsMixtureUB'>
<p>Calculation of the weights for the OWA operators</p></a></li>
<li><a href='#xyplotPCArchetypes'>
<p>PC scores for archetypes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Anthropometric Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.19</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillermo Vinue, Irene Epifanio, Amelia Simo, M. Victoria Ibanez, Juan Domingo, Guillermo Ayala</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillermo Vinue &lt;Guillermo.Vinue@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical methodologies especially developed to analyze anthropometric data. These methods are aimed 		at providing effective solutions to some commons problems related to Ergonomics and Anthropometry. They are based on clustering, the 		statistical concept of data depth, statistical shape analysis and archetypal analysis. Please see Vinue (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v077.i06">doi:10.18637/jss.v077.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.R-project.org">https://www.R-project.org</a>, <a href="https://www.uv.es/vivigui/">https://www.uv.es/vivigui/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>shapes, rgl, archetypes, nnls, ddalpha, FNN, ICGE, cluster,
biclust</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, calibrate, mvtnorm, RColorBrewer, plotrix, abind</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-22 09:47:01 UTC; guillevinue</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-22 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anthrCases'>
Helper generic function for obtaining the anthropometric cases
</h2><span id='topic+anthrCases'></span><span id='topic+anthrCases.default'></span><span id='topic+anthrCases.trimowa'></span><span id='topic+anthrCases.hipamAnthropom'></span>

<h3>Description</h3>

<p>Because the goal of the methodologies included in this package is always to estimate a number of anthropometric cases given a data set (both central (prototypes) and boundaries (archetypoids)), this auxiliary generic function allows the user to identify the cases computed by each method in an easy way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anthrCases(resMethod, nsizes)
## S3 method for class 'trimowa'
 anthrCases(resMethod, nsizes)
## S3 method for class 'hipamAnthropom'
 anthrCases(resMethod, nsizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anthrCases_+3A_resmethod">resMethod</code></td>
<td>

<p>This is the object which saves the results obtained by the methodologies and which contains the anthropometric cases to return.
</p>
</td></tr>
<tr><td><code id="anthrCases_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of bust sizes. This argument is needed for the &quot;trimowa&quot; and &quot;hipamAnthropom&quot; methodologies because they can compute the prototypes for any given number of bust sizes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code>anthrCases</code> with the anthropometric cases.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., and Ibanez, M. V., (2014). <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+TDDclust">TDDclust</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>, <code><a href="#topic+archetypoids">archetypoids</a></code>, <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#kmeansProcrustes:
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 10 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)
#shapes::plotshapes(array3D[,,1]) 
#calibrate::textxy(array3D[,1,1], array3D[,2,1], labs = 1:numLandmarks, cex = 0.7) 

numClust &lt;- 2 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
resLL &lt;- LloydShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, FALSE)

prototypes &lt;- anthrCases(resLL)                                  
</code></pre>

<hr>
<h2 id='Anthropometry-internalArchetypoids'>
Several internal functions to compute and represent archetypes and archetypoids
</h2><span id='topic+ahull'></span><span id='topic+no.scalefn'></span><span id='topic+no.rescalefn'></span><span id='topic+.perc'></span><span id='topic+swap'></span><span id='topic+swap2'></span><span id='topic+swap2_k1'></span>

<h3>Description</h3>

<p>This file contains six extra functions. The <code>ahull</code> function is a helper function to calculate the approximated convex hull. The <code>no.scalefn</code> and <code>no.rescalefn</code> functions allow us to use the archetype algorithm without standardizing the data (see <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>). The other three functions are called by the archetypoid algorithm (<code><a href="#topic+archetypoids">archetypoids</a></code>). All these functions are therefore not solely used.
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Epifanio, I., Vinue,, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>, <code><a href="#topic+archetypoids">archetypoids</a></code>
</p>

<hr>
<h2 id='Anthropometry-internalHipamAnthropom'>
Several internal functions used by both $HIPAM_MO$ and $HIPAM_IMO$ algorithms
</h2><span id='topic+initialize.tree'></span><span id='topic+ext.dist'></span><span id='topic+pamsam'></span><span id='topic+initial.clustering'></span><span id='topic+cluster.search'></span><span id='topic+asw.calc'></span><span id='topic+further.clustering'></span><span id='topic+partition.cluster'></span><span id='topic+collapse.cluster'></span><span id='topic+collapse.step'></span><span id='topic+hipam.local'></span><span id='topic+update.tree.local'></span><span id='topic+full2dist'></span>

<h3>Description</h3>

<p>This file contains several functions called for both $HIPAM_MO$ and $HIPAM_IMO$ algorithms. Therefore, they are not used directly. 
</p>
<p>The $HIPAM_MO$ and $HIPAM_IMO$ algorithms are different in the way to generate and validate a clustering partition. However, the functions related to the further clustering steps are common to both of them. These functions are those collected in this file. 
</p>
<p>The <em>ext.dist</em> function is adapted to compute the dissimilarity developed in McCulloch et al. (1998). See <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> for a detailed explanation of the HIPAM algorithm.
</p>


<h3>Author(s)</h3>

<p>All these functions were originally created by E. Wit et al., and they are available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1.
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>
<p>McCulloch, C., Paal, B. and Ashdown, S., (1998). An optimization approach to apparel sizing, <em>Journal of the Operational Research Society</em> <b>49</b>, 492&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+getBestPamsamMO">getBestPamsamMO</a></code>, <code><a href="#topic+getBestPamsamIMO">getBestPamsamIMO</a></code>, <code><a href="#topic+checkBranchLocalMO">checkBranchLocalMO</a></code>, <code><a href="#topic+checkBranchLocalIMO">checkBranchLocalIMO</a></code>
</p>

<hr>
<h2 id='Anthropometry-internalPlotTree'>
Several internal functions used to build the HIPAM plot tree
</h2><span id='topic+make.circle.discovery'></span><span id='topic+make.arrow.circle'></span>

<h3>Description</h3>

<p>This file contains two subfunctions called by the <code><a href="#topic+plotTreeHipamAnthropom">plotTreeHipamAnthropom</a></code> function. Therefore, they are not used directly. These functions are the same as those called by the <em>plot.tree</em> function of the <span class="pkg">smida</span> R package (Wit et al. (2006)).
</p>


<h3>Author(s)</h3>

<p>All these functions were originally created by E. Wit et al., and they are available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1. <a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotTreeHipamAnthropom">plotTreeHipamAnthropom</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>

<hr>
<h2 id='Anthropometry-internalTDDclust'>
Several internal functions to clustering based on the L1 data depth
</h2><span id='topic+is.empty'></span><span id='topic+rowweight'></span><span id='topic+Distvec'></span><span id='topic+l1norm'></span><span id='topic+unitvec'></span><span id='topic+initW2'></span><span id='topic+Weisziteradj'></span><span id='topic+Weiszfeldadj'></span><span id='topic+DDapply'></span><span id='topic+DDfcnadj'></span><span id='topic+DDapplyloo'></span><span id='topic+DDcalc2'></span><span id='topic+pamsil'></span><span id='topic+NNDDVQA1'></span><span id='topic+NNDDVQE'></span><span id='topic+NNDDVQEstart'></span>

<h3>Description</h3>

<p>This file contains a large number of extra functions originally developed to execute the <em>DDclust</em> algorithm proposed by R. Jornsten in Jornsten (2004). <em>DDclust</em> is a method for clustering based on the L1 data depth. 
</p>
<p>Regarding the original functions, a stopping criterion and a trimmed procedure have been incorporated to <em>NNDDVQE</em> and <em>NNDDVQEstart</em>. The stopping criterion includes a tolerance which, if crossed, stops the iterations. The trimmed procedure allows us to discard the more extreme individuals (those with the lowest depth values). See <code><a href="#topic+TDDclust">TDDclust</a></code>. 
</p>
<p>All these functions are therefore not solely used.
</p>


<h3>Author(s)</h3>

<p>All these functions were originally created by R. Jornsten and they were available freely on
http://www.stat.rutgers.edu/home/rebecka/DDcl/. However, the link to this page doesn't currently exist as a result of a website redesign. 
</p>


<h3>References</h3>

<p>Jornsten R., (2004). Clustering and classification based on the L1 data depth, <em>Journal of Multivariate Analysis</em> <b>90</b>, 67&ndash;89
</p>
<p>Vinue, G., and Ibanez, M. V., (2014). <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TDDclust">TDDclust</a></code>
</p>

<hr>
<h2 id='Anthropometry-package'>
Statistical Methods for Anthropometric Data
</h2><span id='topic+Anthropometry-package'></span>

<h3>Description</h3>

<p>Statistical methodologies especially developed to analyze anthropometric data. These methods are aimed at providing effective solutions to some commons problems related to Ergonomics and Anthropometry. They are based on clustering, the statistical concept of data depth, statistical shape analysis and archetypal analysis. Please see Vinue (2017) &lt;doi:10.18637/jss.v077.i06&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: Anthropometry</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: 1.19</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: 2023-02-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>anthrCases: Helper generic function for obtaining the anthropometric cases.<br />
Anthropometry-internalArchetypoids: Several internal functions to compute and represent archetypes and archetypoids.<br />
Anthropometry-internalHipamAnthropom: Several internal functions used by both $HIPAM_MO$ and $HIPAM_IMO$ algorithms.<br />
Anthropometry-internalPlotTree: Several internal functions used to build the HIPAM plot tree.<br />
Anthropometry-internalTDDclust: Several internal functions to clustering based on the L1 data depth. <br />
archetypesBoundary: Archetypal analysis in multivariate accommodation problem.<br />
archetypoids: Finding archetypoids.<br />
array3Dlandm: Helper function for the 3D landmarks.<br />
bustSizesStandard: Helper function for defining the bust sizes.<br /> 
CCbiclustAnthropo: Cheng and Church biclustering algorithm applied to anthropometric data.<br />
cdfDissWomenPrototypes: CDF for the dissimilarities between women and computed medoids and standard prototypes.<br />
checkBranchLocalIMO: Evaluation of the candidate clustering partition in $HIPAM_IMO$.<br />
checkBranchLocalMO: Evaluation of the candidate clustering partition in $HIPAM_MO$.<br />
computSizesTrimowa: Computation of the trimowa elements for a given number of sizes defined by the EN.<br />
computSizesHipamAnthropom: Computation of the hipamAnthropom elements for a given number of sizes defined by the EN.<br />
cube8landm: Cube of 8 landmarks.<br /> 
cube34landm: Cube of 34 landmarks.<br />
descrDissTrunks: Description of the dissimilarities between women's trunks.<br />
figures8landm: Figures of 8 landmarks with labelled landmarks.<br />
getBestPamsamIMO: Generation of the candidate clustering partition in $HIPAM_IMO$. <br />
getBestPamsamMO: Generation of the candidate clustering partition in $HIPAM_MO$.<br />
getDistMatrix: Dissimilarity matrix between individuals and prototypes.<br />
HartiganShapes: Hartigan-Wong k-means for 3D shapes.<br />
hipamAnthropom: HIPAM algorithm for anthropometric data.<br />
landmarksSampleSpaSurv: Landmarks of the sampled women of the Spanish Survey.<br />
LloydShapes: Lloyd k-means for 3D shapes.<br />
nearestToArchetypes: Nearest individuals to archetypes.<br />
optraShapes: Auxiliary optra subroutine of the Hartigan-Wong k-means for 3D shapes.<br />
overlapBiclustersByRows: Overlapped biclusters by rows.<br />
parallelep8landm: Parallelepiped of 8 landmarks.<br />
parallelep34landm: Parallelepiped of 34 landmarks.<br />
percentilsArchetypoid: Helper function for computing percentiles of a certain archetypoid.<br />
plotPrototypes: Prototypes representation.<br />
plotTreeHipamAnthropom: HIPAM dendogram.<br />
plotTrimmOutl: Trimmed or outlier observations representation.<br />
preprocessing: Data preprocessing before computing archetypal observations.<br />
projShapes: Helper function for plotting the shapes.<br />
qtranShapes: Auxiliary qtran subroutine of the Hartigan-Wong k-means for 3D shapes.<br />
sampleSpanishSurvey: Sample database of the Spanish anthropometric survey.<br />
screeArchetypal: Screeplot of archetypal individuals.<br />
shapes3dShapes: 3D shapes plot.<br />
skeletonsArchetypal: Skeleton plot of archetypal individuals.<br />
stepArchetypesRawData: Archetype algorithm to raw data.<br />
stepArchetypoids: Run the archetypoid algorithm several times.<br />
TDDclust: Trimmed clustering based on L1 data depth.<br />
trimmedLloydShapes: Trimmed Lloyd k-means for 3D shapes.<br />
trimmedoid: Trimmed k-medoids algorithm.<br />
trimmOutl: Helper generic function for obtaining the trimmed and outlier observations.<br />
trimowa: Trimmed PAM with OWA operators.<br />
USAFSurvey: USAF 1967 survey.<br />
weightsMixtureUB: Calculation of the weights for the OWA operators.<br />
xyplotPCArchetypes: PC scores for archetypes.<br />
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue &lt;Guillermo.Vinue@uv.es&gt;, Irene Epifanio, Amelia Simo, M. Victoria Ibanez, Juan Domingo, Guillermo Ayala
</p>


<h3>References</h3>

<p>Vinue, G., (2017). Anthropometry: An R Package for Analysis of Anthropometric Data, <em>Journal of Statistical Software</em> <b>77(6)</b>, 1&ndash;39, doi: <a href="https://doi.org/10.18637/jss.v077.i06">10.18637/jss.v077.i06</a>.
</p>

<hr>
<h2 id='archetypesBoundary'>
Archetypal analysis in multivariate accommodation problem
</h2><span id='topic+archetypesBoundary'></span>

<h3>Description</h3>

<p>This function allows us to reproduce the results shown in section 2.2.2 and section 3.1 of Epifanio et al. (2013). In addition, from the results provided by this function, the other results shown in section 3.2 and section 3.3 of the same paper can be also reproduced (see section <em>examples</em> below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypesBoundary(data,numArch,verbose,numRep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypesBoundary_+3A_data">data</code></td>
<td>

<p>USAF 1967 database (see <code><a href="#topic+USAFSurvey">USAFSurvey</a></code>). Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="archetypesBoundary_+3A_numarch">numArch</code></td>
<td>

<p>Number of archetypes (archetypal observations).
</p>
</td></tr>
<tr><td><code id="archetypesBoundary_+3A_verbose">verbose</code></td>
<td>

<p>Logical value. If TRUE, some details of the execution progress are shown (this is the same argument as that of the <code>stepArchetypes</code> function of the <span class="pkg">archetypes</span> R package (Eugster (2009))).
</p>
</td></tr>
<tr><td><code id="archetypesBoundary_+3A_numrep">numRep</code></td>
<td>

<p>For each archetype run <code>archetypes</code> <code>numRep</code> times (this is the same argument as the <code>nrep</code> argument of the <code>stepArchetypes</code> function of <span class="pkg">archetypes</span>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before using this function, the more extreme (100 - <code>percAcomm</code>*100)% observations must be removed by means of the <code><a href="#topic+preprocessing">preprocessing</a></code> function. To that end, it is recommended that you use the Mahalanobis distance. In this case, the depth procedure has the disadvantage that the desired percentage of accommodation is not under control of the analyst and it may not exactly coincide with that one indicated.
</p>


<h3>Value</h3>

<p>A list with <code>numArch</code> elements. Each element is a list of class attribute <code>stepArchetypes</code> with <code>numRep</code> elements.
</p>


<h3>Note</h3>

<p>We would like to note that, some time after publishing the paper Epifanio et al. (2013), we found out that the <code>stepArchetypes</code> function standardizes the data by default (even when the data are already standardized) and this option is not always desired. In order to avoid this way of proceeding, we have created the <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code> function, which is used within <code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code> instead of using <code>stepArchetypes</code>. Therefore, the results provided by <code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code> allows us to reproduce the results of Epifanio et al. (2013) but they are now slightly different.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio and Guillermo Vinue
</p>


<h3>References</h3>

<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>
<p>Zehner, G. F., Meindl, R. S., and Hudson, J. A., (1993). A multivariate anthropometric method for crew station design: abridged. Tech. rep. Ohio: Human Engineering Division, Armstrong Laboratory, Wright-Patterson Air Force Base.
</p>


<h3>See Also</h3>

<p><code>archetypes</code>, <code>stepArchetypes</code>, <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>, <code><a href="#topic+USAFSurvey">USAFSurvey</a></code>, <code><a href="#topic+nearestToArchetypes">nearestToArchetypes</a></code>, <code><a href="#topic+preprocessing">preprocessing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The following R code allows us to reproduce the results of the paper Epifanio et al. (2013).
#As a toy example, only the first 25 individuals are used.
#First,the USAF 1967 database is read and preprocessed (Zehner et al. (1993)).
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_inch &lt;- USAFSurvey[1:25, variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_inch, TRUE, 0.95, TRUE)

#Procedure and results shown in section 2.2.2 and section 3.1:
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010)
res &lt;- archetypesBoundary(USAFSurvey_preproc$data, 15, FALSE, 3)
#To understand the warning messages, see the vignette of the
#archetypes package.

#Results shown in section 3.2 (figure 3):
screeplot(res) 

#3 archetypes:
a3 &lt;- archetypes::bestModel(res[[3]])
archetypes::parameters(a3)
#7 archetypes:
a7 &lt;- archetypes::bestModel(res[[7]])
archetypes::parameters(a7) 
#Plotting the percentiles of each archetype:
#Figure 2 (b):
barplot(a3,USAFSurvey_preproc$data, percentiles = TRUE, which = "beside") 
#Figure 2 (f):
barplot(a7,USAFSurvey_preproc$data, percentiles = TRUE, which = "beside")

#Results shown in section 3.3 related with PCA.
pznueva &lt;- prcomp(USAFSurvey_preproc$data, scale = TRUE, retx = TRUE) 
#Table 3:
summary(pznueva)
pznueva
#PCA scores for 3 archetypes:
p3 &lt;- predict(pznueva,archetypes::parameters(a3)) 
#PCA scores for 7 archetypes:
p7 &lt;- predict(pznueva,archetypes::parameters(a7))
#Representing the scores:
#Figure 4 (a):
xyplotPCArchetypes(p3[,1:2], pznueva$x[,1:2], data.col = gray(0.7), atypes.col = 1, 
                   atypes.pch = 15)
#Figure 4 (b):
xyplotPCArchetypes(p7[,1:2], pznueva$x[,1:2], data.col = gray(0.7), atypes.col = 1, 
                   atypes.pch = 15)

#Percentiles for 7 archetypes (table 5):
Fn &lt;- ecdf(USAFSurvey_preproc$data)
round(Fn(archetypes::parameters(a7)) * 100)

#Which are the nearest individuals to archetypes?:
#Example for three archetypes:
ras &lt;- rbind(archetypes::parameters(a3),USAFSurvey_preproc$data)
dras &lt;- dist(ras,method = "euclidean", diag = FALSE, upper = TRUE, p = 2)
mdras &lt;- as.matrix(dras)
diag(mdras) = 1e+11
numArch &lt;- 3
sapply(seq(length=numArch),nearestToArchetypes,numArch,mdras) 

#In addition, we can turn the standardized values to the original variables.
p &lt;- archetypes::parameters(a7)
m &lt;- sapply(USAFSurvey_inch,mean)
s &lt;- sapply(USAFSurvey_inch,sd)
d &lt;- p
for(i in 1 : 6){
 d[,i] = p[,i] * s[i] + m[i]
}
#Table 7:
t(d)
</code></pre>

<hr>
<h2 id='archetypoids'>
Finding archetypoids
</h2><span id='topic+archetypoids'></span>

<h3>Description</h3>

<p>Archetypoid algorithm. It is based on the PAM clustering algorithm. It is made up of two phases (a BUILD phase and a SWAP phase). In the BUILD phase, an initial set of archetypoids is determined. Unlike PAM, this collection is not derived in a stepwise format. Instead, it is suggested you choose the set made up of the nearest individuals returned by the <code>archetypes</code> function of the <span class="pkg">archetypes</span> R package (Eugster et al. (2009)). This set can be defined in three different ways, see next section <em>arguments</em>. The goal of the SWAP step is the same as that of the SWAP step of PAM, but changing the objective function. The initial vector of archetypoids is attempted to be improved. This is done by exchanging selected individuals for unselected individuals and by checking whether these replacements reduce the objective function of the archetypoid analysis problem. 
</p>
<p>All details are given in Vinue et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archetypoids(numArchoid,data,huge=200,step,init,ArchObj,nearest="cand_ns",sequ,aux)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archetypoids_+3A_numarchoid">numArchoid</code></td>
<td>

<p>Number of archetypoids (archetypal observations).
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_data">data</code></td>
<td>

<p>Data matrix. Each row corresponds to an observation and each column corresponds to an anthropometric variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_huge">huge</code></td>
<td>

<p>This is a penalization added to solve the convex least squares problems regarding the minimization problem to estimate archetypoids, see Eugster et al. (2009). Default value is 200.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_step">step</code></td>
<td>

<p>Logical value. If TRUE, the archetypoid algorithm is executed repeatedly within <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>. Therefore, this function requires the next argument <code>init</code> (but neither the <code>ArchObj</code> nor the <code>nearest</code> arguments) that specifies the initial vector of archetypoids, which has already been computed within <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>. If FALSE, the archetypoid algorithm is executed once. In this case, the <code>ArchObj</code> and <code>nearest</code> arguments are required to compute the initial vector of archetypoids.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_init">init</code></td>
<td>

<p>Initial vector of archetypoids for the BUILD phase of the archetypoid algorithm. It is computed within <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>. See <code>nearest</code> argument below for an explanation of how this vector is calculated.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_archobj">ArchObj</code></td>
<td>

<p>The list object returned by the <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code> function. This function is a slight modification of the original <code>stepArchetypes</code> function of <span class="pkg">archetypes</span> to apply the archetype algorithm to raw data. The <code>stepArchetypes</code> function standardizes the data by default and this option is not always desired. This list is needed to compute the nearest individuals to archetypes. Required when <code>step=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_nearest">nearest</code></td>
<td>

<p>Initial vector of archetypoids for the BUILD phase of the archetypoid algorithm. Required when <code>step=FALSE</code>. This initial vector contain the nearest individuals to the archetypes returned by the <code>archetypes</code> function of <span class="pkg">archetypes</span> (In Vinue et al. (2015), archetypes are computed after running the archetype algorithm twenty times). This argument is a string vector with three different possibilities. The first and default option is &quot;cand_ns&quot; and allows us to calculate the nearest individuals by computing the Euclidean distance between the archetypes and the individuals and choosing the nearest. It is used in Epifanio et al. (2013). The second option is &quot;cand_alpha&quot; and allows us to calculate the nearest individuals by consecutively identifying the individual with the maximum value of alpha for each archetype, until the defined number of archetypes is reached. It is used in Eugster (2012). The third and final option is &quot;cand_beta&quot; and allows us to calculate the nearest individuals by identifying the individuals with the maximum beta value for each archetype, i.e. the major contributors in the generation of the archetypes.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_sequ">sequ</code></td>
<td>

<p>Logical value. It indicates whether a sequence of archetypoids (TRUE) or only a single number of them (FALSE) is computed. It is determined by the number of archetypes computed by means of <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>.
</p>
</td></tr>
<tr><td><code id="archetypoids_+3A_aux">aux</code></td>
<td>

<p>If <code>sequ</code>=FALSE, this value is equal to <code>numArchoid</code>-1 since for a single number of archetypoids, the list associated with the archetype object only has one element.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As mentioned, this algorithm is based on PAM. These types of algorithms aim to find good solutions in a short period of time, although not necessarily the best solution. Otherwise, the global minimum solution may always be obtained using as much time as it would be necessary, but this would be very inefficient computationally.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>cases</em>: Anthropometric cases (final vector of <code>numArchoid</code> archetypoids).
</p>
<p><em>rss</em>: Residual sum of squares corresponding to the final vector of <code>numArchoid</code> archetypoids.
</p>
<p><em>archet_ini</em>: Vector of initial archetypoids (<em>cand_ns</em>, <em>cand_alpha</em> or <em>cand_beta</em>).
</p>
<p><em>alphas</em>: Alpha coefficients for the optimal vector of archetypoids.
</p>


<h3>Note</h3>

<p>It may be happen that <code>archetypes</code> does not find results for <code>numArchoid</code> archetypes. In this case, it is not possible to calculate the vector of nearest individuals and consequently, the vector of archetypoids. Therefore, this function will return an error message. 
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio and Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Cutler, A., and Breiman, L., (1994). Archetypal Analysis, <em>Technometrics</em> <b>36</b>, 338&ndash;347.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>
<p>Eugster, M. J. A., (2012). Performance profiles based on archetypal athletes, <em>International Journal of Performance Analysis in Sport</em> <b>12</b>, 166&ndash;187.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code>, <code>archetypes</code>, <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Note: For a sportive example, see www.uv.es/vivigui/softw/more_examples.R 

#COCKPIT DESIGN PROBLEM:
#As a toy example, only the first 25 individuals are used.
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 5 ; numRep &lt;- 2
lass &lt;- stepArchetypesRawData(data = USAFSurvey_preproc$data, numArch = 1:numArch,
                              numRep = numRep, verbose = FALSE)  
#To understand the warning messages, see the vignette of the
#archetypes package.                              

#screeplot(lass)

numArchoid &lt;- 3 #number of archetypoids.
res_ns &lt;- archetypoids(numArchoid, USAFSurvey_preproc$data, huge = 200, step = FALSE,
                       ArchObj = lass, nearest = "cand_ns",sequ = TRUE)
</code></pre>

<hr>
<h2 id='array3Dlandm'>
Helper function for the 3D landmarks
</h2><span id='topic+array3Dlandm'></span>

<h3>Description</h3>

<p>This is a helper function for obtaining the array with the 3D landmarks of the sample objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array3Dlandm(numLandm,numIndiv,matLandm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array3Dlandm_+3A_numlandm">numLandm</code></td>
<td>

<p>Number of landmarks that represent the 3D body of the individuals.
</p>
</td></tr>
<tr><td><code id="array3Dlandm_+3A_numindiv">numIndiv</code></td>
<td>

<p>Number of individuals to analyze.
</p>
</td></tr>
<tr><td><code id="array3Dlandm_+3A_matlandm">matLandm</code></td>
<td>

<p>Matrix with the <code>numLandm</code> landmarks for the <code>numIndiv</code> individuals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with the 3D landmarks of the sample objects.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
landmarksNoNa_First50 &lt;- landmarksNoNa[1:50, ]
numIndiv &lt;- dim(landmarksNoNa_First50)[1]

array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First50)
</code></pre>

<hr>
<h2 id='bustSizesStandard'>
Helper function for defining the bust sizes 
</h2><span id='topic+bustSizesStandard'></span>

<h3>Description</h3>

<p>This is a helper function for defining the twelve bust sizes (from 74 cm to 131 cm) according to the sizes proposed in the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bustSizesStandard(bustCirc_4, bustCirc_6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bustSizesStandard_+3A_bustcirc_4">bustCirc_4</code></td>
<td>

<p>Sequence of measurements from 74 to 102 in groups of four.
</p>
</td></tr>
<tr><td><code id="bustSizesStandard_+3A_bustcirc_6">bustCirc_6</code></td>
<td>

<p>Sequence of measurements from 107 to 131 in groups of six.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>bustCirc</em>: Vector of the twelve bust sizes.
</p>
<p><em>nsizes</em>: Number of bust sizes (twelve).
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>
<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))
</code></pre>

<hr>
<h2 id='CCbiclustAnthropo'>
Cheng and Church biclustering algorithm applied to anthropometric data
</h2><span id='topic+CCbiclustAnthropo'></span>

<h3>Description</h3>

<p>This function is the implementation in R of the algorithm that uses the Cheng and Church biclustering method (from now on, CC) to find size groups (biclusters) and disaccommodated individuals.
</p>
<p>Designing lower body garments depends not only on the waist circumference (the principal dimension in this case), but also on other secondary control dimensions (for upper body garments the bust circumference is usually required only). Biclustering identifies groups of observations with a similar pattern in a subset of attributes instead of in the whole of them. Therefore, it seems to be more interesting to use a biclustering algorithm with a set of lower body variables. 
</p>
<p>In Vinue et al. (2014), the way of proceeding was as follows: first, all the body variables related to the lower body part included in the Spanish anthropometric survey were chosen (there were 36). Second, the data set was divided into twelve segments (classes) using waist circumference values according to the European standard. Part 3: Measurements and intervals. Finally, the CC algorithm was applied to each waist class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCbiclustAnthropo(data,waistVariable,waistCirc,lowerVar,
                  nsizes,nBic,diffRanges,percDisac,dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCbiclustAnthropo_+3A_data">data</code></td>
<td>

<p>Data matrix. Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_waistvariable">waistVariable</code></td>
<td>

<p>Vector containing the waist values of the individuals.
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_waistcirc">waistCirc</code></td>
<td>

<p><code>data</code> is segmented into twelve waist classes. This vector contains the waist values to define each one of the twelve classes.  
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_lowervar">lowerVar</code></td>
<td>

<p>Lower body dimensions.
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of waist sizes.
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_nbic">nBic</code></td>
<td>

<p>Maximum number of biclusters to be found in each waist size. 
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_diffranges">diffRanges</code></td>
<td>

<p>List with <code>nsizes</code> elements. Each element is a vector whose extremes indicate the acceptable boundaries for selecting variables with a similar scale. This is needed because CC may be very influenced in case of variables involved in the study are on very different scales. 
</p>
</td></tr>  
<tr><td><code id="CCbiclustAnthropo_+3A_percdisac">percDisac</code></td>
<td>

<p>Proportion of no accommodated sample. 
</p>
</td></tr>
<tr><td><code id="CCbiclustAnthropo_+3A_dir">dir</code></td>
<td>

<p>Working directory where to save the results.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interesting results in terms of apparel design were found: an efficient partition into different biclusters was obtained. All individuals in the same bicluster can wear a garment designed for the particular body dimensions (waist and other variables) which were the most relevant for defining the group. Each group is represented by the median woman. Because the CC algorithm is nonexhaustive, i.e, some rows (and columns) do not belong to any bicluster, this property can be used to fix a proportion of no accommodated sample.
</p>
<p>This approach was descriptive and exploratory. It is emphasized that this function cannot be used with <code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, because this data file does not contain variables related to the lower body part in addition to waist and hip. However, this function is included in the package in the hope that it could be helpful or useful for other researchers. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>res</em>: List with <code>nsizes</code> elements. Each element contains the biclustering results for each waist segment.
</p>
<p><em>dims</em>: List with <code>nsizes</code> elements. Each element contains the number of variables with a similar scale in each waist segment.
</p>
<p><em>delta</em>: List with <code>nsizes</code> elements. Each element contains the delta parameter of the CC algorithm for each waist segment. 
</p>
<p><em>disac</em>: List with <code>nsizes</code> elements. Each element contains the number of women who not belong to any bicluster for each waist segment.
</p>
<p><em>mat</em>: List with <code>nsizes</code> elements. Each element contains the matrix showing which rows belong to each bicluster for each waist segment. This matrix allow us to know whether there are rows that belong to more than one bicluster, that is to say, whether there are overlapping biclusters. This is very important in our application because each individual must be assigned to a single size. See the <em>Note</em> section.
</p>
<p><em>tab_acc</em>: List with <code>nsizes</code> elements. Each element is a list with four elements. The first component indicates how many individuals belong to a single bicluster and how many do not belong to any bicluster. The second component refers to the number of biclusters found in each segment. The third one indicates the number of women that belong to each waist segment. The fourth one coincides with the <em>disac</em> element.
</p>
<p><em>ColBics</em>: List with <code>nsizes</code> elements. Each element contains the variables that belong to each bicluster for each waist segment.
</p>


<h3>Note</h3>

<p>In order to know whether a row belongs to more than one bicluster, we count the number of 0s in each row of the <em>mat</em> matrix returned by this function (see the <em>Value</em> section). 
</p>
<p>In case of there are res@Number - 1 0s in each row of <em>mat</em>, then each row belongs to only one bicluster. The <em>mat</em> matrix indicates with an 1 the rows that make up of the bicluster 1, with a 2 those rows that make up of the bicluster 2 and so on. In addition, it indicates with a 0 the rows that do not belong to any bicluster. Therefore, in order to check overlapping, every row must have a number of 0s equal to the total number of biclusters minus one. This one will indicate that that row belongs to a single bicluster. Otherwise, every row must have a number of 0s equal to the total number of biclusters. In this case, that row does not belong to any bicluster.  
</p>
<p>For instance, if we find two biclusters, there should be one or two 0s in each row in case of no overlapping.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., and Ibanez, M. V., (2014), <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>
<p>Cheng, Y., and Church, G., (2000). Biclustering of expression data. <em>Proceedings of the Eighth International Conference on Intelligent Systems for Molecular Biology</em> <b>8</b>, 93&ndash;103.
</p>
<p>Kaiser, S., and Leisch, F., (2008). A Toolbox for Bicluster Analysis in R. Tech.rep., Department of Statistics (University of Munich).
</p>
<p>Alemany, S., Gonzalez, J. C., Nacher, B., Soriano, C., Arnaiz, C., and Heras, H., (2010). Anthropometric survey of the Spanish female population aimed at the apparel industry. <em>Proceedings of the 2010 Intl. Conference on 3D Body scanning Technologies</em>, 307&ndash;315.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 2: Primary and secondary dimensions. (2002).
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlapBiclustersByRows">overlapBiclustersByRows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Note: package biclust needed.
#This is an example of using this function with a certain database 
#made up of body dimensions related to the lower body part.
data &lt;- dataUser[(waist &gt;= 58) &amp; (waist &lt; 115),] #dataUser is the user database.
rownames(data) &lt;- 1:dim(data)[1]
  
waist &lt;- data[,"WaistCircumference"] 
    
waist_4 &lt;- seq(58, 86, 4) 
waist_6 &lt;- seq(91, 115, 6) 
waistCirc &lt;- c(waist_4,waist_6)
nsizes &lt;- length(waistCirc) 

#Position of the body variables in the database:
lowerVars &lt;- c(14, 17:25, 27, 28, 65:73, 75, 77:81, seq(100, 116, 2))

nBic &lt;- c(2, 2, 4, rep(5, 7), 3, 3)  
diffRanges &lt;- list(c(14,20), c(24,30), c(24,30), c(33,39), c(29,35), c(29,35), 
                   c(28,35), c(31,38), c(31,38), c(30,37), c(26,33), c(25,32))
percDisac &lt;- 0.01 
dir &lt;- "/home/guillermo/"
  
res_bicl_antropom &lt;- CCbiclustAnthropo(data,waist,waistCirc,lowerVars,
                                       nsizes,nBic,diffRanges,percDisac,dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdfDissWomenPrototypes'>
CDF for the dissimilarities between women and computed medoids and standard prototypes
</h2><span id='topic+cdfDissWomenPrototypes'></span>

<h3>Description</h3>

<p>This function allows us to calculate the Cumulative Distribution Functions for the dissimilarities between all the women and the medoids obtained with the <code><a href="#topic+trimowa">trimowa</a></code> algorithm and for the dissimilarities between all the women and the standard prototypes defined by the European standard. Part 3: Measurements and intervals. In both cases, the dissimilarities have been computed by using the dissimilarity function obtained with <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. 
</p>
<p>These types of plots can also be used to identify the expected range of the dissimilarities, that is to say, the values between the 10 and 90th percentiles. 
</p>
<p>This function was used to obtain the Fig. 11 of Ibanez et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdfDissWomenPrototypes(min_med,min_med_UNE,main,xlab,ylab,leg,cexLeg,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdfDissWomenPrototypes_+3A_min_med">min_med</code></td>
<td>

<p>Vector with the dissimilarities between all the women and the prototypes (medoids) obtained with <code><a href="#topic+trimowa">trimowa</a></code>.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_min_med_une">min_med_UNE</code></td>
<td>

<p>Vector with the dissimilarities between all the women and the standard prototypes.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_main">main</code></td>
<td>

<p>A title for the plot.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_xlab">xlab</code></td>
<td>

<p>A title for the x axis.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_ylab">ylab</code></td>
<td>

<p>A title for the y axis.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_leg">leg</code></td>
<td>

<p>A character vector to appear in the legend.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_cexleg">cexLeg</code></td>
<td>

<p>Character expansion for the legend.
</p>
</td></tr>
<tr><td><code id="cdfDissWomenPrototypes_+3A_...">...</code></td>
<td>

<p>Further graphical parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>, <code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Loading the data to apply the trimowa algorithm:
dataTrimowa &lt;- sampleSpanishSurvey
dim(dataTrimowa)
#[1] 600   5
numVar &lt;- dim(dataTrimowa)[2]
bust &lt;- dataTrimowa$bust
chest &lt;- dataTrimowa$chest
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness,numVar)

numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
#numSizes &lt;- bustSizes$nsizes - 1
numSizes &lt;- 2
res_trimowa &lt;- computSizesTrimowa(dataTrimowa, bust, bustSizes$bustCirc, numSizes,
                                  weightsTrimowa, numClust, alpha, niter, algSteps, 
                                  ah, FALSE)                           

#Prototypes obtained with the trimowa algorithm:
prototypes &lt;- anthrCases(res_trimowa, numSizes)
#length(unlist(prototypes)) is (numSizes - 1) * numClust
meds &lt;- dataTrimowa[unlist(prototypes),]

regr &lt;- lm(chest ~ bust)

#Prototypes defined by the European standard:
hip_UNE &lt;- c(seq(84,112,4), seq(117,132,5))          ; hip &lt;- rep(hip_UNE,3)
waist_UNE &lt;- c(seq(60,88,4), seq(94,112,6))          ; waist &lt;- rep(waist_UNE,3)
bust_UNE &lt;- c(seq(76,104,4), seq(110,128,6))         ; bust &lt;- rep(bust_UNE,3)
chest_UNE &lt;- predict(regr, list(bust=bust_UNE))      ; chest &lt;- rep(chest_UNE,3)
necktoground &lt;- c(rep(130,12), rep(134,12),rep(138,12))

medsUNE &lt;- data.frame(chest, necktoground, waist, hip, bust) 
dim(medsUNE)
#[1] 36  5

dataAll &lt;- rbind(dataTrimowa, meds, medsUNE)
dim(dataAll)
#[1] 642   5

bh &lt;- (apply(as.matrix(log(dataAll)),2,range)[2,] 
       - apply(as.matrix(log(dataAll)),2,range)[1,]) / ((numClust-1) * 8) 
bl &lt;- -3 * bh
ah &lt;- c(28,20,30,25,23)
al &lt;- 3 * ah
num.persons &lt;- dim(dataAll)[1]
dataAllm &lt;- as.matrix(dataAll)
dataAllt &lt;- aperm(dataAllm, c(2,1))    
dim(dataAllt) &lt;- c(1,num.persons * numVar)  
rm(dataAllm)
D &lt;- getDistMatrix(dataAllt, num.persons, numVar, weightsTrimowa, bl, bh, al, ah, FALSE)

sequen &lt;- (dim(dataTrimowa)[1] + 1) : (dim(dataTrimowa)[1] + length(unlist(prototypes)))
f &lt;- function(i, D){
 r &lt;- min(D[i, sequen])
}
min_med &lt;- sapply(1:dim(dataTrimowa)[1], f, D) 

sequen1 &lt;- (dim(dataTrimowa)[1] + length(unlist(prototypes)) + 1) : dim(D)[1]
f1 &lt;- function(i, D){
 r &lt;- min(D[i, 619:636])
}
min_med_UNE &lt;- sapply(1:dim(dataTrimowa)[1], f1, D)

#CDF plot:
main &lt;- "Comparison between sizing methods"
xlab &lt;- "Dissimilarity"
ylab &lt;- "Cumulative distribution function"
leg &lt;- c("Dissimilarity between women and computed medoids", 
         "Dissimilarity between women and standard prototypes")
cdfDissWomenPrototypes(min_med, min_med_UNE, main, xlab, ylab, leg,cexLeg = 0.7)
</code></pre>

<hr>
<h2 id='checkBranchLocalIMO'>
Evaluation of the candidate clustering partition in $HIPAM_IMO$
</h2><span id='topic+checkBranchLocalIMO'></span>

<h3>Description</h3>

<p>In the HIPAM algorithm, each (parent) cluster P is investigated to see if it can be divided further into new (child) clusters, or stop (in this case, P would be a terminal node). 
</p>
<p>In this version of HIPAM, called $HIPAM_IMO$, there are three different stopping criteria: First, if $|P| leq 2$, then P is a terminal node. If not, the second stopping refers to the INCA (Index Number Clusters Atypical) criterion (Irigoien et al. (2008)): if $INCA_k leq 0.2$ for all k, then P is a terminal node. Finally, the third stopping criteria uses the Mean Split Silhouette. See Vinue et al. (2014) for more details.
</p>
<p>The foundation and performance of the HIPAM algorithm is explained in <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBranchLocalIMO(tree,data,i,maxsplit,asw.tol,local.const,orness,type,ah,
                    verbose,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkBranchLocalIMO_+3A_tree">tree</code></td>
<td>

<p>The clustering tree being defined.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_data">data</code></td>
<td>

<p>Data to be clustered.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_i">i</code></td>
<td>

<p>A specific cluster of the clustering partition in a certain level of the tree.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_maxsplit">maxsplit</code></td>
<td>

<p>The maximum number of clusters that any cluster can be divided when searching for the best clustering.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_asw.tol">asw.tol</code></td>
<td>

<p>If this value is given, a tolerance or penalty can be introduced (asw.tol &gt; 0 or asw.tol &lt; 0, respectively) in the branch splitting procedure. Default value (0) is maintained. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_local.const">local.const</code></td>
<td>

<p>If this value is given (meaningful values are those between -1 and 1), a proposed partition is accepted only if the associated asw is greater than this constant. Default option for this argument is maintained, that is to say, this value is ignored. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation. See <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code> and <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_type">type</code></td>
<td>

<p>Option 'IMO' for using $HIPAM_IMO$.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalIMO_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new resulting classification tree.
</p>


<h3>Note</h3>

<p>This function belongs to the $HIPAM_IMO$ algorithm and it is not solely used. That is why there is no section of <em>examples</em> in this help page. See <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally created by E. Wit et al., and it is available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>. We have adapted it to incorporate the second stopping criterion related to INCA. 
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1.
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>
<p>Pollard, K. S., and van der Laan, M. J., (2002). A method to identify significant clusters in gene expression data. <em>Vol. II of SCI2002 Proceedings</em>, 318&ndash;325.
</p>
<p>Irigoien, I., and Arenas, C., (2008). INCA: New statistic for estimating the number of clusters and identifying atypical units, <em>Statistics in Medicine</em> <b>27</b>, 2948&ndash;2973.
</p>
<p>Irigoien, I., Sierra, B., and Arenas, C., (2012). ICGE: an R package for detecting relevant clusters and atypical units in gene expression, <em>BMC Bioinformatics</em> <b>13</b> 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>

<hr>
<h2 id='checkBranchLocalMO'>
Evaluation of the candidate clustering partition in $HIPAM_MO$
</h2><span id='topic+checkBranchLocalMO'></span>

<h3>Description</h3>

<p>In the HIPAM algorithm, each (parent) cluster P is investigated to see if it can be divided further into new (child) clusters, or stop (in this case, P would be a terminal node). 
</p>
<p>In this version of HIPAM, called $HIPAM_MO$, there are two different stopping criteria: First, if $|P| leq 2$, then P is a terminal node. If not, the second stopping criteria uses the Mean Split Silhouette. See Vinue et al. (2014) for more details.
</p>
<p>The foundation and performance of the HIPAM algorithm is explained in <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBranchLocalMO(tree,data,i,maxsplit,asw.tol,local.const,orness,type,ah,
                   verbose,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkBranchLocalMO_+3A_tree">tree</code></td>
<td>

<p>The clustering tree being defined.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_data">data</code></td>
<td>

<p>Data to be clustered.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_i">i</code></td>
<td>

<p>A specific cluster of the clustering partition in a certain level of the tree.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_maxsplit">maxsplit</code></td>
<td>

<p>The maximum number of clusters that any cluster can be divided when searching for the best clustering.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_asw.tol">asw.tol</code></td>
<td>

<p>If this value is given, a tolerance or penalty can be introduced (asw.tol &gt; 0 or asw.tol &lt; 0, respectively) in the branch splitting procedure. Default value (0) is maintained. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_local.const">local.const</code></td>
<td>

<p>If this value is given (meaningful values are those between -1 and 1), a proposed partition is accepted only if the associated asw is greater than this constant. Default option for this argument is maintained, that is to say, this value is ignored. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation. See <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code> and <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_type">type</code></td>
<td>

<p>Option 'MO' for using $HIPAM_MO$.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
<tr><td><code id="checkBranchLocalMO_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new resulting classification tree.
</p>


<h3>Note</h3>

<p>This function belongs to the $HIPAM_MO$ algorithm and it is not solely used. That is why there is no section of <em>examples</em> in this help page. See <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally created by E. Wit et al., and it is available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1.
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>
</p>
<p>Pollard, K. S., and van der Laan, M. J., (2002). A method to identify significant clusters in gene expression data. <em>Vol. II of SCI2002 Proceedings</em>, 318&ndash;325.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>

<hr>
<h2 id='computSizesHipamAnthropom'>
Computation of the hipamAnthropom elements for a given number of sizes defined by the EN
</h2><span id='topic+computSizesHipamAnthropom'></span>

<h3>Description</h3>

<p>This is a helper function for computing the hipamAnthropom elements provided by the <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> algorithm for a number of bust sizes defined by the European Normative (EN). Therefore, the <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> is used inside this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computSizesHipamAnthropom(dataHip, bust, bustMeasur, nsizes, maxsplit, orness, 
                          type, ah, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computSizesHipamAnthropom_+3A_datahip">dataHip</code></td>
<td>

<p>Data frame.
</p>
</td></tr>
<tr><td><code id="computSizesHipamAnthropom_+3A_bust">bust</code></td>
<td>

<p>Bust column of the data frame.
</p>
</td></tr>
<tr><td><code id="computSizesHipamAnthropom_+3A_bustmeasur">bustMeasur</code></td>
<td>

<p>Sequence vector of bust measurements (bust sizes) provided by the <code><a href="#topic+bustSizesStandard">bustSizesStandard</a></code> function.
</p>
</td></tr>
<tr><td><code id="computSizesHipamAnthropom_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of sizes defined by the European Normative to apply the <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> function.
</p>
</td></tr>
<tr><td><code id="computSizesHipamAnthropom_+3A_maxsplit">maxsplit</code>, <code id="computSizesHipamAnthropom_+3A_orness">orness</code>, <code id="computSizesHipamAnthropom_+3A_type">type</code>, <code id="computSizesHipamAnthropom_+3A_ah">ah</code>, <code id="computSizesHipamAnthropom_+3A_verbose">verbose</code></td>
<td>

<p>Same arguments as those of the <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same elements as the <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+bustSizesStandard">bustSizesStandard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataHipam &lt;- sampleSpanishSurvey
bust &lt;- dataHipam$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

type &lt;- "IMO"
maxsplit &lt;- 5 ; orness &lt;- 0.7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
numSizes &lt;- 1
res_hipam &lt;- computSizesHipamAnthropom(dataHipam, bust, bustSizes$bustCirc, numSizes,
                                       maxsplit, orness, type, ah, FALSE)
</code></pre>

<hr>
<h2 id='computSizesTrimowa'>
Computation of the trimowa elements for a given number of sizes defined by the EN
</h2><span id='topic+computSizesTrimowa'></span>

<h3>Description</h3>

<p>This is a helper function for computing the trimowa elements provided by the <code><a href="#topic+trimowa">trimowa</a></code> algorithm for a number of bust sizes defined by the European Normative (EN). Therefore, the <code><a href="#topic+trimowa">trimowa</a></code> is used inside this function. The number of sizes
must be bigger than one. For a single size use directly <code><a href="#topic+trimowa">trimowa</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computSizesTrimowa(dataTrim, bust, bustMeasur, nsizes, w, numClust, alpha, 
                   niter, algSteps, ah, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computSizesTrimowa_+3A_datatrim">dataTrim</code></td>
<td>

<p>Data frame.
</p>
</td></tr>
<tr><td><code id="computSizesTrimowa_+3A_bust">bust</code></td>
<td>

<p>Bust column of the data frame.
</p>
</td></tr>
<tr><td><code id="computSizesTrimowa_+3A_bustmeasur">bustMeasur</code></td>
<td>

<p>Sequence vector of bust measurements (bust sizes) provided by the <code><a href="#topic+bustSizesStandard">bustSizesStandard</a></code> function.
</p>
</td></tr>
<tr><td><code id="computSizesTrimowa_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of sizes defined by the European Normative to apply the <code><a href="#topic+trimowa">trimowa</a></code> function.
</p>
</td></tr>
<tr><td><code id="computSizesTrimowa_+3A_w">w</code>, <code id="computSizesTrimowa_+3A_numclust">numClust</code>, <code id="computSizesTrimowa_+3A_alpha">alpha</code>, <code id="computSizesTrimowa_+3A_niter">niter</code>, <code id="computSizesTrimowa_+3A_algsteps">algSteps</code>, <code id="computSizesTrimowa_+3A_ah">ah</code>, <code id="computSizesTrimowa_+3A_verbose">verbose</code></td>
<td>

<p>Same arguments as those of the <code><a href="#topic+trimowa">trimowa</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same elements as the <code><a href="#topic+trimowa">trimowa</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>
<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+bustSizesStandard">bustSizesStandard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataTrimowa &lt;- sampleSpanishSurvey
numVar &lt;- dim(dataTrimowa)[2]
bust &lt;- dataTrimowa$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness, numVar)

numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
numSizes &lt;- 2
res_trimowa &lt;- computSizesTrimowa(dataTrimowa, bust, bustSizes$bustCirc, numSizes,
                                  weightsTrimowa, numClust, alpha, niter,
                                  algSteps, ah, verbose = FALSE)
</code></pre>

<hr>
<h2 id='cube34landm'>
Cube of 34 landmarks
</h2><span id='topic+cube34landm'></span>

<h3>Description</h3>

<p>This is a cube made up of 34 landmarks, used as controlled data in the simulation study carried out in the paper referred below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube34landm</code></pre>


<h3>Format</h3>

<p>An array with one matrix of 34 rows and 3 columns.</p>


<h3>Source</h3>

<p>Software Rhinoceros.</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>

<hr>
<h2 id='cube8landm'>
Cube of 8 landmarks
</h2><span id='topic+cube8landm'></span>

<h3>Description</h3>

<p>This is a cube made up of 8 landmarks, used as controlled data in the simulation study carried out in the paper referred below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube8landm</code></pre>


<h3>Format</h3>

<p>An array with one matrix of 8 rows and 3 columns.</p>


<h3>Source</h3>

<p>Software Rhinoceros.</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>

<hr>
<h2 id='descrDissTrunks'>
Description of the dissimilarities between women's trunks
</h2><span id='topic+descrDissTrunks'></span>

<h3>Description</h3>

<p>Unlike archetypes, archetypoids can be computed when features are unavailable. Given a dissimilarity matrix, the classical multidimensional scaling (cMDS) can be applied to obtain a description of the dissimilarities. 
</p>
<p>In Vinue et al. (2015), the dissimilarity matrix represents the dissimilarities between women's trunks. After applying the cMDS, the database described here is obtained. Then, the archetypoid algorithm can be applied to this database, see section <em>examples</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descrDissTrunks</code></pre>


<h3>Format</h3>

<p>A matrix with 470 rows and 4 columns.</p>


<h3>Source</h3>

<p>Anthropometric survey of the Spanish female population.</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Alemany, S., Gonzalez, J. C., Nacher, B., Soriano, C., Arnaiz, C., and Heras, H., (2010). Anthropometric survey of the Spanish female population aimed at the apparel industry. <em>Proceedings of the 2010 Intl. Conference on 3D Body scanning Technologies</em>, 307&ndash;315.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Database:
#As a toy example, only the first 25 individuals are used.
X &lt;- descrDissTrunks[1:25,]
X &lt;- as.matrix(X) 

#Computation of archetypes and archetypoids:
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 5 ; nrep &lt;- 2
lass &lt;- stepArchetypesRawData(data = X, numArch = 1:numArch, numRep = nrep, verbose = FALSE)
#To understand the warning messages, see the vignette of the
#archetypes package.  

#screeplot(lass)

numArchoid &lt;- 3
res_archoids_ns &lt;- archetypoids(numArchoid, X, huge = 200, step = FALSE, ArchObj = lass, 
                                nearest = "cand_ns", sequ = TRUE)
</code></pre>

<hr>
<h2 id='figures8landm'>
Figures of 8 landmarks with labelled landmarks
</h2><span id='topic+figures8landm'></span>

<h3>Description</h3>

<p>This function allows us to represent the two geometric figures (a cube and a parallelepiped) of 8 landmarks, with the landmark labels. Both appear in the paper Vinue et al. (2016), referred below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>figures8landm(figure,data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="figures8landm_+3A_figure">figure</code></td>
<td>

<p>A character vector, two values are admitted: if figure=&quot;cube&quot;, the cube is represented. If figure=&quot;paral&quot;, the parallelepiped is represented.
</p>
</td></tr>
<tr><td><code id="figures8landm_+3A_data">data</code></td>
<td>

<p>The data with the landmarks of the corresponding figure.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the cube or the parallelepiped with the landmark labels.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
figures8landm("cube", cube8landm)
figures8landm("paral", parallelep8landm)

## End(Not run)
</code></pre>

<hr>
<h2 id='getBestPamsamIMO'>
Generation of the candidate clustering partition in $HIPAM_IMO$
</h2><span id='topic+getBestPamsamIMO'></span>

<h3>Description</h3>

<p>The HIPAM algorithm starts with one large cluster and, at each level, a given (parent) cluster is partitioned using PAM.
</p>
<p>In this version of HIPAM, called $HIPAM_IMO$, the number k of (child) clusters is obtained by using the INCA (Index Number Clusters Atypical) criterion (Irigoien et al. (2008)) in the following way: at each node P, if there is k such that $INCA_k &gt; 0.2$, then the k prior to the first largest slope decrease is selected. However, this procedure does not apply either to the top node or to the generation of the new partitions from which the Mean Split Silhouette is calculated. In these cases, even when all $INCA_k &lt; 0.2$, k = 3 is fixed as the number of groups to divide and proceed. See Vinue et al. (2014) for more details.
</p>
<p>The foundation and performance of the HIPAM algorithm is explained in <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBestPamsamIMO(data,maxsplit,orness=0.7,type,ah,verbose,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBestPamsamIMO_+3A_data">data</code></td>
<td>

<p>Data to be clustered.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_maxsplit">maxsplit</code></td>
<td>

<p>The maximum number of clusters that any cluster can be divided when searching for the best clustering.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation. See <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code> and <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_type">type</code></td>
<td>

<p>Option 'IMO' for using $HIPAM_IMO$.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
<tr><td><code id="getBestPamsamIMO_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>medoids</em>: The cluster medoids.
</p>
<p><em>clustering</em>: The clustering partition obtained.
</p>
<p><em>asw</em>: The asw of the clustering.
</p>
<p><em>num.of.clusters</em>: Number of clusters in the final clustering.
</p>
<p><em>info</em>: List that informs about the progress of the clustering algorithm.
</p>
<p><em>profiles</em>: List that contains the asw and sesw (stardard error of the silhouette widths) profiles at each
stage of the search.
</p>
<p><em>metric</em>: Dissimilarity used (called 'McCulloch' because the dissimilarity function used is that explained in McCulloch et al. (1998)).
</p>


<h3>Note</h3>

<p>This function belongs to the $HIPAM_IMO$ algorithm and it is not solely used. That is why there is no section of <em>examples</em> in this help page. See <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally created by E. Wit et al., and it is available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>. We have adapted it to incorporate the INCA criterion.
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1.
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>
<p>Pollard, K. S., and van der Laan, M. J., (2002). A method to identify significant clusters in gene expression data. <em>Vol. II of SCI2002 Proceedings</em>, 318&ndash;325.
</p>
<p>Irigoien, I., and Arenas, C., (2008). INCA: New statistic for estimating the number of clusters and identifying atypical units, <em>Statistics in Medicine</em> <b>27</b>, 2948&ndash;2973.
</p>
<p>Irigoien, I., Sierra, B., and Arenas, C., (2012). ICGE: an R package for detecting relevant clusters and atypical units in gene expression, <em>BMC Bioinformatics</em> <b>13</b> 1&ndash;29.
</p>
<p>McCulloch, C., Paal, B., and Ashdown, S., (1998). An optimization approach to apparel sizing, <em>Journal of the Operational Research Society</em> <b>49</b>, 492&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>

<hr>
<h2 id='getBestPamsamMO'>
Generation of the candidate clustering partition in $HIPAM_MO$
</h2><span id='topic+getBestPamsamMO'></span>

<h3>Description</h3>

<p>The HIPAM algorithm starts with one large cluster and, at each level, a given (parent) cluster is partitioned using PAM.
</p>
<p>In this version of HIPAM, called $HIPAM_MO$, the number k of (child) clusters is obtained by maximizing the silhouette width (asw). See Vinue et al. (2014) for more details.
</p>
<p>The foundation and performance of the HIPAM algorithm is explained in <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBestPamsamMO(data,maxsplit,orness=0.7,type,ah,verbose,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBestPamsamMO_+3A_data">data</code></td>
<td>

<p>Data to be clustered.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_maxsplit">maxsplit</code></td>
<td>

<p>The maximum number of clusters that any cluster can be divided when searching for the best clustering.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation. See <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code> and <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_type">type</code></td>
<td>

<p>Option 'MO' for using $HIPAM_MO$.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
<tr><td><code id="getBestPamsamMO_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>medoids</em>: The cluster medoids.
</p>
<p><em>clustering</em>: The clustering partition obtained.
</p>
<p><em>asw</em>: The asw of the clustering.
</p>
<p><em>num.of.clusters</em>: Number of clusters in the final clustering.
</p>
<p><em>info</em>: List that informs about the progress of the clustering algorithm.
</p>
<p><em>profiles</em>: List that contains the asw and sesw (stardard error of the silhouette widths) profiles at each
stage of the search.
</p>
<p><em>metric</em>: Dissimilarity used (called 'McCulloch' because the dissimilarity function used is that explained in McCulloch et al. (1998)).
</p>


<h3>Note</h3>

<p>This function belongs to the $HIPAM_MO$ algorithm and it is not solely used. That is why there is no section of <em>examples</em> in this help page. See <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Author(s)</h3>

<p>This function was originally created by E. Wit et al., and it is available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1.
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>
<p>Pollard, K. S., and van der Laan, M. J., (2002). A method to identify significant clusters in gene expression data. <em>Vol. II of SCI2002 Proceedings</em>, 318&ndash;325.
</p>
<p>McCulloch, C., Paal, B., and Ashdown, S., (1998). An optimization approach to apparel sizing, <em>Journal of the Operational Research Society</em> <b>49</b>, 492&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>

<hr>
<h2 id='getDistMatrix'>
Dissimilarity matrix between individuals and prototypes
</h2><span id='topic+getDistMatrix'></span>

<h3>Description</h3>

<p>In the definition of a sizing system, a distance function allows us to represent mathematically the idea of garment fit and it is a key element to quantify the misfit between an individual and the prototype.
</p>
<p>This function computes the dissimilarity defined in McCulloch et al. (1998), which is used in <code><a href="#topic+trimowa">trimowa</a></code> and <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>. For more details, see also Ibanez et al. (2012) and Vinue et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistMatrix(data,np,nv,w,bl,bh,al,ah,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistMatrix_+3A_data">data</code></td>
<td>

<p>Data vector.
</p>
</td></tr>
<tr><td><code id="getDistMatrix_+3A_np">np</code></td>
<td>

<p>Number of observations in the database.
</p>
</td></tr>
<tr><td><code id="getDistMatrix_+3A_nv">nv</code></td>
<td>

<p>Number of variables in the database.
</p>
</td></tr>
<tr><td><code id="getDistMatrix_+3A_w">w</code></td>
<td>

<p>Weights for the OWA operator computed by means of <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>.
</p>
</td></tr>
<tr><td><code id="getDistMatrix_+3A_bl">bl</code>, <code id="getDistMatrix_+3A_bh">bh</code>, <code id="getDistMatrix_+3A_al">al</code>, <code id="getDistMatrix_+3A_ah">ah</code></td>
<td>

<p>Constants required to specify the distance function.
</p>
</td></tr>
<tr><td><code id="getDistMatrix_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At the computational level, it is asummed that all the <code>bh</code> values are negative, all the <code>bl</code> values are positive and all the <code>al</code> and <code>ah</code> slopes are positive (the sign of <code>al</code> is changed within the function when computing the dissimilarities).
</p>


<h3>Value</h3>

<p>A symmetric <code>np</code> x <code>np</code> matrix of dissimilarities.
</p>


<h3>Note</h3>

<p>This function requires a C code called cast.c. In order to use  <code><a href="#topic+getDistMatrix">getDistMatrix</a></code> outside the package, the dynamic-link library is called by means of the sentence <code>dyn.load("cast.so")</code> (In Windows, it would be <code>dyn.load("cast.dll")</code>). 
</p>


<h3>Author(s)</h3>

<p>Juan Domingo
</p>


<h3>References</h3>

<p>McCulloch, C., Paal, B., and Ashdown, S., (1998). An optimization approach to apparel sizing, <em>Journal of the Operational Research Society</em> <b>49</b>, 492&ndash;499.
</p>
<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Leon, T., Zuccarello, P., Ayala, G., de Ves, E., and Domingo, J., (2007), Applying logistic regression to relevance feedback in image retrieval systems, <em>Pattern Recognition</em> <b>40</b>, 2621&ndash;2632.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data loading:
dataTrimowa &lt;- sampleSpanishSurvey
bust &lt;- dataTrimowa$bust
#First bust class:
data &lt;- dataTrimowa[(bust &gt;= 74) &amp; (bust &lt; 78), ]   
numVar &lt;- dim(dataTrimowa)[2]

#Weights calculation:
orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness,numVar)

#Constants required to specify the distance function:
numClust &lt;- 3
bh &lt;- (apply(as.matrix(log(data)),2,range)[2,] 
       - apply(as.matrix(log(data)),2,range)[1,]) / ((numClust-1) * 8) 
bl &lt;- -3 * bh
ah &lt;- c(23,28,20,25,25)
al &lt;- 3 * ah

#Data processing.
num.persons &lt;- dim(data)[1]
num.variables &lt;- dim(data)[2]
datam &lt;- as.matrix(data)
datat &lt;- aperm(datam, c(2,1))                     
dim(datat) &lt;- c(1,num.persons * num.variables)   

#Dissimilarity matrix:
D &lt;- getDistMatrix(datat, num.persons, numVar, weightsTrimowa, bl, bh, al, ah, FALSE)
</code></pre>

<hr>
<h2 id='HartiganShapes'>
Hartigan-Wong k-means for 3D shapes
</h2><span id='topic+HartiganShapes'></span>

<h3>Description</h3>

<p>The basic foundation of k-means is that the sample mean is the value that minimizes the Euclidean distance from each point, to the centroid of the cluster to which it belongs. Two fundamental concepts of the statistical shape analysis are the Procrustes mean and the Procrustes distance. Therefore, by integrating the Procrustes mean and the Procrustes distance we can use k-means in the shape analysis context. 
</p>
<p>The k-means method has been proposed by several scientists in different forms. In computer science and pattern recognition the k-means algorithm is often termed the Lloyd algorithm (see Lloyd (1982)). However, in many texts, the term k-means algorithm is used for certain similar sequential clustering algorithms. Hartigan and Wong (1979) use the term k-means for an algorithm that searches for the locally optimal k-partition by moving points from one cluster to another.
</p>
<p>This function allows us to use the Hartigan-Wong version of k-means adapted to deal with 3D shapes. Note that in the generic name of the k-means algorithm, k refers to the number of clusters to search for. To be more specific in the R code, k is referred to as <code>numClust</code>, see next section <em>arguments</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HartiganShapes(array3D,numClust,algSteps=10,niter=10,
               stopCr=0.0001,simul,initLl,initials,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HartiganShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample objects. Each row corresponds to an observation, and each column corresponds to a dimension (x,y,z).
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_algsteps">algSteps</code></td>
<td>

<p>Number of steps per initialization. Default value is 10.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations). Default value is 10.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_stopcr">stopCr</code></td>
<td>

<p>Relative stopping criteria. Default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_simul">simul</code></td>
<td>

<p>Logical value. If TRUE, this function is used for a simulation study.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_initll">initLl</code></td>
<td>

<p>Logical value. If TRUE, see next argument <code>initials</code>. If FALSE, they are new random initial values.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_initials">initials</code></td>
<td>

<p>If <code>initLl=TRUE</code>, they are the same random initial values used in each iteration of <code><a href="#topic+LloydShapes">LloydShapes</a></code>. If <code>initLl=FALSE</code> this argument must be passed simply as an empty vector.
</p>
</td></tr>
<tr><td><code id="HartiganShapes_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There have been several attempts to adapt the k-means algorithm in the context of the statistical shape analysis, each one adapting a different version of the k-means algorithm (Amaral et al. (2010), Georgescu (2009)). In Vinue, G. et al. (2014), it is demonstrated that the Lloyd k-means represents a noticeable reduction in the computation involved when the sample size increases, compared with the Hartigan-Wong k-means. We state that Hartigan-Wong should be used in the shape analysis context only for very small samples.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>ic1</em>: Optimal clustering.
</p>
<p><em>cases</em>: Anthropometric cases (optimal centers).
</p>
<p><em>vopt</em>: Optimal objective function.
</p>
<p>If a simulation study is carried out, the following elements are returned:
</p>
<p><em>ic1</em>: Optimal clustering.
</p>
<p><em>cases</em>: Anthropometric cases (optimal centers).
</p>
<p><em>vopt</em>: Optimal objective function.
</p>
<p><em>compTime</em>: Computational time.
</p>
<p><em>AllRate</em>: Allocation rate.
</p>


<h3>Note</h3>

<p>This function is based on the kmns.m file available from <a href="https://github.com/johannesgerer/jburkardt-m/tree/master/asa136">https://github.com/johannesgerer/jburkardt-m/tree/master/asa136</a>
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Hartigan, J. A., and Wong, M. A., (1979). A K-Means Clustering Algorithm, <em>Applied Statistics</em>, 100&ndash;108.
</p>
<p>Lloyd, S. P., (1982). Least Squares Quantization in PCM, <em>IEEE Transactions on Information Theory</em> <b>28</b>, 129&ndash;137.
</p>
<p>Amaral, G. J. A., Dore, L. H., Lessa, R. P., and Stosic, B., (2010). k-Means Algorithm in Statistical Shape Analysis, <em>Communications in Statistics - Simulation and Computation</em> <b>39(5)</b>, 1016&ndash;1026.
</p>
<p>Georgescu, V., (2009). Clustering of Fuzzy Shapes by Integrating Procrustean Metrics and Full Mean Shape Estimation into K-Means Algorithm. <em>In IFSA-EUSFLAT Conference.</em>
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>, <code><a href="#topic+landmarksSampleSpaSurv">landmarksSampleSpaSurv</a></code>, <code><a href="#topic+cube8landm">cube8landm</a></code>, <code><a href="#topic+parallelep8landm">parallelep8landm</a></code>, <code><a href="#topic+cube34landm">cube34landm</a></code>, <code><a href="#topic+parallelep34landm">parallelep34landm</a></code>, <code>procGPA</code>, <code><a href="#topic+optraShapes">optraShapes</a></code>, <code><a href="#topic+qtranShapes">qtranShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#CLUSTERING INDIVIDUALS ACCORDING TO THEIR SHAPE:
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 20 individuals are used.
landmarksNoNa_First20 &lt;- landmarksNoNa[1:20, ] 
(numIndiv &lt;- dim(landmarksNoNa_First20)[1])
#[1] 20         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First20)
#array3D &lt;- array3D[1:10,,] #to reduce computational times.
#shapes::plotshapes(array3D[,,1]) 
#calibrate::textxy(array3D[,1,1], array3D[,2,1], labs = 1:numLandmarks, cex = 0.7) 
 
numClust &lt;- 3 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
#resHA &lt;- HartiganShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, FALSE, c(), FALSE)
initials &lt;- list(c(15,10,1))
resHA &lt;- HartiganShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, TRUE, initials, TRUE)

if (!is.null(resHA)) {
  asig &lt;- resHA$ic1  #table(asig) shows the clustering results.
  prototypes &lt;- anthrCases(resHA)
}
#Note: For a simulation study, see www.uv.es/vivigui/softw/more_examples.R 
</code></pre>

<hr>
<h2 id='hipamAnthropom'>
HIPAM algorithm for anthropometric data
</h2><span id='topic+hipamAnthropom'></span>

<h3>Description</h3>

<p>The HIerarchical Partitioning Around Medoids clustering method (HIPAM) was originally created to gene clustering (Wit et al. (2004)). The HIPAM algorithm is a divisive hierarchical clustering method based on the PAM algorithm. 
</p>
<p>This function is a HIPAM algorithm adapted to deal with anthropometric data. To that end, a different dissimilarity function is incorporated. This function is that explained in McCulloch et al. (1998) and it is implemented in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. We call it $d_MO$. In addition, a different method to obtain a classification tree is also incorporated.
</p>
<p>Two HIPAM algorithms are proposed. The first one, called $HIPAM_MO$, is a HIPAM that uses $d_MO$. The second one, $HIPAM_IMO$, is a HIPAM algorithm that uses $d_MO$ and the INCA (Index Number Clusters Atypical) statistic criterion (Irigoien et al. (2008)) to decide the number of child clusters and as a stopping rule. 
</p>
<p>See Vinue et al. (2014) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hipamAnthropom(data,asw.tol=0,maxsplit=5,local.const=NULL,
               orness=0.7,type,ah=c(23,28,20,25,25),verbose,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hipamAnthropom_+3A_data">data</code></td>
<td>

<p>Data frame. In our approach, this is each of the subframes originated after segmenting the whole anthropometric Spanish survey into twelve bust segments, according to the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals. Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_asw.tol">asw.tol</code></td>
<td>

<p>If this value is given, a tolerance or penalty can be introduced (asw.tol &gt; 0 or asw.tol &lt; 0, respectively) in the branch splitting procedure. Default value (0) is maintained. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_maxsplit">maxsplit</code></td>
<td>

<p>The maximum number of clusters that any cluster can be divided into when searching for the best clustering.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_local.const">local.const</code></td>
<td>

<p>If this value is given (meaningful values are those between -1 and 1), a proposed partition is accepted only if the associated asw is greater than this constant. Default option for this argument is maintained, that is to say, this value is ignored. See page 154 of Wit et al. (2004) for more details.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation. See <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code> and <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_type">type</code></td>
<td>

<p>Type of HIPAM algorithm to be used. The possible options are 'MO' (for $HIPAM_MO$) and 'IMO' (for $HIPAM_IMO$).
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_verbose">verbose</code></td>
<td>

<p>Boolean variable (TRUE or FALSE) to indicate whether to report information on progress.
</p>
</td></tr>
<tr><td><code id="hipamAnthropom_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied to the internal functions of the HIPAM algorithms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The $HIPAM_MO$ algorithm uses the <code><a href="#topic+getBestPamsamMO">getBestPamsamMO</a></code> and <code><a href="#topic+checkBranchLocalMO">checkBranchLocalMO</a></code> functions, while the $HIPAM_IMO$ algorithm uses the <code><a href="#topic+getBestPamsamIMO">getBestPamsamIMO</a></code> and <code><a href="#topic+checkBranchLocalIMO">checkBranchLocalIMO</a></code> functions. 
</p>
<p>For more details of HIPAM, see van der Laan et al. (2003), Wit et al. (2004) and the manual of the <span class="pkg">smida</span> R package.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>clustering</em>: Final clustering that corresponds to the last level of the tree.
</p>
<p><em>asw</em>: The asw of the final clustering.
</p>
<p><em>n.levels</em>: Number of levels in the tree.
</p>
<p><em>cases</em>: Anthropometric cases (medoids of all of the clusters in the tree).
</p>
<p><em>active</em>: Activity status of each cluster (FALSE for every cluster of the final partition).
</p>
<p><em>development</em>: Matrix that indicates the ancestors of the final clusters.
</p>
<p><em>num.of.clusters</em>: Number of clusters in the final clustering.
</p>
<p><em>metric</em>: Dissimilarity used (called 'McCulloch' because the dissimilarity function used is that explained in McCulloch et al. (1998)).
</p>


<h3>Note</h3>

<p>All the functions related to the HIPAM algorithm were originally created by E. Wit et al., and they are available freely on <a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>. In order to develop the $HIPAM_MO$ and $HIPAM_IMO$ algorithms, we have used and adapted them.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1. <a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>
<p>van der Laan, M. J., and Pollard, K. S., (2003). A new algorithm for hybrid hierarchical clustering with visualization and the bootstrap, <em>Journal of Statistical Planning and Inference</em> <b>117</b>, 275&ndash;303.
</p>
<p>Pollard, K. S., and van der Laan, M. J., (2002). A method to identify significant clusters in gene expression data. <em>Vol. II of SCI2002 Proceedings</em>, 318&ndash;325.
</p>
<p>Irigoien, I., and Arenas, C., (2008). INCA: New statistic for estimating the number of clusters and identifying atypical units, <em>Statistics in Medicine</em> <b>27</b>, 2948&ndash;2973.
</p>
<p>Irigoien, I., Sierra, B., and Arenas, C., (2012). ICGE: an R package for detecting relevant clusters and atypical units in gene expression, <em>BMC Bioinformatics</em> <b>13</b>, 1&ndash;29.
</p>
<p>McCulloch, C., Paal, B., and Ashdown, S., (1998). An optimization approach to apparel sizing, <em>Journal of the Operational Research Society</em> <b>49</b>, 492&ndash;499.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>
<p>Alemany, S., Gonzalez, J. C., Nacher, B., Soriano, C., Arnaiz, C., and Heras, H., (2010). Anthropometric survey of the Spanish female population aimed at the apparel industry. <em>Proceedings of the 2010 Intl. Conference on 3D Body scanning Technologies</em>, 307&ndash;315.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBestPamsamMO">getBestPamsamMO</a></code>, <code><a href="#topic+getBestPamsamIMO">getBestPamsamIMO</a></code>, <code><a href="#topic+checkBranchLocalMO">checkBranchLocalMO</a></code>, <code><a href="#topic+checkBranchLocalIMO">checkBranchLocalIMO</a></code>, <code><a href="#topic+plotTreeHipamAnthropom">plotTreeHipamAnthropom</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#FOR THE SIZES DEFINED BY THE EUROPEAN NORMATIVE:
dataHipam &lt;- sampleSpanishSurvey
bust &lt;- dataHipam$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

type &lt;- "IMO"
maxsplit &lt;- 5 ; orness &lt;- 0.7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
numSizes &lt;- 1
res_hipam &lt;- computSizesHipamAnthropom(dataHipam, bust, bustSizes$bustCirc, numSizes,
                                       maxsplit, orness, type, ah, FALSE)

fitmodels &lt;- anthrCases(res_hipam, numSizes)
outliers &lt;- trimmOutl(res_hipam, numSizes)

#FOR ANY OTHER DEFINED SIZE:
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(1900)
rand &lt;- sample(1:600,20)
dataComp &lt;- sampleSpanishSurvey[rand, c(2, 3, 5)]
numVar &lt;- dim(dataComp)[2]

type &lt;- "IMO"
maxsplit &lt;- 5 ; orness &lt;- 0.7
ah &lt;- c(28, 25, 25) 

dataMat &lt;- as.matrix(dataComp)
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
res_hipam_One &lt;- list() ; class(res_hipam_One) &lt;- "hipamAnthropom" 
res_hipam_One[[1]] &lt;- hipamAnthropom(dataMat, maxsplit = maxsplit, orness = orness, 
                                     type = type, ah = ah, verbose = FALSE)
                            
#plotTreeHipamAnthropom(res_hipam_One, main="Proposed Hierarchical PAM Clustering \n")

fitmodels_One &lt;- anthrCases(res_hipam_One,1)
outliers_One &lt;- trimmOutl(res_hipam_One,1)
</code></pre>

<hr>
<h2 id='landmarksSampleSpaSurv'>
Landmarks of the sampled women of the Spanish Survey
</h2><span id='topic+landmarksSampleSpaSurv'></span>

<h3>Description</h3>

<p>The body shape of the women who belong to <code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code> is represented by a set of anatomical correspondence points, called landmarks. 
</p>
<p>This database collects the set of landmarks of each woman. 
</p>
<p>The landmarks considered were placed in three different ways:
</p>

<ul>
<li><p> Automatic landmarks: automatically calculated with scanner program algorithms, based on geometrical features of the body.
</p>
</li>
<li><p> Manual landmarks: points which are not reflected on the external body geometry; they were located through palpation by expert personnel and identified by a physical marker.
</p>
</li>
<li><p> Digital landmarks: detected on the computer screen in the 3D scanned image. They are not robust on the automatic calculation but are easy to detect on the screen.  
</p>
</li></ul>
 


<h3>Usage</h3>

<pre><code class='language-R'>landmarksSampleSpaSurv</code></pre>


<h3>Format</h3>

<p>A data frame with 600 observations and 198 variables (66 landmarks times 3 dimensions).</p>


<h3>Source</h3>

<p>Anthropometric survey of the Spanish female population.</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Alemany, S., Gonzalez, J. C., Nacher, B., Soriano, C., Arnaiz, C., and Heras, H., (2010). Anthropometric survey of the Spanish female population aimed at the apparel industry. <em>Proceedings of the 2010 Intl. Conference on 3D Body scanning Technologies</em>, 307&ndash;315.
</p>

<hr>
<h2 id='LloydShapes'>
Lloyd k-means for 3D shapes
</h2><span id='topic+LloydShapes'></span>

<h3>Description</h3>

<p>The basic foundation of k-means is that the sample mean is the value that minimizes the Euclidean distance from each point, to the centroid of the cluster to which it belongs. Two fundamental concepts of the statistical shape analysis are the Procrustes mean and the Procrustes distance. Therefore, by integrating the Procrustes mean and the Procrustes distance we can use k-means in the shape analysis context. 
</p>
<p>The k-means method has been proposed by several scientists in different forms. In computer science and pattern recognition the k-means algorithm is often termed the Lloyd algorithm (see Lloyd (1982)). 
</p>
<p>This function allows us to use the Lloyd version of k-means adapted to deal with 3D shapes. Note that in the generic name of the k-means algorithm, k refers to the number of clusters to search for. To be more specific in the R code, k is referred to as <code>numClust</code>, see next section <em>arguments</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LloydShapes(array3D,numClust,algSteps=10,niter=10,stopCr=0.0001,simul,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LloydShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample objects. Each row corresponds to an observation, and each column corresponds to a dimension (x,y,z).
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_algsteps">algSteps</code></td>
<td>

<p>Number of steps of the algorithm per initialization. Default value is 10.
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations). Default value is 10.
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_stopcr">stopCr</code></td>
<td>

<p>Relative stopping criteria. Default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_simul">simul</code></td>
<td>

<p>Logical value. If TRUE, this function is used for a simulation study.
</p>
</td></tr>
<tr><td><code id="LloydShapes_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There have been several attempts to adapt the k-means algorithm in the context of the statistical shape analysis, each one adapting a different version of the k-means algorithm (Amaral et al. (2010), Georgescu (2009)). In Vinue et al. (2014), it is demonstrated that the Lloyd k-means represents a noticeable reduction in the computation involved when the sample size increases, compared with the Hartigan-Wong k-means. We state that Hartigan-Wong should be used in the shape analysis context only for very small samples.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>asig</em>: Optimal clustering.
</p>
<p><em>cases</em>: Anthropometric cases (optimal centers).
</p>
<p><em>vopt</em>: Optimal objective function.
</p>
<p><em>initials</em>: Random initial values used in each iteration. These values are then used by <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>.
</p>
<p>If a simulation study is carried out, the following elements are returned:
</p>
<p><em>asig</em>: Optimal clustering.
</p>
<p><em>cases</em>: Anthropometric cases (optimal centers).
</p>
<p><em>vopt</em>: Optimal objective function.
</p>
<p><em>compTime</em>: Computational time.
</p>
<p><em>AllRate</em>: Allocation rate.
</p>
<p><em>initials</em>: Random initial values used in each iteration. These values are then used by <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>.
</p>


<h3>Author(s)</h3>

<p>Amelia Simo
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Lloyd, S. P., (1982). Least Squares Quantization in PCM, <em>IEEE Transactions on Information Theory</em> <b>28</b>, 129&ndash;137.
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HartiganShapes">HartiganShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>, <code><a href="#topic+landmarksSampleSpaSurv">landmarksSampleSpaSurv</a></code>, <code><a href="#topic+cube8landm">cube8landm</a></code>, <code><a href="#topic+parallelep8landm">parallelep8landm</a></code>, <code><a href="#topic+cube34landm">cube34landm</a></code>, <code><a href="#topic+parallelep34landm">parallelep34landm</a></code>, <code>procGPA</code>, <code><a href="#topic+optraShapes">optraShapes</a></code>, <code><a href="#topic+qtranShapes">qtranShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#CLUSTERING INDIVIDUALS ACCORDING TO THEIR SHAPE:
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 10 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)
#shapes::plotshapes(array3D[,,1]) 
#calibrate::textxy(array3D[,1,1], array3D[,2,1], labs = 1:numLandmarks, cex = 0.7) 

numClust &lt;- 2 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
resLL &lt;- LloydShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, FALSE)

asig &lt;- resLL$asig 
table(resLL$asig) 
prototypes &lt;- anthrCases(resLL)

#Note: For a simulation study, see www.uv.es/vivigui/softw/more_examples.R 
</code></pre>

<hr>
<h2 id='nearestToArchetypes'>
Nearest individuals to archetypes
</h2><span id='topic+nearestToArchetypes'></span>

<h3>Description</h3>

<p>The nearest individual to each archetype can be obtained by simply computing the distance between the archetypes and the individuals and choosing the nearest. This is the procedure to obtain what is called the <em>cand_ns</em> vector, see Vinue et al. (2015). It is used within <code><a href="#topic+archetypoids">archetypoids</a></code> and <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestToArchetypes(indivs,numArch,mdras)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestToArchetypes_+3A_indivs">indivs</code></td>
<td>

<p>Vector from 1 to <code>numArch</code> of individuals nearest to archetypes.
</p>
</td></tr>
<tr><td><code id="nearestToArchetypes_+3A_numarch">numArch</code></td>
<td>

<p>Number of archetypes computed. 
</p>
</td></tr>
<tr><td><code id="nearestToArchetypes_+3A_mdras">mdras</code></td>
<td>

<p>Distance matrix between the archetypes and the individuals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the nearest individuals to archetypes.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids">archetypoids</a></code>, <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>, <code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#COCKPIT DESIGN PROBLEM:
#As a toy example, only the first 25 individuals are used.
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

res &lt;- archetypesBoundary(USAFSurvey_preproc$data, 5, FALSE, 3)
#To understand the warning messages, see the vignette of the
#archetypes package.  

numArch &lt;- 3
a3 &lt;- archetypes::bestModel(res[[numArch]])
ras &lt;- rbind(archetypes::parameters(a3), USAFSurvey_preproc$data)
dras &lt;- dist(ras, method = "euclidean", diag = FALSE, upper = TRUE, p = 2)
mdras &lt;- as.matrix(dras)
diag(mdras) &lt;- 1e+11
sapply(seq(length=numArch), nearestToArchetypes, numArch, mdras) 
</code></pre>

<hr>
<h2 id='optraShapes'>
Auxiliary optra subroutine of the Hartigan-Wong k-means for 3D shapes
</h2><span id='topic+optraShapes'></span>

<h3>Description</h3>

<p>The Hartigan-Wong version of the k-means algorithm uses two auxiliary algorithms: the optimal transfer stage (optra) and the quick transfer stage (qtran). 
</p>
<p>This function is the optra subroutine adapted to the shape analysis context. It is used within <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>. See Hartigan and Wong (1979) for details of the original k-means algorithm and Amaral et al. (2010) for details about its adaptation to shape analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optraShapes(array3D,n,c,numClust,ic1,ic2,nc,an1,an2,ncp,d,itran,live,indx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optraShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample objects.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_n">n</code></td>
<td>

<p>Number of sample objects.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_c">c</code></td>
<td>

<p>Array of centroids.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_ic1">ic1</code></td>
<td>

<p>The cluster to each object belongs.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_ic2">ic2</code></td>
<td>

<p>This vector is used to remember the cluster which each object is most likely to be transferred to at each step.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_nc">nc</code></td>
<td>

<p>Number of objects in each cluster.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_an1">an1</code></td>
<td>

<p>$an1(l) = nc(l) / (nc(l) - 1), l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_an2">an2</code></td>
<td>

<p>$an2(l) = nc(l) / (nc(l) + 1), l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_ncp">ncp</code></td>
<td>

<p>In the optimal transfer stage, ncp(l) stores the step at which cluster l is last updated, $l=1,...,numClust$.<br />
In the quick transfer stage, ncp(l) stores the step at which cluster l is last updated plus n, $l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_d">d</code></td>
<td>

<p>Vector of distances from each object to every centroid. 
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_itran">itran</code></td>
<td>

<p>itran(l) = 1 if cluster l is updated in the quick-transfer stage (0 otherwise), $l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_live">live</code></td>
<td>

<p>Vector that indicates whether a cluster is included in the live set or not.
</p>
</td></tr>
<tr><td><code id="optraShapes_+3A_indx">indx</code></td>
<td>

<p>Number of steps since a transfer took place.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: <em>c,ic1,ic2,nc,an1,an2,ncp,d,itran,live,indx</em>, updated after the optimal transfer stage.
</p>


<h3>Note</h3>

<p>This function belongs to <code><a href="#topic+HartiganShapes">HartiganShapes</a></code> and it is not solely used. That is why there is no section of <em>examples</em> in this help page.
</p>


<h3>Note</h3>

<p>This function is based on the optra.m file available from <a href="https://github.com/johannesgerer/jburkardt-m/tree/master/asa136">https://github.com/johannesgerer/jburkardt-m/tree/master/asa136</a>.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Hartigan, J. A., and Wong, M. A., (1979). A K-Means Clustering Algorithm, <em>Applied Statistics</em>, 100&ndash;108.
</p>
<p>Amaral, G. J. A., Dore, L. H., Lessa, R. P., and Stosic, B., (2010). k-Means Algorithm in Statistical Shape Analysis, <em>Communications in Statistics - Simulation and Computation</em> <b>39(5)</b>, 1016&ndash;1026.
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HartiganShapes">HartiganShapes</a></code>
</p>

<hr>
<h2 id='overlapBiclustersByRows'>
Overlapped biclusters by rows
</h2><span id='topic+overlapBiclustersByRows'></span>

<h3>Description</h3>

<p>This function allows us to check which rows belong to more than one bicluster. It is used within the <code><a href="#topic+CCbiclustAnthropo">CCbiclustAnthropo</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapBiclustersByRows(Bic,resBicluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapBiclustersByRows_+3A_bic">Bic</code></td>
<td>

<p>Bicluster number.
</p>
</td></tr>
<tr><td><code id="overlapBiclustersByRows_+3A_resbicluster">resBicluster</code></td>
<td>

<p>An object of class Biclust.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to know how this function works, it is necessary to understand the following commands:
</p>
<p><em>res.bicl@RowxNumber[,1]</em> indicates the rows that belong to the bicluster 1, by assigning a TRUE value to the position of those rows inside the original matrix. By using <em>table(res.bicl@RowxNumber[,1])</em>, we obtain the number of rows belonging to bicluster 1.
</p>
<p><em>1 * res.bicl@RowxNumber[,1]</em> makes TRUES into 1s.
</p>
<p><em>Bic * res.bicl@RowxNumber[,Bic]</em> makes TRUES into the corresponding value of Bic.
</p>
<p>In short, this function puts a 1 in those rows belonging to bicluster 1, a 2 in those ones of bicluster 2, and so on.
</p>
<p>The fact that certain columns of the matrix returned by this function have a value different from 0 at the same row, will indicate that that row belong to both biclusters.
</p>
<p>This function cannot be used with the data of the package. This function is included in the package in the hope that it could be helpful or useful for other researchers. 
</p>


<h3>Value</h3>

<p>A matrix with as many rows as rows of the original matrix, and as many columns as obtained biclusters. 
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., and Ibanez, M. V., (2014), <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>
<p>Kaiser, S., and Leisch, F., (2008). A Toolbox for Bicluster Analysis in R. Tech.rep., Department of Statistics (University of Munich).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCbiclustAnthropo">CCbiclustAnthropo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Note: package biclust needed.
#This is an example of using this function with a certain database 
#made up of body dimensions related to the lower body part.
data &lt;- dataUser[(waist &gt;= 58) &amp; (waist &lt; 115),] #dataUser is the user database.
rownames(data) &lt;- 1:dim(data)[1]
  
waist &lt;- data[,"WaistCircumference"] 
    
waist_4 &lt;- seq(58, 86, 4) 
waist_6 &lt;- seq(91, 115, 6) 
waistCirc &lt;- c(waist_4,waist_6)
nsizes &lt;- length(waistCirc) 

#Position of the body variables in the database:
lowerVars &lt;- c(14, 17:25, 27, 28, 65:73, 75, 77:81, seq(100, 116, 2))

nBic &lt;- c(2, 2, 4, rep(5, 7), 3, 3)  
diffRanges &lt;- list(c(14,20), c(24,30), c(24,30), c(33,39), c(29,35), c(29,35), 
                   c(28,35), c(31,38), c(31,38), c(30,37), c(26,33), c(25,32))
percDisac &lt;- 0.01 
dir &lt;- "/home/guillermo/"
  
res_bicl_antropom &lt;- CCbiclustAnthropo(data,waist,waistCirc,lowerVars,
                                       nsizes,nBic,diffRanges,percDisac,dir)

#For a single size:
size &lt;- 5
res &lt;- res_bicl_antropom[[1]][[size]]

sapply(1 : res@Number, overlapBiclustersByRows, res)

## End(Not run)
</code></pre>

<hr>
<h2 id='parallelep34landm'>
Parallelepiped of 34 landmarks
</h2><span id='topic+parallelep34landm'></span>

<h3>Description</h3>

<p>This is a parallelepiped made up of 34 landmarks, used as controlled data in the simulation study carried out in the paper referred below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelep34landm</code></pre>


<h3>Format</h3>

<p>An array with one matrix of 34 rows and 3 columns.</p>


<h3>Source</h3>

<p>Software Rhinoceros.</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>

<hr>
<h2 id='parallelep8landm'>
Parallelepiped of 8 landmarks
</h2><span id='topic+parallelep8landm'></span>

<h3>Description</h3>

<p>This is a parallelepiped made up of 8 landmarks, used as controlled data in the simulation study carried out in the paper referred below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelep8landm</code></pre>


<h3>Format</h3>

<p>An array with one matrix of 8 rows and 3 columns.</p>


<h3>Source</h3>

<p>Software Rhinoceros.</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>

<hr>
<h2 id='percentilsArchetypoid'>
Helper function for computing percentiles of a certain archetypoid
</h2><span id='topic+percentilsArchetypoid'></span>

<h3>Description</h3>

<p>This helper function computes the percentiles of an archetypoid for a given variable. Once these percentile values have been calculated, they can be represented by means of a barplot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentilsArchetypoid(column,indiv,data,digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentilsArchetypoid_+3A_column">column</code></td>
<td>

<p>Numeric variable (column of a data frame).
</p>
</td></tr>
<tr><td><code id="percentilsArchetypoid_+3A_indiv">indiv</code></td>
<td>

<p>A certain archetypoid.
</p>
</td></tr>
<tr><td><code id="percentilsArchetypoid_+3A_data">data</code></td>
<td>

<p>Data frame that contains the columns and archetypoids to be analyzed. 
</p>
</td></tr>
<tr><td><code id="percentilsArchetypoid_+3A_digits">digits</code></td>
<td>

<p>Argument of the <code><a href="base.html#topic+round">round</a></code> function (it is a integer indicating the number of decimal places to be used).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical vector with the percentile values of an archetypoid. 
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids">archetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#COCKPIT DESIGN PROBLEM:
#As a toy example, only the first 25 individuals are used.
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 5 ; numRep &lt;- 2
lass &lt;- stepArchetypesRawData(data = USAFSurvey_preproc$data, numArch = 1:numArch,
                              numRep = numRep, verbose = FALSE)  
#To understand the warning messages, see the vignette of the
#archetypes package.  

#screeplot(lass)

#Three archetypoids:
numArchoid &lt;- 3
res_ns &lt;- archetypoids(numArchoid, USAFSurvey_preproc$data, huge = 200, step = FALSE, 
                                ArchObj = lass, nearest = "cand_ns" , sequ = TRUE)
 
percentilsArchetypoid(1, res_ns$archet[1], USAFSurvey_preproc$data, 0)
</code></pre>

<hr>
<h2 id='plotPrototypes'>
Prototypes representation
</h2><span id='topic+plotPrototypes'></span>

<h3>Description</h3>

<p>This function represents the scatter plots of bust circumference against other selected variable (chest, hip, neck to ground or waist) jointly with the prototypes obtained for each bust class provided by either <code><a href="#topic+trimowa">trimowa</a></code> or <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>. In addition, the prototypes defined by the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals can be also displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPrototypes(data,prototypes,nsizes,bustVariable,variable,col,xlim,ylim,
               main,EN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPrototypes_+3A_data">data</code></td>
<td>

<p>Data frame. It should contain the chest, neck to ground, waist, hip and bust measurements of the individuals. In order to be able to represent them, the name of the columns of the database must be 'chest', 'necktoground', 'waist', 'hip' and 'bust' respectively, see <code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>. Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_prototypes">prototypes</code></td>
<td>

<p>Prototypes (medoids) i.e., typical persons within the sample, obtained with <code><a href="#topic+trimowa">trimowa</a></code> or <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of subsets (classes), into the database is segmented. In our approach, the whole anthropometric Spanish survey is segmented into twelve bust segments, according to the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_bustvariable">bustVariable</code></td>
<td>

<p>Bust variable.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_variable">variable</code></td>
<td>

<p>Anthropometric variable to be plotted. It can be 'chest', 'necktoground', 'waist' and 'hip'.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_col">col</code></td>
<td>

<p>A specification for the medoids color in each bust class.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_xlim">xlim</code></td>
<td>

<p>Axis lenght of the x axis according to the range of the bust variable.
</p>
</td></tr> 
<tr><td><code id="plotPrototypes_+3A_ylim">ylim</code></td>
<td>

<p>Axis lenght of the y axis according to the range of the selected variable among chest, hip, neck to ground and waist.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_main">main</code></td>
<td>

<p>Main title of the plot.
</p>
</td></tr>
<tr><td><code id="plotPrototypes_+3A_en">EN</code></td>
<td>

<p>A logical value. If TRUE, the prototypes defined by the European standard for each variable are represented. See section <em>Details</em> for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ir order to check the goodness of <code><a href="#topic+trimowa">trimowa</a></code>, the sizes defined by the prototypes can be compared with those defined by the European standard to sizing system. This standard establishes 12 sizes according to the combinations of the bust, waist and hip measurements and does not fix neither chest nor height standard measurements. We can approximate the chest measurements through a linear regression analysis, taking the bust measurements detailed in the standard as independent variable. Besides, we take as neck to ground measurements for the standard sizing system, the values 132, 136 and 140 cm because those are the most repeated values and they are those which best cover our data set. See Ibanez et al. (2012) for a complete explanation.
</p>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Note</h3>

<p>As mentioned, this function is especially defined for the sizes established by the European standard on sizing systems. Part 3: Measurements and intervals. In order to use this function with other standard, this function must be adapted. 
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>, <code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>, <code><a href="#topic+trimmedoid">trimmedoid</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TRIMOWA ALGORITHM:
dataTrimowa &lt;- sampleSpanishSurvey
numVar &lt;- dim(dataTrimowa)[2]
bust &lt;- dataTrimowa$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness, numVar)

numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
numSizes &lt;- 2
res_trimowa &lt;- computSizesTrimowa(dataTrimowa, bust, bustSizes$bustCirc, numSizes,
                                  weightsTrimowa, numClust, alpha, niter, algSteps, 
                                  ah, FALSE)

prototypes &lt;- anthrCases(res_trimowa, numSizes)

bustVariable &lt;- "bust"
xlim &lt;- c(72, 132)
color &lt;- c("black", "red", "green", "blue", "cyan", "brown", "gray",
           "deeppink3", "orange", "springgreen4", "khaki3", "steelblue1")

variable &lt;- "chest"
range(dataTrimowa[,variable])
#[1] 76.7755 135.8580
ylim &lt;- c(70,140)
title &lt;- "Prototypes \n bust vs chest"

plotPrototypes(dataTrimowa, prototypes, numSizes, bustVariable, 
               variable, color, xlim, ylim, title, FALSE)
plotPrototypes(dataTrimowa, prototypes, numSizes, bustVariable, 
               variable, color, xlim, ylim, title, TRUE)

#For other plots and an example for the hipam algorithm, 
#see www.uv.es/vivigui/softw/more_examples.R 
</code></pre>

<hr>
<h2 id='plotTreeHipamAnthropom'>
HIPAM dendogram
</h2><span id='topic+plotTreeHipamAnthropom'></span>

<h3>Description</h3>

<p>This function represents a dendrogram for the clustering results provided by a HIPAM algorithm. It is a small modification of the original <code>plot.tree</code> function of the <span class="pkg">smida</span> R package, available from <a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTreeHipamAnthropom(x,main,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTreeHipamAnthropom_+3A_x">x</code></td>
<td>

<p>The HIPAM object to be plotted.
</p>
</td></tr>
<tr><td><code id="plotTreeHipamAnthropom_+3A_main">main</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="plotTreeHipamAnthropom_+3A_...">...</code></td>
<td>

<p>Other arguments that may be supplied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Note</h3>

<p>This function only represents the 'tree' option of the original <code>plot.tree</code> function of <span class="pkg">smida</span>, because we believe that this option displays better the clustering results provided by HIPAM than the option '2d'.
</p>


<h3>Author(s)</h3>

<p>This function was originally created by E. Wit et al., and it is available freely on
<a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>. We have slightly modified. 
</p>


<h3>References</h3>

<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Wit, E., and McClure, J., (2004). <em>Statistics for Microarrays: Design, Analysis and Inference</em>. John Wiley &amp; Sons, Ltd.
</p>
<p>Wit, E., and McClure, J., (2006). Statistics for Microarrays: Inference, Design and Analysis. R package version 0.1. <a href="https://www.math.rug.nl/~ernst/book/smida.html">https://www.math.rug.nl/~ernst/book/smida.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataHipam &lt;- sampleSpanishSurvey
bust &lt;- dataHipam$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

type &lt;- "IMO"
maxsplit &lt;- 5 ; orness &lt;- 0.7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
numSizes &lt;- 1
res_hipam &lt;- computSizesHipamAnthropom(dataHipam, bust, bustSizes$bustCirc, numSizes,
                                       maxsplit, orness, type, ah, FALSE)

plotTreeHipamAnthropom(res_hipam[[1]],
                       main=paste("Proposed Hierarchical PAM Clustering \n",
                       "74-78"))
</code></pre>

<hr>
<h2 id='plotTrimmOutl'>
Trimmed or outlier observations representation
</h2><span id='topic+plotTrimmOutl'></span>

<h3>Description</h3>

<p>This function represents the scatter plots of bust circumference against other selected variable (chest,hip,neck to ground or waist) jointly with the trimmed individuals discarded in each bust class provided by <code><a href="#topic+trimowa">trimowa</a></code> or with the outlier individuals provided by <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrimmOutl(data,trimmOutl,nsizes,bustVariable,variable,col,xlim,ylim,main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrimmOutl_+3A_data">data</code></td>
<td>

<p>Data frame. It should contain the chest, neck to ground, waist, hip and bust measurements of the individuals. In order to be able to represent them, the name of the columns of the database must be 'chest', 'necktoground', 'waist', 'hip' and 'bust' respectively, see <code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>. Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_trimmoutl">trimmOutl</code></td>
<td>

<p>Trimmed women (if <code><a href="#topic+trimowa">trimowa</a></code>) or outlier women (if <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>).
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of subsets (classes), into the database is segmented. In our approach, the whole anthropometric Spanish survey is segmented into twelve bust segments, according to the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_bustvariable">bustVariable</code></td>
<td>

<p>Bust variable.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_variable">variable</code></td>
<td>

<p>Anthropometric variable to be plotted. It can be 'chest', 'necktoground', 'waist' and 'hip'.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_col">col</code></td>
<td>

<p>A specification for the trimmed or outlier women color in each bust class.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_xlim">xlim</code></td>
<td>

<p>Axis lenght of the x axis according to the range of the bust variable.
</p>
</td></tr> 
<tr><td><code id="plotTrimmOutl_+3A_ylim">ylim</code></td>
<td>

<p>Axis lenght of the y axis according to the range of the selected variable among chest, hip, neck to ground and waist.
</p>
</td></tr>
<tr><td><code id="plotTrimmOutl_+3A_main">main</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+trimowa">trimowa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TRIMOWA ALGORITHM:
dataTrimowa &lt;- sampleSpanishSurvey
numVar &lt;- dim(dataTrimowa)[2]
bust &lt;- dataTrimowa$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness, numVar)

numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
numSizes &lt;- 2
res_trimowa &lt;- computSizesTrimowa(dataTrimowa, bust, bustSizes$bustCirc, numSizes,
                                  weightsTrimowa, numClust, alpha, niter, algSteps, 
                                  ah, FALSE)

prototypes &lt;- anthrCases(res_trimowa, numSizes)
trimmed &lt;- trimmOutl(res_trimowa, numSizes)

bustVariable &lt;- "bust"
xlim &lt;- c(72, 132)
color &lt;- c("black", "red", "green", "blue", "cyan", "brown", "gray",
           "deeppink3", "orange", "springgreen4", "khaki3", "steelblue1")

variable &lt;- "chest"
range(dataTrimowa[,variable])
#[1] 76.7755 135.8580
ylim &lt;- c(70,140)
main &lt;- "Trimmed women \n bust vs chest"

plotTrimmOutl(dataTrimowa, trimmed, numSizes, bustVariable, variable, color, 
              xlim, ylim, main)

#For other plots and an example for the hipam algorithm, 
#see www.uv.es/vivigui/softw/more_examples.R 
</code></pre>

<hr>
<h2 id='preprocessing'>
Data preprocessing before computing archetypal observations
</h2><span id='topic+preprocessing'></span>

<h3>Description</h3>

<p>This function allows us to fix the accommodated data before computing archetypes and archetypoids. First, depending on the problem, it is possible to standardize the data or not. Second, it is possible to use the Mahalanobis distance or a depth procedure to select the accommodated subsample of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocessing(data,stand,percAccomm,mahal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocessing_+3A_data">data</code></td>
<td>

<p>Raw data. It must be a data frame. Each row corresponds to an observation and each column corresponds to an anthropometric variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="preprocessing_+3A_stand">stand</code></td>
<td>

<p>A logical value. If TRUE (FALSE) the data are (not) standardized. This option will depend on the problem.
</p>
</td></tr>
<tr><td><code id="preprocessing_+3A_percaccomm">percAccomm</code></td>
<td>

<p>Percentage of the population to accommodate (value between 0 and 1). When this percentage is equal to 1 all the individuals will be accommodated.
</p>
</td></tr>
<tr><td><code id="preprocessing_+3A_mahal">mahal</code></td>
<td>

<p>If percAccom is different from 1, then <code>mahal=TRUE</code> (<code>mahal=FALSE</code>) indicates that the Mahalanobis distance (a depth procedure) will be used to select the accommodated subsample of data. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In somes cases, the depth procedure has the disadvantage that the desired percentage of accommodation is not under control of the analyst and it could not coincide exactly with <code>percAccomm</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements if <code>percAccomm</code> is different from 1:
</p>
<p><em>data</em>: Database after preprocessing, with the 1-<code>percAccomm</code> percentage of individuals removed.
</p>
<p><em>indivYes</em>: Individuals who belong to <code>data</code>.
</p>
<p><em>indivNo</em>: Individuals discarded in the accommodation procedure.
</p>
<p>A list with the following elements if <code>percAccomm</code> is equals to 1:
</p>
<p><em>data</em>: Initial database with the same number of observations, which has been standarized depending on the value of <code>stand</code>.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio and Guillermo Vinue
</p>


<h3>References</h3>

<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Genest, M., Masse, J.-C., and Plante, J.-F., (2012). <span class="pkg">depth</span>: Depth functions tools for multivariate analysis. R package version 2.0-0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#As a toy example, only the first 25 individuals are used.
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_inch &lt;- USAFSurvey[1:25, variabl_sel] / (10 * 2.54)

#Data preprocessing:
preproc &lt;- preprocessing(USAFSurvey_inch, TRUE, 0.95, TRUE)
preproc &lt;- preprocessing(USAFSurvey_inch, TRUE, 0.95, FALSE)
</code></pre>

<hr>
<h2 id='projShapes'>
Helper function for plotting the shapes
</h2><span id='topic+projShapes'></span>

<h3>Description</h3>

<p>Helper function for plotting the projections of the shapes. It displays the projection on the xy plane of the recorded points and mean shape for a given cluster. To that end, first it is needed to carry out a generalized Procrustes analysis in the cluster to obtain the full Procrustes rotated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projShapes(clust,array3D,asig,prototypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projShapes_+3A_clust">clust</code></td>
<td>

<p>Cluster for which represent its mean shape together with the recorded points.
</p>
</td></tr>
<tr><td><code id="projShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample points. Each row corresponds to an observation, and each column corresponds to a dimension (x,y,z).
</p>
</td></tr>
<tr><td><code id="projShapes_+3A_asig">asig</code></td>
<td>

<p>Clustering optimal results.
</p>
</td></tr>
<tr><td><code id="projShapes_+3A_prototypes">prototypes</code></td>
<td>

<p>Vector of optimal prototypes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical vector with the percentile values of an archetypoid. 
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 15 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)
#shapes::plotshapes(array3D[,,1]) 
#calibrate::textxy(array3D[,1,1], array3D[,2,1], labs = 1:numLandmarks, cex = 0.7) 

numClust &lt;- 2 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
resLL &lt;- LloydShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, FALSE)
clust_kmeansProc &lt;- resLL$asig

prototypes &lt;- anthrCases(resLL)

projShapes(1, array3D, clust_kmeansProc, prototypes)
#legend("topleft", c("Registrated data", "Mean shape"), pch = 1, col = 1:2, text.col = 1:2)
#title("Procrustes registrated data for cluster 1 \n with its mean shape superimposed", 
#      sub = "Plane xy")
</code></pre>

<hr>
<h2 id='qtranShapes'>
Auxiliary qtran subroutine of the Hartigan-Wong k-means for 3D shapes
</h2><span id='topic+qtranShapes'></span>

<h3>Description</h3>

<p>The Hartigan-Wong version of the k-means algorithm uses two auxiliary algorithms: the optimal transfer stage (optra) and the quick transfer stage (qtran). 
</p>
<p>This function is the qtran subroutine adapted to the shape analysis context. It is used within <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>. See Hartigan and Wong (1979) for details of the original k-means algorithm and Amaral et al. (2010) for details about its adaptation to shape analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtranShapes(array3D,n,c,ic1,ic2,nc,an1,an2,ncp,d,itran,indx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtranShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample objects.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_n">n</code></td>
<td>

<p>Number of sample objects.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_c">c</code></td>
<td>

<p>Array of centroids.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_ic1">ic1</code></td>
<td>

<p>The cluster to each object belongs.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_ic2">ic2</code></td>
<td>

<p>This vector is used to remember the cluster which each object is most likely to be transferred to at each step.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_nc">nc</code></td>
<td>

<p>Number of objects in each cluster.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_an1">an1</code></td>
<td>

<p>$an1(l) = nc(l) / (nc(l) - 1), l=1,...,numClust$, where numClust is the number of clusters.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_an2">an2</code></td>
<td>

<p>$an2(l) = nc(l) / (nc(l) + 1), l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_ncp">ncp</code></td>
<td>

<p>In the optimal transfer stage, ncp(l) stores the step at which cluster l is last updated, $l=1,...,numClust$.<br />
In the quick transfer stage, ncp(l) stores the step at which cluster l is last updated plus n, $l=1,...,numClust$.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_d">d</code></td>
<td>

<p>Vector of distances from each object to every centroid. 
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_itran">itran</code></td>
<td>

<p>itran(l) = 1 if cluster l is updated in the quick-transfer stage (0 otherwise), $l=1,...,k$.
</p>
</td></tr>
<tr><td><code id="qtranShapes_+3A_indx">indx</code></td>
<td>

<p>Number of steps since a transfer took place.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:: <em>c,ic1,ic2,nc,an1,an2,ncp,d,itran,indx,icoun</em>, updated after the optimal transfer stage. Note that <em>icoun</em> counts the steps where a re-allocation took place.
</p>


<h3>Note</h3>

<p>This function belongs to <code><a href="#topic+HartiganShapes">HartiganShapes</a></code> and it is not solely used. That is why there is no section of <em>examples</em> in this help page.
</p>


<h3>Note</h3>

<p>This function is based on the qtran.m file available from <a href="https://github.com/johannesgerer/jburkardt-m/tree/master/asa136">https://github.com/johannesgerer/jburkardt-m/tree/master/asa136</a>.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Hartigan, J. A., and Wong, M. A., (1979). A K-Means Clustering Algorithm, <em>Applied Statistics</em>, 100&ndash;108.
</p>
<p>Amaral, G. J. A., Dore, L. H., Lessa, R. P., and Stosic, B., (2010). k-Means Algorithm in Statistical Shape Analysis, <em>Communications in Statistics - Simulation and Computation</em> <b>39(5)</b>, 1016&ndash;1026.
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HartiganShapes">HartiganShapes</a></code>
</p>

<hr>
<h2 id='sampleSpanishSurvey'>
Sample database of the Spanish anthropometric survey
</h2><span id='topic+sampleSpanishSurvey'></span>

<h3>Description</h3>

<p>This a database for academic and training purposes. It is oriented to exemplify the use of <code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code> and <code><a href="#topic+TDDclust">TDDclust</a></code>. 
</p>
<p>It is made up of 600 women selected randomly from the Spanish anthropometric survey and five anthropometric variables: chest circumference, neck to ground length, waist circumference, hip circumference and bust circumference. These variables have been chosen following the recommendations of experts. In addition, they are commonly used in the literature about sizing system design and they appear in the European standard to sizing system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSpanishSurvey</code></pre>


<h3>Format</h3>

<p>A matrix with 600 rows and 5 columns. Each row corresponds to an observation, and each column corresponds to a variable.</p>


<h3>Source</h3>

<p>Anthropometric survey of the Spanish female population.</p>


<h3>References</h3>

<p>Alemany, S., Gonzalez, J. C., Nacher, B., Soriano, C., Arnaiz, C., and Heras, H., (2010). Anthropometric survey of the Spanish female population aimed at the apparel industry. <em>Proceedings of the 2010 Intl. Conference on 3D Body scanning Technologies</em>, 307&ndash;315.
</p>
<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Vinue, G., and Ibanez, M. V., (2014). <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 2: Primary and secondary dimensions. (2002).
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+TDDclust">TDDclust</a></code>
</p>

<hr>
<h2 id='screeArchetypal'>
Screeplot of archetypal individuals
</h2><span id='topic+screeArchetypal'></span>

<h3>Description</h3>

<p>This function allows us to represent in the same plot the screeplot of the archetypes and the both <em>cand_ns</em>, <em>cand_alpha</em> and <em>cand_beta</em> archetypoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screeArchetypal(numArch,rss_lass_def,rss_step_ns,rss_step_alpha,rss_step_beta,
                ylim,main,xlab,ylab,col=c("red","blue","green3"),axis2,seq,leg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeArchetypal_+3A_numarch">numArch</code></td>
<td>

<p>Number of archetypal observations (archetypes and archetypoids).
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_rss_lass_def">rss_lass_def</code></td>
<td>

<p>Vector of the residual sum of squares (rss) associated with each archetype from 1 to <code>numArch</code>.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_rss_step_ns">rss_step_ns</code></td>
<td>

<p>Vector of the residual sum of squares (rss) associated with each <em>cand_ns</em> archetypoid from 1 to <code>numArch</code>.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_rss_step_alpha">rss_step_alpha</code></td>
<td>

<p>Vector of the residual sum of squares (rss) associated with each <em>cand_alpha</em> archetypoid from 1 to <code>numArch</code>.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_rss_step_beta">rss_step_beta</code></td>
<td>

<p>Vector of the residual sum of squares (rss) associated with each <em>cand_beta</em> archetypoid from 1 to <code>numArch</code>.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_ylim">ylim</code></td>
<td>

<p>The y limits of the plot.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_main">main</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_xlab">xlab</code></td>
<td>

<p>A title for the x axis.  
</p>
</td></tr>  
<tr><td><code id="screeArchetypal_+3A_ylab">ylab</code></td>
<td>

<p>A title for the y axis.  
</p>
</td></tr>  
<tr><td><code id="screeArchetypal_+3A_col">col</code></td>
<td>

<p>Color vector for the screeplots of the archetypoids. Default is c(&quot;red&quot;,&quot;blue&quot;,&quot;green3&quot;).
</p>
</td></tr>  
<tr><td><code id="screeArchetypal_+3A_axis2">axis2</code></td>
<td>

<p>A logical value. If TRUE, the y axis can be customized to have spaced tick-marks by means of the following argument <code>seq</code>.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_seq">seq</code></td>
<td>

<p>Vector sequence with the values of the tick-marks to be drawn in the y axis.
</p>
</td></tr>
<tr><td><code id="screeArchetypal_+3A_leg">leg</code></td>
<td>

<p>If TRUE, a legend is shown.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Cutler, A., and Breiman, L., (1994). Archetypal Analysis, <em>Technometrics</em> <b>36</b>, 338&ndash;347.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>
<p>Eugster, M. J. A., (2012). Performance profiles based on archetypal athletes, <em>International Journal of Performance Analysis in Sport</em> <b>12</b>, 166&ndash;187.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids">archetypoids</a></code>, <code><a href="#topic+stepArchetypoids">stepArchetypoids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#COCKPIT DESIGN PROBLEM:
#The following R code allows us to obtain a similar plot regarding Figure 5 
#of the paper Vinue et al. (2015).
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 2 ; numRep &lt;- 2
lass &lt;- stepArchetypesRawData(data = USAFSurvey_preproc$data, 
                          numArch=1:numArch, numRep = numRep, 
                          verbose = FALSE)
#To understand the warning messages, see the vignette of the
#archetypes package.                            
  
rss_lass &lt;- matrix(0, nrow = numArch, ncol = numRep)
for(i in 1:numArch){
  for(j in 1:numRep){
    rss_lass[i,j] &lt;- lass[[i]][[j]]$rss
  }
}
(rss_lass_def &lt;- apply(rss_lass, 1, min, na.rm = TRUE))

#Run archetypoids algorithm repeatedly from 1 to numArch archetypes:
for(numArchoid in 1:numArch){
  temp &lt;-  stepArchetypoids(numArchoid, nearest = "cand_ns", 
                            USAFSurvey_preproc$data, lass)
  filename &lt;- paste("res_ns", numArchoid, sep = "")
  assign(filename,temp)
  save(list = c(filename), file = paste(filename, ".RData", sep = "")) 
}   

#Run archetypoids algorithm repeatedly from 1 to numArch archetypes:
for(numArchoid in 1:numArch){
  temp &lt;-  stepArchetypoids(numArchoid, nearest = "cand_alpha", 
                            USAFSurvey_preproc$data, lass)
  filename &lt;- paste("res_alpha", numArchoid, sep = "")
  assign(filename,temp)
  save(list = c(filename), file = paste(filename, ".RData", sep = "")) 
}  

#Run archetypoids algorithm repeatedly from 1 to numArch archetypes:
for(numArchoid in 1:numArch){
  temp &lt;-  stepArchetypoids(numArchoid, nearest = "cand_beta", 
                            USAFSurvey_preproc$data, lass)
  filename &lt;- paste("res_beta", numArchoid, sep = "")
  assign(filename,temp)
  save(list = c(filename), file = paste(filename, ".RData", sep = "")) 
}  

#Numerical and graphical results:
#Cand_ns:
for(i in 1:numArch){
  load(paste("res_ns", i, ".RData", sep = ""))
}
rss_step &lt;- c()
for (i in 1:numArch){
  rss_step[i] &lt;- get(paste("res_ns", i, sep = ""))[[2]]
}
(rss_step_ns &lt;- as.numeric(rss_step))

#Cand_alpha:
for(i in 1:numArch){
  load(paste("res_alpha", i, ".RData", sep = ""))
}
rss_step_which &lt;- c()
for (i in 1:numArch){
  rss_step_which[i] &lt;- get(paste("res_alpha", i, sep = ""))[[2]]
}
(rss_step_alpha &lt;- as.numeric(rss_step_which))

#Cand_beta:
for(i in 1:numArch){
  load(paste("res_beta", i, ".RData", sep = ""))
}
rss_step_which &lt;- c()
for (i in 1:numArch){
  rss_step_which[i] &lt;- get(paste("res_beta", i, sep = ""))[[2]]
}
(rss_step_beta &lt;- as.numeric(rss_step_which))

forYlim &lt;- c(rss_lass_def, rss_step_ns, rss_step_alpha, rss_step_beta)
range(forYlim)
#[1] 0.06387125 0.27395811

#main &lt;- "Aircraft pilots archetypes and archetypoids" 
xlab &lt;- "Archetypes/Archetypoids"
ylab &lt;- "RSS"
screeArchetypal(numArch, rss_lass_def, rss_step_ns, rss_step_alpha, rss_step_beta, 
                c(0,0.5), main = "", xlab, ylab, col = c("red","blue","green3"), 
                TRUE, seq(0,0.5,0.1), FALSE)
#rm(res_ns1.RData)
#rm(res_ns2.RData)
#rm(res_alpha1.RData)
#rm(res_alpha2.RData)
#rm(res_beta1.RData)
#rm(res_beta2.RData)

## End(Not run)
</code></pre>

<hr>
<h2 id='shapes3dShapes'>
3D shapes plot
</h2><span id='topic+shapes3dShapes'></span>

<h3>Description</h3>

<p>This function is a slight modification of the original <code>shapes3d</code> function of the <span class="pkg">shapes</span> R package so that the resulting plot has customized title and axes. Specifically, the changing lines regarding the original function are those related to its argument <em>axes3</em> when it is fixed to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes3dShapes(x,loop=0,type="p",color=2,joinline=c(1:1),
               axes3=FALSE,rglopen=TRUE,main=main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapes3dShapes_+3A_x">x</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_loop">loop</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_type">type</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_color">color</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_joinline">joinline</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_axes3">axes3</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_rglopen">rglopen</code></td>
<td>

<p>See <code>shapes3d</code>.
</p>
</td></tr>
<tr><td><code id="shapes3dShapes_+3A_main">main</code></td>
<td>

<p>Allows us to give the plot a title if axes3=TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>References</h3>

<p>Dryden, I. L., (2012). <span class="pkg">shapes</span> package. R Foundation for Statistical Computing, Vienna, Austria. Contributed package.
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>


<h3>See Also</h3>

<p><code>shapes3d</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 10 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)
#shapes::plotshapes(array3D[,,1]) 
#calibrate::textxy(array3D[,1,1], array3D[,2,1], labs = 1:numLandmarks, cex = 0.7) 

numClust &lt;- 2 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
resLL &lt;- LloydShapes(array3D, numClust, algSteps, niter, stopCr, FALSE, FALSE)

prototypes &lt;- anthrCases(resLL)

shapes3dShapes(prototypes[,,1], loop = 0, type = "p", color = 2, joinline = c(1:1), 
            axes3 = TRUE, rglopen = TRUE, main = "Mean shape cluster 1")

## End(Not run)            
</code></pre>

<hr>
<h2 id='skeletonsArchetypal'>
Skeleton plot of archetypal individuals
</h2><span id='topic+skeletonsArchetypal'></span>

<h3>Description</h3>

<p>This function represents the skeleton plots of the archetypal observations (archetypes and archetypoids) of <code><a href="#topic+USAFSurvey">USAFSurvey</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeletonsArchetypal(measuArch,main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeletonsArchetypal_+3A_measuarch">measuArch</code></td>
<td>

<p>Vector with the measurements of each archetype.
</p>
</td></tr>
<tr><td><code id="skeletonsArchetypal_+3A_main">main</code></td>
<td>

<p>The title of the plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Note</h3>

<p>This function allows us to reproduce the archetypes of Figure 5 of Epifanio et al. (2013), see <code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code>.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code>, <code><a href="#topic+USAFSurvey">USAFSurvey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#List with the measurements of each archetype (Table 7 of Epifanio et al (2013)):
lista_arch &lt;- list()
lista_arch[[1]] &lt;- c(34.18, 25.85, 18.65, 39.66, 35.05, 26.73)
lista_arch[[2]] &lt;- c(28.51, 21.23, 15.39, 33.57, 29.24, 21.26)
lista_arch[[3]] &lt;- c(35.34, 24.94, 18.79, 36.7, 32.28, 23.41)
lista_arch[[4]] &lt;- c(31.34, 22.27, 16.89, 38, 33.08, 25.8)
lista_arch[[5]] &lt;- c(32.33, 25.09, 17.84, 34.46, 29.58, 22.82)
lista_arch[[6]] &lt;- c(29.69, 24.18, 18.22, 38.07, 33.04, 24.56)
lista_arch[[7]] &lt;- c(29.24, 22.97, 14.99, 36.88, 32.28, 24.22)

for(i in 1:length(lista_arch)){
 titlePlot &lt;- paste("Archetype", i, sep = " ")
 skeletonsArchetypal(lista_arch[[i]],titlePlot)
}

#Note: For an example for archetypoids, see www.uv.es/vivigui/softw/more_examples.R 
</code></pre>

<hr>
<h2 id='stepArchetypesRawData'>
Archetype algorithm to raw data
</h2><span id='topic+stepArchetypesRawData'></span>

<h3>Description</h3>

<p>This is a slight modification of the original <code>stepArchetypes</code> function of the <span class="pkg">archetypes</span> R package to apply the archetype algorithm to raw data. The <code>stepArchetypes</code> function standardizes the data by default and this option is not always desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypesRawData(data,numArch,numRep=3,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypesRawData_+3A_data">data</code></td>
<td>

<p>Data to obtain archetypes.
</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_+3A_numarch">numArch</code></td>
<td>

<p>Number of archetypes to compute, from 1 to <code>numArch</code>.
</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_+3A_numrep">numRep</code></td>
<td>

<p>For each <code>numArch</code>, run <code>archetypes</code> <code>numRep</code> times.
</p>
</td></tr>
<tr><td><code id="stepArchetypesRawData_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, the progress during execution is shown.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>numArch</code> elements. Each element is a list of class attribute <code>stepArchetypes</code> with <code>numRep</code> elements.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue based on the the original <code>stepArchetypes</code> function of <span class="pkg">archetypes</span>.
</p>


<h3>References</h3>

<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>
<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>


<h3>See Also</h3>

<p><code>stepArchetypes</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#COCKPIT DESIGN PROBLEM:
#As a toy example, only the first 25 individuals are used.
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 5 ; numRep &lt;- 2
lass &lt;- stepArchetypesRawData(data = USAFSurvey_preproc$data, numArch = 1:numArch,
                              numRep = numRep, verbose = FALSE) 
#To understand the warning messages, see the vignette of the
#archetypes package.                                
</code></pre>

<hr>
<h2 id='stepArchetypoids'>
Run the archetypoid algorithm several times
</h2><span id='topic+stepArchetypoids'></span>

<h3>Description</h3>

<p>Execute the archetypoid algorithm repeatedly. It is inspired by the <code>stepArchetypes</code> function of the <span class="pkg">archetypes</span> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepArchetypoids(numArchoid,nearest="cand_ns",data,ArchObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepArchetypoids_+3A_numarchoid">numArchoid</code></td>
<td>

<p>Number of archetypoids.
</p>
</td></tr>
<tr><td><code id="stepArchetypoids_+3A_nearest">nearest</code></td>
<td>

<p>Initial vector of archetypoids for the BUILD phase of the archetypoid algorithm. This initial vector contain the nearest individuals to the archetypes returned by the <code>archetypes</code> function of <span class="pkg">archetypes</span> (In Vinue et al. (2015), archetypes are computed after running the archetype algorithm twenty times). This argument is a string vector with three different possibilities. The first and default option is &quot;cand_ns&quot; and allows us to calculate the nearest individuals by computing the Euclidean distance between the archetypes and the individuals and choosing the nearest. It is used in Epifanio et al. (2013). The second option is &quot;cand_alpha&quot; and allows us to calculate the nearest individuals by consecutively identifying the individual with the maximum value of alpha for each archetype, until the defined number of archetypes is reached. It is used in Eugster (2012). The third and final option is &quot;cand_beta&quot; and allows us to calculate the nearest individuals by identifying the individuals with the maximum beta value for each archetype, i.e. the major contributors in the generation of the archetypes.
</p>
</td></tr>
<tr><td><code id="stepArchetypoids_+3A_data">data</code></td>
<td>

<p>Data matrix. Each row corresponds to an observation and each column corresponds to an anthropometric variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="stepArchetypoids_+3A_archobj">ArchObj</code></td>
<td>

<p>The list object returned by the <code><a href="#topic+stepArchetypesRawData">stepArchetypesRawData</a></code> function. This function is a slight modification of the original <code>stepArchetypes</code> function of <span class="pkg">archetypes</span> to apply the archetype algorithm to raw data. The <code>stepArchetypes</code> function standardizes the data by default and this option is not always desired. This list is needed to compute the nearest individuals to archetypes. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>cases</em>: Anthropometric cases (final vector of <code>numArchoid</code> archetypoids).
</p>
<p><em>rss</em>: Residual sum of squares corresponding to the final vector of <code>numArchoid</code> archetypoids.
</p>
<p><em>archet_ini</em>: Vector of initial archetypoids (<em>cand_ns</em>, <em>cand_alpha</em> or <em>cand_beta</em>).
</p>
<p><em>alphas</em>: Alpha coefficients for the optimal vector of archetypoids.
</p>


<h3>Note</h3>

<p>It may be happen that <code>archetypes</code> does not find results for <em>k</em> archetypes. In this case, it is not possible to calculate the vector of nearest individuals and consequently, the vector of archetypoids. Therefore, this function will return an error message. 
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio and Guillermo Vinue
</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Cutler, A., and Breiman, L., (1994). Archetypal Analysis, <em>Technometrics</em> <b>36</b>, 338&ndash;347.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>
<p>Eugster, M. J., and Leisch, F., (2009). From Spider-Man to Hero - Archetypal Analysis in R, <em>Journal of Statistical Software</em> <b>30</b>, 1&ndash;23, doi: <a href="https://doi.org/10.18637/jss.v030.i08">10.18637/jss.v030.i08</a>.
</p>
<p>Eugster, M. J. A., (2012). Performance profiles based on archetypal athletes, <em>International Journal of Performance Analysis in Sport</em> <b>12</b>, 166&ndash;187.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypoids">archetypoids</a></code>, <code>archetypes</code>, <code>stepArchetypes</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#COCKPIT DESIGN PROBLEM:
#As a toy example, only the first 25 individuals are used.
USAFSurvey_First25 &lt;- USAFSurvey[1:25, ]
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_First25_inch &lt;- USAFSurvey_First25[,variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_First25_inch, TRUE, 0.95, TRUE)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010) 
#Run archetype algorithm repeatedly from 1 to numArch archetypes:
#This is a toy example. In other situation, choose numArch=10 and numRep=20.
numArch &lt;- 2 ; numRep &lt;- 2
lass &lt;- stepArchetypesRawData(data = USAFSurvey_preproc$data, numArch = 1:numArch,
                              numRep = numRep, verbose = FALSE) 
#To understand the warning messages, see the vignette of the
#archetypes package.                                

#Run archetypoids algorithm repeatedly from 1 to numArch archetypes:
#for(numArchoid in 1:numArch){
# temp &lt;-  stepArchetypoids(numArchoid,nearest="cand_ns",USAFSurvey_preproc$data,lass)
# filename &lt;- paste("res", numArchoid, sep="")
# assign(filename,temp)
# save(list=c(filename),file=paste(filename, ".RData", sep="")) 
#}
temp &lt;-  stepArchetypoids(2,nearest="cand_ns",USAFSurvey_preproc$data,lass)
</code></pre>

<hr>
<h2 id='TDDclust'>
Trimmed clustering based on L1 data depth
</h2><span id='topic+TDDclust'></span>

<h3>Description</h3>

<p>This is the trimmed version of the clustering algorithm based on the L1 depth proposed by Rebecka Jornsten (2004).  She segments all the observations in clusters, and assigns to each point z in the data space, the L1 depth value regarding its cluster. A trimmed procedure is incorporated to remove the more extreme individuals of each cluster (those one with the lowest depth values), in line with <code><a href="#topic+trimowa">trimowa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TDDclust(data,numClust,lambda,Th,niter,T0,simAnn,alpha,data1,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TDDclust_+3A_data">data</code></td>
<td>

<p>Data frame. Each row corresponds to an observation, and each column corresponds to a variable. All variables must be numeric.
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters. 
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_lambda">lambda</code></td>
<td>

<p>Tuning parameter that controls the influence the data depth has over the clustering, see Jornsten (2004).
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_th">Th</code></td>
<td>

<p>Threshold for observations to be relocated, usually set to 0.
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations).
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_t0">T0</code></td>
<td>

<p>Simulated annealing parameter. It is the current temperature in the simulated annealing procedure.
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_simann">simAnn</code></td>
<td>

<p>Simulated annealing parameter. It is the decay rate, default 0.9. 
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_alpha">alpha</code></td>
<td>

<p>Proportion of trimmed sample.
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_data1">data1</code></td>
<td>

<p>The same data frame as <em>data</em>, used to incorporate the trimmed observations into the rest of them for the next iteration. 
</p>
</td></tr>
<tr><td><code id="TDDclust_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process. Default TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>NN</em>: Cluster assignment, NN[1,] is the final partition. 
</p>
<p><em>cases</em>: Anthropometric cases (the multivariate median cluster representatives). 
</p>
<p><em>DD</em>: Depth values of the observations (only if there are trimmed observations).
</p>
<p><em>Cost</em>: Final value of the optimal partition.
</p>
<p><em>discarded</em>: Discarded (trimmed) observations.
</p>
<p><em>klBest</em>: Iteration in which the optimal partition was found.
</p>


<h3>Author(s)</h3>

<p>This function has been defined from the original functions developed by Rebecka Jornsten, which were available freely on
http://www.stat.rutgers.edu/home/rebecka/DDcl/. However, the link to this page doesn't currently exist as a result of a website redesign. 
</p>


<h3>References</h3>

<p>Jornsten R., (2004). Clustering and classification based on the L1 data depth, <em>Journal of Multivariate Analysis</em> <b>90</b>, 67&ndash;89
</p>
<p>Vinue, G., and Ibanez, M. V., (2014). <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the interests of simplicity of the computation involved, only 15 points are selected:
dataTDDcl &lt;- sampleSpanishSurvey[1 : 15, c(2, 3, 5)]  
dataTDDcl_aux &lt;- sampleSpanishSurvey[1 : 15, c(2, 3, 5)]

numClust &lt;- 3 ; alpha &lt;- 0.01 ; lambda &lt;- 0.5 ; niter &lt;- 2
Th &lt;- 0 ; T0 &lt;- 0 ; simAnn &lt;- 0.9  

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
res_TDDcl &lt;- TDDclust(dataTDDcl, numClust, lambda, Th, niter, T0, simAnn, 
                      alpha, dataTDDcl_aux,FALSE) 

prototypes &lt;- anthrCases(res_TDDcl)

table(res_TDDcl$NN[1,]) 
res_TDDcl$Cost
res_TDDcl$klBest

trimmed &lt;- trimmOutl(res_TDDcl)
</code></pre>

<hr>
<h2 id='trimmedLloydShapes'>
Trimmed Lloyd k-means for 3D shapes
</h2><span id='topic+trimmedLloydShapes'></span>

<h3>Description</h3>

<p>The basic foundation of k-means is that the sample mean is the value that minimizes the Euclidean distance from each point, to the centroid of the cluster to which it belongs. Two fundamental concepts of the statistical shape analysis are the Procrustes mean and the Procrustes distance. Therefore, by integrating the Procrustes mean and the Procrustes distance we can use k-means in the shape analysis context. 
</p>
<p>The k-means method has been proposed by several scientists in different forms. In computer science and pattern recognition the k-means algorithm is often termed the Lloyd algorithm (see Lloyd (1982)). 
</p>
<p>This function is proposed to incorporate a modification to <code><a href="#topic+LloydShapes">LloydShapes</a></code> in order to make the k-means algorithm robust. Robustness is a property very desirable in a lot of applications. As it is well known, the results of the k-means algorithm can be influenced by outliers and extreme data, or bridging points between clusters. Garcia-Escudero et al. (1999) propose a way of making k-means more robust, which combines the k-means idea with an impartial trimming procedure: a proportion alpha (between 0 and 1) of observations are trimmed (the trimmed observations are self-determined by the data). See also <code><a href="#topic+trimmedoid">trimmedoid</a></code>.
</p>
<p>Note that in the generic name of the k-means algorithm, k refers to the number of clusters to search for. To be more specific in the R code, k is referred to as <code>numClust</code>, see next section <em>arguments</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimmedLloydShapes(array3D,n,alpha,numClust,algSteps=10,niter=10,
                   stopCr=0.0001,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimmedLloydShapes_+3A_array3d">array3D</code></td>
<td>

<p>Array with the 3D landmarks of the sample objects. Each row corresponds to an observation, and each column corresponds to a dimension (x,y,z).
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_n">n</code></td>
<td>

<p>Number of individuals.
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_alpha">alpha</code></td>
<td>

<p>Proportion of trimmed sample.
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_algsteps">algSteps</code></td>
<td>

<p>Number of steps per initialization. Default value is 10.
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations). Default value is 10.
</p>
</td></tr> 
<tr><td><code id="trimmedLloydShapes_+3A_stopcr">stopCr</code></td>
<td>

<p>Relative stopping criteria. Default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="trimmedLloydShapes_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>asig</em>: Optimal clustering.
</p>
<p><em>cases</em>: Anthropometric cases (optimal centers).
</p>
<p><em>vopt</em>: Optimal objective function.
</p>
<p><em>trimmWomen</em>: List to save the trimmed individual of each iteration.
</p>
<p><em>trimmsIter</em>: Vector with the number of iterations where the optimum was reached. The last number different from NA refers to the last iteration where the final optimum was reached.
</p>
<p><em>bestNstep</em>: Nstep of the iteration where the optimum has reached.
</p>
<p><em>initials</em>: Random initial values used in each iteration. These values can be used by <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>.
</p>
<p><em>discarded</em>: Discarded (trimmed) observations.
</p>


<h3>Note</h3>

<p>We note that adding a trimmed procedure to the Lloyd algorithm is very direct and easy, while for the Hartigan-Wong algorithm, more modifications of the algorithm are needed, which makes the implementation of its trimmed version difficult.
</p>


<h3>Author(s)</h3>

<p>Amelia Simo
</p>


<h3>References</h3>

<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Lloyd, S. P., (1982). Least Squares Quantization in PCM, <em>IEEE Transactions on Information Theory</em> <b>28</b>, 129&ndash;137.
</p>
<p>Dryden, I. L., and Mardia, K. V., (1998). <em>Statistical Shape Analysis</em>, Wiley, Chichester.
</p>
<p>Garcia-Escudero, L. A., Gordaliza, A., and Matran, C., (2003). Trimming tools in exploratory data analysis, <em>Journal of Computational and Graphical Statistics</em> <b>12(2)</b>, 434&ndash;449.
</p>
<p>Garcia-Escudero, L. A., and Gordaliza, A., (1999). Robustness properties of k-means and trimmed k-means, <em>Journal of the American Statistical Association</em> <b>94(447)</b>, 956&ndash;969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+trimmedoid">trimmedoid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#CLUSTERING INDIVIDUALS ACCORDING TO THEIR SHAPE:
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 10 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)

numClust &lt;- 2 ; alpha &lt;- 0.01 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
res &lt;- trimmedLloydShapes(array3D, numIndiv, alpha, numClust, 
                          algSteps, niter, stopCr, FALSE)

#Optimal partition and prototypes:
clust &lt;- res$asig 
table(clust)
prototypes &lt;- anthrCases(res)

#Trimmed individuals:
trimmed &lt;- trimmOutl(res)
</code></pre>

<hr>
<h2 id='trimmedoid'>
Trimmed k-medoids algorithm
</h2><span id='topic+trimmedoid'></span>

<h3>Description</h3>

<p>This is the trimmed k-medoids algorithm. It is used within <code><a href="#topic+trimowa">trimowa</a></code>. It is analogous to k-medoids but a proportion alpha of observations is discarded by the own procedure (the trimmed observations are self-determined by the data). Furthermore, the trimmed k-medoids is analogous to trimmed k-means. An algorithm for computing trimmed k-means can be found in Garcia-Escudero et al. (2003). See Ibanez et al. (2012) for more details. Note that in the generic name of the k-medoids algorithm, k refers to the number of clusters to search for. To be more specific in the R code, k is referred to as <code>numClust</code>, see next section <em>arguments</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimmedoid(D,numClust,alpha,niter,algSteps=7,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimmedoid_+3A_d">D</code></td>
<td>

<p>Dissimilarity matrix.
</p>
</td></tr>
<tr><td><code id="trimmedoid_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="trimmedoid_+3A_alpha">alpha</code></td>
<td>

<p>Proportion of trimmed sample.
</p>
</td></tr>
<tr><td><code id="trimmedoid_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations).
</p>
</td></tr>
<tr><td><code id="trimmedoid_+3A_algsteps">algSteps</code></td>
<td>

<p>Number of steps of the algorithm per initialization. Default value is 7.
</p>
</td></tr>
<tr><td><code id="trimmedoid_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>vopt</em>: The objective value.
</p>
<p><em>copt</em>: The trimmed medoids.
</p>
<p><em>asig</em>: The assignation of each observation (asig=0 indicates trimmed individuals).
</p>
<p><em>ch</em>:   The goodness index.
</p>
<p><em>Dmod</em>: Modified data with the non-trimmed women.
</p>
<p><em>qq</em>: Vector with the non-trimmed points.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Garcia-Escudero, L. A., Gordaliza, A., and Matran, C., (2003). Trimming tools in exploratory data analysis, <em>Journal of Computational and Graphical Statistics</em> <b>12(2)</b>, 434&ndash;449.
</p>
<p>Garcia-Escudero, L. A., and Gordaliza, A., (1999). Robustness properties of k-means and trimmed k-means, <em>Journal of the American Statistical Association</em> <b>94(447)</b>, 956&ndash;969.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>, <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>, <code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data loading:
dataTrimowa &lt;- sampleSpanishSurvey
bust &lt;- dataTrimowa$bust
#First bust class:
data &lt;- dataTrimowa[(bust &gt;= 74) &amp; (bust &lt; 78), ]   
numVar &lt;- dim(dataTrimowa)[2]

#Weights calculation:
orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness,numVar)

#Constants required to specify the distance function:
numClust &lt;- 3
bh &lt;- (apply(as.matrix(log(data)),2,range)[2,] 
       - apply(as.matrix(log(data)),2,range)[1,]) / ((numClust-1) * 8) 
bl &lt;- -3 * bh
ah &lt;- c(23,28,20,25,25)
al &lt;- 3 * ah

#Data processing.
num.persons &lt;- dim(data)[1]
num.variables &lt;- dim(data)[2]
datam &lt;- as.matrix(data)
datat &lt;- aperm(datam, c(2,1))                     
dim(datat) &lt;- c(1,num.persons * num.variables)   

#Dissimilarity matrix:
D &lt;- getDistMatrix(datat, num.persons, numVar, weightsTrimowa, bl, bh, al, ah, FALSE)

res_trimm &lt;- trimmedoid(D, numClust, 0.01, 6, 7, FALSE)
</code></pre>

<hr>
<h2 id='trimmOutl'>
Helper generic function for obtaining the trimmed and outlier observations
</h2><span id='topic+trimmOutl'></span><span id='topic+trimmOutl.default'></span><span id='topic+trimmOutl.trimowa'></span><span id='topic+trimmOutl.hipamAnthropom'></span>

<h3>Description</h3>

<p>The methodologies included in this package which are developed to the clothing design problem take into account that a clothing sizing system is intended to cover only what we could call standard population, leaving out those individuals who are extreme respect to a set of measurements. For &quot;trimowa&quot;, &quot;TDDclust and &quot;kmeansProcrustes&quot; (which refers to as <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code> in this case) these individuals are called trimmed individuals. For the &quot;hipamAnthropom&quot; methodology these individuals are called outlier individuals.
</p>
<p>This auxiliary generic function allows the user to identify the discarded individuals computed by each method in an easy way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimmOutl(resMethod, nsizes)
## S3 method for class 'trimowa'
 trimmOutl(resMethod, nsizes)
## S3 method for class 'hipamAnthropom'
 trimmOutl(resMethod, nsizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimmOutl_+3A_resmethod">resMethod</code></td>
<td>

<p>This is the object which saves the results obtained by the aforementioned methodologies and which contains the discarded individuals to return.
</p>
</td></tr>
<tr><td><code id="trimmOutl_+3A_nsizes">nsizes</code></td>
<td>

<p>Number of bust sizes. This argument is needed for the &quot;trimowa&quot; and &quot;hipamAnthropom&quot; methodologies because they can compute the prototypes for any given number of bust sizes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code>trimmOutl</code> with the discarded observations.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Vinue, G., Simo, A., and Alemany, S., (2016). The k-means algorithm for 3D shapes with an application to apparel design, <em>Advances in Data Analysis and Classification</em> <b>10(1)</b>, 103&ndash;132.
</p>
<p>Vinue, G., and Ibanez, M. V., (2014). <em>Data depth and Biclustering applied to anthropometric data. Exploring their utility in apparel design</em>. Technical report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+TDDclust">TDDclust</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>, <code><a href="#topic+LloydShapes">LloydShapes</a></code>, <code><a href="#topic+HartiganShapes">HartiganShapes</a></code>, <code><a href="#topic+trimmedLloydShapes">trimmedLloydShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#CLUSTERING INDIVIDUALS ACCORDING TO THEIR SHAPE:
landmarksNoNa &lt;- na.exclude(landmarksSampleSpaSurv)
dim(landmarksNoNa) 
#[1] 574 198 
numLandmarks &lt;- (dim(landmarksNoNa)[2]) / 3
#[1] 66
#As a toy example, only the first 10 individuals are used.
landmarksNoNa_First10 &lt;- landmarksNoNa[1:10, ] 
(numIndiv &lt;- dim(landmarksNoNa_First10)[1])
#[1] 10         
    
array3D &lt;- array3Dlandm(numLandmarks, numIndiv, landmarksNoNa_First10)

numClust &lt;- 2 ; alpha &lt;- 0.01 ; algSteps &lt;- 1 ; niter &lt;- 1 ; stopCr &lt;- 0.0001
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2013)
res_kmeansProc &lt;- trimmedLloydShapes(array3D, numIndiv, alpha, numClust, 
                                     algSteps, niter, stopCr, FALSE)

trimmed &lt;- trimmOutl(res_kmeansProc)
</code></pre>

<hr>
<h2 id='trimowa'>
Trimmed PAM with OWA operators
</h2><span id='topic+trimowa'></span>

<h3>Description</h3>

<p>This is the methodology developed in Ibanez et al. (2012) to define an efficient apparel sizing system based on clustering techniques jointly with OWA operators. In our approach, we apply the trimmed k-medoids algorithm (<code><a href="#topic+trimmedoid">trimmedoid</a></code>) to the first twelve bust classes according to the sizes defined in the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimowa(data,w,numClust,alpha,niter,algSteps,ah=c(23,28,20,25,25),verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimowa_+3A_data">data</code></td>
<td>

<p>Data frame. In our approach, this is each of the subframes originated after segmenting the whole anthropometric Spanish survey into twelve bust segments, according to the European standard on sizing systems. Size designation of clothes. Part 3: Measurements and intervals. Each row corresponds to an observation, and each column corresponds to a variable. All variables are numeric.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_w">w</code></td>
<td>

<p>The aggregation weights of the OWA operators. They are computed with the <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_alpha">alpha</code></td>
<td>

<p>Proportion of trimmed sample.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_niter">niter</code></td>
<td>

<p>Number of random initializations (iterations).
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_algsteps">algSteps</code></td>
<td>

<p>Number of steps of the algorithm per initialization. Default value is 7.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_ah">ah</code></td>
<td>

<p>Constants that define the <code>ah</code> slopes of the distance function in <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>. Given the five variables considered, this vector is c(23,28,20,25,25). This vector would be different according to the variables considered.
</p>
</td></tr>
<tr><td><code id="trimowa_+3A_verbose">verbose</code></td>
<td>

<p>A logical specifying whether to provide descriptive output about the running process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><em>cases</em>: Anthropometric cases (medoids of the clusters). They are the prototypes obtained for each bust class.
</p>
<p><em>numTrim</em>: Number of trimmed individuals in each bust class.
</p>
<p><em>numClass</em>: Number of individuals in each bust class.
</p>
<p><em>noTrim</em>: Number of of non-trimmed individuals.
</p>
<p><em>C1,C2,C3,C4</em>: Required constant values to define the distance <code><a href="#topic+getDistMatrix">getDistMatrix</a></code> (<em>C1</em> is bh, <em>C2</em> is bl, <em>C3</em> is ah and <em>C4</em> is al).
</p>
<p><em>asig</em>: Vector of the clusters to which each individual belongs.
</p>
<p><em>discarded</em>: Discarded (trimmed) individuals.
</p>


<h3>Author(s)</h3>

<p>Guillermo Vinue
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>European Committee for Standardization. Size designation of clothes. Part 3: Measurements and intervals. (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleSpanishSurvey">sampleSpanishSurvey</a></code>, <code><a href="#topic+weightsMixtureUB">weightsMixtureUB</a></code>, <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>, <code><a href="#topic+trimmedoid">trimmedoid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#FOR THE SIZES DEFINED BY THE EUROPEAN NORMATIVE:
dataTrimowa &lt;- sampleSpanishSurvey
numVar &lt;- dim(dataTrimowa)[2]
bust &lt;- dataTrimowa$bust
bustSizes &lt;- bustSizesStandard(seq(74, 102, 4), seq(107, 131, 6))

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness, numVar)

numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(23, 28, 20, 25, 25)

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
numSizes &lt;- 2
res_trimowa &lt;- computSizesTrimowa(dataTrimowa, bust, bustSizes$bustCirc, numSizes,
                                  weightsTrimowa, numClust, alpha, niter, algSteps, 
                                  ah, FALSE)
prototypes &lt;- anthrCases(res_trimowa, numSizes)

#FOR ANY OTHER DEFINED SIZE:
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(1900)
rand &lt;- sample(1:600,20)
dataComp &lt;- sampleSpanishSurvey[rand, c(2, 3, 5)]
numVar &lt;- dim(dataComp)[2]

orness &lt;- 0.7
weightsTrimowa &lt;- weightsMixtureUB(orness, numVar)
numClust &lt;- 3 ; alpha &lt;- 0.01 ; niter &lt;- 10 ; algSteps &lt;- 7
ah &lt;- c(28, 25, 25) 

#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2014)
res_trimowa &lt;- trimowa(dataComp, weightsTrimowa, numClust, alpha, niter, 
                            algSteps, ah, verbose = FALSE)
class(res_trimowa) &lt;- "trimowa"
prototypes &lt;- anthrCases(res_trimowa, 1)
</code></pre>

<hr>
<h2 id='USAFSurvey'>
USAF 1967 survey 
</h2><span id='topic+USAFSurvey'></span>

<h3>Description</h3>

<p>This data set comes from the 1967 United States Air Force (USAF) survey. The 1967 USAF survey was conducted during the first three months of 1967 under the direction of the Anthropology Branch of the Aerospace Medical Research Laboratory, located in Ohio. Subjects were measured at 17 Air Force bases across the United States of America. A total of 202 variables (including body dimensions and background variables) were taken on 2420 Air Force personnel between 21 and 50 years of age. 
</p>
<p>Please find in www.uv.es/vivigui/softw/data_information.zip some files that provide a detailed information about this database. Please note that in this documentation 24 variable names are excluded (Vars 9-11, 28, 76-95). 
</p>
<p>In Epifanio et al. (2013), the column numbers selected were c(48,40,39,33,32) and correspond to 'Thumb tip reach', 'Buttock-Knee length', 'Popliteal height sitting', 'Sitting height', 'Eye height sitting' and 'Shoulder height sitting'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USAFSurvey</code></pre>


<h3>Format</h3>

<p>A matrix with 2420 rows and 202 columns. Each row corresponds to an observation, and each column corresponds to a variable.</p>


<h3>Source</h3>

<p>1967 United States Air Force (USAF) survey.</p>


<h3>References</h3>

<p>Vinue, G., Epifanio, I., and Alemany, S., (2015). Archetypoids: a new approach to define representative archetypal data, <em>Computational Statistics and Data Analysis</em> <b>87</b>, 102&ndash;115.
</p>
<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>

<hr>
<h2 id='weightsMixtureUB'>
Calculation of the weights for the OWA operators
</h2><span id='topic+weightsMixtureUB'></span>

<h3>Description</h3>

<p>This function calculates the weights of the OWA operators. They can be used to adjust the compromise between the style of garments and the general comfort sensation of wearers. This function is used both in <code><a href="#topic+trimowa">trimowa</a></code> and <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsMixtureUB(orness,numVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightsMixtureUB_+3A_orness">orness</code></td>
<td>

<p>Quantity to measure the degree to which the aggregation is like a min or max operation.
</p>
</td></tr>
<tr><td><code id="weightsMixtureUB_+3A_numvar">numVar</code></td>
<td>

<p>Number of variables of the database.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the weights.
</p>


<h3>Author(s)</h3>

<p>Guillermo Ayala
</p>


<h3>References</h3>

<p>Ibanez, M. V., Vinue, G., Alemany, S., Simo, A., Epifanio, I., Domingo, J., and Ayala, G., (2012). Apparel sizing using trimmed PAM and OWA operators, <em>Expert Systems with Applications</em> <b>39</b>, 10512&ndash;10520.
</p>
<p>Vinue, G., Leon, T., Alemany, S., and Ayala, G., (2014). Looking for representative fit models for apparel sizing, <em>Decision Support Systems</em> <b>57</b>, 22&ndash;33.
</p>
<p>Leon, T., Zuccarello, P., Ayala, G., de Ves, E., and Domingo, J., (2007), Applying logistic regression to relevance feedback in image retrieval systems, <em>Pattern Recognition</em> <b>40</b>, 2621&ndash;2632.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="#topic+getDistMatrix">getDistMatrix</a></code>, <code><a href="#topic+trimowa">trimowa</a></code>, <code><a href="#topic+hipamAnthropom">hipamAnthropom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numVar &lt;- dim(sampleSpanishSurvey)[2]
orness &lt;- 0.7
w &lt;- weightsMixtureUB(orness,numVar)
</code></pre>

<hr>
<h2 id='xyplotPCArchetypes'>
PC scores for archetypes
</h2><span id='topic+xyplotPCArchetypes'></span>

<h3>Description</h3>

<p>This function is a small modification of the generic <code>xyplot</code> function  of the <span class="pkg">archetypes</span> R package. It shows the scores for the principal components of all individuals jointly with the scores for the computed archetypes. This function is used to obtain the Figure 4 of the subsection 3.3 of Epifanio et al. (2013).
</p>


<h3>Value</h3>

<p>A device with the desired plot.
</p>


<h3>Note</h3>

<p>There are no usage and arguments sections in this help file because they are the same than those of the page 25 of the reference manual of <span class="pkg">archetypes</span>.
</p>


<h3>Author(s)</h3>

<p>Irene Epifanio
</p>


<h3>References</h3>

<p>Epifanio, I., Vinue, G., and Alemany, S., (2013). Archetypal analysis: contributions for estimating boundary cases in multivariate accommodation problem, <em>Computers &amp; Industrial Engineering</em> <b>64</b>, 757&ndash;765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archetypesBoundary">archetypesBoundary</a></code>, <code><a href="#topic+USAFSurvey">USAFSurvey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#First,the USAF 1967 database is read and preprocessed (Zehner et al. (1993)).
#Variable selection:
variabl_sel &lt;- c(48, 40, 39, 33, 34, 36)
#Changing to inches: 
USAFSurvey_inch &lt;- USAFSurvey[1:25, variabl_sel] / (10 * 2.54)

#Data preprocessing:
USAFSurvey_preproc &lt;- preprocessing(USAFSurvey_inch, TRUE, 0.95, TRUE)

#Procedure and results shown in section 2.2.2 and section 3.1:
#For reproducing results, seed for randomness:
#suppressWarnings(RNGversion("3.5.0"))
#set.seed(2010)
res &lt;- archetypesBoundary(USAFSurvey_preproc$data, 15, FALSE, 3)
#To understand the warning messages, see the vignette of the
#archetypes package.  

a3 &lt;- archetypes::bestModel(res[[3]])
a7 &lt;- archetypes::bestModel(res[[7]])

pznueva &lt;- prcomp(USAFSurvey_preproc$data, scale = TRUE, retx = TRUE) 
#PCA scores for 3 archetypes:
p3 &lt;- predict(pznueva,archetypes::parameters(a3)) 
#PCA scores for 7 archetypes:
p7 &lt;- predict(pznueva,archetypes::parameters(a7))
#Representing the scores:
#Figure 4 (a):
xyplotPCArchetypes(p3[,1:2], pznueva$x[,1:2], data.col = gray(0.7), 
                   atypes.col = 1, atypes.pch = 15)
#Figure 4 (b):
xyplotPCArchetypes(p7[,1:2], pznueva$x[,1:2], data.col = gray(0.7), 
                   atypes.col = 1, atypes.pch = 15)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
