<!DOCTYPE html><html lang="en"><head><title>Help for package bWGR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bWGR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bWGR-package'>
<p>Bayesian Whole-Genome Regression</p></a></li>
<li><a href='#Dataset'>
<p>Tetra-seed Pods</p></a></li>
<li><a href='#WGR1+20+28MC+29'>
<p>MCMC Whole-genome Regression</p></a></li>
<li><a href='#WGR2+20+28EM+29'>
<p>Expectation-Maximization WGR</p></a></li>
<li><a href='#WGR3+20+28MV+29'>
<p>Multivariate Regression</p></a></li>
<li><a href='#XTRA+201'>
<p>Mixed model solver</p></a></li>
<li><a href='#XTRA+202'>
<p>Additional tools</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Whole-Genome Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.13</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alencar Xavier &lt;alenxav@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Whole-genome regression methods on Bayesian framework fitted via EM
    or Gibbs sampling, single step (&lt;<a href="https://doi.org/10.1534%2Fg3.119.400728">doi:10.1534/g3.119.400728</a>&gt;), 
    univariate and multivariate (&lt;<a href="https://doi.org/10.1186%2Fs12711-022-00730-w">doi:10.1186/s12711-022-00730-w</a>&gt;, &lt;<a href="https://doi.org/10.1093%2Fgenetics%2Fiyae179">doi:10.1093/genetics/iyae179</a>&gt;),
    with optional kernel term and sampling techniques (&lt;<a href="https://doi.org/10.1186%2Fs12859-017-1582-3">doi:10.1186/s12859-017-1582-3</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-05 17:09:55 UTC; rd7564</td>
</tr>
<tr>
<td>Author:</td>
<td>Alencar Xavier <a href="https://orcid.org/0000-0001-5034-9954"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  William Muir [aut],
  David Habier [aut],
  Kyle Kocak [aut],
  Shizhong Xu [aut],
  Katy Rainey [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bWGR-package'>
Bayesian Whole-Genome Regression
</h2><span id='topic+bWGR-package'></span><span id='topic+bWGR'></span>

<h3>Description</h3>

<p>Whole-genome regression methods on Bayesian framework fitted via EM
or Gibbs sampling, single step (&lt;doi:10.1534/g3.119.400728&gt;), 
univariate and multivariate (&lt;doi:10.1186/s12711-022-00730-w&gt;, &lt;doi:10.1093/genetics/iyae179&gt;),
with optional kernel term and sampling techniques (&lt;doi:10.1186/s12859-017-1582-3&gt;).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bWGR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2.13 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-12-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alencar Xavier, William Muir, David Habier, Kyle Kocak, Shizhong Xu, Katy Rainey.
Maintainer: Alencar Xavier &lt;alenxav@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tpod)
Fit = wgr(y,gen)
cor(y,Fit$hat)
</code></pre>

<hr>
<h2 id='Dataset'>
Tetra-seed Pods
</h2><span id='topic+tpod'></span><span id='topic+gen'></span><span id='topic+chr'></span><span id='topic+fam'></span><span id='topic+y'></span>

<h3>Description</h3>

<p>Two biparental crosses phenotyped for the percentage of pods containing four seeds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(tpod)
</code></pre>


<h3>Details</h3>

<p>Soybean nested association panel with 2 families (<code class="reqn">fam</code>) containing 196 indiviuals. Genotypic matrix (<code class="reqn">gen</code>) have 376 SNP across 20 chromosome (<code class="reqn">chr</code>). Phenotypic information (<code class="reqn">y</code>) regards the proportion of tetra-seed pods. Data provided by Rainey Lab for Soybean Breeding and Genetics, Purdue University.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier and Katy Rainey
</p>

<hr>
<h2 id='WGR1+20+28MC+29'>
MCMC Whole-genome Regression
</h2><span id='topic+wgr'></span><span id='topic+KMUP'></span><span id='topic+KMUP2'></span><span id='topic+GSEN'></span><span id='topic+BayesA'></span><span id='topic+BayesA2'></span><span id='topic+BayesB'></span><span id='topic+BayesB2'></span><span id='topic+BayesC'></span><span id='topic+BayesCpi'></span><span id='topic+BayesDpi'></span><span id='topic+BayesL'></span><span id='topic+BayesRR'></span><span id='topic+BayesRR2'></span><span id='topic+mcmcCV'></span>

<h3>Description</h3>

<p>Univariate model to find breeding values through regression with optional resampling techniques (Xavier et al. 2017) and polygenic term (Kernel). See &quot;Details&quot; for additional standalone functions written in C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgr(y,X,it=1500,bi=500,th=1,bag=1,rp=FALSE,iv=FALSE,de=FALSE,
    pi=0,df=5,R2=0.5,eigK=NULL,VarK=0.95,verb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_y">y</code></td>
<td>

<p>Numeric vector of observations (<code class="reqn">n</code>) describing the trait to be analyzed. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_x">X</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and (<code class="reqn">m</code>) columns of molecular markers.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_it">it</code></td>
<td>

<p>Integer. Number of iterations or samples to be generated.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_bi">bi</code></td>
<td>

<p>Integer. Burn-in, the number of iterations or samples to be discarted.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_th">th</code></td>
<td>

<p>Integer. Thinning parameter, used to save memory by storing only one every 'th' samples.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_bag">bag</code></td>
<td>

<p>If different than one, it indicates the proportion of data to be subsampled in each Markov chain. For datasets with moderate number of observations, values of bag from 0.30 to 0.60 may speed up computation without losses in predicion properties. This argument enable users to enhance MCMC through subsampling (Xavier et al. 2017).
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_rp">rp</code></td>
<td>

<p>Logical. Use replacement for bootstrap samples when bag is different than one.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_iv">iv</code></td>
<td>

<p>Logical. Assign markers independent variance, a T prior from a mixture of normals. If true, turns the default model BLUP into BayesA.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_de">de</code></td>
<td>

<p>Logical. Assign markers independent variance through double-exponential prior. If true, turns the default model BLUP into Bayesian LASSO. This argument overides iv.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_pi">pi</code></td>
<td>

<p>Value between 0 and 1. If greater than zero it activates variable selection, where markers have expected probability pi of having null effect.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_df">df</code></td>
<td>

<p>Prior degrees of freedom of variance components.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_r2">R2</code></td>
<td>

<p>Expected R2, used to calculate the prior shape.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_eigk">eigK</code></td>
<td>

<p>Output of function <code>eigen</code>. Spectral decomposition of the kernel used as a second random effect (eg. pedigree matrix).
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_vark">VarK</code></td>
<td>

<p>Numeric between 0 and 1. For reduction of dimensionality. Indicates the proportion of variance explained by Eigenpairs used to fit second random effect.
</p>
</td></tr>
<tr><td><code id="WGR1+2B20+2B28MC+2B29_+3A_verb">verb</code></td>
<td>

<p>Logical. If verbose is TRUE, function displays MCMC progress bar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model for the whole-genome regression is as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = mu + Xb + u + e</code>
</p>

<p>where <code class="reqn">y</code> is the response variable, <code class="reqn">mu</code> is the intercept, <code class="reqn">X</code> is the genotypic matrix, <code class="reqn">b</code> is the regression coefficient or effect of an allele substitution, with <code class="reqn">d</code> probability of being included into the model, <code class="reqn">u</code> is the polygenic term if a kernel is used, and <code class="reqn">e</code> is the residual term.
</p>
<p>Users can obtain four WGR methods out of this function: BRR (pi=0,iv=F), BayesA (pi=0,iv=T), BayesB (pi=0.95,iv=T), BayesC (pi=0.95,iv=F) and Bayesian LASSO or BayesL (pi=0,de=T). Theoretical basis of each model is described by de los Campos et al. (2013).
</p>
<p>Gibbs sampler that updates regression coefficients is adapted from GSRU algorithm (Legarra and Misztal 2008). The variable selection of functions <code class="reqn">wgr</code>, <code class="reqn">BayesB</code> and <code class="reqn">BayesC</code> works through the unconditional prior algorithm proposed by Kuo and Mallick (1998), whereas <code class="reqn">BayesCpi</code> and <code class="reqn">BayesDpi</code> are based on Metropolis-Hastings. Prior shape estimates are computed as Sb = R2*df*var(y)/MSx and Se = (1-R2)*df*var(y), with an exception for <code class="reqn">BayesC</code> and <code class="reqn">BayesCpi</code> where the prior shape is Sb = R2*df*var(y)/MSx/(1-pi). The polygenic term is solved by Bayesian algorithm of reproducing kernel Hilbert Spaces proposed by de los Campos et al. (2010).
</p>
<p>In addition to <code>wgr</code>, standalone C++ functions available include:
</p>
<p>01) <code>BayesA(y,X,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>02) <code>BayesB(y,X,it=1500,bi=500,pi=0.95,df=5,R2=0.5)</code>
</p>
<p>03) <code>BayesC(y,X,it=1500,bi=500,pi=0.95,df=5,R2=0.5)</code>
</p>
<p>04) <code>BayesCpi(y,X,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>05) <code>BayesDpi(y,X,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>06) <code>BayesL(y,X,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>07) <code>BayesRR(y,X,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>The implementations that support two random effects include:
</p>
<p>08) <code>BayesA2(y,X1,X2,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>09) <code>BayesB2(y,X1,X2,it=1500,bi=500,pi=0.95,df=5,R2=0.5)</code>
</p>
<p>10) <code>BayesRR2(y,X1,X2,it=1500,bi=500,df=5,R2=0.5)</code>
</p>
<p>And the cross-validation for the C++ implementations, with arguments analogous to <code>emCV</code>.
</p>
<p><code>mcmcCV(y,gen,k=5,n=5,it=1500,bi=500,pi=0.95,df=5,R2=0.5,avg=T,llo=NULL,tbv=NULL,ReturnGebv=FALSE)</code>    
</p>


<h3>Value</h3>

<p>The function wgr returns a list with expected value from the marker effect (<code class="reqn">b</code>), probability of marker being in the model (<code class="reqn">d</code>), regression coefficient (<code class="reqn">g</code>), variance of each marker (<code class="reqn">Vb</code>), the intercept (<code class="reqn">mu</code>), the polygene (<code class="reqn">u</code>) and polygenic variance (<code class="reqn">Vk</code>), residual variance (<code class="reqn">Ve</code>) and the fitted value (<code class="reqn">hat</code>).
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>References</h3>

<p>de los Campos, G., Hickey, J. M., Pong-Wong, R., Daetwyler, H. D., and Calus, M. P. (2013). Whole-genome regression and prediction methods applied to plant and animal breeding. Genetics, 193(2), 327-345.
</p>
<p>de los Campos, G., Gianola, D., Rosa, G. J., Weigel, K. A., &amp; Crossa, J. (2010). Semi-parametric genomic-enabled prediction of genetic values using reproducing kernel Hilbert spaces methods. Genetics Research, 92(04), 295-308.
</p>
<p>Kuo, L., &amp; Mallick, B. (1998). Variable selection for regression models. Sankhya: The Indian Journal of Statistics, Series B, 65-81.
</p>
<p>Legarra, A., &amp; Misztal, I. (2008). Technical note: Computing strategies in genome-wide selection. Journal of dairy science, 91(1), 360-366.
</p>
<p>Xavier, A., Xu, S., Muir, W., &amp; Rainey, K. M. (2017). Genomic prediction using subsampling. BMC bioinformatics, 18(1), 191.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 
        
# Load data
data(tpod)

# BLUP
fit_BRR = wgr(y,gen,iv=FALSE,pi=0)
cor(y,fit_BRR$hat)

# BayesA
fit_BayesA = wgr(y,gen,iv=TRUE,pi=0)
cor(y,fit_BayesA$hat)

# BayesB
fit_BayesB = wgr(y,gen,iv=TRUE,pi=.95)
cor(y,fit_BayesB$hat)

# BayesC
fit_BayesC = wgr(y,gen,iv=FALSE,pi=.95)
cor(y,fit_BayesC$hat)

# BayesCpi
fit_BayesCpi = BayesCpi(y,gen)
cor(y,fit_BayesCpi$hat)        

# BayesDpi
fit_BayesDpi = BayesDpi(y,gen)
cor(y,fit_BayesDpi$hat)        
        
# BayesL
fit_BayesL = wgr(y,gen,de=TRUE)
cor(y,fit_BayesL$hat)

# Bagging BLUP
fit_Bag = wgr(y,gen,bag=0.5)
cor(y,fit_Bag$hat)
    
    
## End(Not run)
</code></pre>

<hr>
<h2 id='WGR2+20+28EM+29'>
Expectation-Maximization WGR
</h2><span id='topic+emBA'></span><span id='topic+emBB'></span><span id='topic+emBC'></span><span id='topic+emRR'></span><span id='topic+emBL'></span><span id='topic+emDE'></span><span id='topic+emEN'></span><span id='topic+emML'></span><span id='topic+emML2'></span><span id='topic+emCV'></span><span id='topic+emBCpi'></span><span id='topic+lasso'></span>

<h3>Description</h3>

<p>Univariate models to find breeding values through regression fitted via expectation-maximization implemented in C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emRR(y, gen, df = 10, R2 = 0.5)
emBA(y, gen, df = 10, R2 = 0.5)
emBB(y, gen, df = 10, R2 = 0.5, Pi = 0.75)
emBC(y, gen, df = 10, R2 = 0.5, Pi = 0.75)
emBCpi(y, gen, df = 10, R2 = 0.5, Pi = 0.75)
emBL(y, gen, R2 = 0.5, alpha = 0.02)
emEN(y, gen, R2 = 0.5, alpha = 0.02)
emDE(y, gen, R2 = 0.5)
emML(y, gen, D = NULL)
lasso(y, gen)

emCV(y, gen, k = 5, n = 5, Pi = 0.75, alpha = 0.02,
     df = 10, R2 = 0.5, avg=TRUE, llo=NULL, tbv=NULL, ReturnGebv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_y">y</code></td>
<td>

<p>Numeric vector of response variable (<code class="reqn">n</code>). <code>NA</code> is not allowed.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_gen">gen</code></td>
<td>

<p>Numeric matrix containing the genotypic data. A matrix with <code class="reqn">n</code>
rows of observations and <code class="reqn">m</code> columns of molecular markers.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_df">df</code></td>
<td>

<p>Hyperprior degrees of freedom of variance components.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_r2">R2</code></td>
<td>

<p>Expected R2, used to calculate the prior shape (de los Campos et al. 2013).
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_pi">Pi</code></td>
<td>

<p>Value between 0 and 1. Expected probability pi of having null effect (or 1-Pi if Pi&gt;0.5).
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_alpha">alpha</code></td>
<td>

<p>Value between 0 and 1. Intensity of L1 variable selection.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_d">D</code></td>
<td>

<p>NULL or numeric vector with length p. Vector of weights for markers.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_k">k</code></td>
<td>

<p>Integer. Folding of a k-fold cross-validation.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_n">n</code></td>
<td>

<p>Integer. Number of cross-validation to perform.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_avg">avg</code></td>
<td>

<p>Logical. Return average across CV, or correlations within CV.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_llo">llo</code></td>
<td>

<p>NULL or a vector (numeric or factor) with the same length as y. If provided, the cross-validations are performed as Leave a Level Out (LLO). This argument allows the user to predefine the splits. This argument overrides <code>k</code> and <code>n</code>.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_tbv">tbv</code></td>
<td>

<p>NULL or numeric vector of 'true breeding values' (<code class="reqn">n</code>) to use to compare cross-validations to. If NULL, the cross-validations will have the phenotypes as prediction target.
</p>
</td></tr>
<tr><td><code id="WGR2+2B20+2B28EM+2B29_+3A_returngebv">ReturnGebv</code></td>
<td>

<p>Logical. If TRUE, it returns a list with the average marker values and fitted values across all cross-validations, in addition to the regular output.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The model for the whole-genome regression is as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = mu + Xb + e</code>
</p>

<p>where <code class="reqn">y</code> is the response variable, <code class="reqn">mu</code> is the intercept, <code class="reqn">X</code> is the genotypic matrix, <code class="reqn">b</code> is the effect of an allele substitution (or regression coefficient) and <code class="reqn">e</code> is the residual term. A k-fold cross-validation for model evaluation is provided by <code class="reqn">emCV</code>.
</p>


<h3>Value</h3>

<p>The EM functions returns a list with the intercept (<code class="reqn">mu</code>), the regression coefficient (<code class="reqn">b</code>), the fitted value (<code class="reqn">hat</code>), and the estimated intraclass-correlation (<code class="reqn">h2</code>). 
</p>
<p>The function emCV returns the predictive ability of each model, that is, the correlation between the predicted and observed values from <code class="reqn">k</code>-fold cross-validations repeated <code class="reqn">n</code> times.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     ## Not run: 

data(tpod)
emCV(y,gen,3,3)
          
 
## End(Not run)
</code></pre>

<hr>
<h2 id='WGR3+20+28MV+29'>
Multivariate Regression
</h2><span id='topic+mkr'></span><span id='topic+mrr'></span><span id='topic+mrr_float'></span><span id='topic+mkr2X'></span><span id='topic+mrr2X'></span><span id='topic+MRR3'></span><span id='topic+MRR3F'></span><span id='topic+MLM'></span><span id='topic+SEM'></span><span id='topic+mrr_svd'></span><span id='topic+MEGA'></span><span id='topic+GSEM'></span><span id='topic+UVBETA'></span><span id='topic+solver1x'></span><span id='topic+solver2x'></span><span id='topic+FUVBETA'></span><span id='topic+solver1xF'></span><span id='topic+solver2xF'></span><span id='topic+XFUVBETA'></span><span id='topic+ZFUVBETA'></span><span id='topic+XSEMF'></span><span id='topic+YSEMF'></span><span id='topic+ZSEMF'></span>

<h3>Description</h3>

<p>Multivariate model to find breeding values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mkr(Y,K,...)
  mrr(Y,X,...)
  mrr_float(Y,X,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WGR3+2B20+2B28MV+2B29_+3A_y">Y</code></td>
<td>

<p>Numeric matrix of observations x trait. <code>NA</code> is allowed.
</p>
</td></tr>
<tr><td><code id="WGR3+2B20+2B28MV+2B29_+3A_k">K</code></td>
<td>

<p>Numeric matrix containing the relationship matrix.
</p>
</td></tr>
<tr><td><code id="WGR3+2B20+2B28MV+2B29_+3A_x">X</code></td>
<td>

<p>Numeric matrix containing the genotyping matrix.
</p>
</td></tr> 
<tr><td><code id="WGR3+2B20+2B28MV+2B29_+3A_...">...</code></td>
<td>

<p>Arguments to pass to MRR3/MRR3F. See <code>args(MRR3)</code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Algorithm is described in Xavier and Habier (2022). The model for the ridge regression (mrr) is as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = Mu + XB + E</code>
</p>

<p>where <code class="reqn">Y</code> is a matrix of response variables, <code class="reqn">Mu</code> represents the intercepts, <code class="reqn">X</code> is the matrix of genotypic information, <code class="reqn">B</code> is the matrix of marker effects,  and <code class="reqn">E</code> is the residual matrix.
</p>
<p>The model for the kernel regression (mkr) is as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = Mu + UB + E</code>
</p>

<p>where <code class="reqn">Y</code> is a matrix of response variables, <code class="reqn">Mu</code> represents the intercepts, <code class="reqn">U</code> is the matrix of Eigenvector of K, <code class="reqn">b</code> is a vector of regression coefficients and <code class="reqn">E</code> is the residual matrix.
</p>
<p>Algorithm: Residuals are assumed to be independent among traits. Regression coefficients are solved via a multivaraite adaptation of Gauss-Seidel Residual Update. Since version 2.0, the solver of <code>mrr</code> is based on the Randomized Gauss-Seidel algorithm. Variance and covariance components are solved with an EM-REML like approach proposed by Schaeffer called Pseudo-Expectation.
</p>
<p>Other related implementations:
</p>
<p>01) <code>mkr2X(Y,K1,K2):</code> Solves multi-trait kernel regressions with two random effects.
</p>
<p>02) <code>mrr2X(Y,X1,X2):</code> Solves multi-trait ridge regressions with two random effects.
</p>
<p>03) <code>MRR3(Y,X,...):</code> Extension of mrr with additional parameters.
</p>
<p>04) <code>MRR3F(Y,X,...):</code> MRR3 running on float.
</p>
<p>05) <code>mrr_svd(Y,W):</code> Solves mrr through the principal components of parameters.
</p>
<p>06) <code>MLM(Y,X,Z,maxit=500,logtol=-8,cores=1):</code> Multivariate model with fixed effects.
</p>
<p>07) <code>SEM(Y,Z,...):</code> Fits a MegaSEM with both shared- and trait-specific terms.
</p>
<p>08) <code>MEGA(Y,X,npc=-1):</code> Toy implementation of MegaLMM, imputing missing with GEBVs.
</p>
<p>09) <code>GSEM(Y,X,npc=-1):</code> Toy C++ implementaiton of MegaSEM, jointly fits FA and XB.
</p>
<p>10) <code>ZSEMF(Y,X,npc=0):</code> Full-rank MegaSEM, float precision.
</p>
<p>11) <code>YSEMF(Y,X,npc=-1):</code> Reduced-rank MegaSEM, float, two-steps approach.
</p>
<p>12) <code>XSEMF(Y,X,npc=0):</code> Full-rank MegaSEM, h2 fixed at 0.5, float precision.
</p>
<p>In GSEM, XSEMF and MEGA, 'npc' means number of latent spaces if input is above zero, otherwise, 0 means all and -1 means <code>2*sqrt(ncol(Y))</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the random effect covariances (<code>Vb</code>), residual variances (<code>Ve</code>), genetic correlations (<code>GC</code>), matrix with marker effects (<code>b</code>) or eigenvector effects (if <code>mkr</code>), intercepts (<code>mu</code>), heritabilities (<code>h2</code>), and a matrix with fitted values (<code>hat</code>).
</p>
<p>NOTE: Numeric stability is a serious concern with multivariate models with large number of response variables, as the covariance matrix is often not invesible. If output is filled with NAs, try using <code>MRR3</code> and play with some parameters. For example, one may try adding priors to stabilize variances, e.g., <code>fit=MRR3(Y,X,df0=20)</code>. 
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier, David Habier
</p>


<h3>References</h3>

<p>Xavier, A and Habier, D. (2022). A new approach fits multivariate genomic prediction models efficiently. GSE, DOI: 10.1186/s12711-022-00730-w 
</p>
<p>Xavier, A et al. (2024). Megavariate Methods Capture Complex Genotype-by-Environment Interactions. Genetics, DOI: 10.1093/genetics/iyae179
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    # Load genomic data
    
    data(tpod)
    X = CNT(gen)
    
    # Simulate phenotyp
    
    sim = SimY(X)
    Y = sim$Y
    TBV = sim$tbv
    
    # Fit regression model
    
    test = mrr(Y,X)
    
    # Genetic correlation
    
    test$GC
    
    # Heritabilies
    
    test$h2
    
    # Accuracy
    
    diag(cor(TBV,test$hat))
    
    # try: demo(multivariates)

</code></pre>

<hr>
<h2 id='XTRA+201'>
Mixed model solver
</h2><span id='topic+mixed'></span><span id='topic+mtmixed'></span><span id='topic+mtgsru'></span><span id='topic+mm'></span><span id='topic+NNS'></span><span id='topic+GSFLM'></span><span id='topic+GSRR'></span><span id='topic+GS2EIGEN'></span><span id='topic+NNSEARCH'></span><span id='topic+predict_FLMSS'></span>

<h3>Description</h3>

<p>Function to solve univariate mixed models with or without the usage of omic information. This function allows single-step modeling of replicated observations with marker information available through the usage of a linkage function to connect to a whole-genome regression method. Genomic estimated values can be optionally deregressed (no shrinkage) while fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed(y,random=NULL,fixed=NULL,data=NULL,X=list(),
      alg=emML,maxit=10,Deregress=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XTRA+2B201_+3A_y">y</code></td>
<td>

<p>Response variable from the data frame containg the dataset.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_random">random</code></td>
<td>

<p>Formula. Right-hand side formula of random effects.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_fixed">fixed</code></td>
<td>

<p>Formula. Right-hand side formula of fixed effects.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_data">data</code></td>
<td>

<p>Data frame containing the response variable, random and fixed terms.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_x">X</code></td>
<td>

<p>List of omic incidence matrix. Row names of these matrices connect the omic information to the levels of the indicated random terms (eg. <code>X=list("ID"=gen)</code>).
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_alg">alg</code></td>
<td>

<p>Function. Whole-genome regression algorithm utilized to solve link functions. These include MCMC (<code>wgr</code>, <code>BayesB</code>, etc) and EM (<code>emEN</code>, <code>emDE</code>, etc) algorithms. By default, it runs maximum likelihood <code>emML</code>.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_maxit">maxit</code></td>
<td>

<p>Integer. Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="XTRA+2B201_+3A_deregress">Deregress</code></td>
<td>

<p>Logical. Deregress (unshrink) coefficients while fitting the model?
</p>
</td></tr> 
<tr><td><code id="XTRA+2B201_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the whole-genome regression algorithms especified on <code>alg</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model for the whole-genome regression is as follows:
</p>
<p style="text-align: center;"><code class="reqn">y = Xb + Zu + Wa + e</code>
</p>

<p>where <code class="reqn">y</code> is the response variable, <code class="reqn">Xb</code> corresponds to the fixed effect term, <code class="reqn">Zu</code> corresponds to one or more random effect terms, <code class="reqn">W</code> is the incidence matrix of terms with omic information and <code class="reqn">a</code> is omic values by <code class="reqn">a=Mg</code>, where <code class="reqn">M</code> is the genotypic matrix and <code class="reqn">g</code> are marker effects. Here, <code class="reqn">e</code> is the residual term. An example is provided using the data from the NAM package with: <code>demo(mixedmodel)</code>.
</p>
<p>Alterinative (and updated) implementations have similar syntax:
</p>
<p>01) <code>mm(y,random=NULL,fixed=NULL,data=NULL,
              M=NULL,bin=FALSE,AM=NULL,it=10,verb=TRUE,
              FLM=TRUE,wgtM=TRUE,cntM=TRUE,nPc=3)</code>
</p>
<p>02) <code>mtmixed = function(resp, random=NULL, fixed=NULL,
              data, X=list(), maxit=10, init=10, regVC=FALSE)</code>
</p>


<h3>Value</h3>

<p>The function wgr returns a list with Fitness values (<code>Fitness</code>) containing observation <code>obs</code>, fitted values <code>hat</code>, residuals <code>res</code>, and fitted values by model term <code>fits</code>; Estimated variance components (<code>VarComp</code>) containing the variance components per se (<code>VarComponents</code>) and variance explained by each model term (<code>VarExplained</code>), regression coefficients by model term (<code>Coefficients</code>), and the effects of structured terms (<code>Structure</code>) containing the marker effects of each model term where markers were provided.
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>


<h3>References</h3>

<p>Xavier, A. (2019). Efficient Estimation of Marker Effects in Plant Breeding. G3: Genes, Genomes, Genetics, DOI: 10.1534/g3.119.400728      
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 demo(mixedmodel)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='XTRA+202'>
Additional tools
</h2><span id='topic+emGWA'></span><span id='topic+SPC'></span><span id='topic+SPM'></span><span id='topic+markov'></span><span id='topic+IMP'></span><span id='topic+CNT'></span><span id='topic+GAU'></span><span id='topic+GRM'></span><span id='topic+Hmat'></span><span id='topic+SibZ'></span><span id='topic+EigenGAU'></span><span id='topic+EigenGRM'></span><span id='topic+EigenCNT'></span><span id='topic+EigenARC'></span><span id='topic+EigenEVD'></span><span id='topic+EigenBDCSVD'></span><span id='topic+EigenJacobiSVD'></span><span id='topic+EigenAcc'></span><span id='topic+AccByC'></span><span id='topic+EigenArcZ'></span><span id='topic+EigenGauZ'></span><span id='topic+K2X'></span><span id='topic+SimY'></span><span id='topic+SimZ'></span><span id='topic+SimGC'></span><span id='topic+MvSimY'></span>

<h3>Description</h3>

<p>Complementary functions that may help with handling parameters and routine operations.
</p>


<h3>Details</h3>

<p><code>emGWA(y,gen)</code> # Simple MLM for association analysis
</p>
<p><code>markov(gen,chr=NULL)</code> # Markovian imputation of genotypes coded as 012
</p>
<p><code>IMP(X)</code> # Imputes genotypes with SNP expectation (column average)
</p>
<p><code>CNT(X)</code> # Recodes SNPs by centralizing columns in a matrix
</p>
<p><code>GAU(X)</code> # Creates Gaussian kernel as exp(-Dist2/mean(Dist2))
</p>
<p><code>GRM(X,Code012=FALSE)</code> # Creates additive kinship matrix VanRaden 2008
</p>
<p><code>SPC(y,blk,row,col,rN=3,cN=1)</code> # Spatial covariate
</p>
<p><code>SPM(blk,row,col,rN=3,cN=1)</code> # Spatial design matrix
</p>
<p><code>SibZ(id,p1,p2)</code> # Pedigree design matrix compatible to regression methods
</p>
<p><code>Hmat(ped,gen=NULL)</code> # Kinship combining pedigree and genomics
</p>
<p><code>EigenGRM(X, centralizeZ = TRUE, cores = 1)</code> # GRM using Eigen library
</p>
<p><code>EigenARC(X, centralizeZ = TRUE, cores = 1)</code> # ArcCosine kernel
</p>
<p><code>EigenGAU(X, phi = 1.0, cores = 1)</code> # Gaussian kernel using Eigen library
</p>
<p><code>EigenCNT(X, cores = 1)</code> # Center SNPs without missing Eigen library
</p>
<p><code>EigenEVD(A, cores = 1)</code> # Eigendecomposition from Eigen library
</p>
<p><code>EigenBDCSVD(X, cores = 1)</code> # BDC single value composition from Eigen
</p>
<p><code>EigenJacobiSVD(X, cores = 1)</code> # Jacobi single value composition from Eigen
</p>
<p><code>EigenAcc(X1, X2, h2 = 0.5, cores = 1)</code> # Deterministic accuracy X1 -&gt; X2 via V
</p>
<p><code>AccByC(X1, X2, h2 = 0.5, cores = 1)</code> # Deterministic accuracy X1 -&gt; X2 via C
</p>
<p><code>EigenArcZ(Zfndr, Zsamp, cores = 1)</code> # Reduced rank ArcCos kernel PCs with founder rotation
</p>
<p><code>EigenGauZ(Zfndr, Zsamp, phi=1, cores = 1)</code> # Reduced rank Gaussian kernel PCs with founder rotation 
</p>
<p><code>K2X(K, MinEV = 1e-8, cores = 1)</code> # Reparametrize kernel to PCs to run regression models 
</p>
<p><code>SimY(Z,k=5,h2=0.5,GC=0.5,seed=123,unbalanced=FALSE,PercMiss=0,BlkMiss=FALSE)</code> # Simulate phenotypes 
</p>
<p><code>SimZ(ind=500,snp=500,chr=2,F2=TRUE,rec=0.01)</code> # Simulate genome
</p>
<p><code>SimGC(k=50,...)</code> # Simulate genetic correlation matrix
</p>
<p><code>MvSimY(Ufndr,Zfndr,Zsamp,GxY,GxL,H2plot,nLoc=20,Seed=123)</code> # Simulate phenotypes given founders
</p>


<h3>Author(s)</h3>

<p>Alencar Xavier
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
