<!DOCTYPE html><html lang="en"><head><title>Help for package clickR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clickR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+3DNA+25'><p>geq &amp; not NA</p></a></li>
<li><a href='#+25+26gt+3BNA+25'><p>greater &amp; NA</p></a></li>
<li><a href='#+25+26lt+3B+3DNA+25'><p>leq &amp; not NA</p></a></li>
<li><a href='#+25+26lt+3BNA+25'><p>less &amp; NA</p></a></li>
<li><a href='#+between+'><p>between operator</p></a></li>
<li><a href='#+betweenNA+'><p>between operator &amp; not NA</p></a></li>
<li><a href='#antimoda'><p>Get anti-mode</p></a></li>
<li><a href='#bivariate_outliers'><p>Check for bivariate outliers</p></a></li>
<li><a href='#check_quality'><p>Checks data quality of a variable</p></a></li>
<li><a href='#cluster_var'><p>Clustering of variables</p></a></li>
<li><a href='#descriptive'><p>Detailed summary of the data</p></a></li>
<li><a href='#extreme_values'><p>Extreme values from a numeric vector</p></a></li>
<li><a href='#f_replace'><p>Find and replace</p></a></li>
<li><a href='#fix_all'><p>fix_all</p></a></li>
<li><a href='#fix_concat'><p>fix_concat</p></a></li>
<li><a href='#fix_dates'><p>Fix dates</p></a></li>
<li><a href='#fix_factors'><p>Fix factors imported as numerics</p></a></li>
<li><a href='#fix_levels'><p>Fix levels</p></a></li>
<li><a href='#fix_NA'><p>fix_NA</p></a></li>
<li><a href='#fix_numerics'><p>Fix numeric data</p></a></li>
<li><a href='#forge'><p>Forge</p></a></li>
<li><a href='#fxd'><p>Internal function to fix_dates</p></a></li>
<li><a href='#GK_assoc'><p>Computes Goodman and Kruskal's tau</p></a></li>
<li><a href='#good2go'><p>Good to go</p></a></li>
<li><a href='#ipboxplot'><p>Improved boxplot</p></a></li>
<li><a href='#kill.factors'><p>Kill factors</p></a></li>
<li><a href='#kurtosis'><p>Computes kurtosis</p></a></li>
<li><a href='#manual_fix'><p>Tracked manual fixes to data</p></a></li>
<li><a href='#may.numeric'><p>Checks if each value might be numeric</p></a></li>
<li><a href='#mine.plot'><p>Mine plot</p></a></li>
<li><a href='#moda'><p>Get mode</p></a></li>
<li><a href='#moda_cont'><p>Estimates number of modes</p></a></li>
<li><a href='#mtapply'><p>Multiple tapply</p></a></li>
<li><a href='#mtcars_messy'><p>Messy Motor Trend Car Road Tests Dataset</p></a></li>
<li><a href='#nearest'><p>Internal function for descriptive()</p></a></li>
<li><a href='#nice_names'><p>Nice names</p></a></li>
<li><a href='#numeros'><p>Brute numeric coercion</p></a></li>
<li><a href='#outliers'><p>outliers</p></a></li>
<li><a href='#peek'><p>Peek</p></a></li>
<li><a href='#prop_may'><p>Gets proportion of most repeated value</p></a></li>
<li><a href='#prop_min'><p>Gets proportion of least repeated value</p></a></li>
<li><a href='#remove_empty'><p>remove_empty</p></a></li>
<li><a href='#restore_changes'><p>Restore changes</p></a></li>
<li><a href='#scale_01'><p>Scales data between 0 and 1</p></a></li>
<li><a href='#search_scripts'><p>Search scripts</p></a></li>
<li><a href='#skewness'><p>Computes skewness</p></a></li>
<li><a href='#text_date'><p>Internal function for dates with text</p></a></li>
<li><a href='#track_changes'><p>track_changes</p></a></li>
<li><a href='#ttrue'><p>True TRUE</p></a></li>
<li><a href='#unforge'><p>Un-Forge</p></a></li>
<li><a href='#v_df_changes'><p>Internal function to track_changes</p></a></li>
<li><a href='#workspace'><p>Explores global environment workspace</p></a></li>
<li><a href='#workspace_sapply'><p>Applies a function over objects of a specific class</p></a></li>
<li><a href='#xscores'><p>Estimate sample scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semi-Automatic Preprocessing of Messy Data with Change Tracking
for Dataset Cleaning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.45</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Hervas Marin &lt;ddhervas@yahoo.es&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>beeswarm, future, future.apply, methods, stringdist</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for assessing data quality, performing exploratory analysis, and 
    semi-automatic preprocessing of messy data with change tracking for integral dataset cleaning.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-05 12:50:20 UTC; aghil</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Author:</td>
<td>David Hervas Marin [aut, cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 13:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+3DNA+25'>geq &amp; not NA</h2><span id='topic++25+3E+3DNA+25'></span>

<h3>Description</h3>

<p>'&gt;=' operator where NA values return FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&gt;=NA% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B3DNA+2B25_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B3DNA+2B25_+3A_y">y</code></td>
<td>
<p>A Scalar or vector of the same length as x for the right side of the operator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='+25+26gt+3BNA+25'>greater &amp; NA</h2><span id='topic++25+3ENA+25'></span>

<h3>Description</h3>

<p>'&gt;' operator where NA values return FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&gt;NA% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3BNA+2B25_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3BNA+2B25_+3A_y">y</code></td>
<td>
<p>A Scalar or vector of the same length as x for the right side of the operator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='+25+26lt+3B+3DNA+25'>leq &amp; not NA</h2><span id='topic++25+3C+3DNA+25'></span>

<h3>Description</h3>

<p>'&lt;=' operator where NA values return FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;=NA% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3B+2B3DNA+2B25_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3B+2B3DNA+2B25_+3A_y">y</code></td>
<td>
<p>A Scalar or vector of the same length as x for the right side of the operator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='+25+26lt+3BNA+25'>less &amp; NA</h2><span id='topic++25+3CNA+25'></span>

<h3>Description</h3>

<p>'&lt;' operator where NA values return FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;NA% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3BNA+2B25_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3BNA+2B25_+3A_y">y</code></td>
<td>
<p>A Scalar or vector of the same length as x for the right side of the operator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='+between+'>between operator</h2><span id='topic++between+'></span>

<h3>Description</h3>

<p>Operator equivalent to x &gt;= lower.value &amp; x &lt;= upper.value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %between% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2Bbetween+2B_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2Bbetween+2B_+3A_y">y</code></td>
<td>
<p>A vector of length two with the lower and upper values of the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='+betweenNA+'>between operator &amp; not NA</h2><span id='topic++betweenNA+'></span>

<h3>Description</h3>

<p>Operator equivalent to x &gt;= lower.value &amp; x &lt;= upper.value &amp; !is.na(x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %betweenNA% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2BbetweenNA+2B_+3A_x">x</code></td>
<td>
<p>Vector for the left side of the operator</p>
</td></tr>
<tr><td><code id="+2BbetweenNA+2B_+3A_y">y</code></td>
<td>
<p>A vector of length two with the lower and upper values of the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x
</p>

<hr>
<h2 id='antimoda'>Get anti-mode</h2><span id='topic+antimoda'></span>

<h3>Description</h3>

<p>Returns the least repeated value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antimoda(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="antimoda_+3A_x">x</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The anti-mode (least repeated value)
</p>

<hr>
<h2 id='bivariate_outliers'>Check for bivariate outliers</h2><span id='topic+bivariate_outliers'></span>

<h3>Description</h3>

<p>Checks for bivariate outliers in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivariate_outliers(x, threshold_r = 10, threshold_b = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivariate_outliers_+3A_x">x</code></td>
<td>
<p>A data.frame object</p>
</td></tr>
<tr><td><code id="bivariate_outliers_+3A_threshold_r">threshold_r</code></td>
<td>
<p>Threshold for the case of two continuous variables</p>
</td></tr>
<tr><td><code id="bivariate_outliers_+3A_threshold_b">threshold_b</code></td>
<td>
<p>Threshold for the case of one continuous and one categorical variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with all the observations considered as bivariate outliers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bivariate_outliers(iris)
</code></pre>

<hr>
<h2 id='check_quality'>Checks data quality of a variable</h2><span id='topic+check_quality'></span>

<h3>Description</h3>

<p>Returns different data quality details of a numeric or categorical variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_quality(
  x,
  id = 1:length(x),
  plot = TRUE,
  numeric = NULL,
  k = 5,
  n = ifelse(is.numeric(x) | ttrue(numeric) | class(x) %in% "Date", 5, 2),
  output = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_quality_+3A_x">x</code></td>
<td>
<p>A variable from a data.frame</p>
</td></tr>
<tr><td><code id="check_quality_+3A_id">id</code></td>
<td>
<p>ID column to reference the found extreme values</p>
</td></tr>
<tr><td><code id="check_quality_+3A_plot">plot</code></td>
<td>
<p>If the variable is numeric, should a boxplot be drawn?</p>
</td></tr>
<tr><td><code id="check_quality_+3A_numeric">numeric</code></td>
<td>
<p>If set to TRUE, forces the variable to be considered numeric</p>
</td></tr>
<tr><td><code id="check_quality_+3A_k">k</code></td>
<td>
<p>Number of different numeric values in a variable to be considered as numeric</p>
</td></tr>
<tr><td><code id="check_quality_+3A_n">n</code></td>
<td>
<p>Number of extreme values to extract</p>
</td></tr>
<tr><td><code id="check_quality_+3A_output">output</code></td>
<td>
<p>Format of the output. If TRUE, optimize for exporting as csv</p>
</td></tr>
<tr><td><code id="check_quality_+3A_...">...</code></td>
<td>
<p>further arguments passed to boxplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a data.frame with information about data quality of the variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_quality(airquality$Ozone)  #For one variable
lapply(airquality, check_quality)  #For a data.frame
lapply(airquality, check_quality, output=TRUE)  #For a data.frame, one row per variable
</code></pre>

<hr>
<h2 id='cluster_var'>Clustering of variables</h2><span id='topic+cluster_var'></span>

<h3>Description</h3>

<p>Displays associations between variables in a data.frame in a heatmap with clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_var(x, margins = c(8, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_var_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="cluster_var_+3A_margins">margins</code></td>
<td>
<p>Margins for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap with the variable associations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster_var(iris)
cluster_var(mtcars)
</code></pre>

<hr>
<h2 id='descriptive'>Detailed summary of the data</h2><span id='topic+descriptive'></span>

<h3>Description</h3>

<p>Creates a detailed summary of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descriptive(x, z = 3, ignore.na = TRUE, by = NULL, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="descriptive_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="descriptive_+3A_z">z</code></td>
<td>
<p>Number of decimal places</p>
</td></tr>
<tr><td><code id="descriptive_+3A_ignore.na">ignore.na</code></td>
<td>
<p>If TRUE NA values will not count for relative frequencies calculations</p>
</td></tr>
<tr><td><code id="descriptive_+3A_by">by</code></td>
<td>
<p>Factor variable definining groups for the summary</p>
</td></tr>
<tr><td><code id="descriptive_+3A_print">print</code></td>
<td>
<p>Should results be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>descriptive(iris)
descriptive(iris, by="Species")
</code></pre>

<hr>
<h2 id='extreme_values'>Extreme values from a numeric vector</h2><span id='topic+extreme_values'></span>

<h3>Description</h3>

<p>Returns the nth lowest and highest values from a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extreme_values(x, n = 5, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extreme_values_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="extreme_values_+3A_n">n</code></td>
<td>
<p>Number of extreme values to return</p>
</td></tr>
<tr><td><code id="extreme_values_+3A_id">id</code></td>
<td>
<p>ID column to reference the found extreme values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the lowest and highest values from a vector
</p>

<hr>
<h2 id='f_replace'>Find and replace</h2><span id='topic+f_replace'></span>

<h3>Description</h3>

<p>Searches a data.frame for a specific character string and replaces it with another one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_replace(
  x,
  string,
  replacement,
  complete = TRUE,
  select = 1:ncol(x),
  track = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_replace_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="f_replace_+3A_string">string</code></td>
<td>
<p>A character string to search in the data.frame</p>
</td></tr>
<tr><td><code id="f_replace_+3A_replacement">replacement</code></td>
<td>
<p>A character string to replace the old string (can be NA)</p>
</td></tr>
<tr><td><code id="f_replace_+3A_complete">complete</code></td>
<td>
<p>If TRUE, search for complete strings only. If FALSE, search also for partial strings.</p>
</td></tr>
<tr><td><code id="f_replace_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="f_replace_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>iris2 &lt;- f_replace(iris, "setosa", "ensata")
track_changes(iris2)
</code></pre>

<hr>
<h2 id='fix_all'>fix_all</h2><span id='topic+fix_all'></span>

<h3>Description</h3>

<p>Tries to automatically fix all problems in the data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_all(x, select = 1:ncol(x), track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_all_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_all_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="fix_all_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
</table>

<hr>
<h2 id='fix_concat'>fix_concat</h2><span id='topic+fix_concat'></span>

<h3>Description</h3>

<p>Fixes concatenated values in a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_concat(x, varname, sep = ", |; | ", track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_concat_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_concat_+3A_varname">varname</code></td>
<td>
<p>Variable name</p>
</td></tr>
<tr><td><code id="fix_concat_+3A_sep">sep</code></td>
<td>
<p>Separator for the different values</p>
</td></tr>
<tr><td><code id="fix_concat_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(concat=c("a", "b", "a b" , "a b, c", "a; c"),
numeric = c(1, 2, 3, 4, 5))
fix_concat(mydata, "concat")
</code></pre>

<hr>
<h2 id='fix_dates'>Fix dates</h2><span id='topic+fix_dates'></span>

<h3>Description</h3>

<p>Fixes dates. Dates can be recorded in numerous formats depending on the
country, the traditions and the field of knowledge. <code>fix.dates</code> tries to detect
all possible date formats and transforms all of them in the ISO standard favored by
R (yyyy-mm-dd).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_dates(
  x,
  max.NA = 0.8,
  min.obs = nrow(x) * 0.05,
  use.probs = TRUE,
  select = 1:ncol(x),
  track = TRUE,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_dates_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_max.na">max.NA</code></td>
<td>
<p>Maximum allowed proportion of NA values created by coercion. If the
coercion to date creates more NA values than those specified in <code>max.NA</code>, then all
changes will be reverted and the variable will remain unchanged.</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_min.obs">min.obs</code></td>
<td>
<p>Minimum number of non-NA observations allowed per variable. If the variable
has fewer non-NA observations, then it will be ignored by <code>fix.dates</code>.</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_use.probs">use.probs</code></td>
<td>
<p>When there are multiple date formats in the same column, there can
be ambiguities. For example, 04-06-2015 can be interpreted as 2015-06-04 or as 2015-04-06.
If <code>use.probs=TRUE</code>, ambiguities will be solved by assigning to the most frequent
date format in the column.</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
<tr><td><code id="fix_dates_+3A_parallel">parallel</code></td>
<td>
<p>Should the computations be performed in parallel? Set up strategy first with future::plan()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata&lt;-data.frame(Dates1=c("25/06/1983", "25-08/2014", "2001/11/01", "2008-10-01"),
                   Dates2=c("01/01/85", "04/04/1982", "07/12-2016", "September 24, 2020"),
                   Numeric1=rnorm(4))
fix_dates(mydata)
</code></pre>

<hr>
<h2 id='fix_factors'>Fix factors imported as numerics</h2><span id='topic+fix_factors'></span>

<h3>Description</h3>

<p>Fixes factors imported as numerics. It is usual in some fields to encode
factor variables as integers. This function detects such variables and transforms
them into factors. When <code>drop=TRUE</code> (by default) it detects multiple versions
of the same levels due to different capitalization, whitespaces or non-ASCII characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_factors(x, k = 5, select = 1:ncol(x), drop = TRUE, track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_factors_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_factors_+3A_k">k</code></td>
<td>
<p>Maximum number of different numeric values to be converted to factor</p>
</td></tr>
<tr><td><code id="fix_factors_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="fix_factors_+3A_drop">drop</code></td>
<td>
<p>Drop similar levels?</p>
</td></tr>
<tr><td><code id="fix_factors_+3A_track">track</code></td>
<td>
<p>Keep track of changes?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># mtcars data has all variables encoded as numeric, even the factor variables.
descriptive(mtcars)
# After using fix_factors, factor variables are recognized as such.
descriptive(fix_factors(mtcars))
</code></pre>

<hr>
<h2 id='fix_levels'>Fix levels</h2><span id='topic+fix_levels'></span>

<h3>Description</h3>

<p>Fixes levels of a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_levels(
  data,
  factor_name,
  method = "dl",
  levels = NULL,
  plot = FALSE,
  k = ifelse(!is.null(levels), length(levels), 2),
  track = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_levels_+3A_data">data</code></td>
<td>
<p>data.frame with the factor to fix</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_factor_name">factor_name</code></td>
<td>
<p>Name of the factor to fix (as character)</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_method">method</code></td>
<td>
<p>Method from stringdist package to estimate distances</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_levels">levels</code></td>
<td>
<p>Optional vector with the levels names. If &quot;auto&quot;, levels are assigned based on frequency</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_plot">plot</code></td>
<td>
<p>Optional: Plot cluster dendrogram?</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_k">k</code></td>
<td>
<p>Number of levels for clustering</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_track">track</code></td>
<td>
<p>Keep track of changes?</p>
</td></tr>
<tr><td><code id="fix_levels_+3A_...">...</code></td>
<td>
<p>Further parameters passed to stringdist::stringdistmatrix function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(factor1=factor(c("Control", "Treatment", "Tretament", "Tratment", "treatment",
"teatment", "contrl", "cntrol", "CONTol", "not available", "na")))
fix_levels(mydata, "factor1", k=4, plot=TRUE)   #Chose k to select matching levels
fix_levels(mydata, "factor1", levels=c("Control", "Treatment"), k=4)
</code></pre>

<hr>
<h2 id='fix_NA'>fix_NA</h2><span id='topic+fix_NA'></span>

<h3>Description</h3>

<p>Fixes miscoded missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_NA(
  x,
  na.strings = c("^$", "^ $", "^\\?$", "^-$", "^\\.$", "^NaN$", "^NULL$", "^N/A$"),
  track = TRUE,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_NA_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_NA_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings to be considered NA</p>
</td></tr>
<tr><td><code id="fix_NA_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
<tr><td><code id="fix_NA_+3A_parallel">parallel</code></td>
<td>
<p>Should the computations be performed in parallel? Set up strategy first with future::plan()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(prueba = c("", NA, "A", 4, " ", "?", "-", "+"),
casa = c("", 1, 2, 3, 4, " ", 6, 7))
fix_NA(mydata)
</code></pre>

<hr>
<h2 id='fix_numerics'>Fix numeric data</h2><span id='topic+fix_numerics'></span>

<h3>Description</h3>

<p>Fixes numeric data. In many cases, numeric data are not recognized by R
because there are data inconsistencies (wrong decimal separator, whitespaces, typos,
thousand separator, etc.). <code>fix_numerics</code> detects and corrects these variables,
making them numeric again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_numerics(
  x,
  k = 8,
  max.NA = 0.2,
  select = 1:ncol(x),
  track = TRUE,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_numerics_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="fix_numerics_+3A_k">k</code></td>
<td>
<p>Minimum number of different values a variable has to have to be considered numerical</p>
</td></tr>
<tr><td><code id="fix_numerics_+3A_max.na">max.NA</code></td>
<td>
<p>Maximum allowed proportion of NA values created by coercion. If the
coercion to numeric creates more NA values than those specified in <code>max.NA</code>, then all
changes will be reverted and the variable will remain unchanged.</p>
</td></tr>
<tr><td><code id="fix_numerics_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="fix_numerics_+3A_track">track</code></td>
<td>
<p>Keep track of changes?</p>
</td></tr>
<tr><td><code id="fix_numerics_+3A_parallel">parallel</code></td>
<td>
<p>Should the computations be performed in parallel? Set up strategy first with future::plan()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata&lt;-data.frame(Numeric1=c(7.8, 9.2, "5.4e+2", 3.3, "6,8", "3..3"),
                   Numeric2=c(3.1, 1.2, "3.4s", "48,500.04 $", 7, "$  6.4"))
descriptive(mydata)
descriptive(fix_numerics(mydata, k=5))
</code></pre>

<hr>
<h2 id='forge'>Forge</h2><span id='topic+forge'></span>

<h3>Description</h3>

<p>Reshapes a data frame from wide to long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forge(data, affixes, force.fixed = NULL, var.name = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forge_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="forge_+3A_affixes">affixes</code></td>
<td>
<p>Affixes for repeated measures</p>
</td></tr>
<tr><td><code id="forge_+3A_force.fixed">force.fixed</code></td>
<td>
<p>Variables with matching affix to be excluded</p>
</td></tr>
<tr><td><code id="forge_+3A_var.name">var.name</code></td>
<td>
<p>Name for the new created variable (repetitions)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Data frame in wide format
df1 &lt;- data.frame(id = 1:4, age = c(20, 30, 30, 35), score1 = c(2,2,3,4),
                  score2 = c(2,1,3,1), score3 = c(1,1,0,1))
df1
#Data frame in long format
forge(df1, affixes= c("1", "2", "3"))

#Data frame in wide format with two repeated measured variables
df2 &lt;- data.frame(df1, var1 = c(15, 20, 16, 19), var3 = c(12, 15, 15, 17))
df2
#Missing times are filled with NAs
forge(df2, affixes = c("1", "2", "3"))

#Use of parameter force.fixed
df3 &lt;- df2[, -7]
df3
forge(df3, affixes=c("1", "2", "3"))
forge(df3, affixes=c("1", "2", "3"), force.fixed = c("var1"))
</code></pre>

<hr>
<h2 id='fxd'>Internal function to fix_dates</h2><span id='topic+fxd'></span>

<h3>Description</h3>

<p>Function to format dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fxd(d, use.probs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fxd_+3A_d">d</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="fxd_+3A_use.probs">use.probs</code></td>
<td>
<p>Solve ambiguities by similarity to the most frequent formats</p>
</td></tr>
</table>

<hr>
<h2 id='GK_assoc'>Computes Goodman and Kruskal's tau</h2><span id='topic+GK_assoc'></span>

<h3>Description</h3>

<p>Returns Goodman and Kruskal's tau measure of association between two categorical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GK_assoc(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GK_assoc_+3A_x">x</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
<tr><td><code id="GK_assoc_+3A_y">y</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Goodman and Kruskal's tau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infert)
GK_assoc(infert$education, infert$case)
GK_assoc(infert$case, infert$education) #Not the same
</code></pre>

<hr>
<h2 id='good2go'>Good to go</h2><span id='topic+good2go'></span>

<h3>Description</h3>

<p>Loads all libraries used in scripts inside the selected path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>good2go(path = getwd(), info = TRUE, load = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="good2go_+3A_path">path</code></td>
<td>
<p>Path where the scripts are located</p>
</td></tr>
<tr><td><code id="good2go_+3A_info">info</code></td>
<td>
<p>List the libraries found?</p>
</td></tr>
<tr><td><code id="good2go_+3A_load">load</code></td>
<td>
<p>Should the libraries found be loaded?</p>
</td></tr>
</table>

<hr>
<h2 id='ipboxplot'>Improved boxplot</h2><span id='topic+ipboxplot'></span>

<h3>Description</h3>

<p>Creates an improved boxplot with individual data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipboxplot(formula, boxwex = 0.6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipboxplot_+3A_formula">formula</code></td>
<td>
<p>Formula for the boxplot</p>
</td></tr>
<tr><td><code id="ipboxplot_+3A_boxwex">boxwex</code></td>
<td>
<p>Width of the boxes</p>
</td></tr>
<tr><td><code id="ipboxplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to beeswarm()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ipboxplot(Sepal.Length ~ Species, data=iris)
ipboxplot(mpg ~ gear, data=mtcars)
</code></pre>

<hr>
<h2 id='kill.factors'>Kill factors</h2><span id='topic+kill.factors'></span>

<h3>Description</h3>

<p>Changes factor variables to character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kill.factors(dat, k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kill.factors_+3A_dat">dat</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="kill.factors_+3A_k">k</code></td>
<td>
<p>Maximum number of levels for factors</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(Letters=letters[1:20], Nums=1:20)
d$Letters
d &lt;- kill.factors(d)
d$Letters
</code></pre>

<hr>
<h2 id='kurtosis'>Computes kurtosis</h2><span id='topic+kurtosis'></span>

<h3>Description</h3>

<p>Calculates kurtosis of a numeric variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtosis(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kurtosis_+3A_x">x</code></td>
<td>
<p>A numeric variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kurtosis value
</p>

<hr>
<h2 id='manual_fix'>Tracked manual fixes to data</h2><span id='topic+manual_fix'></span>

<h3>Description</h3>

<p>Tracks manual fixes performed on a variable in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual_fix(data, variable, subset, newvalues = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manual_fix_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="manual_fix_+3A_variable">variable</code></td>
<td>
<p>A character string with the name of the variable to be fixed</p>
</td></tr>
<tr><td><code id="manual_fix_+3A_subset">subset</code></td>
<td>
<p>A logical expression for selecting the cases to be fixed</p>
</td></tr>
<tr><td><code id="manual_fix_+3A_newvalues">newvalues</code></td>
<td>
<p>New value or values that will take the cases selected by <code>subset</code> parameter.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>iris2 &lt;- manual_fix(iris, "Petal.Length", Petal.Length &lt; 1.2, 0)
track_changes(iris2)
</code></pre>

<hr>
<h2 id='may.numeric'>Checks if each value might be numeric</h2><span id='topic+may.numeric'></span>

<h3>Description</h3>

<p>Checks if each value from a vector might be numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>may.numeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="may.numeric_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>

<hr>
<h2 id='mine.plot'>Mine plot</h2><span id='topic+mine.plot'></span>

<h3>Description</h3>

<p>Creates a heatmap-like plot for exploring the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mine.plot(
  x,
  fun = is.na,
  spacing = 5,
  sort = F,
  show.x = TRUE,
  show.y = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mine.plot_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_fun">fun</code></td>
<td>
<p>A function that evaluates a vector and returns a logical vector</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_spacing">spacing</code></td>
<td>
<p>Numerical separation between lines at the y-axis</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_sort">sort</code></td>
<td>
<p>If TRUE, variables are sorted according to their results</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_show.x">show.x</code></td>
<td>
<p>Should the x-axis be plotted?</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_show.y">show.y</code></td>
<td>
<p>Should the y-axis be plotted?</p>
</td></tr>
<tr><td><code id="mine.plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to order()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mine.plot(airquality)   #Displays missing data
mine.plot(airquality, fun=outliers)   #Shows extreme values
</code></pre>

<hr>
<h2 id='moda'>Get mode</h2><span id='topic+moda'></span>

<h3>Description</h3>

<p>Returns the most repeated value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moda(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moda_+3A_x">x</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mode
</p>

<hr>
<h2 id='moda_cont'>Estimates number of modes</h2><span id='topic+moda_cont'></span>

<h3>Description</h3>

<p>Estimates the number of modes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moda_cont(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moda_cont_+3A_x">x</code></td>
<td>
<p>A numeric variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated number of modes.
</p>

<hr>
<h2 id='mtapply'>Multiple tapply</h2><span id='topic+mtapply'></span>

<h3>Description</h3>

<p>Modification of the tapply function to use with data.frames. Consider using aggregate()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtapply(x, group, fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mtapply_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="mtapply_+3A_group">group</code></td>
<td>
<p>Grouping variable</p>
</td></tr>
<tr><td><code id="mtapply_+3A_fun">fun</code></td>
<td>
<p>Function to apply by group</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtapply(mtcars, mtcars$gear, mean)
</code></pre>

<hr>
<h2 id='mtcars_messy'>Messy Motor Trend Car Road Tests Dataset</h2><span id='topic+mtcars_messy'></span>

<h3>Description</h3>

<p>Modified version of the mtcars dataset with different types of errors
in the data. The dataset has 13 variables and 32 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtcars_messy
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations and 13 variables
</p>


<h3>Source</h3>

<p><code>datasets</code> package
</p>


<h3>References</h3>

<p>Henderson and Velleman (1981), Building multiple regression
models interactively. Biometrics, 37, 391–411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>descriptive(mtcars_messy)
</code></pre>

<hr>
<h2 id='nearest'>Internal function for descriptive()</h2><span id='topic+nearest'></span>

<h3>Description</h3>

<p>Finds positions for substitution of characters in Distribution column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest(x, to = seq(0, 1, length.out = 30))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearest_+3A_x">x</code></td>
<td>
<p>A numeric value between 0-1</p>
</td></tr>
<tr><td><code id="nearest_+3A_to">to</code></td>
<td>
<p>Range of reference values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nearest position to the input value
</p>

<hr>
<h2 id='nice_names'>Nice names</h2><span id='topic+nice_names'></span>

<h3>Description</h3>

<p>Changes names of a data frame to ease work with them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice_names(x, select = 1:ncol(x), tolower = TRUE, track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nice_names_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="nice_names_+3A_select">select</code></td>
<td>
<p>Numeric vector with the positions (all by default) to be affected by the function</p>
</td></tr>
<tr><td><code id="nice_names_+3A_tolower">tolower</code></td>
<td>
<p>Set all names to lower case?</p>
</td></tr>
<tr><td><code id="nice_names_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data.frame <code>x</code> with the fixed names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame('Variable 1'=NA, '% Response'=NA, ' Variable     3'=NA,check.names=FALSE)
names(d)
names(nice_names(d))
</code></pre>

<hr>
<h2 id='numeros'>Brute numeric coercion</h2><span id='topic+numeros'></span>

<h3>Description</h3>

<p>If possible, coerces values from a vector to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeros(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numeros_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>

<hr>
<h2 id='outliers'>outliers</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p>Function for detecting outliers based on the boxplot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(x, threshold = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outliers_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="outliers_+3A_threshold">threshold</code></td>
<td>
<p>Threshold (as multiple of the IQR) to consider an observation as outlier</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>outliers(iris$Petal.Length)
outliers(airquality$Ozone)
</code></pre>

<hr>
<h2 id='peek'>Peek</h2><span id='topic+peek'></span>

<h3>Description</h3>

<p>Takes a peek into a data.frame returning a concise visualization about it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(x, n = 10, which = 1:ncol(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peek_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="peek_+3A_n">n</code></td>
<td>
<p>Number of rows to include in output</p>
</td></tr>
<tr><td><code id="peek_+3A_which">which</code></td>
<td>
<p>Columns to include in output</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>peek(iris)
</code></pre>

<hr>
<h2 id='prop_may'>Gets proportion of most repeated value</h2><span id='topic+prop_may'></span>

<h3>Description</h3>

<p>Returns the proportion for the most repeated value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_may(x, ignore.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_may_+3A_x">x</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
<tr><td><code id="prop_may_+3A_ignore.na">ignore.na</code></td>
<td>
<p>Should NA values be ignored for computing proportions?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A proportion
</p>

<hr>
<h2 id='prop_min'>Gets proportion of least repeated value</h2><span id='topic+prop_min'></span>

<h3>Description</h3>

<p>Returns the proportion for the least repeated value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_min(x, ignore.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_min_+3A_x">x</code></td>
<td>
<p>A categorical variable</p>
</td></tr>
<tr><td><code id="prop_min_+3A_ignore.na">ignore.na</code></td>
<td>
<p>Should NA values be ignored for computing proportions?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A proportion
</p>

<hr>
<h2 id='remove_empty'>remove_empty</h2><span id='topic+remove_empty'></span>

<h3>Description</h3>

<p>Removes empty rows or columns from data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty(x, remove_rows = TRUE, remove_cols = TRUE, track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_remove_rows">remove_rows</code></td>
<td>
<p>Remove empty rows?</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_remove_cols">remove_cols</code></td>
<td>
<p>Remove empty columns?</p>
</td></tr>
<tr><td><code id="remove_empty_+3A_track">track</code></td>
<td>
<p>Track changes?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(a = c(NA, NA, NA, NA, NA), b = c(1, NA, 3, 4, 5),
c=c(NA, NA, NA, NA, NA), d=c(4, NA, 5, 6, 3))
remove_empty(mydata)
</code></pre>

<hr>
<h2 id='restore_changes'>Restore changes</h2><span id='topic+restore_changes'></span>

<h3>Description</h3>

<p>Restores original values after using a fix function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore_changes(tracking)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restore_changes_+3A_tracking">tracking</code></td>
<td>
<p>A data.frame generated by track_changes() function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata&lt;-data.frame(Dates1=c("25/06/1983", "25-08/2014", "2001/11/01", "2008-10-01"),
                   Dates2=c("01/01/85", "04/04/1982", "07/12-2016", NA),
                   Numeric1=rnorm(4))
mydata &lt;- fix_dates(mydata)
mydata
tracking &lt;- track_changes(mydata)
mydata_r &lt;- restore_changes(tracking)
mydata_r
</code></pre>

<hr>
<h2 id='scale_01'>Scales data between 0 and 1</h2><span id='topic+scale_01'></span>

<h3>Description</h3>

<p>Escale data to 0-1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_01(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_01_+3A_x">x</code></td>
<td>
<p>A numeric variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled data
</p>

<hr>
<h2 id='search_scripts'>Search scripts</h2><span id='topic+search_scripts'></span>

<h3>Description</h3>

<p>Searches for strings in R script files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_scripts(string, path = getwd(), recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_scripts_+3A_string">string</code></td>
<td>
<p>Character string to search</p>
</td></tr>
<tr><td><code id="search_scripts_+3A_path">path</code></td>
<td>
<p>Character vector with the path name</p>
</td></tr>
<tr><td><code id="search_scripts_+3A_recursive">recursive</code></td>
<td>
<p>Logical. Should the search be recursive into subdirectories?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with each element being one of the files containing the search string
</p>

<hr>
<h2 id='skewness'>Computes skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Calculates skewness of a numeric variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>A numeric variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>skewness value
</p>

<hr>
<h2 id='text_date'>Internal function for dates with text</h2><span id='topic+text_date'></span>

<h3>Description</h3>

<p>Function to transform text into dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_date(date, format = "%d/%Y %b")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text_date_+3A_date">date</code></td>
<td>
<p>A date</p>
</td></tr>
<tr><td><code id="text_date_+3A_format">format</code></td>
<td>
<p>Format of the date</p>
</td></tr>
</table>

<hr>
<h2 id='track_changes'>track_changes</h2><span id='topic+track_changes'></span>

<h3>Description</h3>

<p>Gets a data.frame with all the changes performed by the different fix functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_changes(x, subset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track_changes_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="track_changes_+3A_subset">subset</code></td>
<td>
<p>Logical expression for subsetting the data.frame with the changes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mydata&lt;-data.frame(Dates1=c("25/06/1983", "25-08/2014", "2001/11/01", "2008-10-01"),
                   Dates2=c("01/01/85", "04/04/1982", "07/12-2016", NA),
                   Numeric1=rnorm(4))
mydata &lt;- fix_dates(mydata)
mydata
track_changes(mydata)
</code></pre>

<hr>
<h2 id='ttrue'>True TRUE</h2><span id='topic+ttrue'></span>

<h3>Description</h3>

<p>Makes possible vectorized logical comparisons against NULL and NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttrue(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ttrue_+3A_x">x</code></td>
<td>
<p>A logical vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>

<hr>
<h2 id='unforge'>Un-Forge</h2><span id='topic+unforge'></span>

<h3>Description</h3>

<p>Reshapes a data frame from long to wide format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unforge(data, origin, variables, prefix = origin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unforge_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="unforge_+3A_origin">origin</code></td>
<td>
<p>Character vector with variable names in data containing the values to be assigned to the different new variables</p>
</td></tr>
<tr><td><code id="unforge_+3A_variables">variables</code></td>
<td>
<p>Variable in data containing the variable names to be created</p>
</td></tr>
<tr><td><code id="unforge_+3A_prefix">prefix</code></td>
<td>
<p>Vector with prefixes for the new variable names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Data frame in wide format
df1 &lt;- data.frame(id = 1:4, age = c(20, 30, 30, 35), score1 = c(2,2,3,4),
                  score2 = c(2,1,3,1), score3 = c(1,1,0,1))
df1
#Data frame in long format
df2 &lt;- forge(df1, affixes= c("1", "2", "3"))
df2
#Data frame in wide format again
df3 &lt;- unforge(df2, "score", "time", prefix="score")

</code></pre>

<hr>
<h2 id='v_df_changes'>Internal function to track_changes</h2><span id='topic+v_df_changes'></span>

<h3>Description</h3>

<p>Function to track_changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_df_changes(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v_df_changes_+3A_x">x</code></td>
<td>
<p>Original data.frame</p>
</td></tr>
<tr><td><code id="v_df_changes_+3A_y">y</code></td>
<td>
<p>New data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='workspace'>Explores global environment workspace</h2><span id='topic+workspace'></span>

<h3>Description</h3>

<p>Returns information regarding the different objects in global environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workspace(table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="workspace_+3A_table">table</code></td>
<td>
<p>If TRUE a table with the frequencies of each type of object is given</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object names by class or a table with frequencies if table = TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(x=rnorm(10), y=rnorm(10, 1, 2))
df2 &lt;- data.frame(x=rnorm(20), y=rnorm(20, 1, 2))
workspace(table=TRUE)  #Frequency table of the different object classes
workspace()  #All objects in the global object separated by class
</code></pre>

<hr>
<h2 id='workspace_sapply'>Applies a function over objects of a specific class</h2><span id='topic+workspace_sapply'></span>

<h3>Description</h3>

<p>Applies a function over all objects of a specific class in the global environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workspace_sapply(object_class, action = "summary")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="workspace_sapply_+3A_object_class">object_class</code></td>
<td>
<p>Class of the objects where the function is to be applied</p>
</td></tr>
<tr><td><code id="workspace_sapply_+3A_action">action</code></td>
<td>
<p>Name of the function to apply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of the function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(x=rnorm(10), y=rnorm(10, 1, 2))
df2 &lt;- data.frame(x=rnorm(20), y=rnorm(20, 1, 2))
workspace_sapply("data.frame", "summary")  #Gives a summary of each data.frame
</code></pre>

<hr>
<h2 id='xscores'>Estimate sample scores</h2><span id='topic+xscores'></span>

<h3>Description</h3>

<p>Calculates different scores to measure how much extreme are the different data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xscores(x, type = "z")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xscores_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="xscores_+3A_type">type</code></td>
<td>
<p>'z' calculates standard normal scores, 'z-out' calculates standard normal scores excluding
each data point when computing the mean and the standard deviation, 't' calculates t scores,
'chisq' calculates chisquared scores, 'tukey' calculates scores based on the boxplot method,
'mad' calculates scores using median and mad instead of mean and sd.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xscores(iris$Sepal.Length, type="z-out")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
