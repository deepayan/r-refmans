<!DOCTYPE html><html><head><title>Help for package IntervalSurgeon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IntervalSurgeon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate'><p>Annotate one set of intervals with the names of those which intersect with the other</p></a></li>
<li><a href='#breaks'><p>Get break points for set of intervals</p></a></li>
<li><a href='#depth'><p>Depth of piled intervals</p></a></li>
<li><a href='#detached_sorted_nonempty'><p>Check intervals are detached, sorted and non-empty.</p></a></li>
<li><a href='#flatten'><p>Flatten a set of intervals</p></a></li>
<li><a href='#intersected'><p>Determine whether each interval in a given set are intersected/covered by intervals in another set</p></a></li>
<li><a href='#IntervalSurgeon-package'><p>Operating on Integer-Bounded Intervals</p></a></li>
<li><a href='#join'><p>Get all overlapping tuples of intervals from multiple sets</p></a></li>
<li><a href='#overlaps'><p>Compute overlaps of two sets of detached and sorted intervals</p></a></li>
<li><a href='#pile'><p>Get IDs of intervals covering each sub-interval</p></a></li>
<li><a href='#proportion_overlap'><p>Calculate proportion overlapping of intersecting intervals</p></a></li>
<li><a href='#sections'><p>Get the sections from a set of interval breaks</p></a></li>
<li><a href='#stitch'><p>Stich together touching intervals and remove empty intervals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Operating on Integer-Bounded Intervals</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Greene</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Greene &lt;dg333@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Manipulate integer-bounded intervals including finding overlaps, piling and merging.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 22:08:31 UTC; dg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate'>Annotate one set of intervals with the names of those which intersect with the other</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>Create a list of vectors of indices/names of intervals/points in <code>annotation</code> (if <code>annotation</code> is a two-column matrix/vector respectively) which intersect with each interval/point in <code>x</code> (if <code>x</code> is a two-column matrix/vector respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(x, annotation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points, or, an integer vector specifying the location of points.</p>
</td></tr>
<tr><td><code id="annotate_+3A_annotation">annotation</code></td>
<td>
<p>Matrix specifying intervals or vector specifying points with which to annotate <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of vectors of indices of overlapping intervals/points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>annotate(rbind(A=c(1, 100), B=c(50, 100)), rbind(a=c(1, 2), b=c(49, 51), c=c(50, 200)))
annotate(rbind(A=c(1, 100), B=c(50, 100)), c(a=1, b=49, c=51, d=100))
</code></pre>

<hr>
<h2 id='breaks'>Get break points for set of intervals</h2><span id='topic+breaks'></span>

<h3>Description</h3>

<p>Get the sorted set start points and end points for a set of intervals specified as an integer matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breaks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breaks_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ordered integer vector of unique interval start/end points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>breaks(cbind(2*1:5, 3*1:5))
</code></pre>

<hr>
<h2 id='depth'>Depth of piled intervals</h2><span id='topic+depth'></span>

<h3>Description</h3>

<p>Get the depth of piled intervals for each section in the sections of <code>x</code> (see <code><a href="#topic+sections">sections</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(x, include_intervals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
<tr><td><code id="depth_+3A_include_intervals">include_intervals</code></td>
<td>
<p>Logical value determining whether the function should return a vector of depths at each &lsquo;section&rsquo; in the range of <code>x</code> (see <code><a href="#topic+sections">sections</a></code>), or a list with properties <code>intervals</code> and <code>depths</code> specifying the intervals of the sections and the corresponding depths respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector giving depth of piled intervals from <code>x</code> (within each sub-interval) or list containing a property <code>"intervals"</code>, a matrix of sections, and property <code>"depths"</code>, giving the corresponding pile depths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depth(cbind(1:10, 11:20))
</code></pre>

<hr>
<h2 id='detached_sorted_nonempty'>Check intervals are detached, sorted and non-empty.</h2><span id='topic+detached_sorted_nonempty'></span>

<h3>Description</h3>

<p>Check that <code>x</code> is an integer matrix specifying intervals, that the specified intervals are detached (i.e. non-overlapping/disjoint and non-touching) and that it is sorted (given that the intervals are detached, sorting by start position gives a unique result), and that the start points are greater than the end points (i.e. that they are non-empty/the lengths of all intervals is greater than zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detached_sorted_nonempty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detached_sorted_nonempty_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>detached_sorted_nonempty(cbind(1:2, 2:3)) 
detached_sorted_nonempty(cbind(c(1, 3), c(2, 4))) 
detached_sorted_nonempty(cbind(1, 1)) 
</code></pre>

<hr>
<h2 id='flatten'>Flatten a set of intervals</h2><span id='topic+flatten'></span>

<h3>Description</h3>

<p>For a given set of intervals compute the set of intervals where there is overlap with at least one from the given. The resulting intervals are sorted and detached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intervals represented by integer matrix of two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flatten(rbind(c(1, 3), c(2, 4), c(5, 6)))
</code></pre>

<hr>
<h2 id='intersected'>Determine whether each interval in a given set are intersected/covered by intervals in another set</h2><span id='topic+intersected'></span><span id='topic+covered'></span>

<h3>Description</h3>

<p>Compute a logical vector indicating whether corresponding intervals specified by <code>x</code> overlap (<code>intersected</code>)/are covered by (<code>covered</code>) those in <code>by_intervals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersected(x, by_intervals)

covered(x, by_intervals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersected_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points, or, an integer vector specifying the location of points.</p>
</td></tr>
<tr><td><code id="intersected_+3A_by_intervals">by_intervals</code></td>
<td>
<p>Matrix specifying intervals to test for intersection of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector with elements corresponding to rows of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>intersected(rbind(c(1, 2), c(49, 51), c(50, 200)), rbind(c(50, 100)))
covered(rbind(c(1, 10), c(49, 51), c(50, 200)), rbind(c(2, 60)))
</code></pre>

<hr>
<h2 id='IntervalSurgeon-package'>Operating on Integer-Bounded Intervals</h2><span id='topic+IntervalSurgeon-package'></span><span id='topic+IntervalSurgeon'></span>

<h3>Description</h3>

<p>Manipulate integer-bounded intervals including finding overlaps, piling and merging.</p>


<h3>Details</h3>

<p>The DESCRIPTION file: </p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> IntervalSurgeon</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Operating on Integer-Bounded Intervals</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-20</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Daniel Greene</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Daniel Greene &lt;dg333@cam.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Manipulate integer-bounded intervals including finding overlaps, piling and merging.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.12.4)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,
rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
IntervalSurgeon-package                                     Operating on Integer-Bounded Intervals
annotate                                                    Annotate one set of intervals with the names of those which intersect with the other
breaks                                                      Get break points for set of intervals
depth                                                       Depth of piled intervals
detached_sorted_nonempty                                    Check intervals are detached, sorted and non-empty.
flatten                                                     Flatten a set of intervals
intersected                                                 Determine whether each interval in a given set are intersected/covered by intervals in another set
join                                                        Get all overlapping tuples of intervals from multiple sets
overlaps                                                    Compute overlaps of two sets of detached and sorted intervals
pile                                                        Get IDs of intervals covering each sub-interval
proportion_overlap                                          Calculate proportion overlapping of intersecting intervals
sections                                                    Get the sections from a set of interval breaks
stitch                                                      Stich together touching intervals and remove empty intervals
</pre>
<p>IntervalSurgeon presents functions for manipulating integer-bounded sets of intervals.
Sets of intervals are represented by two-column matrices, where inclusive start points are stored in the first column, and exclusive end points in the second.
A central concept in the package is the &lsquo;sections&rsquo; of a set of intervals <code>x</code>: the non-overlapping, completely-covering set of intervals on the range of <code>x</code>, formed by making intervals between the consecutive sorted start/end points of the intevals in <code>x</code>.
The function <code>sections</code> returns such a set of intervals given an input set.
</p>


<h3>Author(s)</h3>

<p>Daniel Greene
</p>
<p>Maintainer: Daniel Greene &lt;dg333@cam.ac.uk&gt;
</p>

<hr>
<h2 id='join'>Get all overlapping tuples of intervals from multiple sets</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Get matrix specifying overlapping tuples of intervals from multiple sets. Each row specifies an overlapping tuple. The <code>n</code>th element in a row contains the row index of the interval in the <code>n</code>th set of intervals passed to the function. Depending on the value of the <code>output</code> argument, there may two additional columns giving the start and end coordinates of the overlap (the default: <code>output="intervals"</code>, no extra columns (<code>output="indices"</code>) or one additional column giving the row index of the 'section' of the complete set of intervals (<code>output="sections"</code>, see <code><a href="#topic+sections">sections</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(..., output = "intervals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p>Integer matrices of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
<tr><td><code id="join_+3A_output">output</code></td>
<td>
<p>Character value, one of <code>"intervals"</code>, <code>"indices"</code> and <code>"sections"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>join(rbind(c(1, 100), c(50, 100)), rbind(c(1, 2), c(49, 51), c(50, 200)))
</code></pre>

<hr>
<h2 id='overlaps'>Compute overlaps of two sets of detached and sorted intervals</h2><span id='topic+overlaps'></span><span id='topic+intersects'></span><span id='topic+unions'></span><span id='topic+setdiffs'></span>

<h3>Description</h3>

<p>Find intervals satisfying particular conditions, including corresponding base R functions <code>intersect</code> (i.e. find intersections of intervals), <code>union</code> (i.e. unions of intervals) and <code>setdiff</code> (i.e. finding intervals which are contained in one set of intervals but not another).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlaps(x, y, check = TRUE, in_x = TRUE, in_y = TRUE, op = "and")

intersects(x, y, ...)

unions(x, y, ...)

setdiffs(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlaps_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code>.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_check">check</code></td>
<td>
<p>Boolean value determining whether to check that the intervals specified in arguments <code>x</code> and <code>y</code> are sorted and non-overlapping (uses function <code><a href="#topic+detached_sorted_nonempty">detached_sorted_nonempty</a></code>). Defaults to <code>TRUE</code>, but setting to <code>FALSE</code> may allow faster execution.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_in_x">in_x</code></td>
<td>
<p>Boolean value determining whether to flag <code>TRUE</code> on intervals contained in <code>x</code>.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_in_y">in_y</code></td>
<td>
<p>Boolean value determining whether to flag <code>TRUE</code> on intervals contained in <code>y</code>.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_op">op</code></td>
<td>
<p>Character value specifying operator used to combine flags for each interval, either <code>"and"</code> or <code>"or"</code>.</p>
</td></tr>
<tr><td><code id="overlaps_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>overlaps</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intervals represented by integer matrix of two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>intersects(cbind(1, 3), cbind(2, 4))
setdiffs(cbind(1, 3), cbind(2, 4))
unions(cbind(1, 3), cbind(2, 4))
</code></pre>

<hr>
<h2 id='pile'>Get IDs of intervals covering each sub-interval</h2><span id='topic+pile'></span>

<h3>Description</h3>

<p>Get the intervals overlapping each section as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pile(x, interval_names = rownames(x), output = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pile_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
<tr><td><code id="pile_+3A_interval_names">interval_names</code></td>
<td>
<p>Character vector of names for each interval, not necessarily unique. If they are not unique, one might wish to <code>lapply</code> <code>unique</code> to the list of members for each sub-interval returned by this function. Defaults to the <code>rownames</code> of <code>x</code>.</p>
</td></tr>
<tr><td><code id="pile_+3A_output">output</code></td>
<td>
<p>Character value either <code>"list"</code> or <code>"vector"</code> determining whether a named list of interval index/name vectors or flat vector of members (corresponding to the output of <code><a href="#topic+depth">depth</a></code>) is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See notes on <code>output</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pile(cbind(1:10, 11:20))
</code></pre>

<hr>
<h2 id='proportion_overlap'>Calculate proportion overlapping of intersecting intervals</h2><span id='topic+proportion_overlap'></span>

<h3>Description</h3>

<p>Proportion overlapping is calculated as the size of the intersection of intervals, divided by the size of the union.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proportion_overlap(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportion_overlap_+3A_...">...</code></td>
<td>
<p>Interval matrices (passed to <code><a href="#topic+join">join</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing integer columns corresponding to indices of intervals within the input matrices and a final numeric column called <code>proportion_overlap</code> containing the fraction of the size of the intersection within the union.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proportion_overlap(rbind(c(1, 2), c(49, 51), c(50, 200)), rbind(c(50, 100)))
</code></pre>

<hr>
<h2 id='sections'>Get the sections from a set of interval breaks</h2><span id='topic+sections'></span>

<h3>Description</h3>

<p>Given a set of interval breaks (see <code><a href="#topic+breaks">breaks</a></code>), generate a new set of intervals, the &lsquo;sections&rsquo;, which partitions the full range of the given set, with an interval between every &lsquo;break&rsquo; (i.e. start/end point) in the given set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sections(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sections_+3A_x">x</code></td>
<td>
<p>Sorted integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intervals represented by integer matrix of two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sections(1:10)
</code></pre>

<hr>
<h2 id='stitch'>Stich together touching intervals and remove empty intervals</h2><span id='topic+stitch'></span>

<h3>Description</h3>

<p>Given an integer matrix specifying disjoint intervals sorted by start position, merge intervals with matching start and ends, and remove intervals of length zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitch_+3A_x">x</code></td>
<td>
<p>Integer matrix of two columns, the first column giving the (inclusive) start points of intervals and the second column giving the corresponding (exclusive) end points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intervals represented by integer matrix of two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stitch(cbind(1:2, 2:3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
