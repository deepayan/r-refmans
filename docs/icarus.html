<!DOCTYPE html><html><head><title>Help for package icarus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icarus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addMargin'><p>Adds a margin to marginMatrix</p></a></li>
<li><a href='#calibration'><p>Calibration on margins</p></a></li>
<li><a href='#calibrationMarginStats'><p>Stats for initial weights, calibrated weights, and margins.</p></a></li>
<li><a href='#calWeights_movies'><p>Calibration weights for <code>data_employees</code></p></a></li>
<li><a href='#colToDummies'><p>Changes a column containing multiple values</p>
to a matrix of columns containing the dummies
corresponding to each value.</a></li>
<li><a href='#data_employees'><p>A small example sample for calibration with Icarus</p></a></li>
<li><a href='#dataPop'><p>Test population for Icarus.</p></a></li>
<li><a href='#HTmean'><p>Weighted estimator for the mean</p></a></li>
<li><a href='#HTtotal'><p>Weighted estimator for total</p></a></li>
<li><a href='#marginStats'><p>Stats for initial weights, calibrated weights, and margins.</p></a></li>
<li><a href='#newMarginMatrix'><p>Create empty margin matrix</p></a></li>
<li><a href='#poptest_calmar'><p>Calibration on population test - made on Calmar2</p></a></li>
<li><a href='#poptest_calmar_nr'><p>Calibration with nonresponse on population test - made on Calmar2</p></a></li>
<li><a href='#regroupCalibrationModalities'><p>Regroup calibration modalities</p></a></li>
<li><a href='#regroupModalities'><p>Regroup elements of a vector</p></a></li>
<li><a href='#table_margins_1'><p>Margins for calibration of test population</p></a></li>
<li><a href='#table_margins_2'><p>Margins for calibration of test population</p></a></li>
<li><a href='#weightedMean'><p>Weighted estimator for the mean</p></a></li>
<li><a href='#weightedTotal'><p>Weighted estimator for total</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Calibrates and Reweights Units in Samples</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides user-friendly tools for calibration in survey sampling.
    The package is production-oriented, and its interface is inspired by the famous
    popular macro 'Calmar' for SAS, so that 'Calmar' users can quickly get used to
    'icarus'. In addition to calibration (with linear, raking and logit methods),
    'icarus' features functions for calibration on tight bounds and penalized
    calibration.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Rebecq &lt;antoine.rebecq@m4x.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggplot2, Rglpk, slam, xtable, magrittr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-27 01:03:07 UTC; rharoine2</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Rebecq [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-27 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addMargin'>Adds a margin to marginMatrix</h2><span id='topic+addMargin'></span>

<h3>Description</h3>

<p>Adds a margin to marginMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMargin(
  marginMatrix,
  varName,
  vecTotals,
  adjustToOne = TRUE,
  thresholdAdjustToOne = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMargin_+3A_marginmatrix">marginMatrix</code></td>
<td>
<p>The matrix of margins to add the new margin to</p>
</td></tr>
<tr><td><code id="addMargin_+3A_varname">varName</code></td>
<td>
<p>Name of variable in calibration matrix corresponding
to the new margin</p>
</td></tr>
<tr><td><code id="addMargin_+3A_vectotals">vecTotals</code></td>
<td>
<p>values of margins (Calmar style) for the variable.
Note : if length(vecTotals) &gt; 1, then sum(thresholdAdjustToOne) has to be 1.</p>
</td></tr>
<tr><td><code id="addMargin_+3A_adjusttoone">adjustToOne</code></td>
<td>
<p>if TRUE and sum(vecTotals) is nearly 1, modify values of vecTotals
so that sum is 1.</p>
</td></tr>
<tr><td><code id="addMargin_+3A_thresholdadjusttoone">thresholdAdjustToOne</code></td>
<td>
<p>adjust sum(vecTotals) to 1 if difference
is under thresholdAdjustToOne</p>
</td></tr>
</table>

<hr>
<h2 id='calibration'>Calibration on margins</h2><span id='topic+calibration'></span>

<h3>Description</h3>

<p>Performs calibration on margins with several methods and customizable parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration(
  data,
  marginMatrix,
  colWeights,
  method = "linear",
  bounds = NULL,
  q = NULL,
  costs = NULL,
  gap = NULL,
  popTotal = NULL,
  pct = FALSE,
  scale = NULL,
  description = TRUE,
  maxIter = 2500,
  check = TRUE,
  calibTolerance = 1e-06,
  uCostPenalized = 1,
  lambda = NULL,
  precisionBounds = 1e-04,
  forceSimplex = FALSE,
  forceBisection = FALSE,
  colCalibratedWeights,
  exportDistributionImage = NULL,
  exportDistributionTable = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_+3A_data">data</code></td>
<td>
<p>The dataframe containing the survey data</p>
</td></tr>
<tr><td><code id="calibration_+3A_marginmatrix">marginMatrix</code></td>
<td>
<p>The matrix giving the margins for each column variable included
in the calibration problem</p>
</td></tr>
<tr><td><code id="calibration_+3A_colweights">colWeights</code></td>
<td>
<p>The name of the column containing the initial weights in the survey
dataframe</p>
</td></tr>
<tr><td><code id="calibration_+3A_method">method</code></td>
<td>
<p>The method used to calibrate. Can be &quot;linear&quot;, &quot;raking&quot;, &quot;logit&quot;</p>
</td></tr>
<tr><td><code id="calibration_+3A_bounds">bounds</code></td>
<td>
<p>Two-element vector containing the lower and upper bounds for bounded methods
(&quot;logit&quot;)</p>
</td></tr>
<tr><td><code id="calibration_+3A_q">q</code></td>
<td>
<p>Vector of q_k weights described in Deville and Sarndal (1992)</p>
</td></tr>
<tr><td><code id="calibration_+3A_costs">costs</code></td>
<td>
<p>The penalized calibration method will be used, using costs defined by this
vector. Must match the number of rows of marginMatrix. Negative of non-finite costs are given
an infinite cost (coefficient of C^-1 matrix is 0)</p>
</td></tr>
<tr><td><code id="calibration_+3A_gap">gap</code></td>
<td>
<p>Only useful for penalized calibration. Sets the maximum gap between max and min
calibrated weights / initial weights ratio (and thus is similar to the &quot;bounds&quot;
parameter used in regular calibration)</p>
</td></tr>
<tr><td><code id="calibration_+3A_poptotal">popTotal</code></td>
<td>
<p>Precise the total population if margins are defined by relative value in
marginMatrix (percentages)</p>
</td></tr>
<tr><td><code id="calibration_+3A_pct">pct</code></td>
<td>
<p>If TRUE, margins for categorical variables are considered to
be entered as percentages. popTotal must then be set. (FALSE by default)</p>
</td></tr>
<tr><td><code id="calibration_+3A_scale">scale</code></td>
<td>
<p>If TRUE, stats (including bounds) on ratio calibrated weights / initial weights are
done on a vector multiplied by the weighted non-response ratio (ratio population total /
total of initial weights). Has same behavior as &quot;ECHELLE=0&quot; in Calmar.</p>
</td></tr>
<tr><td><code id="calibration_+3A_description">description</code></td>
<td>
<p>If TRUE, output stats about the calibration process as well as the
graph of the density of the ratio calibrated weights / initial weights</p>
</td></tr>
<tr><td><code id="calibration_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations before stopping</p>
</td></tr>
<tr><td><code id="calibration_+3A_check">check</code></td>
<td>
<p>performs a few check about the dataframe. TRUE by default</p>
</td></tr>
<tr><td><code id="calibration_+3A_calibtolerance">calibTolerance</code></td>
<td>
<p>Tolerance for the distance to an exact solution.
Could be useful when there is a huge number of margins as the risk of
inadvertently setting incompatible constraints is higher. Set to 1e-06 by default.</p>
</td></tr>
<tr><td><code id="calibration_+3A_ucostpenalized">uCostPenalized</code></td>
<td>
<p>Unary cost by which every cost is &quot;costs&quot; column is multiplied</p>
</td></tr>
<tr><td><code id="calibration_+3A_lambda">lambda</code></td>
<td>
<p>The initial ridge lambda used in penalized calibration. By default, the initial
lambda is automatically chosen by the algorithm, but you can speed up the search for the optimum
if you already know a lambda close to the lambda_opt corresponding to the gap you set. Be careful,
the search zone is reduced when a lambda is set by the user, so the program may not converge
if the lambda set is too far from the lambda_opt.</p>
</td></tr>
<tr><td><code id="calibration_+3A_precisionbounds">precisionBounds</code></td>
<td>
<p>Only used for calibration on minimum bounds. Desired precision
for lower and upper reweighting factor, both bounds being as close to 1 as possible</p>
</td></tr>
<tr><td><code id="calibration_+3A_forcesimplex">forceSimplex</code></td>
<td>
<p>Only used for calibration on tight bounds.Bisection algorithm is used
for matrices whose size exceed 1e8. forceSimplex = TRUE forces the use of the simplex algorithm
whatever the size of the problem (you might want to set this parameter to TRUE if you
have a large memory size)</p>
</td></tr>
<tr><td><code id="calibration_+3A_forcebisection">forceBisection</code></td>
<td>
<p>Only used for calibration on tight bounds. Forces the use of the bisection
algorithm to solve calibration on tight bounds</p>
</td></tr>
<tr><td><code id="calibration_+3A_colcalibratedweights">colCalibratedWeights</code></td>
<td>
<p>Deprecated. Only used in the scope of calibration function</p>
</td></tr>
<tr><td><code id="calibration_+3A_exportdistributionimage">exportDistributionImage</code></td>
<td>
<p>File name to which the density plot shown when
description is TRUE is exported. Requires package &quot;ggplot2&quot;</p>
</td></tr>
<tr><td><code id="calibration_+3A_exportdistributiontable">exportDistributionTable</code></td>
<td>
<p>File name to which the distribution table of before/after
weights shown when description is TRUE is exported. Requires package &quot;xtable&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column containing the final calibrated weights
</p>


<h3>References</h3>

<p>Deville, Jean-Claude, and Carl-Erik Sarndal. &quot;Calibration estimators in survey sampling.&quot; 
Journal of the American statistical Association 87.418 (1992): 376-382.
</p>
<p>Bocci, J., and C. Beaumont. &quot;Another look at ridge calibration.&quot; 
Metron 66.1 (2008): 5-20.
</p>
<p>Vanderhoeft, Camille. Generalised calibration at statistics Belgium: SPSS Module G-CALIB-S and current practices. 
Inst. National de Statistique, 2001.
</p>
<p>Le Guennec, Josiane, and Olivier Sautory. &quot;Calmar 2: Une nouvelle version 
de la macro calmar de redressement d'echantillon par calage.&quot; Journees de Methodologie Statistique, 
Paris. INSEE (2002).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 300 ## population total
## Horvitz Thompson estimator of the mean: 1.666667
weightedMean(data_employees$movies, data_employees$weight, N) 
## Enter calibration margins:
mar1 &lt;- c("category",3,80,90,60)
mar2 &lt;- c("sex",2,140,90,0)
mar3 &lt;- c("department",2,100,130,0)
mar4 &lt;- c("salary", 0, 470000,0,0)
margins &lt;- rbind(mar1, mar2, mar3, mar4)
## Compute calibrated weights with raking ratio method
wCal &lt;- calibration(data=data_employees, marginMatrix=margins, colWeights="weight"
                            , method="raking", description=FALSE)
## Calibrated estimate: 2.471917
weightedMean(data_employees$movies, wCal, N)

</code></pre>

<hr>
<h2 id='calibrationMarginStats'>Stats for initial weights, calibrated weights, and margins.</h2><span id='topic+calibrationMarginStats'></span>

<h3>Description</h3>

<p>Gives stats about the calibration process: differences between 
totals after/before calibration and margins. Totals for categorical
variables are displayed in percentages.
(same as first panels output in Calmar/Calmar 2)
Output is a list, which might not be convenient for exports (e.g. for integration
into a scientific report). In such cases,
use function <code><a href="#topic+marginStats">marginStats</a></code>, which outputs a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrationMarginStats(
  data,
  marginMatrix,
  popTotal = NULL,
  pct = FALSE,
  colWeights,
  colCalibratedWeights = NULL,
  calibThreshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrationMarginStats_+3A_data">data</code></td>
<td>
<p>dataframe containing the survey data</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_marginmatrix">marginMatrix</code></td>
<td>
<p>matrix of margins</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_poptotal">popTotal</code></td>
<td>
<p>total of population, useful if margins are entered in relative value</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_pct">pct</code></td>
<td>
<p>Set this to true if margins for categorical variables are written in percentages</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_colweights">colWeights</code></td>
<td>
<p>name of weights column in the dataframe</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_colcalibratedweights">colCalibratedWeights</code></td>
<td>
<p>name of calibrated weights column in the dataframe (if applicable)</p>
</td></tr>
<tr><td><code id="calibrationMarginStats_+3A_calibthreshold">calibThreshold</code></td>
<td>
<p>If difference between calibration estimate and margin differ more than
this parameter, calibration is considered to have failed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing stats on weights and margins
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginStats">marginStats</a></code>
</p>

<hr>
<h2 id='calWeights_movies'>Calibration weights for <code><a href="#topic+data_employees">data_employees</a></code></h2><span id='topic+calWeights_movies'></span>

<h3>Description</h3>

<p>Calibration weights computed with Calmar2 for the small example <code><a href="#topic+data_employees">data_employees</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calWeights_movies
</code></pre>


<h3>Format</h3>

<p>1 column &quot;id&quot;, unique id for each of the 15 units in sample.
3 columns with calibration weights using 3 different methods (linear, raking, and logit
with bounds LO=0.4, UP=2.2)
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>

<hr>
<h2 id='colToDummies'>Changes a column containing multiple values
to a matrix of columns containing the dummies
corresponding to each value.</h2><span id='topic+colToDummies'></span>

<h3>Description</h3>

<p>Changes a column containing multiple values
to a matrix of columns containing the dummies
corresponding to each value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colToDummies(col, nameCol, modalities = NULL, keepValue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colToDummies_+3A_col">col</code></td>
<td>
<p>input column</p>
</td></tr>
<tr><td><code id="colToDummies_+3A_namecol">nameCol</code></td>
<td>
<p>name that will be used as a prefix for
dummies column name in the output matrix</p>
</td></tr>
<tr><td><code id="colToDummies_+3A_modalities">modalities</code></td>
<td>
<p>if a vector is entered, dummies produced
will only be the ones corresponding to the values in the
&quot;modalities&quot; input column + another one containing all
the other modalities.</p>
</td></tr>
<tr><td><code id="colToDummies_+3A_keepvalue">keepValue</code></td>
<td>
<p>Logical. If TRUE, puts not &quot;1&quot;s in the dummies output
columns but the real values in the &quot;col&quot; column (except if values are
non-numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the dummy columns
</p>

<hr>
<h2 id='data_employees'>A small example sample for calibration with Icarus</h2><span id='topic+data_employees'></span>

<h3>Description</h3>

<p>This table features a samples of 15 units (drawn from a population of size 300), 
used in a small survey to determine how frequently the employees of a firm go the movies (column &quot;cinema&quot;).
Some auxiliary variables are given, which allows the use of calibration to improve
estimates. Margins for these auxiliary variables are known:
categ: 80 (modality 1) ; 90 (modality 2) ; 60 (modality 3)
sexe: 140 (modality 1) ; 90 (modality 2)
service: 100 (modality 1) ; 130 (modality 2)
salaire : 470000
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_employees
</code></pre>


<h3>Format</h3>

<p>15 rows, one per unit in sample.
1 column &quot;id&quot;, unique id for each unit.
4 columns of auxiliary variables (&quot;service&quot;, &quot;categ&quot;, &quot;sexe&quot;, &quot;salaire&quot;).
1 column &quot;cinema&quot; - the variable of interest
1 column &quot;weight&quot; - the Horvitz-Thompson weights
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>

<hr>
<h2 id='dataPop'>Test population for Icarus.</h2><span id='topic+dataPop'></span>

<h3>Description</h3>

<p>This data set features a generated population of 50000 units.
11 characteristics of interest for all units in population are featured. 
These characteristics of interest are variously correlated to one another.
A stratified random sampling (with a proportional allocation on variable Y3) 
of fixed size 1000 is selected. Among the 1000 units in the selected sample, only
718 are respondant to the survey. These responding units are selected using a dummy
logit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataPop
</code></pre>


<h3>Format</h3>

<p>1 column &quot;ident&quot; with unique id for all units.
11 columns with various characteristics of interest for units in the population.
1 column &quot;weight&quot;, with sampling weights . Weights equal to zero means that the unit
is not selected in the sample.
1 column &quot;simul_nr&quot; indicates the probability that each unit will respond to the survey.
1 column &quot;responding&quot;. For sampled units, indicates whether unit is respondant to survey (1)
or not (0). Variable is also equal to 0 for units not selected in sample
1 column &quot;qTest&quot; containing randomly generated q weights used in unit tests
50000 rows, 1 row per unit in the population.
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>


<h3>References</h3>

<p>Rebecq, A., &amp; Merly-Alpa, T. Pourquoi minimiser la dispersion des 
poids en sondage. preprint.
</p>

<hr>
<h2 id='HTmean'>Weighted estimator for the mean</h2><span id='topic+HTmean'></span>

<h3>Description</h3>

<p>Computes the weighted estimator for the mean of a column. Alias for
<code><a href="#topic+weightedMean">weightedMean</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTmean(var, weights, popTot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTmean_+3A_var">var</code></td>
<td>
<p>column of variable of interest</p>
</td></tr>
<tr><td><code id="HTmean_+3A_weights">weights</code></td>
<td>
<p>column of weights matching the variable of interest</p>
</td></tr>
<tr><td><code id="HTmean_+3A_poptot">popTot</code></td>
<td>
<p>population size, used in Horvitz-Thompson-like estimation. 
If no value is given for popTot, default value is the sum of weights. In the context
of survey sampling, this is equivalent to using an Hajek estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated mean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightedMean">weightedMean</a></code>
</p>

<hr>
<h2 id='HTtotal'>Weighted estimator for total</h2><span id='topic+HTtotal'></span>

<h3>Description</h3>

<p>Computes the weighted estimator for the total of a column. Alias for
<code><a href="#topic+weightedTotal">weightedTotal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTtotal(var, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTtotal_+3A_var">var</code></td>
<td>
<p>column of variable of interest</p>
</td></tr>
<tr><td><code id="HTtotal_+3A_weights">weights</code></td>
<td>
<p>column of weights matching the variable of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated total
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightedTotal">weightedTotal</a></code>
</p>

<hr>
<h2 id='marginStats'>Stats for initial weights, calibrated weights, and margins.</h2><span id='topic+marginStats'></span>

<h3>Description</h3>

<p>Just like <code><a href="#topic+calibrationMarginStats">calibrationMarginStats</a></code>, gives stats about the calibration process: 
differences between totals after/before calibration and margins. Totals for categorical
variables are displayed in percentages. The last column, named &quot;difference&quot;, shows
the difference (in percentage points) between initial estimates and margins (if colCalibratedWeights is NULL) 
or between calibrated estimates and margins (if colCalibratedWeights is not NULL).
Output is a dataframe, which might be more convenient to export than a list
(e.g. for integration into reports).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginStats(
  data,
  marginMatrix,
  pct = FALSE,
  popTotal = NULL,
  colWeights,
  colCalibratedWeights = NULL,
  calibThreshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginStats_+3A_data">data</code></td>
<td>
<p>dataframe containing the survey data</p>
</td></tr>
<tr><td><code id="marginStats_+3A_marginmatrix">marginMatrix</code></td>
<td>
<p>matrix of margins</p>
</td></tr>
<tr><td><code id="marginStats_+3A_pct">pct</code></td>
<td>
<p>Set this to true if margins for categorical variables are written in percentages</p>
</td></tr>
<tr><td><code id="marginStats_+3A_poptotal">popTotal</code></td>
<td>
<p>total of population, useful if margins are entered in relative value</p>
</td></tr>
<tr><td><code id="marginStats_+3A_colweights">colWeights</code></td>
<td>
<p>name of weights column in the dataframe</p>
</td></tr>
<tr><td><code id="marginStats_+3A_colcalibratedweights">colCalibratedWeights</code></td>
<td>
<p>name of calibrated weights column in the dataframe (if applicable)</p>
</td></tr>
<tr><td><code id="marginStats_+3A_calibthreshold">calibThreshold</code></td>
<td>
<p>If difference between calibration estimate and margin differ more than
this parameter, calibration is considered to have failed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing stats on weights and margins
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrationMarginStats">calibrationMarginStats</a></code>
</p>

<hr>
<h2 id='newMarginMatrix'>Create empty margin matrix</h2><span id='topic+newMarginMatrix'></span>

<h3>Description</h3>

<p>Use this to create an empty margin matrix (which facilitates
the use of magrittr syntax to enter margins)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newMarginMatrix()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
N &lt;- 230 ## population total
## Horvitz Thompson estimator of the mean: 2.174
weightedMean(data_employees$movies, data_employees$weight, N)
## Enter calibration margins:
margins &lt;- newMarginMatrix() %&gt;%
  addMargin("category", c(0.35, 0.40, 0.25)) %&gt;%
  addMargin("sex", c(0.6, 0.4)) %&gt;%
  addMargin("department", c(0.45, 0.55)) %&gt;%
  addMargin("salary", 470000)
## Compute calibrated weights with raking ratio method
wCal &lt;- calibration(data=data_employees, marginMatrix=margins, colWeights="weight"
                    , method="raking", pct = TRUE, description=FALSE
                    , popTotal = N)
## Calibrated estimate: 2.471917
weightedMean(data_employees$movies, wCal, N)
</code></pre>

<hr>
<h2 id='poptest_calmar'>Calibration on population test - made on Calmar2</h2><span id='topic+poptest_calmar'></span>

<h3>Description</h3>

<p>This data set features calibration weights for the sample test of <code><a href="#topic+dataPop">dataPop</a></code>
(using margins tables <code><a href="#topic+table_margins_1">table_margins_1</a></code> and <code><a href="#topic+table_margins_2">table_margins_2</a></code>). Calibration is
is computed using the SAS Macro Calmar2, for test purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poptest_calmar
</code></pre>


<h3>Format</h3>

<p>1000 rows, one per unit in the sample.
1 column &quot;ident&quot;, with a unique id for every unit in the sample
3 methods of calibration are used (linear, raking, and logit with bounds LO=0.2 and UP=1.3) for
two different margins tables <code><a href="#topic+table_margins_1">table_margins_1</a></code> and <code><a href="#topic+table_margins_2">table_margins_2</a></code>, which results in 
7 columns of weights.
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>


<h3>References</h3>

<p>Le Guennec, J., and Sautory, O. (2002). Calmar 2: Une nouvelle version 
de la macro calmar de redressement d'echantillon par calage. 
Journees de Methodologie Statistique, Paris. INSEE.
</p>

<hr>
<h2 id='poptest_calmar_nr'>Calibration with nonresponse on population test - made on Calmar2</h2><span id='topic+poptest_calmar_nr'></span>

<h3>Description</h3>

<p>This data set features calibration weights for the sample test of <code><a href="#topic+dataPop">dataPop</a></code>
(using margins tables <code><a href="#topic+table_margins_1">table_margins_1</a></code> and <code><a href="#topic+table_margins_2">table_margins_2</a></code>). Calibration is
is computed using the SAS Macro Calmar2, for test purposes. Only the 718 responding units are
taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poptest_calmar_nr
</code></pre>


<h3>Format</h3>

<p>718 rows, one per unit in the sample.
1 column &quot;ident&quot;, with a unique id for every unit in the sample
3 methods of calibration are used (linear, raking, and logit with bounds LO=0.1 and UP=2.0 and parameter ECHELLE=0) for
two different margins tables <code><a href="#topic+table_margins_1">table_margins_1</a></code> and <code><a href="#topic+table_margins_2">table_margins_2</a></code>, which results in 
7 columns of weights.
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>


<h3>References</h3>

<p>Le Guennec, J., and Sautory, O. (2002). Calmar 2: Une nouvelle version 
de la macro calmar de redressement d'echantillon par calage. 
Journees de Methodologie Statistique, Paris. INSEE.
</p>

<hr>
<h2 id='regroupCalibrationModalities'>Regroup calibration modalities</h2><span id='topic+regroupCalibrationModalities'></span>

<h3>Description</h3>

<p>Beware, this function modifies the calibrationMatrix and marginMatrix objects entered in parameter?
Regroups modalities entered in &quot;vecModalities&quot; into single
&quot;newModality&quot; in &quot;calibrationMatrix&quot; and adapts &quot;marginMatrix&quot; to the new concept.
Typical usage is right before a calibration (and after comptutation of marginMatrix), when
you realise calibration output is better when several modalities are reduced to one.
(typically very rare modalities, on which calibration constraints are very restrictive).
Uses pseudo-&quot;call by reference&quot; via eval.parent because 2 objects are modified :
calibrationMatrix and marginMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroupCalibrationModalities(
  calibrationMatrix,
  marginMatrix,
  calibrationVariable,
  vecModalities,
  newModality
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroupCalibrationModalities_+3A_calibrationmatrix">calibrationMatrix</code></td>
<td>
<p>calibration matrix</p>
</td></tr>
<tr><td><code id="regroupCalibrationModalities_+3A_marginmatrix">marginMatrix</code></td>
<td>
<p>matrix containing the margins to the Icarus format</p>
</td></tr>
<tr><td><code id="regroupCalibrationModalities_+3A_calibrationvariable">calibrationVariable</code></td>
<td>
<p>name of the calibration varaible for which regroupment has to be done</p>
</td></tr>
<tr><td><code id="regroupCalibrationModalities_+3A_vecmodalities">vecModalities</code></td>
<td>
<p>Initial modalities of the variable</p>
</td></tr>
<tr><td><code id="regroupCalibrationModalities_+3A_newmodality">newModality</code></td>
<td>
<p>Regrouped modalities of the variable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Suppose we have a calibration matrix and a margin matrix containing information
## for two categorical variables "X1" (10 modalities) and "X2" (5 modalities)

matrixCal &lt;- data.frame(matrix(
               c(floor(10*runif(100))+1,floor((5)*runif(100))+1,
               floor(10*runif(100))+1,rep(10,100)),
               ncol=4))
marginMatrix &lt;- matrix(c("X1",10,rep(1/10,10),
                 "X2",5,rep(1/5,5),rep(0,5)), nrow=2, byrow=TRUE)

# table(matrixCal$X1)
# 1  2  3  4  5  6  7  8  9 10 
# 9  8  8  8 11 15 13  6 10 12 
# marginMatrix
# [,1] [,2] [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10] [,11] [,12]
# [1,] "X1" "10" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1"
# [2,] "X2" "5"  "0.2" "0.2" "0.2" "0.2" "0.2" "0"   "0"   "0"   "0"   "0" 

regroupCalibrationModalities(matrixCal, marginMatrix, "X1", c(3,4,8), "0")

# table(matrixCal$X1)
# 0  1  2  5  6  7  9 10 
# 22  9  8 11 15 13 10 12 
# marginMatrix
# [,1] [,2] [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]  [,10]
# [1,] "X1" "8"  "0.3" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1" "0.1"
# [2,] "X2" "5"  "0.2" "0.2" "0.2" "0.2" "0.2" "0"   "0"   "0"  

## End(Not run)
</code></pre>

<hr>
<h2 id='regroupModalities'>Regroup elements of a vector</h2><span id='topic+regroupModalities'></span>

<h3>Description</h3>

<p>Regroup the contiguous elements of a vector under a single value. Which elements should
be regrouped is indicated by the rows of a matrix. Output vector is NOT a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroupModalities(column, regroupMatrix, modalities = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroupModalities_+3A_column">column</code></td>
<td>
<p>Column vector which values are going to be replaced</p>
</td></tr>
<tr><td><code id="regroupModalities_+3A_regroupmatrix">regroupMatrix</code></td>
<td>
<p>Bounds of the values to regroup under the same modality</p>
</td></tr>
<tr><td><code id="regroupModalities_+3A_modalities">modalities</code></td>
<td>
<p>Specify the values of the modalities to use. Must match number of rows
of regroupMatrix
If not specified, replacement modalities will be 1:length(column)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column vector with regrouped modalities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regroupModalities(c(1:20), rbind(c(0,5),c(6,18),c(19,Inf)))
# Returns : [1] 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3
</code></pre>

<hr>
<h2 id='table_margins_1'>Margins for calibration of test population</h2><span id='topic+table_margins_1'></span>

<h3>Description</h3>

<p>This table features calibration margins for the sample of the test population
of <code><a href="#topic+dataPop">dataPop</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_margins_1
</code></pre>


<h3>Format</h3>

<p>A margins table written in the Icarus format.
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>

<hr>
<h2 id='table_margins_2'>Margins for calibration of test population</h2><span id='topic+table_margins_2'></span>

<h3>Description</h3>

<p>This table features calibration margins for the sample of the test population
of <code><a href="#topic+dataPop">dataPop</a></code>. Margins for categorical variables are entered in percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_margins_2
</code></pre>


<h3>Format</h3>

<p>A margins table written in the Icarus format.
</p>


<h3>Author(s)</h3>

<p>Antoine Rebecq
</p>

<hr>
<h2 id='weightedMean'>Weighted estimator for the mean</h2><span id='topic+weightedMean'></span>

<h3>Description</h3>

<p>Computes the weighted estimator for the mean of a column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMean(var, weights, popTot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedMean_+3A_var">var</code></td>
<td>
<p>column of variable of interest</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_weights">weights</code></td>
<td>
<p>column of weights matching the variable of interest</p>
</td></tr>
<tr><td><code id="weightedMean_+3A_poptot">popTot</code></td>
<td>
<p>population size, used in Horvitz-Thompson-like estimation. 
If no value is given for popTot, default value is the sum of weights. In the context
of survey sampling, this is equivalent to using an Hajek estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated mean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HTmean">HTmean</a></code>
</p>

<hr>
<h2 id='weightedTotal'>Weighted estimator for total</h2><span id='topic+weightedTotal'></span>

<h3>Description</h3>

<p>Computes the weighted estimator for the total of a column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedTotal(var, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedTotal_+3A_var">var</code></td>
<td>
<p>column of variable of interest</p>
</td></tr>
<tr><td><code id="weightedTotal_+3A_weights">weights</code></td>
<td>
<p>column of weights matching the variable of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated total
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HTtotal">HTtotal</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
