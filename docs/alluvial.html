<!DOCTYPE html><html><head><title>Help for package alluvial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alluvial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alluvial'><p>Alluvial diagram</p></a></li>
<li><a href='#alluvial_ts'><p>Alluvial diagram for multiple time series data</p></a></li>
<li><a href='#Refugees'><p>Refugees data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Alluvial Diagrams</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-09-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Creating alluvial diagrams (also known as parallel sets plots) for multivariate
  and time series-like data.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbojan/alluvial">https://github.com/mbojan/alluvial</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbojan/alluvial/issues">https://github.com/mbojan/alluvial/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, testthat, reshape2, knitr, rmarkdown, dplyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-09-09 09:58:05 UTC; mbojan</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Bojanowski [aut, cre],
  Robin Edwards [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Bojanowski &lt;michal2992@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-09-09 13:08:51</td>
</tr>
</table>
<hr>
<h2 id='alluvial'>Alluvial diagram</h2><span id='topic+alluvial'></span>

<h3>Description</h3>

<p>Drawing alluvial diagrams, also known as parallel set plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial(..., freq, col = "gray", border = 0, layer, hide = FALSE,
  alpha = 0.5, gap.width = 0.05, xw = 0.1, cw = 0.1, blocks = TRUE,
  ordering = NULL, axis_labels = NULL, cex = par("cex"),
  cex.axis = par("cex.axis"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_+3A_...">...</code></td>
<td>
<p>vectors or data frames, all for the same number of observations</p>
</td></tr>
<tr><td><code id="alluvial_+3A_freq">freq</code></td>
<td>
<p>numeric, vector of frequencies of the same length as the number of observations</p>
</td></tr>
<tr><td><code id="alluvial_+3A_col">col</code></td>
<td>
<p>vector of colors of the stripes</p>
</td></tr>
<tr><td><code id="alluvial_+3A_border">border</code></td>
<td>
<p>vector of border colors for the stripes</p>
</td></tr>
<tr><td><code id="alluvial_+3A_layer">layer</code></td>
<td>
<p>numeric, order of drawing of the stripes</p>
</td></tr>
<tr><td><code id="alluvial_+3A_hide">hide</code></td>
<td>
<p>logical, should particular stripe be plotted</p>
</td></tr>
<tr><td><code id="alluvial_+3A_alpha">alpha</code></td>
<td>
<p>numeric, vector of transparency of the stripes</p>
</td></tr>
<tr><td><code id="alluvial_+3A_gap.width">gap.width</code></td>
<td>
<p>numeric, relative width of inter-category gaps</p>
</td></tr>
<tr><td><code id="alluvial_+3A_xw">xw</code></td>
<td>
<p>numeric, the distance from the set axis to the control points of the xspline</p>
</td></tr>
<tr><td><code id="alluvial_+3A_cw">cw</code></td>
<td>
<p>numeric, width of the category axis</p>
</td></tr>
<tr><td><code id="alluvial_+3A_blocks">blocks</code></td>
<td>
<p>logical, whether to use blocks to tie the flows together at each category, versus contiguous ribbons (also admits character value &quot;bookends&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_+3A_ordering">ordering</code></td>
<td>
<p>list of numeric vectors allowing to reorder the alluvia on each axis separately, see Examples</p>
</td></tr>
<tr><td><code id="alluvial_+3A_axis_labels">axis_labels</code></td>
<td>
<p>character, labels of the axes, defaults to variable names in the data</p>
</td></tr>
<tr><td><code id="alluvial_+3A_cex">cex</code>, <code id="alluvial_+3A_cex.axis">cex.axis</code></td>
<td>
<p>numeric, scaling of fonts of category labels and axis labels respectively. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly a list with elements:
</p>
<table>
<tr><td><code>endpoints</code></td>
<td>
<p>A list of matrices of y-coordinates of endpoints of the
alluvia. x-coordinates are consecutive natural numbers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please mind that the API is planned to change to be more compatible
with <span class="pkg">dplyr</span> verbs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Titanic data
tit &lt;- as.data.frame(Titanic)

# 2d
tit2d &lt;- aggregate( Freq ~ Class + Survived, data=tit, sum)
alluvial( tit2d[,1:2], freq=tit2d$Freq, xw=0.0, alpha=0.8,
         gap.width=0.1, col= "steelblue", border="white",
         layer = tit2d$Survived != "Yes" )

alluvial( tit2d[,1:2], freq=tit2d$Freq, 
         hide=tit2d$Freq &lt; 150,
         xw=0.0, alpha=0.8,
         gap.width=0.1, col= "steelblue", border="white",
         layer = tit2d$Survived != "Yes" )

# 3d
tit3d &lt;- aggregate( Freq ~ Class + Sex + Survived, data=tit, sum)

alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
         col=ifelse( tit3d$Survived == "No", "red", "gray"),
         layer = tit3d$Sex != "Female",
         border="white")


# 4d
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
         hide = tit$Freq &lt; quantile(tit$Freq, .50),
         col=ifelse( tit$Class == "3rd" &amp; tit$Sex == "Male", "red", "gray") )

# 3d example with custom ordering
# Reorder "Sex" axis according to survival status
ord &lt;- list(NULL, with(tit3d, order(Sex, Survived)), NULL)
alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
         col=ifelse( tit3d$Survived == "No", "red", "gray"),
         layer = tit3d$Sex != "Female",
         border="white", ordering=ord)

# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
    
    # Elaborate alluvial diagram from main examples file
    alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
              hide = tit$Freq &lt; quantile(tit$Freq, .50),
              col = ifelse( tit$Class == "3rd" &amp; tit$Sex == "Male",
                            "red", "gray" ),
              blocks = blocks )
}


# Data returned
x &lt;- alluvial( tit2d[,1:2], freq=tit2d$Freq, xw=0.0, alpha=0.8,
          gap.width=0.1, col= "steelblue", border="white",
          layer = tit2d$Survived != "Yes" )
points( rep(1, 16), x$endpoints[[1]], col="green")
points( rep(2, 16), x$endpoints[[2]], col="blue")
</code></pre>

<hr>
<h2 id='alluvial_ts'>Alluvial diagram for multiple time series data</h2><span id='topic+alluvial_ts'></span>

<h3>Description</h3>

<p>This is a variant of alluvial diagram suitable for multiple
(cross-sectional) time series. It also works with continuous variables equivalent to time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_ts(dat, wave = NA, ygap = 1, col = NA, alpha = NA,
  plotdir = "up", rankup = FALSE, lab.cex = 1, lab.col = "black",
  xmargin = 0.1, axis.col = "black", title = NA, title.cex = 1,
  axis.cex = 1, grid = FALSE, grid.col = "grey80", grid.lwd = 1,
  leg.mode = TRUE, leg.x = 0.1, leg.y = 0.9, leg.cex = 1,
  leg.col = "black", leg.lty = NA, leg.lwd = NA, leg.max = NA,
  xlab = NA, ylab = NA, xlab.pos = 2, ylab.pos = 1, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_ts_+3A_dat">dat</code></td>
<td>
<p>data.frame of time-series (or suitable equivalent continuously disaggregated data), with 3 columns (in order: category, time-variable, value) with &lt;= 1 row for each category-time combination</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_wave">wave</code></td>
<td>
<p>numeric, curve wavyness defined in terms of x axis data range - i.e. bezier point offset. Experiment to get this right</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_ygap">ygap</code></td>
<td>
<p>numeric, vertical distance between polygons - a multiple of 10% of the mean data value</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_col">col</code></td>
<td>
<p>colour, value or vector of length matching the number of unique categories. Individual colours of vector are mapped to categories in alpha-numeric order</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_alpha">alpha</code></td>
<td>
<p>numeric, [0,1] polygon fill transparency</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_plotdir">plotdir</code></td>
<td>
<p>character, string ('up', 'down' or 'centred') giving the vertical alignment of polygon stacks</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_rankup">rankup</code></td>
<td>
<p>logical, rank polygons on time axes upward by magnitude (largest to smallest) or not</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_lab.cex">lab.cex</code></td>
<td>
<p>numeric, category label font size</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_lab.col">lab.col</code></td>
<td>
<p>colour, of category label</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_xmargin">xmargin</code></td>
<td>
<p>numeric [0,1], proportional space for category labels</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_axis.col">axis.col</code></td>
<td>
<p>colour, of axes</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_title">title</code></td>
<td>
<p>character, plot title</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_title.cex">title.cex</code></td>
<td>
<p>numeric, plot title font size</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_axis.cex">axis.cex</code></td>
<td>
<p>numeric, font size of x-axis break labels</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_grid">grid</code></td>
<td>
<p>logical, plot vertical axes</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_grid.col">grid.col</code></td>
<td>
<p>colour, of grid axes</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_grid.lwd">grid.lwd</code></td>
<td>
<p>numeric, line width of grid axes</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.mode">leg.mode</code></td>
<td>
<p>logical, draw y-axis scale legend inside largest data point (TRUE default) or alternatively with custom position/value (FALSE)</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.x">leg.x</code>, <code id="alluvial_ts_+3A_leg.y">leg.y</code></td>
<td>
<p>numeric [0,1], x/y positions of legend if leg.mode = FALSE</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.cex">leg.cex</code></td>
<td>
<p>numeric, legend text size</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.col">leg.col</code></td>
<td>
<p>colour, of legend lines and text</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.lty">leg.lty</code></td>
<td>
<p>numeric, code for legend line type</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.lwd">leg.lwd</code></td>
<td>
<p>numeric, legend line width</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_leg.max">leg.max</code></td>
<td>
<p>numeric, legend scale line width</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_xlab">xlab</code>, <code id="alluvial_ts_+3A_ylab">ylab</code></td>
<td>
<p>character, x-axis / y-axis titles</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_xlab.pos">xlab.pos</code>, <code id="alluvial_ts_+3A_ylab.pos">ylab.pos</code></td>
<td>
<p>numeric, perpendicular offset for axis titles</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_lwd">lwd</code></td>
<td>
<p>numeric, value or vector of length matching the number of unique categories for polygon stroke line width. Individual values of vector are mapped to categories in alpha-numeric order</p>
</td></tr>
<tr><td><code id="alluvial_ts_+3A_...">...</code></td>
<td>
<p>arguments to pass to polygon()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if( require(reshape2) )
{
data(Refugees)
reshape2::dcast(Refugees, country ~ year, value.var = 'refugees')
d &lt;- Refugees

set.seed(39) # for nice colours
cols &lt;- hsv(h = sample(1:10/10), s = sample(3:12)/15, v = sample(3:12)/15)

alluvial_ts(d)
alluvial_ts(d, wave = .2, ygap = 5, lwd = 3)
alluvial_ts(d, wave = .3, ygap = 5, col = cols)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, rankup = TRUE)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, plotdir = 'down')
alluvial_ts(d, wave = .3, ygap = 5, col = cols, plotdir = 'centred', grid=TRUE,
            grid.lwd = 5)
alluvial_ts(d, wave =  0, ygap = 0, col = cols, alpha = .9, border = 'white',
            grid = TRUE, grid.lwd = 5)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, xmargin = 0.4)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, xmargin = 0.3, lab.cex = .7)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, xmargin = 0.3, lab.cex=.7,
            leg.cex=.7, leg.col = 'white')
alluvial_ts(d, wave = .3, ygap = 5, col = cols, leg.mode = FALSE, leg.x = .1,
            leg.y = .7, leg.max = 3e6)
alluvial_ts(d, wave = .3, ygap = 5, col = cols, plotdir = 'centred', alpha=.9,
            grid = TRUE, grid.lwd = 5, xmargin = 0.2, lab.cex = .7, xlab = '',
            ylab = '', border = NA, axis.cex = .8, leg.cex = .7,
            leg.col='white', 
         title = "UNHCR-recognised refugees\nTop 10 countries (2003-13)\n")

# non time-series example - Virginia deaths dataset
d &lt;- reshape2::melt(data.frame(age=row.names(VADeaths), VADeaths), id.vars='age')[,c(2,1,3)]
names(d) = c('pop_group','age_group','deaths')
alluvial_ts(d)
}
</code></pre>

<hr>
<h2 id='Refugees'>Refugees data</h2><span id='topic+Refugees'></span>

<h3>Description</h3>

<p>Top 10 countries/territories of origin (excluding &quot;Various&quot;) for period
2003-13 of UNHCR statistics on &quot;Persons recognized as refugees under the
1951 UN Convention/1967 Protocol, the 1969 OAU Convention, in accordance
with the UNHCR Statute, persons granted a complementary form of protection
and those granted temporary protection.&quot;
</p>


<h3>Format</h3>

<p>Data frame with the following columns:
</p>

<dl>
<dt>country</dt><dd><p>Country or territory of origin</p>
</dd>
<dt>year</dt><dd><p>Year (2003-13)</p>
</dd>
<dt>refugees</dt><dd><p>Persons recognized as refugees under the 1951 UN Convention, etc..</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="http://data.un.org/Data.aspx?d=UNHCR&amp;f=indID%3aType-Ref">http://data.un.org/Data.aspx?d=UNHCR&amp;f=indID%3aType-Ref</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
