<!DOCTYPE html><html><head><title>Help for package rlibkriging</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rlibkriging}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.km'><p>Coerce an Object into a <code>km</code> Object</p></a></li>
<li><a href='#as.km.Kriging'><p>Coerce a <code>Kriging</code> object into the <code>"km"</code> class of the</p>
<span class="pkg">DiceKriging</span> package.</a></li>
<li><a href='#as.km.NoiseKriging'><p>Coerce a <code>NoiseKriging</code> object into the <code>"km"</code> class of the</p>
<span class="pkg">DiceKriging</span> package.</a></li>
<li><a href='#as.km.NuggetKriging'><p>Coerce a <code>NuggetKriging</code> object into the <code>"km"</code> class of the</p>
<span class="pkg">DiceKriging</span> package.</a></li>
<li><a href='#as.list.Kriging'><p>Coerce a <code>Kriging</code> Object into a List</p></a></li>
<li><a href='#as.list.NoiseKriging'><p>Coerce a <code>NoiseKriging</code> Object into a List</p></a></li>
<li><a href='#as.list.NuggetKriging'><p>Coerce a <code>NuggetKriging</code> Object into a List</p></a></li>
<li><a href='#copy'><p>Duplicate object.</p></a></li>
<li><a href='#copy.Kriging'><p>Duplicate a Kriging Model</p></a></li>
<li><a href='#copy.NoiseKriging'><p>Duplicate a NoiseKriging Model</p></a></li>
<li><a href='#copy.NuggetKriging'><p>Duplicate a NuggetKriging Model</p></a></li>
<li><a href='#fit'><p>Fit model on data.</p></a></li>
<li><a href='#fit.Kriging'><p>Fit <code>Kriging</code> object on given data.</p></a></li>
<li><a href='#fit.NoiseKriging'><p>Fit <code>NoiseKriging</code> object on given data.</p></a></li>
<li><a href='#fit.NuggetKriging'><p>Fit <code>NuggetKriging</code> object on given data.</p></a></li>
<li><a href='#KM'><p>Create an <code>KM</code> Object</p></a></li>
<li><a href='#KM-class'><p>S4 class for Kriging Models Extending the <code>"km"</code> Class</p></a></li>
<li><a href='#Kriging'><p>Create an object with S3 class <code>"Kriging"</code> using</p>
the <span class="pkg">libKriging</span> library.</a></li>
<li><a href='#leaveOneOut'><p>Compute Leave-One-Out</p></a></li>
<li><a href='#leaveOneOut.Kriging'><p>Get leaveOneOut of Kriging Model</p></a></li>
<li><a href='#leaveOneOutFun'><p>Leave-One-Out function</p></a></li>
<li><a href='#leaveOneOutFun.Kriging'><p>Compute Leave-One-Out (LOO) error for an object with S3 class</p>
<code>"Kriging"</code> representing a kriging model.</a></li>
<li><a href='#leaveOneOutVec'><p>Leave-One-Out vector</p></a></li>
<li><a href='#leaveOneOutVec.Kriging'><p>Compute Leave-One-Out (LOO) vector error for an object with S3 class</p>
<code>"Kriging"</code> representing a kriging model.</a></li>
<li><a href='#load'><p>Load any Kriging Model from a file storage.</p></a></li>
<li><a href='#load.Kriging'><p>Load a Kriging Model from a file storage</p></a></li>
<li><a href='#load.NoiseKriging'><p>Load a NoiseKriging Model from a file storage</p></a></li>
<li><a href='#load.NuggetKriging'><p>Load a NuggetKriging Model from a file storage</p></a></li>
<li><a href='#logLikelihood'><p>Compute Log-Likelihood</p></a></li>
<li><a href='#logLikelihood.Kriging'><p>Get Log-Likelihood of Kriging Model</p></a></li>
<li><a href='#logLikelihood.NoiseKriging'><p>Get logLikelihood of NoiseKriging Model</p></a></li>
<li><a href='#logLikelihood.NuggetKriging'><p>Get logLikelihood of NuggetKriging Model</p></a></li>
<li><a href='#logLikelihoodFun'><p>Log-Likelihood function</p></a></li>
<li><a href='#logLikelihoodFun.Kriging'><p>Compute Log-Likelihood of Kriging Model</p></a></li>
<li><a href='#logLikelihoodFun.NoiseKriging'><p>Compute Log-Likelihood of NoiseKriging Model</p></a></li>
<li><a href='#logLikelihoodFun.NuggetKriging'><p>Compute Log-Likelihood of NuggetKriging Model</p></a></li>
<li><a href='#logMargPost'><p>Compute log-Marginal Posterior</p></a></li>
<li><a href='#logMargPost.Kriging'><p>Get logMargPost of Kriging Model</p></a></li>
<li><a href='#logMargPost.NuggetKriging'><p>Get logMargPost of NuggetKriging Model</p></a></li>
<li><a href='#logMargPostFun'><p>log-Marginal Posterior function</p></a></li>
<li><a href='#logMargPostFun.Kriging'><p>Compute the log-marginal posterior of a kriging model, using the</p>
prior XXXY.</a></li>
<li><a href='#logMargPostFun.NuggetKriging'><p>Compute the log-marginal posterior of a kriging model, using the</p>
prior XXXY.</a></li>
<li><a href='#NoiseKM'><p>Create an <code>NoiseKM</code> Object</p></a></li>
<li><a href='#NoiseKM-class'><p>S4 class for NoiseKriging Models Extending the <code>"km"</code> Class</p></a></li>
<li><a href='#NoiseKriging'><p>Create an object with S3 class <code>"NoiseKriging"</code> using</p>
the <span class="pkg">libKriging</span> library.</a></li>
<li><a href='#NuggetKM'><p>Create an <code>NuggetKM</code> Object</p></a></li>
<li><a href='#NuggetKM-class'><p>S4 class for NuggetKriging Models Extending the <code>"km"</code> Class</p></a></li>
<li><a href='#NuggetKriging'><p>Create an object with S3 class <code>"NuggetKriging"</code> using</p>
the <span class="pkg">libKriging</span> library.</a></li>
<li><a href='#predict,KM-method'><p>Prediction Method for a <code>KM</code> Object</p></a></li>
<li><a href='#predict,NoiseKM-method'><p>Prediction Method for a <code>NoiseKM</code> Object</p></a></li>
<li><a href='#predict,NuggetKM-method'><p>Prediction Method for a <code>NuggetKM</code> Object</p></a></li>
<li><a href='#predict.Kriging'><p>Predict from a <code>Kriging</code> object.</p></a></li>
<li><a href='#predict.NoiseKriging'><p>Predict from a <code>NoiseKriging</code> object.</p></a></li>
<li><a href='#predict.NuggetKriging'><p>Predict from a <code>NuggetKriging</code> object.</p></a></li>
<li><a href='#print.Kriging'><p>Print the content of a <code>Kriging</code> object.</p></a></li>
<li><a href='#print.NoiseKriging'><p>Print the content of a <code>NoiseKriging</code> object.</p></a></li>
<li><a href='#print.NuggetKriging'><p>Print the content of a <code>NuggetKriging</code> object.</p></a></li>
<li><a href='#save'><p>Save object.</p></a></li>
<li><a href='#save.Kriging'><p>Save a Kriging Model to a file storage</p></a></li>
<li><a href='#save.NoiseKriging'><p>Save a NoiseKriging Model to a file storage</p></a></li>
<li><a href='#save.NuggetKriging'><p>Save a NuggetKriging Model to a file storage</p></a></li>
<li><a href='#simulate,KM-method'><p>Simulation from a <code>KM</code> Object</p></a></li>
<li><a href='#simulate,NoiseKM-method'><p>Simulation from a <code>NoiseKM</code> Object</p></a></li>
<li><a href='#simulate,NuggetKM-method'><p>Simulation from a <code>NuggetKM</code> Object</p></a></li>
<li><a href='#simulate.Kriging'><p>Simulation from a <code>Kriging</code> model object.</p></a></li>
<li><a href='#simulate.NoiseKriging'><p>Simulation from a <code>NoiseKriging</code> model object.</p></a></li>
<li><a href='#simulate.NuggetKriging'><p>Simulation from a <code>NuggetKriging</code> model object.</p></a></li>
<li><a href='#update,KM-method'><p>Update a <code>KM</code> Object with New Points</p></a></li>
<li><a href='#update,NoiseKM-method'><p>Update a <code>NoiseKM</code> Object with New Points</p></a></li>
<li><a href='#update,NuggetKM-method'><p>Update a <code>NuggetKM</code> Object with New Points</p></a></li>
<li><a href='#update.Kriging'><p>Update a <code>Kriging</code> model object with new points</p></a></li>
<li><a href='#update.NoiseKriging'><p>Update a <code>NoiseKriging</code> model object with new points</p></a></li>
<li><a href='#update.NuggetKriging'><p>Update a <code>NuggetKriging</code> model object with new points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kriging Models using the 'libKriging' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yann Richet &lt;yann.richet@irsn.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to 'libKriging' 'C++' library <a href="https://github.com/libKriging">https://github.com/libKriging</a> that should
    provide most standard Kriging / Gaussian process regression features
    (like in 'DiceKriging', 'kergp' or 'RobustGaSP' packages).
    'libKriging' relies on Armadillo linear algebra library (Apache 2 license) by Conrad Sanderson, 
    'lbfgsb_cpp' is a 'C++' port around 'lbfgsb' library (BSD-3 license) by 
    Ciyou Zhu, Richard Byrd, Jorge Nocedal and Jose Luis Morales used for hyperparameters optimization,
    and HDF5 features coming from HDF Group (see HDF5_LICENSE file)
    possibly provided by Rhdf5lib by Mike Smith (Artistic-2.0 license).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.11), methods, DiceKriging</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, RobustGaSP, utils, DiceDesign, foreach</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, cmake (&gt;= 3.2.0), gcc, gfortran, HDF5</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/libKriging">https://github.com/libKriging</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 20:42:14 UTC; richet</td>
</tr>
<tr>
<td>Author:</td>
<td>Yann Richet <a href="https://orcid.org/0000-0002-5677-8458"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Pascal Hav√© [aut],
  Yves Deville [aut],
  Conrad Sanderson [ctb],
  Ciyou Zhu [ctb],
  Richard Byrd [ctb],
  Jorge Nocedal [ctb],
  Jose Luis Morales [ctb],
  Mike Smith [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 12:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.km'>Coerce an Object into a <code>km</code> Object</h2><span id='topic+as.km'></span>

<h3>Description</h3>

<p>Coerce an object into an object with S4 class <code>"km"</code> from the
<span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.km(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.km_+3A_x">x</code></td>
<td>
<p>Object to be coerced.</p>
</td></tr>
<tr><td><code id="as.km_+3A_...">...</code></td>
<td>
<p>Further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Such a coercion is typically used to compare the performance of
the methods implemented in the current <span class="pkg">rlibkriging</span> package to
those which are available in the <span class="pkg">DiceKriging</span> package.
</p>


<h3>Value</h3>

<p>An object with S4 class <code>"km"</code>.
</p>

<hr>
<h2 id='as.km.Kriging'>Coerce a <code>Kriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.</h2><span id='topic+as.km.Kriging'></span><span id='topic+as.km+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Coerce a <code>Kriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
as.km(x, .call = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.km.Kriging_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="as.km.Kriging_+3A_.call">.call</code></td>
<td>
<p>Force the <code>call</code> slot to be filled in the
returned <code>km</code> object.</p>
</td></tr>
<tr><td><code id="as.km.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of having the S4 class <code>"KM"</code> which extends
the <code>"km"</code> class of the <span class="pkg">DiceKriging</span> package and
contains an extra <code>Kriging</code> slot.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, "matern3_2")
print(k)

k_km &lt;- as.km(k)
print(k_km)
</code></pre>

<hr>
<h2 id='as.km.NoiseKriging'>Coerce a <code>NoiseKriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.</h2><span id='topic+as.km.NoiseKriging'></span>

<h3>Description</h3>

<p>Coerce a <code>NoiseKriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
as.km(x, .call = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.km.NoiseKriging_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"NoiseKriging"</code>.</p>
</td></tr>
<tr><td><code id="as.km.NoiseKriging_+3A_.call">.call</code></td>
<td>
<p>Force the <code>call</code> slot to be filled in the
returned <code>km</code> object.</p>
</td></tr>
<tr><td><code id="as.km.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of having the S4 class <code>"KM"</code> which extends
the <code>"km"</code> class of the <span class="pkg">DiceKriging</span> package and
contains an extra <code>NoiseKriging</code> slot.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X)) # add noise dep. on X
## fit and print
k &lt;- NoiseKriging(y, noise=(X/10)^2, X, kernel = "matern3_2")
print(k)

k_km &lt;- as.km(k)
print(k_km)
</code></pre>

<hr>
<h2 id='as.km.NuggetKriging'>Coerce a <code>NuggetKriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.</h2><span id='topic+as.km.NuggetKriging'></span>

<h3>Description</h3>

<p>Coerce a <code>NuggetKriging</code> object into the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
as.km(x, .call = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.km.NuggetKriging_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"NuggetKriging"</code>.</p>
</td></tr>
<tr><td><code id="as.km.NuggetKriging_+3A_.call">.call</code></td>
<td>
<p>Force the <code>call</code> slot to be filled in the
returned <code>km</code> object.</p>
</td></tr>
<tr><td><code id="as.km.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of having the S4 class <code>"KM"</code> which extends
the <code>"km"</code> class of the <span class="pkg">DiceKriging</span> package and
contains an extra <code>NuggetKriging</code> slot.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, "matern3_2")
print(k)

k_km &lt;- as.km(k)
print(k_km)
</code></pre>

<hr>
<h2 id='as.list.Kriging'>Coerce a <code>Kriging</code> Object into a List</h2><span id='topic+as.list.Kriging'></span><span id='topic+as.list+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Coerce a <code>Kriging</code> Object into a List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.Kriging_+3A_x">x</code></td>
<td>
<p>An object with class <code>"Kriging"</code>.</p>
</td></tr>
<tr><td><code id="as.list.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with its elements copying the content of the
<code>Kriging</code> object fields: <code>kernel</code>, <code>optim</code>,
<code>objective</code>, <code>theta</code> (vector of ranges),
<code>sigma2</code> (variance), <code>X</code>, <code>centerX</code>,
<code>scaleX</code>, <code>y</code>, <code>centerY</code>, <code>scaleY</code>,
<code>regmodel</code>, <code>F</code>, <code>T</code>, <code>M</code>, <code>z</code>,
<code>beta</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x ) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2")

l &lt;- as.list(k)
cat(paste0(names(l), " =" , l, collapse = "\n"))
</code></pre>

<hr>
<h2 id='as.list.NoiseKriging'>Coerce a <code>NoiseKriging</code> Object into a List</h2><span id='topic+as.list.NoiseKriging'></span><span id='topic+as.list+2CNoiseKriging+2CNoiseKriging-method'></span>

<h3>Description</h3>

<p>Coerce a <code>NoiseKriging</code> Object into a List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.NoiseKriging_+3A_x">x</code></td>
<td>
<p>An object with class <code>"NoiseKriging"</code>.</p>
</td></tr>
<tr><td><code id="as.list.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with its elements copying the content of the
<code>NoiseKriging</code> object fields: <code>kernel</code>, <code>optim</code>,
<code>objective</code>, <code>theta</code> (vector of ranges),
<code>sigma2</code> (variance), <code>X</code>, <code>centerX</code>,
<code>scaleX</code>, <code>y</code>, <code>centerY</code>, <code>scaleY</code>,
<code>regmodel</code>, <code>F</code>, <code>T</code>, <code>M</code>, <code>z</code>,
<code>beta</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X)) # add noise dep. on X

k &lt;- NoiseKriging(y, noise=(X/10)^2, X, kernel = "matern3_2")

l &lt;- as.list(k)
cat(paste0(names(l), " =" , l, collapse = "\n"))
</code></pre>

<hr>
<h2 id='as.list.NuggetKriging'>Coerce a <code>NuggetKriging</code> Object into a List</h2><span id='topic+as.list.NuggetKriging'></span><span id='topic+as.list+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Coerce a <code>NuggetKriging</code> Object into a List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.NuggetKriging_+3A_x">x</code></td>
<td>
<p>An object with class <code>"NuggetKriging"</code>.</p>
</td></tr>
<tr><td><code id="as.list.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with its elements copying the content of the
<code>NuggetKriging</code> object fields: <code>kernel</code>, <code>optim</code>,
<code>objective</code>, <code>theta</code> (vector of ranges),
<code>sigma2</code> (variance), <code>X</code>, <code>centerX</code>,
<code>scaleX</code>, <code>y</code>, <code>centerY</code>, <code>scaleY</code>,
<code>regmodel</code>, <code>F</code>, <code>T</code>, <code>M</code>, <code>z</code>,
<code>beta</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, kernel = "matern3_2")

l &lt;- as.list(k)
cat(paste0(names(l), " =" , l, collapse = "\n"))
</code></pre>

<hr>
<h2 id='copy'>Duplicate object.</h2><span id='topic+copy'></span>

<h3>Description</h3>

<p>Duplicate a model given in
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="copy_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The copied object.
</p>

<hr>
<h2 id='copy.Kriging'>Duplicate a Kriging Model</h2><span id='topic+copy.Kriging'></span><span id='topic+copy+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Duplicate a Kriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
copy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="copy.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The copy of object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

print(copy(k))
</code></pre>

<hr>
<h2 id='copy.NoiseKriging'>Duplicate a NoiseKriging Model</h2><span id='topic+copy.NoiseKriging'></span><span id='topic+copy+2CNoiseKriging+2CNoiseKriging-method'></span>

<h3>Description</h3>

<p>Duplicate a NoiseKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
copy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy.NoiseKriging_+3A_object">object</code></td>
<td>
<p>An S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="copy.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The copy of object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))

k &lt;- NoiseKriging(y, (X/10)^2, X, kernel = "matern3_2", objective="LL")
print(k)

print(copy(k))
</code></pre>

<hr>
<h2 id='copy.NuggetKriging'>Duplicate a NuggetKriging Model</h2><span id='topic+copy.NuggetKriging'></span><span id='topic+copy+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Duplicate a NuggetKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
copy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy.NuggetKriging_+3A_object">object</code></td>
<td>
<p>An S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="copy.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The copy of object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

print(copy(k))
</code></pre>

<hr>
<h2 id='fit'>Fit model on data.</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>Fit a model given in
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Further arguments of function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Kriging object argument is modified.
</p>

<hr>
<h2 id='fit.Kriging'>Fit <code>Kriging</code> object on given data.</h2><span id='topic+fit.Kriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
fit(
  object,
  y,
  X,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "Newton", "none"),
  objective = c("LL", "LOO", "LMP"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.Kriging_+3A_object">object</code></td>
<td>
<p>S3 Kriging object.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal Kriging linear trend.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code>,
<code>"Newton"</code> and <code>"none"</code>, the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective. The method
<code>"Newton"</code> uses both the gradient and the Hessian of the
objective.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood, <code>"LOO"</code> for the Leave-One-Out sum of
squares and <code>"LMP"</code> for the Log-Marginal Posterior.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When
provided this must be named list with elements <code>"sigma2"</code>
and <code>"theta"</code> containing the initial value(s) for the
variance and for the range parameters. If <code>theta</code> is a
matrix with more than one row, each row is used as a starting
point for optimization.</p>
</td></tr>
<tr><td><code id="fit.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Kriging object argument is modified.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)
points(X, y, col = "blue", pch = 16)

k &lt;- Kriging("matern3_2")
print(k)

fit(k,y,X)
print(k)
</code></pre>

<hr>
<h2 id='fit.NoiseKriging'>Fit <code>NoiseKriging</code> object on given data.</h2><span id='topic+fit.NoiseKriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
fit(
  object,
  y,
  noise,
  X,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "none"),
  objective = c("LL"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.NoiseKriging_+3A_object">object</code></td>
<td>
<p>S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_noise">noise</code></td>
<td>
<p>Numeric vector of response variances.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal NoiseKriging linear trend.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code> and <code>"none"</code>,
the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When
provided this must be named list with elements <code>"sigma2"</code>
and <code>"theta"</code> containing the initial value(s) for the
variance and for the range parameters. If <code>theta</code> is a
matrix with more than one row, each row is used as a starting
point for optimization.</p>
</td></tr>
<tr><td><code id="fit.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. NoiseKriging object argument is modified.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X)) # add noise dep. on X
points(X, y, col = "blue", pch = 16)

k &lt;- NoiseKriging("matern3_2")
print(k)

fit(k,y,noise=(X/10)^2,X)
print(k)
</code></pre>

<hr>
<h2 id='fit.NuggetKriging'>Fit <code>NuggetKriging</code> object on given data.</h2><span id='topic+fit.NuggetKriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
fit(
  object,
  y,
  X,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "none"),
  objective = c("LL", "LMP"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.NuggetKriging_+3A_object">object</code></td>
<td>
<p>S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal NuggetKriging linear trend.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code> and <code>"none"</code>,
the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood and <code>"LMP"</code> for the Log-Marginal Posterior.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When provided this
must be named list with some elements <code>"sigma2"</code>, <code>"theta"</code>, <code>"nugget"</code>
containing the initial value(s) for the variance, range and nugget
parameters. If <code>theta</code> is a matrix with more than one row,
each row is used as a starting point for optimization.</p>
</td></tr>
<tr><td><code id="fit.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. NuggetKriging object argument is modified.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
points(X, y, col = "blue", pch = 16)

k &lt;- NuggetKriging("matern3_2")
print(k)

fit(k,y,X)
print(k)
</code></pre>

<hr>
<h2 id='KM'>Create an <code>KM</code> Object</h2><span id='topic+KM'></span>

<h3>Description</h3>

<p>Create an object of S4 class <code>"KM"</code> similar to a
<code>km</code> object in the <span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KM(
  formula = ~1,
  design,
  response,
  covtype = c("matern5_2", "gauss", "matern3_2", "exp"),
  coef.trend = NULL,
  coef.cov = NULL,
  coef.var = NULL,
  nugget = NULL,
  nugget.estim = FALSE,
  noise.var = NULL,
  estim.method = c("MLE", "LOO"),
  penalty = NULL,
  optim.method = "BFGS",
  lower = NULL,
  upper = NULL,
  parinit = NULL,
  multistart = 1,
  control = NULL,
  gr = TRUE,
  iso = FALSE,
  scaling = FALSE,
  knots = NULL,
  kernel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KM_+3A_formula">formula</code></td>
<td>
<p>R formula object to setup the linear trend in
Universal Kriging. Supports <code>~ 1</code>, ~. and <code>~ .^2</code>.</p>
</td></tr>
<tr><td><code id="KM_+3A_design">design</code></td>
<td>
<p>Data frame. The design of experiments.</p>
</td></tr>
<tr><td><code id="KM_+3A_response">response</code></td>
<td>
<p>Vector of output values.</p>
</td></tr>
<tr><td><code id="KM_+3A_covtype">covtype</code></td>
<td>
<p>Covariance structure. For now all the kernels are
tensor product kernels.</p>
</td></tr>
<tr><td><code id="KM_+3A_coef.trend">coef.trend</code></td>
<td>
<p>Optional value for a fixed vector of trend
coefficients.  If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="KM_+3A_coef.cov">coef.cov</code></td>
<td>
<p>Optional value for a fixed correlation range
value. If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="KM_+3A_coef.var">coef.var</code></td>
<td>
<p>Optional value for a fixed variance. If given, no
optimization is done.</p>
</td></tr>
<tr><td><code id="KM_+3A_nugget">nugget</code>, <code id="KM_+3A_nugget.estim">nugget.estim</code>, <code id="KM_+3A_noise.var">noise.var</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="KM_+3A_estim.method">estim.method</code></td>
<td>
<p>Estimation criterion. <code>"MLE"</code> for
Maximum-Likelihood or <code>"LOO"</code> for Leave-One-Out
cross-validation.</p>
</td></tr>
<tr><td><code id="KM_+3A_penalty">penalty</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="KM_+3A_optim.method">optim.method</code></td>
<td>
<p>Optimization algorithm used in the
optimization of the objective given in
<code>estim.method</code>. Supports <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="KM_+3A_lower">lower</code>, <code id="KM_+3A_upper">upper</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="KM_+3A_parinit">parinit</code></td>
<td>
<p>Initial values for the correlation ranges which
will be optimized using <code>optim.method</code>.</p>
</td></tr>
<tr><td><code id="KM_+3A_multistart">multistart</code>, <code id="KM_+3A_control">control</code>, <code id="KM_+3A_gr">gr</code>, <code id="KM_+3A_iso">iso</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="KM_+3A_scaling">scaling</code>, <code id="KM_+3A_knots">knots</code>, <code id="KM_+3A_kernel">kernel</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="KM_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"KM"</code> extends the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package, hence has all slots of <code>"km"</code>. It
also has an extra slot <code>"Kriging"</code> slot which contains a copy
of the original object.
</p>


<h3>Value</h3>

<p>A KM object. See <b>Details</b>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km">km</a></code> in the <span class="pkg">DiceKriging</span>
package for more details on the slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- as.matrix(expand.grid(x1 = seq(0, 1, length = 4),
                                     x2 = seq(0, 1, length = 4)))
y &lt;- apply(design.fact, 1, DiceKriging::branin) 

# Using `km` from DiceKriging and a similar `KM` object 
# kriging model 1 : matern5_2 covariance structure, no trend, no nugget effect
km1 &lt;- DiceKriging::km(design = design.fact, response = y, covtype = "gauss",
                       parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- KM(design = design.fact, response = y, covtype = "gauss",
          parinit = c(.5, 1))

</code></pre>

<hr>
<h2 id='KM-class'>S4 class for Kriging Models Extending the <code>"km"</code> Class</h2><span id='topic+KM-class'></span>

<h3>Description</h3>

<p>This class is intended to be used either by using its
own dedicated S4 methods or by using the S4 methods inherited
from the <code>"km"</code> class of the <span class="pkg">libKriging</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>d,n,X,y,p,F</code></dt><dd><p>Number of (numeric) inputs, number of
observations, design matrix, response vector, number of trend
variables, trend matrix.</p>
</dd>
<dt><code>trend.formula,trend.coef</code></dt><dd><p>Formula used for the trend, vector
<code class="reqn">\hat{\boldsymbol{\beta}}</code> of estimated (or fixed)
trend coefficients with length <code class="reqn">p</code>.</p>
</dd>
<dt><code>covariance</code></dt><dd><p>A S4 object with class <code>"covTensorProduct"</code>
representing a covariance kernel.</p>
</dd>
<dt><code>noise.flag,noise.var</code></dt><dd><p>Logical flag and numeric value for an
optional noise term.</p>
</dd>
<dt><code>known.param</code></dt><dd><p>A character code indicating what parameters are
known.</p>
</dd>
<dt><code>lower,upper</code></dt><dd><p>Bounds on the correlation range parameters.</p>
</dd>
<dt><code>method,penalty,optim.method,control,gr,parinit</code></dt><dd><p>Objects
defining the estimation criterion, the optimization.</p>
</dd>
<dt><code>T,M,z</code></dt><dd><p>Auxiliary variables (matrices and vectors) that can be
used in several computations.</p>
</dd>
<dt><code>case</code></dt><dd><p>The possible concentration (a.k.a. profiling) of the
likelihood.</p>
</dd>
<dt><code>param.estim</code></dt><dd><p>Logical. Is an estimation used?</p>
</dd>
<dt><code>Kriging</code></dt><dd><p>A copy of the <code>Kriging</code> object used to create
the current <code>KM</code> object.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km-class">km-class</a></code> in the
<span class="pkg">DiceKriging</span> package. The creator <code><a href="#topic+KM">KM</a></code>.
</p>

<hr>
<h2 id='Kriging'>Create an object with S3 class <code>"Kriging"</code> using
the <span class="pkg">libKriging</span> library.</h2><span id='topic+Kriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kriging(
  y = NULL,
  X = NULL,
  kernel = NULL,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "Newton", "none"),
  objective = c("LL", "LOO", "LMP"),
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_kernel">kernel</code></td>
<td>
<p>Character defining the covariance model:
<code>"exp"</code>, <code>"gauss"</code>, <code>"matern3_2"</code>, <code>"matern5_2"</code>.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal Kriging linear trend.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code>,
<code>"Newton"</code> and <code>"none"</code>, the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective. The method
<code>"Newton"</code> uses both the gradient and the Hessian of the
objective.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood, <code>"LOO"</code> for the Leave-One-Out sum of
squares and <code>"LMP"</code> for the Log-Marginal Posterior.</p>
</td></tr>
<tr><td><code id="Kriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When
provided this must be named list with elements <code>"sigma2"</code>
and <code>"theta"</code> containing the initial value(s) for the
variance and for the range parameters. If <code>theta</code> is a
matrix with more than one row, each row is used as a starting
point for optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"Kriging"</code>. Should be used
with its <code>predict</code>, <code>simulate</code>, <code>update</code>
methods.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)
## fit and print
k &lt;- Kriging(y, X, kernel = "matern3_2")
print(k)

x &lt;- as.matrix(seq(from = 0, to = 1, length.out = 101))
p &lt;- predict(k, x = x, stdev = TRUE, cov = FALSE)

plot(f)
points(X, y)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
border = NA, col = rgb(0, 0, 1, 0.2))

s &lt;- simulate(k, nsim = 10, seed = 123, x = x)

matlines(x, s, col = rgb(0, 0, 1, 0.2), type = "l", lty = 1)
</code></pre>

<hr>
<h2 id='leaveOneOut'>Compute Leave-One-Out</h2><span id='topic+leaveOneOut'></span>

<h3>Description</h3>

<p>Compute the leave-One-Out error of a model given in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="leaveOneOut_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Leave-One-Out sum of squares.
</p>

<hr>
<h2 id='leaveOneOut.Kriging'>Get leaveOneOut of Kriging Model</h2><span id='topic+leaveOneOut.Kriging'></span><span id='topic+leaveOneOut+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Get leaveOneOut of Kriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
leaveOneOut(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="leaveOneOut.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The leaveOneOut computed for fitted
<code class="reqn">\boldsymbol{theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LOO")
print(k)

leaveOneOut(k)
</code></pre>

<hr>
<h2 id='leaveOneOutFun'>Leave-One-Out function</h2><span id='topic+leaveOneOutFun'></span>

<h3>Description</h3>

<p>Compute the leave-One-Out error of a model given in <code>object</code>,
at a different value of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOutFun(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOutFun_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="leaveOneOutFun_+3A_...">...</code></td>
<td>
<p>Further arguments of function (eg. range).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Leave-One-Out sum of squares.
</p>

<hr>
<h2 id='leaveOneOutFun.Kriging'>Compute Leave-One-Out (LOO) error for an object with S3 class
<code>"Kriging"</code> representing a kriging model.</h2><span id='topic+leaveOneOutFun.Kriging'></span><span id='topic+leaveOneOutFun+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>The returned value is the sum of squares <code class="reqn">\sum_{i=1}^n [y_i -
\hat{y}_{i,(-i)}]^2</code> where <code class="reqn">\hat{y}_{i,(-i)}</code> is the
prediction of <code class="reqn">y_i</code> based on the the observations <code class="reqn">y_j</code>
with <code class="reqn">j \neq i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
leaveOneOutFun(object, theta, grad = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOutFun.Kriging_+3A_object">object</code></td>
<td>
<p>A <code>Kriging</code> object.</p>
</td></tr>
<tr><td><code id="leaveOneOutFun.Kriging_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of range parameters at which the LOO
will be evaluated.</p>
</td></tr>
<tr><td><code id="leaveOneOutFun.Kriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the gradient (w.r.t. <code>theta</code>) be
returned?</p>
</td></tr>
<tr><td><code id="leaveOneOutFun.Kriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output</p>
</td></tr>
<tr><td><code id="leaveOneOutFun.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The leave-One-Out value computed for the given vector
<code class="reqn">\boldsymbol{\theta}</code> of correlation ranges.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective = "LOO", optim="BFGS")
print(k)

loo &lt;-  function(theta) leaveOneOutFun(k, theta)$leaveOneOut
t &lt;-  seq(from = 0.001, to = 2, length.out = 101)
plot(t, loo(t), type = "l")
abline(v = k$theta(), col = "blue")
</code></pre>

<hr>
<h2 id='leaveOneOutVec'>Leave-One-Out vector</h2><span id='topic+leaveOneOutVec'></span>

<h3>Description</h3>

<p>Compute the leave-One-Out vector error of a model given in <code>object</code>,
at a different value of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOutVec(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOutVec_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="leaveOneOutVec_+3A_...">...</code></td>
<td>
<p>Further arguments of function (eg. range).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Leave-One-Out errors (mean and stdev) for each conditional point.
</p>

<hr>
<h2 id='leaveOneOutVec.Kriging'>Compute Leave-One-Out (LOO) vector error for an object with S3 class
<code>"Kriging"</code> representing a kriging model.</h2><span id='topic+leaveOneOutVec.Kriging'></span><span id='topic+leaveOneOutVec+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>The returned value is the mean and stdev of <code class="reqn">\hat{y}_{i,(-i)}</code>, the
prediction of <code class="reqn">y_i</code> based on the the observations <code class="reqn">y_j</code>
with <code class="reqn">j \neq i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
leaveOneOutVec(object, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOutVec.Kriging_+3A_object">object</code></td>
<td>
<p>A <code>Kriging</code> object.</p>
</td></tr>
<tr><td><code id="leaveOneOutVec.Kriging_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of range parameters at which the LOO
will be evaluated.</p>
</td></tr>
<tr><td><code id="leaveOneOutVec.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The leave-One-Out vector computed for the given vector
<code class="reqn">\boldsymbol{\theta}</code> of correlation ranges.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(c(0.0, 0.25, 0.5, 0.75, 1.0))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2")
print(k)

x &lt;- as.matrix(seq(0, 1, , 101))
p &lt;- predict(k, x, TRUE, FALSE)

plot(f)
points(X, y)
lines(x, p$mean, col = 'blue')
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
        border = NA, col = rgb(0, 0, 1, 0.2))

# Compute leave-one-out (no range re-estimate) on 2nd point
X_no2 = X[-2,,drop=FALSE]
y_no2 = f(X_no2)
k_no2 = Kriging(y_no2, X_no2, "matern3_2", optim = "none", parameters = list(theta = k$theta()))
print(k_no2)

p_no2 &lt;- predict(k_no2, x, TRUE, FALSE)
lines(x, p_no2$mean, col = 'red')
polygon(c(x, rev(x)), c(p_no2$mean - 2 * p_no2$stdev, rev(p_no2$mean + 2 * p_no2$stdev)), 
        border = NA, col = rgb(1, 0, 0, 0.2))

# Use leaveOneOutVec to get the same
loov = k$leaveOneOutVec(matrix(k$theta()))
points(X[2],loov$mean[2],col='red')
lines(rep(X[2],2),loov$mean[2]+2*c(-loov$stdev[2],loov$stdev[2]),col='red')
</code></pre>

<hr>
<h2 id='load'>Load any Kriging Model from a file storage.</h2><span id='topic+load'></span>

<h3>Description</h3>

<p>Load any Kriging Model from a file storage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_+3A_filename">filename</code></td>
<td>
<p>A file holding any Kriging object.</p>
</td></tr>
<tr><td><code id="load_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded &quot;*&quot;Kriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

outfile = tempfile("k.h5") 
save(k,outfile)

print(load(outfile))
</code></pre>

<hr>
<h2 id='load.Kriging'>Load a Kriging Model from a file storage</h2><span id='topic+load.Kriging'></span>

<h3>Description</h3>

<p>Load a Kriging Model from a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.Kriging(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.Kriging_+3A_filename">filename</code></td>
<td>
<p>File name to load from.</p>
</td></tr>
<tr><td><code id="load.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded Kriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

outfile = tempfile("k.h5")
save(k,outfile)

print(load.Kriging(outfile)) 
</code></pre>

<hr>
<h2 id='load.NoiseKriging'>Load a NoiseKriging Model from a file storage</h2><span id='topic+load.NoiseKriging'></span>

<h3>Description</h3>

<p>Load a NoiseKriging Model from a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.NoiseKriging(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.NoiseKriging_+3A_filename">filename</code></td>
<td>
<p>File name to load from.</p>
</td></tr>
<tr><td><code id="load.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded NoiseKriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NoiseKriging(y, (X/10)^2, X, "matern3_2")
print(k)

outfile = tempfile("k.h5")
save(k,outfile)

print(load.NoiseKriging(outfile)) 
</code></pre>

<hr>
<h2 id='load.NuggetKriging'>Load a NuggetKriging Model from a file storage</h2><span id='topic+load.NuggetKriging'></span>

<h3>Description</h3>

<p>Load a NuggetKriging Model from a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.NuggetKriging(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.NuggetKriging_+3A_filename">filename</code></td>
<td>
<p>File name to load from.</p>
</td></tr>
<tr><td><code id="load.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded NuggetKriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NuggetKriging(y, X, "matern3_2")
print(k)

outfile = tempfile("k.h5")
save(k,outfile)

print(load.NuggetKriging(outfile)) 
</code></pre>

<hr>
<h2 id='logLikelihood'>Compute Log-Likelihood</h2><span id='topic+logLikelihood'></span>

<h3>Description</h3>

<p>Compute the log-Likelihood of a model given in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikelihood(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="logLikelihood_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood.
</p>

<hr>
<h2 id='logLikelihood.Kriging'>Get Log-Likelihood of Kriging Model</h2><span id='topic+logLikelihood.Kriging'></span><span id='topic+logLikelihood+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Get Log-Likelihood of Kriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
logLikelihood(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="logLikelihood.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-Likelihood computed for fitted
<code class="reqn">\boldsymbol{theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LL")
print(k)

logLikelihood(k)
</code></pre>

<hr>
<h2 id='logLikelihood.NoiseKriging'>Get logLikelihood of NoiseKriging Model</h2><span id='topic+logLikelihood.NoiseKriging'></span><span id='topic+logLikelihood+2CNoiseKriging+2CNoiseKriging-method'></span>

<h3>Description</h3>

<p>Get logLikelihood of NoiseKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
logLikelihood(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.NoiseKriging_+3A_object">object</code></td>
<td>
<p>An S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="logLikelihood.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logLikelihood computed for fitted
<code class="reqn">\boldsymbol{theta_sigma2}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))

k &lt;- NoiseKriging(y, (X/10)^2, X, kernel = "matern3_2", objective="LL")
print(k)

logLikelihood(k)
</code></pre>

<hr>
<h2 id='logLikelihood.NuggetKriging'>Get logLikelihood of NuggetKriging Model</h2><span id='topic+logLikelihood.NuggetKriging'></span><span id='topic+logLikelihood+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Get logLikelihood of NuggetKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
logLikelihood(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihood.NuggetKriging_+3A_object">object</code></td>
<td>
<p>An S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="logLikelihood.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logLikelihood computed for fitted
<code class="reqn">\boldsymbol{theta_alpha}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, kernel = "matern3_2", objective="LL")
print(k)

logLikelihood(k)
</code></pre>

<hr>
<h2 id='logLikelihoodFun'>Log-Likelihood function</h2><span id='topic+logLikelihoodFun'></span>

<h3>Description</h3>

<p>Compute the log-Likelihood of a model given in <code>object</code>,
at a different value of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikelihoodFun(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihoodFun_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun_+3A_...">...</code></td>
<td>
<p>Further arguments of function (eg. range).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood.
</p>

<hr>
<h2 id='logLikelihoodFun.Kriging'>Compute Log-Likelihood of Kriging Model</h2><span id='topic+logLikelihoodFun.Kriging'></span><span id='topic+logLikelihoodFun+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Compute Log-Likelihood of Kriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
logLikelihoodFun(object, theta, grad = FALSE, hess = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of (positive) range parameters at
which the log-likelihood will be evaluated.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the function return the gradient?</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_hess">hess</code></td>
<td>
<p>Logical. Should the function return Hessian?</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output?</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-Likelihood computed for given
<code class="reqn">\boldsymbol{theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2")
print(k)

ll &lt;- function(theta) logLikelihoodFun(k, theta)$logLikelihood

t &lt;- seq(from = 0.001, to = 2, length.out = 101)
plot(t, ll(t), type = 'l')
abline(v = k$theta(), col = "blue")
</code></pre>

<hr>
<h2 id='logLikelihoodFun.NoiseKriging'>Compute Log-Likelihood of NoiseKriging Model</h2><span id='topic+logLikelihoodFun.NoiseKriging'></span><span id='topic+logLikelihoodFun+2CNoiseKriging+2CNoiseKriging-method'></span><span id='topic+f'></span><span id='topic++3C-'></span><span id='topic+function+28x+29'></span><span id='topic+1'></span><span id='topic+-'></span><span id='topic++2F'></span><span id='topic+2'></span><span id='topic++2A'></span><span id='topic++28sin+2812'></span><span id='topic+x+29'></span><span id='topic++281'></span><span id='topic++2B'></span><span id='topic+cos+287'></span><span id='topic+x+5E5'></span><span id='topic+0.7+29'></span><span id='topic+set.seed+28123+29'></span><span id='topic+X'></span><span id='topic+as.matrix+28runif+2810+29+29'></span><span id='topic+y'></span><span id='topic+f+28X+29'></span><span id='topic+X+2F10'></span><span id='topic++2Arnorm+28nrow+28X+29+29'></span><span id='topic+k'></span><span id='topic+NoiseKriging+28y+2C'></span><span id='topic++28X+2F10+29+5E2+2C'></span><span id='topic+X+2C'></span><span id='topic+kernel'></span><span id='topic++3D'></span><span id='topic++22matern3_2+22+29'></span><span id='topic+print+28k+29'></span><span id='topic+theta0'></span><span id='topic+k+24theta+28+29'></span><span id='topic+ll_sigma2'></span><span id='topic+function+28sigma2+29'></span><span id='topic+logLikelihoodFun+28k+2C'></span><span id='topic+cbind+28theta0+2Csigma2+29+29+24logLikelihood'></span><span id='topic+s2'></span><span id='topic+seq+28from'></span><span id='topic+0.001+2C'></span><span id='topic+to'></span><span id='topic+1+2C'></span><span id='topic+length.out'></span><span id='topic+101+29'></span><span id='topic+plot+28s2+2C'></span><span id='topic+Vectorize+28ll_sigma2+29+28s2+29+2C'></span><span id='topic+type'></span><span id='topic++27l+27+29'></span><span id='topic+abline+28v'></span><span id='topic+k+24sigma2+28+29+2C'></span><span id='topic+col'></span><span id='topic++22blue+22+29'></span><span id='topic+sigma20'></span><span id='topic+k+24sigma2+28+29'></span><span id='topic+ll_theta'></span><span id='topic+function+28theta+29'></span><span id='topic+cbind+28theta+2Csigma20+29+29+24logLikelihood'></span><span id='topic+t'></span><span id='topic+2+2C'></span><span id='topic+plot+28t+2C'></span><span id='topic+Vectorize+28ll_theta+29+28t+29+2C'></span><span id='topic+k+24theta+28+29+2C'></span><span id='topic+ll'></span><span id='topic+function+28theta_sigma2+29'></span><span id='topic+theta_sigma2+29+24logLikelihood'></span><span id='topic+31+29'></span><span id='topic+contour+28t+2Cs2+2Cmatrix+28ncol+3Dlength+28s2+29+2Cll+28expand.grid+28t+2Cs2+29+29+29+2Cxlab+3D+22theta+22+2Cylab+3D+22sigma2+22+29'></span><span id='topic+points+28k+24theta+28+29+2Ck+24sigma2+28+29+2Ccol+3D+27blue+27+29'></span>

<h3>Description</h3>

<p>Compute Log-Likelihood of NoiseKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
logLikelihoodFun(object, theta_sigma2, grad = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihoodFun.NoiseKriging_+3A_object">object</code></td>
<td>
<p>An S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NoiseKriging_+3A_theta_sigma2">theta_sigma2</code></td>
<td>
<p>A numeric vector of (positive) range parameters and variance at
which the log-likelihood will be evaluated.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NoiseKriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the function return the gradient?</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NoiseKriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-Likelihood computed for given
<code class="reqn">\boldsymbol{theta_sigma2}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>

<hr>
<h2 id='logLikelihoodFun.NuggetKriging'>Compute Log-Likelihood of NuggetKriging Model</h2><span id='topic+logLikelihoodFun.NuggetKriging'></span><span id='topic+logLikelihoodFun+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Compute Log-Likelihood of NuggetKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
logLikelihoodFun(object, theta_alpha, grad = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikelihoodFun.NuggetKriging_+3A_object">object</code></td>
<td>
<p>An S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NuggetKriging_+3A_theta_alpha">theta_alpha</code></td>
<td>
<p>A numeric vector of (positive) range parameters and variance over variance plus nugget at
which the log-likelihood will be evaluated.</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NuggetKriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the function return the gradient?</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NuggetKriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output</p>
</td></tr>
<tr><td><code id="logLikelihoodFun.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-Likelihood computed for given
<code class="reqn">\boldsymbol{theta_alpha}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, kernel = "matern3_2")
print(k)

theta0 = k$theta()
ll_alpha &lt;- function(alpha) logLikelihoodFun(k,cbind(theta0,alpha))$logLikelihood
a &lt;- seq(from = 0.9, to = 1.0, length.out = 101)
plot(a, Vectorize(ll_alpha)(a), type = "l",xlim=c(0.9,1))
abline(v = k$sigma2()/(k$sigma2()+k$nugget()), col = "blue")

alpha0 = k$sigma2()/(k$sigma2()+k$nugget())
ll_theta &lt;- function(theta) logLikelihoodFun(k,cbind(theta,alpha0))$logLikelihood
t &lt;- seq(from = 0.001, to = 2, length.out = 101)
plot(t, Vectorize(ll_theta)(t), type = 'l')
abline(v = k$theta(), col = "blue")

ll &lt;- function(theta_alpha) logLikelihoodFun(k,theta_alpha)$logLikelihood
a &lt;- seq(from = 0.9, to = 1.0, length.out = 31)
t &lt;- seq(from = 0.001, to = 2, length.out = 101)
contour(t,a,matrix(ncol=length(a),ll(expand.grid(t,a))),xlab="theta",ylab="sigma2/(sigma2+nugget)")
points(k$theta(),k$sigma2()/(k$sigma2()+k$nugget()),col='blue')
</code></pre>

<hr>
<h2 id='logMargPost'>Compute log-Marginal Posterior</h2><span id='topic+logMargPost'></span>

<h3>Description</h3>

<p>Compute the log-Marginal Posterior of a model given in
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMargPost(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPost_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="logMargPost_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-marginal posterior.
</p>

<hr>
<h2 id='logMargPost.Kriging'>Get logMargPost of Kriging Model</h2><span id='topic+logMargPost.Kriging'></span><span id='topic+logMargPost+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Get logMargPost of Kriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
logMargPost(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPost.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="logMargPost.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logMargPost computed for fitted
<code class="reqn">\boldsymbol{theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

logMargPost(k)
</code></pre>

<hr>
<h2 id='logMargPost.NuggetKriging'>Get logMargPost of NuggetKriging Model</h2><span id='topic+logMargPost.NuggetKriging'></span><span id='topic+logMargPost+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Get logMargPost of NuggetKriging Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
logMargPost(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPost.NuggetKriging_+3A_object">object</code></td>
<td>
<p>An S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="logMargPost.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The logMargPost computed for fitted
<code class="reqn">\boldsymbol{theta_alpha}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

logMargPost(k)
</code></pre>

<hr>
<h2 id='logMargPostFun'>log-Marginal Posterior function</h2><span id='topic+logMargPostFun'></span>

<h3>Description</h3>

<p>Compute the log-Marginal Posterior of a model given in
<code>object</code>, at a different value of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMargPostFun(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPostFun_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="logMargPostFun_+3A_...">...</code></td>
<td>
<p>Further arguments of function (eg. range).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-marginal posterior.
</p>

<hr>
<h2 id='logMargPostFun.Kriging'>Compute the log-marginal posterior of a kriging model, using the
prior XXXY.</h2><span id='topic+logMargPostFun.Kriging'></span><span id='topic+logMargPostFun+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Compute the log-marginal posterior of a kriging model, using the
prior XXXY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
logMargPostFun(object, theta, grad = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPostFun.Kriging_+3A_object">object</code></td>
<td>
<p>S3 Kriging object.</p>
</td></tr>
<tr><td><code id="logMargPostFun.Kriging_+3A_theta">theta</code></td>
<td>
<p>Numeric vector of correlation range parameters at
which the function is to be evaluated.</p>
</td></tr>
<tr><td><code id="logMargPostFun.Kriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the function return the gradient
(w.r.t theta)?</p>
</td></tr>
<tr><td><code id="logMargPostFun.Kriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output?</p>
</td></tr>
<tr><td><code id="logMargPostFun.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the log-marginal posterior computed for the
given vector theta.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>References</h3>

<p>XXXY A reference describing the model (prior, ...)
</p>


<h3>See Also</h3>

<p><code><a href="RobustGaSP.html#topic+rgasp">rgasp</a></code> in the RobustGaSP package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, "matern3_2", objective="LMP")
print(k)

lmp &lt;- function(theta) logMargPostFun(k, theta)$logMargPost

t &lt;- seq(from = 0.01, to = 2, length.out = 101)
plot(t, lmp(t), type = "l")
abline(v = k$theta(), col = "blue")
</code></pre>

<hr>
<h2 id='logMargPostFun.NuggetKriging'>Compute the log-marginal posterior of a kriging model, using the
prior XXXY.</h2><span id='topic+logMargPostFun.NuggetKriging'></span><span id='topic+logMargPostFun+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Compute the log-marginal posterior of a kriging model, using the
prior XXXY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
logMargPostFun(object, theta_alpha, grad = FALSE, bench = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargPostFun.NuggetKriging_+3A_object">object</code></td>
<td>
<p>S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="logMargPostFun.NuggetKriging_+3A_theta_alpha">theta_alpha</code></td>
<td>
<p>Numeric vector of correlation range and variance over variance plus nugget parameters at
which the function is to be evaluated.</p>
</td></tr>
<tr><td><code id="logMargPostFun.NuggetKriging_+3A_grad">grad</code></td>
<td>
<p>Logical. Should the function return the gradient
(w.r.t theta_alpha)?</p>
</td></tr>
<tr><td><code id="logMargPostFun.NuggetKriging_+3A_bench">bench</code></td>
<td>
<p>Logical. Should the function display benchmarking output</p>
</td></tr>
<tr><td><code id="logMargPostFun.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the log-marginal posterior computed for the
given vector <code class="reqn">\boldsymbol{theta_alpha}</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>References</h3>

<p>XXXY A reference describing the model (prior, ...)
</p>


<h3>See Also</h3>

<p><code><a href="RobustGaSP.html#topic+rgasp">rgasp</a></code> in the RobustGaSP package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, "matern3_2", objective="LMP")
print(k)

theta0 = k$theta()
lmp_alpha &lt;- function(alpha) k$logMargPostFun(cbind(theta0,alpha))$logMargPost
a &lt;- seq(from = 0.9, to = 1.0, length.out = 101)
plot(a, Vectorize(lmp_alpha)(a), type = "l",xlim=c(0.9,1))
abline(v = k$sigma2()/(k$sigma2()+k$nugget()), col = "blue")

alpha0 = k$sigma2()/(k$sigma2()+k$nugget())
lmp_theta &lt;- function(theta) k$logMargPostFun(cbind(theta,alpha0))$logMargPost
t &lt;- seq(from = 0.001, to = 2, length.out = 101)
plot(t, Vectorize(lmp_theta)(t), type = 'l')
abline(v = k$theta(), col = "blue")

lmp &lt;- function(theta_alpha) k$logMargPostFun(theta_alpha)$logMargPost
t &lt;- seq(from = 0.4, to = 0.6, length.out = 51)
a &lt;- seq(from = 0.9, to = 1, length.out = 51)
contour(t,a,matrix(ncol=length(t),lmp(expand.grid(t,a))),
 nlevels=50,xlab="theta",ylab="sigma2/(sigma2+nugget)")
points(k$theta(),k$sigma2()/(k$sigma2()+k$nugget()),col='blue')
</code></pre>

<hr>
<h2 id='NoiseKM'>Create an <code>NoiseKM</code> Object</h2><span id='topic+NoiseKM'></span>

<h3>Description</h3>

<p>Create an object of S4 class <code>"NoiseKM"</code> similar to a
<code>km</code> object in the <span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoiseKM(
  formula = ~1,
  design,
  response,
  covtype = c("matern5_2", "gauss", "matern3_2", "exp"),
  coef.trend = NULL,
  coef.cov = NULL,
  coef.var = NULL,
  nugget = NULL,
  nugget.estim = FALSE,
  noise.var,
  estim.method = c("MLE", "LOO"),
  penalty = NULL,
  optim.method = "BFGS",
  lower = NULL,
  upper = NULL,
  parinit = NULL,
  multistart = 1,
  control = NULL,
  gr = TRUE,
  iso = FALSE,
  scaling = FALSE,
  knots = NULL,
  kernel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoiseKM_+3A_formula">formula</code></td>
<td>
<p>R formula object to setup the linear trend in
Universal NoiseKriging. Supports <code>~ 1</code>, ~. and <code>~ .^2</code>.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_design">design</code></td>
<td>
<p>Data frame. The design of experiments.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_response">response</code></td>
<td>
<p>Vector of output values.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_covtype">covtype</code></td>
<td>
<p>Covariance structure. For now all the kernels are
tensor product kernels.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_coef.trend">coef.trend</code></td>
<td>
<p>Optional value for a fixed vector of trend
coefficients.  If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_coef.cov">coef.cov</code></td>
<td>
<p>Optional value for a fixed correlation range
value. If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_coef.var">coef.var</code></td>
<td>
<p>Optional value for a fixed variance. If given, no
optimization is done.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_nugget">nugget</code>, <code id="NoiseKM_+3A_nugget.estim">nugget.estim</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_noise.var">noise.var</code></td>
<td>
<p>Vector of output values variance.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_estim.method">estim.method</code></td>
<td>
<p>Estimation criterion. <code>"MLE"</code> for
Maximum-Likelihood or <code>"LOO"</code> for Leave-One-Out
cross-validation.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_penalty">penalty</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_optim.method">optim.method</code></td>
<td>
<p>Optimization algorithm used in the
optimization of the objective given in
<code>estim.method</code>. Supports <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_lower">lower</code>, <code id="NoiseKM_+3A_upper">upper</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_parinit">parinit</code></td>
<td>
<p>Initial values for the correlation ranges which
will be optimized using <code>optim.method</code>.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_multistart">multistart</code>, <code id="NoiseKM_+3A_control">control</code>, <code id="NoiseKM_+3A_gr">gr</code>, <code id="NoiseKM_+3A_iso">iso</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_scaling">scaling</code>, <code id="NoiseKM_+3A_knots">knots</code>, <code id="NoiseKM_+3A_kernel">kernel</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NoiseKM_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"NoiseKM"</code> extends the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package, hence has all slots of <code>"km"</code>. It
also has an extra slot <code>"NoiseKriging"</code> slot which contains a copy
of the original object.
</p>


<h3>Value</h3>

<p>A NoiseKM object. See <b>Details</b>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km">km</a></code> in the <span class="pkg">DiceKriging</span>
package for more details on the slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- as.matrix(expand.grid(x1 = seq(0, 1, length = 4),
                                     x2 = seq(0, 1, length = 4)))
y &lt;- apply(design.fact, 1, DiceKriging::branin) + rnorm(nrow(design.fact))

# Using `km` from DiceKriging and a similar `NoiseKM` object 
# kriging model 1 : matern5_2 covariance structure, no trend, no nugget effect
km1 &lt;- DiceKriging::km(design = design.fact, response = y, covtype = "gauss",
                       noise.var=rep(1,nrow(design.fact)),
                       parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- NoiseKM(design = design.fact, response = y, covtype = "gauss",
          noise=rep(1,nrow(design.fact)), parinit = c(.5, 1))

</code></pre>

<hr>
<h2 id='NoiseKM-class'>S4 class for NoiseKriging Models Extending the <code>"km"</code> Class</h2><span id='topic+NoiseKM-class'></span>

<h3>Description</h3>

<p>This class is intended to be used either by using its
own dedicated S4 methods or by using the S4 methods inherited
from the <code>"km"</code> class of the <span class="pkg">libKriging</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>d,n,X,y,p,F</code></dt><dd><p>Number of (numeric) inputs, number of
observations, design matrix, response vector, number of trend
variables, trend matrix.</p>
</dd>
<dt><code>trend.formula,trend.coef</code></dt><dd><p>Formula used for the trend, vector
<code class="reqn">\hat{\boldsymbol{\beta}}</code> of estimated (or fixed)
trend coefficients with length <code class="reqn">p</code>.</p>
</dd>
<dt><code>covariance</code></dt><dd><p>A S4 object with class <code>"covTensorProduct"</code>
representing a covariance kernel.</p>
</dd>
<dt><code>noise.flag,noise.var</code></dt><dd><p>Logical flag and numeric value for an
optional noise term.</p>
</dd>
<dt><code>known.param</code></dt><dd><p>A character code indicating what parameters are
known.</p>
</dd>
<dt><code>lower,upper</code></dt><dd><p>Bounds on the correlation range parameters.</p>
</dd>
<dt><code>method,penalty,optim.method,control,gr,parinit</code></dt><dd><p>Objects
defining the estimation criterion, the optimization.</p>
</dd>
<dt><code>T,M,z</code></dt><dd><p>Auxiliary variables (matrices and vectors) that can be
used in several computations.</p>
</dd>
<dt><code>case</code></dt><dd><p>The possible concentration (a.k.a. profiling) of the
likelihood.</p>
</dd>
<dt><code>param.estim</code></dt><dd><p>Logical. Is an estimation used?</p>
</dd>
<dt><code>NoiseKriging</code></dt><dd><p>A copy of the <code>NoiseKriging</code> object used to create
the current <code>NoiseKM</code> object.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km-class">km-class</a></code> in the
<span class="pkg">DiceKriging</span> package. The creator <code><a href="#topic+NoiseKM">NoiseKM</a></code>.
</p>

<hr>
<h2 id='NoiseKriging'>Create an object with S3 class <code>"NoiseKriging"</code> using
the <span class="pkg">libKriging</span> library.</h2><span id='topic+NoiseKriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoiseKriging(
  y = NULL,
  noise = NULL,
  X = NULL,
  kernel = NULL,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "none"),
  objective = c("LL"),
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoiseKriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_noise">noise</code></td>
<td>
<p>Numeric vector of response variances.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_kernel">kernel</code></td>
<td>
<p>Character defining the covariance model:
<code>"exp"</code>, <code>"gauss"</code>, <code>"matern3_2"</code>, <code>"matern5_2"</code>.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal NoiseKriging linear trend.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code> and <code>"none"</code>,
the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood.</p>
</td></tr>
<tr><td><code id="NoiseKriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When
provided this must be named list with elements <code>"sigma2"</code>
and <code>"theta"</code> containing the initial value(s) for the
variance and for the range parameters. If <code>theta</code> is a
matrix with more than one row, each row is used as a starting
point for optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"NoiseKriging"</code>. Should be used
with its <code>predict</code>, <code>simulate</code>, <code>update</code>
methods.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X)) # add noise dep. on X
## fit and print
k &lt;- NoiseKriging(y, noise=(X/10)^2, X, kernel = "matern3_2")
print(k)

x &lt;- as.matrix(seq(from = 0, to = 1, length.out = 101))
p &lt;- predict(k,x = x, stdev = TRUE, cov = FALSE)

plot(f)
points(X, y)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
border = NA, col = rgb(0, 0, 1, 0.2))

s &lt;- simulate(k, nsim = 10, seed = 123, x = x)

matlines(x, s, col = rgb(0, 0, 1, 0.2), type = "l", lty = 1)
</code></pre>

<hr>
<h2 id='NuggetKM'>Create an <code>NuggetKM</code> Object</h2><span id='topic+NuggetKM'></span>

<h3>Description</h3>

<p>Create an object of S4 class <code>"NuggetKM"</code> similar to a
<code>km</code> object in the <span class="pkg">DiceKriging</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NuggetKM(
  formula = ~1,
  design,
  response,
  covtype = c("matern5_2", "gauss", "matern3_2", "exp"),
  coef.trend = NULL,
  coef.cov = NULL,
  coef.var = NULL,
  nugget = NULL,
  nugget.estim = TRUE,
  noise.var = NULL,
  estim.method = c("MLE", "LOO"),
  penalty = NULL,
  optim.method = "BFGS",
  lower = NULL,
  upper = NULL,
  parinit = NULL,
  multistart = 1,
  control = NULL,
  gr = TRUE,
  iso = FALSE,
  scaling = FALSE,
  knots = NULL,
  kernel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NuggetKM_+3A_formula">formula</code></td>
<td>
<p>R formula object to setup the linear trend in
Universal NuggetKriging. Supports <code>~ 1</code>, ~. and <code>~ .^2</code>.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_design">design</code></td>
<td>
<p>Data frame. The design of experiments.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_response">response</code></td>
<td>
<p>Vector of output values.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_covtype">covtype</code></td>
<td>
<p>Covariance structure. For now all the kernels are
tensor product kernels.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_coef.trend">coef.trend</code></td>
<td>
<p>Optional value for a fixed vector of trend
coefficients.  If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_coef.cov">coef.cov</code></td>
<td>
<p>Optional value for a fixed correlation range
value. If given, no optimization is done.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_coef.var">coef.var</code></td>
<td>
<p>Optional value for a fixed variance. If given, no
optimization is done.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_nugget.estim">nugget.estim</code>, <code id="NuggetKM_+3A_nugget">nugget</code></td>
<td>
<p>Should nugget be estimated? (defaults TRUE) or given values.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_noise.var">noise.var</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_estim.method">estim.method</code></td>
<td>
<p>Estimation criterion. <code>"MLE"</code> for
Maximum-Likelihood or <code>"LOO"</code> for Leave-One-Out
cross-validation.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_penalty">penalty</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_optim.method">optim.method</code></td>
<td>
<p>Optimization algorithm used in the
optimization of the objective given in
<code>estim.method</code>. Supports <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_lower">lower</code>, <code id="NuggetKM_+3A_upper">upper</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_parinit">parinit</code></td>
<td>
<p>Initial values for the correlation ranges which
will be optimized using <code>optim.method</code>.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_multistart">multistart</code>, <code id="NuggetKM_+3A_control">control</code>, <code id="NuggetKM_+3A_gr">gr</code>, <code id="NuggetKM_+3A_iso">iso</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_scaling">scaling</code>, <code id="NuggetKM_+3A_knots">knots</code>, <code id="NuggetKM_+3A_kernel">kernel</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="NuggetKM_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"NuggetKM"</code> extends the <code>"km"</code> class of the
<span class="pkg">DiceKriging</span> package, hence has all slots of <code>"km"</code>. It
also has an extra slot <code>"NuggetKriging"</code> slot which contains a copy
of the original object.
</p>


<h3>Value</h3>

<p>A NuggetKM object. See <b>Details</b>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km">km</a></code> in the <span class="pkg">DiceKriging</span>
package for more details on the slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- as.matrix(expand.grid(x1 = seq(0, 1, length = 4),
                                     x2 = seq(0, 1, length = 4)))
y &lt;- apply(design.fact, 1, DiceKriging::branin) + rnorm(nrow(design.fact))

# Using `km` from DiceKriging and a similar `NuggetKM` object 
# kriging model 1 : matern5_2 covariance structure, no trend, no nugget effect
km1 &lt;- DiceKriging::km(design = design.fact, response = y, covtype = "gauss",
                       nugget.estim=TRUE,
                       parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- NuggetKM(design = design.fact, response = y, covtype = "gauss",
          parinit = c(.5, 1))

</code></pre>

<hr>
<h2 id='NuggetKM-class'>S4 class for NuggetKriging Models Extending the <code>"km"</code> Class</h2><span id='topic+NuggetKM-class'></span>

<h3>Description</h3>

<p>This class is intended to be used either by using its
own dedicated S4 methods or by using the S4 methods inherited
from the <code>"km"</code> class of the <span class="pkg">libKriging</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>d,n,X,y,p,F</code></dt><dd><p>Number of (numeric) inputs, number of
observations, design matrix, response vector, number of trend
variables, trend matrix.</p>
</dd>
<dt><code>trend.formula,trend.coef</code></dt><dd><p>Formula used for the trend, vector
<code class="reqn">\hat{\boldsymbol{\beta}}</code> of estimated (or fixed)
trend coefficients with length <code class="reqn">p</code>.</p>
</dd>
<dt><code>covariance</code></dt><dd><p>A S4 object with class <code>"covTensorProduct"</code>
representing a covariance kernel.</p>
</dd>
<dt><code>noise.flag,noise.var</code></dt><dd><p>Logical flag and numeric value for an
optional noise term.</p>
</dd>
<dt><code>known.param</code></dt><dd><p>A character code indicating what parameters are
known.</p>
</dd>
<dt><code>lower,upper</code></dt><dd><p>Bounds on the correlation range parameters.</p>
</dd>
<dt><code>method,penalty,optim.method,control,gr,parinit</code></dt><dd><p>Objects
defining the estimation criterion, the optimization.</p>
</dd>
<dt><code>T,M,z</code></dt><dd><p>Auxiliary variables (matrices and vectors) that can be
used in several computations.</p>
</dd>
<dt><code>case</code></dt><dd><p>The possible concentration (a.k.a. profiling) of the
likelihood.</p>
</dd>
<dt><code>param.estim</code></dt><dd><p>Logical. Is an estimation used?</p>
</dd>
<dt><code>NuggetKriging</code></dt><dd><p>A copy of the <code>NuggetKriging</code> object used to create
the current <code>NuggetKM</code> object.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+km-class">km-class</a></code> in the
<span class="pkg">DiceKriging</span> package. The creator <code><a href="#topic+NuggetKM">NuggetKM</a></code>.
</p>

<hr>
<h2 id='NuggetKriging'>Create an object with S3 class <code>"NuggetKriging"</code> using
the <span class="pkg">libKriging</span> library.</h2><span id='topic+NuggetKriging'></span>

<h3>Description</h3>

<p>The hyper-parameters (variance and vector of correlation ranges)
are estimated thanks to the optimization of a criterion given by
<code>objective</code>, using the method given in <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NuggetKriging(
  y = NULL,
  X = NULL,
  kernel = NULL,
  regmodel = c("constant", "linear", "interactive"),
  normalize = FALSE,
  optim = c("BFGS", "none"),
  objective = c("LL", "LMP"),
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NuggetKriging_+3A_y">y</code></td>
<td>
<p>Numeric vector of response values.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_x">X</code></td>
<td>
<p>Numeric matrix of input design.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_kernel">kernel</code></td>
<td>
<p>Character defining the covariance model:
<code>"exp"</code>, <code>"gauss"</code>, <code>"matern3_2"</code>, <code>"matern5_2"</code>.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_regmodel">regmodel</code></td>
<td>
<p>Universal NuggetKriging linear trend.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code> both the input matrix
<code>X</code> and the response <code>y</code> in normalized to take
values in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_optim">optim</code></td>
<td>
<p>Character giving the Optimization method used to fit
hyper-parameters. Possible values are: <code>"BFGS"</code> and <code>"none"</code>,
the later simply keeping
the values given in <code>parameters</code>. The method
<code>"BFGS"</code> uses the gradient of the objective.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_objective">objective</code></td>
<td>
<p>Character giving the objective function to
optimize. Possible values are: <code>"LL"</code> for the
Log-Likelihood and <code>"LMP"</code> for the Log-Marginal Posterior.</p>
</td></tr>
<tr><td><code id="NuggetKriging_+3A_parameters">parameters</code></td>
<td>
<p>Initial values for the hyper-parameters. When provided this
must be named list with some elements <code>"sigma2"</code>, <code>"theta"</code>, <code>"nugget"</code>
containing the initial value(s) for the variance, range and nugget
parameters. If <code>theta</code> is a matrix with more than one row,
each row is used as a starting point for optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"NuggetKriging"</code>. Should be used
with its <code>predict</code>, <code>simulate</code>, <code>update</code>
methods.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
## fit and print
k &lt;- NuggetKriging(y, X, kernel = "matern3_2")
print(k)

x &lt;- sort(c(X,as.matrix(seq(from = 0, to = 1, length.out = 101))))
p &lt;- predict(k, x = x, stdev = TRUE, cov = FALSE)

plot(f)
points(X, y)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
border = NA, col = rgb(0, 0, 1, 0.2))

s &lt;- simulate(k, nsim = 10, seed = 123, x = x)

matlines(x, s, col = rgb(0, 0, 1, 0.2), type = "l", lty = 1)
</code></pre>

<hr>
<h2 id='predict+2CKM-method'>Prediction Method for a <code>KM</code> Object</h2><span id='topic+predict+2CKM-method'></span>

<h3>Description</h3>

<p>Compute predictions for the response at new given input
points. These conditional mean, the conditional standard deviation
and confidence limits at the 95% level. Optionnally the
conditional covariance can be returned as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KM'
predict(
  object,
  newdata,
  type = "UK",
  se.compute = TRUE,
  cov.compute = FALSE,
  light.return = TRUE,
  bias.correct = FALSE,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2CKM-method_+3A_object">object</code></td>
<td>
<p><code>KM</code> object.</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Matrix of &quot;new&quot; input points where to perform
prediction.</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_type">type</code></td>
<td>
<p>character giving the kriging type. For now only
<code>"UK"</code> is possible.</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_se.compute">se.compute</code></td>
<td>
<p>Logical. Should the standard error be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_cov.compute">cov.compute</code></td>
<td>
<p>Logical. Should the covariance matrix between
newdata points be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_light.return">light.return</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no auxiliary results
will be returned (such as the Cholesky root of the correlation
matrix).</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_bias.correct">bias.correct</code></td>
<td>
<p>Logical. If <code>TRUE</code> the UK variance and
covariance are .</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Logical to check the consistency of the column
names between the design stored in <code>object@X</code> and the new
one given <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2CKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>predict</code> method for the class
<code>"KM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>KM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>predict</code>.
</p>


<h3>Value</h3>

<p>A named list. The elements are the conditional mean and
standard deviation (<code>mean</code> and <code>sd</code>), the predicted
trend (<code>trend</code>) and the confidence limits (<code>lower95</code>
and <code>upper95</code>). Optionnally, the conditional covariance matrix
is returned in <code>cov</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(x1 = seq(0, 1, length = 4), x2 = seq(0, 1, length = 4))
y &lt;- apply(design.fact, 1, DiceKriging::branin) 

## library(DiceKriging)
## kriging model 1 : matern5_2 covariance structure, no trend, no nugget
## m1 &lt;- km(design = design.fact, response = y, covtype = "gauss",
##          parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- KM(design = design.fact, response = y, covtype = "gauss",
               parinit = c(.5, 1))
Pred &lt;- predict(KM1, newdata = matrix(.5,ncol = 2), type = "UK",
                checkNames = FALSE, light.return = TRUE)

</code></pre>

<hr>
<h2 id='predict+2CNoiseKM-method'>Prediction Method for a <code>NoiseKM</code> Object</h2><span id='topic+predict+2CNoiseKM-method'></span>

<h3>Description</h3>

<p>Compute predictions for the response at new given input
points. These conditional mean, the conditional standard deviation
and confidence limits at the 95% level. Optionnally the
conditional covariance can be returned as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NoiseKM'
predict(
  object,
  newdata,
  type = "UK",
  se.compute = TRUE,
  cov.compute = FALSE,
  light.return = TRUE,
  bias.correct = FALSE,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_object">object</code></td>
<td>
<p><code>NoiseKM</code> object.</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Matrix of &quot;new&quot; input points where to perform
prediction.</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_type">type</code></td>
<td>
<p>character giving the kriging type. For now only
<code>"UK"</code> is possible.</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_se.compute">se.compute</code></td>
<td>
<p>Logical. Should the standard error be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_cov.compute">cov.compute</code></td>
<td>
<p>Logical. Should the covariance matrix between
newdata points be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_light.return">light.return</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no auxiliary results
will be returned (such as the Cholesky root of the correlation
matrix).</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_bias.correct">bias.correct</code></td>
<td>
<p>Logical. If <code>TRUE</code> the UK variance and
covariance are .</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Logical to check the consistency of the column
names between the design stored in <code>object@X</code> and the new
one given <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2CNoiseKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>predict</code> method for the class
<code>"NoiseKM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>NoiseKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>predict</code>.
</p>


<h3>Value</h3>

<p>A named list. The elements are the conditional mean and
standard deviation (<code>mean</code> and <code>sd</code>), the predicted
trend (<code>trend</code>) and the confidence limits (<code>lower95</code>
and <code>upper95</code>). Optionnally, the conditional covariance matrix
is returned in <code>cov</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(x1 = seq(0, 1, length = 4), x2 = seq(0, 1, length = 4))
y &lt;- apply(design.fact, 1, DiceKriging::branin) + rnorm(nrow(design.fact))

## library(DiceKriging)
## kriging model 1 : matern5_2 covariance structure, no trend, no nugget
## m1 &lt;- km(design = design.fact, response = y, covtype = "gauss",
##          noise.var=rep(1,nrow(design.fact)),
##          parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- NoiseKM(design = design.fact, response = y, covtype = "gauss",
               noise=rep(1,nrow(design.fact)),
               parinit = c(.5, 1))
Pred &lt;- predict(KM1, newdata = matrix(.5,ncol = 2), type = "UK",
                checkNames = FALSE, light.return = TRUE)

</code></pre>

<hr>
<h2 id='predict+2CNuggetKM-method'>Prediction Method for a <code>NuggetKM</code> Object</h2><span id='topic+predict+2CNuggetKM-method'></span>

<h3>Description</h3>

<p>Compute predictions for the response at new given input
points. These conditional mean, the conditional standard deviation
and confidence limits at the 95% level. Optionnally the
conditional covariance can be returned as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NuggetKM'
predict(
  object,
  newdata,
  type = "UK",
  se.compute = TRUE,
  cov.compute = FALSE,
  light.return = TRUE,
  bias.correct = FALSE,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_object">object</code></td>
<td>
<p><code>NuggetKM</code> object.</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Matrix of &quot;new&quot; input points where to perform
prediction.</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_type">type</code></td>
<td>
<p>character giving the kriging type. For now only
<code>"UK"</code> is possible.</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_se.compute">se.compute</code></td>
<td>
<p>Logical. Should the standard error be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_cov.compute">cov.compute</code></td>
<td>
<p>Logical. Should the covariance matrix between
newdata points be computed?</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_light.return">light.return</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no auxiliary results
will be returned (such as the Cholesky root of the correlation
matrix).</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_bias.correct">bias.correct</code></td>
<td>
<p>Logical. If <code>TRUE</code> the UK variance and
covariance are .</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Logical to check the consistency of the column
names between the design stored in <code>object@X</code> and the new
one given <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2CNuggetKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>predict</code> method for the class
<code>"NuggetKM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>NuggetKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>predict</code>.
</p>


<h3>Value</h3>

<p>A named list. The elements are the conditional mean and
standard deviation (<code>mean</code> and <code>sd</code>), the predicted
trend (<code>trend</code>) and the confidence limits (<code>lower95</code>
and <code>upper95</code>). Optionnally, the conditional covariance matrix
is returned in <code>cov</code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a 16-points factorial design, and the corresponding response
d &lt;- 2; n &lt;- 16
design.fact &lt;- expand.grid(x1 = seq(0, 1, length = 4), x2 = seq(0, 1, length = 4))
y &lt;- apply(design.fact, 1, DiceKriging::branin) + rnorm(nrow(design.fact))

## library(DiceKriging)
## kriging model 1 : matern5_2 covariance structure, no trend, no nugget
## m1 &lt;- km(design = design.fact, response = y, covtype = "gauss",
##          nugget.estim=TRUE,
##          parinit = c(.5, 1), control = list(trace = FALSE))
KM1 &lt;- NuggetKM(design = design.fact, response = y, covtype = "gauss",
               parinit = c(.5, 1))
Pred &lt;- predict(KM1, newdata = matrix(.5,ncol = 2), type = "UK",
                checkNames = FALSE, light.return = TRUE)

</code></pre>

<hr>
<h2 id='predict.Kriging'>Predict from a <code>Kriging</code> object.</h2><span id='topic+predict.Kriging'></span>

<h3>Description</h3>

<p>Given &quot;new&quot; input points, the method compute the expectation,
variance and (optionnally) the covariance of the corresponding
stochastic process, conditional on the values at the input points
used when fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
predict(object, x, stdev = TRUE, cov = FALSE, deriv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Kriging_+3A_object">object</code></td>
<td>
<p>S3 Kriging object.</p>
</td></tr>
<tr><td><code id="predict.Kriging_+3A_x">x</code></td>
<td>
<p>Input points where the prediction must be computed.</p>
</td></tr>
<tr><td><code id="predict.Kriging_+3A_stdev">stdev</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the standard deviation
is returned.</p>
</td></tr>
<tr><td><code id="predict.Kriging_+3A_cov">cov</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the covariance matrix of
the predictions is returned.</p>
</td></tr>
<tr><td><code id="predict.Kriging_+3A_deriv">deriv</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the derivatives of mean and sd
of the predictions are returned.</p>
</td></tr>
<tr><td><code id="predict.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the element <code>mean</code> and possibly
<code>stdev</code> and  <code>cov</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>predict</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>, <code>stdev</code> corresponds to <code>se.compute</code>
and <code>cov</code> to <code>cov.compute</code>. These names are chosen
<span class="pkg">Python</span> and <span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)
points(X, y, col = "blue", pch = 16)

k &lt;- Kriging(y, X, "matern3_2")

x &lt;-seq(from = 0, to = 1, length.out = 101)
p &lt;- predict(k, x)

lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))
</code></pre>

<hr>
<h2 id='predict.NoiseKriging'>Predict from a <code>NoiseKriging</code> object.</h2><span id='topic+predict.NoiseKriging'></span>

<h3>Description</h3>

<p>Given &quot;new&quot; input points, the method compute the expectation,
variance and (optionnally) the covariance of the corresponding
stochastic process, conditional on the values at the input points
used when fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
predict(object, x, stdev = TRUE, cov = FALSE, deriv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.NoiseKriging_+3A_object">object</code></td>
<td>
<p>S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="predict.NoiseKriging_+3A_x">x</code></td>
<td>
<p>Input points where the prediction must be computed.</p>
</td></tr>
<tr><td><code id="predict.NoiseKriging_+3A_stdev">stdev</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the standard deviation
is returned.</p>
</td></tr>
<tr><td><code id="predict.NoiseKriging_+3A_cov">cov</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the covariance matrix of
the predictions is returned.</p>
</td></tr>
<tr><td><code id="predict.NoiseKriging_+3A_deriv">deriv</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the derivatives of mean and sd
of the predictions are returned.</p>
</td></tr>
<tr><td><code id="predict.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the element <code>mean</code> and possibly
<code>stdev</code> and  <code>cov</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>predict</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>, <code>stdev</code> corresponds to <code>se.compute</code>
and <code>cov</code> to <code>cov.compute</code>. These names are chosen
<span class="pkg">Python</span> and <span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))
points(X, y, col = "blue", pch = 16)

k &lt;- NoiseKriging(y, (X/10)^2, X, "matern3_2")

x &lt;-seq(from = 0, to = 1, length.out = 101)
p &lt;- predict(k, x)

lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))
</code></pre>

<hr>
<h2 id='predict.NuggetKriging'>Predict from a <code>NuggetKriging</code> object.</h2><span id='topic+predict.NuggetKriging'></span>

<h3>Description</h3>

<p>Given &quot;new&quot; input points, the method compute the expectation,
variance and (optionnally) the covariance of the corresponding
stochastic process, conditional on the values at the input points
used when fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
predict(object, x, stdev = TRUE, cov = FALSE, deriv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.NuggetKriging_+3A_object">object</code></td>
<td>
<p>S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="predict.NuggetKriging_+3A_x">x</code></td>
<td>
<p>Input points where the prediction must be computed.</p>
</td></tr>
<tr><td><code id="predict.NuggetKriging_+3A_stdev">stdev</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the standard deviation
is returned.</p>
</td></tr>
<tr><td><code id="predict.NuggetKriging_+3A_cov">cov</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the covariance matrix of
the predictions is returned.</p>
</td></tr>
<tr><td><code id="predict.NuggetKriging_+3A_deriv">deriv</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code> the derivatives of mean and sd
of the predictions are returned.</p>
</td></tr>
<tr><td><code id="predict.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the element <code>mean</code> and possibly
<code>stdev</code> and  <code>cov</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>predict</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>, <code>stdev</code> corresponds to <code>se.compute</code>
and <code>cov</code> to <code>cov.compute</code>. These names are chosen
<span class="pkg">Python</span> and <span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
points(X, y, col = "blue", pch = 16)

k &lt;- NuggetKriging(y, X, "matern3_2")

## include design points to see interpolation
x &lt;- sort(c(X,seq(from = 0, to = 1, length.out = 101)))
p &lt;- predict(k, x)

lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))
</code></pre>

<hr>
<h2 id='print.Kriging'>Print the content of a <code>Kriging</code> object.</h2><span id='topic+print.Kriging'></span>

<h3>Description</h3>

<p>Print the content of a <code>Kriging</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Kriging_+3A_x">x</code></td>
<td>
<p>A (S3) <code>Kriging</code> Object.</p>
</td></tr>
<tr><td><code id="print.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of printed object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, "matern3_2")

print(k)
## same thing
k
</code></pre>

<hr>
<h2 id='print.NoiseKriging'>Print the content of a <code>NoiseKriging</code> object.</h2><span id='topic+print.NoiseKriging'></span>

<h3>Description</h3>

<p>Print the content of a <code>NoiseKriging</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NoiseKriging_+3A_x">x</code></td>
<td>
<p>A (S3) <code>NoiseKriging</code> Object.</p>
</td></tr>
<tr><td><code id="print.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of printed object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X)) # add noise dep. on X

k &lt;- NoiseKriging(y, noise=(X/10)^2, X, kernel = "matern3_2")

print(k)
## same thing
k
</code></pre>

<hr>
<h2 id='print.NuggetKriging'>Print the content of a <code>NuggetKriging</code> object.</h2><span id='topic+print.NuggetKriging'></span>

<h3>Description</h3>

<p>Print the content of a <code>NuggetKriging</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NuggetKriging_+3A_x">x</code></td>
<td>
<p>A (S3) <code>NuggetKriging</code> Object.</p>
</td></tr>
<tr><td><code id="print.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of printed object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))

k &lt;- NuggetKriging(y, X, "matern3_2")

print(k)
## same thing
k
</code></pre>

<hr>
<h2 id='save'>Save object.</h2><span id='topic+save'></span>

<h3>Description</h3>

<p>Save a model given in
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_+3A_object">object</code></td>
<td>
<p>An object representing a fitted model.</p>
</td></tr>
<tr><td><code id="save_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The saved object.
</p>

<hr>
<h2 id='save.Kriging'>Save a Kriging Model to a file storage</h2><span id='topic+save.Kriging'></span><span id='topic+save+2CKriging+2CKriging-method'></span>

<h3>Description</h3>

<p>Save a Kriging Model to a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
save(object, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.Kriging_+3A_object">object</code></td>
<td>
<p>An S3 Kriging object.</p>
</td></tr>
<tr><td><code id="save.Kriging_+3A_filename">filename</code></td>
<td>
<p>File name to save in.</p>
</td></tr>
<tr><td><code id="save.Kriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded Kriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)

k &lt;- Kriging(y, X, kernel = "matern3_2", objective="LMP")
print(k)

outfile = tempfile("k.h5") 
save(k,outfile)
</code></pre>

<hr>
<h2 id='save.NoiseKriging'>Save a NoiseKriging Model to a file storage</h2><span id='topic+save.NoiseKriging'></span><span id='topic+save+2CNoiseKriging+2CNoiseKriging-method'></span>

<h3>Description</h3>

<p>Save a NoiseKriging Model to a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
save(object, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.NoiseKriging_+3A_object">object</code></td>
<td>
<p>An S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="save.NoiseKriging_+3A_filename">filename</code></td>
<td>
<p>File name to save in.</p>
</td></tr>
<tr><td><code id="save.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded NoiseKriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))

k &lt;- NoiseKriging(y, (X/10)^2, X, "matern3_2")
print(k)

outfile = tempfile("k.h5") 
save(k,outfile)
</code></pre>

<hr>
<h2 id='save.NuggetKriging'>Save a NuggetKriging Model to a file storage</h2><span id='topic+save.NuggetKriging'></span><span id='topic+save+2CNuggetKriging+2CNuggetKriging-method'></span>

<h3>Description</h3>

<p>Save a NuggetKriging Model to a file storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
save(object, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.NuggetKriging_+3A_object">object</code></td>
<td>
<p>An S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="save.NuggetKriging_+3A_filename">filename</code></td>
<td>
<p>File name to save in.</p>
</td></tr>
<tr><td><code id="save.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded NuggetKriging object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NuggetKriging(y, X, "matern3_2")
print(k)

outfile = tempfile("k.h5") 
save(k,outfile)
</code></pre>

<hr>
<h2 id='simulate+2CKM-method'>Simulation from a <code>KM</code> Object</h2><span id='topic+simulate+2CKM-method'></span>

<h3>Description</h3>

<p>The <code>simulate</code> method is used to simulate paths from the
kriging model described in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KM'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  newdata,
  cond = TRUE,
  nugget.sim = 0,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CKM-method_+3A_object">object</code></td>
<td>
<p>A <code>KM</code> object.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_nsim">nsim</code></td>
<td>
<p>Integer: number of response vectors to simulate.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Numeric matrix with it rows giving the points where
the simulation is to be performed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_cond">cond</code></td>
<td>
<p>Logical telling wether the simulation is conditional
or not. Only <code>TRUE</code> is accepted for now.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_nugget.sim">nugget.sim</code></td>
<td>
<p>Numeric. A postive nugget effect used to avoid
numerical instability.</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Check consistency between the design data
<code>X</code> within <code>object</code> and <code>newdata</code>. The default
is <code>FALSE</code>. XXXY Not used!!!</p>
</td></tr>
<tr><td><code id="simulate+2B2CKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>simulate</code> method for the class
<code>"KM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>KM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>simulate</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>nrow(newdata)</code> rows and
<code>nsim</code> columns containing as its columns the simulated
paths at the input points given in <code>newdata</code>.
</p>
<p>XXX method simulate KM
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;-  function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X)
points(X, y, col = 'blue')
k &lt;- KM(design = X, response = y, covtype = "gauss")
x &lt;- seq(from = 0, to = 1, length.out = 101)
s_x &lt;- simulate(k, nsim = 3, newdata = x)
lines(x, s_x[ , 1], col = 'blue')
lines(x, s_x[ , 2], col = 'blue')
lines(x, s_x[ , 3], col = 'blue')

</code></pre>

<hr>
<h2 id='simulate+2CNoiseKM-method'>Simulation from a <code>NoiseKM</code> Object</h2><span id='topic+simulate+2CNoiseKM-method'></span>

<h3>Description</h3>

<p>The <code>simulate</code> method is used to simulate paths from the
kriging model described in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NoiseKM'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  newdata,
  cond = TRUE,
  nugget.sim = 0,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_object">object</code></td>
<td>
<p>A <code>NoiseKM</code> object.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_nsim">nsim</code></td>
<td>
<p>Integer: number of response vectors to simulate.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Numeric matrix with it rows giving the points where
the simulation is to be performed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_cond">cond</code></td>
<td>
<p>Logical telling wether the simulation is conditional
or not. Only <code>TRUE</code> is accepted for now.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_nugget.sim">nugget.sim</code></td>
<td>
<p>Numeric. A postive nugget effect used to avoid
numerical instability.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Check consistency between the design data
<code>X</code> within <code>object</code> and <code>newdata</code>. The default
is <code>FALSE</code>. XXXY Not used!!!</p>
</td></tr>
<tr><td><code id="simulate+2B2CNoiseKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>simulate</code> method for the class
<code>"NoiseKM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>NoiseKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>simulate</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>nrow(newdata)</code> rows and
<code>nsim</code> columns containing as its columns the simulated
paths at the input points given in <code>newdata</code>.
</p>
<p>XXX method simulate NoiseKM
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;-  function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X) + 0.01*rnorm(nrow(X))
points(X, y, col = 'blue')
k &lt;- NoiseKM(design = X, response = y, covtype = "gauss", noise=rep(0.01^2,nrow(X)))
x &lt;- seq(from = 0, to = 1, length.out = 101)
s_x &lt;- simulate(k, nsim = 3, newdata = x)
lines(x, s_x[ , 1], col = 'blue')
lines(x, s_x[ , 2], col = 'blue')
lines(x, s_x[ , 3], col = 'blue')

</code></pre>

<hr>
<h2 id='simulate+2CNuggetKM-method'>Simulation from a <code>NuggetKM</code> Object</h2><span id='topic+simulate+2CNuggetKM-method'></span>

<h3>Description</h3>

<p>The <code>simulate</code> method is used to simulate paths from the
kriging model described in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NuggetKM'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  newdata,
  cond = TRUE,
  nugget.sim = 0,
  checkNames = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_object">object</code></td>
<td>
<p>A <code>NuggetKM</code> object.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_nsim">nsim</code></td>
<td>
<p>Integer: number of response vectors to simulate.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_newdata">newdata</code></td>
<td>
<p>Numeric matrix with it rows giving the points where
the simulation is to be performed.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_cond">cond</code></td>
<td>
<p>Logical telling wether the simulation is conditional
or not. Only <code>TRUE</code> is accepted for now.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_nugget.sim">nugget.sim</code></td>
<td>
<p>Numeric. A postive nugget effect used to avoid
numerical instability.</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_checknames">checkNames</code></td>
<td>
<p>Check consistency between the design data
<code>X</code> within <code>object</code> and <code>newdata</code>. The default
is <code>FALSE</code>. XXXY Not used!!!</p>
</td></tr>
<tr><td><code id="simulate+2B2CNuggetKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>simulate</code> method for the class
<code>"NuggetKM"</code>, this method would have been inherited from the
<code>"km"</code> class. The dedicated method is expected to run faster.
A comparison can be made by coercing a <code>NuggetKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>simulate</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>nrow(newdata)</code> rows and
<code>nsim</code> columns containing as its columns the simulated
paths at the input points given in <code>newdata</code>.
</p>
<p>XXX method simulate NuggetKM
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;-  function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X) + 0.01*rnorm(nrow(X))
points(X, y, col = 'blue')
k &lt;- NuggetKM(design = X, response = y, covtype = "gauss")
x &lt;- seq(from = 0, to = 1, length.out = 101)
s_x &lt;- simulate(k, nsim = 3, newdata = x)
lines(x, s_x[ , 1], col = 'blue')
lines(x, s_x[ , 2], col = 'blue')
lines(x, s_x[ , 3], col = 'blue')

</code></pre>

<hr>
<h2 id='simulate.Kriging'>Simulation from a <code>Kriging</code> model object.</h2><span id='topic+simulate.Kriging'></span>

<h3>Description</h3>

<p>This method draws paths of the stochastic process at new input
points conditional on the values at the input points used in the
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
simulate(object, nsim = 1, seed = 123, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.Kriging_+3A_object">object</code></td>
<td>
<p>S3 Kriging object.</p>
</td></tr>
<tr><td><code id="simulate.Kriging_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to perform.</p>
</td></tr>
<tr><td><code id="simulate.Kriging_+3A_seed">seed</code></td>
<td>
<p>Random seed used.</p>
</td></tr>
<tr><td><code id="simulate.Kriging_+3A_x">x</code></td>
<td>
<p>Points in model input space where to simulate.</p>
</td></tr>
<tr><td><code id="simulate.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>length(x)</code> rows and <code>nsim</code>
columns containing the simulated paths at the inputs points
given in <code>x</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>simulate</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>. These names are chosen <span class="pkg">Python</span> and
<span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)
points(X, y, col = "blue")

k &lt;- Kriging(y, X, kernel = "matern3_2")

x &lt;- seq(from = 0, to = 1, length.out = 101)
s &lt;- simulate(k, nsim = 3, x = x)

lines(x, s[ , 1], col = "blue")
lines(x, s[ , 2], col = "blue")
lines(x, s[ , 3], col = "blue")
</code></pre>

<hr>
<h2 id='simulate.NoiseKriging'>Simulation from a <code>NoiseKriging</code> model object.</h2><span id='topic+simulate.NoiseKriging'></span>

<h3>Description</h3>

<p>This method draws paths of the stochastic process at new input
points conditional on the values at the input points used in the
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
simulate(object, nsim = 1, seed = 123, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.NoiseKriging_+3A_object">object</code></td>
<td>
<p>S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="simulate.NoiseKriging_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to perform.</p>
</td></tr>
<tr><td><code id="simulate.NoiseKriging_+3A_seed">seed</code></td>
<td>
<p>Random seed used.</p>
</td></tr>
<tr><td><code id="simulate.NoiseKriging_+3A_x">x</code></td>
<td>
<p>Points in model input space where to simulate.</p>
</td></tr>
<tr><td><code id="simulate.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>length(x)</code> rows and <code>nsim</code>
columns containing the simulated paths at the inputs points
given in <code>x</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>simulate</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>. These names are chosen <span class="pkg">Python</span> and
<span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NoiseKriging(y, (X/10)^2, X, kernel = "matern3_2")

x &lt;- seq(from = 0, to = 1, length.out = 101)
s &lt;- simulate(k, nsim = 3, x = x)

lines(x, s[ , 1], col = "blue")
lines(x, s[ , 2], col = "blue")
lines(x, s[ , 3], col = "blue")
</code></pre>

<hr>
<h2 id='simulate.NuggetKriging'>Simulation from a <code>NuggetKriging</code> model object.</h2><span id='topic+simulate.NuggetKriging'></span>

<h3>Description</h3>

<p>This method draws paths of the stochastic process at new input
points conditional on the values at the input points used in the
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
simulate(object, nsim = 1, seed = 123, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.NuggetKriging_+3A_object">object</code></td>
<td>
<p>S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="simulate.NuggetKriging_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to perform.</p>
</td></tr>
<tr><td><code id="simulate.NuggetKriging_+3A_seed">seed</code></td>
<td>
<p>Random seed used.</p>
</td></tr>
<tr><td><code id="simulate.NuggetKriging_+3A_x">x</code></td>
<td>
<p>Points in model input space where to simulate.</p>
</td></tr>
<tr><td><code id="simulate.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>length(x)</code> rows and <code>nsim</code>
columns containing the simulated paths at the inputs points
given in <code>x</code>.
</p>


<h3>Note</h3>

<p>The names of the formal arguments differ from those of the
<code>simulate</code> methods for the S4 classes <code>"km"</code> and
<code>"KM"</code>. The formal <code>x</code> corresponds to
<code>newdata</code>. These names are chosen <span class="pkg">Python</span> and
<span class="pkg">Octave</span> interfaces to <span class="pkg">libKriging</span>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1  *rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NuggetKriging(y, X, kernel = "matern3_2")

x &lt;- seq(from = 0, to = 1, length.out = 101)
s &lt;- simulate(k, nsim = 3, x = x)

lines(x, s[ , 1], col = "blue")
lines(x, s[ , 2], col = "blue")
lines(x, s[ , 3], col = "blue")
</code></pre>

<hr>
<h2 id='update+2CKM-method'>Update a <code>KM</code> Object with New Points</h2><span id='topic+update+2CKM-method'></span>

<h3>Description</h3>

<p>The <code>update</code> method is used when new observations are added
to a fitted kriging model. Rather than fitting the model from
scratch with the updated observations added, the results of the
fit as stored in <code>object</code> are used to achieve some savings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KM'
update(
  object,
  newX,
  newy,
  newX.alreadyExist = FALSE,
  cov.reestim = TRUE,
  trend.reestim = cov.reestim,
  nugget.reestim = FALSE,
  newnoise.var = NULL,
  kmcontrol = NULL,
  newF = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CKM-method_+3A_object">object</code></td>
<td>
<p>A KM object.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_newx">newX</code></td>
<td>
<p>A numeric matrix containing the new design points. It
must have <code>object@d</code> columns in correspondence with those
of the design matrix used to fit the model which is stored as
<code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_newy">newy</code></td>
<td>
<p>A numeric vector of new response values, in
correspondence with the rows of <code>newX</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_newx.alreadyexist">newX.alreadyExist</code></td>
<td>
<p>Logical. If TRUE, <code>newX</code> can contain
some input points that are already in <code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_cov.reestim">cov.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector
<code>theta</code> of correlation ranges will be re-estimated using
the new observations as well as the observations already used
when fitting <code>object</code>. Only <code>TRUE</code> can be used for
now.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_trend.reestim">trend.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the vector
<code>beta</code> of trend coefficients will be re-estimated using
all the observations. Only <code>TRUE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_nugget.reestim">nugget.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the nugget effect
will be re-estimated using all the observations. Only
<code>FALSE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_newnoise.var">newnoise.var</code></td>
<td>
<p>Optional variance of an additional noise on
the new response.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_kmcontrol">kmcontrol</code></td>
<td>
<p>A list of options to tune the fit. Not available
yet.</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_newf">newF</code></td>
<td>
<p>New trend matrix. XXXY?</p>
</td></tr>
<tr><td><code id="update+2B2CKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>update</code> method for the class
<code>"KM"</code>, this would have been inherited from the class
<code>"km"</code>. The dedicated method is expected to run faster.  A
comparison can be made by coercing a <code>KM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>update</code>.
</p>


<h3>Value</h3>

<p>The updated <code>KM</code> object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.km">as.km</a></code> to coerce a <code>KM</code> object to the
class <code>"km"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X)
points(X, y, col = "blue")
KMobj &lt;- KM(design = X, response = y,covtype = "gauss")
x &lt;-  seq(from = 0, to = 1, length.out = 101)
p_x &lt;- predict(KMobj, x)
lines(x, p_x$mean, col = "blue")
lines(x, p_x$lower95, col = "blue")
lines(x, p_x$upper95, col = "blue")
newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX)
points(newX, newy, col = "red")

## replace the object by its udated version
KMobj &lt;- update(KMobj, newX=newX, newy=newy)

x &lt;- seq(from = 0, to = 1, length.out = 101)
p2_x &lt;- predict(KMobj, x)
lines(x, p2_x$mean, col = "red")
lines(x, p2_x$lower95, col = "red")
lines(x, p2_x$upper95, col = "red")

</code></pre>

<hr>
<h2 id='update+2CNoiseKM-method'>Update a <code>NoiseKM</code> Object with New Points</h2><span id='topic+update+2CNoiseKM-method'></span>

<h3>Description</h3>

<p>The <code>update</code> method is used when new observations are added
to a fitted kriging model. Rather than fitting the model from
scratch with the updated observations added, the results of the
fit as stored in <code>object</code> are used to achieve some savings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NoiseKM'
update(
  object,
  newX,
  newy,
  newnoise.var,
  newX.alreadyExist = FALSE,
  cov.reestim = TRUE,
  trend.reestim = cov.reestim,
  nugget.reestim = FALSE,
  kmcontrol = NULL,
  newF = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_object">object</code></td>
<td>
<p>A NoiseKM object.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_newx">newX</code></td>
<td>
<p>A numeric matrix containing the new design points. It
must have <code>object@d</code> columns in correspondence with those
of the design matrix used to fit the model which is stored as
<code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_newy">newy</code></td>
<td>
<p>A numeric vector of new response values, in
correspondence with the rows of <code>newX</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_newnoise.var">newnoise.var</code></td>
<td>
<p>Variance of an additional noise on
the new response.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_newx.alreadyexist">newX.alreadyExist</code></td>
<td>
<p>Logical. If TRUE, <code>newX</code> can contain
some input points that are already in <code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_cov.reestim">cov.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector
<code>theta</code> of correlation ranges will be re-estimated using
the new observations as well as the observations already used
when fitting <code>object</code>. Only <code>TRUE</code> can be used for
now.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_trend.reestim">trend.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the vector
<code>beta</code> of trend coefficients will be re-estimated using
all the observations. Only <code>TRUE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_nugget.reestim">nugget.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the nugget effect
will be re-estimated using all the observations. Only
<code>FALSE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_kmcontrol">kmcontrol</code></td>
<td>
<p>A list of options to tune the fit. Not available
yet.</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_newf">newF</code></td>
<td>
<p>New trend matrix. XXXY?</p>
</td></tr>
<tr><td><code id="update+2B2CNoiseKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>update</code> method for the class
<code>"NoiseKM"</code>, this would have been inherited from the class
<code>"km"</code>. The dedicated method is expected to run faster.  A
comparison can be made by coercing a <code>NoiseKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>update</code>.
</p>


<h3>Value</h3>

<p>The updated <code>NoiseKM</code> object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.km">as.km</a></code> to coerce a <code>NoiseKM</code> object to the
class <code>"km"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X) + 0.01*rnorm(nrow(X))
points(X, y, col = "blue")
KMobj &lt;- NoiseKM(design = X, response = y, noise=rep(0.01^2,5), covtype = "gauss")
x &lt;-  seq(from = 0, to = 1, length.out = 101)
p_x &lt;- predict(KMobj, x)
lines(x, p_x$mean, col = "blue")
lines(x, p_x$lower95, col = "blue")
lines(x, p_x$upper95, col = "blue")
newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX) + 0.01*rnorm(nrow(newX))
points(newX, newy, col = "red")

## replace the object by its udated version
KMobj &lt;- update(KMobj, newX=newX, newy=newy, newnoise.var=rep(0.01^2,3))

x &lt;- seq(from = 0, to = 1, length.out = 101)
p2_x &lt;- predict(KMobj, x)
lines(x, p2_x$mean, col = "red")
lines(x, p2_x$lower95, col = "red")
lines(x, p2_x$upper95, col = "red")

</code></pre>

<hr>
<h2 id='update+2CNuggetKM-method'>Update a <code>NuggetKM</code> Object with New Points</h2><span id='topic+update+2CNuggetKM-method'></span>

<h3>Description</h3>

<p>The <code>update</code> method is used when new observations are added
to a fitted kriging model. Rather than fitting the model from
scratch with the updated observations added, the results of the
fit as stored in <code>object</code> are used to achieve some savings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NuggetKM'
update(
  object,
  newX,
  newy,
  newX.alreadyExist = FALSE,
  cov.reestim = TRUE,
  trend.reestim = cov.reestim,
  nugget.reestim = FALSE,
  newnoise.var = NULL,
  kmcontrol = NULL,
  newF = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_object">object</code></td>
<td>
<p>A NuggetKM object.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_newx">newX</code></td>
<td>
<p>A numeric matrix containing the new design points. It
must have <code>object@d</code> columns in correspondence with those
of the design matrix used to fit the model which is stored as
<code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_newy">newy</code></td>
<td>
<p>A numeric vector of new response values, in
correspondence with the rows of <code>newX</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_newx.alreadyexist">newX.alreadyExist</code></td>
<td>
<p>Logical. If TRUE, <code>newX</code> can contain
some input points that are already in <code>object@X</code>.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_cov.reestim">cov.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the vector
<code>theta</code> of correlation ranges will be re-estimated using
the new observations as well as the observations already used
when fitting <code>object</code>. Only <code>TRUE</code> can be used for
now.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_trend.reestim">trend.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the vector
<code>beta</code> of trend coefficients will be re-estimated using
all the observations. Only <code>TRUE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_nugget.reestim">nugget.reestim</code></td>
<td>
<p>Logical. If <code>TRUE</code> the nugget effect
will be re-estimated using all the observations. Only
<code>FALSE</code> can be used for now.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_newnoise.var">newnoise.var</code></td>
<td>
<p>Optional variance of an additional noise on
the new response.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_kmcontrol">kmcontrol</code></td>
<td>
<p>A list of options to tune the fit. Not available
yet.</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_newf">newF</code></td>
<td>
<p>New trend matrix. XXXY?</p>
</td></tr>
<tr><td><code id="update+2B2CNuggetKM-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a dedicated <code>update</code> method for the class
<code>"NuggetKM"</code>, this would have been inherited from the class
<code>"km"</code>. The dedicated method is expected to run faster.  A
comparison can be made by coercing a <code>NuggetKM</code> object to a
<code>km</code> object with <code><a href="#topic+as.km">as.km</a></code> before calling
<code>update</code>.
</p>


<h3>Value</h3>

<p>The updated <code>NuggetKM</code> object.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.km">as.km</a></code> to coerce a <code>NuggetKM</code> object to the
class <code>"km"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1 - 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x) * x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(5))
y &lt;- f(X) + 0.01*rnorm(nrow(X))
points(X, y, col = "blue")
KMobj &lt;- NuggetKM(design = X, response = y,covtype = "gauss")
x &lt;-  seq(from = 0, to = 1, length.out = 101)
p_x &lt;- predict(KMobj, x)
lines(x, p_x$mean, col = "blue")
lines(x, p_x$lower95, col = "blue")
lines(x, p_x$upper95, col = "blue")
newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX) + 0.01*rnorm(nrow(newX))
points(newX, newy, col = "red")

## replace the object by its udated version
KMobj &lt;- update(KMobj, newX=newX, newy=newy)

x &lt;- seq(from = 0, to = 1, length.out = 101)
p2_x &lt;- predict(KMobj, x)
lines(x, p2_x$mean, col = "red")
lines(x, p2_x$lower95, col = "red")
lines(x, p2_x$upper95, col = "red")

</code></pre>

<hr>
<h2 id='update.Kriging'>Update a <code>Kriging</code> model object with new points</h2><span id='topic+update.Kriging'></span>

<h3>Description</h3>

<p>Update a <code>Kriging</code> model object with new points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kriging'
update(object, newy, newX, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.Kriging_+3A_object">object</code></td>
<td>
<p>S3 Kriging object.</p>
</td></tr>
<tr><td><code id="update.Kriging_+3A_newy">newy</code></td>
<td>
<p>Numeric vector of new responses (output).</p>
</td></tr>
<tr><td><code id="update.Kriging_+3A_newx">newX</code></td>
<td>
<p>Numeric matrix of new input points.</p>
</td></tr>
<tr><td><code id="update.Kriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Kriging object argument is modified.
</p>


<h3>Caution</h3>

<p>The method <em>does not return the updated
object</em>, but instead changes the content of
<code>object</code>. This behaviour is quite unusual in R and
differs from the behaviour of the methods
<code><a href="DiceKriging.html#topic+update.km">update.km</a></code> in <span class="pkg">DiceKriging</span> and
<code><a href="#topic+update+2CKM-method">update,KM-method</a></code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X)
points(X, y, col = "blue")

k &lt;- Kriging(y, X, "matern3_2")

x &lt;- seq(from = 0, to = 1, length.out = 101)
p &lt;- predict(k, x)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))

newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX)
points(newX, newy, col = "red")

## change the content of the object 'k'
update(k, newy, newX)

x &lt;- seq(from = 0, to = 1, length.out = 101)
p2 &lt;- predict(k, x)
lines(x, p2$mean, col = "red")
polygon(c(x, rev(x)), c(p2$mean - 2 * p2$stdev, rev(p2$mean + 2 * p2$stdev)),
 border = NA, col = rgb(1, 0, 0, 0.2))
</code></pre>

<hr>
<h2 id='update.NoiseKriging'>Update a <code>NoiseKriging</code> model object with new points</h2><span id='topic+update.NoiseKriging'></span>

<h3>Description</h3>

<p>Update a <code>NoiseKriging</code> model object with new points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoiseKriging'
update(object, newy, newnoise, newX, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.NoiseKriging_+3A_object">object</code></td>
<td>
<p>S3 NoiseKriging object.</p>
</td></tr>
<tr><td><code id="update.NoiseKriging_+3A_newy">newy</code></td>
<td>
<p>Numeric vector of new responses (output).</p>
</td></tr>
<tr><td><code id="update.NoiseKriging_+3A_newnoise">newnoise</code></td>
<td>
<p>Numeric vector of new noise variances (output).</p>
</td></tr>
<tr><td><code id="update.NoiseKriging_+3A_newx">newX</code></td>
<td>
<p>Numeric matrix of new input points.</p>
</td></tr>
<tr><td><code id="update.NoiseKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. NoiseKriging object argument is modified.
</p>


<h3>Caution</h3>

<p>The method <em>does not return the updated
object</em>, but instead changes the content of
<code>object</code>. This behaviour is quite unusual in R and
differs from the behaviour of the methods
<code><a href="DiceKriging.html#topic+update.km">update.km</a></code> in <span class="pkg">DiceKriging</span> and
<code><a href="#topic+update+2CKM-method">update,KM-method</a></code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + X/10 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NoiseKriging(y, (X/10)^2, X, "matern3_2")

x &lt;- seq(from = 0, to = 1, length.out = 101)
p &lt;- predict(k, x)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))

newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX) + 0.1 * rnorm(nrow(newX))
points(newX, newy, col = "red")

## change the content of the object 'k'
update(k, newy, rep(0.1^2,3), newX)

x &lt;- seq(from = 0, to = 1, length.out = 101)
p2 &lt;- predict(k, x)
lines(x, p2$mean, col = "red")
polygon(c(x, rev(x)), c(p2$mean - 2 * p2$stdev, rev(p2$mean + 2 * p2$stdev)),
 border = NA, col = rgb(1, 0, 0, 0.2))
</code></pre>

<hr>
<h2 id='update.NuggetKriging'>Update a <code>NuggetKriging</code> model object with new points</h2><span id='topic+update.NuggetKriging'></span>

<h3>Description</h3>

<p>Update a <code>NuggetKriging</code> model object with new points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NuggetKriging'
update(object, newy, newX, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.NuggetKriging_+3A_object">object</code></td>
<td>
<p>S3 NuggetKriging object.</p>
</td></tr>
<tr><td><code id="update.NuggetKriging_+3A_newy">newy</code></td>
<td>
<p>Numeric vector of new responses (output).</p>
</td></tr>
<tr><td><code id="update.NuggetKriging_+3A_newx">newX</code></td>
<td>
<p>Numeric matrix of new input points.</p>
</td></tr>
<tr><td><code id="update.NuggetKriging_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. NuggetKriging object argument is modified.
</p>


<h3>Caution</h3>

<p>The method <em>does not return the updated
object</em>, but instead changes the content of
<code>object</code>. This behaviour is quite unusual in R and
differs from the behaviour of the methods
<code><a href="DiceKriging.html#topic+update.km">update.km</a></code> in <span class="pkg">DiceKriging</span> and
<code><a href="#topic+update+2CKM-method">update,KM-method</a></code>.
</p>


<h3>Author(s)</h3>

<p>Yann Richet <a href="mailto:yann.richet@irsn.fr">yann.richet@irsn.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) 1- 1 / 2 * (sin(12 * x) / (1 + x) + 2 * cos(7 * x)*x^5 + 0.7)
plot(f)
set.seed(123)
X &lt;- as.matrix(runif(10))
y &lt;- f(X) + 0.1 * rnorm(nrow(X))
points(X, y, col = "blue")

k &lt;- NuggetKriging(y, X, "matern3_2")

## include design points to see interpolation
x &lt;- sort(c(X,seq(from = 0, to = 1, length.out = 101)))
p &lt;- predict(k, x)
lines(x, p$mean, col = "blue")
polygon(c(x, rev(x)), c(p$mean - 2 * p$stdev, rev(p$mean + 2 * p$stdev)),
 border = NA, col = rgb(0, 0, 1, 0.2))

newX &lt;- as.matrix(runif(3))
newy &lt;- f(newX) + 0.1 * rnorm(nrow(newX))
points(newX, newy, col = "red")

## change the content of the object 'k'
update(k, newy, newX)

## include design points to see interpolation
x &lt;- sort(c(X,newX,seq(from = 0, to = 1, length.out = 101)))
p2 &lt;- predict(k, x)
lines(x, p2$mean, col = "red")
polygon(c(x, rev(x)), c(p2$mean - 2 * p2$stdev, rev(p2$mean + 2 * p2$stdev)),
 border = NA, col = rgb(1, 0, 0, 0.2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
