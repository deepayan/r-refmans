<!DOCTYPE html><html><head><title>Help for package rstanarm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rstanarm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rstanarm-package'><p>Applied Regression Modeling via RStan</p></a></li>
<li><a href='#adapt_delta'><p><code>adapt_delta</code>: Target average acceptance probability</p></a></li>
<li><a href='#as.matrix.stanreg'><p>Extract the posterior sample</p></a></li>
<li><a href='#available-algorithms'><p>Estimation algorithms available for <span class="pkg">rstanarm</span> models</p></a></li>
<li><a href='#available-models'><p>Modeling functions available in <span class="pkg">rstanarm</span></p></a></li>
<li><a href='#bayes_R2.stanreg'><p>Compute a Bayesian version of R-squared or LOO-adjusted R-squared for</p>
regression models.</a></li>
<li><a href='#example_jm'><p>Example joint longitudinal and time-to-event model</p></a></li>
<li><a href='#example_model'><p>Example model</p></a></li>
<li><a href='#family.stanmvreg'><p>family method for stanmvreg objects</p></a></li>
<li><a href='#family.stanreg'><p>family method for stanreg objects</p></a></li>
<li><a href='#formula.stanreg'><p>formula method for stanreg objects</p></a></li>
<li><a href='#get_y'><p>Extract X, Y or Z from a stanreg object</p></a></li>
<li><a href='#kfold.stanreg'><p>K-fold cross-validation</p></a></li>
<li><a href='#launch_shinystan.stanreg'><p>Using the ShinyStan GUI with rstanarm models</p></a></li>
<li><a href='#log_lik.stanreg'><p>Pointwise log-likelihood matrix</p></a></li>
<li><a href='#logit'><p>Logit and inverse logit</p></a></li>
<li><a href='#loo_predict.stanreg'><p>Compute weighted expectations using LOO</p></a></li>
<li><a href='#loo.stanreg'><p>Information criteria and cross-validation</p></a></li>
<li><a href='#model.frame.stanmvreg'><p>model.frame method for stanmvreg objects</p></a></li>
<li><a href='#model.frame.stanreg'><p>model.frame method for stanreg objects</p></a></li>
<li><a href='#model.matrix.stanreg'><p>model.matrix method for stanreg objects</p></a></li>
<li><a href='#neg_binomial_2'><p>Family function for negative binomial GLMs</p></a></li>
<li><a href='#nobs.stanmvreg'><p>Methods for stanreg objects</p></a></li>
<li><a href='#pairs.stanreg'><p>Pairs method for stanreg objects</p></a></li>
<li><a href='#plot.predict.stanjm'><p>Plot the estimated subject-specific or marginal longitudinal trajectory</p></a></li>
<li><a href='#plot.stanreg'><p>Plot method for stanreg objects</p></a></li>
<li><a href='#plot.survfit.stanjm'><p>Plot the estimated subject-specific or marginal survival function</p></a></li>
<li><a href='#posterior_interval.stanreg'><p>Posterior uncertainty intervals</p></a></li>
<li><a href='#posterior_linpred.stanreg'><p>Posterior distribution of the (possibly transformed) linear predictor</p></a></li>
<li><a href='#posterior_predict.stanreg'><p>Draw from posterior predictive distribution</p></a></li>
<li><a href='#posterior_survfit'><p>Estimate subject-specific or standardised survival probabilities</p></a></li>
<li><a href='#posterior_traj'><p>Estimate the subject-specific or marginal longitudinal trajectory</p></a></li>
<li><a href='#posterior_vs_prior'><p>Juxtapose prior and posterior</p></a></li>
<li><a href='#pp_check.stanreg'><p>Graphical posterior predictive checks</p></a></li>
<li><a href='#pp_validate'><p>Model validation via simulation</p></a></li>
<li><a href='#predict.stanreg'><p>Predict method for stanreg objects</p></a></li>
<li><a href='#predictive_error.stanreg'><p>In-sample or out-of-sample predictive errors</p></a></li>
<li><a href='#predictive_interval.stanreg'><p>Predictive intervals</p></a></li>
<li><a href='#print.stanreg'><p>Print method for stanreg objects</p></a></li>
<li><a href='#print.survfit.stanjm'><p>Generic print method for <code>survfit.stanjm</code> objects</p></a></li>
<li><a href='#prior_summary.stanreg'><p>Summarize the priors used for an rstanarm model</p></a></li>
<li><a href='#priors'><p>Prior distributions and options</p></a></li>
<li><a href='#ps_check'><p>Graphical checks of the estimated survival function</p></a></li>
<li><a href='#QR-argument'><p>The <code>QR</code> argument</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rstanarm-datasets'><p>Datasets for rstanarm examples</p></a></li>
<li><a href='#rstanarm-deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#se'><p>Extract standard errors</p></a></li>
<li><a href='#stan_aov'><p>Bayesian regularized linear models via Stan</p></a></li>
<li><a href='#stan_betareg'><p>Bayesian beta regression models via Stan</p></a></li>
<li><a href='#stan_biglm'><p>Bayesian regularized linear but big models via Stan</p></a></li>
<li><a href='#stan_clogit'><p>Conditional logistic (clogit) regression models via Stan</p></a></li>
<li><a href='#stan_gamm4'><p>Bayesian generalized linear additive models with optional group-specific</p>
terms via Stan</a></li>
<li><a href='#stan_glm'><p>Bayesian generalized linear models via Stan</p></a></li>
<li><a href='#stan_glmer'><p>Bayesian generalized linear models with group-specific terms via Stan</p></a></li>
<li><a href='#stan_jm'><p>Bayesian joint longitudinal and time-to-event models via Stan</p></a></li>
<li><a href='#stan_mvmer'><p>Bayesian multivariate generalized linear models with correlated</p>
group-specific terms via Stan</a></li>
<li><a href='#stan_nlmer'><p>Bayesian nonlinear models with group-specific terms via Stan</p></a></li>
<li><a href='#stan_polr'><p>Bayesian ordinal regression models via Stan</p></a></li>
<li><a href='#stanmvreg-methods'><p>Methods for stanmvreg objects</p></a></li>
<li><a href='#stanreg_list'><p>Create lists of fitted model objects, combine them, or append new models to</p>
existing lists of models.</a></li>
<li><a href='#stanreg-draws-formats'><p>Create a <code>draws</code> object from a <code>stanreg</code> object</p></a></li>
<li><a href='#stanreg-objects'><p>Fitted model objects</p></a></li>
<li><a href='#summary.stanreg'><p>Summary method for stanreg objects</p></a></li>
<li><a href='#terms.stanmvreg'><p>terms method for stanmvreg objects</p></a></li>
<li><a href='#terms.stanreg'><p>terms method for stanreg objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Applied Regression Modeling via Stan</td>
</tr>
<tr>
<td>Version:</td>
<td>2.32.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-15</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates previously compiled regression models using the 'rstan'
    package, which provides the R interface to the Stan C++ library for Bayesian
    estimation. Users specify models via the customary R syntax with a formula and
    data.frame plus some additional arguments for priors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 0.12.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayesplot (&ge; 1.7.0), ggplot2 (&ge; 2.2.1), lme4 (&ge; 1.1-8), loo
(&ge; 2.1.0), Matrix (&ge; 1.2-13), nlme (&ge; 3.1-124), posterior,
rstan (&ge; 2.32.0), rstantools (&ge; 2.1.0), shinystan (&ge; 2.3.0),
stats, survival (&ge; 2.40.1), RcppParallel (&ge; 5.0.1), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>biglm, betareg, data.table (&ge; 1.10.0), digest, gridExtra,
HSAUR3, knitr (&ge; 1.15.1), MASS, mgcv (&ge; 1.8-13), rmarkdown,
roxygen2, StanHeaders (&ge; 2.21.0), testthat (&ge; 1.0.2), gamm4,
shiny, V8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.32.0), rstan (&ge; 2.32.0), BH (&ge;
1.72.0-2), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc (&gt;= 1.12.3), pandoc-citeproc</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>UseLTO:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/rstanarm/">https://mc-stan.org/rstanarm/</a>, <a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stan-dev/rstanarm/issues">https://github.com/stan-dev/rstanarm/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 19:07:49 UTC; ben</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonah Gabry [aut],
  Imad Ali [ctb],
  Sam Brilleman [ctb],
  Jacqueline Buros Novik [ctb] (R/stan_jm.R),
  AstraZeneca [ctb] (R/stan_jm.R),
  Trustees of Columbia University [cph],
  Simon Wood [cph] (R/stan_gamm4.R),
  R Core Deveopment Team [cph] (R/stan_aov.R),
  Douglas Bates [cph] (R/pp_data.R),
  Martin Maechler [cph] (R/pp_data.R),
  Ben Bolker [cph] (R/pp_data.R),
  Steve Walker [cph] (R/pp_data.R),
  Brian Ripley [cph] (R/stan_aov.R, R/stan_polr.R),
  William Venables [cph] (R/stan_polr.R),
  Paul-Christian Burkner [cph] (R/misc.R),
  Ben Goodrich [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Goodrich &lt;benjamin.goodrich@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 23:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='rstanarm-package'>Applied Regression Modeling via RStan</h2><span id='topic+rstanarm-package'></span><span id='topic+rstanarm'></span>

<h3>Description</h3>


<p><img src="../help/figures/stanlogo.png" width="50" alt="https://mc-stan.org/about/logo/" />
<em>Stan Development Team</em>

</p>
<p>The <span class="pkg">rstanarm</span> package is an appendage to the <span class="pkg">rstan</span> package that
enables many of the most common applied regression models to be estimated
using Markov Chain Monte Carlo, variational approximations to the posterior
distribution, or optimization. The <span class="pkg">rstanarm</span> package allows these models
to be specified using the customary R modeling syntax (e.g., like that of
<code><a href="stats.html#topic+glm">glm</a></code> with a <code>formula</code> and a <code>data.frame</code>).
</p>
<p>The sections below provide an overview of the modeling functions and
estimation algorithms used by <span class="pkg">rstanarm</span>.
</p>


<h3>Details</h3>

<p>The set of models supported by <span class="pkg">rstanarm</span> is large (and will continue to
grow), but also limited enough so that it is possible to integrate them
tightly with the <code><a href="#topic+pp_check">pp_check</a></code> function for graphical posterior
predictive checks with <span class="pkg"><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></span> and the
<code><a href="#topic+posterior_predict">posterior_predict</a></code> function to easily estimate the effect of
specific manipulations of predictor variables or to predict the outcome in a
training set.
</p>
<p>The objects returned by the <span class="pkg">rstanarm</span> modeling functions are called
<code><a href="#topic+stanreg-objects">stanreg</a></code> objects. In addition to all of the
typical <code><a href="#topic+stanreg-methods">methods</a></code> defined for fitted model
objects, stanreg objects can be passed to the <code><a href="loo.html#topic+loo">loo</a></code> function
in the <span class="pkg">loo</span> package for model comparison or to the
<code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code> function in the <span class="pkg">shinystan</span>
package in order to visualize the posterior distribution using the ShinyStan
graphical user interface. See the <span class="pkg">rstanarm</span> vignettes for more details
about the entire process.
</p>


<h3>Prior distributions</h3>

<p>See <a href="#topic+priors">priors help page</a> and the vignette
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior Distributions for rstanarm Models</em></a>
for an overview of the various choices the user can make for prior
distributions. The package vignettes for the modeling functions also provide
examples of using many of the available priors as well as more detailed
descriptions of some of the novel priors used by <span class="pkg">rstanarm</span>.
</p>


<h3>Modeling functions</h3>

<p>The model estimating functions are described in greater detail in their
individual help pages and vignettes. Here we provide a very brief
overview:
</p>

<dl>
<dt><code><a href="#topic+stan_lm">stan_lm</a></code>, <code>stan_aov</code>, <code>stan_biglm</code></dt><dd>
<p>Similar to <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+aov">aov</a></code> but with
novel regularizing priors on the model parameters that are driven by prior
beliefs about <code class="reqn">R^2</code>, the proportion of variance in the outcome
attributable to the predictors in a linear model.
</p>
</dd>
<dt><code><a href="#topic+stan_glm">stan_glm</a></code>, <code>stan_glm.nb</code></dt><dd>
<p>Similar to <code><a href="stats.html#topic+glm">glm</a></code> but with various possible prior
distributions for the coefficients and, if applicable, a prior distribution
for any auxiliary parameter in a Generalized Linear Model (GLM) that is
characterized by a <code><a href="stats.html#topic+family">family</a></code> object (e.g. the shape
parameter in Gamma models). It is also possible to estimate a negative
binomial model in a similar way to the <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> function
in the <span class="pkg">MASS</span> package.
</p>
</dd>
<dt><code><a href="#topic+stan_glmer">stan_glmer</a></code>, <code>stan_glmer.nb</code>, <code>stan_lmer</code></dt><dd>
<p>Similar to the <code><a href="lme4.html#topic+glmer">glmer</a></code>, <code><a href="lme4.html#topic+glmer.nb">glmer.nb</a></code> and
<code><a href="lme4.html#topic+lmer">lmer</a></code> functions in the <span class="pkg">lme4</span> package in that GLMs
are augmented to have group-specific terms that deviate from the common
coefficients according to a mean-zero multivariate normal distribution with
a highly-structured but unknown covariance matrix (for which <span class="pkg">rstanarm</span>
introduces an innovative prior distribution). MCMC provides more
appropriate estimates of uncertainty for models that consist of a mix of
common and group-specific parameters.
</p>
</dd>
<dt><code><a href="#topic+stan_nlmer">stan_nlmer</a></code></dt><dd>
<p>Similar to <code><a href="lme4.html#topic+nlmer">nlmer</a></code> in the <span class="pkg">lme4</span> package for 
nonlinear &quot;mixed-effects&quot; models, but the group-specific coefficients 
have flexible priors on their unknown covariance matrices.
</p>
</dd>
<dt><code><a href="#topic+stan_gamm4">stan_gamm4</a></code></dt><dd>
<p>Similar to <code><a href="gamm4.html#topic+gamm4">gamm4</a></code> in the <span class="pkg">gamm4</span> package, which
augments a GLM (possibly with group-specific terms) with nonlinear smooth
functions of the predictors to form a Generalized Additive Mixed Model
(GAMM). Rather than calling <code><a href="lme4.html#topic+glmer">glmer</a></code> like
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code> does, <code><a href="#topic+stan_gamm4">stan_gamm4</a></code> essentially calls
<code><a href="#topic+stan_glmer">stan_glmer</a></code>, which avoids the optimization issues that often
crop up with GAMMs and provides better estimates for the uncertainty of the
parameter estimates.
</p>
</dd>
<dt><code><a href="#topic+stan_polr">stan_polr</a></code></dt><dd>
<p>Similar to <code><a href="MASS.html#topic+polr">polr</a></code> in the <span class="pkg">MASS</span> package in that it
models an ordinal response, but the Bayesian model also implies a prior
distribution on the unknown cutpoints. Can also be used to model binary
outcomes, possibly while estimating an unknown exponent governing the
probability of success.
</p>
</dd>
<dt><code><a href="#topic+stan_betareg">stan_betareg</a></code></dt><dd>
<p>Similar to <code><a href="betareg.html#topic+betareg">betareg</a></code> in that it models an outcome that
is a rate (proportion) but, rather than performing maximum likelihood
estimation, full Bayesian estimation is performed by default, with
customizable prior distributions for all parameters.
</p>
</dd>
<dt><code><a href="#topic+stan_clogit">stan_clogit</a></code></dt><dd>
<p>Similar to <code><a href="survival.html#topic+clogit">clogit</a></code> in that it models an binary outcome
where the number of successes and failures is fixed within each stratum by
the research design. There are some minor syntactical differences relative
to <code><a href="survival.html#topic+clogit">clogit</a></code> that allow <code>stan_clogit</code> to accept
group-specific terms as in <code><a href="#topic+stan_glmer">stan_glmer</a></code>.
</p>
</dd>
<dt><code><a href="#topic+stan_mvmer">stan_mvmer</a></code></dt><dd>
<p>A multivariate form of <code><a href="#topic+stan_glmer">stan_glmer</a></code>, whereby the user can
specify one or more submodels each consisting of a GLM with group-specific 
terms. If more than one submodel is specified (i.e. there is more than one
outcome variable) then a dependence is induced by assuming that the
group-specific terms for each grouping factor are correlated across submodels. 
</p>
</dd>
<dt><code><a href="#topic+stan_jm">stan_jm</a></code></dt><dd>
<p>Estimates shared parameter joint models for longitudinal and time-to-event 
(i.e. survival) data. The joint model can be univariate (i.e. one longitudinal 
outcome) or multivariate (i.e. more than one longitudinal outcome). A variety 
of parameterisations are available for linking the longitudinal and event 
processes (i.e. a variety of association structures).      
</p>
</dd>
</dl>



<h3>Estimation algorithms</h3>

<p>The modeling functions in the <span class="pkg">rstanarm</span> package take an <code>algorithm</code>
argument that can be one of the following:
</p>

<dl>
<dt><strong>Sampling</strong> (<code>algorithm="sampling"</code>)</dt><dd>
<p>Uses Markov Chain Monte Carlo (MCMC) &mdash; in particular, Hamiltonian Monte
Carlo (HMC) with a tuned but diagonal mass matrix &mdash; to draw from the
posterior distribution of the parameters. See <code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>
(<span class="pkg">rstan</span>) for more details. This is the slowest but most reliable of the
available estimation algorithms and it is <strong>the default and
recommended algorithm for statistical inference.</strong>
</p>
</dd>
<dt><strong>Mean-field</strong> (<code>algorithm="meanfield"</code>)</dt><dd>
<p>Uses mean-field variational inference to draw from an approximation to the
posterior distribution. In particular, this algorithm finds the set of
independent normal distributions in the unconstrained space that &mdash; when
transformed into the constrained space &mdash; most closely approximate the
posterior distribution. Then it draws repeatedly from these independent
normal distributions and transforms them into the constrained space. The
entire process is much faster than HMC and yields independent draws but
<strong>is not recommended for final statistical inference</strong>. It can be
useful to narrow the set of candidate models in large problems, particularly
when specifying <code>QR=TRUE</code> in <code><a href="#topic+stan_glm">stan_glm</a></code>,
<code><a href="#topic+stan_glmer">stan_glmer</a></code>, and <code><a href="#topic+stan_gamm4">stan_gamm4</a></code>, but is <strong>only
an approximation to the posterior distribution</strong>.
</p>
</dd>
<dt><strong>Full-rank</strong> (<code>algorithm="fullrank"</code>)</dt><dd>
<p>Uses full-rank variational inference to draw from an approximation to the
posterior distribution by finding the multivariate normal distribution in
the unconstrained space that &mdash; when transformed into the constrained space
&mdash; most closely approximates the posterior distribution. Then it draws
repeatedly from this multivariate normal distribution and transforms the
draws into the constrained space. This process is slower than meanfield
variational inference but is faster than HMC. Although still an
approximation to the posterior distribution and thus <strong>not recommended
for final statistical inference</strong>, the approximation is more realistic than
that of mean-field variational inference because the parameters are not
assumed to be independent in the unconstrained space. Nevertheless, fullrank
variational inference is a more difficult optimization problem and the
algorithm is more prone to non-convergence or convergence to a local
optimum.
</p>
</dd>
<dt><strong>Optimizing</strong> (<code>algorithm="optimizing"</code>)</dt><dd>
<p>Finds the posterior mode using a C++ implementation of the LBGFS algorithm.
See <code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code> for more details. If there is no prior
information, then this is equivalent to maximum likelihood, in which case
there is no great reason to use the functions in the <span class="pkg">rstanarm</span> package
over the emulated functions in other packages. However, if priors are
specified, then the estimates are penalized maximum likelihood estimates,
which may have some redeeming value. Currently, optimization is only
supported for <code><a href="#topic+stan_glm">stan_glm</a></code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Bates, D., Maechler, M., Bolker, B., and Walker, S. (2015). Fitting linear 
mixed-Effects models using lme4. <em>Journal of Statistical Software</em>.
67(1), 1&ndash;48.
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. <a href="https://stat.columbia.edu/~gelman/book/">https://stat.columbia.edu/~gelman/book/</a>
</p>
<p>Gelman, A. and Hill, J. (2007). <em>Data Analysis Using
Regression and Multilevel/Hierarchical Models.</em> Cambridge University Press,
Cambridge, UK. <a href="https://stat.columbia.edu/~gelman/arm/">https://stat.columbia.edu/~gelman/arm/</a>
</p>
<p>Stan Development Team. <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4. arXiv preprint:
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>
</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018) Using
stacking to average Bayesian predictive distributions. <em>Bayesian
Analysis</em>, advance publication,  <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>
<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Muth, C., Oravecz, Z., and Gabry, J. (2018)
User-friendly Bayesian regression modeling: A tutorial with rstanarm and shinystan.
<em>The Quantitative Methods for Psychology</em>. 14(2), 99&ndash;119.
<a href="https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf">https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://mc-stan.org/">https://mc-stan.org/</a> for more information on the Stan C++
package used by <span class="pkg">rstanarm</span> for model fitting.
</p>
</li>
<li> <p><a href="https://github.com/stan-dev/rstanarm/issues/">https://github.com/stan-dev/rstanarm/issues/</a> to submit a bug
report or feature request.
</p>
</li>
<li> <p><a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a> to ask a
question about <span class="pkg">rstanarm</span> on the Stan-users forum.
</p>
</li></ul>


<hr>
<h2 id='adapt_delta'><code>adapt_delta</code>: Target average acceptance probability</h2><span id='topic+adapt_delta'></span>

<h3>Description</h3>

<p>Details about the <code>adapt_delta</code> argument to <span class="pkg">rstanarm</span>'s modeling
functions.
</p>


<h3>Details</h3>

<p>For the No-U-Turn Sampler (NUTS), the variant of Hamiltonian Monte
Carlo used used by <span class="pkg">rstanarm</span>, <code>adapt_delta</code> is the target average
proposal acceptance probability during Stan's adaptation period.
<code>adapt_delta</code> is ignored by <span class="pkg">rstanarm</span> if the <code>algorithm</code> argument 
is not set to <code>"sampling"</code>.
</p>
<p>The default value of <code>adapt_delta</code> is 0.95, except when the prior for 
the regression coefficients is <code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+hs">hs</a></code>, or 
<code><a href="#topic+hs_plus">hs_plus</a></code>, in which case the default is 0.99.
</p>
<p>These defaults are higher (more conservative) than the default of
<code>adapt_delta=0.8</code> used in the <span class="pkg">rstan</span> package, which may result in
slower sampling speeds but will be more robust to posterior distributions
with high curvature.
</p>
<p>In general you should not need to change <code>adapt_delta</code> unless you see
a warning message about divergent transitions, in which case you can
increase <code>adapt_delta</code> from the default to a value <em>closer</em> to 1
(e.g. from 0.95 to 0.99, or from 0.99 to 0.999, etc). The step size used by
the numerical integrator is a function of <code>adapt_delta</code> in that
increasing <code>adapt_delta</code> will result in a smaller step size and fewer
divergences. Increasing <code>adapt_delta</code> will typically result in a
slower sampler, but it will always lead to a more robust sampler.
</p>


<h3>References</h3>

<p>Stan Development Team. <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>
<p>Brief Guide to Stan's Warnings:
<a href="https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup">https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup</a>
</p>

<hr>
<h2 id='as.matrix.stanreg'>Extract the posterior sample</h2><span id='topic+as.matrix.stanreg'></span><span id='topic+as.array.stanreg'></span><span id='topic+as.data.frame.stanreg'></span>

<h3>Description</h3>

<p>For models fit using MCMC (<code>algorithm="sampling"</code>), the posterior sample
&mdash;the post-warmup draws from the posterior distribution&mdash; can be extracted 
from a fitted model object as a matrix, data frame, or array. The 
<code>as.matrix</code> and <code>as.data.frame</code> methods merge all chains together, 
whereas the <code>as.array</code> method keeps the chains separate. For models fit 
using optimization (<code>"optimizing"</code>) or variational inference 
(<code>"meanfield"</code> or <code>"fullrank"</code>), there is no posterior sample but 
rather a matrix (or data frame) of 1000 draws from either the asymptotic
multivariate Gaussian sampling distribution of the parameters or the
variational approximation to the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
as.matrix(x, ..., pars = NULL, regex_pars = NULL)

## S3 method for class 'stanreg'
as.array(x, ..., pars = NULL, regex_pars = NULL)

## S3 method for class 'stanreg'
as.data.frame(x, ..., pars = NULL, regex_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.stanreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="as.matrix.stanreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.matrix.stanreg_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.</p>
</td></tr>
<tr><td><code id="as.matrix.stanreg_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, data.frame, or array, the dimensions of which depend on
<code>pars</code> and <code>regex_pars</code>, as well as the model and estimation
algorithm (see the Description section above).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-draws-formats">stanreg-draws-formats</a></code>, <code><a href="#topic+stanreg-methods">stanreg-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

if (!exists("example_model")) example(example_model)
# Extract posterior sample after MCMC
draws &lt;- as.matrix(example_model)
print(dim(draws))

# For example, we can see that the median of the draws for the intercept 
# is the same as the point estimate rstanarm uses
print(median(draws[, "(Intercept)"]))
print(example_model$coefficients[["(Intercept)"]])

# The as.array method keeps the chains separate
draws_array &lt;- as.array(example_model)
print(dim(draws_array)) # iterations x chains x parameters

# Extract draws from asymptotic Gaussian sampling distribution 
# after optimization
fit &lt;- stan_glm(mpg ~ wt, data = mtcars, algorithm = "optimizing")
draws &lt;- as.data.frame(fit)
print(colnames(draws))
print(nrow(draws)) # 1000 draws are taken

# Extract draws from variational approximation to the posterior distribution
fit2 &lt;- update(fit, algorithm = "meanfield")
draws &lt;- as.data.frame(fit2, pars = "wt")
print(colnames(draws))
print(nrow(draws)) # 1000 draws are taken

}
</code></pre>

<hr>
<h2 id='available-algorithms'>Estimation algorithms available for <span class="pkg">rstanarm</span> models</h2><span id='topic+available-algorithms'></span>

<h3>Description</h3>

<p>Estimation algorithms available for <span class="pkg">rstanarm</span> models
</p>


<h3>Estimation algorithms</h3>

<p>The modeling functions in the <span class="pkg">rstanarm</span> package take an <code>algorithm</code>
argument that can be one of the following:
</p>

<dl>
<dt><strong>Sampling</strong> (<code>algorithm="sampling"</code>)</dt><dd>
<p>Uses Markov Chain Monte Carlo (MCMC) &mdash; in particular, Hamiltonian Monte
Carlo (HMC) with a tuned but diagonal mass matrix &mdash; to draw from the
posterior distribution of the parameters. See <code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>
(<span class="pkg">rstan</span>) for more details. This is the slowest but most reliable of the
available estimation algorithms and it is <strong>the default and
recommended algorithm for statistical inference.</strong>
</p>
</dd>
<dt><strong>Mean-field</strong> (<code>algorithm="meanfield"</code>)</dt><dd>
<p>Uses mean-field variational inference to draw from an approximation to the
posterior distribution. In particular, this algorithm finds the set of
independent normal distributions in the unconstrained space that &mdash; when
transformed into the constrained space &mdash; most closely approximate the
posterior distribution. Then it draws repeatedly from these independent
normal distributions and transforms them into the constrained space. The
entire process is much faster than HMC and yields independent draws but
<strong>is not recommended for final statistical inference</strong>. It can be
useful to narrow the set of candidate models in large problems, particularly
when specifying <code>QR=TRUE</code> in <code><a href="#topic+stan_glm">stan_glm</a></code>,
<code><a href="#topic+stan_glmer">stan_glmer</a></code>, and <code><a href="#topic+stan_gamm4">stan_gamm4</a></code>, but is <strong>only
an approximation to the posterior distribution</strong>.
</p>
</dd>
<dt><strong>Full-rank</strong> (<code>algorithm="fullrank"</code>)</dt><dd>
<p>Uses full-rank variational inference to draw from an approximation to the
posterior distribution by finding the multivariate normal distribution in
the unconstrained space that &mdash; when transformed into the constrained space
&mdash; most closely approximates the posterior distribution. Then it draws
repeatedly from this multivariate normal distribution and transforms the
draws into the constrained space. This process is slower than meanfield
variational inference but is faster than HMC. Although still an
approximation to the posterior distribution and thus <strong>not recommended
for final statistical inference</strong>, the approximation is more realistic than
that of mean-field variational inference because the parameters are not
assumed to be independent in the unconstrained space. Nevertheless, fullrank
variational inference is a more difficult optimization problem and the
algorithm is more prone to non-convergence or convergence to a local
optimum.
</p>
</dd>
<dt><strong>Optimizing</strong> (<code>algorithm="optimizing"</code>)</dt><dd>
<p>Finds the posterior mode using a C++ implementation of the LBGFS algorithm.
See <code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code> for more details. If there is no prior
information, then this is equivalent to maximum likelihood, in which case
there is no great reason to use the functions in the <span class="pkg">rstanarm</span> package
over the emulated functions in other packages. However, if priors are
specified, then the estimates are penalized maximum likelihood estimates,
which may have some redeeming value. Currently, optimization is only
supported for <code><a href="#topic+stan_glm">stan_glm</a></code>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="https://mc-stan.org/rstanarm/">https://mc-stan.org/rstanarm/</a>
</p>

<hr>
<h2 id='available-models'>Modeling functions available in <span class="pkg">rstanarm</span></h2><span id='topic+available-models'></span>

<h3>Description</h3>

<p>Modeling functions available in <span class="pkg">rstanarm</span>
</p>


<h3>Modeling functions</h3>

<p>The model estimating functions are described in greater detail in their
individual help pages and vignettes. Here we provide a very brief
overview:
</p>

<dl>
<dt><code><a href="#topic+stan_lm">stan_lm</a></code>, <code>stan_aov</code>, <code>stan_biglm</code></dt><dd>
<p>Similar to <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+aov">aov</a></code> but with
novel regularizing priors on the model parameters that are driven by prior
beliefs about <code class="reqn">R^2</code>, the proportion of variance in the outcome
attributable to the predictors in a linear model.
</p>
</dd>
<dt><code><a href="#topic+stan_glm">stan_glm</a></code>, <code>stan_glm.nb</code></dt><dd>
<p>Similar to <code><a href="stats.html#topic+glm">glm</a></code> but with various possible prior
distributions for the coefficients and, if applicable, a prior distribution
for any auxiliary parameter in a Generalized Linear Model (GLM) that is
characterized by a <code><a href="stats.html#topic+family">family</a></code> object (e.g. the shape
parameter in Gamma models). It is also possible to estimate a negative
binomial model in a similar way to the <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> function
in the <span class="pkg">MASS</span> package.
</p>
</dd>
<dt><code><a href="#topic+stan_glmer">stan_glmer</a></code>, <code>stan_glmer.nb</code>, <code>stan_lmer</code></dt><dd>
<p>Similar to the <code><a href="lme4.html#topic+glmer">glmer</a></code>, <code><a href="lme4.html#topic+glmer.nb">glmer.nb</a></code> and
<code><a href="lme4.html#topic+lmer">lmer</a></code> functions in the <span class="pkg">lme4</span> package in that GLMs
are augmented to have group-specific terms that deviate from the common
coefficients according to a mean-zero multivariate normal distribution with
a highly-structured but unknown covariance matrix (for which <span class="pkg">rstanarm</span>
introduces an innovative prior distribution). MCMC provides more
appropriate estimates of uncertainty for models that consist of a mix of
common and group-specific parameters.
</p>
</dd>
<dt><code><a href="#topic+stan_nlmer">stan_nlmer</a></code></dt><dd>
<p>Similar to <code><a href="lme4.html#topic+nlmer">nlmer</a></code> in the <span class="pkg">lme4</span> package for 
nonlinear &quot;mixed-effects&quot; models, but the group-specific coefficients 
have flexible priors on their unknown covariance matrices.
</p>
</dd>
<dt><code><a href="#topic+stan_gamm4">stan_gamm4</a></code></dt><dd>
<p>Similar to <code><a href="gamm4.html#topic+gamm4">gamm4</a></code> in the <span class="pkg">gamm4</span> package, which
augments a GLM (possibly with group-specific terms) with nonlinear smooth
functions of the predictors to form a Generalized Additive Mixed Model
(GAMM). Rather than calling <code><a href="lme4.html#topic+glmer">glmer</a></code> like
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code> does, <code><a href="#topic+stan_gamm4">stan_gamm4</a></code> essentially calls
<code><a href="#topic+stan_glmer">stan_glmer</a></code>, which avoids the optimization issues that often
crop up with GAMMs and provides better estimates for the uncertainty of the
parameter estimates.
</p>
</dd>
<dt><code><a href="#topic+stan_polr">stan_polr</a></code></dt><dd>
<p>Similar to <code><a href="MASS.html#topic+polr">polr</a></code> in the <span class="pkg">MASS</span> package in that it
models an ordinal response, but the Bayesian model also implies a prior
distribution on the unknown cutpoints. Can also be used to model binary
outcomes, possibly while estimating an unknown exponent governing the
probability of success.
</p>
</dd>
<dt><code><a href="#topic+stan_betareg">stan_betareg</a></code></dt><dd>
<p>Similar to <code><a href="betareg.html#topic+betareg">betareg</a></code> in that it models an outcome that
is a rate (proportion) but, rather than performing maximum likelihood
estimation, full Bayesian estimation is performed by default, with
customizable prior distributions for all parameters.
</p>
</dd>
<dt><code><a href="#topic+stan_clogit">stan_clogit</a></code></dt><dd>
<p>Similar to <code><a href="survival.html#topic+clogit">clogit</a></code> in that it models an binary outcome
where the number of successes and failures is fixed within each stratum by
the research design. There are some minor syntactical differences relative
to <code><a href="survival.html#topic+clogit">clogit</a></code> that allow <code>stan_clogit</code> to accept
group-specific terms as in <code><a href="#topic+stan_glmer">stan_glmer</a></code>.
</p>
</dd>
<dt><code><a href="#topic+stan_mvmer">stan_mvmer</a></code></dt><dd>
<p>A multivariate form of <code><a href="#topic+stan_glmer">stan_glmer</a></code>, whereby the user can
specify one or more submodels each consisting of a GLM with group-specific 
terms. If more than one submodel is specified (i.e. there is more than one
outcome variable) then a dependence is induced by assuming that the
group-specific terms for each grouping factor are correlated across submodels. 
</p>
</dd>
<dt><code><a href="#topic+stan_jm">stan_jm</a></code></dt><dd>
<p>Estimates shared parameter joint models for longitudinal and time-to-event 
(i.e. survival) data. The joint model can be univariate (i.e. one longitudinal 
outcome) or multivariate (i.e. more than one longitudinal outcome). A variety 
of parameterisations are available for linking the longitudinal and event 
processes (i.e. a variety of association structures).      
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="https://mc-stan.org/rstanarm/">https://mc-stan.org/rstanarm/</a>
</p>

<hr>
<h2 id='bayes_R2.stanreg'>Compute a Bayesian version of R-squared or LOO-adjusted R-squared for
regression models.</h2><span id='topic+bayes_R2.stanreg'></span><span id='topic+bayes_R2'></span><span id='topic+loo_R2.stanreg'></span><span id='topic+loo_R2'></span>

<h3>Description</h3>

<p>Compute a Bayesian version of R-squared or LOO-adjusted R-squared for
regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
bayes_R2(object, ..., re.form = NULL)

## S3 method for class 'stanreg'
loo_R2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_R2.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_R2.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="bayes_R2.stanreg_+3A_re.form">re.form</code></td>
<td>
<p>For models with group-level terms, <code>re.form</code> is
passed to <code><a href="#topic+posterior_epred">posterior_epred</a></code> if specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of R-squared values with length equal to the posterior
sample size (the posterior distribution of R-squared).
</p>


<h3>References</h3>

<p>Andrew Gelman, Ben Goodrich, Jonah Gabry, and Aki Vehtari (2018). R-squared
for Bayesian regression models. <em>The American Statistician</em>, to appear.
<a href="https://doi.org/10.1080/00031305.2018.1549100">doi:10.1080/00031305.2018.1549100</a>
(<a href="http://www.stat.columbia.edu/~gelman/research/published/bayes_R2_v3.pdf">Preprint</a>,
<a href="https://avehtari.github.io/bayes_R2/bayes_R2.html">Notebook</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
fit &lt;- stan_glm(
  mpg ~ wt + cyl, 
  data = mtcars, 
  QR = TRUE, 
  chains = 2, 
  refresh = 0
)
rsq &lt;- bayes_R2(fit)
print(median(rsq))
hist(rsq)

loo_rsq &lt;- loo_R2(fit)
print(median(loo_rsq))

# multilevel binomial model
if (!exists("example_model")) example(example_model)
print(example_model)
median(bayes_R2(example_model))
median(bayes_R2(example_model, re.form = NA)) # exclude group-level
}
</code></pre>

<hr>
<h2 id='example_jm'>Example joint longitudinal and time-to-event model</h2><span id='topic+example_jm'></span>

<h3>Description</h3>

<p>A model for use in the <span class="pkg">rstanarm</span> examples related to <code><a href="#topic+stan_jm">stan_jm</a></code>.
</p>


<h3>Format</h3>

<p>Calling <code>example("example_jm")</code> will run the model in the 
Examples section, below, and the resulting stanmvreg object will then be
available in the global environment. The <code>chains</code> and <code>iter</code>
arguments are specified to make this example be small in size. In practice,
we recommend that they be left unspecified in order to use the default
values or increased if there are convergence problems. The <code>cores</code> 
argument is optional and on a multicore system, the user may well want 
to set that equal to the number of chains being executed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # set.seed(123)
  if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386")
  example_jm &lt;- 
     stan_jm(formulaLong = logBili ~ year + (1 | id), 
             dataLong = pbcLong[1:101,],
             formulaEvent = survival::Surv(futimeYears, death) ~ sex + trt, 
             dataEvent = pbcSurv[1:15,],
             time_var = "year",
             # this next line is only to keep the example small in size!
             chains = 1, seed = 12345, iter = 100, refresh = 0)


</code></pre>

<hr>
<h2 id='example_model'>Example model</h2><span id='topic+example_model'></span>

<h3>Description</h3>

<p>A model for use in <span class="pkg">rstanarm</span> examples.
</p>


<h3>Format</h3>

<p>Calling <code>example("example_model")</code> will run the model in the 
Examples section, below, and the resulting stanreg object will then be
available in the global environment. The <code>chains</code> and <code>iter</code>
arguments are specified to make this example be small in size. In practice,
we recommend that they be left unspecified in order to use the default
values (4 and 2000 respectively) or increased if there are convergence
problems. The <code>cores</code> argument is optional and on a multicore system,
the user may well want to set that equal to the number of chains being
executed.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+cbpp">cbpp</a></code> for a description of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
example_model &lt;- 
  stan_glmer(cbind(incidence, size - incidence) ~ size + period + (1|herd),
             data = lme4::cbpp, family = binomial, QR = TRUE,
             # this next line is only to keep the example small in size!
             chains = 2, cores = 1, seed = 12345, iter = 1000, refresh = 0)
example_model
}
</code></pre>

<hr>
<h2 id='family.stanmvreg'>family method for stanmvreg objects</h2><span id='topic+family.stanmvreg'></span>

<h3>Description</h3>

<p>family method for stanmvreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanmvreg'
family(object, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.stanmvreg_+3A_object">object</code>, <code id="family.stanmvreg_+3A_...">...</code></td>
<td>
<p>See <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="family.stanmvreg_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
</table>

<hr>
<h2 id='family.stanreg'>family method for stanreg objects</h2><span id='topic+family.stanreg'></span>

<h3>Description</h3>

<p>family method for stanreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.stanreg_+3A_object">object</code>, <code id="family.stanreg_+3A_...">...</code></td>
<td>
<p>See <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='formula.stanreg'>formula method for stanreg objects</h2><span id='topic+formula.stanreg'></span>

<h3>Description</h3>

<p>formula method for stanreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
formula(x, ..., m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.stanreg_+3A_x">x</code></td>
<td>
<p>A stanreg object.</p>
</td></tr>
<tr><td><code id="formula.stanreg_+3A_...">...</code></td>
<td>
<p>Can contain <code>fixed.only</code> and <code>random.only</code> arguments 
that both default to <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_y'>Extract X, Y or Z from a stanreg object</h2><span id='topic+get_y'></span><span id='topic+get_x'></span><span id='topic+get_z'></span>

<h3>Description</h3>

<p>Extract X, Y or Z from a stanreg object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_y(object, ...)

get_x(object, ...)

get_z(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_y_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="get_y_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods. For a <code>stanmvreg</code> object
this can be an integer <code>m</code> specifying the submodel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_x</code> and <code>get_z</code>, a matrix. For <code>get_y</code>, either
a vector or a matrix, depending on how the response variable was specified.
</p>

<hr>
<h2 id='kfold.stanreg'>K-fold cross-validation</h2><span id='topic+kfold.stanreg'></span><span id='topic+kfold'></span>

<h3>Description</h3>

<p>The <code>kfold</code> method performs exact <code class="reqn">K</code>-fold cross-validation. First
the data are randomly partitioned into <code class="reqn">K</code> subsets of equal size (or as close
to equal as possible), or the user can specify the <code>folds</code> argument
to determine the partitioning. Then the model is refit <code class="reqn">K</code> times, each time
leaving out one of the <code class="reqn">K</code> subsets. If <code class="reqn">K</code> is equal to the total
number of observations in the data then <code class="reqn">K</code>-fold cross-validation is
equivalent to exact leave-one-out cross-validation (to which
<code><a href="#topic+loo.stanreg">loo</a></code> is an efficient approximation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
kfold(
  x,
  K = 10,
  ...,
  folds = NULL,
  save_fits = FALSE,
  cores = getOption("mc.cores", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold.stanreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the rstanarm modeling
functions. See <a href="#topic+stanreg-objects">stanreg-objects</a>.</p>
</td></tr>
<tr><td><code id="kfold.stanreg_+3A_k">K</code></td>
<td>
<p>For <code>kfold</code>, the number of subsets (folds) into which the data
will be partitioned for performing <code class="reqn">K</code>-fold cross-validation. The model
is refit <code>K</code> times, each time leaving out one of the <code>K</code> folds.
If the <code>folds</code> argument is specified then <code>K</code> will automatically
be set to <code>length(unique(folds))</code>, otherwise the specified value of
<code>K</code> is passed to <code>loo::<a href="loo.html#topic+kfold-helpers">kfold_split_random</a></code> to
randomly partition the data into <code>K</code> subsets of equal (or as close to
equal as possible) size.</p>
</td></tr>
<tr><td><code id="kfold.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="kfold.stanreg_+3A_folds">folds</code></td>
<td>
<p>For <code>kfold</code>, an optional integer vector with one element
per observation in the data used to fit the model. Each element of the
vector is an integer in <code>1:K</code> indicating to which of the <code>K</code>
folds the corresponding observation belongs. There are some convenience
functions available in the <span class="pkg">loo</span> package that create integer vectors to
use for this purpose (see the <strong>Examples</strong> section below and also the
<a href="loo.html#topic+kfold-helpers">kfold-helpers</a> page).</p>
</td></tr>
<tr><td><code id="kfold.stanreg_+3A_save_fits">save_fits</code></td>
<td>
<p>For <code>kfold</code>, if <code>TRUE</code>, a component <code>'fits'</code>
is added to the returned object to store the cross-validated
<a href="#topic+stanreg-objects">stanreg</a> objects and the indices of the omitted
observations for each fold. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kfold.stanreg_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallelization. Instead fitting
separate Markov chains for the same model on different cores, by default
<code>kfold</code> will distribute the <code>K</code> models to be fit across the cores
(using <code><a href="parallel.html#topic+clusterApply">parLapply</a></code> on Windows and
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> otherwise). The Markov chains for each
model will be run sequentially. This will often be the most efficient
option, especially if many cores are available, but in some cases it may be
preferable to fit the <code>K</code> models sequentially and instead use the
cores for the Markov chains. This can be accomplished by setting
<code>options(mc.cores)</code> to be the desired number of cores to use
for the Markov chains <em>and</em> also manually specifying <code>cores=1</code>
when calling the <code>kfold</code> function. See the end of the
<strong>Examples</strong> section for a demonstration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with classes 'kfold' and 'loo' that has a similar structure
as the objects returned by the <code><a href="#topic+loo">loo</a></code> and <code><a href="#topic+waic">waic</a></code>
methods and is compatible with the <code><a href="#topic+loo_compare">loo_compare</a></code> function for
comparing models.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4. arXiv preprint:
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>
</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018) Using
stacking to average Bayesian predictive distributions. <em>Bayesian
Analysis</em>, advance publication,  <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

fit1 &lt;- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)
fit2 &lt;- stan_glm(mpg ~ wt + cyl, data = mtcars, refresh = 0)
fit3 &lt;- stan_glm(mpg ~ disp * as.factor(cyl), data = mtcars, refresh = 0)

# 10-fold cross-validation
# (if possible also specify the 'cores' argument to use multiple cores)
(kfold1 &lt;- kfold(fit1, K = 10))
kfold2 &lt;- kfold(fit2, K = 10)
kfold3 &lt;- kfold(fit3, K = 10) 
loo_compare(kfold1, kfold2, kfold3)

# stratifying by a grouping variable
# (note: might get some divergences warnings with this model but 
# this is just intended as a quick example of how to code this)
fit4 &lt;- stan_lmer(mpg ~ disp + (1|cyl), data = mtcars, refresh = 0)
table(mtcars$cyl)
folds_cyl &lt;- loo::kfold_split_stratified(K = 3, x = mtcars$cyl)
table(cyl = mtcars$cyl, fold = folds_cyl)
kfold4 &lt;- kfold(fit4, folds = folds_cyl, cores = 2)
print(kfold4)

}
# Example code demonstrating the different ways to specify the number 
# of cores and how the cores are used
# 
# options(mc.cores = NULL)
# 
# # spread the K models over N_CORES cores (method 1)
# kfold(fit, K, cores = N_CORES)
# 
# # spread the K models over N_CORES cores (method 2)
# options(mc.cores = N_CORES)
# kfold(fit, K)
#  
# # fit K models sequentially using N_CORES cores for the Markov chains each time
# options(mc.cores = N_CORES)
# kfold(fit, K, cores = 1)

</code></pre>

<hr>
<h2 id='launch_shinystan.stanreg'>Using the ShinyStan GUI with rstanarm models</h2><span id='topic+launch_shinystan.stanreg'></span><span id='topic+launch_shinystan'></span>

<h3>Description</h3>

<p>The ShinyStan interface provides visual and numerical summaries of model
parameters and convergence diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
launch_shinystan(
  object,
  ppd = TRUE,
  seed = 1234,
  model_name = NULL,
  note = NULL,
  rstudio = getOption("shinystan.rstudio"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_shinystan.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.stanreg_+3A_ppd">ppd</code></td>
<td>
<p>Should <span class="pkg">rstanarm</span> draw from the posterior predictive 
distribution before launching ShinyStan? The default is <code>TRUE</code>, 
although for very large objects it can be convenient to set it to 
<code>FALSE</code> as drawing from the posterior predictive distribution can be 
time consuming. If <code>ppd</code> is <code>TRUE</code> then graphical posterior 
predictive checks are available when ShinyStan is launched.</p>
</td></tr>
<tr><td><code id="launch_shinystan.stanreg_+3A_seed">seed</code></td>
<td>
<p>Passed to <a href="#topic+pp_check">pp_check</a> if 
<code>ppd</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.stanreg_+3A_model_name">model_name</code>, <code id="launch_shinystan.stanreg_+3A_note">note</code></td>
<td>
<p>Optional arguments passed to
<code><a href="shinystan.html#topic+as.shinystan">as.shinystan</a></code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.stanreg_+3A_rstudio">rstudio</code></td>
<td>
<p>Only relevant for 'RStudio' users. The default (<code>FALSE</code>)
is to launch the app in the user's default web browser rather than the 
pop-up Viewer provided by 'RStudio'. Users can change the default to
<code>TRUE</code> by setting the global option <code>options(shinystan.rstudio =
TRUE)</code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.stanreg_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="shiny.html#topic+runApp">runApp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code> function will accept a
<code><a href="#topic+stanreg-objects">stanreg</a></code> object as input. Currently, almost 
any model fit using one of <span class="pkg">rstanarm</span>'s model-fitting functions can be 
used with ShinyStan. The only exception is that ShinyStan does not 
currently support <span class="pkg">rstanarm</span> models fit using 
<code>algorithm='optimizing'</code>. See the 
<span class="pkg"><a href="shinystan.html#topic+shinystan-package">shinystan</a></span> package documentation for more 
information.
</p>


<h3>Faster launch times</h3>

<p>For some <span class="pkg">rstanarm</span> models ShinyStan may take a very long time to launch.
If this is the case with one of your models you may be able to speed up
<code>launch_shinystan</code> in one of several ways:
</p>

<dl>
<dt>Prevent ShinyStan from preparing graphical posterior predictive
checks:</dt><dd>
<p>When used with a <code><a href="#topic+stanreg-objects">stanreg</a></code> object 
(<span class="pkg">rstanarm</span> model object) ShinyStan will draw from the posterior 
predictive distribution and prepare graphical posterior predictive checks 
before launching. That way when you go to the PPcheck page the plots are 
immediately available. This can be time consuming for models fit to very
large datasets and you can prevent this behavior by creating a shinystan
object before calling <code>launch_shinystan</code>. To do this use 
<code><a href="shinystan.html#topic+as.shinystan">as.shinystan</a></code> with optional argument <code>ppd</code> set
to <code>FALSE</code> (see the Examples section below). When you then launch
ShinyStan and go to the PPcheck page the plots will no longer be 
automatically generated and you will be presented with the standard
interface requiring you to first specify the appropriate <code class="reqn">y</code> and
<code class="reqn">yrep</code>, which can be done for many but not all <span class="pkg">rstanarm</span> models.
</p>
</dd>
<dt>Use a shinystan object:</dt><dd>
<p>Even if you don't want to prevent ShinyStan from preparing graphical
posterior predictive checks, first creating a shinystan object using
<code><a href="shinystan.html#topic+as.shinystan">as.shinystan</a></code> can reduce <em>future</em> launch
times. That is, <code>launch_shinystan(sso)</code> will be faster than
<code>launch_shinystan(fit)</code>, where <code>sso</code> is a shinystan object and
<code>fit</code> is a stanreg object. It still may take some time for 
<code>as.shinystan</code> to create <code>sso</code> initially, but each time you
subsequently call <code>launch_shinystan(sso)</code> it will reuse <code>sso</code>
instead of internally creating a shinystan object every time. See the
Examples section below.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>
<p>Muth, C., Oravecz, Z., and Gabry, J. (2018)
User-friendly Bayesian regression modeling: A tutorial with rstanarm and shinystan.
<em>The Quantitative Methods for Psychology</em>. 14(2), 99&ndash;119.
<a href="https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf">https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
## Not run: 
if (!exists("example_model")) example(example_model) 

# Launch the ShinyStan app without saving the resulting shinystan object
if (interactive()) launch_shinystan(example_model)

# Launch the ShinyStan app (saving resulting shinystan object as sso)
if (interactive()) sso &lt;- launch_shinystan(example_model)

# First create shinystan object then call launch_shinystan
sso &lt;- shinystan::as.shinystan(example_model)
if (interactive()) launch_shinystan(sso)

# Prevent ShinyStan from preparing graphical posterior predictive checks that
# can be time consuming. example_model is small enough that it won't matter
# much here but in general this can help speed up launch_shinystan
sso &lt;- shinystan::as.shinystan(example_model, ppd = FALSE)
if (interactive()) launch_shinystan(sso)

## End(Not run)
}
</code></pre>

<hr>
<h2 id='log_lik.stanreg'>Pointwise log-likelihood matrix</h2><span id='topic+log_lik.stanreg'></span><span id='topic+log_lik'></span><span id='topic+log_lik.stanmvreg'></span><span id='topic+log_lik.stanjm'></span>

<h3>Description</h3>

<p>For models fit using MCMC only, the <code>log_lik</code> method returns the
<code class="reqn">S</code> by <code class="reqn">N</code> pointwise log-likelihood matrix, where <code class="reqn">S</code> is the size
of the posterior sample and <code class="reqn">N</code> is the number of data points, or in the
case of the <code>stanmvreg</code> method (when called on <code><a href="#topic+stan_jm">stan_jm</a></code>
model objects) an <code class="reqn">S</code> by <code class="reqn">Npat</code> matrix where <code class="reqn">Npat</code> is the number 
of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
log_lik(object, newdata = NULL, offset = NULL, ...)

## S3 method for class 'stanmvreg'
log_lik(object, m = 1, newdata = NULL, ...)

## S3 method for class 'stanjm'
log_lik(object, newdataLong = NULL, newdataEvent = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_lik.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="log_lik.stanreg_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame of new data (e.g. holdout data) to use
when evaluating the log-likelihood. See the description of <code>newdata</code>
for <code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="log_lik.stanreg_+3A_offset">offset</code></td>
<td>
<p>A vector of offsets. Only required if <code>newdata</code> is
specified and an <code>offset</code> was specified when fitting the model.</p>
</td></tr>
<tr><td><code id="log_lik.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="log_lik.stanreg_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
<tr><td><code id="log_lik.stanreg_+3A_newdatalong">newdataLong</code>, <code id="log_lik.stanreg_+3A_newdataevent">newdataEvent</code></td>
<td>
<p>Optional data frames containing new data 
(e.g. holdout data) to use when evaluating the log-likelihood for a 
model estimated using <code><a href="#topic+stan_jm">stan_jm</a></code>. If the fitted model 
was a multivariate joint model (i.e. more than one longitudinal outcome),
then <code>newdataLong</code> is allowed to be a list of data frames. If supplying 
new data, then <code>newdataEvent</code> should also include variables corresponding
to the event time and event indicator as these are required for evaluating the
log likelihood for the event submodel. For more details, see the description 
of <code>newdataLong</code> and <code>newdataEvent</code> for <code><a href="#topic+posterior_survfit">posterior_survfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the <code>stanreg</code> and <code>stanmvreg</code> methods an <code class="reqn">S</code> by 
<code class="reqn">N</code> matrix, where <code class="reqn">S</code> is the size of the posterior sample and 
<code class="reqn">N</code> is the number of data points. For the <code>stanjm</code> method 
an <code class="reqn">S</code> by <code class="reqn">Npat</code> matrix where <code class="reqn">Npat</code> is the number of individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

 roaches$roach100 &lt;- roaches$roach1 / 100
 fit &lt;- stan_glm(
    y ~ roach100 + treatment + senior,
    offset = log(exposure2),
    data = roaches,
    family = poisson(link = "log"),
    prior = normal(0, 2.5),
    prior_intercept = normal(0, 10),
    iter = 500, # just to speed up example,
    refresh = 0
 )
 ll &lt;- log_lik(fit)
 dim(ll)
 all.equal(ncol(ll), nobs(fit))

 # using newdata argument
 nd &lt;- roaches[1:2, ]
 nd$treatment[1:2] &lt;- c(0, 1)
 ll2 &lt;- log_lik(fit, newdata = nd, offset = c(0, 0))
 head(ll2)
 dim(ll2)
 all.equal(ncol(ll2), nrow(nd))

}
</code></pre>

<hr>
<h2 id='logit'>Logit and inverse logit</h2><span id='topic+logit'></span><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Logit and inverse logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)

invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>

<hr>
<h2 id='loo_predict.stanreg'>Compute weighted expectations using LOO</h2><span id='topic+loo_predict.stanreg'></span><span id='topic+loo_predict'></span><span id='topic+loo_linpred'></span><span id='topic+loo_predictive_interval'></span><span id='topic+loo_linpred.stanreg'></span><span id='topic+loo_predictive_interval.stanreg'></span>

<h3>Description</h3>

<p>These functions are wrappers around the <code><a href="loo.html#topic+E_loo">E_loo</a></code> function
(<span class="pkg">loo</span> package) that provide compatibility for <span class="pkg">rstanarm</span> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
loo_predict(
  object,
  type = c("mean", "var", "quantile"),
  probs = 0.5,
  ...,
  psis_object = NULL
)

## S3 method for class 'stanreg'
loo_linpred(
  object,
  type = c("mean", "var", "quantile"),
  probs = 0.5,
  transform = FALSE,
  ...,
  psis_object = NULL
)

## S3 method for class 'stanreg'
loo_predictive_interval(object, prob = 0.9, ..., psis_object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_predict.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_type">type</code></td>
<td>
<p>The type of expectation to compute. The options are
<code>"mean"</code>, <code>"variance"</code>, and <code>"quantile"</code>.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_probs">probs</code></td>
<td>
<p>For computing quantiles, a vector of probabilities.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_psis_object">psis_object</code></td>
<td>
<p>An object returned by <code><a href="loo.html#topic+psis">psis</a></code>. If missing 
then <code>psis</code> will be run internally, which may be time consuming
for models fit to very large datasets.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_transform">transform</code></td>
<td>
<p>Passed to <code><a href="#topic+posterior_linpred">posterior_linpred</a></code>.</p>
</td></tr>
<tr><td><code id="loo_predict.stanreg_+3A_prob">prob</code></td>
<td>
<p>For <code>loo_predictive_interval</code>, a scalar in <code class="reqn">(0,1)</code>
indicating the desired probability mass to include in the intervals. The
default is <code>prob=0.9</code> (<code class="reqn">90</code>% intervals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>value</code> and <code>pareto_k</code>. 
</p>
<p>For <code>loo_predict</code> and <code>loo_linpred</code> the value component is a 
vector with one element per observation. 
</p>
<p>For <code>loo_predictive_interval</code> the <code>value</code> component is a matrix
with one row per observation and two columns (like
<code><a href="#topic+predictive_interval">predictive_interval</a></code>). <code>loo_predictive_interval(..., prob
  = p)</code> is equivalent to <code>loo_predict(..., type = "quantile", probs =
  c(a, 1-a))</code> with <code>a = (1 - p)/2</code>, except it transposes the result and
adds informative column names.
</p>
<p>See <code><a href="loo.html#topic+E_loo">E_loo</a></code> and <code><a href="loo.html#topic+pareto-k-diagnostic">pareto-k-diagnostic</a></code> for
details on the <code>pareto_k</code> diagnostic.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4. arXiv preprint:
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>
</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018) Using
stacking to average Bayesian predictive distributions. <em>Bayesian
Analysis</em>, advance publication,  <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>
<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
## Not run: 
if (!exists("example_model")) example(example_model)

# optionally, log-weights can be pre-computed and reused
psis_result &lt;- loo::psis(log_ratios = -log_lik(example_model))

loo_probs &lt;- loo_linpred(example_model, type = "mean", transform = TRUE, psis_object = psis_result)
str(loo_probs)

loo_pred_var &lt;- loo_predict(example_model, type = "var", psis_object = psis_result)
str(loo_pred_var)

loo_pred_ints &lt;- loo_predictive_interval(example_model, prob = 0.8, psis_object = psis_result)
str(loo_pred_ints)

## End(Not run)
}
</code></pre>

<hr>
<h2 id='loo.stanreg'>Information criteria and cross-validation</h2><span id='topic+loo.stanreg'></span><span id='topic+loo'></span><span id='topic+waic.stanreg'></span><span id='topic+waic'></span><span id='topic+loo_compare.stanreg'></span><span id='topic+loo_compare'></span><span id='topic+loo_compare.stanreg_list'></span><span id='topic+loo_model_weights.stanreg_list'></span><span id='topic+loo_model_weights'></span><span id='topic+compare_models'></span>

<h3>Description</h3>

<p>For models fit using MCMC, compute approximate leave-one-out
cross-validation (LOO, LOOIC) or, less preferably, the Widely Applicable
Information Criterion (WAIC) using the <span class="pkg"><a href="loo.html#topic+loo-package">loo</a></span>
package. (For <code class="reqn">K</code>-fold cross-validation see <code><a href="#topic+kfold.stanreg">kfold.stanreg</a></code>.)
Functions for  model comparison, and model weighting/averaging are also
provided. 
</p>
<p><strong>Note</strong>: these functions are not guaranteed to work
properly unless the <code>data</code> argument was specified when the model was
fit. Also, as of <span class="pkg">loo</span> version <code>2.0.0</code> the default number of cores
is now only 1, but we recommend using as many (or close to as many) cores
as possible by setting the <code>cores</code> argument or using
<code>options(mc.cores = VALUE)</code> to set it for an entire session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
loo(
  x,
  ...,
  cores = getOption("mc.cores", 1),
  save_psis = FALSE,
  k_threshold = NULL
)

## S3 method for class 'stanreg'
waic(x, ...)

## S3 method for class 'stanreg'
loo_compare(x, ..., criterion = c("loo", "kfold", "waic"), detail = FALSE)

## S3 method for class 'stanreg_list'
loo_compare(x, ..., criterion = c("loo", "kfold", "waic"), detail = FALSE)

## S3 method for class 'stanreg_list'
loo_model_weights(x, ..., cores = getOption("mc.cores", 1), k_threshold = NULL)

compare_models(..., loos = list(), detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.stanreg_+3A_x">x</code></td>
<td>
<p>For <code>loo</code> and <code>waic</code>, a fitted model object returned by
one of the rstanarm modeling functions. See <a href="#topic+stanreg-objects">stanreg-objects</a>.
</p>
<p>For the <code>loo_model_weights</code> method, <code>x</code> should be a
&quot;stanreg_list&quot; object, which is a list of fitted model objects created by
<code><a href="#topic+stanreg_list">stanreg_list</a></code>. <code>loo_compare</code> also allows <code>x</code> to be a
single stanreg object, with the remaining objects passed via <code>...</code>, or
a single <code>stanreg_list</code> object.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_...">...</code></td>
<td>
<p>For <code>loo_compare.stanreg</code>, <code>...</code> can contain objects
returned by the <code>loo</code>, <code><a href="#topic+kfold.stanreg">kfold</a></code>, or
<code>waic</code> method (see the <strong>Examples</strong> section, below).
</p>
<p>For <code>loo_model_weights</code>, <code>...</code> should contain arguments (e.g.
<code>method</code>) to pass to the default <code><a href="loo.html#topic+loo_model_weights">loo_model_weights</a></code>
method from the <span class="pkg">loo</span> package.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_cores">cores</code>, <code id="loo.stanreg_+3A_save_psis">save_psis</code></td>
<td>
<p>Passed to <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_k_threshold">k_threshold</code></td>
<td>
<p>Threshold for flagging estimates of the Pareto shape
parameters <code class="reqn">k</code> estimated by <code>loo</code>. See the <em>How to proceed
when <code>loo</code> gives warnings</em> section, below, for details.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_criterion">criterion</code></td>
<td>
<p>For <code>loo_compare.stanreg</code> and
<code>loo_compare.stanreg_list</code>, should the comparison be based on LOO-CV
(<code>criterion="loo"</code>), K-fold-CV (<code>criterion="kfold"</code>), or WAIC
(<code>criterion="waic"</code>). The default is LOO-CV. See the <strong>Comparing
models</strong> and <strong>Examples</strong> sections below.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_detail">detail</code></td>
<td>
<p>For <code>loo_compare.stanreg</code> and
<code>loo_compare.stanreg_list</code>, if <code>TRUE</code> then extra information
about each model (currently just the model formulas) will be printed with
the output.</p>
</td></tr>
<tr><td><code id="loo.stanreg_+3A_loos">loos</code></td>
<td>
<p>a list of objects produced by the <code><a href="#topic+loo">loo</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The structure of the objects returned by <code>loo</code> and <code>waic</code>
methods are documented in detail in the <strong>Value</strong> section in
<code><a href="loo.html#topic+loo">loo</a></code> and <code><a href="loo.html#topic+waic">waic</a></code> (from the <span class="pkg">loo</span>
package).
</p>
<p><code>loo_compare</code> returns a matrix with class 'compare.loo'. See the
<strong>Comparing models</strong> section below for more details.
</p>


<h3>Approximate LOO CV</h3>

<p>The <code>loo</code> method for stanreg objects
provides an interface to the <span class="pkg"><a href="loo.html#topic+loo-package">loo</a></span> package for
approximate leave-one-out cross-validation (LOO). The LOO Information
Criterion (LOOIC) has the same purpose as the Akaike Information Criterion
(AIC) that is used by frequentists. Both are intended to estimate the
expected log predictive density (ELPD) for a new dataset. However, the AIC
ignores priors and assumes that the posterior distribution is multivariate
normal, whereas the functions from the <span class="pkg">loo</span> package do not make this
distributional assumption and integrate over uncertainty in the parameters.
This only assumes that any one observation can be omitted without having a
major effect on the posterior distribution, which can be judged using the
diagnostic plot provided by the <code><a href="loo.html#topic+pareto-k-diagnostic">plot.loo</a></code> method and the
warnings provided by the <code><a href="loo.html#topic+print.loo">print.loo</a></code> method (see the
<em>How to Use the rstanarm Package</em> vignette for an example of this
process).
</p>


<h4>How to proceed when <code>loo</code> gives warnings (k_threshold)</h4>

<p>The <code>k_threshold</code> argument to the <code>loo</code> method for <span class="pkg">rstanarm</span>
models is provided as a possible remedy when the diagnostics reveal
problems stemming from the posterior's sensitivity to particular
observations. Warnings about Pareto <code class="reqn">k</code> estimates indicate observations
for which the approximation to LOO is problematic (this is described in
detail in Vehtari, Gelman, and Gabry (2017) and the
<span class="pkg"><a href="loo.html#topic+loo-package">loo</a></span> package documentation). The
<code>k_threshold</code> argument can be used to set the <code class="reqn">k</code> value above
which an observation is flagged. If <code>k_threshold</code> is not <code>NULL</code>
and there are <code class="reqn">J</code> observations with <code class="reqn">k</code> estimates above
<code>k_threshold</code> then when <code>loo</code> is called it will refit the
original model <code class="reqn">J</code> times, each time leaving out one of the <code class="reqn">J</code>
problematic observations. The pointwise contributions of these observations
to the total ELPD are then computed directly and substituted for the
previous estimates from these <code class="reqn">J</code> observations that are stored in the
object created by <code>loo</code>. Another option to consider is K-fold
cross-validation, which is documented on a separate page (see
<code><a href="#topic+kfold.stanreg">kfold</a></code>).
</p>
<p><strong>Note</strong>: in the warning messages issued by <code>loo</code> about large
Pareto <code class="reqn">k</code> estimates we recommend setting <code>k_threshold</code> to at
least <code class="reqn">0.7</code>. There is a theoretical reason, explained in Vehtari,
Gelman, and Gabry (2017), for setting the threshold to the stricter value
of <code class="reqn">0.5</code>, but in practice they find that errors in the LOO
approximation start to increase non-negligibly when <code class="reqn">k &gt; 0.7</code>.
</p>



<h3>Comparing models</h3>

<p>&quot;loo&quot; (or &quot;waic&quot; or &quot;kfold&quot;) objects can be passed
to the <code><a href="loo.html#topic+loo_compare">loo_compare</a></code> function in the <span class="pkg">loo</span> package to
perform model comparison. <span class="pkg">rstanarm</span> also provides a
<code>loo_compare.stanreg</code> method that can be used if the &quot;loo&quot; (or &quot;waic&quot;
or &quot;kfold&quot;) object has been added to the fitted model object (see the
<strong>Examples</strong> section below for how to do this). This second method
allows <span class="pkg">rstanarm</span> to perform some extra checks that can't be done by
the <span class="pkg">loo</span> package itself (e.g., verifying that all models to be
compared were fit using the same outcome variable).
</p>
<p><code>loo_compare</code> will return a matrix with one row per model and columns
containing the ELPD difference and the standard error of the difference. In
the first row of the matrix will be the model with the largest ELPD
(smallest LOOIC) and will contain zeros (there is no difference between
this model and itself). For each of the remaining models the ELPD
difference and SE are reported relative to the model with the best ELPD
(the first row). See the <strong>Details</strong> section at the
<code><a href="loo.html#topic+loo_compare">loo_compare</a></code> page in the <span class="pkg">loo</span> package for more
information.
</p>


<h3>Model weights</h3>

<p>The <code>loo_model_weights</code> method can be used to
compute model weights for a <code>"stanreg_list"</code> object, which is a list
of fitted model objects made with <code><a href="#topic+stanreg_list">stanreg_list</a></code>. The end of
the <strong>Examples</strong> section has a demonstration. For details see the
<code><a href="loo.html#topic+loo_model_weights">loo_model_weights</a></code> documentation in the <span class="pkg">loo</span>
package.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical
Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432.
doi:10.1007/s11222-016-9696-4. arXiv preprint:
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>
</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018) Using
stacking to average Bayesian predictive distributions. <em>Bayesian
Analysis</em>, advance publication,  <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>
<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>


<ul>
<li><p> The new <a href="https://mc-stan.org/loo/articles/"><span class="pkg">loo</span> package vignettes</a>
and various <a href="https://mc-stan.org/rstanarm/articles/"><span class="pkg">rstanarm</span> vignettes</a>
for more examples using <code>loo</code> and related functions with <span class="pkg">rstanarm</span> models.
</p>
</li>
<li> <p><code><a href="loo.html#topic+pareto-k-diagnostic">pareto-k-diagnostic</a></code> in the <span class="pkg">loo</span> package for
more on Pareto <code class="reqn">k</code> diagnostics.
</p>
</li>
<li> <p><code><a href="#topic+log_lik.stanreg">log_lik.stanreg</a></code> to directly access the pointwise
log-likelihood matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

fit1 &lt;- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)
fit2 &lt;- stan_glm(mpg ~ wt + cyl, data = mtcars, refresh = 0)

# (for bigger models use as many cores as possible)
loo1 &lt;- loo(fit1, cores = 1)
print(loo1)
loo2 &lt;- loo(fit2, cores = 1)
print(loo2)

# when comparing models the loo objects can be passed to loo_compare
# as individual arguments or as a list of loo objects
loo_compare(loo1, loo2)
loo_compare(list(loo1, loo2))

# if the fitted model objects contain a loo object in the component "loo"
# then the model objects can be passed directly or as a stanreg_list
fit1$loo &lt;- loo1
fit2$loo &lt;- loo2
loo_compare(fit1, fit2)

# if the fitted model objects contain a loo object _and_ a waic or kfold
# object, then the criterion argument determines which of them the comparison
# is based on 
fit1$waic &lt;- waic(fit1)
fit2$waic &lt;- waic(fit2)
loo_compare(fit1, fit2, criterion = "waic")

# the models can also be combined into a stanreg_list object, and more 
# informative model names can be provided to use when printing
model_list &lt;- stanreg_list(fit1, fit2, model_names = c("Fewer predictors", "More predictors"))
loo_compare(model_list)

fit3 &lt;- stan_glm(mpg ~ disp * as.factor(cyl), data = mtcars, refresh = 0)
loo3 &lt;- loo(fit3, cores = 2, k_threshold = 0.7)
loo_compare(loo1, loo2, loo3)

# setting detail=TRUE will also print model formulas if used with
# loo_compare.stanreg or loo_compare.stanreg_list
fit3$loo &lt;- loo3
model_list &lt;- stanreg_list(fit1, fit2, fit3)
loo_compare(model_list, detail=TRUE)

# Computing model weights
#
# if the objects in model_list already have 'loo' components then those
# will be used. otherwise loo will be computed for each model internally
# (in which case the 'cores' argument may also be used and is passed to loo())
loo_model_weights(model_list)  # defaults to method="stacking"
loo_model_weights(model_list,  method = "pseudobma")
loo_model_weights(model_list,  method = "pseudobma", BB = FALSE)

# you can also pass precomputed loo objects directly to loo_model_weights
loo_list &lt;- list(A = loo1, B = loo2, C = loo3) # names optional (affects printing)
loo_model_weights(loo_list)

}
</code></pre>

<hr>
<h2 id='model.frame.stanmvreg'>model.frame method for stanmvreg objects</h2><span id='topic+model.frame.stanmvreg'></span>

<h3>Description</h3>

<p>model.frame method for stanmvreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanmvreg'
model.frame(formula, fixed.only = FALSE, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.stanmvreg_+3A_formula">formula</code>, <code id="model.frame.stanmvreg_+3A_...">...</code></td>
<td>
<p>See <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.stanmvreg_+3A_fixed.only">fixed.only</code></td>
<td>
<p>See <code><a href="lme4.html#topic+merMod-class">model.frame.merMod</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.stanmvreg_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
</table>

<hr>
<h2 id='model.frame.stanreg'>model.frame method for stanreg objects</h2><span id='topic+model.frame.stanreg'></span>

<h3>Description</h3>

<p>model.frame method for stanreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
model.frame(formula, fixed.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.stanreg_+3A_formula">formula</code>, <code id="model.frame.stanreg_+3A_...">...</code></td>
<td>
<p>See <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.stanreg_+3A_fixed.only">fixed.only</code></td>
<td>
<p>See <code><a href="lme4.html#topic+merMod-class">model.frame.merMod</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='model.matrix.stanreg'>model.matrix method for stanreg objects</h2><span id='topic+model.matrix.stanreg'></span>

<h3>Description</h3>

<p>model.matrix method for stanreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.stanreg_+3A_object">object</code>, <code id="model.matrix.stanreg_+3A_...">...</code></td>
<td>
<p>See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='neg_binomial_2'>Family function for negative binomial GLMs</h2><span id='topic+neg_binomial_2'></span>

<h3>Description</h3>

<p>Specifies the information required to fit a Negative Binomial GLM in a 
similar way to <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code>. However, here the 
overdispersion parameter <code>theta</code> is not specified by the user and always
estimated (really the <em>reciprocal</em> of the dispersion parameter is
estimated). A call to this function can be passed to the <code>family</code>
argument of <code><a href="#topic+stan_glm">stan_glm</a></code> or <code><a href="#topic+stan_glmer">stan_glmer</a></code> to estimate a
Negative Binomial model. Alternatively, the <code><a href="#topic+stan_glm.nb">stan_glm.nb</a></code> and 
<code><a href="#topic+stan_glmer.nb">stan_glmer.nb</a></code> wrapper functions may be used, which call 
<code>neg_binomial_2</code> internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_binomial_2(link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neg_binomial_2_+3A_link">link</code></td>
<td>
<p>The same as for <code><a href="stats.html#topic+family">poisson</a></code>, typically a character
vector of length one among <code>"log"</code>, <code>"identity"</code>, and
<code>"sqrt"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+family">family</a></code> very similar to
that of <code><a href="stats.html#topic+family">poisson</a></code> but with a different family name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386")
stan_glm(Days ~ Sex/(Age + Eth*Lrn), data = MASS::quine, seed = 123,
         family = neg_binomial_2, QR = TRUE, algorithm = "optimizing") 
                
# or, equivalently, call stan_glm.nb() without specifying the family

</code></pre>

<hr>
<h2 id='nobs.stanmvreg'>Methods for stanreg objects</h2><span id='topic+nobs.stanmvreg'></span><span id='topic+stanreg-methods'></span><span id='topic+VarCorr'></span><span id='topic+fixef'></span><span id='topic+ranef'></span><span id='topic+ngrps'></span><span id='topic+sigma'></span><span id='topic+nsamples'></span><span id='topic+coef.stanreg'></span><span id='topic+confint.stanreg'></span><span id='topic+fitted.stanreg'></span><span id='topic+nobs.stanreg'></span><span id='topic+residuals.stanreg'></span><span id='topic+se.stanreg'></span><span id='topic+update.stanreg'></span><span id='topic+vcov.stanreg'></span><span id='topic+fixef.stanreg'></span><span id='topic+ngrps.stanreg'></span><span id='topic+nsamples.stanreg'></span><span id='topic+ranef.stanreg'></span><span id='topic+sigma.stanreg'></span><span id='topic+VarCorr.stanreg'></span>

<h3>Description</h3>

<p>The methods documented on this page are actually some of the least important 
methods defined for <a href="#topic+stanreg-objects">stanreg</a> objects. The most 
important methods are documented separately, each with its own page. Links to
those pages are provided in the <strong>See Also</strong> section, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanmvreg'
nobs(object, ...)

## S3 method for class 'stanreg'
coef(object, ...)

## S3 method for class 'stanreg'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'stanreg'
fitted(object, ...)

## S3 method for class 'stanreg'
nobs(object, ...)

## S3 method for class 'stanreg'
residuals(object, ...)

## S3 method for class 'stanreg'
se(object, ...)

## S3 method for class 'stanreg'
update(object, formula., ..., evaluate = TRUE)

## S3 method for class 'stanreg'
vcov(object, correlation = FALSE, ...)

## S3 method for class 'stanreg'
fixef(object, ...)

## S3 method for class 'stanreg'
ngrps(object, ...)

## S3 method for class 'stanreg'
nsamples(object, ...)

## S3 method for class 'stanreg'
ranef(object, ...)

## S3 method for class 'stanreg'
sigma(object, ...)

## S3 method for class 'stanreg'
VarCorr(x, sigma = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.stanmvreg_+3A_object">object</code>, <code id="nobs.stanmvreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_...">...</code></td>
<td>
<p>Ignored, except by the <code>update</code> method. See
<code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_parm">parm</code></td>
<td>
<p>For <code>confint</code>, an optional character vector of parameter
names.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_level">level</code></td>
<td>
<p>For <code>confint</code>, a scalar between <code class="reqn">0</code> and <code class="reqn">1</code>
indicating the confidence level to use.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_formula.">formula.</code>, <code id="nobs.stanmvreg_+3A_evaluate">evaluate</code></td>
<td>
<p>See <code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_correlation">correlation</code></td>
<td>
<p>For <code>vcov</code>, if <code>FALSE</code> (the default) the
covariance matrix is returned. If <code>TRUE</code>, the correlation matrix is
returned instead.</p>
</td></tr>
<tr><td><code id="nobs.stanmvreg_+3A_sigma">sigma</code></td>
<td>
<p>Ignored (included for compatibility with
<code><a href="nlme.html#topic+VarCorr">VarCorr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods documented on this page are similar to the methods 
defined for objects of class 'lm', 'glm', 'glmer', etc. However there are a
few key differences:
</p>

<dl>
<dt><code>residuals</code></dt><dd>
<p>Residuals are <em>always</em> of type <code>"response"</code> (not <code>"deviance"</code>
residuals or any other type). However, in the case of <code><a href="#topic+stan_polr">stan_polr</a></code>
with more than two response categories, the residuals are the difference 
between the latent utility and its linear predictor.
</p>
</dd>
<dt><code>coef</code></dt><dd>
<p>Medians are used for point estimates. See the <em>Point estimates</em> section
in <code><a href="#topic+print.stanreg">print.stanreg</a></code> for more details.
</p>
</dd>
<dt><code>se</code></dt><dd>
<p>The <code>se</code> function returns standard errors based on 
<code><a href="stats.html#topic+mad">mad</a></code>. See the <em>Uncertainty estimates</em> section in
<code><a href="#topic+print.stanreg">print.stanreg</a></code> for more details.
</p>
</dd>
<dt><code>confint</code></dt><dd>
<p>For models fit using optimization, confidence intervals are returned via a 
call to <code><a href="stats.html#topic+confint">confint.default</a></code>. If <code>algorithm</code> is 
<code>"sampling"</code>, <code>"meanfield"</code>, or <code>"fullrank"</code>, the
<code>confint</code> will throw an error because the
<code><a href="#topic+posterior_interval">posterior_interval</a></code> function should be used to compute Bayesian 
uncertainty intervals.
</p>
</dd>
<dt><code>nsamples</code></dt><dd>
<p>The number of draws from the posterior distribution obtained
</p>
</dd>
</dl>



<h3>See Also</h3>


<ul>
<li><p> The <code><a href="#topic+print.stanreg">print</a></code>,
<code><a href="#topic+summary.stanreg">summary</a></code>, and <code><a href="#topic+prior_summary">prior_summary</a></code> 
methods for stanreg objects for information on the fitted model.
</p>
</li>
<li> <p><code><a href="#topic+launch_shinystan">launch_shinystan</a></code> to use the ShinyStan GUI to explore a
fitted <span class="pkg">rstanarm</span> model.
</p>
</li>
<li><p> The <code><a href="#topic+plot.stanreg">plot</a></code> method to plot estimates and
diagnostics.
</p>
</li>
<li><p> The <code><a href="#topic+pp_check">pp_check</a></code> method for graphical posterior predictive
checking.
</p>
</li>
<li><p> The <code><a href="#topic+posterior_predict">posterior_predict</a></code> and <code><a href="#topic+predictive_error">predictive_error</a></code>
methods for predictions and predictive errors.
</p>
</li>
<li><p> The <code><a href="#topic+posterior_interval">posterior_interval</a></code> and <code><a href="#topic+predictive_interval">predictive_interval</a></code>
methods for uncertainty intervals for model parameters and predictions.
</p>
</li>
<li><p> The <code><a href="#topic+loo.stanreg">loo</a></code>, <code><a href="#topic+kfold">kfold</a></code>, and
<code><a href="#topic+log_lik">log_lik</a></code> methods for leave-one-out or K-fold cross-validation, 
model comparison, and computing the log-likelihood of (possibly new) data.
</p>
</li>
<li><p> The <code><a href="#topic+as.matrix.stanreg">as.matrix</a></code>, <code>as.data.frame</code>, 
and <code>as.array</code> methods to access posterior draws.
</p>
</li></ul>


<hr>
<h2 id='pairs.stanreg'>Pairs method for stanreg objects</h2><span id='topic+pairs.stanreg'></span><span id='topic+pairs_style_np'></span><span id='topic+pairs_condition'></span>

<h3>Description</h3>

<p>Interface to <span class="pkg">bayesplot</span>'s
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code> function for use with
<span class="pkg">rstanarm</span> models. Be careful not to specify too many parameters to
include or the plot will be both hard to read and slow to render.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
pairs(
  x,
  pars = NULL,
  regex_pars = NULL,
  condition = pairs_condition(nuts = "accept_stat__"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.stanreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="pairs.stanreg_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names. All parameters 
are included by default, but for models with more than just a few 
parameters it may be far too many to visualize on a small computer screen 
and also may require substantial computing time.</p>
</td></tr>
<tr><td><code id="pairs.stanreg_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
<tr><td><code id="pairs.stanreg_+3A_condition">condition</code></td>
<td>
<p>Same as the <code>condition</code> argument to 
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code> except the <em>default is different</em>
for <span class="pkg">rstanarm</span> models. By default, the <code>mcmc_pairs</code> function in
the <span class="pkg">bayesplot</span> package plots some of the Markov chains (half, in the
case of an even number of chains) in the panels above the diagonal and the
other half in the panels below the diagonal. However since we know that 
<span class="pkg">rstanarm</span> models were fit using Stan (which <span class="pkg">bayesplot</span> doesn't 
assume) we can make the default more useful by splitting the draws 
according to the <code>accept_stat__</code> diagnostic. The plots below the 
diagonal will contain realizations that are below the median 
<code>accept_stat__</code> and the plots above the diagonal will contain 
realizations that are above the median <code>accept_stat__</code>. To change this
behavior see the documentation of the <code>condition</code> argument at 
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.</p>
</td></tr>
<tr><td><code id="pairs.stanreg_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>. 
The <code>np</code>, <code>lp</code>, and <code>max_treedepth</code> arguments to 
<code>mcmc_pairs</code> are handled automatically by <span class="pkg">rstanarm</span> and do not 
need to be specified by the user in <code>...</code>. The arguments that can be 
specified in <code>...</code> include <code>transformations</code>, <code>diag_fun</code>,
<code>off_diag_fun</code>, <code>diag_args</code>, <code>off_diag_args</code>,
and <code>np_style</code>. These arguments are
documented thoroughly on the help page for
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

if (!exists("example_model")) example(example_model)

bayesplot::color_scheme_set("purple")

# see 'condition' argument above for details on the plots below and 
# above the diagonal. default is to split by accept_stat__.
pairs(example_model, pars = c("(Intercept)", "log-posterior"))

# for demonstration purposes, intentionally fit a model that
# will (almost certainly) have some divergences
fit &lt;- stan_glm(
  mpg ~ ., data = mtcars,
  iter = 1000,
  # this combo of prior and adapt_delta should lead to some divergences
  prior = hs(),
  adapt_delta = 0.9,
  refresh = 0
)

pairs(fit, pars = c("wt", "sigma", "log-posterior"))

# requires hexbin package
# pairs(
# fit, 
#   pars = c("wt", "sigma", "log-posterior"), 
#   transformations = list(sigma = "log"), # show log(sigma) instead of sigma
#  off_diag_fun = "hex" # use hexagonal heatmaps instead of scatterplots
# )

bayesplot::color_scheme_set("brightblue")
pairs(
  fit, 
  pars = c("(Intercept)", "wt", "sigma", "log-posterior"), 
  transformations = list(sigma = "log"), 
  off_diag_args = list(size = 3/4, alpha = 1/3), # size and transparency of scatterplot points
  np_style = pairs_style_np(div_color = "black", div_shape = 2) # color and shape of the divergences
)

# Using the condition argument to show divergences above the diagonal 
pairs(
  fit, 
  pars = c("(Intercept)", "wt", "log-posterior"), 
  condition = pairs_condition(nuts = "divergent__")
)


}
</code></pre>

<hr>
<h2 id='plot.predict.stanjm'>Plot the estimated subject-specific or marginal longitudinal trajectory</h2><span id='topic+plot.predict.stanjm'></span>

<h3>Description</h3>

<p>This generic <code>plot</code> method for <code>predict.stanjm</code> objects will
plot the estimated subject-specific or marginal longitudinal trajectory
using the data frame returned by a call to <code><a href="#topic+posterior_traj">posterior_traj</a></code>.
To ensure that enough data points are available to plot the longitudinal
trajectory, it is assumed that the call to <code><a href="#topic+posterior_traj">posterior_traj</a></code>
would have used the default <code>interpolate = TRUE</code>, and perhaps also 
<code>extrapolate = TRUE</code> (the latter being optional, depending on 
whether or not the user wants to see extrapolation of the longitudinal 
trajectory beyond the last observation time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.stanjm'
plot(
  x,
  ids = NULL,
  limits = c("ci", "pi", "none"),
  xlab = NULL,
  ylab = NULL,
  vline = FALSE,
  plot_observed = FALSE,
  facet_scales = "free_x",
  ci_geom_args = NULL,
  grp_overlay = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict.stanjm_+3A_x">x</code></td>
<td>
<p>A data frame and object of class <code>predict.stanjm</code>
returned by a call to the function <code><a href="#topic+posterior_traj">posterior_traj</a></code>.
The object contains point estimates and uncertainty interval limits
for the fitted values of the longitudinal response.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_ids">ids</code></td>
<td>
<p>An optional vector providing a subset of subject IDs for whom 
the predicted curves should be plotted.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_limits">limits</code></td>
<td>
<p>A quoted character string specifying the type of limits to
include in the plot. Can be one of: <code>"ci"</code> for the Bayesian
posterior uncertainty interval for the estimated mean longitudinal
response (often known as a credible interval);
<code>"pi"</code> for the prediction interval for the estimated (raw)
longitudinal response; or <code>"none"</code> for no interval limits.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_xlab">xlab</code>, <code id="plot.predict.stanjm_+3A_ylab">ylab</code></td>
<td>
<p>An optional axis label passed to 
<code><a href="ggplot2.html#topic+labs">labs</a></code>.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_vline">vline</code></td>
<td>
<p>A logical. If <code>TRUE</code> then a vertical dashed line
is added to the plot indicating the event or censoring time for
the individual. Can only be used if each plot within the figure
is for a single individual.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_plot_observed">plot_observed</code></td>
<td>
<p>A logical. If <code>TRUE</code> then the observed
longitudinal measurements are overlaid on the plot.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_facet_scales">facet_scales</code></td>
<td>
<p>A character string passed to the <code>scales</code>
argument of <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> when plotting the 
longitudinal trajectory for more than one individual.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_ci_geom_args">ci_geom_args</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> and used to control features
of the plotted interval limits. They should be supplied as a named list.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_grp_overlay">grp_overlay</code></td>
<td>
<p>Only relevant if the model had lower level units 
clustered within an individual. If <code>TRUE</code>, then the fitted trajectories 
for the lower level units will be overlaid in the same plot region (that 
is, all lower level units for a single individual will be shown within a 
single facet). If <code>FALSE</code>, then the fitted trajectories for each lower
level unit will be shown in a separate facet.</p>
</td></tr>
<tr><td><code id="plot.predict.stanjm_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code> and used to control features
of the plotted longitudinal trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object, also of class <code>plot.predict.stanjm</code>.
This object can be further customised using the <span class="pkg">ggplot2</span> package.
It can also be passed to the function <code><a href="#topic+plot_stack_jm">plot_stack_jm</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_traj">posterior_traj</a></code>, <code><a href="#topic+plot_stack_jm">plot_stack_jm</a></code>,
<code><a href="#topic+posterior_survfit">posterior_survfit</a></code>, <code><a href="#topic+plot.survfit.stanjm">plot.survfit.stanjm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

  # Run example model if not already loaded
  if (!exists("example_jm")) example(example_jm)
  
  # For a subset of individuals in the estimation dataset we will
  # obtain subject-specific predictions for the longitudinal submodel 
  # at evenly spaced times between 0 and their event or censoring time.
  pt1 &lt;- posterior_traj(example_jm, ids = c(7,13,15), interpolate = TRUE)
  plot(pt1)                  # credible interval for mean response
  plot(pt1, limits = "pi")   # prediction interval for raw response
  plot(pt1, limits = "none") # no uncertainty interval
  
  # We can also extrapolate the longitudinal trajectories.
  pt2 &lt;- posterior_traj(example_jm, ids = c(7,13,15), interpolate = TRUE,
                        extrapolate = TRUE)
  plot(pt2)
  plot(pt2, vline = TRUE)    # add line indicating event or censoring time
  plot(pt2, vline = TRUE, plot_observed = TRUE)  # overlay observed longitudinal data
 
  # We can change or add attributes to the plot
  plot1 &lt;- plot(pt2, ids = c(7,13,15), xlab = "Follow up time",
                     vline = TRUE, plot_observed = TRUE, 
                     facet_scales = "fixed", color = "blue", linetype = 2,
                     ci_geom_args = list(fill = "red"))
  plot1
       
  # Since the returned plot is also a ggplot object, we can
  # modify some of its attributes after it has been returned
  plot1 + 
    ggplot2::theme(strip.background = ggplot2::element_blank()) +
    ggplot2::labs(title = "Some plotted longitudinal trajectories")

}
</code></pre>

<hr>
<h2 id='plot.stanreg'>Plot method for stanreg objects</h2><span id='topic+plot.stanreg'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <a href="#topic+stanreg-objects">stanreg-objects</a> provides a convenient 
interface to the <a href="bayesplot.html#topic+MCMC-overview">MCMC</a> module in the 
<span class="pkg"><a href="bayesplot.html#topic+bayesplot">bayesplot</a></span> package for plotting MCMC draws and diagnostics. It is also 
straightforward to use the functions from the <span class="pkg">bayesplot</span> package directly rather than
via the <code>plot</code> method. Examples of both methods of plotting are given
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
plot(x, plotfun = "intervals", pars = NULL, regex_pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stanreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stanreg_+3A_plotfun">plotfun</code></td>
<td>
<p>A character string naming the <span class="pkg">bayesplot</span> 
<a href="bayesplot.html#topic+MCMC-overview">MCMC</a> function to use. The default is to call
<code><a href="bayesplot.html#topic+MCMC-intervals">mcmc_intervals</a></code>. <code>plotfun</code> can be specified
either as the full name of a <span class="pkg">bayesplot</span> plotting function (e.g.
<code>"mcmc_hist"</code>) or can be abbreviated to the part of the name following
the <code>"mcmc_"</code> prefix (e.g. <code>"hist"</code>). To get the names of all
available MCMC functions see <code><a href="bayesplot.html#topic+available_ppc">available_mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stanreg_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.</p>
</td></tr>
<tr><td><code id="plot.stanreg_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
<tr><td><code id="plot.stanreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plotfun</code> for customizing the
plot. These are described on the help pages for the individual plotting 
functions. For example, the arguments accepted for the default
<code>plotfun="intervals"</code> can be found at
<code><a href="bayesplot.html#topic+MCMC-intervals">mcmc_intervals</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a ggplot object that can be further customized using the
<span class="pkg">ggplot2</span> package, or an object created from multiple ggplot objects
(e.g. a gtable object created by <code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>).
</p>


<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>

 
<ul>
<li><p> The vignettes in the <span class="pkg">bayesplot</span> package for many examples.
</p>
</li>
<li> <p><code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code> (<span class="pkg">bayesplot</span>) for links to
the documentation for all the available plotting functions.
</p>
</li>
<li> <p><code><a href="bayesplot.html#topic+bayesplot-colors">color_scheme_set</a></code> (<span class="pkg">bayesplot</span>) to change
the color scheme used for plotting.
</p>
</li>
<li> <p><code><a href="#topic+pp_check">pp_check</a></code> for graphical posterior predictive checks.
</p>
</li>
<li> <p><code><a href="#topic+plot_nonlinear">plot_nonlinear</a></code> for models with nonlinear smooth 
functions fit using <code><a href="#topic+stan_gamm4">stan_gamm4</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

# Use rstanarm example model
if (!exists("example_model")) example(example_model)
fit &lt;- example_model

#####################################
### Intervals and point estimates ###
#####################################
plot(fit) # same as plot(fit, "intervals"), plot(fit, "mcmc_intervals")

p &lt;- plot(fit, pars = "size", regex_pars = "period",
          prob = 0.5, prob_outer = 0.9)
p + ggplot2::ggtitle("Posterior medians \n with 50% and 90% intervals")

# Shaded areas under densities
bayesplot::color_scheme_set("brightblue")
plot(fit, "areas", regex_pars = "period",
     prob = 0.5, prob_outer = 0.9)

# Make the same plot by extracting posterior draws and calling
# bayesplot::mcmc_areas directly
x &lt;- as.array(fit, regex_pars = "period")
bayesplot::mcmc_areas(x, prob = 0.5, prob_outer = 0.9)

# Ridgelines version of the areas plot
bayesplot::mcmc_areas_ridges(x, regex_pars = "period", prob = 0.9)


##################################
### Histograms &amp; density plots ###
##################################
plot_title &lt;- ggplot2::ggtitle("Posterior Distributions")
plot(fit, "hist", regex_pars = "period") + plot_title
plot(fit, "dens_overlay", pars = "(Intercept)",
     regex_pars = "period") + plot_title

####################
### Scatterplots ###
####################
bayesplot::color_scheme_set("teal")
plot(fit, "scatter", pars = paste0("period", 2:3))
plot(fit, "scatter", pars = c("(Intercept)", "size"),
     size = 3, alpha = 0.5) +
     ggplot2::stat_ellipse(level = 0.9)


####################################################
### Rhat, effective sample size, autocorrelation ###
####################################################
bayesplot::color_scheme_set("red")

# rhat
plot(fit, "rhat")
plot(fit, "rhat_hist")

# ratio of effective sample size to total posterior sample size
plot(fit, "neff")
plot(fit, "neff_hist")

# autocorrelation by chain
plot(fit, "acf", pars = "(Intercept)", regex_pars = "period")
plot(fit, "acf_bar", pars = "(Intercept)", regex_pars = "period")


##################
### Traceplots ###
##################
# NOTE: rstanarm doesn't store the warmup draws (to save space because they
# are not so essential for diagnosing the particular models implemented in
# rstanarm) so the iterations in the traceplot are post-warmup iterations

bayesplot::color_scheme_set("pink")
(trace &lt;- plot(fit, "trace", pars = "(Intercept)"))

# change traceplot colors to ggplot defaults or custom values
trace + ggplot2::scale_color_discrete()
trace + ggplot2::scale_color_manual(values = c("maroon", "skyblue2"))

# changing facet layout 
plot(fit, "trace", pars = c("(Intercept)", "period2"),
     facet_args = list(nrow = 2))
# same plot by calling bayesplot::mcmc_trace directly
x &lt;- as.array(fit, pars = c("(Intercept)", "period2"))
bayesplot::mcmc_trace(x, facet_args = list(nrow = 2))


############
### More ###
############

# regex_pars examples
plot(fit, regex_pars = "herd:1\\]")
plot(fit, regex_pars = "herd:[279]")
plot(fit, regex_pars = "herd:[279]|period2")
plot(fit, regex_pars = c("herd:[279]", "period2"))


# For graphical posterior predictive checks see
# help("pp_check.stanreg")
}
</code></pre>

<hr>
<h2 id='plot.survfit.stanjm'>Plot the estimated subject-specific or marginal survival function</h2><span id='topic+plot.survfit.stanjm'></span><span id='topic+plot_stack_jm'></span>

<h3>Description</h3>

<p>This generic <code>plot</code> method for <code>survfit.stanjm</code> objects will
plot the estimated subject-specific or marginal survival function
using the data frame returned by a call to <code><a href="#topic+posterior_survfit">posterior_survfit</a></code>.
The call to <code>posterior_survfit</code> should ideally have included an
&quot;extrapolation&quot; of the survival function, obtained by setting the
<code>extrapolate</code> argument to <code>TRUE</code>.
</p>
<p>The <code>plot_stack_jm</code> function takes arguments containing the plots of the estimated
subject-specific longitudinal trajectory (or trajectories if a multivariate
joint model was estimated) and the plot of the estimated subject-specific
survival function and combines them into a single figure. This is most
easily understood by running the <strong>Examples</strong> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit.stanjm'
plot(
  x,
  ids = NULL,
  limits = c("ci", "none"),
  xlab = NULL,
  ylab = NULL,
  facet_scales = "free",
  ci_geom_args = NULL,
  ...
)

plot_stack_jm(yplot, survplot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survfit.stanjm_+3A_x">x</code></td>
<td>
<p>A data frame and object of class <code>survfit.stanjm</code>
returned by a call to the function <code><a href="#topic+posterior_survfit">posterior_survfit</a></code>.
The object contains point estimates and uncertainty interval limits
for estimated values of the survival function.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_ids">ids</code></td>
<td>
<p>An optional vector providing a subset of subject IDs for whom 
the predicted curves should be plotted.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_limits">limits</code></td>
<td>
<p>A quoted character string specifying the type of limits to
include in the plot. Can be one of: <code>"ci"</code> for the Bayesian
posterior uncertainty interval for the estimated survival probability
(often known as a credible interval); or <code>"none"</code> for no interval
limits.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_xlab">xlab</code>, <code id="plot.survfit.stanjm_+3A_ylab">ylab</code></td>
<td>
<p>An optional axis label passed to 
<code><a href="ggplot2.html#topic+labs">labs</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_facet_scales">facet_scales</code></td>
<td>
<p>A character string passed to the <code>scales</code>
argument of <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> when plotting the 
longitudinal trajectory for more than one individual.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_ci_geom_args">ci_geom_args</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> and used to control features
of the plotted interval limits. They should be supplied as a named list.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to
<code><a href="ggplot2.html#topic+geom_path">geom_line</a></code> and used to control features
of the plotted survival function.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_yplot">yplot</code></td>
<td>
<p>An object of class <code>plot.predict.stanjm</code>, returned by a
call to the generic <code><a href="#topic+plot.predict.stanjm">plot</a></code> method for
objects of class <code>predict.stanjm</code>. If there is more than one
longitudinal outcome, then a list of such objects can be provided.</p>
</td></tr>
<tr><td><code id="plot.survfit.stanjm_+3A_survplot">survplot</code></td>
<td>
<p>An object of class <code>plot.survfit.stanjm</code>, returned by a
call to the generic <code><a href="#topic+plot.survfit.stanjm">plot</a></code> method for
objects of class <code>survfit.stanjm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot method returns a <code>ggplot</code> object, also of class
<code>plot.survfit.stanjm</code>. This object can be further customised using the
<span class="pkg">ggplot2</span> package. It can also be passed to the function
<code>plot_stack_jm</code>.
</p>
<p><code>plot_stack_jm</code> returns an object of class
<code><a href="bayesplot.html#topic+bayesplot_grid">bayesplot_grid</a></code> that includes plots of the
estimated subject-specific longitudinal trajectories stacked on top of the
associated subject-specific survival curve.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_survfit">posterior_survfit</a></code>, <code><a href="#topic+plot_stack_jm">plot_stack_jm</a></code>,
<code><a href="#topic+posterior_traj">posterior_traj</a></code>, <code><a href="#topic+plot.predict.stanjm">plot.predict.stanjm</a></code>
</p>
<p><code><a href="#topic+plot.predict.stanjm">plot.predict.stanjm</a></code>, <code><a href="#topic+plot.survfit.stanjm">plot.survfit.stanjm</a></code>,
<code><a href="#topic+posterior_predict">posterior_predict</a></code>, <code><a href="#topic+posterior_survfit">posterior_survfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

  # Run example model if not already loaded
  if (!exists("example_jm")) example(example_jm)

  # Obtain subject-specific conditional survival probabilities
  # for all individuals in the estimation dataset.
  ps1 &lt;- posterior_survfit(example_jm, extrapolate = TRUE)

  # We then plot the conditional survival probabilities for
  # a subset of individuals
  plot(ps1, ids = c(7,13,15))
  # We can change or add attributes to the plot
  plot(ps1, ids = c(7,13,15), limits = "none")
  plot(ps1, ids = c(7,13,15), xlab = "Follow up time")
  plot(ps1, ids = c(7,13,15), ci_geom_args = list(fill = "red"),
       color = "blue", linetype = 2)
  plot(ps1, ids = c(7,13,15), facet_scales = "fixed")

  # Since the returned plot is also a ggplot object, we can
  # modify some of its attributes after it has been returned
  plot1 &lt;- plot(ps1, ids = c(7,13,15))
  plot1 +
    ggplot2::theme(strip.background = ggplot2::element_blank()) +
    ggplot2::coord_cartesian(xlim = c(0, 15)) +
    ggplot2::labs(title = "Some plotted survival functions")

  # We can also combine the plot(s) of the estimated
  # subject-specific survival functions, with plot(s)
  # of the estimated longitudinal trajectories for the
  # same individuals
  ps1 &lt;- posterior_survfit(example_jm, ids = c(7,13,15))
  pt1 &lt;- posterior_traj(example_jm, , ids = c(7,13,15))
  plot_surv &lt;- plot(ps1)
  plot_traj &lt;- plot(pt1, vline = TRUE, plot_observed = TRUE)
  plot_stack_jm(plot_traj, plot_surv)

  # Lastly, let us plot the standardised survival function
  # based on all individuals in our estimation dataset
  ps2 &lt;- posterior_survfit(example_jm, standardise = TRUE, times = 0,
                          control = list(epoints = 20))
  plot(ps2)

}
if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

  if (!exists("example_jm")) example(example_jm)
  ps1 &lt;- posterior_survfit(example_jm, ids = c(7,13,15))
  pt1 &lt;- posterior_traj(example_jm, ids = c(7,13,15), extrapolate = TRUE)
  plot_surv &lt;- plot(ps1)
  plot_traj &lt;- plot(pt1, vline = TRUE, plot_observed = TRUE)
  plot_stack_jm(plot_traj, plot_surv)

}
</code></pre>

<hr>
<h2 id='posterior_interval.stanreg'>Posterior uncertainty intervals</h2><span id='topic+posterior_interval.stanreg'></span><span id='topic+posterior_interval'></span>

<h3>Description</h3>

<p>For models fit using MCMC (<code>algorithm="sampling"</code>) or one of the
variational approximations (<code>"meanfield"</code> or <code>"fullrank"</code>), the
<code>posterior_interval</code> function computes Bayesian posterior uncertainty
intervals. These intervals are often referred to as <em>credible</em>
intervals, but we use the term <em>uncertainty</em> intervals to highlight the
fact that wider intervals correspond to greater uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
posterior_interval(
  object,
  prob = 0.9,
  type = "central",
  pars = NULL,
  regex_pars = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_interval.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_interval.stanreg_+3A_prob">prob</code></td>
<td>
<p>A number <code class="reqn">p \in (0,1)</code> indicating the desired
probability mass to include in the intervals. The default is to report
<code class="reqn">90</code>% intervals (<code>prob=0.9</code>) rather than the traditionally used
<code class="reqn">95</code>% (see Details).</p>
</td></tr>
<tr><td><code id="posterior_interval.stanreg_+3A_type">type</code></td>
<td>
<p>The type of interval to compute. Currently the only option is
<code>"central"</code> (see Details). A central <code class="reqn">100p</code>%
interval is defined by the <code class="reqn">\alpha/2</code> and <code class="reqn">1 - \alpha/2</code> quantiles,
where <code class="reqn">\alpha = 1 - p</code>.</p>
</td></tr>
<tr><td><code id="posterior_interval.stanreg_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.</p>
</td></tr>
<tr><td><code id="posterior_interval.stanreg_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
<tr><td><code id="posterior_interval.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Interpretation</h4>

<p>Unlike for a frenquentist confidence interval, it is valid to say that,
conditional on the data and model, we believe that with probability <code class="reqn">p</code>
the value of a parameter is in its <code class="reqn">100p</code>% posterior interval. This
intuitive interpretation of Bayesian intervals is often erroneously applied
to frequentist confidence intervals. See Morey et al. (2015) for more details
on this issue and the advantages of using Bayesian posterior uncertainty
intervals (also known as credible intervals).
</p>



<h4>Default 90% intervals</h4>

<p>We default to reporting <code class="reqn">90</code>% intervals rather than <code class="reqn">95</code>% intervals
for several reasons:
</p>

<ul>
<li><p> Computational stability: <code class="reqn">90</code>% intervals are more stable than
<code class="reqn">95</code>% intervals (for which each end relies on only <code class="reqn">2.5</code>% of the
posterior draws). </p>
</li>
<li><p> Relation to Type-S errors (Gelman and Carlin, 2014):
<code class="reqn">95</code>% of the mass in a <code class="reqn">90</code>% central interval is above the lower
value (and <code class="reqn">95</code>% is below the upper value). For a parameter
<code class="reqn">\theta</code>, it is therefore easy to see if the posterior probability that
<code class="reqn">\theta &gt; 0</code> (or <code class="reqn">\theta &lt; 0</code>) is larger or smaller than <code class="reqn">95</code>%.
</p>
</li></ul>

<p>Of course, if <code class="reqn">95</code>% intervals are desired they can be computed by
specifying <code>prob=0.95</code>.
</p>



<h4>Types of intervals</h4>

<p>Currently <code>posterior_interval</code> only computes central intervals because
other types of intervals are rarely useful for the models that <span class="pkg">rstanarm</span>
can estimate. Additional possibilities may be provided in future releases as
more models become available.
</p>



<h3>Value</h3>

<p>A matrix with two columns and as many rows as model parameters (or
the subset of parameters specified by <code>pars</code> and/or
<code>regex_pars</code>). For a given value of <code>prob</code>, <code class="reqn">p</code>, the columns
correspond to the lower and upper <code class="reqn">100p</code>% interval limits and have the
names <code class="reqn">100\alpha/2</code>% and <code class="reqn">100(1 - \alpha/2)</code>%, where <code class="reqn">\alpha
  = 1-p</code>. For example, if <code>prob=0.9</code> is specified (a <code class="reqn">90</code>%
interval), then the column names will be <code>"5%"</code> and <code>"95%"</code>,
respectively.
</p>


<h3>References</h3>

<p>Gelman, A. and Carlin, J. (2014). Beyond power calculations:
assessing Type S (sign) and Type M (magnitude) errors. <em>Perspectives on
Psychological Science</em>. 9(6), 641&ndash;51.
</p>
<p>Morey, R. D., Hoekstra, R., Rouder, J., Lee, M. D., and Wagenmakers, E. 
(2016). The fallacy of placing confidence in confidence intervals. 
<em>Psychonomic Bulletin &amp; Review</em>. 23(1), 103&ndash;123.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.stanreg">confint.stanreg</a></code>, which, for models fit using optimization, can
be used to compute traditional confidence intervals.
</p>
<p><code><a href="#topic+predictive_interval">predictive_interval</a></code> for predictive intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model)
posterior_interval(example_model)
posterior_interval(example_model, regex_pars = "herd")
posterior_interval(example_model, pars = "period2", prob = 0.5)
}
</code></pre>

<hr>
<h2 id='posterior_linpred.stanreg'>Posterior distribution of the (possibly transformed) linear predictor</h2><span id='topic+posterior_linpred.stanreg'></span><span id='topic+posterior_linpred'></span><span id='topic+posterior_epred'></span><span id='topic+posterior_epred.stanreg'></span>

<h3>Description</h3>

<p>Extract the posterior draws of the linear predictor, possibly transformed by
the inverse-link function. This function is occasionally useful, but it
should be used sparingly: inference and model checking should generally be
carried out using the posterior predictive distribution (i.e., using
<code><a href="#topic+posterior_predict">posterior_predict</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
posterior_linpred(
  object,
  transform = FALSE,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  offset = NULL,
  XZ = FALSE,
  ...
)

## S3 method for class 'stanreg'
posterior_epred(
  object,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  offset = NULL,
  XZ = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_linpred.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.stanreg_+3A_transform">transform</code></td>
<td>
<p>Should the linear predictor be transformed using the
inverse-link function? The default is <code>FALSE</code>. This argument is still
allowed but not recommended because the <code>posterior_epred</code> function now
provides the equivalent of <code>posterior_linpred(..., transform=TRUE)</code>.
See <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.stanreg_+3A_newdata">newdata</code>, <code id="posterior_linpred.stanreg_+3A_draws">draws</code>, <code id="posterior_linpred.stanreg_+3A_re.form">re.form</code>, <code id="posterior_linpred.stanreg_+3A_offset">offset</code></td>
<td>
<p>Same as for <code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.stanreg_+3A_xz">XZ</code></td>
<td>
<p>If <code>TRUE</code> then instead of computing the linear predictor the 
design matrix <code>X</code> (or <code>cbind(X,Z)</code> for models with group-specific
terms) constructed from <code>newdata</code> is returned. The default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>posterior_linpred</code> function returns the posterior
distribution of the linear predictor, while the <code>posterior_epred</code>
function returns the posterior distribution of the conditional expectation.
In the special case of a Gaussian likelihood with an identity link
function, these two concepts are the same. The <code>posterior_epred</code>
function is a less noisy way to obtain expectations over the output of
<code><a href="#topic+posterior_predict">posterior_predict</a></code>.
</p>


<h3>Value</h3>

<p>The default is to return a <code>draws</code> by <code>nrow(newdata)</code>
matrix of simulations from the posterior distribution of the (possibly
transformed) linear predictor. The exception is if the argument <code>XZ</code>
is set to <code>TRUE</code> (see the <code>XZ</code> argument description above).
</p>


<h3>Note</h3>

<p>For models estimated with <code><a href="#topic+stan_clogit">stan_clogit</a></code>, the number of 
successes per stratum is ostensibly fixed by the research design. Thus,
when calling <code>posterior_linpred</code> with new data and <code>transform =
  TRUE</code>, the <code>data.frame</code> passed to the <code>newdata</code> argument must
contain an outcome variable and a stratifying factor, both with the same
name as in the original <code>data.frame</code>. Then, the probabilities will
condition on this outcome in the new data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_predict">posterior_predict</a></code> to draw from the posterior 
predictive distribution of the outcome, which is typically preferable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model)
print(family(example_model))

# linear predictor on log-odds scale
linpred &lt;- posterior_linpred(example_model)
colMeans(linpred)

# probabilities
# same as posterior_linpred(example_model, transform = TRUE)
probs &lt;- posterior_epred(example_model) 
colMeans(probs)

# not conditioning on any group-level parameters
probs2 &lt;- posterior_epred(example_model, re.form = NA)
apply(probs2, 2, median)
}
</code></pre>

<hr>
<h2 id='posterior_predict.stanreg'>Draw from posterior predictive distribution</h2><span id='topic+posterior_predict.stanreg'></span><span id='topic+posterior_predict'></span><span id='topic+posterior_predict.stanmvreg'></span>

<h3>Description</h3>

<p>The posterior predictive distribution is the distribution of the outcome
implied by the model after using the observed data to update our beliefs
about the unknown parameters in the model. Simulating data from the posterior
predictive distribution using the observed predictors is useful for checking
the fit of the model. Drawing from the posterior predictive distribution at
interesting values of the predictors also lets us visualize how a
manipulation of a predictor affects (a function of) the outcome(s). With new
observations of predictor variables we can use the posterior predictive
distribution to generate predicted outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
posterior_predict(
  object,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  fun = NULL,
  seed = NULL,
  offset = NULL,
  ...
)

## S3 method for class 'stanmvreg'
posterior_predict(
  object,
  m = 1,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  fun = NULL,
  seed = NULL,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with
which to predict. If omitted, the model matrix is used. If <code>newdata</code>
is provided and any variables were transformed (e.g. rescaled) in the data
used to fit the model, then these variables must also be transformed in
<code>newdata</code>. This only applies if variables were transformed before
passing the data to one of the modeling functions and <em>not</em> if
transformations were specified inside the model formula. Also see the Note
section below for a note about using the <code>newdata</code> argument with with
binomial models.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of draws to return. The default
and maximum number of draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_re.form">re.form</code></td>
<td>
<p>If <code>object</code> contains <code><a href="#topic+stan_glmer">group-level</a></code>
parameters, a formula indicating which group-level parameters to
condition on when making predictions. <code>re.form</code> is specified in the
same form as for <code><a href="lme4.html#topic+predict.merMod">predict.merMod</a></code>. The default,
<code>NULL</code>, indicates that all estimated group-level parameters are
conditioned on. To refrain from conditioning on any group-level parameters,
specify <code>NA</code> or <code>~0</code>. The <code>newdata</code> argument may include new
<em>levels</em> of the grouping factors that were specified when the model
was estimated, in which case the resulting posterior predictions
marginalize over the relevant variables.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_fun">fun</code></td>
<td>
<p>An optional function to apply to the results. <code>fun</code> is found
by a call to <code><a href="base.html#topic+match.fun">match.fun</a></code> and so can be specified as a function
object, a string naming a function, etc.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_seed">seed</code></td>
<td>
<p>An optional <code><a href="base.html#topic+set.seed">seed</a></code> to use.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_offset">offset</code></td>
<td>
<p>A vector of offsets. Only required if <code>newdata</code> is
specified and an <code>offset</code> argument was specified when fitting the
model.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_...">...</code></td>
<td>
<p>For <code>stanmvreg</code> objects, argument <code>m</code> can be specified
indicating the submodel for which you wish to obtain predictions.</p>
</td></tr>
<tr><td><code id="posterior_predict.stanreg_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> by <code>nrow(newdata)</code> matrix of simulations from the
posterior predictive distribution. Each row of the matrix is a vector of 
predictions generated using a single draw of the model parameters from the 
posterior distribution.
</p>


<h3>Note</h3>

<p>For binomial models with a number of trials greater than one (i.e., not
Bernoulli models), if <code>newdata</code> is specified then it must include all
variables needed for computing the number of binomial trials to use for the
predictions. For example if the left-hand side of the model formula is
<code>cbind(successes, failures)</code> then both <code>successes</code> and
<code>failures</code> must be in <code>newdata</code>. The particular values of
<code>successes</code> and <code>failures</code> in <code>newdata</code> do not matter so
long as their sum is the desired number of trials. If the left-hand side of
the model formula were <code>cbind(successes, trials - successes)</code> then
both <code>trials</code> and <code>successes</code> would need to be in <code>newdata</code>,
probably with <code>successes</code> set to <code>0</code> and <code>trials</code> specifying
the number of trials. See the Examples section below and the
<em>How to Use the rstanarm Package</em> for examples.
</p>
<p>For models estimated with <code><a href="#topic+stan_clogit">stan_clogit</a></code>, the number of 
successes per stratum is ostensibly fixed by the research design. Thus, when
doing posterior prediction with new data, the <code>data.frame</code> passed to
the <code>newdata</code> argument must contain an outcome variable and a stratifying
factor, both with the same name as in the original <code>data.frame</code>. Then, the 
posterior predictions will condition on this outcome in the new data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_check">pp_check</a></code> for graphical posterior predictive checks.
Examples of posterior predictive checking can also be found in the
<span class="pkg">rstanarm</span> vignettes and demos.
</p>
<p><code><a href="#topic+predictive_error">predictive_error</a></code> and <code><a href="#topic+predictive_interval">predictive_interval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model)
yrep &lt;- posterior_predict(example_model)
table(yrep)


# Using newdata
counts &lt;- c(18,17,15,20,10,20,25,13,12)
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
dat &lt;- data.frame(counts, treatment, outcome)
fit3 &lt;- stan_glm(
  counts ~ outcome + treatment, 
  data = dat,
  family = poisson(link="log"),
  prior = normal(0, 1, autoscale = FALSE), 
  prior_intercept = normal(0, 5, autoscale = FALSE),
  refresh = 0
)
nd &lt;- data.frame(treatment = factor(rep(1,3)), outcome = factor(1:3))
ytilde &lt;- posterior_predict(fit3, nd, draws = 500)
print(dim(ytilde))  # 500 by 3 matrix (draws by nrow(nd))

ytilde &lt;- data.frame(
  count = c(ytilde),
  outcome = rep(nd$outcome, each = 500)
)
ggplot2::ggplot(ytilde, ggplot2::aes(x=outcome, y=count)) +
  ggplot2::geom_boxplot() +
  ggplot2::ylab("predicted count")


# Using newdata with a binomial model.
# example_model is binomial so we need to set
# the number of trials to use for prediction.
# This could be a different number for each
# row of newdata or the same for all rows.
# Here we'll use the same value for all.
nd &lt;- lme4::cbpp
print(formula(example_model))  # cbind(incidence, size - incidence) ~ ...
nd$size &lt;- max(nd$size) + 1L   # number of trials
nd$incidence &lt;- 0  # set to 0 so size - incidence = number of trials
ytilde &lt;- posterior_predict(example_model, newdata = nd)


# Using fun argument to transform predictions
mtcars2 &lt;- mtcars
mtcars2$log_mpg &lt;- log(mtcars2$mpg)
fit &lt;- stan_glm(log_mpg ~ wt, data = mtcars2, refresh = 0)
ytilde &lt;- posterior_predict(fit, fun = exp)

}
</code></pre>

<hr>
<h2 id='posterior_survfit'>Estimate subject-specific or standardised survival probabilities</h2><span id='topic+posterior_survfit'></span>

<h3>Description</h3>

<p>This function allows us to generate estimated survival probabilities
based on draws from the posterior predictive distribution. By default
the survival probabilities are conditional on an individual's
group-specific coefficients (i.e. their individual-level random
effects). If prediction data is provided via the <code>newdataLong</code>
and <code>newdataEvent</code> arguments, then the default behaviour is to
sample new group-specific coefficients for the individuals in the
new data using a Monte Carlo scheme that conditions on their
longitudinal outcome data provided in <code>newdataLong</code>
(sometimes referred to as &quot;dynamic predictions&quot;, see Rizopoulos
(2011)). This default behaviour can be stopped by specifying
<code>dynamic = FALSE</code>, in which case the predicted survival
probabilities will be marginalised over the distribution of the
group-specific coefficients. This has the benefit that the user does
not need to provide longitudinal outcome measurements for the new
individuals, however, it does mean that the predictions will incorporate
all the uncertainty associated with between-individual variation, since
the predictions aren't conditional on any observed data for the individual.
In addition, by default, the predicted subject-specific survival
probabilities are conditional on observed values of the fixed effect
covariates (ie, the predictions will be obtained using either the design
matrices used in the original <code><a href="#topic+stan_jm">stan_jm</a></code> model call, or using the
covariate values provided in the <code>newdataLong</code> and <code>newdataEvent</code>
arguments). However, if you wish to average over the observed distribution
of the fixed effect covariates then this is possible &ndash; such predictions
are sometimes referred to as standardised survival probabilties &ndash; see the
<code>standardise</code> argument below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_survfit(
  object,
  newdataLong = NULL,
  newdataEvent = NULL,
  extrapolate = TRUE,
  control = list(),
  condition = NULL,
  last_time = NULL,
  prob = 0.95,
  ids,
  times = NULL,
  standardise = FALSE,
  dynamic = TRUE,
  scale = 1.5,
  draws = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_survfit_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by the 
<code><a href="#topic+stan_jm">stan_jm</a></code> modelling function. See 
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_newdatalong">newdataLong</code>, <code id="posterior_survfit_+3A_newdataevent">newdataEvent</code></td>
<td>
<p>Optionally, a data frame (or in the case of
<code>newdataLong</code> this can be a list of data frames) in which to look
for variables with which to predict. If omitted, the model matrices are used.
If new data is provided, then it should also contain the longitudinal
outcome data on which to condition when drawing the new group-specific
coefficients for individuals in the new data. Note that there is only
allowed to be one row of data for each individual in <code>newdataEvent</code>,
that is, time-varying covariates are not allowed in the prediction data for
the event submodel. Also, <code>newdataEvent</code> can optionally include a
variable with information about the last known survival time for the new
individuals &ndash; see the description for the <code>last_time</code> argument below
&ndash; however also note that when generating the survival probabilities it
is of course assumed that all individuals in <code>newdataEvent</code> have not
yet experienced the event (that is, any variable in <code>newdataEvent</code> that
corresponds to the event indicator will be ignored).</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A logical specifying whether to extrapolate the estimated
survival probabilities beyond the times specified in the <code>times</code> argument.
If <code>TRUE</code> then the extrapolation can be further controlled using
the <code>control</code> argument.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_control">control</code></td>
<td>
<p>A named list with parameters controlling extrapolation
of the estimated survival function when <code>extrapolate = TRUE</code>. The list
can contain one or more of the following named elements: <br />
</p>

<dl>
<dt><code>epoints</code></dt><dd><p>a positive integer specifying the number of
discrete time points at which to calculate the forecasted survival
probabilities. The default is 10.</p>
</dd>
<dt><code>edist</code></dt><dd><p>a positive scalar specifying the amount of time
across which to forecast the estimated survival function, represented
in units of the time variable <code>time_var</code> (from fitting the model).
The default is to extrapolate between the times specified in the
<code>times</code> argument and the maximum event or censoring time in the
original data. If <code>edist</code> leads to times that are beyond
the maximum event or censoring time in the original data then the
estimated survival probabilities will be truncated at that point, since
the estimate for the baseline hazard is not available beyond that time.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_condition">condition</code></td>
<td>
<p>A logical specifying whether the estimated
subject-specific survival probabilities at time <code>t</code> should be
conditioned on survival up to a fixed time point <code>u</code>. The default
is for <code>condition</code> to be set to <code>TRUE</code>, unless standardised survival
probabilities have been requested (by specifying <code>standardise = TRUE</code>),
in which case <code>condition</code> must (and will) be set to <code>FALSE</code>.
When conditional survival probabilities are requested, the fixed
time point <code>u</code> will be either: (i) the value specified via the
<code>last_time</code> argument; or if the <code>last_time</code> argument is
<code>NULL</code> then the latest observation time for each individual
(taken to be the value in the <code>times</code> argument if <code>newdataEvent</code>
is specified, or the observed event or censoring time if <code>newdataEvent</code>
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_last_time">last_time</code></td>
<td>
<p>A scalar, character string, or <code>NULL</code>. This argument
specifies the last known survival time for each individual when
conditional predictions are being obtained. If
<code>newdataEvent</code> is provided and conditional survival predictions are being
obtained, then the <code>last_time</code> argument can be one of the following:
(i) a scalar, this will use the same last time for each individual in
<code>newdataEvent</code>; (ii) a character string, naming a column in
<code>newdataEvent</code> in which to look for the last time for each individual;
(iii) <code>NULL</code>, in which case the default is to use the time of the latest
longitudinal observation in <code>newdataLong</code>. If <code>newdataEvent</code> is
<code>NULL</code> then the <code>last_time</code> argument cannot be specified
directly; instead it will be set equal to the event or censoring time for
each individual in the dataset that was used to estimate the model.
If standardised survival probabilities are requested (i.e.
<code>standardise = TRUE</code>) then conditional survival probabilities are
not allowed and therefore the <code>last_time</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_prob">prob</code></td>
<td>
<p>A scalar between 0 and 1 specifying the width to use for the
uncertainty interval (sometimes called credible interval) for the predictions.
For example <code>prob = 0.95</code> (the default) means that the 2.5th and 97.5th
percentiles will be provided.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_ids">ids</code></td>
<td>
<p>An optional vector specifying a subset of IDs for whom the
predictions should be obtained. The default is to predict for all individuals
who were used in estimating the model or, if <code>newdataLong</code> and
<code>newdataEvent</code> are specified, then all individuals contained in
the new data.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_times">times</code></td>
<td>
<p>A scalar, a character string, or <code>NULL</code>. Specifies the
times at which the estimated survival probabilities should be calculated.
It can be either: (i) <code>NULL</code>, in which case it will default to the last known
survival time for each individual, as determined by the <code>last_time</code>
argument; (ii) a scalar, specifying a time to estimate the survival probability
for each of the individuals; or (iii) if <code>newdataEvent</code> is
provided, it can be the name of a variable in <code>newdataEvent</code> that
indicates the time at which the survival probabilities should be calculated
for each individual.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_standardise">standardise</code></td>
<td>
<p>A logical specifying whether the estimated
subject-specific survival probabilities should be averaged
across all individuals for whom the subject-specific predictions are
being obtained. This can be used to average over the covariate and random effects
distributions of the individuals used in estimating the model, or the individuals
included in the <code>newdata</code> arguments. This approach of
averaging across the observed distribution of the covariates is sometimes
referred to as a &quot;standardised&quot; survival curve. If <code>standardise = TRUE</code>,
then the <code>times</code> argument must be specified and it must be constant across
individuals, that is, the survival probabilities must be calculated at the
same time for all individuals.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_dynamic">dynamic</code></td>
<td>
<p>A logical that is only relevant if new data is provided
via the <code>newdataLong</code> and <code>newdataEvent</code> arguments. If
<code>dynamic = TRUE</code>, then new group-specific parameters are drawn for
the individuals in the new data, conditional on their longitudinal
biomarker data contained in <code>newdataLong</code>. These group-specific
parameters are then used to generate individual-specific survival probabilities
for these individuals. These are often referred to as &quot;dynamic predictions&quot;
in the joint modelling context, because the predictions can be updated
each time additional longitudinal biomarker data is collected on the individual.
On the other hand, if <code>dynamic = FALSE</code> then the survival probabilities
will just be marginalised over the distribution of the group-specific
coefficients; this will mean that the predictions will incorporate all
uncertainty due to between-individual variation so there will likely be
very wide credible intervals on the predicted survival probabilities.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_scale">scale</code></td>
<td>
<p>A scalar, specifying how much to multiply the asymptotic
variance-covariance matrix for the random effects by, which is then
used as the &quot;width&quot; (ie. variance-covariance matrix) of the multivariate
Student-t proposal distribution in the Metropolis-Hastings algorithm. This
is only relevant when <code>newdataEvent</code> is supplied and
<code>dynamic = TRUE</code>, in which case new random effects are simulated
for the individuals in the new data using the Metropolis-Hastings algorithm.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of MCMC draws to return.
The default is to set the number of draws equal to 200, or equal to the
size of the posterior sample if that is less than 200.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_seed">seed</code></td>
<td>
<p>An optional <code><a href="base.html#topic+set.seed">seed</a></code> to use.</p>
</td></tr>
<tr><td><code id="posterior_survfit_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>survfit.stanjm</code>. The data frame includes
columns for each of the following:
(i) the median of the posterior predictions of the estimated survival
probabilities (<code>survpred</code>);
(ii) each of the lower and upper limits of the corresponding uncertainty
interval for the estimated survival probabilities (<code>ci_lb</code> and
<code>ci_ub</code>);
(iii) a subject identifier (<code>id_var</code>), unless standardised survival
probabilities were estimated;
(iv) the time that the estimated survival probability is calculated for
(<code>time_var</code>).
The returned object also includes a number of additional attributes.
</p>


<h3>Note</h3>

<p>Note that if any variables were transformed (e.g. rescaled) in the data
used to fit the model, then these variables must also be transformed in
<code>newdataLong</code> and <code>newdataEvent</code>. This only applies if variables
were transformed before passing the data to one of the modeling functions and
<em>not</em> if transformations were specified inside the model formula.
</p>


<h3>References</h3>

<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in
joint models for longitudinal and time-to-event data. <em>Biometrics</em>
<strong>67</strong>, 819.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.survfit.stanjm">plot.survfit.stanjm</a></code> for plotting the estimated survival
probabilities, <code><a href="#topic+ps_check">ps_check</a></code> for for graphical checks of the estimated
survival function, and <code><a href="#topic+posterior_traj">posterior_traj</a></code> for estimating the
marginal or subject-specific longitudinal trajectories, and
<code><a href="#topic+plot_stack_jm">plot_stack_jm</a></code> for combining plots of the estimated subject-specific
longitudinal trajectory and survival function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

  # Run example model if not already loaded
  if (!exists("example_jm")) example(example_jm)

  # Obtain subject-specific survival probabilities for a few
  # selected individuals in the estimation dataset who were
  # known to survive up until their censoring time. By default
  # the posterior_survfit function will estimate the conditional
  # survival probabilities, that is, conditional on having survived
  # until the event or censoring time, and then by default will
  # extrapolate the survival predictions forward from there.
  ps1 &lt;- posterior_survfit(example_jm, ids = c(7,13,15))
  # We can plot the estimated survival probabilities using the
  # associated plot function
  plot(ps1)

  # If we wanted to estimate the survival probabilities for the
  # same three individuals as the previous example, but this time
  # we won't condition on them having survived up until their
  # censoring time. Instead, we will estimate their probability
  # of having survived between 0 and 5 years given their covariates
  # and their estimated random effects.
  # The easiest way to achieve the time scale we want (ie, 0 to 5 years)
  # is to specify that we want the survival time estimated at time 0
  # and then extrapolated forward 5 years. We also specify that we
  # do not want to condition on their last known survival time.
  ps2 &lt;- posterior_survfit(example_jm, ids = c(7,13,15), times = 0,
    extrapolate = TRUE, condition = FALSE, control = list(edist = 5))

  # Instead we may want to estimate subject-specific survival probabilities
  # for a set of new individuals. To demonstrate this, we will simply take
  # the first two individuals in the estimation dataset, but pass their data
  # via the newdata arguments so that posterior_survfit will assume we are
  # predicting survival for new individuals and draw new random effects
  # under a Monte Carlo scheme (see Rizopoulos (2011)).
  ndL &lt;- pbcLong[pbcLong$id %in% c(1,2),]
  ndE &lt;- pbcSurv[pbcSurv$id %in% c(1,2),]
  ps3 &lt;- posterior_survfit(example_jm,
    newdataLong = ndL, newdataEvent = ndE,
    last_time = "futimeYears", seed = 12345)
  head(ps3)
  # We can then compare the estimated random effects for these
  # individuals based on the fitted model and the Monte Carlo scheme
  ranef(example_jm)$Long1$id[1:2,,drop=FALSE] # from fitted model
  colMeans(attr(ps3, "b_new"))                # from Monte Carlo scheme

  # Lastly, if we wanted to obtain "standardised" survival probabilities,
  # (by averaging over the observed distribution of the fixed effect
  # covariates, as well as averaging over the estimated random effects
  # for individuals in our estimation sample or new data) then we can
  # specify 'standardise = TRUE'. We can then plot the resulting
  # standardised survival curve.
  ps4 &lt;- posterior_survfit(example_jm, standardise = TRUE,
                           times = 0, extrapolate = TRUE)
  plot(ps4)

}
</code></pre>

<hr>
<h2 id='posterior_traj'>Estimate the subject-specific or marginal longitudinal trajectory</h2><span id='topic+posterior_traj'></span>

<h3>Description</h3>

<p>This function allows us to generate an estimated longitudinal trajectory 
(either subject-specific, or by marginalising over the distribution of the 
group-specific parameters) based on draws from the posterior predictive 
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_traj(
  object,
  m = 1,
  newdata = NULL,
  newdataLong = NULL,
  newdataEvent = NULL,
  interpolate = TRUE,
  extrapolate = FALSE,
  control = list(),
  last_time = NULL,
  prob = 0.95,
  ids,
  dynamic = TRUE,
  scale = 1.5,
  draws = NULL,
  seed = NULL,
  return_matrix = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_traj_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by the 
<code><a href="#topic+stan_jm">stan_jm</a></code> modelling function. See 
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_newdata">newdata</code></td>
<td>
<p><strong>Deprecated</strong>: please use <code>newdataLong</code> instead.
Optionally, a data frame in which to look for variables with
which to predict. If omitted, the model matrix is used. If <code>newdata</code>
is provided and any variables were transformed (e.g. rescaled) in the data
used to fit the model, then these variables must also be transformed in
<code>newdata</code>. This only applies if variables were transformed before
passing the data to one of the modeling functions and <em>not</em> if
transformations were specified inside the model formula.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_newdatalong">newdataLong</code>, <code id="posterior_traj_+3A_newdataevent">newdataEvent</code></td>
<td>
<p>Optionally, a data frame (or in the case of 
<code>newdataLong</code> this can be a list of data frames) in which to look 
for variables with which to predict. If omitted, the model matrices are used. 
If new data is provided, then two options are available. Either one can
provide observed covariate and outcome data, collected up to some time 
<em>t</em>, and use this data to draw new individual-specific coefficients
(i.e. individual-level random effects). This is the default behaviour when 
new data is provided, determined by the argument <code>dynamic = TRUE</code>, and
requiring both <code>newdataLong</code> and <code>newdataEvent</code> to be specified.
Alternatively, one can specify <code>dynamic = FALSE</code>, and then predict 
using just covariate data, by marginalising over the distribution
of the group-specific coefficients; in this case, only <code>newdataLong</code>
needs to be specified and it only needs to be a single data frame with
the covariate data for the predictions for the one longitudinal submodel.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_interpolate">interpolate</code></td>
<td>
<p>A logical specifying whether to interpolate the estimated 
longitudinal trajectory in between the observation times. This can be used
to achieve a smooth estimate of the longitudinal trajectory across the 
entire follow up time. If <code>TRUE</code> then the interpolation can be further 
controlled using the <code>control</code> argument.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_extrapolate">extrapolate</code></td>
<td>
<p>A logical specifying whether to extrapolate the estimated 
longitudinal trajectory beyond the time of the last known observation time.
If <code>TRUE</code> then the extrapolation can be further controlled using
the <code>control</code> argument.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_control">control</code></td>
<td>
<p>A named list with parameters controlling the interpolation or
extrapolation of the estimated longitudinal trajectory when either 
<code>interpolate = TRUE</code> or <code>extrapolate = TRUE</code>. The 
list can contain one or more of the following named elements: <br />
</p>

<dl>
<dt><code>ipoints</code></dt><dd><p>a positive integer specifying the number of discrete 
time points at which to calculate the estimated longitudinal response for
<code>interpolate = TRUE</code>. These time points are evenly spaced starting at 
0 and ending at the last known observation time for each individual. The
last observation time for each individual is taken to be either: the
event or censoring time if no new data is provided; the time specified
in the &quot;last_time&quot; column if provided in the new data (see <strong>Details</strong>
section below); or the time of the last longitudinal measurement if new
data is provided but no &quot;last_time&quot; column is included. The default is 15.</p>
</dd>
<dt><code>epoints</code></dt><dd><p>a positive integer specifying the number of discrete 
time points at which to calculate the estimated longitudinal response for
<code>extrapolate = TRUE</code>. These time points are evenly spaced between the 
last known observation time for each individual and the extrapolation 
distance specifed using either <code>edist</code> or <code>eprop</code>.
The default is 15.</p>
</dd>
<dt><code>eprop</code></dt><dd><p>a positive scalar between 0 and 1 specifying the 
amount of time across which to extrapolate the longitudinal trajectory,
represented as a proportion of the total observed follow up time for each
individual. For example specifying <code>eprop = 0.2</code> means that for an
individual for whom the latest of their measurement, event or censoring times
was 10 years, their estimated longitudinal trajectory will be extrapolated 
out to 12 years (i.e. 10 + (0.2 * 10)). The default value is 0.2.</p>
</dd>
<dt><code>edist</code></dt><dd><p>a positive scalar specifying the amount of time 
across which to extrapolate the longitudinal trajectory for each individual,
represented in units of the time variable <code>time_var</code> (from fitting the
model). This cannot be specified if <code>eprop</code> is specified.</p>
</dd> 
</dl>
</td></tr>
<tr><td><code id="posterior_traj_+3A_last_time">last_time</code></td>
<td>
<p>A scalar, character string, or <code>NULL</code>. This argument 
specifies the last known survival time for each individual when
conditional predictions are being obtained. If 
<code>newdataEvent</code> is provided and conditional survival predictions are being
obtained, then the <code>last_time</code> argument can be one of the following:
(i) a scalar, this will use the same last time for each individual in 
<code>newdataEvent</code>; (ii) a character string, naming a column in 
<code>newdataEvent</code> in which to look for the last time for each individual;
(iii) <code>NULL</code>, in which case the default is to use the time of the latest 
longitudinal observation in <code>newdataLong</code>. If <code>newdataEvent</code> is
<code>NULL</code> then the <code>last_time</code> argument cannot be specified 
directly; instead it will be set equal to the event or censoring time for
each individual in the dataset that was used to estimate the model. 
If standardised survival probabilities are requested (i.e. 
<code>standardise = TRUE</code>) then conditional survival probabilities are
not allowed and therefore the <code>last_time</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_prob">prob</code></td>
<td>
<p>A scalar between 0 and 1 specifying the width to use for the 
uncertainty interval (sometimes called credible interval) for the predicted
mean response and the prediction interval for the predicted (raw) response. 
For example <code>prob = 0.95</code> (the default) means that the 2.5th and 97.5th  
percentiles will be provided. Only relevant when <code>return_matrix</code> is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_ids">ids</code></td>
<td>
<p>An optional vector specifying a subset of subject IDs for whom the 
predictions should be obtained. The default is to predict for all individuals
who were used in estimating the model or, if <code>newdata</code> is specified,
then all individuals contained in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_dynamic">dynamic</code></td>
<td>
<p>A logical that is only relevant if new data is provided
via the <code>newdata</code> argument. If 
<code>dynamic = TRUE</code>, then new group-specific parameters are drawn for 
the individuals in the new data, conditional on their longitudinal 
biomarker data contained in <code>newdata</code>. These group-specific
parameters are then used to generate individual-specific survival probabilities
for these individuals. These are often referred to as &quot;dynamic predictions&quot;
in the joint modelling context, because the predictions can be updated
each time additional longitudinal biomarker data is collected on the individual.
On the other hand, if <code>dynamic = FALSE</code> then the survival probabilities
will just be marginalised over the distribution of the group-specific
coefficients; this will mean that the predictions will incorporate all
uncertainty due to between-individual variation so there will likely be
very wide credible intervals on the predicted survival probabilities.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_scale">scale</code></td>
<td>
<p>A scalar, specifying how much to multiply the asymptotic 
variance-covariance matrix for the random effects by, which is then
used as the &quot;width&quot; (ie. variance-covariance matrix) of the multivariate
Student-t proposal distribution in the Metropolis-Hastings algorithm. This
is only relevant when <code>newdataEvent</code> is supplied and 
<code>dynamic = TRUE</code>, in which case new random effects are simulated
for the individuals in the new data using the Metropolis-Hastings algorithm.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of MCMC draws to return. 
The default is to set the number of draws equal to 200, or equal to the 
size of the posterior sample if that is less than 200.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_seed">seed</code></td>
<td>
<p>An optional <code><a href="base.html#topic+set.seed">seed</a></code> to use.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_return_matrix">return_matrix</code></td>
<td>
<p>A logical. If <code>TRUE</code> then a <code>draws</code> by 
<code>nrow(newdata)</code> matrix is returned which contains all the actual
simulations or draws from the posterior predictive distribution. Otherwise
if <code>return_matrix</code> is set to <code>FALSE</code> (the default) then a 
data frame is returned, as described in the <strong>Value</strong> section below.</p>
</td></tr>
<tr><td><code id="posterior_traj_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+posterior_predict">posterior_predict</a></code>, for
example <code>draws</code>, <code>re.form</code>, <code>seed</code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>posterior_traj</code> function acts as a wrapper to the 
<code><a href="#topic+posterior_predict">posterior_predict</a></code> function, but allows predictions to be 
easily generated at time points that are interpolated and/or extrapolated 
between time zero (baseline) and the last known survival time for the 
individual, thereby providing predictions that correspond to a smooth estimate
of the longitudinal trajectory (useful for the plotting via the associated
<code><a href="#topic+plot.predict.stanjm">plot.predict.stanjm</a></code> method). In addition it returns a data 
frame by default, whereas the <code><a href="#topic+posterior_predict">posterior_predict</a></code> function 
returns a matrix; see the <strong>Value</strong> section below for details. Also,
<code>posterior_traj</code> allows predictions to only be generated for a subset
of individuals, via the <code>ids</code> argument.
</p>


<h3>Value</h3>

<p>When <code>return_matrix = FALSE</code>, a data frame 
of class <code>predict.stanjm</code>. The data frame includes a column for the median 
of the posterior predictions of the mean longitudinal response (<code>yfit</code>),
a column for each of the lower and upper limits of the uncertainty interval
corresponding to the posterior predictions of the mean longitudinal response 
(<code>ci_lb</code> and <code>ci_ub</code>), and a column for each of the lower and upper
limits of the prediction interval corresponding to the posterior predictions
of the (raw) longitudinal response. The data frame also includes columns for
the subject ID variable, and each of the predictor variables. The returned
object also includes a number of attributes.
</p>
<p>When <code>return_matrix = TRUE</code>, the returned object is the same as that 
described for <code><a href="#topic+posterior_predict">posterior_predict</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.predict.stanjm">plot.predict.stanjm</a></code>, <code><a href="#topic+posterior_predict">posterior_predict</a></code>,
<code><a href="#topic+posterior_survfit">posterior_survfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

  # Run example model if not already loaded
  if (!exists("example_jm")) example(example_jm)
  
  # Obtain subject-specific predictions for all individuals 
  # in the estimation dataset
  pt1 &lt;- posterior_traj(example_jm, interpolate = FALSE, extrapolate = FALSE)
  head(pt1)
  
  # Obtain subject-specific predictions only for a few selected individuals
  pt2 &lt;- posterior_traj(example_jm, ids = c(1,3,8))
  
  # If we wanted to obtain subject-specific predictions in order to plot the 
  # longitudinal trajectories, then we might want to ensure a full trajectory 
  # is obtained by interpolating and extrapolating time. We can then use the 
  # generic plot function to plot the subject-specific predicted trajectories
  # for the first three individuals. Interpolation and extrapolation is 
  # carried out by default.
  pt3 &lt;- posterior_traj(example_jm)
  head(pt3) # predictions at additional time points compared with pt1 
  plot(pt3, ids = 1:3)
  
  # If we wanted to extrapolate further in time, but decrease the number of 
  # discrete time points at which we obtain predictions for each individual, 
  # then we could specify a named list in the 'control' argument
  pt4 &lt;- posterior_traj(example_jm, control = list(ipoints = 10, epoints = 10, eprop = 0.5))
  
  # If we have prediction data for a new individual, and we want to
  # estimate the longitudinal trajectory for that individual conditional
  # on this new data (perhaps extrapolating forward from our last
  # longitudinal measurement) then we can do that. It requires drawing
  # new individual-specific parameters, based on the full likelihood,
  # so we must supply new data for both the longitudinal and event 
  # submodels. These are sometimes known as dynamic predictions.
  ndL &lt;- pbcLong[pbcLong$id == 8, , drop = FALSE]
  ndE &lt;- pbcSurv[pbcSurv$id == 8, , drop = FALSE]
  ndL$id &lt;- "new_subject" # new id can't match one used in training data
  ndE$id &lt;- "new_subject"
  pt5 &lt;- posterior_traj(example_jm, 
                        newdataLong = ndL,
                        newdataEvent = ndE)
                        
  # By default it is assumed that the last known survival time for 
  # the individual is the time of their last biomarker measurement,
  # but if we know they survived to some later time then we can
  # condition on that information using the last_time argument
  pt6 &lt;- posterior_traj(example_jm, 
                        newdataLong = ndL,
                        newdataEvent = ndE, 
                        last_time = "futimeYears")
  
  # Alternatively we may want to estimate the marginal longitudinal
  # trajectory for a given set of covariates. To do this, we can pass
  # the desired covariate values in a new data frame (however the only
  # covariate in our fitted model was the time variable, year). To make sure  
  # that we marginalise over the random effects, we need to specify an ID value
  # which does not correspond to any of the individuals who were used in the
  # model estimation and specify the argument dynamic=FALSE.
  # The marginal prediction is obtained by generating subject-specific 
  # predictions using a series of random draws from the random 
  # effects distribution, and then integrating (ie, averaging) over these. 
  # Our marginal prediction will therefore capture the between-individual 
  # variation associated with the random effects.
  
  nd &lt;- data.frame(id = rep("new1", 11), year = (0:10 / 2))
  pt7 &lt;- posterior_traj(example_jm, newdataLong = nd, dynamic = FALSE)
  head(pt7)  # note the greater width of the uncertainty interval compared 
             # with the subject-specific predictions in pt1, pt2, etc
  
  # Alternatively, we could have estimated the "marginal" trajectory by 
  # ignoring the random effects (ie, assuming the random effects were set 
  # to zero). This will generate a predicted longitudinal trajectory only
  # based on the fixed effect component of the model. In essence, for a 
  # linear mixed effects model (ie, a model that uses an identity link 
  # function), we should obtain a similar point estimate ("yfit") to the
  # estimates obtained in pt5 (since the mean of the estimated random effects
  # distribution will be approximately 0). However, it is important to note that
  # the uncertainty interval will be much more narrow, since it completely
  # ignores the between-individual variability captured by the random effects.
  # Further, if the model uses a non-identity link function, then the point
  # estimate ("yfit") obtained only using the fixed effect component of the
  # model will actually provide a biased estimate of the marginal prediction.
  # Nonetheless, to demonstrate how we can obtain the predictions only using 
  # the fixed effect component of the model, we simply specify 're.form = NA'. 
  # (We will use the same covariate values as used in the prediction for 
  # example for pt5).
  
  pt8 &lt;- posterior_traj(example_jm, newdataLong = nd, dynamic = FALSE, 
                        re.form = NA)
  head(pt8)  # note the much narrower ci, compared with pt5

}
</code></pre>

<hr>
<h2 id='posterior_vs_prior'>Juxtapose prior and posterior</h2><span id='topic+posterior_vs_prior'></span><span id='topic+posterior_vs_prior.stanreg'></span>

<h3>Description</h3>

<p>Plot medians and central intervals comparing parameter draws from the prior 
and posterior distributions. If the plotted priors look different than the 
priors you think you specified it is likely either because of internal 
rescaling or the use of the <code>QR</code> argument (see the documentation for the
<code><a href="#topic+prior_summary.stanreg">prior_summary</a></code> method for details on 
these special cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_vs_prior(object, ...)

## S3 method for class 'stanreg'
posterior_vs_prior(
  object,
  pars = NULL,
  regex_pars = NULL,
  prob = 0.9,
  color_by = c("parameter", "vs", "none"),
  group_by_parameter = FALSE,
  facet_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_vs_prior_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_...">...</code></td>
<td>
<p>The S3 generic uses <code>...</code> to pass arguments to any defined 
methods. For the method for stanreg objects, <code>...</code> is for arguments
(other than <code>color</code>) passed to <code>geom_pointrange</code> in the <span class="pkg">ggplot2</span>
package to control the appearance of the plotted intervals.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_pars">pars</code></td>
<td>
<p>An optional character vector specifying a subset of parameters to
display. Parameters can be specified by name or several shortcuts can be 
used. Using <code>pars="beta"</code> will restrict the displayed parameters to 
only the regression coefficients (without the intercept). <code>"alpha"</code> 
can also be used as a shortcut for <code>"(Intercept)"</code>. If the model has 
varying intercepts and/or slopes they can be selected using <code>pars = 
"varying"</code>.
</p>
<p>In addition, for <code>stanmvreg</code> objects there are some additional shortcuts 
available. Using <code>pars = "long"</code> will display the 
parameter estimates for the longitudinal submodels only (excluding group-specific
pparameters, but including auxiliary parameters).
Using <code>pars = "event"</code> will display the 
parameter estimates for the event submodel only, including any association
parameters. 
Using <code>pars = "assoc"</code> will display only the 
association parameters. 
Using <code>pars = "fixef"</code> will display all fixed effects, but not
the random effects or the auxiliary parameters. 
<code>pars</code> and <code>regex_pars</code> are set to <code>NULL</code> then all 
fixed effect regression coefficients are selected, as well as any 
auxiliary parameters and the log posterior.   
</p>
<p>If <code>pars</code> is <code>NULL</code> all parameters are selected for a <code>stanreg</code>
object, while for a <code>stanmvreg</code> object all 
fixed effect regression coefficients are selected as well as any 
auxiliary parameters and the log posterior. See 
<strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_prob">prob</code></td>
<td>
<p>A number <code class="reqn">p \in (0,1)</code> indicating the desired 
posterior probability mass to include in the (central posterior) interval 
estimates displayed in the plot. The default is <code class="reqn">0.9</code>.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_color_by">color_by</code></td>
<td>
<p>How should the estimates be colored? Use <code>"parameter"</code> 
to color by parameter name, <code>"vs"</code> to color the prior one color and 
the posterior another, and <code>"none"</code> to use no color. Except when 
<code>color_by="none"</code>, a variable is mapped to the color 
<code><a href="ggplot2.html#topic+aes">aes</a></code>thetic and it is therefore also possible to
change the default colors by adding one of the various discrete color
scales available in <code>ggplot2</code> 
(<code><a href="ggplot2.html#topic+scale_manual">scale_color_manual</a></code>, 
<code>scale_colour_brewer</code>, etc.). See Examples.</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_group_by_parameter">group_by_parameter</code></td>
<td>
<p>Should estimates be grouped together by parameter
(<code>TRUE</code>) or by posterior and prior (<code>FALSE</code>, the default)?</p>
</td></tr>
<tr><td><code id="posterior_vs_prior_+3A_facet_args">facet_args</code></td>
<td>
<p>A named list of arguments passed to
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> (other than the <code>facets</code> argument),
e.g., <code>nrow</code> or <code>ncol</code> to change the layout, <code>scales</code> to 
allow axis scales to vary across facets, etc. See Examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the 
<span class="pkg">ggplot2</span> package.
</p>


<h3>References</h3>

<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
## Not run: 
if (!exists("example_model")) example(example_model)
# display non-varying (i.e. not group-level) coefficients
posterior_vs_prior(example_model, pars = "beta")

# show group-level (varying) parameters and group by parameter
posterior_vs_prior(example_model, pars = "varying",
                   group_by_parameter = TRUE, color_by = "vs")

# group by parameter and allow axis scales to vary across facets
posterior_vs_prior(example_model, regex_pars = "period",
                   group_by_parameter = TRUE, color_by = "none",
                   facet_args = list(scales = "free"))

# assign to object and customize with functions from ggplot2
(gg &lt;- posterior_vs_prior(example_model, pars = c("beta", "varying"), prob = 0.8))

gg + 
 ggplot2::geom_hline(yintercept = 0, size = 0.3, linetype = 3) + 
 ggplot2::coord_flip() + 
 ggplot2::ggtitle("Comparing the prior and posterior")
 
# compare very wide and very narrow priors using roaches example
# (see help(roaches, "rstanarm") for info on the dataset)
roaches$roach100 &lt;- roaches$roach1 / 100
wide_prior &lt;- normal(0, 10)
narrow_prior &lt;- normal(0, 0.1)
fit_pois_wide_prior &lt;- stan_glm(y ~ treatment + roach100 + senior, 
                                offset = log(exposure2), 
                                family = "poisson", data = roaches, 
                                prior = wide_prior)
posterior_vs_prior(fit_pois_wide_prior, pars = "beta", prob = 0.5, 
                   group_by_parameter = TRUE, color_by = "vs", 
                   facet_args = list(scales = "free"))
                   
fit_pois_narrow_prior &lt;- update(fit_pois_wide_prior, prior = narrow_prior)
posterior_vs_prior(fit_pois_narrow_prior, pars = "beta", prob = 0.5, 
                   group_by_parameter = TRUE, color_by = "vs", 
                   facet_args = list(scales = "free"))
                   

# look at cutpoints for ordinal model
fit_polr &lt;- stan_polr(tobgp ~ agegp, data = esoph, method = "probit",
                      prior = R2(0.2, "mean"), init_r = 0.1)
(gg_polr &lt;- posterior_vs_prior(fit_polr, regex_pars = "\\|", color_by = "vs",
                               group_by_parameter = TRUE))
# flip the x and y axes
gg_polr + ggplot2::coord_flip()

## End(Not run)
}
</code></pre>

<hr>
<h2 id='pp_check.stanreg'>Graphical posterior predictive checks</h2><span id='topic+pp_check.stanreg'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p>Interface to the <a href="bayesplot.html#topic+PPC-overview">PPC</a> (posterior predictive checking) module
in the <span class="pkg"><a href="bayesplot.html#topic+bayesplot">bayesplot</a></span> package, providing various plots comparing the
observed outcome variable <code class="reqn">y</code> to simulated datasets <code class="reqn">y^{rep}</code>
from the posterior predictive distribution. The <code>pp_check</code> method for
<a href="#topic+stanreg-objects">stanreg-objects</a> prepares the arguments required for the specified
<span class="pkg">bayesplot</span> PPC plotting function and then calls that function. It is
also straightforward to use the functions from the <span class="pkg">bayesplot</span> package
directly rather than via the <code>pp_check</code> method. Examples of both are
given below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
pp_check(object, plotfun = "dens_overlay", nreps = NULL, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="pp_check.stanreg_+3A_plotfun">plotfun</code></td>
<td>
<p>A character string naming the <span class="pkg">bayesplot</span>
<a href="bayesplot.html#topic+PPC-overview">PPC</a> function to use. The default is to call
<code><a href="bayesplot.html#topic+PPC-distributions">ppc_dens_overlay</a></code>. <code>plotfun</code> can be specified
either as the full name of a <span class="pkg">bayesplot</span> plotting function (e.g.
<code>"ppc_hist"</code>) or can be abbreviated to the part of the name following
the <code>"ppc_"</code> prefix (e.g. <code>"hist"</code>). To get the names of all
available PPC functions see <code><a href="bayesplot.html#topic+available_ppc">available_ppc</a></code>.</p>
</td></tr>
<tr><td><code id="pp_check.stanreg_+3A_nreps">nreps</code></td>
<td>
<p>The number of <code class="reqn">y^{rep}</code> datasets to generate from the
<a href="#topic+posterior_predict">posterior predictive distribution</a> and show in
the plots. The default depends on <code>plotfun</code>. For functions that plot
each <code>yrep</code> dataset separately (e.g. <code>ppc_hist</code>), <code>nreps</code>
defaults to a small value to make the plots readable. For functions that
overlay many <code>yrep</code> datasets (e.g., <code>ppc_dens_overlay</code>) a larger
number is used by default, and for other functions (e.g. <code>ppc_stat</code>)
the default is to set <code>nreps</code> equal to the posterior sample size.</p>
</td></tr>
<tr><td><code id="pp_check.stanreg_+3A_seed">seed</code></td>
<td>
<p>An optional <code><a href="base.html#topic+set.seed">seed</a></code> to pass to
<code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="pp_check.stanreg_+3A_...">...</code></td>
<td>
<p>Additonal arguments passed to the <span class="pkg"><a href="bayesplot.html#topic+bayesplot">bayesplot</a></span> function
called. For many plotting functions <code>...</code> is optional, however for
functions that require a <code>group</code> or <code>x</code> argument, these arguments
should be specified in <code>...</code>. If specifying <code>group</code> and/or
<code>x</code>, they can be provided as either strings naming variables (in which
case they are searched for in the model frame) or as vectors containing the
actual values of the variables. See the <strong>Examples</strong> section, below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pp_check</code> returns a ggplot object that can be further
customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Note</h3>

<p>For binomial data, plots of <code class="reqn">y</code> and <code class="reqn">y^{rep}</code> show the
proportion of 'successes' rather than the raw count. Also for binomial
models see <code><a href="bayesplot.html#topic+PPC-errors">ppc_error_binned</a></code> for binned residual
plots.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. (Ch. 6)
</p>
<p>Gabry, J. , Simpson, D. , Vehtari, A. , Betancourt, M. and
Gelman, A. (2019), Visualization in Bayesian workflow. <em>J. R. Stat.
Soc. A</em>, 182: 389-402. doi:10.1111/rssa.12378,
<a href="https://arxiv.org/abs/1709.01449">arXiv preprint</a>,
<a href="https://github.com/jgabry/bayes-vis-paper">code on GitHub</a>)
</p>


<h3>See Also</h3>


<ul>
<li><p> The vignettes in the <span class="pkg">bayesplot</span> package for many examples.
Examples of posterior predictive checks can also be found in the
<span class="pkg">rstanarm</span> vignettes and demos.
</p>
</li>
<li> <p><code><a href="bayesplot.html#topic+PPC-overview">PPC-overview</a></code> (<span class="pkg">bayesplot</span>) for links to
the documentation for all the available plotting functions.
</p>
</li>
<li> <p><code><a href="#topic+posterior_predict">posterior_predict</a></code> for drawing from the posterior
predictive distribution.
</p>
</li>
<li> <p><code><a href="bayesplot.html#topic+bayesplot-colors">color_scheme_set</a></code> to change the color scheme
of the plots.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
fit &lt;- stan_glmer(
  mpg ~ wt + am + (1|cyl),
  data = mtcars,
  iter = 400, # iter and chains small just to keep example quick
  chains = 2,
  refresh = 0
)

# Compare distribution of y to distributions of multiple yrep datasets
pp_check(fit)
pp_check(fit, plotfun = "boxplot", nreps = 10, notch = FALSE)
pp_check(fit, plotfun = "hist", nreps = 3)


# Same plot (up to RNG noise) using bayesplot package directly
bayesplot::ppc_hist(y = mtcars$mpg, yrep = posterior_predict(fit, draws = 3))

# Check histograms of test statistics by level of grouping variable 'cyl'
pp_check(fit, plotfun = "stat_grouped", stat = "median", group = "cyl")

# Defining a custom test statistic
q25 &lt;- function(y) quantile(y, probs = 0.25)
pp_check(fit, plotfun = "stat_grouped", stat = "q25", group = "cyl")

# Scatterplot of two test statistics
pp_check(fit, plotfun = "stat_2d", stat = c("mean", "sd"))

# Scatterplot of y vs. average yrep
pp_check(fit, plotfun = "scatter_avg") # y vs. average yrep
# Same plot (up to RNG noise) using bayesplot package directly
bayesplot::ppc_scatter_avg(y = mtcars$mpg, yrep = posterior_predict(fit))

# Scatterplots of y vs. several individual yrep datasets
pp_check(fit, plotfun = "scatter", nreps = 3)

# Same plot (up to RNG noise) using bayesplot package directly
bayesplot::ppc_scatter(y = mtcars$mpg, yrep = posterior_predict(fit, draws = 3))

# yrep intervals with y points overlaid
# by default 1:length(y) used on x-axis but can also specify an x variable
pp_check(fit, plotfun = "intervals")
pp_check(fit, plotfun = "intervals", x = "wt") + ggplot2::xlab("wt")

# Same plot (up to RNG noise) using bayesplot package directly
bayesplot::ppc_intervals(y = mtcars$mpg, yrep = posterior_predict(fit),
                         x = mtcars$wt) + ggplot2::xlab("wt")

# predictive errors
pp_check(fit, plotfun = "error_hist", nreps = 6)
pp_check(fit, plotfun = "error_scatter_avg_vs_x", x = "wt") +
  ggplot2::xlab("wt")

# Example of a PPC for ordinal models (stan_polr)
fit2 &lt;- stan_polr(tobgp ~ agegp, data = esoph, method = "probit",
                  prior = R2(0.2, "mean"), init_r = 0.1,
                  refresh = 0)
pp_check(fit2, plotfun = "bars", nreps = 500, prob = 0.5)
pp_check(fit2, plotfun = "bars_grouped", group = esoph$agegp,
         nreps = 500, prob = 0.5)

}
</code></pre>

<hr>
<h2 id='pp_validate'>Model validation via simulation</h2><span id='topic+pp_validate'></span>

<h3>Description</h3>

<p>The <code>pp_validate</code> function is based on the methods described in
Cook, Gelman, and Rubin (2006) for validating software developed to fit
particular Bayesian models. Here we take the perspective that models
themselves are software and thus it is useful to apply this validation
approach to individual models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_validate(object, nreps = 20, seed = 12345, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_validate_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="pp_validate_+3A_nreps">nreps</code></td>
<td>
<p>The number of replications to be performed. <code>nreps</code> must be
sufficiently large so that the statistics described below in Details are
meaningful. Depending on the model and the size of the data, running
<code>pp_validate</code> may be slow. See also the Note section below for advice
on avoiding numerical issues.</p>
</td></tr>
<tr><td><code id="pp_validate_+3A_seed">seed</code></td>
<td>
<p>A seed passed to Stan to use when refitting the model.</p>
</td></tr>
<tr><td><code id="pp_validate_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We repeat <code>nreps</code> times the process of simulating parameters and data
from the model and refitting the model to this simulated data. For each of
the <code>nreps</code> replications we do the following:
</p>

<ol>
<li><p> Refit the model but <em>without</em> conditioning on the data (setting
<code>prior_PD=TRUE</code>), obtaining draws <code class="reqn">\theta^{true}</code>
from the <em>prior</em> distribution of the model parameters.
</p>
</li>
<li><p> Given <code class="reqn">\theta^{true}</code>, simulate data <code class="reqn">y^\ast</code>
from the <em>prior</em> predictive distribution (calling
<code><a href="#topic+posterior_predict">posterior_predict</a></code> on the fitted model object obtained in step
1).
</p>
</li>
<li><p> Fit the model to the simulated outcome <code class="reqn">y^\ast</code>, obtaining
parameters <code class="reqn">\theta^{post}</code>.
</p>
</li></ol>

<p>For any individual parameter, the quantile of the &quot;true&quot; parameter value with
respect to its posterior distribution <em>should</em> be uniformly distributed.
The validation procedure entails looking for deviations from uniformity by
computing statistics for a test that the quantiles are uniformly distributed.
The absolute values of the computed  test statistics are plotted for batches
of parameters (e.g., non-varying coefficients are grouped into a batch called
&quot;beta&quot;, parameters that vary by group level are in batches named for the
grouping variable, etc.). See Cook, Gelman, and Rubin (2006) for more details
on the validation procedure.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the
<span class="pkg">ggplot2</span> package.
</p>


<h3>Note</h3>

<p>In order to make it through <code>nreps</code> replications without running
into numerical difficulties you may have to restrict the range for randomly
generating initial values for parameters when you fit the <em>original</em>
model. With any of <span class="pkg">rstanarm</span>'s modeling functions this can be done by
specifying the optional argument <code>init_r</code> as some number less than the
default of <code class="reqn">2</code>.
</p>


<h3>References</h3>

<p>Cook, S., Gelman, A., and Rubin, D.
(2006). Validation of software for Bayesian models using posterior quantiles.
<em>Journal of Computational and Graphical Statistics</em>. 15(3), 675&ndash;692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_check">pp_check</a></code> for graphical posterior predictive checks and
<code><a href="#topic+posterior_predict">posterior_predict</a></code> to draw from the posterior predictive
distribution.
</p>
<p><code><a href="bayesplot.html#topic+bayesplot-colors">color_scheme_set</a></code> to change the color scheme of the
plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
## Not run: 
if (!exists("example_model")) example(example_model)
try(pp_validate(example_model)) # fails with default seed / priors

## End(Not run)
}
</code></pre>

<hr>
<h2 id='predict.stanreg'>Predict method for stanreg objects</h2><span id='topic+predict.stanreg'></span>

<h3>Description</h3>

<p>This method is primarily intended to be used only for models fit using 
optimization. For models fit using MCMC or one of the variational
approximations, see <code><a href="#topic+posterior_predict">posterior_predict</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
predict(
  object,
  ...,
  newdata = NULL,
  type = c("link", "response"),
  se.fit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="predict.stanreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="predict.stanreg_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with 
which to predict. If omitted, the model matrix is used.</p>
</td></tr>
<tr><td><code id="predict.stanreg_+3A_type">type</code></td>
<td>
<p>The type of prediction. The default <code>'link'</code> is on the scale
of the linear predictors; the alternative <code>'response'</code> is on the scale
of the response variable.</p>
</td></tr>
<tr><td><code id="predict.stanreg_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical scalar indicating if standard errors should be 
returned. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector if <code>se.fit</code> is <code>FALSE</code> and a list if <code>se.fit</code>
is <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_predict">posterior_predict</a></code>
</p>

<hr>
<h2 id='predictive_error.stanreg'>In-sample or out-of-sample predictive errors</h2><span id='topic+predictive_error.stanreg'></span><span id='topic+predictive_error'></span><span id='topic+predictive_error.matrix'></span><span id='topic+predictive_error.ppd'></span>

<h3>Description</h3>

<p>This is a convenience function for computing <code class="reqn">y - y^{rep}</code> 
(in-sample, for observed <code class="reqn">y</code>) or <code class="reqn">y - \tilde{y}</code> 
(out-of-sample, for new or held-out <code class="reqn">y</code>). The method for stanreg objects 
calls <code><a href="#topic+posterior_predict">posterior_predict</a></code> internally, whereas the method for
matrices accepts the matrix returned by <code>posterior_predict</code> as input and
can be used to avoid multiple calls to <code>posterior_predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
predictive_error(
  object,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  seed = NULL,
  offset = NULL,
  ...
)

## S3 method for class 'matrix'
predictive_error(object, y, ...)

## S3 method for class 'ppd'
predictive_error(object, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_error.stanreg_+3A_object">object</code></td>
<td>
<p>Either a fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions (a <a href="#topic+stanreg-objects">stanreg 
object</a>) or, for the matrix method, a matrix of draws from the 
posterior predictive distribution returned by 
<code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="predictive_error.stanreg_+3A_newdata">newdata</code>, <code id="predictive_error.stanreg_+3A_draws">draws</code>, <code id="predictive_error.stanreg_+3A_seed">seed</code>, <code id="predictive_error.stanreg_+3A_offset">offset</code>, <code id="predictive_error.stanreg_+3A_re.form">re.form</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="#topic+posterior_predict">posterior_predict</a></code>. For binomial models, please see the
<strong>Note</strong> section below if <code>newdata</code> will be specified.</p>
</td></tr>
<tr><td><code id="predictive_error.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="predictive_error.stanreg_+3A_y">y</code></td>
<td>
<p>For the matrix method only, a vector of <code class="reqn">y</code> values the 
same length as the number of columns in the matrix used as <code>object</code>. 
The method for stanreg objects takes <code>y</code> directly from the fitted 
model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>draws</code> by <code>nrow(newdata)</code> matrix. If <code>newdata</code> is 
not specified then it will be <code>draws</code> by <code>nobs(object)</code>.
</p>


<h3>Note</h3>

<p>The <strong>Note</strong> section in <code><a href="#topic+posterior_predict">posterior_predict</a></code> about 
<code>newdata</code> for binomial models also applies for
<code>predictive_error</code>, with one important difference. For
<code>posterior_predict</code> if the left-hand side of the model formula is 
<code>cbind(successes, failures)</code> then the particular values of 
<code>successes</code> and <code>failures</code> in <code>newdata</code> don't matter, only 
that they add to the desired number of trials. <strong>This is not the case
for</strong> <code>predictive_error</code>. For <code>predictive_error</code> the particular
value of <code>successes</code> matters because it is used as <code class="reqn">y</code> when
computing the error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_predict.stanreg">posterior_predict</a></code> to draw
from the posterior predictive distribution without computing predictive
errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model)
err1 &lt;- predictive_error(example_model, draws = 50)
hist(err1)

# Using newdata with a binomial model
formula(example_model)
nd &lt;- data.frame(
 size = c(10, 20), 
 incidence = c(5, 10), 
 period = factor(c(1,2)), 
 herd = c(1, 15)
)
err2 &lt;- predictive_error(example_model, newdata = nd, draws = 10, seed = 1234)

# stanreg vs matrix methods
fit &lt;- stan_glm(mpg ~ wt, data = mtcars, iter = 300)
preds &lt;- posterior_predict(fit, seed = 123)
all.equal(
  predictive_error(fit, seed = 123),
  predictive_error(preds, y = fit$y)
)
}
</code></pre>

<hr>
<h2 id='predictive_interval.stanreg'>Predictive intervals</h2><span id='topic+predictive_interval.stanreg'></span><span id='topic+predictive_interval'></span><span id='topic+predictive_interval.matrix'></span><span id='topic+predictive_interval.ppd'></span>

<h3>Description</h3>

<p>For models fit using MCMC (<code>algorithm="sampling"</code>) or one of the
variational approximations (<code>"meanfield"</code> or <code>"fullrank"</code>), the
<code>predictive_interval</code> function computes Bayesian predictive intervals.
The method for stanreg objects calls <code><a href="#topic+posterior_predict">posterior_predict</a></code>
internally, whereas the method for matrices accepts the matrix returned by
<code>posterior_predict</code> as input and can be used to avoid multiple calls to
<code>posterior_predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
predictive_interval(
  object,
  prob = 0.9,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  fun = NULL,
  seed = NULL,
  offset = NULL,
  ...
)

## S3 method for class 'matrix'
predictive_interval(object, prob = 0.9, ...)

## S3 method for class 'ppd'
predictive_interval(object, prob = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_interval.stanreg_+3A_object">object</code></td>
<td>
<p>Either a fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions (a <a href="#topic+stanreg-objects">stanreg 
object</a>) or, for the matrix method, a matrix of draws from the 
posterior predictive distribution returned by 
<code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="predictive_interval.stanreg_+3A_prob">prob</code></td>
<td>
<p>A number <code class="reqn">p \in (0,1)</code> indicating the desired
probability mass to include in the intervals. The default is to report
<code class="reqn">90</code>% intervals (<code>prob=0.9</code>) rather than the traditionally used
<code class="reqn">95</code>% (see Details).</p>
</td></tr>
<tr><td><code id="predictive_interval.stanreg_+3A_newdata">newdata</code>, <code id="predictive_interval.stanreg_+3A_draws">draws</code>, <code id="predictive_interval.stanreg_+3A_fun">fun</code>, <code id="predictive_interval.stanreg_+3A_offset">offset</code>, <code id="predictive_interval.stanreg_+3A_re.form">re.form</code>, <code id="predictive_interval.stanreg_+3A_seed">seed</code></td>
<td>
<p>Passed to 
<code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="predictive_interval.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns and as many rows as are in <code>newdata</code>. 
If <code>newdata</code> is not provided then the matrix will have as many rows as
the data used to fit the model. For a given value of <code>prob</code>, <code class="reqn">p</code>,
the columns correspond to the lower and upper <code class="reqn">100p</code>% central interval
limits and have the names <code class="reqn">100\alpha/2</code>% and <code class="reqn">100(1 -
  \alpha/2)</code>%, where <code class="reqn">\alpha = 1-p</code>. For example, if <code>prob=0.9</code> is
specified (a <code class="reqn">90</code>% interval), then the column names will be
<code>"5%"</code> and <code>"95%"</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictive_error">predictive_error</a></code>, <code><a href="#topic+posterior_predict">posterior_predict</a></code>, 
<code><a href="#topic+posterior_interval">posterior_interval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
fit &lt;- stan_glm(mpg ~ wt, data = mtcars, iter = 300)
predictive_interval(fit)
predictive_interval(fit, newdata = data.frame(wt = range(mtcars$wt)), 
                    prob = 0.5)

# stanreg vs matrix methods
preds &lt;- posterior_predict(fit, seed = 123)
all.equal(
  predictive_interval(fit, seed = 123),
  predictive_interval(preds)
)
}
</code></pre>

<hr>
<h2 id='print.stanreg'>Print method for stanreg objects</h2><span id='topic+print.stanreg'></span><span id='topic+print.stanmvreg'></span>

<h3>Description</h3>

<p>The <code>print</code> method for stanreg objects displays a compact summary of the
fitted model. See the <strong>Details</strong> section below for descriptions of the
different components of the printed output. For additional summary statistics
and diagnostics use the <code><a href="#topic+summary.stanreg">summary</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
print(x, digits = 1, detail = TRUE, ...)

## S3 method for class 'stanmvreg'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stanreg_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="print.stanreg_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for formatting numbers.</p>
</td></tr>
<tr><td><code id="print.stanreg_+3A_detail">detail</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>. If <code>FALSE</code> a more
minimal summary is printed consisting only of the parameter estimates.</p>
</td></tr>
<tr><td><code id="print.stanreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Point estimates</h4>

<p>Regardless of the estimation algorithm, point estimates are medians computed 
from simulations. For models fit using MCMC (<code>"sampling"</code>) the posterior
sample is used. For optimization (<code>"optimizing"</code>), the simulations are
generated from the asymptotic Gaussian sampling distribution of the
parameters. For the <code>"meanfield"</code> and <code>"fullrank"</code> variational
approximations, draws from the variational approximation to the posterior are
used. In all cases, the point estimates reported are the same as the values
returned by <code><a href="#topic+coef.stanreg">coef</a></code>.
</p>



<h4>Uncertainty estimates (MAD_SD)</h4>

<p>The standard deviations reported (labeled <code>MAD_SD</code> in the print output)
are computed from the same set of draws described above and are proportional
to the median absolute deviation (<code><a href="stats.html#topic+mad">mad</a></code>) from the median.
Compared to the raw posterior standard deviation, the MAD_SD will be
more robust for long-tailed distributions. These are the same as the values
returned by <code><a href="#topic+se.stanreg">se</a></code>.
</p>



<h4>Additional output</h4>


<ul>
<li><p> For GLMs with group-specific terms (see <code><a href="#topic+stan_glmer">stan_glmer</a></code>) the printed 
output also shows point estimates of the standard deviations of the group 
effects (and correlations if there are both intercept and slopes that vary by
group).
</p>
</li>
<li><p> For analysis of variance models (see <code><a href="#topic+stan_aov">stan_aov</a></code>) models, an
ANOVA-like table is also displayed.
</p>
</li>
<li><p> For joint longitudinal and time-to-event (see <code><a href="#topic+stan_jm">stan_jm</a></code>) models
the estimates are presented separately for each of the distinct submodels.  
</p>
</li></ul>




<h3>Value</h3>

<p>Returns <code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.stanreg">summary.stanreg</a></code>, <code><a href="#topic+stanreg-methods">stanreg-methods</a></code>
</p>

<hr>
<h2 id='print.survfit.stanjm'>Generic print method for <code>survfit.stanjm</code> objects</h2><span id='topic+print.survfit.stanjm'></span>

<h3>Description</h3>

<p>Generic print method for <code>survfit.stanjm</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit.stanjm'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.survfit.stanjm_+3A_x">x</code></td>
<td>
<p>An object of class <code>survfit.stanjm</code>, returned by a call to
<code><a href="#topic+posterior_survfit">posterior_survfit</a></code>.</p>
</td></tr>
<tr><td><code id="print.survfit.stanjm_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for formatting the time variable and
the survival probabilities.</p>
</td></tr>
<tr><td><code id="print.survfit.stanjm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='prior_summary.stanreg'>Summarize the priors used for an rstanarm model</h2><span id='topic+prior_summary.stanreg'></span><span id='topic+prior_summary'></span>

<h3>Description</h3>

<p>The <code>prior_summary</code> method provides a summary of the prior distributions
used for the parameters in a given model. In some cases the user-specified
prior does not correspond exactly to the prior used internally by
<span class="pkg">rstanarm</span> (see the sections below). Especially in these cases, but also
in general, it can be much more useful to visualize the priors. Visualizing
the priors can be done using the <code><a href="#topic+posterior_vs_prior">posterior_vs_prior</a></code> function,
or alternatively by fitting the model with the <code>prior_PD</code> argument set
to <code>TRUE</code> (to draw from the prior predictive distribution instead of
conditioning on the outcome) and then plotting the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
prior_summary(object, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_summary.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="prior_summary.stanreg_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for rounding.</p>
</td></tr>
<tr><td><code id="prior_summary.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored by the method for stanreg objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;prior_summary.stanreg&quot;, which has its own print
method.
</p>


<h3>Intercept (after predictors centered)</h3>

<p>For <span class="pkg">rstanarm</span> modeling functions that accept a <code>prior_intercept</code> 
argument, the specified prior for the intercept term applies to the 
intercept after <span class="pkg">rstanarm</span> internally centers the predictors so they 
each have mean zero. The estimate of the intercept returned to the user 
correspond to the intercept with the predictors as specified by the user 
(unmodified by <span class="pkg">rstanarm</span>), but when <em>specifying</em> the prior the 
intercept can be thought of as the expected outcome when the predictors are
set to their means. The only exception to this is for models fit with the 
<code>sparse</code> argument set to <code>TRUE</code> (which is only possible with a
subset of the modeling functions and never the default).
</p>


<h3>Adjusted scales</h3>

<p>For some models you may see &quot;<code>adjusted scale</code>&quot;
in the printed output and adjusted scales included in the object returned 
by <code>prior_summary</code>. These adjusted scale values are the prior scales 
actually used by <span class="pkg">rstanarm</span> and are computed by adjusting the prior 
scales specified by the user to account for the scales of the predictors 
(as described in the documentation for the <code><a href="#topic+priors">autoscale</a></code>
argument). To disable internal prior scale adjustments set the 
<code>autoscale</code> argument to <code>FALSE</code> when setting a prior using one of
the distributions that accepts an <code>autoscale</code> argument. For example,
<code>normal(0, 5, autoscale=FALSE)</code> instead of just <code>normal(0, 5)</code>.
</p>


<h3>Coefficients in Q-space</h3>

<p>For the models fit with an <span class="pkg">rstanarm</span> modeling function that supports 
the <code>QR</code> argument (see e.g, <code><a href="#topic+stan_glm">stan_glm</a></code>), if <code>QR</code> is 
set to <code>TRUE</code> then the prior distributions for the regression
coefficients specified using the <code>prior</code> argument are not relative to
the original predictor variables <code class="reqn">X</code> but rather to the variables in the
matrix <code class="reqn">Q</code> obtained from the <code class="reqn">QR</code> decomposition of <code class="reqn">X</code>. 
</p>
<p>In particular, if <code>prior = normal(location,scale)</code>, then this prior on
the coefficients in <code class="reqn">Q</code>-space can be easily translated into a joint 
multivariate normal (MVN) prior on the coefficients on the original 
predictors in <code class="reqn">X</code>. Letting <code class="reqn">\theta</code> denote the coefficients on
<code class="reqn">Q</code> and <code class="reqn">\beta</code> the coefficients on <code class="reqn">X</code> then if <code class="reqn">\theta
  \sim N(\mu, \sigma)</code> the corresponding prior on
<code class="reqn">\beta</code> is <code class="reqn">\beta \sim MVN(R\mu, R'R\sigma^2)</code>, where <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> are vectors of the
appropriate length. Technically, <span class="pkg">rstanarm</span> uses a scaled <code class="reqn">QR</code>
decomposition to ensure that the columns of the predictor matrix used to
fit the model all have unit scale, when the <code>autoscale</code> argument
to the function passed to the <code>prior</code> argument is <code>TRUE</code> (the
default), in which case the matrices actually used are
<code class="reqn">Q^\ast = Q \sqrt{n-1}</code> and <code class="reqn">R^\ast =
  \frac{1}{\sqrt{n-1}} R</code>. If <code>autoscale = FALSE</code>
we instead scale such that the lower-right element of <code class="reqn">R^\ast</code> is 
<code class="reqn">1</code>, which is useful if you want to specify a prior on the coefficient 
of the last predictor in its original units (see the documentation for the 
<code><a href="#topic+stan_glm">QR</a></code> argument).
</p>
<p>If you are interested in the prior on <code class="reqn">\beta</code> implied by the prior on
<code class="reqn">\theta</code>, we strongly recommend visualizing it as described above in
the <strong>Description</strong> section, which is simpler than working it out
analytically.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+priors">priors help page</a> and the <em>Prior
Distributions</em> vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model) 
prior_summary(example_model)

priors &lt;- prior_summary(example_model)
names(priors)
priors$prior$scale
priors$prior$adjusted_scale

# for a glm with adjusted scales (see Details, above), compare 
# the default (rstanarm adjusting the scales) to setting 
# autoscale=FALSE for prior on coefficients
fit &lt;- stan_glm(mpg ~ wt + am, data = mtcars, 
                prior = normal(0, c(2.5, 4)), 
                prior_intercept = normal(0, 5), 
                iter = 10, chains = 1) # only for demonstration 
prior_summary(fit)

fit2 &lt;- update(fit, prior = normal(0, c(2.5, 4), autoscale=FALSE), 
               prior_intercept = normal(0, 5, autoscale=FALSE))
prior_summary(fit2)
}
</code></pre>

<hr>
<h2 id='priors'>Prior distributions and options</h2><span id='topic+priors'></span><span id='topic+normal'></span><span id='topic+student_t'></span><span id='topic+cauchy'></span><span id='topic+hs'></span><span id='topic+hs_plus'></span><span id='topic+laplace'></span><span id='topic+lasso'></span><span id='topic+product_normal'></span><span id='topic+exponential'></span><span id='topic+decov'></span><span id='topic+lkj'></span><span id='topic+dirichlet'></span><span id='topic+R2'></span><span id='topic+default_prior_intercept'></span><span id='topic+default_prior_coef'></span>

<h3>Description</h3>

<p>The functions described on this page are used to specify the
prior-related arguments of the various modeling functions in the
<span class="pkg">rstanarm</span> package (to view the priors used for an existing model see
<code><a href="#topic+prior_summary">prior_summary</a></code>). 
</p>
<p>The default priors used in the various <span class="pkg">rstanarm</span> modeling functions
are intended to be <em>weakly informative</em> in that they provide moderate
regularization and help stabilize computation. For many applications the
defaults will perform well, but prudent use of more informative priors is
encouraged. Uniform prior distributions are possible (e.g. by setting
<code><a href="#topic+stan_glm">stan_glm</a></code>'s <code>prior</code> argument to <code>NULL</code>) but, unless
the data is very strong, they are not recommended and are <em>not</em>
non-informative, giving the same probability mass to implausible values as
plausible ones.
</p>
<p>More information on priors is available in the vignette
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a> as well as the vignettes for the
various modeling functions. For details on the 
priors used for multilevel models in particular see the vignette
<a href="https://mc-stan.org/rstanarm/articles/glmer.html"><em>Estimating
Generalized (Non-)Linear Models with Group-Specific Terms with rstanarm</em></a>
and also the <strong>Covariance matrices</strong> section lower down on this page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(location = 0, scale = NULL, autoscale = FALSE)

student_t(df = 1, location = 0, scale = NULL, autoscale = FALSE)

cauchy(location = 0, scale = NULL, autoscale = FALSE)

hs(df = 1, global_df = 1, global_scale = 0.01, slab_df = 4, slab_scale = 2.5)

hs_plus(
  df1 = 1,
  df2 = 1,
  global_df = 1,
  global_scale = 0.01,
  slab_df = 4,
  slab_scale = 2.5
)

laplace(location = 0, scale = NULL, autoscale = FALSE)

lasso(df = 1, location = 0, scale = NULL, autoscale = FALSE)

product_normal(df = 2, location = 0, scale = 1)

exponential(rate = 1, autoscale = FALSE)

decov(regularization = 1, concentration = 1, shape = 1, scale = 1)

lkj(regularization = 1, scale = 10, df = 1, autoscale = TRUE)

dirichlet(concentration = 1)

R2(location = NULL, what = c("mode", "mean", "median", "log"))

default_prior_intercept(family)

default_prior_coef(family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Prior location. In most cases, this is the prior mean, but
for <code>cauchy</code> (which is equivalent to <code>student_t</code> with
<code>df=1</code>), the mean does not exist and <code>location</code> is the prior
median. The default value is <code class="reqn">0</code>, except for <code>R2</code> which has no
default value for <code>location</code>. For <code>R2</code>, <code>location</code> pertains
to the prior location of the <code class="reqn">R^2</code> under a Beta distribution, but the
interpretation of the <code>location</code> parameter depends on the specified
value of the <code>what</code> argument (see the <em>R2 family</em> section in
<strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>Prior scale. The default depends on the family (see
<strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="priors_+3A_autoscale">autoscale</code></td>
<td>
<p>If <code>TRUE</code> then the scales of the priors on the
intercept and regression coefficients may be additionally modified
internally by <span class="pkg">rstanarm</span> in the following cases. First, for Gaussian
models only, the prior scales for the intercept, coefficients, and the
auxiliary parameter <code>sigma</code> (error standard deviation) are multiplied
by <code>sd(y)</code>. Additionally &mdash; not only for Gaussian models &mdash; if the
<code>QR</code> argument to the model fitting function (e.g. <code>stan_glm</code>) is
<code>FALSE</code> then we also divide the prior scale(s) by <code>sd(x)</code>.
Prior autoscaling is also discussed in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a></p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code>, <code id="priors_+3A_df1">df1</code>, <code id="priors_+3A_df2">df2</code></td>
<td>
<p>Prior degrees of freedom. The default is <code class="reqn">1</code> for 
<code>student_t</code>, in which case it is equivalent to <code>cauchy</code>. For the 
hierarchical shrinkage priors (<code>hs</code> and <code>hs_plus</code>) the degrees of
freedom parameter(s) default to <code class="reqn">1</code>. For the <code>product_normal</code>
prior, the degrees of freedom parameter must be an integer (vector) that is
at least <code class="reqn">2</code> (the default).</p>
</td></tr>
<tr><td><code id="priors_+3A_global_df">global_df</code>, <code id="priors_+3A_global_scale">global_scale</code>, <code id="priors_+3A_slab_df">slab_df</code>, <code id="priors_+3A_slab_scale">slab_scale</code></td>
<td>
<p>Optional arguments for the
hierarchical shrinkage priors. See the <em>Hierarchical shrinkage family</em>
section below.</p>
</td></tr>
<tr><td><code id="priors_+3A_rate">rate</code></td>
<td>
<p>Prior rate for the exponential distribution. Defaults to
<code>1</code>. For the exponential distribution, the rate parameter is the
<em>reciprocal</em> of the mean.</p>
</td></tr>
<tr><td><code id="priors_+3A_regularization">regularization</code></td>
<td>
<p>Exponent for an LKJ prior on the correlation matrix in
the <code>decov</code> or <code>lkj</code> prior. The default is <code class="reqn">1</code>, implying a 
joint uniform prior.</p>
</td></tr>
<tr><td><code id="priors_+3A_concentration">concentration</code></td>
<td>
<p>Concentration parameter for a symmetric Dirichlet 
distribution. The default is <code class="reqn">1</code>, implying a joint uniform prior.</p>
</td></tr>
<tr><td><code id="priors_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for a gamma prior on the scale parameter in the
<code>decov</code> prior. If <code>shape</code> and <code>scale</code> are both <code class="reqn">1</code> (the
default) then the gamma prior simplifies to the unit-exponential
distribution.</p>
</td></tr>
<tr><td><code id="priors_+3A_what">what</code></td>
<td>
<p>A character string among <code>'mode'</code> (the default),
<code>'mean'</code>, <code>'median'</code>, or <code>'log'</code> indicating how the
<code>location</code> parameter is interpreted in the <code>LKJ</code> case. If
<code>'log'</code>, then <code>location</code> is interpreted as the expected
logarithm of the <code class="reqn">R^2</code> under a Beta distribution. Otherwise,
<code>location</code> is interpreted as the <code>what</code> of the <code class="reqn">R^2</code>
under a Beta distribution. If the number of predictors is less than
or equal to two, the mode of this Beta distribution does not exist
and an error will prompt the user to specify another choice for
<code>what</code>.</p>
</td></tr>
<tr><td><code id="priors_+3A_family">family</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details depend on the family of the prior being used:
</p>


<h4>Student t family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>normal(location, scale)</code>
</p>
</li>
<li> <p><code>student_t(df, location, scale)</code>
</p>
</li>
<li> <p><code>cauchy(location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>For the prior distribution for the intercept, <code>location</code>, 
<code>scale</code>, and <code>df</code> should be scalars. For the prior for the other
coefficients they can either be vectors of length equal to the number of
coefficients (not including the intercept), or they can be scalars, in 
which case they will be recycled to the appropriate length. As the 
degrees of freedom approaches infinity, the Student t distribution 
approaches the normal distribution and if the degrees of freedom are one,
then the Student t distribution is the Cauchy distribution.
</p>
<p>If <code>scale</code> is not specified it will default to <code class="reqn">2.5</code>, unless the
probit link function is used, in which case these defaults are scaled by a
factor of <code>dnorm(0)/dlogis(0)</code>, which is roughly <code class="reqn">1.6</code>.
</p>
<p>If the <code>autoscale</code> argument is <code>TRUE</code>, then the 
scales will be further adjusted as described above in the documentation of 
the <code>autoscale</code> argument in the <strong>Arguments</strong> section.
</p>



<h4>Hierarchical shrinkage family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>hs(df, global_df, global_scale, slab_df, slab_scale)</code>
</p>
</li>
<li> <p><code>hs_plus(df1, df2, global_df, global_scale, slab_df, slab_scale)</code>
</p>
</li></ul>

<p>The hierarchical shrinkage priors are normal with a mean of zero and a 
standard deviation that is also a random variable. The traditional 
hierarchical shrinkage prior utilizes a standard deviation that is 
distributed half Cauchy with a median of zero and a scale parameter that is
also half Cauchy. This is called the &quot;horseshoe prior&quot;. The hierarchical 
shrinkage (<code>hs</code>) prior in the <span class="pkg">rstanarm</span> package instead utilizes 
a regularized horseshoe prior, as described by Piironen and Vehtari (2017),
which recommends setting the <code>global_scale</code> argument equal to the ratio
of the expected number of non-zero coefficients to the expected number of
zero coefficients, divided by the square root of the number of observations.
</p>
<p>The hierarhical shrinkpage plus (<code>hs_plus</code>) prior is similar except 
that the standard deviation that is distributed as the product of two 
independent half Cauchy parameters that are each scaled in a similar way
to the <code>hs</code> prior.
</p>
<p>The hierarchical shrinkage priors have very tall modes and very fat tails.
Consequently, they tend to produce posterior distributions that are very
concentrated near zero, unless the predictor has a strong influence on the
outcome, in which case the prior has little influence. Hierarchical 
shrinkage priors often require you to increase the 
<code><a href="#topic+adapt_delta">adapt_delta</a></code> tuning parameter in order to diminish the number 
of divergent transitions. For more details on tuning parameters and 
divergent transitions see the Troubleshooting section of the <em>How to
Use the rstanarm Package</em> vignette.
</p>



<h4>Laplace family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>laplace(location, scale)</code>
</p>
</li>
<li> <p><code>lasso(df, location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>The Laplace distribution is also known as the double-exponential 
distribution. It is a symmetric distribution with a sharp peak at its mean 
/ median / mode and fairly long tails. This distribution can be motivated 
as a scale mixture of normal distributions and the remarks above about the 
normal distribution apply here as well.
</p>
<p>The lasso approach to supervised learning can be expressed as finding the
posterior mode when the likelihood is Gaussian and the priors on the 
coefficients have independent Laplace distributions. It is commonplace in
supervised learning to choose the tuning parameter by cross-validation,
whereas a more Bayesian approach would be to place a prior on &ldquo;it&rdquo;,
or rather its reciprocal in our case (i.e. <em>smaller</em> values correspond
to more shrinkage toward the prior location vector). We use a chi-square
prior with degrees of freedom equal to that specified in the call to
<code>lasso</code> or, by default, 1. The expectation of a chi-square random
variable is equal to this degrees of freedom and the mode is equal to the
degrees of freedom minus 2, if this difference is positive.
</p>
<p>It is also common in supervised learning to standardize the predictors 
before training the model. We do not recommend doing so. Instead, it is
better to specify <code>autoscale = TRUE</code>, which 
will adjust the scales of the priors according to the dispersion in the
variables. See the documentation of the <code>autoscale</code> argument above 
and also the <code><a href="#topic+prior_summary">prior_summary</a></code> page for more information.
</p>



<h4>Product-normal family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>product_normal(df, location, scale)</code>
</p>
</li></ul>

<p>The product-normal distribution is the product of at least two independent 
normal variates each with mean zero, shifted by the <code>location</code>
parameter. It can be shown that the density of a product-normal variate is
symmetric and infinite at <code>location</code>, so this prior resembles a
&ldquo;spike-and-slab&rdquo; prior for sufficiently large values of the
<code>scale</code> parameter. For better or for worse, this prior may be
appropriate when it is strongly believed (by someone) that a regression
coefficient &ldquo;is&rdquo; equal to the <code>location</code>, parameter even though
no true Bayesian would specify such a prior.
</p>
<p>Each element of <code>df</code> must be an integer of at least <code class="reqn">2</code> because
these &ldquo;degrees of freedom&rdquo; are interpreted as the number of normal
variates being multiplied and then shifted by <code>location</code> to yield the
regression coefficient. Higher degrees of freedom produce a sharper
spike at <code>location</code>.
</p>
<p>Each element of <code>scale</code> must be a non-negative real number that is
interpreted as the standard deviation of the normal variates being
multiplied and then shifted by <code>location</code> to yield the regression
coefficient. In other words, the elements of <code>scale</code> may differ, but
the k-th standard deviation is presumed to hold for all the normal deviates
that are multiplied together and shifted by the k-th element of
<code>location</code> to yield the k-th regression coefficient. The elements of 
<code>scale</code> are not the prior standard deviations of the regression
coefficients. The prior variance of the regression coefficients is equal to
the scale raised to the power of <code class="reqn">2</code> times the corresponding element of
<code>df</code>. Thus, larger values of <code>scale</code> put more prior volume on
values of the regression coefficient that are far from zero.
</p>



<h4>Dirichlet family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>dirichlet(concentration)</code>
</p>
</li></ul>

<p>The Dirichlet distribution is a multivariate generalization of the beta
distribution. It is perhaps the easiest prior distribution to specify
because the concentration parameters can be interpreted as prior counts
(although they need not be integers) of a multinomial random variable.
</p>
<p>The Dirichlet distribution is used in <code><a href="#topic+stan_polr">stan_polr</a></code> for an 
implicit prior on the cutpoints in an ordinal regression model. More
specifically, the Dirichlet prior pertains to the prior probability of
observing each category of the ordinal outcome when the predictors are at
their sample means. Given these prior probabilities, it is straightforward
to add them to form cumulative probabilities and then use an inverse CDF
transformation of the cumulative probabilities to define the cutpoints.
</p>
<p>If a scalar is passed to the <code>concentration</code> argument of the 
<code>dirichlet</code> function, then it is replicated to the appropriate length 
and the Dirichlet distribution is symmetric. If <code>concentration</code> is a
vector and all elements are <code class="reqn">1</code>, then the Dirichlet distribution is
jointly uniform. If all concentration parameters are equal but greater than
<code class="reqn">1</code> then the prior mode is that the categories are equiprobable, and
the larger the value of the identical concentration parameters, the more
sharply peaked the distribution is at the mode. The elements in 
<code>concentration</code> can also be given different values to represent that 
not all outcome categories are a priori equiprobable.
</p>



<h4>Covariance matrices</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>decov(regularization, concentration, shape, scale)</code>
</p>
</li>
<li> <p><code>lkj(regularization, scale, df)</code>
</p>
</li></ul>

<p>(Also see vignette for <code>stan_glmer</code>, 
<a href="https://mc-stan.org/rstanarm/articles/glmer.html"><em>Estimating
Generalized (Non-)Linear Models with Group-Specific Terms with rstanarm</em></a>)
</p>
<p>Covariance matrices are decomposed into correlation matrices and 
variances. The variances are in turn decomposed into the product of a
simplex vector and the trace of the matrix. Finally, the trace is the
product of the order of the matrix and the square of a scale parameter.
This prior on a covariance matrix is represented by the <code>decov</code> 
function.
</p>
<p>The prior for a correlation matrix is called LKJ whose density is 
proportional to the determinant of the correlation matrix raised to the 
power of a positive regularization parameter minus one. If
<code>regularization = 1</code> (the default), then this prior is jointly 
uniform over all correlation matrices of that size. If 
<code>regularization &gt; 1</code>, then the identity matrix is the mode and in the
unlikely case that <code>regularization &lt; 1</code>, the identity matrix is the
trough.
</p>
<p>The trace of a covariance matrix is equal to the sum of the variances. We
set the trace equal to the product of the order of the covariance matrix
and the <em>square</em> of a positive scale parameter. The particular
variances are set equal to the product of a simplex vector &mdash; which is
non-negative and sums to <code class="reqn">1</code> &mdash; and the scalar trace. In other words,
each element of the simplex vector represents the proportion of the trace
attributable to the corresponding variable.
</p>
<p>A symmetric Dirichlet prior is used for the simplex vector, which has a 
single (positive) <code>concentration</code> parameter, which defaults to
<code class="reqn">1</code> and implies that the prior is jointly uniform over the space of
simplex vectors of that size. If <code>concentration &gt; 1</code>, then the prior
mode corresponds to all variables having the same (proportion of total)
variance, which can be used to ensure the the posterior variances are not
zero. As the <code>concentration</code> parameter approaches infinity, this
mode becomes more pronounced. In the unlikely case that 
<code>concentration &lt; 1</code>, the variances are more polarized.
</p>
<p>If all the variables were multiplied by a number, the trace of their 
covariance matrix would increase by that number squared. Thus, it is 
reasonable to use a scale-invariant prior distribution for the positive
scale parameter, and in this case we utilize a Gamma distribution, whose
<code>shape</code> and <code>scale</code> are both <code class="reqn">1</code> by default, implying a
unit-exponential distribution. Set the <code>shape</code> hyperparameter to some
value greater than <code class="reqn">1</code> to ensure that the posterior trace is not zero.
</p>
<p>If <code>regularization</code>, <code>concentration</code>, <code>shape</code> and / or 
<code>scale</code> are positive scalars, then they are recycled to the 
appropriate length. Otherwise, each can be a positive vector of the 
appropriate length, but the appropriate length depends on the number of 
covariance matrices in the model and their sizes. A one-by-one covariance 
matrix is just a variance and thus does not have <code>regularization</code> or 
<code>concentration</code> parameters, but does have <code>shape</code> and 
<code>scale</code> parameters for the prior standard deviation of that 
variable.
</p>
<p>Note that for <code><a href="#topic+stan_mvmer">stan_mvmer</a></code> and <code><a href="#topic+stan_jm">stan_jm</a></code> models an
additional prior distribution is provided through the <code>lkj</code> function.
This prior is in fact currently used as the default for those modelling
functions (although <code>decov</code> is still available as an option if the user
wishes to specify it through the <code>prior_covariance</code> argument). The
<code>lkj</code> prior uses the same decomposition of the covariance matrices
into correlation matrices and variances, however, the variances are not
further decomposed into a simplex vector and the trace; instead the 
standard deviations (square root of the variances) for each of the group
specific parameters are given a half Student t distribution with the 
scale and df parameters specified through the <code>scale</code> and <code>df</code>
arguments to the <code>lkj</code> function. The scale parameter default is 10
which is then autoscaled, whilst the df parameter default is 1 
(therefore equivalent to a half Cauchy prior distribution for the 
standard deviation of each group specific parameter). This prior generally
leads to similar results as the <code>decov</code> prior, but it is also likely
to be **less** diffuse compared with the <code>decov</code> prior; therefore it 
sometimes seems to lead to faster estimation times, hence why it has
been chosen as the default prior for <code><a href="#topic+stan_mvmer">stan_mvmer</a></code> and 
<code><a href="#topic+stan_jm">stan_jm</a></code> where estimation times can be long.
</p>



<h4>R2 family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>R2(location, what)</code>
</p>
</li></ul>

<p>The <code><a href="#topic+stan_lm">stan_lm</a></code>, <code><a href="#topic+stan_aov">stan_aov</a></code>, and 
<code><a href="#topic+stan_polr">stan_polr</a></code> functions allow the user to utilize a function 
called <code>R2</code> to convey prior information about all the parameters. 
This prior hinges on prior beliefs about the location of <code class="reqn">R^2</code>, the 
proportion of variance in the outcome attributable to the predictors, 
which has a <code><a href="stats.html#topic+Beta">Beta</a></code> prior with first shape 
hyperparameter equal to half the number of predictors and second shape 
hyperparameter free. By specifying <code>what</code> to be the prior mode (the
default), mean, median, or expected log of <code class="reqn">R^2</code>, the second shape
parameter for this Beta distribution is determined internally. If
<code>what = 'log'</code>, location should be a negative scalar; otherwise it
should be a scalar on the <code class="reqn">(0,1)</code> interval.
</p>
<p>For example, if <code class="reqn">R^2 = 0.5</code>, then the mode, mean, and median of
the <code><a href="stats.html#topic+Beta">Beta</a></code> distribution are all the same and thus the
second shape parameter is also equal to half the number of predictors.
The second shape parameter of the <code><a href="stats.html#topic+Beta">Beta</a></code> distribution
is actually the same as the shape parameter in the LKJ prior for a
correlation matrix described in the previous subsection. Thus, the smaller 
is <code class="reqn">R^2</code>, the larger is the shape parameter, the smaller are the
prior correlations among the outcome and predictor variables, and the more
concentrated near zero is the prior density for the regression 
coefficients. Hence, the prior on the coefficients is regularizing and 
should yield a posterior distribution with good out-of-sample predictions 
<em>if</em> the prior location of <code class="reqn">R^2</code> is specified in a reasonable 
fashion.
</p>



<h3>Value</h3>

<p>A named list to be used internally by the <span class="pkg">rstanarm</span> model
fitting functions.
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari,
A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis.</em> Chapman &amp; Hall/CRC
Press, London, third edition. <a href="https://stat.columbia.edu/~gelman/book/">https://stat.columbia.edu/~gelman/book/</a>
</p>
<p>Gelman, A., Jakulin, A., Pittau, M. G., and Su, Y. (2008). A weakly
informative default prior distribution for logistic and other regression
models. <em>Annals of Applied Statistics</em>. 2(4), 1360&ndash;1383.
</p>
<p>Piironen, J., and Vehtari, A. (2017). Sparsity information and regularization
in the horseshoe and other shrinkage priors. <a href="https://arxiv.org/abs/1707.01694">https://arxiv.org/abs/1707.01694</a>
</p>
<p>Stan Development Team. <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>


<h3>See Also</h3>

<p>The various vignettes for the <span class="pkg">rstanarm</span> package also discuss 
and demonstrate the use of some of the supported prior distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
fmla &lt;- mpg ~ wt + qsec + drat + am

# Draw from prior predictive distribution (by setting prior_PD = TRUE)
prior_pred_fit &lt;- stan_glm(fmla, data = mtcars, prior_PD = TRUE,
                           chains = 1, seed = 12345, iter = 250, # for speed only
                           prior = student_t(df = 4, 0, 2.5), 
                           prior_intercept = cauchy(0,10), 
                           prior_aux = exponential(1/2))
plot(prior_pred_fit, "hist")


# Can assign priors to names
N05 &lt;- normal(0, 5)
fit &lt;- stan_glm(fmla, data = mtcars, prior = N05, prior_intercept = N05)


# Visually compare normal, student_t, cauchy, laplace, and product_normal
compare_priors &lt;- function(scale = 1, df_t = 2, xlim = c(-10, 10)) {
  dt_loc_scale &lt;- function(x, df, location, scale) { 
    1/scale * dt((x - location)/scale, df)  
  }
  dlaplace &lt;- function(x, location, scale) {
    0.5 / scale * exp(-abs(x - location) / scale)
  }
  dproduct_normal &lt;- function(x, scale) {
    besselK(abs(x) / scale ^ 2, nu = 0) / (scale ^ 2 * pi)
  }
  stat_dist &lt;- function(dist, ...) {
    ggplot2::stat_function(ggplot2::aes_(color = dist), ...)
  }
  ggplot2::ggplot(data.frame(x = xlim), ggplot2::aes(x)) + 
    stat_dist("normal", size = .75, fun = dnorm, 
              args = list(mean = 0, sd = scale)) +
    stat_dist("student_t", size = .75, fun = dt_loc_scale, 
              args = list(df = df_t, location = 0, scale = scale)) +
    stat_dist("cauchy", size = .75, linetype = 2, fun = dcauchy, 
              args = list(location = 0, scale = scale)) + 
    stat_dist("laplace", size = .75, linetype = 2, fun = dlaplace,
              args = list(location = 0, scale = scale)) +
    stat_dist("product_normal", size = .75, linetype = 2, fun = dproduct_normal,
              args = list(scale = 1))            
}
# Cauchy has fattest tails, followed by student_t, laplace, and normal
compare_priors()

# The student_t with df = 1 is the same as the cauchy
compare_priors(df_t = 1) 

# Even a scale of 5 is somewhat large. It gives plausibility to rather 
# extreme values
compare_priors(scale = 5, xlim = c(-20,20)) 

# If you use a prior like normal(0, 1000) to be "non-informative" you are 
# actually saying that a coefficient value of e.g. -500 is quite plausible
compare_priors(scale = 1000, xlim = c(-1000,1000))
}
</code></pre>

<hr>
<h2 id='ps_check'>Graphical checks of the estimated survival function</h2><span id='topic+ps_check'></span>

<h3>Description</h3>

<p>This function plots the estimated marginal survival function based on draws
from the posterior predictive distribution of the fitted joint model, and then 
overlays the Kaplan-Meier curve based on the observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_check(
  object,
  check = "survival",
  limits = c("ci", "none"),
  draws = NULL,
  seed = NULL,
  xlab = NULL,
  ylab = NULL,
  ci_geom_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_check_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by the 
<code><a href="#topic+stan_jm">stan_jm</a></code> modelling function. See 
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_check">check</code></td>
<td>
<p>The type of plot to show. Currently only &quot;survival&quot; is 
allowed, which compares the estimated marginal survival function under
the joint model to the estimated Kaplan-Meier curve based on the 
observed data.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_limits">limits</code></td>
<td>
<p>A quoted character string specifying the type of limits to
include in the plot. Can be one of: <code>"ci"</code> for the Bayesian
posterior uncertainty interval (often known as a credible interval);
or <code>"none"</code> for no interval limits.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of MCMC draws to use to 
to estimate the survival function. The default and maximum number of 
draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_seed">seed</code></td>
<td>
<p>An optional <code><a href="base.html#topic+set.seed">seed</a></code> to use.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_xlab">xlab</code>, <code id="ps_check_+3A_ylab">ylab</code></td>
<td>
<p>An optional axis label passed to 
<code><a href="ggplot2.html#topic+labs">labs</a></code>.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_ci_geom_args">ci_geom_args</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code> and used to control features
of the plotted interval limits. They should be supplied as a named list.</p>
</td></tr>
<tr><td><code id="ps_check_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to 
<code><a href="ggplot2.html#topic+geom_path">geom_line</a></code> and used to control features
of the plotted trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the
<span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_survfit">posterior_survfit</a></code> for the estimated marginal or
subject-specific survival function based on draws of the model parameters
from the posterior distribution, 
<code><a href="#topic+posterior_predict">posterior_predict</a></code> for drawing from the posterior 
predictive distribution for the longitudinal submodel, and 
<code><a href="#topic+pp_check">pp_check</a></code> for graphical checks of the longitudinal submodel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

if (!exists("example_jm")) example(example_jm)
# Compare estimated survival function to Kaplan-Meier curve
ps &lt;- ps_check(example_jm)
ps + 
 ggplot2::scale_color_manual(values = c("red", "black")) + # change colors
 ggplot2::scale_size_manual(values = c(0.5, 3)) + # change line sizes 
 ggplot2::scale_fill_manual(values = c(NA, NA)) # remove fill

}
</code></pre>

<hr>
<h2 id='QR-argument'>The <code>QR</code> argument</h2><span id='topic+QR-argument'></span>

<h3>Description</h3>

<p>Details about the <code>QR</code> argument to <span class="pkg">rstanarm</span>'s modeling
functions.
</p>


<h3>Details</h3>

<p>The <code>QR</code> argument is a logical scalar defaulting to
<code>FALSE</code>, but if <code>TRUE</code> applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code>
decomposition to the design matrix, <code class="reqn">X = Q^\ast R^\ast</code>. 
If <code>autoscale = TRUE</code> (the default) 
in the call to the function passed to the <code>prior</code> argument, then
<code class="reqn">Q^\ast = Q \sqrt{n-1}</code> and 
<code class="reqn">R^\ast = \frac{1}{\sqrt{n-1}} R</code>. When 
<code>autoscale = FALSE</code>, <code class="reqn">R</code> is scaled such that the lower-right
element of <code class="reqn">R^\ast</code> is <code class="reqn">1</code>.
</p>
<p>The coefficients relative to <code class="reqn">Q^\ast</code> are obtained and then 
premultiplied by the inverse of <code class="reqn">R^{\ast}</code> to obtain coefficients 
relative to the original predictors, <code class="reqn">X</code>. Thus, when 
<code>autoscale = FALSE</code>, the coefficient on the last column of <code class="reqn">X</code> 
is the same as the coefficient on the last column of <code class="reqn">Q^\ast</code>.
</p>
<p>These transformations do not change the likelihood of the data but are 
recommended for computational reasons when there are multiple predictors. 
Importantly, while the columns of <code class="reqn">X</code> are almost generally correlated, 
the columns of <code class="reqn">Q^\ast</code> are uncorrelated by design, which often makes 
sampling from the posterior easier. However, because when <code>QR</code> is 
<code>TRUE</code> the <code>prior</code> argument applies to the coefficients relative to 
<code class="reqn">Q^\ast</code> (and those are not very interpretable), setting <code>QR=TRUE</code> 
is only recommended if you do not have an informative prior for the regression
coefficients or if the only informative prior is on the last regression
coefficient (in which case you should set <code>autoscale = FALSE</code> when
specifying such priors). 
</p>
<p>For more details see the Stan case study 
<em>The QR Decomposition For Regression Models</em> at 
<a href="https://mc-stan.org/users/documentation/case-studies/qr_regression.html">https://mc-stan.org/users/documentation/case-studies/qr_regression.html</a>.
</p>


<h3>References</h3>

<p>Stan Development Team. <em>Stan Modeling Language Users Guide and
Reference Manual.</em> <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>survival</dt><dd><p><code><a href="survival.html#topic+Surv">Surv</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rstanarm-datasets'>Datasets for rstanarm examples</h2><span id='topic+rstanarm-datasets'></span><span id='topic+kidiq'></span><span id='topic+roaches'></span><span id='topic+wells'></span><span id='topic+bball1970'></span><span id='topic+bball2006'></span><span id='topic+mortality'></span><span id='topic+tumors'></span><span id='topic+radon'></span><span id='topic+pbcLong'></span><span id='topic+pbcSurv'></span>

<h3>Description</h3>

<p>Small datasets for use in <span class="pkg">rstanarm</span> examples and vignettes.
</p>


<h3>Format</h3>


<dl>
<dt><code>bball1970</code></dt><dd>
<p>Data on hits and at-bats from the 1970 Major League Baseball season for 18
players.
</p>
<p>Source: Efron and Morris (1975).
</p>
<p>18 obs. of 5 variables
</p>

<ul>
<li> <p><code>Player</code> Player's last name
</p>
</li>
<li> <p><code>Hits</code> Number of hits in the first 45 at-bats of the season
</p>
</li>
<li> <p><code>AB</code> Number of at-bats (45 for all players)
</p>
</li>
<li> <p><code>RemainingAB</code> Number of remaining at-bats (different for most players)
</p>
</li>
<li> <p><code>RemainingHits</code> Number of remaining hits
</p>
</li></ul>

</dd>
<dt><code>bball2006</code></dt><dd>
<p>Hits and at-bats for the entire 2006 American League season of Major League
Baseball.
</p>
<p>Source: Carpenter (2009)
</p>
<p>302 obs. of 2 variables
</p>

<ul>
<li> <p><code>y</code> Number of hits
</p>
</li>
<li> <p><code>K</code> Number of at-bats
</p>
</li></ul>

</dd>
<dt><code>kidiq</code></dt><dd>
<p>Data from a survey of adult American women and their children 
(a subsample from the National Longitudinal Survey of Youth).
</p>
<p>Source: Gelman and Hill (2007)
</p>
<p>434 obs. of 4 variables
</p>

<ul>
<li> <p><code>kid_score</code> Child's IQ score
</p>
</li>
<li> <p><code>mom_hs</code> Indicator for whether the mother has a high school degree
</p>
</li>
<li> <p><code>mom_iq</code> Mother's IQ score
</p>
</li>
<li> <p><code>mom_age</code> Mother's age
</p>
</li></ul>

</dd>
<dt><code>mortality</code></dt><dd>
<p>Surgical mortality rates in 12 hospitals performing cardiac surgery
in babies.
</p>
<p>Source: Spiegelhalter et al. (1996).
</p>
<p>12 obs. of 2 variables
</p>

<ul>
<li> <p><code>y</code> Number of deaths
</p>
</li>
<li> <p><code>K</code> Number of surgeries
</p>
</li></ul>

</dd>
<dt><code>pbcLong,pbcSurv</code></dt><dd>
<p>Longitudinal biomarker and time-to-event survival data for 40 patients 
with primary biliary cirrhosis who participated in a randomised 
placebo controlled trial of D-penicillamine conducted at the Mayo
Clinic between 1974 and 1984.
</p>
<p>Source: Therneau and Grambsch (2000)
</p>
<p>304 obs. of 8 variables (<code>pbcLong</code>) and 40 obs. of 7 variables (<code>pbcSurv</code>)
</p>

<ul>
<li> <p><code>age</code> in years
</p>
</li>
<li> <p><code>albumin</code> serum albumin (g/dl)
</p>
</li>
<li> <p><code>logBili</code> logarithm of serum bilirubin
</p>
</li>
<li> <p><code>death</code> indicator of death at endpoint
</p>
</li>
<li> <p><code>futimeYears</code> time (in years) between baseline and  
the earliest of death, transplantion or censoring
</p>
</li>
<li> <p><code>id</code> numeric ID unique to each individual
</p>
</li>
<li> <p><code>platelet</code> platelet count
</p>
</li>
<li> <p><code>sex</code> gender (m = male, f = female)
</p>
</li>
<li> <p><code>status</code> status at endpoint (0 = censored, 
1 = transplant, 2 = dead)
</p>
</li>
<li> <p><code>trt</code> binary treatment code (0 = placebo, 1 = 
D-penicillamine)
</p>
</li>
<li> <p><code>year</code> time (in years) of the longitudinal measurements,
taken as time since baseline)
</p>
</li></ul>

</dd>
<dt><code>radon</code></dt><dd>
<p>Data on radon levels in houses in the state of Minnesota. 
</p>
<p>Source: Gelman and Hill (2007)
</p>
<p>919 obs. of 4 variables
</p>

<ul>
<li> <p><code>log_radon</code> Radon measurement from the house (log scale)
</p>
</li>
<li> <p><code>log_uranium</code> Uranium level in the county (log scale)
</p>
</li>
<li> <p><code>floor</code> Indicator for radon measurement made on the first floor of
the house (0 = basement, 1 = first floor)
</p>
</li>
<li> <p><code>county</code> County name (<code><a href="base.html#topic+factor">factor</a></code>)
</p>
</li></ul>

</dd>
<dt><code>roaches</code></dt><dd>
<p>Data on the efficacy of a pest management system at reducing the number of
roaches in urban apartments.
</p>
<p>Source: Gelman and Hill (2007)
</p>
<p>262 obs. of 6 variables
</p>

<ul>
<li> <p><code>y</code> Number of roaches caught
</p>
</li>
<li> <p><code>roach1</code> Pretreatment number of roaches
</p>
</li>
<li> <p><code>treatment</code> Treatment indicator
</p>
</li>
<li> <p><code>senior</code> Indicator for only elderly residents in building
</p>
</li>
<li> <p><code>exposure2</code> Number of days for which the roach traps were used
</p>
</li></ul>

</dd>
<dt><code>tumors</code></dt><dd>
<p>Tarone (1982) provides a data set of tumor incidence in historical
control groups of rats; specifically endometrial stromal polyps in
female lab rats of type F344.  
</p>
<p>Source: Gelman and Hill (2007)
</p>
<p>71 obs. of 2 variables
</p>

<ul>
<li> <p><code>y</code> Number of rats with tumors
</p>
</li>
<li> <p><code>K</code> Number of rats
</p>
</li></ul>

</dd>
<dt><code>wells</code></dt><dd>
<p>A survey of 3200 residents in a small area of Bangladesh suffering from
arsenic contamination of groundwater. Respondents with elevated arsenic
levels in their wells had been encouraged to switch their water source to a
safe public or private well in the nearby area and the survey was conducted
several years later to learn which of the affected residents had switched
wells.
</p>
<p>Souce: Gelman and Hill (2007)
</p>
<p>3020 obs. of 5 variables
</p>

<ul>
<li> <p><code>switch</code> Indicator for well-switching
</p>
</li>
<li> <p><code>arsenic</code> Arsenic level in respondent's well
</p>
</li>
<li> <p><code>dist</code> Distance (meters) from the respondent's house to the
nearest well with safe drinking water.
</p>
</li>
<li> <p><code>assoc</code> Indicator for member(s) of household participate
in community organizations
</p>
</li>
<li> <p><code>educ</code> Years of education (head of household)
</p>
</li></ul>

</dd>
</dl>



<h3>References</h3>

<p>Carpenter, B. (2009) Bayesian estimators for the beta-binomial model of
batting ability. <a href="https://web.archive.org/web/20220618114439/https://lingpipe-blog.com/2009/09/23/">https://web.archive.org/web/20220618114439/https://lingpipe-blog.com/2009/09/23/</a>
</p>
<p>Efron, B. and Morris, C. (1975) Data analysis using Stein's estimator and its
generalizations. <em>Journal of the American Statistical Association</em>
<strong>70</strong>(350), 311&ndash;319.
</p>
<p>Gelman, A. and Hill, J. (2007). <em>Data Analysis Using
Regression and Multilevel/Hierarchical Models.</em> Cambridge University Press,
Cambridge, UK. <a href="https://stat.columbia.edu/~gelman/arm/">https://stat.columbia.edu/~gelman/arm/</a>
</p>
<p>Spiegelhalter, D., Thomas, A., Best, N., &amp; Gilks, W. (1996) BUGS 0.5 
Examples. MRC Biostatistics Unit, Institute of Public health, Cambridge, UK.
</p>
<p>Tarone, R. E. (1982) The use of historical control information in testing for
a trend in proportions. <em>Biometrics</em> <strong>38</strong>(1):215&ndash;220.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending 
the Cox Model</em>. Springer-Verlag, New York, US.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
# Using 'kidiq' dataset 
fit &lt;- stan_lm(kid_score ~ mom_hs * mom_iq, data = kidiq, 
               prior = R2(location = 0.30, what = "mean"),
               # the next line is only to make the example go fast enough
               chains = 1, iter = 500, seed = 12345)
pp_check(fit, nreps = 20)

bayesplot::color_scheme_set("brightblue")
pp_check(fit, plotfun = "stat_grouped", stat = "median", 
         group = factor(kidiq$mom_hs, labels = c("No HS", "HS")))

}
</code></pre>

<hr>
<h2 id='rstanarm-deprecated'>Deprecated functions</h2><span id='topic+rstanarm-deprecated'></span><span id='topic+prior_options'></span>

<h3>Description</h3>

<p>These functions are deprecated and will be removed in a future release. The 
<strong>Arguments</strong> section below provides details on how the functionality 
obtained via each of the arguments has been replaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_options(
  prior_scale_for_dispersion = 5,
  min_prior_scale = 1e-12,
  scaled = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstanarm-deprecated_+3A_prior_scale_for_dispersion">prior_scale_for_dispersion</code>, <code id="rstanarm-deprecated_+3A_min_prior_scale">min_prior_scale</code>, <code id="rstanarm-deprecated_+3A_scaled">scaled</code></td>
<td>
<p>Arguments to 
deprecated <code>prior_options</code> function. The functionality provided 
by the now deprecated <code>prior_options</code> function has been replaced 
as follows: 
</p>

<dl>
<dt><code>prior_scale_for_dispersion</code></dt><dd>
<p>Instead of using the <code>prior_scale_for_dispersion</code> argument to 
<code>prior_options</code>, priors for these parameters can now be 
specified directly when calling <code><a href="#topic+stan_glm">stan_glm</a></code> (or
<code><a href="#topic+stan_glmer">stan_glmer</a></code>, etc.) using the new <code>prior_aux</code>
argument.
</p>
</dd>
<dt><code>scaled</code></dt><dd>
<p>Instead of setting <code>prior_options(scaled=FALSE)</code>, internal rescaling
is now toggled using the new <code>autoscale</code> arguments to
<code><a href="#topic+normal">normal</a></code>, <code><a href="#topic+student_t">student_t</a></code>, and <code><a href="#topic+cauchy">cauchy</a></code> 
(the other prior distributions do not support 'autoscale').
</p>
</dd>
<dt><code>min_prior_scale</code></dt><dd>
<p>No replacement. <code>min_prior_scale</code> (the minimum possible scale
parameter value that be used for priors) is now fixed to <code>1e-12</code>.
</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='se'>Extract standard errors</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Generic function for extracting standard errors from fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="se_+3A_...">...</code></td>
<td>
<p>Arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard errors of model parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+se.stanreg">se.stanreg</a></code>
</p>

<hr>
<h2 id='stan_aov'>Bayesian regularized linear models via Stan</h2><span id='topic+stan_aov'></span><span id='topic+stan_lm'></span><span id='topic+stan_lm.wfit'></span><span id='topic+stan_lm.fit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for linear modeling with regularizing priors on the model
parameters that are driven by prior beliefs about <code class="reqn">R^2</code>, the proportion
of variance in the outcome attributable to the predictors. See
<code><a href="#topic+priors">priors</a></code> for an explanation of this critical point.
<code><a href="#topic+stan_glm">stan_glm</a></code> with <code>family="gaussian"</code> also estimates a linear
model with normally-distributed errors and allows for various other priors on
the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_aov(
  formula,
  data,
  projections = FALSE,
  contrasts = NULL,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL
)

stan_lm(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_intercept = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL
)

stan_lm.wfit(
  x,
  y,
  w,
  offset = NULL,
  singular.ok = TRUE,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_intercept = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL
)

stan_lm.fit(
  x,
  y,
  offset = NULL,
  singular.ok = TRUE,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_intercept = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_aov_+3A_formula">formula</code>, <code id="stan_aov_+3A_data">data</code>, <code id="stan_aov_+3A_subset">subset</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+lm">lm</a></code>, 
but <em>we strongly advise against omitting the <code>data</code>
argument</em>. Unless <code>data</code> is specified (and is a data frame) many
post-estimation functions (including <code>update</code>, <code>loo</code>,
<code>kfold</code>) are not guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_projections">projections</code></td>
<td>
<p>For <code>stan_aov</code>, a logical scalar (defaulting to
<code>FALSE</code>) indicating whether <code><a href="stats.html#topic+proj">proj</a></code> should be called
on the fit.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_prior">prior</code></td>
<td>
<p>Must be a call to <code><a href="#topic+R2">R2</a></code> with its 
<code>location</code> argument specified or <code>NULL</code>, which would
indicate a standard uniform prior for the <code class="reqn">R^2</code>.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_na.action">na.action</code>, <code id="stan_aov_+3A_singular.ok">singular.ok</code>, <code id="stan_aov_+3A_contrasts">contrasts</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+lm">lm</a></code>, but 
rarely specified.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_model">model</code>, <code id="stan_aov_+3A_offset">offset</code>, <code id="stan_aov_+3A_weights">weights</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+lm">lm</a></code>, but
rarely specified.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_x">x</code>, <code id="stan_aov_+3A_y">y</code></td>
<td>
<p>In <code>stan_lm, stan_aov</code>, logical scalars indicating whether to
return the design matrix and response vector. In <code>stan_lm.fit or stan_lm.wfit</code>,
a design matrix and response vector.</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>Either <code>NULL</code> (the default) or a call to
<code><a href="#topic+normal">normal</a></code>. If a <code><a href="#topic+normal">normal</a></code> prior is specified
without a <code>scale</code>, then the standard deviation is taken to be
the marginal standard deviation of the outcome divided by the square
root of the sample size, which is legitimate because the marginal
standard deviation of the outcome is a primitive parameter being
estimated.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em>. If you prefer
to specify a prior on the intercept without the predictors being
auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_aov_+3A_w">w</code></td>
<td>
<p>Same as in <code>lm.wfit</code> but rarely specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_lm</code> function is similar in syntax to the 
<code><a href="stats.html#topic+lm">lm</a></code> function but rather than choosing the parameters to
minimize the sum of squared residuals, samples from the posterior 
distribution are drawn using MCMC (if <code>algorithm</code> is
<code>"sampling"</code>). The <code>stan_lm</code> function has a formula-based
interface and would usually be called by users but the <code>stan_lm.fit</code>
and <code>stan_lm.wfit</code> functions might be called by other functions that
parse the data themselves and are analogous to <code>lm.fit</code>
and <code>lm.wfit</code> respectively.
</p>
<p>In addition to estimating <code>sigma</code> &mdash; the standard deviation of the
normally-distributed errors &mdash; this model estimates a positive parameter
called <code>log-fit_ratio</code>. If it is positive, the marginal posterior 
variance of the outcome will exceed the sample variance of the outcome
by a multiplicative factor equal to the square of <code>fit_ratio</code>.
Conversely if <code>log-fit_ratio</code> is negative, then the model underfits.
Given the regularizing nature of the priors, a slight underfit is good.
</p>
<p>Finally, the posterior predictive distribution is generated with the
predictors fixed at their sample means. This quantity is useful for
checking convergence because it is reasonably normally distributed
and a function of all the parameters in the model.
</p>
<p>The <code>stan_aov</code> function is similar to <code><a href="stats.html#topic+aov">aov</a></code>, but
does a Bayesian analysis of variance that is basically equivalent to
<code>stan_lm</code> with dummy variables. <code>stan_aov</code> has a somewhat
customized <code><a href="base.html#topic+print">print</a></code> method that prints an ANOVA-like table in
addition to the output printed for <code>stan_lm</code> models.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_lm, stan_aov</code>.
</p>
<p>A <a href="rstan.html#topic+stanfit-class">stanfit</a> object (or a slightly modified 
stanfit object) is returned if <code>stan_lm.fit or stan_lm.wfit</code> is called directly.
</p>


<h3>References</h3>

<p>Lewandowski, D., Kurowicka D., and Joe, H. (2009). Generating random
correlation matrices based on vines and extended onion method. 
<em>Journal of Multivariate Analysis</em>. <strong>100</strong>(9), 1989&ndash;2001.
</p>


<h3>See Also</h3>

<p>The vignettes for <code>stan_lm</code> and <code>stan_aov</code>, which have more
thorough descriptions and examples.
<a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>
<p>Also see <code><a href="#topic+stan_glm">stan_glm</a></code>, which &mdash; if <code>family =
gaussian(link="identity")</code> &mdash; also estimates a linear model with
normally-distributed errors but specifies different priors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {

op &lt;- options(contrasts = c("contr.helmert", "contr.poly"))
fit_aov &lt;- stan_aov(yield ~ block + N*P*K, data = npk,
         prior = R2(0.5), seed = 12345)
options(op)
print(fit_aov)

}
if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386") {
(fit &lt;- stan_lm(mpg ~ wt + qsec + am, data = mtcars, prior = R2(0.75), 
                # the next line is only to make the example go fast enough
                chains = 1, iter = 300, seed = 12345, refresh = 0))
plot(fit, "hist", pars = c("wt", "am", "qsec", "sigma"), 
     transformations = list(sigma = "log"))
}
</code></pre>

<hr>
<h2 id='stan_betareg'>Bayesian beta regression models via Stan</h2><span id='topic+stan_betareg'></span><span id='topic+stan_betareg.fit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Beta regression modeling with optional prior distributions for the 
coefficients, intercept, and auxiliary parameter <code>phi</code> (if applicable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_betareg(
  formula,
  data,
  subset,
  na.action,
  weights,
  offset,
  link = c("logit", "probit", "cloglog", "cauchit", "log", "loglog"),
  link.phi = NULL,
  model = TRUE,
  y = TRUE,
  x = FALSE,
  ...,
  prior = normal(autoscale = TRUE),
  prior_intercept = normal(autoscale = TRUE),
  prior_z = normal(autoscale = TRUE),
  prior_intercept_z = normal(autoscale = TRUE),
  prior_phi = exponential(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE
)

stan_betareg.fit(
  x,
  y,
  z = NULL,
  weights = rep(1, NROW(x)),
  offset = rep(0, NROW(x)),
  link = c("logit", "probit", "cloglog", "cauchit", "log", "loglog"),
  link.phi = NULL,
  ...,
  prior = normal(autoscale = TRUE),
  prior_intercept = normal(autoscale = TRUE),
  prior_z = normal(autoscale = TRUE),
  prior_intercept_z = normal(autoscale = TRUE),
  prior_phi = exponential(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_betareg_+3A_formula">formula</code>, <code id="stan_betareg_+3A_data">data</code>, <code id="stan_betareg_+3A_subset">subset</code></td>
<td>
<p>Same as <code><a href="betareg.html#topic+betareg">betareg</a></code>, 
but <em>we strongly advise against omitting the <code>data</code>
argument</em>. Unless <code>data</code> is specified (and is a data frame) many
post-estimation functions (including <code>update</code>, <code>loo</code>,
<code>kfold</code>) are not guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_na.action">na.action</code></td>
<td>
<p>Same as <code><a href="betareg.html#topic+betareg">betareg</a></code>, but
rarely specified.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_link">link</code></td>
<td>
<p>Character specification of the link function used in the model 
for mu (specified through <code>x</code>). Currently, &quot;logit&quot;, &quot;probit&quot;,
&quot;cloglog&quot;, &quot;cauchit&quot;, &quot;log&quot;, and &quot;loglog&quot; are supported.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_link.phi">link.phi</code></td>
<td>
<p>If applicable, character specification of the link function 
used in the model for <code>phi</code> (specified through <code>z</code>). Currently, 
&quot;identity&quot;, &quot;log&quot; (default), and &quot;sqrt&quot; are supported. Since the &quot;sqrt&quot;
link function is known to be unstable, it is advisable to specify a
different link function (or to model <code>phi</code> as a scalar parameter
instead of via a linear predictor by excluding <code>z</code> from the
<code>formula</code> and excluding <code>link.phi</code>).</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_model">model</code>, <code id="stan_betareg_+3A_offset">offset</code>, <code id="stan_betareg_+3A_weights">weights</code></td>
<td>
<p>Same as <code><a href="betareg.html#topic+betareg">betareg</a></code>.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_x">x</code>, <code id="stan_betareg_+3A_y">y</code></td>
<td>
<p>In <code>stan_betareg</code>, logical scalars indicating whether to
return the design matrix and response vector. In <code>stan_betareg.fit</code>,
a design matrix and response vector.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>The prior distribution for the intercept (after
centering all predictors, see note below).
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_intercept</code> can be a call to
<code>normal</code>, <code>student_t</code> or <code>cauchy</code>. See the
<a href="#topic+priors">priors help page</a> for details on these functions. To omit a
prior on the intercept &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior_intercept</code> can be set to <code>NULL</code>.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em> (you don't
need to manually center them). This is explained further in
[Prior Distributions for rstanarm Models](https://mc-stan.org/rstanarm/articles/priors.html)
If you prefer to specify a prior on the intercept without the predictors
being auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior_z">prior_z</code></td>
<td>
<p>Prior distribution for the coefficients in the model for 
<code>phi</code> (if applicable). Same options as for <code>prior</code>.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior_intercept_z">prior_intercept_z</code></td>
<td>
<p>Prior distribution for the intercept in the model 
for <code>phi</code> (if applicable). Same options as for <code>prior_intercept</code>.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior_phi">prior_phi</code></td>
<td>
<p>The prior distribution for <code>phi</code> if it is <em>not</em> 
modeled as a function of predictors. If <code>z</code> variables are specified 
then <code>prior_phi</code> is ignored and <code>prior_intercept_z</code> and 
<code>prior_z</code> are used to specify the priors on the intercept and
coefficients in the model for <code>phi</code>. When applicable, <code>prior_phi</code>
can be a call to <code>exponential</code> to use an exponential distribution, or
one of <code>normal</code>, <code>student_t</code> or <code>cauchy</code> to use half-normal,
half-t, or half-Cauchy prior. See <code><a href="#topic+priors">priors</a></code> for details on these
functions. To omit a prior &mdash;i.e., to use a flat (improper) uniform
prior&mdash; set <code>prior_phi</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_betareg_+3A_z">z</code></td>
<td>
<p>For <code>stan_betareg.fit</code>, a regressor matrix for <code>phi</code>.
Defaults to an intercept only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_betareg</code> function is similar in syntax to 
<code><a href="betareg.html#topic+betareg">betareg</a></code> but rather than performing maximum 
likelihood estimation, full Bayesian estimation is performed (if 
<code>algorithm</code> is <code>"sampling"</code>) via MCMC. The Bayesian model adds 
priors (independent by default) on the coefficients of the beta regression
model. The <code>stan_betareg</code> function calls the workhorse
<code>stan_betareg.fit</code> function, but it is also possible to call the
latter directly.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_betareg</code>.
</p>
<p>A <a href="rstan.html#topic+stanfit-class">stanfit</a> object (or a slightly modified 
stanfit object) is returned if <code>stan_betareg.fit</code> is called directly.
</p>


<h3>References</h3>

<p>Ferrari, SLP and Cribari-Neto, F (2004). Beta regression for 
modeling rates and proportions. <em>Journal of Applied Statistics</em>.
31(7), 799&ndash;815.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="betareg.html#topic+betareg">betareg</a></code>.
</p>
<p>The vignette for <code>stan_betareg</code>.
<a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
### Simulated data
N &lt;- 200
x &lt;- rnorm(N, 2, 1)
z &lt;- rnorm(N, 2, 1)
mu &lt;- binomial(link = "logit")$linkinv(1 + 0.2*x)
phi &lt;- exp(1.5 + 0.4*z)
y &lt;- rbeta(N, mu * phi, (1 - mu) * phi)
hist(y, col = "dark grey", border = FALSE, xlim = c(0,1))
fake_dat &lt;- data.frame(y, x, z)

fit &lt;- stan_betareg(
  y ~ x | z, data = fake_dat, 
  link = "logit", 
  link.phi = "log", 
  algorithm = "optimizing" # just for speed of example
 ) 
print(fit, digits = 2)
}
</code></pre>

<hr>
<h2 id='stan_biglm'>Bayesian regularized linear but big models via Stan</h2><span id='topic+stan_biglm'></span><span id='topic+stan_biglm.fit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
This is the same model as with <code><a href="#topic+stan_lm">stan_lm</a></code> but it utilizes the
output from <code><a href="biglm.html#topic+biglm">biglm</a></code> in the <span class="pkg">biglm</span> package in order to
proceed when the data is too large to fit in memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_biglm(
  biglm,
  xbar,
  ybar,
  s_y,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_intercept = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL
)

stan_biglm.fit(
  b,
  R,
  SSR,
  N,
  xbar,
  ybar,
  s_y,
  has_intercept = TRUE,
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_intercept = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank", "optimizing"),
  adapt_delta = NULL,
  importance_resampling = TRUE,
  keep_every = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_biglm_+3A_biglm">biglm</code></td>
<td>
<p>The list output by <code><a href="biglm.html#topic+biglm">biglm</a></code> in the <span class="pkg">biglm</span>
package.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_xbar">xbar</code></td>
<td>
<p>A numeric vector of column means in the implicit design matrix 
excluding the intercept for the observations included in the model.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_ybar">ybar</code></td>
<td>
<p>A numeric scalar indicating the mean of the outcome for the
observations included in the model.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_s_y">s_y</code></td>
<td>
<p>A numeric scalar indicating the unbiased sample standard deviation
of the outcome for the observations included in the model.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_prior">prior</code></td>
<td>
<p>Must be a call to <code><a href="#topic+R2">R2</a></code> with its <code>location</code>
argument specified or <code>NULL</code>, which would indicate a standard uniform
prior for the <code class="reqn">R^2</code>.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>Either <code>NULL</code> (the default) or a call to
<code><a href="#topic+normal">normal</a></code>. If a <code><a href="#topic+normal">normal</a></code> prior is specified
without a <code>scale</code>, then the standard deviation is taken to be
the marginal standard deviation of the outcome divided by the square
root of the sample size, which is legitimate because the marginal
standard deviation of the outcome is a primitive parameter being
estimated.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em>. If you prefer
to specify a prior on the intercept without the predictors being
auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_b">b</code></td>
<td>
<p>A numeric vector of OLS coefficients, excluding the intercept</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_r">R</code></td>
<td>
<p>A square upper-triangular matrix from the QR decomposition of the 
design matrix, excluding the intercept</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_ssr">SSR</code></td>
<td>
<p>A numeric scalar indicating the sum-of-squared residuals for OLS</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_n">N</code></td>
<td>
<p>A integer scalar indicating the number of included observations</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_has_intercept">has_intercept</code></td>
<td>
<p>A logical scalar indicating whether to add an intercept 
to the model when estimating it.</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_importance_resampling">importance_resampling</code></td>
<td>
<p>Logical scalar indicating whether to use 
importance resampling when approximating the posterior distribution with
a multivariate normal around the posterior mode, which only applies
when <code>algorithm</code> is <code>"optimizing"</code> but defaults to <code>TRUE</code>
in that case</p>
</td></tr>
<tr><td><code id="stan_biglm_+3A_keep_every">keep_every</code></td>
<td>
<p>Positive integer, which defaults to 1, but can be higher
in order to thin the importance sampling realizations and also only
apples when <code>algorithm</code> is <code>"optimizing"</code> but defaults to
<code>TRUE</code> in that case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_biglm</code> function is intended to be used in the same 
circumstances as the <code><a href="biglm.html#topic+biglm">biglm</a></code> function in the <span class="pkg">biglm</span>
package but with an informative prior on the <code class="reqn">R^2</code> of the regression. 
Like <code><a href="biglm.html#topic+biglm">biglm</a></code>, the memory required to estimate the model 
depends largely on the number of predictors rather than the number of 
observations. However, <code>stan_biglm</code> and <code>stan_biglm.fit</code> have 
additional required arguments that are not necessary in 
<code><a href="biglm.html#topic+biglm">biglm</a></code>, namely <code>xbar</code>, <code>ybar</code>, and <code>s_y</code>.
If any observations have any missing values on any of the predictors or the 
outcome, such observations do not contribute to these statistics.
</p>


<h3>Value</h3>

<p>The output of both <code>stan_biglm</code> and <code>stan_biglm.fit</code> is an
object of <code><a href="rstan.html#topic+stanfit-class">stanfit-class</a></code> rather than
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>, which is more limited and less convenient
but necessitated by the fact that <code>stan_biglm</code> does not bring the full
design matrix into memory. Without the full design matrix,some of the
elements of a <code><a href="#topic+stanreg-objects">stanreg-objects</a></code> object cannot be calculated,
such as residuals. Thus, the functions in the <span class="pkg">rstanarm</span> package that
input <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>, such as 
<code><a href="#topic+posterior_predict">posterior_predict</a></code> cannot be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
# create inputs
ols &lt;- lm(mpg ~ wt + qsec + am, data = mtcars, # all row are complete so ...
          na.action = na.exclude)              # not necessary in this case
b &lt;- coef(ols)[-1]
R &lt;- qr.R(ols$qr)[-1,-1]
SSR &lt;- crossprod(ols$residuals)[1]
not_NA &lt;- !is.na(fitted(ols))
N &lt;- sum(not_NA)
xbar &lt;- colMeans(mtcars[not_NA,c("wt", "qsec", "am")])
y &lt;- mtcars$mpg[not_NA]
ybar &lt;- mean(y)
s_y &lt;- sd(y)
post &lt;- stan_biglm.fit(b, R, SSR, N, xbar, ybar, s_y, prior = R2(.75),
                       # the next line is only to make the example go fast
                       chains = 1, iter = 500, seed = 12345)
cbind(lm = b, stan_lm = rstan::get_posterior_mean(post)[13:15,]) # shrunk
}
</code></pre>

<hr>
<h2 id='stan_clogit'>Conditional logistic (clogit) regression models via Stan</h2><span id='topic+stan_clogit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
A model for case-control studies with optional prior distributions for the
coefficients, intercept, and auxiliary parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_clogit(
  formula,
  data,
  subset,
  na.action = NULL,
  contrasts = NULL,
  ...,
  strata,
  prior = normal(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_clogit_+3A_formula">formula</code>, <code id="stan_clogit_+3A_data">data</code>, <code id="stan_clogit_+3A_subset">subset</code>, <code id="stan_clogit_+3A_na.action">na.action</code>, <code id="stan_clogit_+3A_contrasts">contrasts</code></td>
<td>
<p>Same as for <code><a href="lme4.html#topic+glmer">glmer</a></code>,
except that any global intercept included in the formula will be dropped.
<em>We strongly advise against omitting the <code>data</code> argument</em>. Unless
<code>data</code> is specified (and is a data frame) many post-estimation
functions (including <code>update</code>, <code>loo</code>, <code>kfold</code>) are not
guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_strata">strata</code></td>
<td>
<p>A factor indicating the groups in the data where the number of 
successes (possibly one) is fixed by the research design. It may be useful 
to use <code><a href="base.html#topic+interaction">interaction</a></code> or <code><a href="survival.html#topic+strata">strata</a></code> to
create this factor. However, the <code>strata</code> argument must not rely on
any object besides the <code>data</code> <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code> when lme4-style group-specific
terms are included in the <code>formula</code>. See <code><a href="#topic+decov">decov</a></code> for
more information about the default arguments. Ignored when there are no
group-specific terms.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_clogit_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_clogit</code> function is mostly similar in syntax to 
<code><a href="survival.html#topic+clogit">clogit</a></code> but rather than performing maximum
likelihood estimation of generalized linear models, full Bayesian
estimation is performed (if <code>algorithm</code> is <code>"sampling"</code>) via
MCMC. The Bayesian model adds priors (independent by default) on the
coefficients of the GLM.
</p>
<p>The <code>data.frame</code> passed to the <code>data</code> argument must be sorted by 
the variable passed to the <code>strata</code> argument.
</p>
<p>The <code>formula</code> may have group-specific terms like in
<code><a href="#topic+stan_glmer">stan_glmer</a></code> but should not allow the intercept to vary by the
stratifying variable, since there is no information in the data with which
to estimate such deviations in the intercept.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_clogit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="survival.html#topic+clogit">clogit</a></code>.
</p>
<p>The vignette for Bernoulli and binomial models, which has more
details on using <code>stan_clogit</code>.
<a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
dat &lt;- infert[order(infert$stratum), ] # order by strata
post &lt;- stan_clogit(case ~ spontaneous + induced + (1 | education), 
                    strata = stratum,
                    data = dat,
                    subset = parity &lt;= 2,
                    QR = TRUE,
                    chains = 2, iter = 500) # for speed only

nd &lt;- dat[dat$parity &gt; 2, c("case", "spontaneous", "induced", "education", "stratum")]
# next line would fail without case and stratum variables                                 
pr &lt;- posterior_epred(post, newdata = nd) # get predicted probabilities

# not a random variable b/c probabilities add to 1 within strata
all.equal(rep(sum(nd$case), nrow(pr)), rowSums(pr)) 
}
</code></pre>

<hr>
<h2 id='stan_gamm4'>Bayesian generalized linear additive models with optional group-specific
terms via Stan</h2><span id='topic+stan_gamm4'></span><span id='topic+plot_nonlinear'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for GAMMs with flexible priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_gamm4(
  formula,
  random = NULL,
  family = gaussian(),
  data,
  weights = NULL,
  subset = NULL,
  na.action,
  knots = NULL,
  drop.unused.levels = TRUE,
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_smooth = exponential(autoscale = FALSE),
  prior_aux = exponential(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE
)

plot_nonlinear(
  x,
  smooths,
  ...,
  prob = 0.9,
  facet_args = list(),
  alpha = 1,
  size = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_gamm4_+3A_formula">formula</code>, <code id="stan_gamm4_+3A_random">random</code>, <code id="stan_gamm4_+3A_family">family</code>, <code id="stan_gamm4_+3A_data">data</code>, <code id="stan_gamm4_+3A_knots">knots</code>, <code id="stan_gamm4_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>Same as for 
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code>. <em>We strongly advise against
omitting the <code>data</code> argument</em>. Unless <code>data</code> is specified (and is
a data frame) many post-estimation functions (including <code>update</code>,
<code>loo</code>, <code>kfold</code>) are not guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_subset">subset</code>, <code id="stan_gamm4_+3A_weights">weights</code>, <code id="stan_gamm4_+3A_na.action">na.action</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, 
but rarely specified.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code> (e.g. 
<code>iter</code>, <code>chains</code>, <code>cores</code>, etc.) or to
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code> (if <code>algorithm</code> is <code>"meanfield"</code> or
<code>"fullrank"</code>).</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>The prior distribution for the intercept (after
centering all predictors, see note below).
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_intercept</code> can be a call to
<code>normal</code>, <code>student_t</code> or <code>cauchy</code>. See the
<a href="#topic+priors">priors help page</a> for details on these functions. To omit a
prior on the intercept &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior_intercept</code> can be set to <code>NULL</code>.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em> (you don't
need to manually center them). This is explained further in
[Prior Distributions for rstanarm Models](https://mc-stan.org/rstanarm/articles/priors.html)
If you prefer to specify a prior on the intercept without the predictors
being auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior_smooth">prior_smooth</code></td>
<td>
<p>The prior distribution for the hyperparameters in GAMs,
with lower values yielding less flexible smooth functions.
</p>
<p><code>prior_smooth</code> can be a call to <code>exponential</code> to 
use an exponential distribution, or <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>, which results in a half-normal, half-t, or half-Cauchy 
prior. See <code><a href="#topic+priors">priors</a></code> for details on these functions. To omit a 
prior &mdash;i.e., to use a flat (improper) uniform prior&mdash; set 
<code>prior_smooth</code> to <code>NULL</code>. The number of hyperparameters depends
on the model specification but a scalar prior will be recylced as necessary
to the appropriate length.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior_aux">prior_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameter (if
applicable). The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>prior_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>prior_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>prior_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters.
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_aux</code> can be a call to
<code>exponential</code> to use an exponential distribution, or <code>normal</code>,
<code>student_t</code> or <code>cauchy</code>, which results in a half-normal, half-t,
or half-Cauchy prior. See <code><a href="#topic+priors">priors</a></code> for details on these
functions. To omit a prior &mdash;i.e., to use a flat (improper) uniform
prior&mdash; set <code>prior_aux</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="#topic+decov">decov</a></code> for
more information about the default arguments.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_x">x</code></td>
<td>
<p>An object produced by <code>stan_gamm4</code>.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_smooths">smooths</code></td>
<td>
<p>An optional character vector specifying a subset of the smooth
functions specified in the call to <code>stan_gamm4</code>. The default is
include all smooth terms.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_prob">prob</code></td>
<td>
<p>For univarite smooths, a scalar between 0 and 1 governing the
width of the uncertainty interval.</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_facet_args">facet_args</code></td>
<td>
<p>An optional named list of arguments passed to 
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> (other than the <code>facets</code> argument).</p>
</td></tr>
<tr><td><code id="stan_gamm4_+3A_alpha">alpha</code>, <code id="stan_gamm4_+3A_size">size</code></td>
<td>
<p>For univariate smooths, passed to 
<code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code>. For bivariate smooths, <code>size/2</code> is
passed to <code><a href="ggplot2.html#topic+geom_contour">geom_contour</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_gamm4</code> function is similar in syntax to 
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code> in the <span class="pkg">gamm4</span> package. But rather than performing 
(restricted) maximum likelihood estimation with the <span class="pkg">lme4</span> package,
the <code>stan_gamm4</code> function utilizes MCMC to perform Bayesian 
estimation. The Bayesian model adds priors on the common regression 
coefficients (in the same way as <code><a href="#topic+stan_glm">stan_glm</a></code>), priors on the 
standard deviations of the smooth terms, and a prior on the decomposition
of the covariance matrices of any group-specific parameters (as in 
<code><a href="#topic+stan_glmer">stan_glmer</a></code>). Estimating these models via MCMC avoids
the optimization issues that often crop up with GAMMs and provides better
estimates for the uncertainty in the parameter estimates. 
</p>
<p>See <code><a href="gamm4.html#topic+gamm4">gamm4</a></code> for more information about the model
specicification and <code><a href="#topic+priors">priors</a></code> for more information about the
priors on the main coefficients. The <code>formula</code> should include at least
one smooth term, which can be specified in any way that is supported by the
<code><a href="mgcv.html#topic+jagam">jagam</a></code> function in the <span class="pkg">mgcv</span> package. The 
<code>prior_smooth</code> argument should be used to specify a prior on the unknown
standard deviations that govern how smooth the smooth function is. The
<code>prior_covariance</code> argument can be used to specify the prior on the
components of the covariance matrix for any (optional) group-specific terms.
The <code><a href="gamm4.html#topic+gamm4">gamm4</a></code> function in the <span class="pkg">gamm4</span> package uses
group-specific terms to implement the departure from linearity in the smooth
terms, but that is not the case for <code>stan_gamm4</code> where the group-specific
terms are exactly the same as in <code><a href="#topic+stan_glmer">stan_glmer</a></code>.
</p>
<p>The <code>plot_nonlinear</code> function creates a ggplot object with one facet for
each smooth function specified in the call to <code>stan_gamm4</code> in the case
where all smooths are univariate. A subset of the smooth functions can be 
specified using the <code>smooths</code> argument, which is necessary to plot a
bivariate smooth or to exclude the bivariate smooth and plot the univariate
ones. In the bivariate case, a plot is produced using 
<code><a href="ggplot2.html#topic+geom_contour">geom_contour</a></code>. In the univariate case, the resulting
plot is conceptually similar to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code> except the 
outer lines here demark the edges of posterior uncertainty intervals 
(credible intervals) rather than confidence intervals and the inner line
is the posterior median of the function rather than the function implied
by a point estimate. To change the colors used in the plot see 
<code><a href="bayesplot.html#topic+bayesplot-colors">color_scheme_set</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_gamm4</code>.
</p>
<p><code>plot_nonlinear</code> returns a ggplot object.
</p>


<h3>References</h3>

<p>Crainiceanu, C., Ruppert D., and Wand, M. (2005). Bayesian analysis for 
penalized spline regression using WinBUGS. <em>Journal of Statistical
Software</em>. <strong>14</strong>(14), 1&ndash;22. 
<a href="https://www.jstatsoft.org/article/view/v014i14">https://www.jstatsoft.org/article/view/v014i14</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code>.
</p>
<p>The vignette for <code>stan_glmer</code>, which also discusses
<code>stan_gamm4</code>. <a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
# from example(gamm4, package = "gamm4"), prefixing gamm4() call with stan_

dat &lt;- mgcv::gamSim(1, n = 400, scale = 2) ## simulate 4 term additive truth
## Now add 20 level random effect `fac'...
dat$fac &lt;- fac &lt;- as.factor(sample(1:20, 400, replace = TRUE))
dat$y &lt;- dat$y + model.matrix(~ fac - 1) %*% rnorm(20) * .5

br &lt;- stan_gamm4(y ~ s(x0) + x1 + s(x2), data = dat, random = ~ (1 | fac), 
                 chains = 1, iter = 500) # for example speed
print(br)
plot_nonlinear(br)
plot_nonlinear(br, smooths = "s(x0)", alpha = 2/3)

}
</code></pre>

<hr>
<h2 id='stan_glm'>Bayesian generalized linear models via Stan</h2><span id='topic+stan_glm'></span><span id='topic+stan_glm.nb'></span><span id='topic+stan_glm.fit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Generalized linear modeling with optional prior distributions for the
coefficients, intercept, and auxiliary parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_glm(
  formula,
  family = gaussian(),
  data,
  weights,
  subset,
  na.action = NULL,
  offset = NULL,
  model = TRUE,
  x = FALSE,
  y = TRUE,
  contrasts = NULL,
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  mean_PPD = algorithm != "optimizing" &amp;&amp; !prior_PD,
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE
)

stan_glm.nb(
  formula,
  data,
  weights,
  subset,
  na.action = NULL,
  offset = NULL,
  model = TRUE,
  x = FALSE,
  y = TRUE,
  contrasts = NULL,
  link = "log",
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  mean_PPD = algorithm != "optimizing",
  adapt_delta = NULL,
  QR = FALSE
)

stan_glm.fit(
  x,
  y,
  weights = rep(1, NROW(y)),
  offset = rep(0, NROW(y)),
  family = gaussian(),
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_smooth = exponential(autoscale = FALSE),
  prior_ops = NULL,
  group = list(),
  prior_PD = FALSE,
  algorithm = c("sampling", "optimizing", "meanfield", "fullrank"),
  mean_PPD = algorithm != "optimizing" &amp;&amp; !prior_PD,
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE,
  importance_resampling = algorithm != "sampling",
  keep_every = algorithm != "sampling"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_glm_+3A_formula">formula</code>, <code id="stan_glm_+3A_data">data</code>, <code id="stan_glm_+3A_subset">subset</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, 
but <em>we strongly advise against omitting the <code>data</code>
argument</em>. Unless <code>data</code> is specified (and is a data frame) many
post-estimation functions (including <code>update</code>, <code>loo</code>,
<code>kfold</code>) are not guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_family">family</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, except negative binomial GLMs
are also possible using the <code><a href="#topic+neg_binomial_2">neg_binomial_2</a></code> family object.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_na.action">na.action</code>, <code id="stan_glm_+3A_contrasts">contrasts</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, but
rarely specified.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_model">model</code>, <code id="stan_glm_+3A_offset">offset</code>, <code id="stan_glm_+3A_weights">weights</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_x">x</code></td>
<td>
<p>In <code>stan_glm</code>, logical scalar indicating whether to
return the design matrix. In <code>stan_glm.fit</code>, usually a design matrix
but can also be a list of design matrices with the same number of rows, in
which case the first element of the list is interpreted as the primary design
matrix and the remaining list elements collectively constitute a basis for a
smooth nonlinear function of the predictors indicated by the <code>formula</code>
argument to <code><a href="#topic+stan_gamm4">stan_gamm4</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_y">y</code></td>
<td>
<p>In <code>stan_glm</code>, logical scalar indicating whether to
return the response vector. In <code>stan_glm.fit</code>, a response vector.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>The prior distribution for the intercept (after
centering all predictors, see note below).
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_intercept</code> can be a call to
<code>normal</code>, <code>student_t</code> or <code>cauchy</code>. See the
<a href="#topic+priors">priors help page</a> for details on these functions. To omit a
prior on the intercept &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior_intercept</code> can be set to <code>NULL</code>.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em> (you don't
need to manually center them). This is explained further in
[Prior Distributions for rstanarm Models](https://mc-stan.org/rstanarm/articles/priors.html)
If you prefer to specify a prior on the intercept without the predictors
being auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_aux">prior_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameter (if
applicable). The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>prior_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>prior_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>prior_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters.
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_aux</code> can be a call to
<code>exponential</code> to use an exponential distribution, or <code>normal</code>,
<code>student_t</code> or <code>cauchy</code>, which results in a half-normal, half-t,
or half-Cauchy prior. See <code><a href="#topic+priors">priors</a></code> for details on these
functions. To omit a prior &mdash;i.e., to use a flat (improper) uniform
prior&mdash; set <code>prior_aux</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_mean_ppd">mean_PPD</code></td>
<td>
<p>A logical value indicating whether the sample mean of the
posterior predictive distribution of the outcome should be calculated in
the <code>generated quantities</code> block. If <code>TRUE</code> then <code>mean_PPD</code>
is computed and displayed as a diagnostic in the
<a href="#topic+print.stanreg">printed output</a>. The default is <code>TRUE</code> except if
<code>algorithm=="optimizing"</code>. A useful heuristic is to check if
<code>mean_PPD</code> is plausible when compared to <code>mean(y)</code>. If it is
plausible then this does <em>not</em> mean that the model is good in general
(only that it can reproduce the sample mean), but if <code>mean_PPD</code> is
implausible then there may be something wrong, e.g., severe model
misspecification, problems with the data and/or priors, computational
issues, etc.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_link">link</code></td>
<td>
<p>For <code>stan_glm.nb</code> only, the link function to use. See 
<code><a href="#topic+neg_binomial_2">neg_binomial_2</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_smooth">prior_smooth</code></td>
<td>
<p>The prior distribution for the hyperparameters in GAMs,
with lower values yielding less flexible smooth functions.
</p>
<p><code>prior_smooth</code> can be a call to <code>exponential</code> to 
use an exponential distribution, or <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>, which results in a half-normal, half-t, or half-Cauchy 
prior. See <code><a href="#topic+priors">priors</a></code> for details on these functions. To omit a 
prior &mdash;i.e., to use a flat (improper) uniform prior&mdash; set 
<code>prior_smooth</code> to <code>NULL</code>. The number of hyperparameters depends
on the model specification but a scalar prior will be recylced as necessary
to the appropriate length.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_prior_ops">prior_ops</code></td>
<td>
<p>Deprecated. See <a href="#topic+rstanarm-deprecated">rstanarm-deprecated</a> for details.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_group">group</code></td>
<td>
<p>A list, possibly of length zero (the default), but otherwise
having the structure of that produced by <code><a href="lme4.html#topic+mkReTrms">mkReTrms</a></code> to
indicate the group-specific part of the model. In addition, this list must
have elements for the <code>regularization</code>, <code>concentration</code> 
<code>shape</code>, and <code>scale</code> components of a <code><a href="#topic+decov">decov</a></code>
prior for the covariance matrices among the group-specific coefficients.</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_importance_resampling">importance_resampling</code></td>
<td>
<p>Logical scalar indicating whether to use 
importance resampling when approximating the posterior distribution with
a multivariate normal around the posterior mode, which only applies
when <code>algorithm</code> is <code>"optimizing"</code> but defaults to <code>TRUE</code>
in that case</p>
</td></tr>
<tr><td><code id="stan_glm_+3A_keep_every">keep_every</code></td>
<td>
<p>Positive integer, which defaults to 1, but can be higher
in order to &quot;thin&quot; the importance sampling realizations. Applies only
when <code>importance_resampling=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_glm</code> function is similar in syntax to 
<code><a href="stats.html#topic+glm">glm</a></code> but rather than performing maximum likelihood 
estimation of generalized linear models, full Bayesian estimation is 
performed (if <code>algorithm</code> is <code>"sampling"</code>) via MCMC. The Bayesian
model adds priors (independent by default) on the coefficients of the GLM.
The <code>stan_glm</code> function calls the workhorse <code>stan_glm.fit</code>
function, but it is also possible to call the latter directly.
</p>
<p>The <code>stan_glm.nb</code> function, which takes the extra argument 
<code>link</code>, is a wrapper for <code>stan_glm</code> with <code>family = 
  <a href="#topic+neg_binomial_2">neg_binomial_2</a>(link)</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_glm, stan_glm.nb</code>.
</p>
<p>A <a href="rstan.html#topic+stanfit-class">stanfit</a> object (or a slightly modified 
stanfit object) is returned if <code>stan_glm.fit</code> is called directly.
</p>


<h3>References</h3>

<p>Gelman, A. and Hill, J. (2007). <em>Data Analysis Using
Regression and Multilevel/Hierarchical Models.</em> Cambridge University Press,
Cambridge, UK. (Ch. 3-6)
</p>
<p>Muth, C., Oravecz, Z., and Gabry, J. (2018)
User-friendly Bayesian regression modeling: A tutorial with rstanarm and shinystan.
<em>The Quantitative Methods for Psychology</em>. 14(2), 99&ndash;119.
<a href="https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf">https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p>The various vignettes for <code>stan_glm</code> at
<a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
### Linear regression
mtcars$mpg10 &lt;- mtcars$mpg / 10
fit &lt;- stan_glm(
  mpg10 ~ wt + cyl + am,            
  data = mtcars, 
  QR = TRUE,
  # for speed of example only (default is "sampling")
  algorithm = "fullrank",
  refresh = 0 
 ) 
                
plot(fit, prob = 0.5)
plot(fit, prob = 0.5, pars = "beta")
plot(fit, "hist", pars = "sigma")

### Logistic regression
head(wells)
wells$dist100 &lt;- wells$dist / 100
fit2 &lt;- stan_glm(
  switch ~ dist100 + arsenic, 
  data = wells, 
  family = binomial(link = "logit"), 
  prior_intercept = normal(0, 10),
  QR = TRUE,
  refresh = 0,
  # for speed of example only
  chains = 2, iter = 200 
)
print(fit2)
prior_summary(fit2)

# ?bayesplot::mcmc_areas
plot(fit2, plotfun = "areas", prob = 0.9,
     pars = c("(Intercept)", "arsenic"))

# ?bayesplot::ppc_error_binned
pp_check(fit2, plotfun = "error_binned") 


### Poisson regression (example from help("glm")) 
count_data &lt;- data.frame(
 counts = c(18,17,15,20,10,20,25,13,12),
 outcome = gl(3,1,9),
 treatment = gl(3,3)
)
fit3 &lt;- stan_glm(
  counts ~ outcome + treatment, 
  data = count_data, 
  family = poisson(link="log"),
  prior = normal(0, 2),
  refresh = 0,
  # for speed of example only
  chains = 2, iter = 250 
) 
print(fit3)

bayesplot::color_scheme_set("viridis")
plot(fit3)
plot(fit3, regex_pars = c("outcome", "treatment"))
plot(fit3, plotfun = "combo", regex_pars = "treatment") # ?bayesplot::mcmc_combo
posterior_vs_prior(fit3, regex_pars = c("outcome", "treatment"))

### Gamma regression (example from help("glm"))
clotting &lt;- data.frame(log_u = log(c(5,10,15,20,30,40,60,80,100)),
                       lot1 = c(118,58,42,35,27,25,21,19,18),
                       lot2 = c(69,35,26,21,18,16,13,12,12))
fit4 &lt;- stan_glm(
  lot1 ~ log_u, 
  data = clotting, 
  family = Gamma(link="log"),
  iter = 500, # for speed of example only
  refresh = 0
 ) 
print(fit4, digits = 2)

fit5 &lt;- update(fit4, formula = lot2 ~ log_u)

# ?bayesplot::ppc_dens_overlay
bayesplot::bayesplot_grid(
  pp_check(fit4, seed = 123), 
  pp_check(fit5, seed = 123),
  titles = c("lot1", "lot2")
) 


### Negative binomial regression
fit6 &lt;- stan_glm.nb(
  Days ~ Sex/(Age + Eth*Lrn), 
  data = MASS::quine, 
  link = "log", 
  prior_aux = exponential(1.5, autoscale=TRUE),
  chains = 2, iter = 200, # for speed of example only
  refresh = 0
) 

prior_summary(fit6)
bayesplot::color_scheme_set("brightblue")
plot(fit6)
pp_check(fit6, plotfun = "hist", nreps = 5) # ?bayesplot::ppc_hist

# 80% interval of estimated reciprocal_dispersion parameter
posterior_interval(fit6, pars = "reciprocal_dispersion", prob = 0.8)
plot(fit6, "areas", pars = "reciprocal_dispersion", prob = 0.8)

}
</code></pre>

<hr>
<h2 id='stan_glmer'>Bayesian generalized linear models with group-specific terms via Stan</h2><span id='topic+stan_glmer'></span><span id='topic+stan_lmer'></span><span id='topic+stan_glmer.nb'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for GLMs with group-specific coefficients that have 
unknown covariance matrices with flexible priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_glmer(
  formula,
  data = NULL,
  family = gaussian,
  subset,
  weights,
  na.action = getOption("na.action", "na.omit"),
  offset,
  contrasts = NULL,
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE
)

stan_lmer(
  formula,
  data = NULL,
  subset,
  weights,
  na.action = getOption("na.action", "na.omit"),
  offset,
  contrasts = NULL,
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE
)

stan_glmer.nb(
  formula,
  data = NULL,
  subset,
  weights,
  na.action = getOption("na.action", "na.omit"),
  offset,
  contrasts = NULL,
  link = "log",
  ...,
  prior = default_prior_coef(family),
  prior_intercept = default_prior_intercept(family),
  prior_aux = exponential(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_glmer_+3A_formula">formula</code>, <code id="stan_glmer_+3A_data">data</code></td>
<td>
<p>Same as for <code><a href="lme4.html#topic+glmer">glmer</a></code>. <em>We
strongly advise against omitting the <code>data</code> argument</em>. Unless 
<code>data</code> is specified (and is a data frame) many post-estimation 
functions (including <code>update</code>, <code>loo</code>, <code>kfold</code>) are not 
guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_family">family</code></td>
<td>
<p>Same as for <code><a href="lme4.html#topic+glmer">glmer</a></code> except it is also
possible to use <code>family=mgcv::betar</code> to estimate a Beta regression
with <code>stan_glmer</code>.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_subset">subset</code>, <code id="stan_glmer_+3A_weights">weights</code>, <code id="stan_glmer_+3A_offset">offset</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_na.action">na.action</code>, <code id="stan_glmer_+3A_contrasts">contrasts</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, but rarely 
specified.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_...">...</code></td>
<td>
<p>For <code>stan_glmer</code>, further arguments passed to 
<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code> (e.g. <code>iter</code>, <code>chains</code>, 
<code>cores</code>, etc.) or to <code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code> (if <code>algorithm</code> is 
<code>"meanfield"</code> or <code>"fullrank"</code>). For <code>stan_lmer</code> and 
<code>stan_glmer.nb</code>, <code>...</code> should also contain all relevant arguments
to pass to <code>stan_glmer</code> (except <code>family</code>).</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>The prior distribution for the intercept (after
centering all predictors, see note below).
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_intercept</code> can be a call to
<code>normal</code>, <code>student_t</code> or <code>cauchy</code>. See the
<a href="#topic+priors">priors help page</a> for details on these functions. To omit a
prior on the intercept &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior_intercept</code> can be set to <code>NULL</code>.
</p>
<p><strong>Note:</strong> If using a dense representation of the design matrix
&mdash;i.e., if the <code>sparse</code> argument is left at its default value of
<code>FALSE</code>&mdash; then the prior distribution for the intercept is set so it
applies to the value <em>when all predictors are centered</em> (you don't
need to manually center them). This is explained further in
[Prior Distributions for rstanarm Models](https://mc-stan.org/rstanarm/articles/priors.html)
If you prefer to specify a prior on the intercept without the predictors
being auto-centered, then you have to omit the intercept from the
<code><a href="stats.html#topic+formula">formula</a></code> and include a column of ones as a predictor,
in which case some element of <code>prior</code> specifies the prior on it,
rather than <code>prior_intercept</code>. Regardless of how
<code>prior_intercept</code> is specified, the reported <em>estimates</em> of the
intercept always correspond to a parameterization without centered
predictors (i.e., same as in <code>glm</code>).</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_prior_aux">prior_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameter (if
applicable). The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>prior_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>prior_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>prior_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters.
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_aux</code> can be a call to
<code>exponential</code> to use an exponential distribution, or <code>normal</code>,
<code>student_t</code> or <code>cauchy</code>, which results in a half-normal, half-t,
or half-Cauchy prior. See <code><a href="#topic+priors">priors</a></code> for details on these
functions. To omit a prior &mdash;i.e., to use a flat (improper) uniform
prior&mdash; set <code>prior_aux</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="#topic+decov">decov</a></code> for
more information about the default arguments.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr><td><code id="stan_glmer_+3A_link">link</code></td>
<td>
<p>For <code>stan_glmer.nb</code> only, the link function to use. See 
<code><a href="#topic+neg_binomial_2">neg_binomial_2</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_glmer</code> function is similar in syntax to 
<code><a href="lme4.html#topic+glmer">glmer</a></code> but rather than performing (restricted) maximum 
likelihood estimation of generalized linear models, Bayesian estimation is 
performed via MCMC. The Bayesian model adds priors on the 
regression coefficients (in the same way as <code><a href="#topic+stan_glm">stan_glm</a></code>) and
priors on the terms of a decomposition of the covariance matrices of the
group-specific parameters. See <code><a href="#topic+priors">priors</a></code> for more information
about the priors.
</p>
<p>The <code>stan_lmer</code> function is equivalent to <code>stan_glmer</code> with 
<code>family = gaussian(link = "identity")</code>. 
</p>
<p>The <code>stan_glmer.nb</code> function, which takes the extra argument 
<code>link</code>, is a wrapper for <code>stan_glmer</code> with <code>family = 
  <a href="#topic+neg_binomial_2">neg_binomial_2</a>(link)</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_glmer, stan_lmer, stan_glmer.nb</code>.
</p>
<p>A list with classes <code>stanreg</code>, <code>glm</code>, <code>lm</code>, 
and <code>lmerMod</code>. The conventions for the parameter names are the
same as in the lme4 package with the addition that the standard
deviation of the errors is called <code>sigma</code> and the variance-covariance
matrix of the group-specific deviations from the common parameters is
called <code>Sigma</code>, even if this variance-covariance matrix only has
one row and one column (in which case it is just the group-level variance).
</p>


<h3>References</h3>

<p>Gelman, A. and Hill, J. (2007). <em>Data Analysis Using
Regression and Multilevel/Hierarchical Models.</em> Cambridge University Press,
Cambridge, UK. (Ch. 11-15)
</p>
<p>Muth, C., Oravecz, Z., and Gabry, J. (2018)
User-friendly Bayesian regression modeling: A tutorial with rstanarm and shinystan.
<em>The Quantitative Methods for Psychology</em>. 14(2), 99&ndash;119.
<a href="https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf">https://www.tqmp.org/RegularArticles/vol14-2/p099/p099.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="lme4.html#topic+glmer">glmer</a></code>.
</p>
<p>The vignette for <code>stan_glmer</code> and the <em>Hierarchical 
Partial Pooling</em> vignette. <a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
# see help(example_model) for details on the model below
if (!exists("example_model")) example(example_model) 
print(example_model, digits = 1)
}
</code></pre>

<hr>
<h2 id='stan_jm'>Bayesian joint longitudinal and time-to-event models via Stan</h2><span id='topic+stan_jm'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Fits a shared parameter joint model for longitudinal and time-to-event 
(e.g. survival) data under a Bayesian framework using Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_jm(
  formulaLong,
  dataLong,
  formulaEvent,
  dataEvent,
  time_var,
  id_var,
  family = gaussian,
  assoc = "etavalue",
  lag_assoc = 0,
  grp_assoc,
  scale_assoc = NULL,
  epsilon = 1e-05,
  basehaz = c("bs", "weibull", "piecewise"),
  basehaz_ops,
  qnodes = 15,
  init = "prefit",
  weights,
  priorLong = normal(autoscale = TRUE),
  priorLong_intercept = normal(autoscale = TRUE),
  priorLong_aux = cauchy(0, 5, autoscale = TRUE),
  priorEvent = normal(autoscale = TRUE),
  priorEvent_intercept = normal(autoscale = TRUE),
  priorEvent_aux = cauchy(autoscale = TRUE),
  priorEvent_assoc = normal(autoscale = TRUE),
  prior_covariance = lkj(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  max_treedepth = 10L,
  QR = FALSE,
  sparse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_jm_+3A_formulalong">formulaLong</code></td>
<td>
<p>A two-sided linear formula object describing both the 
fixed-effects and random-effects parts of the longitudinal submodel,
similar in vein to formula specification in the <strong>lme4</strong> package
(see <code><a href="lme4.html#topic+glmer">glmer</a></code> or the <strong>lme4</strong> vignette for details). 
Note however that the double bar (<code>||</code>) notation is not allowed 
when specifying the random-effects parts of the formula, and neither
are nested grouping factors (e.g. <code>(1 | g1/g2))</code> or 
<code>(1 | g1:g2)</code>, where <code>g1</code>, <code>g2</code> are grouping factors. 
Offset terms can also be included in the model formula.
For a multivariate joint model (i.e. more than one longitudinal marker) 
this should be a list of such formula objects, with each element
of the list providing the formula for one of the longitudinal submodels.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_datalong">dataLong</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formulaLong</code>. If fitting a multivariate joint model, then this can
be either a single data frame which contains the data for all 
longitudinal submodels, or it can be a list of data frames where each
element of the list provides the data for one of the longitudinal 
submodels.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_formulaevent">formulaEvent</code></td>
<td>
<p>A two-sided formula object describing the event
submodel. The left hand side of the formula should be a <code>Surv()</code> 
object. See <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_dataevent">dataEvent</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formulaEvent</code>.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_time_var">time_var</code></td>
<td>
<p>A character string specifying the name of the variable 
in <code>dataLong</code> which represents time.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_id_var">id_var</code></td>
<td>
<p>A character string specifying the name of the variable in
<code>dataLong</code> which distinguishes between individuals. This can be
left unspecified if there is only one grouping factor (which is assumed
to be the individual). If there is more than one grouping factor (i.e.
clustering beyond the level of the individual) then the <code>id_var</code>
argument must be specified.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_family">family</code></td>
<td>
<p>The family (and possibly also the link function) for the 
longitudinal submodel(s). See <code><a href="lme4.html#topic+glmer">glmer</a></code> for details. 
If fitting a multivariate joint model, then this can optionally be a
list of families, in which case each element of the list specifies the
family for one of the longitudinal submodels.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_assoc">assoc</code></td>
<td>
<p>A character string or character vector specifying the joint
model association structure. Possible association structures that can
be used include: &quot;etavalue&quot; (the default); &quot;etaslope&quot;; &quot;etaauc&quot;; 
&quot;muvalue&quot;; &quot;muslope&quot;; &quot;muauc&quot;; &quot;shared_b&quot;; &quot;shared_coef&quot;; or &quot;null&quot;. 
These are described in the <strong>Details</strong> section below. For a multivariate 
joint model, different association structures can optionally be used for 
each longitudinal submodel by specifying a list of character
vectors, with each element of the list specifying the desired association 
structure for one of the longitudinal submodels. Specifying <code>assoc = NULL</code>
will fit a joint model with no association structure (equivalent  
to fitting separate longitudinal and time-to-event models). It is also 
possible to include interaction terms between the association term 
(&quot;etavalue&quot;, &quot;etaslope&quot;, &quot;muvalue&quot;, &quot;muslope&quot;) and observed data/covariates. 
It is also possible, when fitting a multivariate joint model, to include 
interaction terms between the association terms (&quot;etavalue&quot; or &quot;muvalue&quot;) 
corresponding to the different longitudinal outcomes. See the 
<strong>Details</strong> section as well as the <strong>Examples</strong> below.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_lag_assoc">lag_assoc</code></td>
<td>
<p>A non-negative scalar specifying the time lag that should be
used for the association structure. That is, the hazard of the event at 
time <em>t</em> will be assumed to be associated with the value/slope/auc of 
the longitudinal marker at time <em>t-u</em>, where <em>u</em> is the time lag.
If fitting a multivariate joint model, then a different time lag can be used
for each longitudinal marker by providing a numeric vector of lags, otherwise
if a scalar is provided then the specified time lag will be used for all 
longitudinal markers. Note however that only one time lag  can be specified 
for linking each longitudinal marker to the 
event, and that that time lag will be used for all association structure
types (e.g. <code>"etavalue"</code>, <code>"etaslope"</code>, <code>"etaauc"</code>, 
<code>"muvalue"</code>, etc) that are specified for that longitudinal marker in
the <code>assoc</code> argument.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_grp_assoc">grp_assoc</code></td>
<td>
<p>Character string specifying the method for combining information
across lower level units clustered within an individual when forming the
association structure. This is only relevant when a grouping factor is  
specified in <code>formulaLong</code> that corresponds to clustering within 
individuals. This can be specified as either <code>"sum"</code>, <code>mean</code>,
<code>"min"</code> or <code>"max"</code>. For example, specifying <code>grp_assoc = "sum"</code>
indicates that the association structure should be based on a summation across 
the lower level units clustered within an individual, or specifying
<code>grp_assoc = "mean"</code>  indicates that the association structure 
should be based on the mean (i.e. average) taken across the lower level 
units clustered within an individual.
So, for example, specifying <code>assoc = "muvalue"</code> 
and <code>grp_assoc = "sum"</code> would mean that the log hazard at time 
<em>t</em> for individual <em>i</em> would be linearly related to the sum of
the expected values at time <em>t</em> for each of the lower level 
units (which may be for example tumor lesions) clustered within that 
individual.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_scale_assoc">scale_assoc</code></td>
<td>
<p>A non-zero numeric value specifying an optional scaling 
parameter for the association structure. This multiplicatively scales the 
value/slope/auc of the longitudinal marker by <code>scale_assoc</code> within the 
event submodel. When fitting a multivariate joint model, a scaling parameter 
must be specified for each longitudinal submodel using a vector of numeric 
values. Note that only one scaling parameter can be specified for each 
longitudinal submodel, and it will be used for all association structure 
types (e.g. <code>"etavalue"</code>, <code>"etaslope"</code>, <code>"etaauc"</code>, 
<code>"muvalue"</code>, etc) that are specified for that longitudinal marker in
the <code>assoc</code> argument.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_epsilon">epsilon</code></td>
<td>
<p>The half-width of the central difference used to numerically
calculate the derivate when the <code>"etaslope"</code> association structure 
is used.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_basehaz">basehaz</code></td>
<td>
<p>A character string indicating which baseline hazard to use
for the event submodel. Options are a B-splines approximation estimated 
for the log baseline hazard (<code>"bs"</code>, the default), a Weibull 
baseline hazard (<code>"weibull"</code>), or a piecewise
constant baseline hazard (<code>"piecewise"</code>). (Note however that there  
is currently limited post-estimation functionality available for
models estimated using a piecewise constant baseline hazard).</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_basehaz_ops">basehaz_ops</code></td>
<td>
<p>A named list specifying options related to the baseline
hazard. Currently this can include: <br />
</p>

<dl>
<dt><code>df</code></dt><dd><p>A positive integer specifying the degrees of freedom 
for the B-splines if <code>basehaz = "bs"</code>, or the number of
intervals used for the piecewise constant baseline hazard if 
<code>basehaz = "piecewise"</code>. The default is 6.</p>
</dd>
<dt><code>knots</code></dt><dd><p>An optional numeric vector specifying the internal knot 
locations for the B-splines if <code>basehaz = "bs"</code>, or the 
internal cut-points for defining intervals of the piecewise constant 
baseline hazard if <code>basehaz = "piecewise"</code>. Knots cannot be
specified if <code>df</code> is specified. If not specified, then the 
default is to use <code>df - 4</code> knots if <code>basehaz = "bs"</code>,
or <code>df - 1</code> knots if <code>basehaz = "piecewise"</code>, which are
placed at equally spaced percentiles of the distribution of
observed event times.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stan_jm_+3A_qnodes">qnodes</code></td>
<td>
<p>The number of nodes to use for the Gauss-Kronrod quadrature
that is used to evaluate the cumulative hazard in the likelihood function. 
Options are 15 (the default), 11 or 7.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_init">init</code></td>
<td>
<p>The method for generating the initial values for the MCMC.
The default is <code>"prefit"</code>, which uses those obtained from 
fitting separate longitudinal and time-to-event models prior to 
fitting the joint model. The separate longitudinal model is a 
(possibly multivariate) generalised linear mixed 
model estimated using variational bayes. This is achieved via the 
<code><a href="#topic+stan_mvmer">stan_mvmer</a></code> function with <code>algorithm = "meanfield"</code>.
The separate Cox model is estimated using <code><a href="survival.html#topic+coxph">coxph</a></code>. 
This is achieved
using the and time-to-event models prior  
to fitting the joint model. The separate models are estimated using the
<code><a href="lme4.html#topic+glmer">glmer</a></code> and <code><a href="survival.html#topic+coxph">coxph</a></code> functions.
This should provide reasonable initial values which should aid the 
MCMC sampler. Parameters that cannot be obtained from 
fitting separate longitudinal and time-to-event models are initialised 
using the &quot;random&quot; method for <code><a href="rstan.html#topic+stan">stan</a></code>.
However it is recommended that any final analysis should ideally
be performed with several MCMC chains each initiated from a different
set of initial values; this can be obtained by setting
<code>init = "random"</code>. In addition, other possibilities for specifying 
<code>init</code> are the same as those described for <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_weights">weights</code></td>
<td>
<p>Experimental and should be used with caution. The 
user can optionally supply a 2-column data frame containing a set of
'prior weights' to be used in the estimation process. The data frame should
contain two columns: the first containing the IDs for each individual, and 
the second containing the corresponding weights. The data frame should only
have one row for each individual; that is, weights should be constant 
within individuals.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_priorlong">priorLong</code>, <code id="stan_jm_+3A_priorevent">priorEvent</code>, <code id="stan_jm_+3A_priorevent_assoc">priorEvent_assoc</code></td>
<td>
<p>The prior distributions for the 
regression coefficients in the longitudinal submodel(s), event submodel,
and the association parameter(s). Can be a call to one of the various functions 
provided by <span class="pkg">rstanarm</span> for specifying priors. The subset of these functions 
that can be used for the prior on the coefficients can be grouped into several 
&quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the scales
of the predictors. See the <a href="#topic+priors">priors help page</a> for details on
the rescaling and the <code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of
the priors used for a particular model.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_priorlong_intercept">priorLong_intercept</code>, <code id="stan_jm_+3A_priorevent_intercept">priorEvent_intercept</code></td>
<td>
<p>The prior distributions
for the intercepts in the longitudinal submodel(s) and event submodel. 
Can be a call to <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>. See the <a href="#topic+priors">priors help page</a> for details on 
these functions. To omit a prior on the intercept &mdash;i.e., to use a flat
(improper) uniform prior&mdash; <code>prior_intercept</code> can be set to
<code>NULL</code>.
</p>
<p><strong>Note:</strong> The prior distribution for the intercept is set so it
applies to the value when all predictors are centered. Moreover, 
note that a prior is only placed on the intercept for the event submodel
when a Weibull baseline hazard has been specified. For the B-splines and
piecewise constant baseline hazards there is not intercept parameter that
is given a prior distribution; an intercept parameter will be shown in 
the output for the fitted model, but this just corresponds to the 
necessary post-estimation adjustment in the linear predictor due to the
centering of the predictiors in the event submodel.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_priorlong_aux">priorLong_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameters
in the longitudinal submodels (if applicable). 
The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>priorLong_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>priorLong_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>priorLong_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters. 
</p>
<p><code>priorLong_aux</code> can be a call to <code>exponential</code> to 
use an exponential distribution, or <code>normal</code>, <code>student_t</code> or 
<code>cauchy</code>, which results in a half-normal, half-t, or half-Cauchy 
prior. See <code><a href="#topic+priors">priors</a></code> for details on these functions. To omit a 
prior &mdash;i.e., to use a flat (improper) uniform prior&mdash; set 
<code>priorLong_aux</code> to <code>NULL</code>.
</p>
<p>If fitting a multivariate joint model, you have the option to
specify a list of prior distributions, however the elements of the list
that correspond to any longitudinal submodel which does not have an 
auxiliary parameter will be ignored.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_priorevent_aux">priorEvent_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameters
in the event submodel. The &quot;auxiliary&quot; parameters refers to different  
parameters depending on the baseline hazard. For <code>basehaz = "weibull"</code>
the auxiliary parameter is the Weibull shape parameter. For 
<code>basehaz = "bs"</code> the auxiliary parameters are the coefficients for the
B-spline approximation to the log baseline hazard.
For <code>basehaz = "piecewise"</code> the auxiliary parameters are the piecewise
estimates of the log baseline hazard.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="#topic+priors">priors</a></code> for
more information about the prior distributions on covariance matrices.
Note however that the default prior for covariance matrices in 
<code>stan_jm</code> is slightly different to that in <code><a href="#topic+stan_glmer">stan_glmer</a></code> 
(the details of which are described on the <code><a href="#topic+priors">priors</a></code> page).</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>A positive integer specifying the maximum treedepth 
for the non-U-turn sampler. See the <code>control</code> argument in 
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr><td><code id="stan_jm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_jm</code> function can be used to fit a joint model (also 
known as a shared parameter model) for longitudinal and time-to-event data 
under a Bayesian framework. The underlying
estimation is carried out using the Bayesian C++ package Stan 
(<a href="https://mc-stan.org/">https://mc-stan.org/</a>). <br />
<br /> 
The joint model may be univariate (with only one longitudinal submodel) or
multivariate (with more than one longitudinal submodel). 
For the longitudinal submodel a (possibly multivariate) generalised linear 
mixed model is assumed with any of the <code><a href="stats.html#topic+family">family</a></code> choices 
allowed by <code><a href="lme4.html#topic+glmer">glmer</a></code>. If a multivariate joint model is specified 
(by providing a list of formulas in the <code>formulaLong</code> argument), then
the multivariate longitudinal submodel consists of a multivariate generalized  
linear model (GLM) with group-specific terms that are assumed to be correlated
across the different GLM submodels. That is, within
a grouping factor (for example, patient ID) the group-specific terms are
assumed to be correlated across the different GLM submodels. It is 
possible to specify a different outcome type (for example a different
family and/or link function) for each of the GLM submodels, by providing
a list of <code><a href="stats.html#topic+family">family</a></code> objects in the <code>family</code> 
argument. Multi-level 
clustered data are allowed, and that additional clustering can occur at a 
level higher than the individual-level (e.g. patients clustered within 
clinics), or at a level lower than the individual-level (e.g. tumor lesions
clustered within patients). If the clustering occurs at a level lower than
the individual, then the user needs to indicate how the lower level 
clusters should be handled when forming the association structure between
the longitudinal and event submodels (see the <code>grp_assoc</code> argument
described above). <br />
<br />
For the event submodel a parametric
proportional hazards model is assumed. The baseline hazard can be estimated 
using either a cubic B-splines approximation (<code>basehaz = "bs"</code>, the
default), a Weibull distribution (<code>basehaz = "weibull"</code>), or a
piecewise constant baseline hazard (<code>basehaz = "piecewise"</code>).
If the B-spline or piecewise constant baseline hazards are used, 
then the degrees of freedom or the internal knot locations can be 
(optionally) specified. If
the degrees of freedom are specified (through the <code>df</code> argument) then
the knot locations are automatically generated based on the 
distribution of the observed event times (not including censoring times). 
Otherwise internal knot locations can be specified 
directly through the <code>knots</code> argument. If neither <code>df</code> or
<code>knots</code> is specified, then the default is to set <code>df</code> equal to 6.
It is not possible to specify both <code>df</code> and <code>knots</code>. <br />
<br />
Time-varying covariates are allowed in both the 
longitudinal and event submodels. These should be specified in the data 
in the same way as they normally would when fitting a separate 
longitudinal model using <code><a href="lme4.html#topic+lmer">lmer</a></code> or a separate 
time-to-event model using <code><a href="survival.html#topic+coxph">coxph</a></code>. These time-varying
covariates should be exogenous in nature, otherwise they would perhaps 
be better specified as an additional outcome (i.e. by including them as an 
additional longitudinal outcome in the joint model). <br />
<br />
Bayesian estimation of the joint model is performed via MCMC. The Bayesian  
model includes independent priors on the 
regression coefficients for both the longitudinal and event submodels, 
including the association parameter(s) (in much the same way as the
regression parameters in <code><a href="#topic+stan_glm">stan_glm</a></code>) and
priors on the terms of a decomposition of the covariance matrices of the
group-specific parameters. 
See <code><a href="#topic+priors">priors</a></code> for more information about the priors distributions
that are available. <br />
<br />
Gauss-Kronrod quadrature is used to numerically evaluate the integral  
over the cumulative hazard in the likelihood function for the event submodel.
The accuracy of the numerical approximation can be controlled using the
number of quadrature nodes, specified through the <code>qnodes</code> 
argument. Using a higher number of quadrature nodes will result in a more 
accurate approximation.
</p>


<h4>Association structures</h4>

<p>The association structure for the joint model can be based on any of the 
following parameterisations: 
</p>

<ul>
<li><p> current value of the linear predictor in the 
longitudinal submodel (<code>"etavalue"</code>) 
</p>
</li>
<li><p> first derivative (slope) of the linear predictor in the 
longitudinal submodel (<code>"etaslope"</code>) 
</p>
</li>
<li><p> the area under the curve of the linear predictor in the 
longitudinal submodel (<code>"etaauc"</code>) 
</p>
</li>
<li><p> current expected value of the longitudinal submodel 
(<code>"muvalue"</code>)
</p>
</li>
<li><p> the area under the curve of the expected value from the 
longitudinal submodel (<code>"muauc"</code>)
</p>
</li>
<li><p> shared individual-level random effects (<code>"shared_b"</code>) 
</p>
</li>
<li><p> shared individual-level random effects which also incorporate 
the corresponding fixed effect as well as any corresponding 
random effects for clustering levels higher than the individual)
(<code>"shared_coef"</code>)
</p>
</li>
<li><p> interactions between association terms and observed data/covariates
(<code>"etavalue_data"</code>, <code>"etaslope_data"</code>, <code>"muvalue_data"</code>, 
<code>"muslope_data"</code>). These are described further below.
</p>
</li>
<li><p> interactions between association terms corresponding to different 
longitudinal outcomes in a multivariate joint model 
(<code>"etavalue_etavalue(#)"</code>, <code>"etavalue_muvalue(#)"</code>,
<code>"muvalue_etavalue(#)"</code>, <code>"muvalue_muvalue(#)"</code>). These
are described further below.      
</p>
</li>
<li><p> no association structure (equivalent to fitting separate 
longitudinal and event models) (<code>"null"</code> or <code>NULL</code>) 
</p>
</li></ul>

<p>More than one association structure can be specified, however,
not all possible combinations are allowed.   
Note that for the lagged association structures baseline values (time = 0) 
are used for the instances 
where the time lag results in a time prior to baseline. When using the 
<code>"etaauc"</code> or <code>"muauc"</code> association structures, the area under
the curve is evaluated using Gauss-Kronrod quadrature with 15 quadrature 
nodes. By default, <code>"shared_b"</code> and <code>"shared_coef"</code> contribute 
all random effects to the association structure; however, a subset of the 
random effects can be chosen by specifying their indices between parentheses 
as a suffix, for example, <code>"shared_b(1)"</code> or <code>"shared_b(1:3)"</code> or 
<code>"shared_b(1,2,4)"</code>, and so on. <br />
<br /> 
In addition, several association terms (<code>"etavalue"</code>, <code>"etaslope"</code>,
<code>"muvalue"</code>, <code>"muslope"</code>) can be interacted with observed 
data/covariates. To do this, use the association term's main handle plus a
suffix of <code>"_data"</code> then followed by the model matrix formula in 
parentheses. For example if we had a variable in our dataset for gender 
named <code>sex</code> then we might want to obtain different estimates for the 
association between the current slope of the marker and the risk of the 
event for each gender. To do this we would specify 
<code>assoc = c("etaslope", "etaslope_data(~ sex)")</code>. <br />
<br />
It is also possible, when fitting  a multivariate joint model, to include 
interaction terms between the association terms themselves (this only
applies for interacting <code>"etavalue"</code> or <code>"muvalue"</code>). For example, 
if we had a joint model with two longitudinal markers, we could specify 
<code>assoc = list(c("etavalue", "etavalue_etavalue(2)"), "etavalue")</code>.
The first element of list says we want to use the value of the linear
predictor for the first marker, as well as it's interaction with the
value of the linear predictor for the second marker. The second element of 
the list says we want to also include the expected value of the second marker 
(i.e. as a &quot;main effect&quot;). Therefore, the linear predictor for the event 
submodel would include the &quot;main effects&quot; for each marker as well as their
interaction. <br />
<br />
There are additional examples in the <strong>Examples</strong> section below.
</p>



<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanjm</a> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-objects">stanreg-objects</a></code>, <code><a href="#topic+stanmvreg-methods">stanmvreg-methods</a></code>, 
<code><a href="#topic+print.stanmvreg">print.stanmvreg</a></code>, <code><a href="#topic+summary.stanmvreg">summary.stanmvreg</a></code>,
<code><a href="#topic+posterior_traj">posterior_traj</a></code>, <code><a href="#topic+posterior_survfit">posterior_survfit</a></code>, 
<code><a href="#topic+posterior_predict">posterior_predict</a></code>, <code><a href="#topic+posterior_interval">posterior_interval</a></code>,
<code><a href="#topic+pp_check">pp_check</a></code>, <code><a href="#topic+ps_check">ps_check</a></code>, <code><a href="#topic+stan_mvmer">stan_mvmer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386") {


#####
# Univariate joint model, with association structure based on the 
# current value of the linear predictor
f1 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              # this next line is only to keep the example small in size!
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f1) 
summary(f1) 
        
#####
# Univariate joint model, with association structure based on the 
# current value and slope of the linear predictor
f2 &lt;- stan_jm(formulaLong = logBili ~ year + (year | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              assoc = c("etavalue", "etaslope"),
              time_var = "year",
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f2)  

#####
# Univariate joint model, with association structure based on the 
# lagged value of the linear predictor, where the lag is 2 time 
# units (i.e. 2 years in this example)
f3 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              assoc = "etavalue", lag_assoc = 2,
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f3) 

#####
# Univariate joint model, where the association structure includes 
# interactions with observed data. Here we specify that we want to use 
# an association structure based on the current value of the linear 
# predictor from the longitudinal submodel (i.e. "etavalue"), but we 
# also want to interact this with the treatment covariate (trt) from
# pbcLong data frame, so that we can estimate a different association 
# parameter (i.e. estimated effect of log serum bilirubin on the log 
# hazard of death) for each treatment group
f4 &lt;- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              assoc = c("etavalue", "etavalue_data(~ trt)"),
              chains = 1, cores = 1, seed = 12345, iter = 1000)
print(f4)

######
# Multivariate joint model, with association structure based 
# on the current value and slope of the linear predictor in the 
# first longitudinal submodel and the area under the marker 
# trajectory for the second longitudinal submodel
mv1 &lt;- stan_jm(
        formulaLong = list(
          logBili ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc = list(c("etavalue", "etaslope"), "etaauc"), 
        time_var = "year",
        chains = 1, cores = 1, seed = 12345, iter = 100)
print(mv1)

#####
# Multivariate joint model, where the association structure is formed by 
# including the expected value of each longitudinal marker (logBili and 
# albumin) in the linear predictor of the event submodel, as well as their 
# interaction effect (i.e. the interaction between the two "etavalue" terms). 
# Note that whether such an association structure based on a marker by 
# marker interaction term makes sense will depend on the context of your 
# application -- here we just show it for demostration purposes).
mv2 &lt;- stan_jm(
        formulaLong = list(
          logBili ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc = list(c("etavalue", "etavalue_etavalue(2)"), "etavalue"),
        time_var = "year", 
        chains = 1, cores = 1, seed = 12345, iter = 100)
        
#####
# Multivariate joint model, with one bernoulli marker and one
# Gaussian marker. We will artificially create the bernoulli
# marker by dichotomising log serum bilirubin
pbcLong$ybern &lt;- as.integer(pbcLong$logBili &gt;= mean(pbcLong$logBili))
mv3 &lt;- stan_jm(
        formulaLong = list(
          ybern ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        family = list(binomial, gaussian),
        time_var = "year", 
        chains = 1, cores = 1, seed = 12345, iter = 1000)

}

</code></pre>

<hr>
<h2 id='stan_mvmer'>Bayesian multivariate generalized linear models with correlated 
group-specific terms via Stan</h2><span id='topic+stan_mvmer'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for multivariate GLMs with group-specific coefficients 
that are assumed to be correlated across the GLM submodels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_mvmer(
  formula,
  data,
  family = gaussian,
  weights,
  prior = normal(autoscale = TRUE),
  prior_intercept = normal(autoscale = TRUE),
  prior_aux = cauchy(0, 5, autoscale = TRUE),
  prior_covariance = lkj(autoscale = TRUE),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  max_treedepth = 10L,
  init = "random",
  QR = FALSE,
  sparse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_mvmer_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing both the 
fixed-effects and random-effects parts of the longitudinal submodel  
similar in vein to formula specification in the <strong>lme4</strong> package
(see <code><a href="lme4.html#topic+glmer">glmer</a></code> or the <strong>lme4</strong> vignette for details). 
Note however that the double bar (<code>||</code>) notation is not allowed 
when specifying the random-effects parts of the formula, and neither
are nested grouping factors (e.g. <code>(1 | g1/g2))</code> or 
<code>(1 | g1:g2)</code>, where <code>g1</code>, <code>g2</code> are grouping factors. 
For a multivariate GLM this should be a list of such formula objects, 
with each element of the list providing the formula for one of the 
GLM submodels.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables specified in
<code>formula</code>. For a multivariate GLM, this can
be either a single data frame which contains the data for all 
GLM submodels, or it can be a list of data frames where each
element of the list provides the data for one of the GLM submodels.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_family">family</code></td>
<td>
<p>The family (and possibly also the link function) for the 
GLM submodel(s). See <code><a href="lme4.html#topic+glmer">glmer</a></code> for details. 
If fitting a multivariate GLM, then this can optionally be a
list of families, in which case each element of the list specifies the
family for one of the GLM submodels. In other words, a different family
can be specified for each GLM submodel.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_weights">weights</code></td>
<td>
<p>Same as in <code><a href="stats.html#topic+glm">glm</a></code>,
except that when fitting a multivariate GLM and a list of data frames 
is provided in <code>data</code> then a corresponding list of weights 
must be provided. If weights are 
provided for one of the GLM submodels, then they must be provided for 
all GLM submodels.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_prior">prior</code>, <code id="stan_mvmer_+3A_prior_intercept">prior_intercept</code>, <code id="stan_mvmer_+3A_prior_aux">prior_aux</code></td>
<td>
<p>Same as in <code><a href="#topic+stan_glmer">stan_glmer</a></code>
except that for a multivariate GLM a list of priors can be provided for 
any of <code>prior</code>, <code>prior_intercept</code> or <code>prior_aux</code> arguments. 
That is, different priors can optionally be specified for each of the GLM  
submodels. If a list is not provided, then the same prior distributions are 
used for each GLM submodel. Note that the <code>"product_normal"</code> prior is
not allowed for <code>stan_mvmer</code>.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="#topic+priors">priors</a></code> for
more information about the prior distributions on covariance matrices.
Note however that the default prior for covariance matrices in 
<code>stan_mvmer</code> is slightly different to that in <code><a href="#topic+stan_glmer">stan_glmer</a></code> 
(the details of which are described on the <code><a href="#topic+priors">priors</a></code> page).</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>A positive integer specifying the maximum treedepth 
for the non-U-turn sampler. See the <code>control</code> argument in 
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_init">init</code></td>
<td>
<p>The method for generating initial values. See
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
<tr><td><code id="stan_mvmer_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_mvmer</code> function can be used to fit a multivariate
generalized linear model (GLM) with group-specific terms. The model consists
of distinct GLM submodels, each which contains group-specific terms; within
a grouping factor (for example, patient ID) the grouping-specific terms are
assumed to be correlated across the different GLM submodels. It is 
possible to specify a different outcome type (for example a different
family and/or link function) for each of the GLM submodels. <br />
<br />
Bayesian estimation of the model is performed via MCMC, in the same way as 
for <code><a href="#topic+stan_glmer">stan_glmer</a></code>. Also, similar to <code><a href="#topic+stan_glmer">stan_glmer</a></code>,
an unstructured covariance matrix is used for the group-specific terms 
within a given grouping factor, with priors on the terms of a decomposition
of the covariance matrix.See <code><a href="#topic+priors">priors</a></code> for more information about 
the priors distributions that are available for the covariance matrices, 
the regression coefficients and the intercept and auxiliary parameters.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanmvreg</a> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_glmer">stan_glmer</a></code>, <code><a href="#topic+stan_jm">stan_jm</a></code>,
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>, <code><a href="#topic+stanmvreg-methods">stanmvreg-methods</a></code>, 
<code><a href="#topic+print.stanmvreg">print.stanmvreg</a></code>, <code><a href="#topic+summary.stanmvreg">summary.stanmvreg</a></code>,
<code><a href="#topic+posterior_predict">posterior_predict</a></code>, <code><a href="#topic+posterior_interval">posterior_interval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386") {

#####
# A multivariate GLM with two submodels. For the grouping factor 'id', the 
# group-specific intercept from the first submodel (logBili) is assumed to
# be correlated with the group-specific intercept and linear slope in the 
# second submodel (albumin)
f1 &lt;- stan_mvmer(
        formula = list(
          logBili ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        data = pbcLong, 
        # this next line is only to keep the example small in size!
        chains = 1, cores = 1, seed = 12345, iter = 1000)
summary(f1) 

#####
# A multivariate GLM with one bernoulli outcome and one
# gaussian outcome. We will artificially create the bernoulli
# outcome by dichotomising log serum bilirubin
pbcLong$ybern &lt;- as.integer(pbcLong$logBili &gt;= mean(pbcLong$logBili))
f2 &lt;- stan_mvmer(
        formula = list(
          ybern ~ year + (1 | id), 
          albumin ~ sex + year + (year | id)),
        data = pbcLong,
        family = list(binomial, gaussian),
        chains = 1, cores = 1, seed = 12345, iter = 1000)

}
</code></pre>

<hr>
<h2 id='stan_nlmer'>Bayesian nonlinear models with group-specific terms via Stan</h2><span id='topic+stan_nlmer'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for NLMMs with group-specific coefficients that have 
unknown covariance matrices with flexible priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_nlmer(
  formula,
  data = NULL,
  subset,
  weights,
  na.action,
  offset,
  contrasts = NULL,
  ...,
  prior = normal(autoscale = TRUE),
  prior_aux = exponential(autoscale = TRUE),
  prior_covariance = decov(),
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  QR = FALSE,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_nlmer_+3A_formula">formula</code>, <code id="stan_nlmer_+3A_data">data</code></td>
<td>
<p>Same as for <code><a href="lme4.html#topic+nlmer">nlmer</a></code>. <em>We strongly
advise against omitting the <code>data</code> argument</em>. Unless <code>data</code> is
specified (and is a data frame) many post-estimation functions (including
<code>update</code>, <code>loo</code>, <code>kfold</code>) are not guaranteed to work
properly.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_subset">subset</code>, <code id="stan_nlmer_+3A_weights">weights</code>, <code id="stan_nlmer_+3A_offset">offset</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_na.action">na.action</code>, <code id="stan_nlmer_+3A_contrasts">contrasts</code></td>
<td>
<p>Same as <code><a href="stats.html#topic+glm">glm</a></code>, but rarely 
specified.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_prior">prior</code></td>
<td>
<p>The prior distribution for the (non-hierarchical) regression
coefficients.
</p>
<p>The default priors are described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior</code> should be a call to one of the
various functions provided by <span class="pkg">rstanarm</span> for specifying priors. The
subset of these functions that can be used for the prior on the
coefficients can be grouped into several &quot;families&quot;:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Family</strong> </td><td style="text-align: left;"> <strong>Functions</strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Student t family</em> </td><td style="text-align: left;"> <code>normal</code>, <code>student_t</code>, <code>cauchy</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Hierarchical shrinkage family</em> </td><td style="text-align: left;"> <code>hs</code>, <code>hs_plus</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <em>Laplace family</em> </td><td style="text-align: left;"> <code>laplace</code>, <code>lasso</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <em>Product normal family</em> </td><td style="text-align: left;"> <code>product_normal</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <a href="#topic+priors">priors help page</a> for details on the families and 
how to specify the arguments for all of the functions in the table above.
To omit a prior &mdash;i.e., to use a flat (improper) uniform prior&mdash;
<code>prior</code> can be set to <code>NULL</code>, although this is rarely a good
idea.
</p>
<p><strong>Note:</strong> Unless <code>QR=TRUE</code>, if <code>prior</code> is from the Student t
family or Laplace family, and if the <code>autoscale</code> argument to the 
function used to specify the prior (e.g. <code><a href="#topic+normal">normal</a></code>) is left at 
its default and recommended value of <code>TRUE</code>, then the default or 
user-specified prior scale(s) may be adjusted internally based on the
scales of the predictors. See the <a href="#topic+priors">priors help page</a> and the
<em>Prior Distributions</em> vignette for details on the rescaling and the
<code><a href="#topic+prior_summary">prior_summary</a></code> function for a summary of the priors used for a
particular model.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_prior_aux">prior_aux</code></td>
<td>
<p>The prior distribution for the &quot;auxiliary&quot; parameter (if
applicable). The &quot;auxiliary&quot; parameter refers to a different parameter 
depending on the <code>family</code>. For Gaussian models <code>prior_aux</code> 
controls <code>"sigma"</code>, the error 
standard deviation. For negative binomial models <code>prior_aux</code> controls 
<code>"reciprocal_dispersion"</code>, which is similar to the 
<code>"size"</code> parameter of <code><a href="stats.html#topic+NegBinomial">rnbinom</a></code>:
smaller values of <code>"reciprocal_dispersion"</code> correspond to 
greater dispersion. For gamma models <code>prior_aux</code> sets the prior on 
to the <code>"shape"</code> parameter (see e.g., 
<code><a href="stats.html#topic+GammaDist">rgamma</a></code>), and for inverse-Gaussian models it is the 
so-called <code>"lambda"</code> parameter (which is essentially the reciprocal of
a scale parameter). Binomial and Poisson models do not have auxiliary 
parameters.
</p>
<p>The default prior is described in the vignette 
<a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a>.
If not using the default, <code>prior_aux</code> can be a call to
<code>exponential</code> to use an exponential distribution, or <code>normal</code>,
<code>student_t</code> or <code>cauchy</code>, which results in a half-normal, half-t,
or half-Cauchy prior. See <code><a href="#topic+priors">priors</a></code> for details on these
functions. To omit a prior &mdash;i.e., to use a flat (improper) uniform
prior&mdash; set <code>prior_aux</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_prior_covariance">prior_covariance</code></td>
<td>
<p>Cannot be <code>NULL</code>; see <code><a href="#topic+decov">decov</a></code> for
more information about the default arguments.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_qr">QR</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code>, but if <code>TRUE</code>
applies a scaled <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition to the design matrix. The
transformation does not change the likelihood of the data but is
recommended for computational reasons when there are multiple predictors.
See the <a href="#topic+QR-argument">QR-argument</a> documentation page for details on how
<span class="pkg">rstanarm</span> does the transformation and important information about how
to interpret the prior distributions of the model parameters when using
<code>QR=TRUE</code>.</p>
</td></tr>
<tr><td><code id="stan_nlmer_+3A_sparse">sparse</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to use a sparse representation of the design (X) matrix. 
If <code>TRUE</code>, the the design matrix is not centered (since that would 
destroy the sparsity) and likewise it is not possible to specify both 
<code>QR = TRUE</code> and <code>sparse = TRUE</code>. Depending on how many zeros
there are in the design matrix, setting <code>sparse = TRUE</code> may make
the code run faster and can consume much less RAM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_nlmer</code> function is similar in syntax to 
<code><a href="lme4.html#topic+nlmer">nlmer</a></code> but rather than performing (approximate) maximum 
marginal likelihood estimation, Bayesian estimation is by default performed
via MCMC. The Bayesian model adds independent priors on the &quot;coefficients&quot;
&mdash; which are really intercepts &mdash; in the same way as 
<code><a href="#topic+stan_nlmer">stan_nlmer</a></code> and priors on the terms of a decomposition of the 
covariance matrices of the group-specific parameters. See
<code><a href="#topic+priors">priors</a></code> for more information about the priors.
</p>
<p>The supported transformation functions are limited to the named 
&quot;self-starting&quot; functions in the <span class="pkg">stats</span> library:
<code><a href="stats.html#topic+SSasymp">SSasymp</a></code>, <code><a href="stats.html#topic+SSasympOff">SSasympOff</a></code>,
<code><a href="stats.html#topic+SSasympOrig">SSasympOrig</a></code>, <code><a href="stats.html#topic+SSbiexp">SSbiexp</a></code>,
<code><a href="stats.html#topic+SSfol">SSfol</a></code>, <code><a href="stats.html#topic+SSfpl">SSfpl</a></code>,
<code><a href="stats.html#topic+SSgompertz">SSgompertz</a></code>, <code><a href="stats.html#topic+SSlogis">SSlogis</a></code>,
<code><a href="stats.html#topic+SSmicmen">SSmicmen</a></code>, and <code><a href="stats.html#topic+SSweibull">SSweibull</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_nlmer</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="lme4.html#topic+nlmer">nlmer</a></code>.
</p>
<p>The vignette for <code>stan_glmer</code>, which also discusses 
<code>stan_nlmer</code> models. <a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386") {

data("Orange", package = "datasets")
Orange$circumference &lt;- Orange$circumference / 100
Orange$age &lt;- Orange$age / 100
fit &lt;- stan_nlmer(
  circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree, 
  data = Orange, 
  # for speed only
  chains = 1, 
  iter = 1000
 ) 
print(fit)
posterior_interval(fit)
plot(fit, regex_pars = "b\\[")

}
</code></pre>

<hr>
<h2 id='stan_polr'>Bayesian ordinal regression models via Stan</h2><span id='topic+stan_polr'></span><span id='topic+stan_polr.fit'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Bayesian inference for ordinal (or binary) regression models under a
proportional odds assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_polr(
  formula,
  data,
  weights,
  ...,
  subset,
  na.action = getOption("na.action", "na.omit"),
  contrasts = NULL,
  model = TRUE,
  method = c("logistic", "probit", "loglog", "cloglog", "cauchit"),
  prior = R2(stop("'location' must be specified")),
  prior_counts = dirichlet(1),
  shape = NULL,
  rate = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  do_residuals = NULL
)

stan_polr.fit(
  x,
  y,
  wt = NULL,
  offset = NULL,
  method = c("logistic", "probit", "loglog", "cloglog", "cauchit"),
  ...,
  prior = R2(stop("'location' must be specified")),
  prior_counts = dirichlet(1),
  shape = NULL,
  rate = NULL,
  prior_PD = FALSE,
  algorithm = c("sampling", "meanfield", "fullrank"),
  adapt_delta = NULL,
  do_residuals = algorithm == "sampling"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_polr_+3A_formula">formula</code>, <code id="stan_polr_+3A_data">data</code>, <code id="stan_polr_+3A_subset">subset</code></td>
<td>
<p>Same as <code><a href="MASS.html#topic+polr">polr</a></code>, 
but <em>we strongly advise against omitting the <code>data</code>
argument</em>. Unless <code>data</code> is specified (and is a data frame) many
post-estimation functions (including <code>update</code>, <code>loo</code>,
<code>kfold</code>) are not guaranteed to work properly.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_weights">weights</code>, <code id="stan_polr_+3A_na.action">na.action</code>, <code id="stan_polr_+3A_contrasts">contrasts</code>, <code id="stan_polr_+3A_model">model</code></td>
<td>
<p>Same as <code><a href="MASS.html#topic+polr">polr</a></code>, but
rarely specified.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function in the <span class="pkg">rstan</span> 
package (<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling</a></code>, 
<code><a href="rstan.html#topic+stanmodel-method-vb">vb</a></code>, or 
<code><a href="rstan.html#topic+stanmodel-method-optimizing">optimizing</a></code>), 
corresponding to the estimation method named by <code>algorithm</code>. For example, 
if <code>algorithm</code> is <code>"sampling"</code> it is possible to specify <code>iter</code>, 
<code>chains</code>, <code>cores</code>, and other MCMC controls.  
</p>
<p>Another useful argument that can be passed to <span class="pkg">rstan</span> via <code>...</code> is
<code>refresh</code>, which specifies how often to print updates when sampling
(i.e., show the progress every <code>refresh</code> iterations). <code>refresh=0</code>
turns off the iteration updates.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_method">method</code></td>
<td>
<p>One of 'logistic', 'probit', 'loglog', 'cloglog' or 'cauchit',
but can be abbreviated. See <code><a href="MASS.html#topic+polr">polr</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_prior">prior</code></td>
<td>
<p>Prior for coefficients. Should be a call to <code><a href="#topic+R2">R2</a></code>
to specify the prior location of the <code class="reqn">R^2</code> but can be <code>NULL</code>
to indicate a standard uniform prior. See <code><a href="#topic+priors">priors</a></code>.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_prior_counts">prior_counts</code></td>
<td>
<p>A call to <code><a href="#topic+dirichlet">dirichlet</a></code> to specify the
prior counts of the outcome when the predictors are at their sample
means.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_shape">shape</code></td>
<td>
<p>Either <code>NULL</code> or a positive scalar that is interpreted
as the shape parameter for a <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>ribution on
the exponent applied to the probability of success when there are only
two outcome categories. If <code>NULL</code>, which is the default, then the
exponent is taken to be fixed at <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_rate">rate</code></td>
<td>
<p>Either <code>NULL</code> or a positive scalar that is interpreted
as the rate parameter for a <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>ribution on
the exponent applied to the probability of success when there are only
two outcome categories. If <code>NULL</code>, which is the default, then the
exponent is taken to be fixed at <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_prior_pd">prior_PD</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_algorithm">algorithm</code></td>
<td>
<p>A string (possibly abbreviated) indicating the 
estimation approach to use. Can be <code>"sampling"</code> for MCMC (the
default), <code>"optimizing"</code> for optimization, <code>"meanfield"</code> for
variational inference with independent normal distributions, or
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution. See <code><a href="#topic+rstanarm-package">rstanarm-package</a></code> for more details on the
estimation algorithms. NOTE: not all fitting functions support all four
algorithms.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Only relevant if <code>algorithm="sampling"</code>. See 
the <a href="#topic+adapt_delta">adapt_delta</a> help page for details.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_do_residuals">do_residuals</code></td>
<td>
<p>A logical scalar indicating whether or not to 
automatically calculate fit residuals after sampling completes. Defaults to
<code>TRUE</code> if and only if <code>algorithm="sampling"</code>. Setting
<code>do_residuals=FALSE</code> is only useful in the somewhat rare case that
<code>stan_polr</code> appears to finish sampling but hangs instead of returning
the fitted model object.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_x">x</code></td>
<td>
<p>A design matrix.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_y">y</code></td>
<td>
<p>A response variable, which must be a (preferably ordered) factor.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_wt">wt</code></td>
<td>
<p>A numeric vector (possibly <code>NULL</code>) of observation weights.</p>
</td></tr>
<tr><td><code id="stan_polr_+3A_offset">offset</code></td>
<td>
<p>A numeric vector (possibly <code>NULL</code>) of offsets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan_polr</code> function is similar in syntax to
<code><a href="MASS.html#topic+polr">polr</a></code> but rather than performing maximum likelihood
estimation of a proportional odds model, Bayesian estimation is performed
(if <code>algorithm = "sampling"</code>) via MCMC. The <code>stan_polr</code>
function calls the workhorse <code>stan_polr.fit</code> function, but it is
possible to call the latter directly.
</p>
<p>As for <code><a href="#topic+stan_lm">stan_lm</a></code>, it is necessary to specify the prior
location of <code class="reqn">R^2</code>. In this case, the <code class="reqn">R^2</code> pertains to the
proportion of variance in the latent variable (which is discretized
by the cutpoints) attributable to the predictors in the model.
</p>
<p>Prior beliefs about the cutpoints are governed by prior beliefs about the
outcome when the predictors are at their sample means. Both of these
are explained in the help page on <code><a href="#topic+priors">priors</a></code> and in the
<span class="pkg">rstanarm</span> vignettes.
</p>
<p>Unlike <code><a href="MASS.html#topic+polr">polr</a></code>, <code>stan_polr</code> also allows the &quot;ordinal&quot;
outcome to contain only two levels, in which case the likelihood is the
same by default as for <code><a href="#topic+stan_glm">stan_glm</a></code> with <code>family = binomial</code>
but the prior on the coefficients is different. However, <code>stan_polr</code>
allows the user to specify the <code>shape</code> and <code>rate</code> hyperparameters,
in which case the probability of success is defined as the logistic CDF of
the linear predictor, raised to the power of <code>alpha</code> where <code>alpha</code>
has a gamma prior with the specified <code>shape</code> and <code>rate</code>. This
likelihood is called &ldquo;scobit&rdquo; by Nagler (1994) because if <code>alpha</code>
is not equal to <code class="reqn">1</code>, then the relationship between the linear predictor
and the probability of success is skewed. If <code>shape</code> or <code>rate</code> is
<code>NULL</code>, then <code>alpha</code> is assumed to be fixed to <code class="reqn">1</code>.
</p>
<p>Otherwise, it is usually advisible to set <code>shape</code> and <code>rate</code> to
the same number so that the expected value of <code>alpha</code> is <code class="reqn">1</code> while
leaving open the possibility that <code>alpha</code> may depart from <code class="reqn">1</code> a
little bit. It is often necessary to have a lot of data in order to estimate
<code>alpha</code> with much precision and always necessary to inspect the
Pareto shape parameters calculated by <code><a href="#topic+loo">loo</a></code> to see if the
results are particularly sensitive to individual observations.
</p>
<p>Users should think carefully about how the outcome is coded when using
a scobit-type model. When <code>alpha</code> is not <code class="reqn">1</code>, the asymmetry
implies that the probability of success is most sensitive to the predictors
when the probability of success is less than <code class="reqn">0.63</code>. Reversing the
coding of the successes and failures allows the predictors to have the
greatest impact when the probability of failure is less than <code class="reqn">0.63</code>.
Also, the gamma prior on <code>alpha</code> is positively skewed, but you
can reverse the coding of the successes and failures to circumvent this
property.
</p>


<h3>Value</h3>

<p>A <a href="#topic+stanreg-objects">stanreg</a> object is returned 
for <code>stan_polr</code>.
</p>
<p>A <a href="rstan.html#topic+stanfit-class">stanfit</a> object (or a slightly modified 
stanfit object) is returned if <code>stan_polr.fit</code> is called directly.
</p>


<h3>References</h3>

<p>Nagler, J., (1994). Scobit: An Alternative Estimator to Logit and Probit.
<em>American Journal of Political Science</em>. 230 &ndash; 255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code> and 
<code><a href="MASS.html#topic+polr">polr</a></code>.
</p>
<p>The vignette for <code>stan_polr</code>.
<a href="https://mc-stan.org/rstanarm/articles/">https://mc-stan.org/rstanarm/articles/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch !="i386") {
 fit &lt;- stan_polr(tobgp ~ agegp, data = esoph, method = "probit",
          prior = R2(0.2, "mean"), init_r = 0.1, seed = 12345,
          algorithm = "fullrank") # for speed only
 print(fit)
 plot(fit)
}

</code></pre>

<hr>
<h2 id='stanmvreg-methods'>Methods for stanmvreg objects</h2><span id='topic+stanmvreg-methods'></span><span id='topic+coef.stanmvreg'></span><span id='topic+fitted.stanmvreg'></span><span id='topic+residuals.stanmvreg'></span><span id='topic+se.stanmvreg'></span><span id='topic+formula.stanmvreg'></span><span id='topic+update.stanmvreg'></span><span id='topic+update.stanjm'></span><span id='topic+fixef.stanmvreg'></span><span id='topic+ngrps.stanmvreg'></span><span id='topic+ranef.stanmvreg'></span><span id='topic+sigma.stanmvreg'></span>

<h3>Description</h3>

<p>S3 methods for <a href="#topic+stanreg-objects">stanmvreg</a> objects. There are also 
several methods (listed in <strong>See Also</strong>, below) with their own
individual help pages. 
The main difference between these methods and the 
<a href="#topic+stanreg-methods">stanreg</a> methods is that the methods described here
generally include an additional argument <code>m</code> which allows the user to
specify which submodel they wish to return the result for. If the argument
<code>m</code> is set to <code>NULL</code> then the result will generally be a named list
with each element of the list containing the result for one of the submodels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanmvreg'
coef(object, m = NULL, ...)

## S3 method for class 'stanmvreg'
fitted(object, m = NULL, ...)

## S3 method for class 'stanmvreg'
residuals(object, m = NULL, ...)

## S3 method for class 'stanmvreg'
se(object, m = NULL, ...)

## S3 method for class 'stanmvreg'
formula(x, fixed.only = FALSE, random.only = FALSE, m = NULL, ...)

## S3 method for class 'stanmvreg'
update(object, formula., ..., evaluate = TRUE)

## S3 method for class 'stanjm'
update(object, formulaLong., formulaEvent., ..., evaluate = TRUE)

## S3 method for class 'stanmvreg'
fixef(object, m = NULL, remove_stub = TRUE, ...)

## S3 method for class 'stanmvreg'
ngrps(object, ...)

## S3 method for class 'stanmvreg'
ranef(object, m = NULL, ...)

## S3 method for class 'stanmvreg'
sigma(object, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanmvreg-methods_+3A_object">object</code>, <code id="stanmvreg-methods_+3A_x">x</code></td>
<td>
<p>A fitted model object returned by one of the 
multivariate <span class="pkg">rstanarm</span> modelling functions. See 
<code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_...">...</code></td>
<td>
<p>Ignored, except by the <code>update</code> method. See
<code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_fixed.only">fixed.only</code></td>
<td>
<p>A logical specifying whether to only retain the fixed effect
part of the longitudinal submodel formulas</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_random.only">random.only</code></td>
<td>
<p>A logical specifying whether to only retain the random effect
part of the longitudinal submodel formulas</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_formula.">formula.</code></td>
<td>
<p>An updated formula for the model. For a multivariate model
<code>formula.</code> should be a list of formulas, as described for the 
<code>formula</code> argument in <code><a href="#topic+stan_mvmer">stan_mvmer</a></code>.</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_evaluate">evaluate</code></td>
<td>
<p>See <code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_formulalong.">formulaLong.</code>, <code id="stanmvreg-methods_+3A_formulaevent.">formulaEvent.</code></td>
<td>
<p>An updated formula for the longitudinal
or event submodel, when <code>object</code> was estimated using 
<code><a href="#topic+stan_jm">stan_jm</a></code>. For a multivariate joint model <code>formulaLong.</code> 
should be a list of formulas, as described for the <code>formulaLong</code>
argument in <code><a href="#topic+stan_jm">stan_jm</a></code>.</p>
</td></tr>
<tr><td><code id="stanmvreg-methods_+3A_remove_stub">remove_stub</code></td>
<td>
<p>Logical specifying whether to remove the string identifying 
the submodel (e.g. <code>y1|</code>, <code>y2|</code>, <code>Long1|</code>, <code>Long2|</code>,
<code>Event|</code>) from each of the parameter names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these methods are similar to the methods defined for objects
of class 'lm', 'glm', 'glmer', etc. However there are a few exceptions:
</p>

<dl>
<dt><code>coef</code></dt><dd>
<p>Medians are used for point estimates. See the <em>Point estimates</em> section
in <code><a href="#topic+print.stanmvreg">print.stanmvreg</a></code> for more details. <code>coef</code> returns a list 
equal to the length of the number of submodels. The first
elements of the list are the coefficients from each of the fitted longitudinal
submodels and are the same layout as those returned by <code>coef</code> method of the
<span class="pkg">lme4</span> package, that is, the sum of the random and fixed effects coefficients 
for each explanatory variable for each level of each grouping factor. The final
element of the returned list is a vector of fixed effect coefficients from the
event submodel. 
</p>
</dd>
<dt><code>se</code></dt><dd>
<p>The <code>se</code> function returns standard errors based on 
<code><a href="stats.html#topic+mad">mad</a></code>. See the <em>Uncertainty estimates</em> section in
<code><a href="#topic+print.stanmvreg">print.stanmvreg</a></code> for more details.
</p>
</dd>
<dt><code>confint</code></dt><dd>
<p>Not supplied, since the <code><a href="#topic+posterior_interval">posterior_interval</a></code> function should 
be used instead to compute Bayesian uncertainty intervals.
</p>
</dd>
<dt><code>residuals</code></dt><dd>
<p>Residuals are <em>always</em> of type <code>"response"</code> (not <code>"deviance"</code>
residuals or any other type).
</p>
</dd>
</dl>



<h3>See Also</h3>


<ul>
<li><p> The <code><a href="#topic+print.stanmvreg">print</a></code>,
<code><a href="#topic+summary.stanmvreg">summary</a></code>, and <code><a href="#topic+prior_summary">prior_summary</a></code> 
methods for <code>stanmvreg</code> objects for information on the fitted model.
</p>
</li>
<li><p> The <code><a href="#topic+plot.stanreg">plot</a></code> method to plot estimates and
diagnostics.
</p>
</li>
<li><p> The <code><a href="#topic+pp_check">pp_check</a></code> method for graphical posterior predictive
checking of the longitudinal or glmer submodels.
</p>
</li>
<li><p> The <code><a href="#topic+ps_check">ps_check</a></code> method for graphical posterior predictive
checking of the event submodel.
</p>
</li>
<li><p> The <code><a href="#topic+posterior_traj">posterior_traj</a></code> for predictions for the longitudinal
submodel (for models estimated using <code><a href="#topic+stan_jm">stan_jm</a></code>), as well as
it's associated <code><a href="#topic+plot.predict.stanjm">plot</a></code> method.
</p>
</li>
<li><p> The <code><a href="#topic+posterior_survfit">posterior_survfit</a></code> for predictions for the event
submodel, including so-called &quot;dynamic&quot; predictions (for models estimated 
using <code><a href="#topic+stan_jm">stan_jm</a></code>), as well as
it's associated <code><a href="#topic+plot.survfit.stanjm">plot</a></code> method.
</p>
</li>
<li><p> The <code><a href="#topic+posterior_predict">posterior_predict</a></code> for predictions for the glmer
submodel (for models estimated using <code><a href="#topic+stan_mvmer">stan_mvmer</a></code>).
</p>
</li>
<li><p> The <code><a href="#topic+posterior_interval">posterior_interval</a></code> for uncertainty intervals for 
model parameters.
</p>
</li>
<li><p> The <code><a href="#topic+loo.stanreg">loo</a></code>, 
and <code><a href="#topic+log_lik.stanmvreg">log_lik</a></code> methods for leave-one-out 
model comparison, and computing the log-likelihood of (possibly new) data.
</p>
</li>
<li><p> The <code><a href="#topic+as.matrix.stanreg">as.matrix</a></code>, <code>as.data.frame</code>, 
and <code>as.array</code> methods to access posterior draws.
</p>
</li></ul>
 
<p>Other S3 methods for stanmvreg objects, which have separate documentation, 
including <code><a href="#topic+print.stanmvreg">print.stanmvreg</a></code>, and <code><a href="#topic+summary.stanmvreg">summary.stanmvreg</a></code>.
</p>
<p>Also <code><a href="#topic+posterior_interval">posterior_interval</a></code> for an alternative to <code>confint</code>, 
and <code>posterior_predict</code>, <code>posterior_traj</code> and 
<code>posterior_survfit</code> for predictions based on the fitted joint model.
</p>

<hr>
<h2 id='stanreg_list'>Create lists of fitted model objects, combine them, or append new models to
existing lists of models.</h2><span id='topic+stanreg_list'></span><span id='topic+stanmvreg_list'></span><span id='topic+stanjm_list'></span><span id='topic+print.stanreg_list'></span>

<h3>Description</h3>

<p>Create lists of fitted model objects, combine them, or append new models to
existing lists of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanreg_list(..., model_names = NULL)

stanmvreg_list(..., model_names = NULL)

stanjm_list(..., model_names = NULL)

## S3 method for class 'stanreg_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanreg_list_+3A_...">...</code></td>
<td>
<p>Objects to combine into a <code>"stanreg_list"</code>,
<code>"stanmvreg_list"</code>, or <code>"stanjm_list"</code>. Can be fitted model
objects, existing <code>"stan*_list"</code> objects to combine, or one existing
<code>"stan*_list"</code> object followed by fitted model objects to append to
the list.</p>
</td></tr>
<tr><td><code id="stanreg_list_+3A_model_names">model_names</code></td>
<td>
<p>Optionally, a character vector of model names. If not
specified then the names are inferred from the name of the objects passed
in via <code>...</code>. These model names are used, for example, when printing
the results of the <code>loo_compare.stanreg_list</code> and
<code>loo_model_weights.stanreg_list</code> methods.</p>
</td></tr>
<tr><td><code id="stanreg_list_+3A_x">x</code></td>
<td>
<p>The object to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"stanreg_list"</code>, <code>"stanmvreg_list"</code>, or
<code>"stanjm_list"</code>, containing the fitted model objects and some metadata
stored as attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo_model_weights">loo_model_weights</a></code> for usage of <code>stanreg_list</code>.
</p>

<hr>
<h2 id='stanreg-draws-formats'>Create a <code>draws</code> object from a <code>stanreg</code> object</h2><span id='topic+stanreg-draws-formats'></span><span id='topic+as_draws'></span><span id='topic+as_draws_matrix'></span><span id='topic+as_draws_array'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws_rvars'></span><span id='topic+as_draws_list'></span><span id='topic+as_draws.stanreg'></span><span id='topic+as_draws_matrix.stanreg'></span><span id='topic+as_draws_array.stanreg'></span><span id='topic+as_draws_df.stanreg'></span><span id='topic+as_draws_list.stanreg'></span><span id='topic+as_draws_rvars.stanreg'></span>

<h3>Description</h3>

<p>Convert a <code>stanreg</code> object to a format supported by the
<span class="pkg"><a href="posterior.html#topic+posterior-package">posterior</a></span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
as_draws(x, ...)

## S3 method for class 'stanreg'
as_draws_matrix(x, ...)

## S3 method for class 'stanreg'
as_draws_array(x, ...)

## S3 method for class 'stanreg'
as_draws_df(x, ...)

## S3 method for class 'stanreg'
as_draws_list(x, ...)

## S3 method for class 'stanreg'
as_draws_rvars(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanreg-draws-formats_+3A_x">x</code></td>
<td>
<p>A <code>stanreg</code> object returned by one of the <span class="pkg">rstanarm</span>
modeling functions.</p>
</td></tr>
<tr><td><code id="stanreg-draws-formats_+3A_...">...</code></td>
<td>
<p>Arguments (e.g., <code>pars</code>, <code>regex_pars</code>) passed internally to
<code><a href="#topic+as.matrix.stanreg">as.matrix.stanreg</a></code> or <code>as.array.stanreg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To subset iterations, chains, or draws, use
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code> after making the
<code>draws</code> object. To subset variables use <code>...</code> to pass the <code>pars</code>
and/or <code>regex_pars</code> arguments to <code>as.matrix.stanreg</code> or
<code>as.array.stanreg</code> (these are called internally by
<code>as_draws.stanreg</code>), or use
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code> after making the
<code>draws</code> object.
</p>


<h3>Value</h3>

<p>A <code>draws</code> object from the
<span class="pkg"><a href="posterior.html#topic+posterior-package">posterior</a></span> package. See the
<span class="pkg">posterior</span> package documentation and vignettes for details on working
with these objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- stan_glm(mpg ~ wt + as.factor(cyl), data = mtcars)
as_draws_matrix(fit) # matrix format combines all chains 
as_draws_df(fit, regex_pars = "cyl")
posterior::summarize_draws(as_draws_array(fit))

</code></pre>

<hr>
<h2 id='stanreg-objects'>Fitted model objects</h2><span id='topic+stanreg-objects'></span>

<h3>Description</h3>

<p>The <span class="pkg">rstanarm</span> model-fitting functions return an object of class 
<code>'stanreg'</code>, which is a list containing at a minimum the components listed 
below. Each <code>stanreg</code> object will also have additional classes (e.g. 'aov', 
'betareg', 'glm', 'polr', etc.) and several additional components depending
on the model and estimation algorithm. <br />
<br />
Some additional details apply to models estimated using the <code><a href="#topic+stan_mvmer">stan_mvmer</a></code>
or <code><a href="#topic+stan_jm">stan_jm</a></code> modelling functions. The <code><a href="#topic+stan_mvmer">stan_mvmer</a></code> modelling 
function returns an object of class <code>'stanmvreg'</code>, which inherits the 
<code>'stanreg'</code> class, but has a number of additional elements described in the 
subsection below. The <code><a href="#topic+stan_jm">stan_jm</a></code> modelling function returns an object of class
<code>'stanjm'</code>, which inherits both the <code>'stanmvreg'</code> and <code>'stanreg'</code> 
classes, but has a number of additional elements described in the subsection below. 
Both the <code>'stanjm'</code> and <code>'stanmvreg'</code> classes have several of their own 
methods for situations in which the default <code>'stanreg'</code> methods are not 
suitable; see the <strong>See Also</strong> section below.
</p>


<h3>Elements for <code>stanreg</code> objects</h3>


<dl>
<dt><code>coefficients</code></dt><dd>
<p>Point estimates, as described in <code><a href="#topic+print.stanreg">print.stanreg</a></code>.
</p>
</dd>
<dt><code>ses</code></dt><dd>
<p>Standard errors based on <code><a href="stats.html#topic+mad">mad</a></code>, as described in
<code><a href="#topic+print.stanreg">print.stanreg</a></code>.
</p>
</dd>
<dt><code>residuals</code></dt><dd>
<p>Residuals of type <code>'response'</code>.
</p>
</dd>
<dt><code>fitted.values</code></dt><dd>
<p>Fitted mean values. For GLMs the linear predictors are transformed by the
inverse link function.
</p>
</dd>
<dt><code>linear.predictors</code></dt><dd>
<p>Linear fit on the link scale. For linear models this is the same as
<code>fitted.values</code>.
</p>
</dd>
<dt><code>covmat</code></dt><dd>
<p>Variance-covariance matrix for the coefficients based on draws from the
posterior distribution, the variational approximation, or the asymptotic 
sampling distribution, depending on the estimation algorithm.
</p>
</dd>
<dt><code>model,x,y</code></dt><dd>
<p>If requested, the the model frame, model matrix and response variable used, 
respectively.
</p>
</dd>
<dt><code>family</code></dt><dd>
<p>The <code><a href="stats.html#topic+family">family</a></code> object used.
</p>
</dd>
<dt><code>call</code></dt><dd>
<p>The matched call.
</p>
</dd>
<dt><code>formula</code></dt><dd>
<p>The model <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
</dd>
<dt><code>data,offset,weights</code></dt><dd>
<p>The <code>data</code>, <code>offset</code>, and <code>weights</code> arguments.
</p>
</dd>
<dt><code>algorithm</code></dt><dd>
<p>The estimation method used.
</p>
</dd>
<dt><code>prior.info</code></dt><dd>
<p>A list with information about the prior distributions used.
</p>
</dd>
<dt><code>stanfit,stan_summary</code></dt><dd>
<p>The object of <code><a href="rstan.html#topic+stanfit-class">stanfit-class</a></code> returned by RStan and a
matrix of various summary statistics from the stanfit object.
</p>
</dd>
<dt><code>rstan_version</code></dt><dd>
<p>The version of the <span class="pkg">rstan</span> package that was used to fit the model.
</p>
</dd>
</dl>



<h3>Elements for <code>stanmvreg</code> objects</h3>


<p>The <code>stanmvreg</code> objects contain the majority of the elements described
above for <code>stanreg</code> objects, but in most cases these will be a list with each
elements of the list correponding to one of the submodels (for example, 
the <code>family</code> element of a <code>stanmvreg</code> object will be a list with each 
element of the list containing the <code><a href="stats.html#topic+family">family</a></code> object for one
submodel). In addition, <code>stanmvreg</code> objects contain the following additional 
elements:
</p>
<dl>
<dt><code>cnms</code></dt><dd>
<p>The names of the grouping factors and group specific parameters, collapsed 
across the longitudinal or glmer submodels.
</p>
</dd>
<dt><code>flevels</code></dt><dd>
<p>The unique factor levels for each grouping factor, collapsed across the 
longitudinal or glmer submodels.
</p>
</dd> 
<dt><code>n_markers</code></dt><dd>
<p>The number of longitudinal or glmer submodels.
</p>
</dd> 
<dt><code>n_yobs</code></dt><dd>
<p>The number of observations for each longitudinal or glmer submodel.
</p>
</dd>
<dt><code>n_grps</code></dt><dd>
<p>The number of levels for each grouping factor (for models estimated using 
<code><a href="#topic+stan_jm">stan_jm</a></code>, this will be equal to <code>n_subjects</code> if the 
individual is the only grouping factor).
</p>
</dd>
<dt><code>runtime</code></dt><dd>
<p>The time taken to fit the model (in minutes).
</p>
</dd>
</dl>



<h3>Additional elements for <code>stanjm</code> objects</h3>


<p>The <code>stanjm</code> objects contain the elements described above for 
<code>stanmvreg</code> objects, but also contain the following additional 
elements:
</p>
<dl>
<dt><code>id_var,time_var</code></dt><dd>
<p>The names of the variables distinguishing between individuals, and 
representing time in the longitudinal submodel.
</p>
</dd> 
<dt><code>n_subjects</code></dt><dd>
<p>The number of individuals.
</p>
</dd>
<dt><code>n_events</code></dt><dd>
<p>The number of non-censored events.
</p>
</dd>  
<dt><code>eventtime,status</code></dt><dd>
<p>The event (or censoring) time and status indicator for each individual.
</p>
</dd>
<dt><code>basehaz</code></dt><dd>
<p>A list containing information about the baseline hazard.
</p>
</dd>
<dt><code>assoc</code></dt><dd>
<p>An array containing information about the association structure.
</p>
</dd>
<dt><code>epsilon</code></dt><dd>
<p>The width of the one-sided difference used to numerically evaluate the 
slope of the longitudinal trajectory; only relevant if a slope-based 
association structure was specified (e.g. etaslope, muslope, etc).
</p>
</dd>
<dt><code>qnodes</code></dt><dd>
<p>The number of Gauss-Kronrod quadrature nodes used to evaluate the 
cumulative hazard in the joint likelihood function.
</p>
</dd>        
</dl>



<h3>Note</h3>

<p>The <code><a href="#topic+stan_biglm">stan_biglm</a></code> function is an exception. It returns a 
<a href="rstan.html#topic+stanfit-class">stanfit</a> object rather than a stanreg object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanreg-methods">stanreg-methods</a></code>, <code><a href="#topic+stanmvreg-methods">stanmvreg-methods</a></code>
</p>

<hr>
<h2 id='summary.stanreg'>Summary method for stanreg objects</h2><span id='topic+summary.stanreg'></span><span id='topic+print.summary.stanreg'></span><span id='topic+as.data.frame.summary.stanreg'></span><span id='topic+summary.stanmvreg'></span><span id='topic+print.summary.stanmvreg'></span>

<h3>Description</h3>

<p>Summaries of parameter estimates and MCMC convergence diagnostics 
(Monte Carlo error, effective sample size, Rhat).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
summary(
  object,
  pars = NULL,
  regex_pars = NULL,
  probs = c(0.1, 0.5, 0.9),
  ...,
  digits = 1
)

## S3 method for class 'summary.stanreg'
print(x, digits = max(1, attr(x, "print.digits")), ...)

## S3 method for class 'summary.stanreg'
as.data.frame(x, ...)

## S3 method for class 'stanmvreg'
summary(object, pars = NULL, regex_pars = NULL, probs = NULL, ..., digits = 3)

## S3 method for class 'summary.stanmvreg'
print(x, digits = max(1, attr(x, "print.digits")), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stanreg_+3A_object">object</code></td>
<td>
<p>A fitted model object returned by one of the 
<span class="pkg">rstanarm</span> modeling functions. See <code><a href="#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_pars">pars</code></td>
<td>
<p>An optional character vector specifying a subset of parameters to
display. Parameters can be specified by name or several shortcuts can be 
used. Using <code>pars="beta"</code> will restrict the displayed parameters to 
only the regression coefficients (without the intercept). <code>"alpha"</code> 
can also be used as a shortcut for <code>"(Intercept)"</code>. If the model has 
varying intercepts and/or slopes they can be selected using <code>pars = 
"varying"</code>.
</p>
<p>In addition, for <code>stanmvreg</code> objects there are some additional shortcuts 
available. Using <code>pars = "long"</code> will display the 
parameter estimates for the longitudinal submodels only (excluding group-specific
pparameters, but including auxiliary parameters).
Using <code>pars = "event"</code> will display the 
parameter estimates for the event submodel only, including any association
parameters. 
Using <code>pars = "assoc"</code> will display only the 
association parameters. 
Using <code>pars = "fixef"</code> will display all fixed effects, but not
the random effects or the auxiliary parameters. 
<code>pars</code> and <code>regex_pars</code> are set to <code>NULL</code> then all 
fixed effect regression coefficients are selected, as well as any 
auxiliary parameters and the log posterior.   
</p>
<p>If <code>pars</code> is <code>NULL</code> all parameters are selected for a <code>stanreg</code>
object, while for a <code>stanmvreg</code> object all 
fixed effect regression coefficients are selected as well as any 
auxiliary parameters and the log posterior. See 
<strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_regex_pars">regex_pars</code></td>
<td>
<p>An optional character vector of <a href="base.html#topic+grep">regular 
expressions</a> to use for parameter selection. <code>regex_pars</code> can be used
in place of <code>pars</code> or in addition to <code>pars</code>. Currently, all
functions that accept a <code>regex_pars</code> argument ignore it for models fit
using optimization.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_probs">probs</code></td>
<td>
<p>For models fit using MCMC or one of the variational algorithms, 
an optional numeric vector of probabilities passed to 
<code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for formatting numbers when printing. 
When calling <code>summary</code>, the value of digits is stored as the 
<code>"print.digits"</code> attribute of the returned object.</p>
</td></tr>
<tr><td><code id="summary.stanreg_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.stanreg"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>mean_PPD diagnostic</h4>

<p>Summary statistics are also reported for <code>mean_PPD</code>, the sample
average posterior predictive distribution of the outcome. This is useful as a
quick diagnostic. A useful heuristic is to check if <code>mean_PPD</code> is
plausible when compared to <code>mean(y)</code>. If it is plausible then this does
<em>not</em> mean that the model is good in general (only that it can reproduce
the sample mean), however if <code>mean_PPD</code> is implausible then it is a sign
that something is wrong (severe model misspecification, problems with the
data, computational issues, etc.).
</p>



<h3>Value</h3>

<p>The <code>summary</code> method returns an object of class 
<code>"summary.stanreg"</code> (or <code>"summary.stanmvreg"</code>, inheriting 
<code>"summary.stanreg"</code>), which is a matrix of 
summary statistics and 
diagnostics, with attributes storing information for use by the
<code>print</code> method. The <code>print</code> method for <code>summary.stanreg</code> or
<code>summary.stanmvreg</code> objects is called for its side effect and just returns 
its input. The <code>as.data.frame</code> method for <code>summary.stanreg</code> 
objects converts the matrix to a data.frame, preserving row and column 
names but dropping the <code>print</code>-related attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prior_summary">prior_summary</a></code> to extract or print a summary of the 
priors used for a particular model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type != "windows" || .Platform$r_arch != "i386") {
if (!exists("example_model")) example(example_model) 
summary(example_model, probs = c(0.1, 0.9))

# These produce the same output for this example, 
# but the second method can be used for any model
summary(example_model, pars = c("(Intercept)", "size", 
                                paste0("period", 2:4)))
summary(example_model, pars = c("alpha", "beta"))

# Only show parameters varying by group
summary(example_model, pars = "varying")
as.data.frame(summary(example_model, pars = "varying"))
}
</code></pre>

<hr>
<h2 id='terms.stanmvreg'>terms method for stanmvreg objects</h2><span id='topic+terms.stanmvreg'></span>

<h3>Description</h3>

<p>terms method for stanmvreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanmvreg'
terms(x, fixed.only = TRUE, random.only = FALSE, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.stanmvreg_+3A_x">x</code>, <code id="terms.stanmvreg_+3A_fixed.only">fixed.only</code>, <code id="terms.stanmvreg_+3A_random.only">random.only</code>, <code id="terms.stanmvreg_+3A_...">...</code></td>
<td>
<p>See lme4:::terms.merMod.</p>
</td></tr>
<tr><td><code id="terms.stanmvreg_+3A_m">m</code></td>
<td>
<p>Integer specifying the number or name of the submodel</p>
</td></tr>
</table>

<hr>
<h2 id='terms.stanreg'>terms method for stanreg objects</h2><span id='topic+terms.stanreg'></span>

<h3>Description</h3>

<p>terms method for stanreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
terms(x, ..., fixed.only = TRUE, random.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.stanreg_+3A_x">x</code>, <code id="terms.stanreg_+3A_fixed.only">fixed.only</code>, <code id="terms.stanreg_+3A_random.only">random.only</code>, <code id="terms.stanreg_+3A_...">...</code></td>
<td>
<p>See lme4:::terms.merMod.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
