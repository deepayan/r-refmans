<!DOCTYPE html><html><head><title>Help for package GWmodel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GWmodel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GWmodel-package'>
<p>Geographically-Weighted Models</p></a></li>
<li><a href='#bw.ggwr'><p>Bandwidth selection for generalised geographically weighted regression (GWR)</p></a></li>
<li><a href='#bw.gtwr'><p>Bandwidth selection for GTWR</p></a></li>
<li><a href='#bw.gwda'><p>Bandwidth selection for GW Discriminant Analysis</p></a></li>
<li><a href='#bw.gwpca'><p>Bandwidth selection for Geographically Weighted Principal Components Analysis (GWPCA)</p></a></li>
<li><a href='#bw.gwr'><p>Bandwidth selection for basic GWR</p></a></li>
<li><a href='#bw.gwr.lcr'><p>Bandwidth selection for locally compensated ridge GWR (GWR-LCR)</p></a></li>
<li><a href='#bw.gwss.average'><p>Bandwidth selection for GW summary averages</p></a></li>
<li><a href='#DubVoter'><p>Voter turnout data in Greater Dublin(SpatialPolygonsDataFrame)</p></a></li>
<li><a href='#EWHP'><p>House price data set (DataFrame) in England and Wales</p></a></li>
<li><a href='#EWOutline'><p>Outline of England and Wales for data EWHP</p></a></li>
<li><a href='#Georgia'><p>Georgia census data set (csv file)</p></a></li>
<li><a href='#GeorgiaCounties'><p>Georgia counties data (SpatialPolygonsDataFrame)</p></a></li>
<li><a href='#ggwr.basic'><p>Generalised GWR models with Poisson and Binomial options</p></a></li>
<li><a href='#ggwr.cv'><p>Cross-validation score for a specified bandwidth for generalised GWR</p></a></li>
<li><a href='#ggwr.cv.contrib'><p>Cross-validation data at each observation location for a generalised GWR model</p></a></li>
<li><a href='#gtwr'><p>Geographically and Temporally Weighted Regression</p></a></li>
<li><a href='#gw.dist'><p>Distance matrix calculation</p></a></li>
<li><a href='#gw.pcplot'><p>Geographically weighted parallel coordinate plot for investigating multivariate data sets</p></a></li>
<li><a href='#gw.weight'><p>Weight matrix calculation</p></a></li>
<li><a href='#gwda'><p>GW Discriminant Analysis</p></a></li>
<li><a href='#gwpca'><p>GWPCA</p></a></li>
<li><a href='#gwpca.check.components'><p>Interaction tool with the GWPCA glyph map</p></a></li>
<li><a href='#gwpca.cv'><p>Cross-validation score for a specified bandwidth for GWPCA</p></a></li>
<li><a href='#gwpca.cv.contrib'><p>Cross-validation data at each observation location for a GWPCA</p></a></li>
<li><a href='#gwpca.glyph.plot'><p>Multivariate glyph plots of GWPCA loadings</p></a></li>
<li><a href='#gwpca.montecarlo.1'><p>Monte Carlo (randomisation) test for significance of GWPCA eigenvalue variability</p>
for the first component only - option 1</a></li>
<li><a href='#gwpca.montecarlo.2'><p>Monte Carlo (randomisation) test for significance of GWPCA eigenvalue variability</p>
for the first component only - option 2</a></li>
<li><a href='#gwr.basic'><p>Basic GWR model</p></a></li>
<li><a href='#gwr.bootstrap'><p>Bootstrap GWR</p></a></li>
<li><a href='#gwr.collin.diagno'><p>Local collinearity diagnostics for basic GWR</p></a></li>
<li><a href='#gwr.cv'><p>Cross-validation score for a specified bandwidth for basic GWR</p></a></li>
<li><a href='#gwr.cv.contrib'><p>Cross-validation data at each observation location for a basic GWR model</p></a></li>
<li><a href='#gwr.hetero'><p>Heteroskedastic GWR</p></a></li>
<li><a href='#gwr.lcr'><p>GWR with a locally-compensated ridge term</p></a></li>
<li><a href='#gwr.lcr.cv'><p>Cross-validation score for a specified bandwidth for GWR-LCR model</p></a></li>
<li><a href='#gwr.lcr.cv.contrib'><p>Cross-validation data at each observation location for the GWR-LCR model</p></a></li>
<li><a href='#gwr.mink.approach'><p>Minkovski approach for GWR</p></a></li>
<li><a href='#gwr.mink.matrixview'><p>Visualisation of the results from <code>gwr.mink.approach</code></p></a></li>
<li><a href='#gwr.mink.pval'><p>Select the values of p for the Minkowski approach for GWR</p></a></li>
<li><a href='#gwr.mixed'><p>Mixed GWR</p></a></li>
<li><a href='#gwr.model.selection'><p>Model selection for GWR with a given set of independent variables</p></a></li>
<li><a href='#gwr.model.sort'><p>Sort the results of the GWR model selection function <code>gwr.model.selection</code>.</p></a></li>
<li><a href='#gwr.model.view'><p>Visualise the GWR models from <code>gwr.model.selection</code></p></a></li>
<li><a href='#gwr.montecarlo'><p>Monte Carlo (randomisation) test for significance of GWR parameter variability</p></a></li>
<li><a href='#gwr.multiscale'><p>Multiscale GWR</p></a></li>
<li><a href='#gwr.predict'><p>GWR used as a spatial predictor</p></a></li>
<li><a href='#gwr.robust'><p>Robust GWR model</p></a></li>
<li><a href='#gwr.scalable'><p>Scalable GWR</p></a></li>
<li><a href='#gwr.t.adjust'><p>Adjust p-values for multiple hypothesis tests in basic GWR</p></a></li>
<li><a href='#gwr.write'><p>Write the GWR results into files</p></a></li>
<li><a href='#gwss'><p>Geographically weighted summary statistics (GWSS)</p></a></li>
<li><a href='#gwss.montecarlo'><p>Monte Carlo (randomisation) test for gwss</p></a></li>
<li><a href='#LondonBorough'><p>London boroughs data</p></a></li>
<li><a href='#LondonHP'><p>London house price data set (SpatialPointsDataFrame)</p></a></li>
<li><a href='#st.dist'><p>Spatio-temporal distance matrix calculation</p></a></li>
<li><a href='#USelect'><p>Results of the 2004 US presidential election at the county level (SpatialPolygonsDataFrame)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Geographically-Weighted Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), robustbase,sp (&gt; 1.4-0),Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, sf, grDevices, spacetime,spdep,spatialreg,FNN</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvoutlier, RColorBrewer, gstat,spData</td>
</tr>
<tr>
<td>Description:</td>
<td>Techniques from a particular branch of spatial statistics,termed geographically-weighted (GW) models. GW models suit situations when data are not described well by some global model, but where there are spatial regions where a suitably localised calibration provides a better description. 'GWmodel' includes functions to calibrate: GW summary statistics (Brunsdon et al., 2002)&lt;<a href="https://doi.org/10.1016%2Fs0198-9715%2801%2900009-6">doi:10.1016/s0198-9715(01)00009-6</a>&gt;, GW principal components analysis (Harris et al., 2011)&lt;<a href="https://doi.org/10.1080%2F13658816.2011.554838">doi:10.1080/13658816.2011.554838</a>&gt;, GW discriminant analysis (Brunsdon et al., 2007)&lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.2007.00709.x">doi:10.1111/j.1538-4632.2007.00709.x</a>&gt; and various forms of GW regression (Brunsdon et al., 1996)&lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1996.tb00936.x">doi:10.1111/j.1538-4632.1996.tb00936.x</a>&gt;; some of which are provided in basic and robust (outlier resistant) forms.</td>
</tr>
<tr>
<td>Author:</td>
<td>Binbin Lu[aut], Paul Harris[aut], Martin Charlton[aut], Chris Brunsdon[aut], Tomoki Nakaya[aut], Daisuke Murakami[aut],Isabella Gollini[ctb], Yigong Hu[ctb], Fiona H Evans[ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Binbin Lu &lt;binbinlu@whu.edu.cn&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 09:38:11 UTC; Lenovo</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 16:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='GWmodel-package'>
Geographically-Weighted Models
</h2><span id='topic+GWmodel-package'></span><span id='topic+GWmodel'></span>

<h3>Description</h3>

<p>In GWmodel, we introduce techniques from a particular branch of spatial statistics, 
termed geographically-weighted (GW) models. GW models suit situations when data are 
not described well by some global model, but where there are spatial regions where 
a suitably localised calibration provides a better description. GWmodel includes functions 
to calibrate: GW summary statistics, GW principal components analysis, GW discriminant analysis 
and various forms of GW regression; some of which are provided in basic and robust (outlier resistant) forms.
In particular, the high-performence computing technologies, including multi-thread and CUDA techniques are started
to be adopted for efficient calibrations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GWmodel</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.3-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>Acknowledgements: We gratefully acknowledge support from National Natural Science Foundation of China (42071368); Science Foundation Ireland 
under the National Development Plan through the award of a Strategic Research Centre 
grant 07-SRC-I1168.
</p>
<p>Beta versions can always be found at <a href="https://github.com/lbb220/GWmodel">https://github.com/lbb220/GWmodel</a>,
which includes all the newly developed functions for GW models.
</p>
<p>For latest tutorials on using GWmodel please go to: <a href="https://rpubs.com/gwmodel">https://rpubs.com/gwmodel</a>
</p>


<h3>Author(s)</h3>

<p>Binbin Lu, Paul Harris, Martin Charlton, Chris Brunsdon, Tomoki Nakaya, Daisuke Murakami,Isabella Gollini[ctb], Yigong Hu[ctb], Fiona H Evans[ctb]
</p>
<p>Maintainer: Binbin Lu &lt;binbinlu@whu.edu.cn&gt;
</p>


<h3>References</h3>

<p>Gollini I, Lu B, Charlton M, Brunsdon C, Harris P (2015) GWmodel: an R Package 
for exploring Spatial Heterogeneity using Geographically Weighted Models. Journal 
of Statistical Software, 63(17):1-50, doi: <a href="https://doi.org/10.18637/jss.v063.i17">10.18637/jss.v063.i17</a>
</p>
<p>Lu B, Harris P, Charlton M, Brunsdon C (2014) The GWmodel R Package: further 
topics for exploring Spatial Heterogeneity using Geographically Weighted Models.
Geo-spatial Information Science 17(2): 85-101, doi: <a href="https://doi.org/10.1080/10095020.2014.917453">10.1080/10095020.2014.917453</a>
</p>

<hr>
<h2 id='bw.ggwr'>Bandwidth selection for generalised geographically weighted regression (GWR)</h2><span id='topic+bw.ggwr'></span><span id='topic+ggwr.aic'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection to calibrate a generalised GWR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.ggwr(formula, data, family ="poisson", approach="CV",
kernel="bisquare",adaptive=FALSE, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.ggwr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, which can be specified by &ldquo;poisson&rdquo; or &ldquo;binomial&rdquo;</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_approach">approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.ggwr_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth
</p>


<h3>Note</h3>

<p>For a discontinuous kernel function, a bandwidth can be specified either as a fixed (constant) distance or 
as a fixed (constant) number of local data (i.e. an adaptive distance).  For a continuous kernel function, 
a bandwidth can be specified either as a fixed distance or as a 'fixed quantity that reflects local sample size'  
(i.e. still an 'adaptive' distance but the actual local sample size will be the sample size as functions are continuous).  
In practise a fixed bandwidth suits fairly regular sample configurations whilst an adaptive bandwidth suits highly irregular 
sample configurations. Adaptive bandwidths ensure sufficient (and constant) local information for each local calibration. 
This note is applicable to all GW models
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='bw.gtwr'>Bandwidth selection for GTWR</h2><span id='topic+bw.gtwr'></span><span id='topic+gtwr.cv'></span><span id='topic+gtwr.aic'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection to calibrate a GTWR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gtwr(formula, data, obs.tv, approach="CV",kernel="bisquare",adaptive=FALSE, 
        p=2, theta=0, longlat=F,lamda=0.05,t.units = "auto",ksi=0, st.dMat,
        verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gtwr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_obs.tv">obs.tv</code></td>
<td>
<p>a vector of time tags for each observation, which could be numeric or of <a href="base.html#topic+POSIXlt">POSIXlt</a> class</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_approach">approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) 
corresponds to the number of nearest neighbours (i.e. adaptive distance); default 
is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_lamda">lamda</code></td>
<td>
<p>an parameter between 0 and 1 for calculating spatio-temporal distance</p>
</td></tr> 
<tr><td><code id="bw.gtwr_+3A_t.units">t.units</code></td>
<td>
<p>	character string to define time unit</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_ksi">ksi</code></td>
<td>
<p>an parameter between 0 and PI for calculating spatio-temporal distance, 
see details in Wu et al. (2014)</p>
</td></tr> 
<tr><td><code id="bw.gtwr_+3A_st.dmat">st.dMat</code></td>
<td>
<p>a pre-specified spatio-temporal distance matrix</p>
</td></tr>
<tr><td><code id="bw.gtwr_+3A_verbose">verbose</code></td>
<td>
<p>logical variable to define whether show the selection procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth
</p>


<h3>Note</h3>

<p>The function is developed according to the articles by Huang et al. (2010) and 
Wu et al. (2014).
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Huang, B., Wu, B., &amp; Barry, M. (2010). Geographically and temporally weighted 
regression for modeling spatio-temporal variation in house prices. International
Journal of Geographical Information Science, 24, 383-401.
</p>
<p>Wu, B., Li, R., &amp; Huang, B. (2014). A geographically and temporally weighted 
autoregressive model with application to housing prices. International Journal 
of Geographical Information Science, 28, 1186-1204. 
</p>
<p>Fotheringham, A. S., Crespo, R., &amp; Yao, J. (2015). Geographical and Temporal 
Weighted Regression (GTWR). Geographical Analysis, 47, 431-452.
</p>

<hr>
<h2 id='bw.gwda'>Bandwidth selection for GW Discriminant Analysis</h2><span id='topic+bw.gwda'></span><span id='topic+wqda.cr'></span><span id='topic+wlda.cr'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection for GW Discriminant Analysis using a cross-validation approach only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gwda(formula, data, COV.gw = T, prior.gw = T, mean.gw = T,
                 prior = NULL, wqda = F, kernel = "bisquare", adaptive
                 = FALSE, p = 2, theta = 0, longlat = F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gwda_+3A_formula">formula</code></td>
<td>
<p>Model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame for training, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_cov.gw">COV.gw</code></td>
<td>
<p>if true, localised variance-covariance matrix is used for GW discriminant analysis; otherwise, global variance-covariance matrix is used</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_mean.gw">mean.gw</code></td>
<td>
<p>if true, localised mean is used for GW discriminant analysis; otherwise, global mean is used</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_prior.gw">prior.gw</code></td>
<td>
<p>if true, localised prior probability is used for GW discriminant analysis; otherwise, fixed prior probability is used</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_prior">prior</code></td>
<td>
<p>a vector of given prior probability</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_wqda">wqda</code></td>
<td>
<p>if TRUE, a weighted quadratic discriminant analysis will be applied; otherwise a weighted linear discriminant analysis will be applied</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gwda_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth.
</p>


<h3>Note</h3>

<p>For a discontinuous kernel function, a bandwidth can be specified either as a fixed (constant) distance or 
as a fixed (constant) number of local data (i.e. an adaptive distance).  For a continuous kernel function, 
a bandwidth can be specified either as a fixed distance or as a 'fixed quantity that reflects local sample size'  
(i.e. still an 'adaptive' distance but the actual local sample size will be the sample size as functions are continuous).  
In practise a fixed bandwidth suits fairly regular sample configurations whilst an adaptive bandwidth suits highly irregular 
sample configurations. Adaptive bandwidths ensure sufficient (and constant) local information for each local calibration. 
This note is applicable to all GW models
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='bw.gwpca'>Bandwidth selection for Geographically Weighted Principal Components Analysis (GWPCA)</h2><span id='topic+bw.gwpca'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection to calibrate a basic or robust GWPCA via a cross-validation approach only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gwpca(data,vars,k=2, robust=FALSE,kernel="bisquare",adaptive=FALSE,p=2, 
         theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gwpca_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_k">k</code></td>
<td>
<p>the number of retained components, and it must be less than the number of variables</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gwpca_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth
</p>


<h3>Note</h3>

<p>For a discontinuous kernel function, a bandwidth can be specified either as a fixed (constant) distance or 
as a fixed (constant) number of local data (i.e. an adaptive distance).  For a continuous kernel function, 
a bandwidth can be specified either as a fixed distance or as a 'fixed quantity that reflects local sample size'  
(i.e. still an 'adaptive' distance but the actual local sample size will be the sample size as functions are continuous).  
In practise a fixed bandwidth suits fairly regular sample configurations whilst an adaptive bandwidth suits highly irregular 
sample configurations. Adaptive bandwidths ensure sufficient (and constant) local information for each local calibration. 
This note is applicable to all GW models
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2015)
Enhancements to a geographically weighted principal components analysis in the context of an application to an environmental data set.
Geographical Analysis 47: 146-172
</p>

<hr>
<h2 id='bw.gwr'>Bandwidth selection for basic GWR</h2><span id='topic+bw.gwr'></span><span id='topic+gwr.aic'></span><span id='topic+gold'></span><span id='topic+AICc_rss1'></span><span id='topic+gw_BIC'></span><span id='topic+e_vec'></span><span id='topic+fitted'></span><span id='topic+gw_cv_all'></span><span id='topic+gw_cv_all_cuda'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection to calibrate a basic GWR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gwr(formula, data, approach="CV", kernel="bisquare",
       adaptive=FALSE, p=2, theta=0, longlat=F, dMat,
       parallel.method=F,parallel.arg=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gwr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_approach">approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_parallel.method">parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
&quot;omp&quot;: multi-thread technique with the OpenMP API, 
&quot;cluster&quot;: multi-process technique with the <span class="pkg">parallel</span> package,
&quot;cuda&quot;: parallel computing technique with CUDA</p>
</td></tr>
<tr><td><code id="bw.gwr_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is &quot;omp&quot;, parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cluster&quot;, parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cuda&quot;,  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth
</p>


<h3>Note</h3>

<p>For a discontinuous kernel function, a bandwidth can be specified either as a fixed (constant) distance or 
as a fixed (constant) number of local data (i.e. an adaptive distance).  For a continuous kernel function, 
a bandwidth can be specified either as a fixed distance or as a 'fixed quantity that reflects local sample size'  
(i.e. still an 'adaptive' distance but the actual local sample size will be the sample size as functions are continuous).  
In practise a fixed bandwidth suits fairly regular sample configurations whilst an adaptive bandwidth suits highly irregular 
sample configurations. Adaptive bandwidths ensure sufficient (and constant) local information for each local calibration. 
This note is applicable to all GW models
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='bw.gwr.lcr'>Bandwidth selection for locally compensated ridge GWR (GWR-LCR)</h2><span id='topic+bw.gwr.lcr'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selection for <a href="#topic+gwr.lcr">gwr.lcr</a> via a cross-validation approach only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gwr.lcr(formula, data, kernel="bisquare",
        lambda=0,lambda.adjust=FALSE,cn.thresh=NA,
        adaptive=FALSE, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gwr.lcr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_lambda">lambda</code></td>
<td>
<p>option for a globally-defined (constant) ridge parameter. Default is lambda=0, which gives a basic GWR fit</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_lambda.adjust">lambda.adjust</code></td>
<td>
<p>a locally-varying ridge parameter. Default FALSE, refers to: (i) a basic GWR without
a local ridge adjustment (i.e. lambda=0, everywhere); or (ii) a penalised GWR with a global ridge adjustment 
(i.e. lambda is user-specified as some constant, other than 0 everywhere); if TRUE, use cn.tresh
to set the maximum condition number. For locations with a condition number (for its local design matrix), 
above this user-specified threshold, a local ridge parameter is found</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_cn.thresh">cn.thresh</code></td>
<td>
<p>maximum value for condition number, commonly set between 20 and 30</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gwr.lcr_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidth
</p>


<h3>Note</h3>

<p>For a discontinuous kernel function, a bandwidth can be specified either as a fixed (constant) distance or 
as a fixed (constant) number of local data (i.e. an adaptive distance).  For a continuous kernel function, 
a bandwidth can be specified either as a fixed distance or as a 'fixed quantity that reflects local sample size'  
(i.e. still an 'adaptive' distance but the actual local sample size will be the sample size as functions are continuous).  
In practise a fixed bandwidth suits fairly regular sample configurations whilst an adaptive bandwidth suits highly irregular 
sample configurations. Adaptive bandwidths ensure sufficient (and constant) local information for each local calibration. 
This note is applicable to all GW models
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Gollini I, Lu B, Charlton M, Brunsdon C, Harris P (2015) GWmodel: an R Package for 
exploring Spatial Heterogeneity using Geographically Weighted Models.  Journal of 
Statistical Software 63(17): 1-50
</p>

<hr>
<h2 id='bw.gwss.average'>Bandwidth selection for GW summary averages</h2><span id='topic+bw.gwss.average'></span><span id='topic+gw.mean.cv'></span><span id='topic+gw.median.cv'></span><span id='topic+gw.average.cv'></span><span id='topic+gw.average.cv.contrib'></span>

<h3>Description</h3>

<p>A function for automatic bandwidth selections to calculate GW summary averages, including means and medians, via a cross-validation approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.gwss.average(data, summary.locat, vars, kernel = "bisquare", adaptive = FALSE, 
               p = 2, theta = 0, longlat = F, dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.gwss.average_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_summary.locat">summary.locat</code></td>
<td>
<p>a Spatial*DataFrame object for providing summary locations, 
i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame 
as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be summarized</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="bw.gwss.average_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adaptive or fixed distance bandwidths (in a two-column matrix) for calculating the averages of each variable.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='DubVoter'>Voter turnout data in Greater Dublin(SpatialPolygonsDataFrame)</h2><span id='topic+DubVoter'></span><span id='topic+Dub.voter'></span>

<h3>Description</h3>

<p>Voter turnout and social characters data in Greater Dublin for the 2002 General election and the 2002 census.
Note that this data set was originally thought to relate to 2004, so for continuity we have retained the associated variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DubVoter)</code></pre>


<h3>Format</h3>

<p>A SpatialPolygonsDataFrame with 322 electoral divisions on the following 11 variables.
</p>

<dl>
<dt>DED_ID</dt><dd><p>a vector of ID</p>
</dd>
<dt>X</dt><dd><p>a numeric vector of x coordinates</p>
</dd>
<dt>Y</dt><dd><p>a numeric vector of y coordinates</p>
</dd>
<dt>DiffAdd</dt><dd><p>percentage of the population in each ED who are one-year migrants (i.e. moved to a different address 1 year ago)</p>
</dd>
<dt>LARent</dt><dd><p>percentage of the population in each ED who are local authority renters</p>
</dd>
<dt>SC1</dt><dd><p>percentage of the population in each ED who are social class one (high social class)</p>
</dd>
<dt>Unempl</dt><dd><p>percentage of the population in each ED who are unemployed</p>
</dd>
<dt>LowEduc</dt><dd><p>percentage of the population in each ED who are with little formal education</p>
</dd>
<dt>Age18_24</dt><dd><p>percentage of the population in each ED who are age group 18-24</p>
</dd>
<dt>Age25_44</dt><dd><p>percentage of the population in each ED who are age group 25-44</p>
</dd>
<dt>Age45_64</dt><dd><p>percentage of the population in each ED who are age group 45-64</p>
</dd>
<dt>GenEl2004</dt><dd><p>percentage of population in each ED who voted in 2004 election</p>
</dd>    
</dl>



<h3>Details</h3>

<p>Variables are from DubVoter.shp.
</p>


<h3>References</h3>

<p>Kavanagh A (2006) Turnout or turned off? Electoral participation in Dublin in the early 21st Century. Journal of Irish Urban Studies 3(2):1-24
</p>
<p>Harris P, Brunsdon C, Charlton M (2011) Geographically weighted principal components analysis.  International Journal of Geographical Information Science 25 (10):1717-1736
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DubVoter)
ls()
## Not run: 
spplot(Dub.voter,names(Dub.voter)[4:12])

## End(Not run)
</code></pre>

<hr>
<h2 id='EWHP'>House price data set (DataFrame) in England and Wales</h2><span id='topic+EWHP'></span><span id='topic+ewhp'></span>

<h3>Description</h3>

<p>A house price data set for England and Wales from 2001 with 9 hedonic (explanatory) variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EWHP)</code></pre>


<h3>Format</h3>

<p>A data frame with 519 observations on the following 12 variables.
</p>

<dl>
<dt>Easting</dt><dd><p>a numeric vector, X coordinate</p>
</dd>
<dt>Northing</dt><dd><p>a numeric vector, Y coordinate</p>
</dd>
<dt>PurPrice</dt><dd><p>a numeric vector, the purchase price of the property</p>
</dd>
<dt>BldIntWr</dt><dd><p>a numeric vector, 1 if the property was built during the world war, 0 otherwise</p>
</dd>
<dt>BldPostW</dt><dd><p>a numeric vector, 1 if the property was built after the world war, 0 otherwise</p>
</dd>
<dt>Bld60s</dt><dd><p>a numeric vector, 1 if the property was built between 1960 and 1969, 0 otherwise</p>
</dd>
<dt>Bld70s</dt><dd><p>a numeric vector, 1 if the property was built between 1970 and 1979, 0 otherwise</p>
</dd>
<dt>Bld80s</dt><dd><p>a numeric vector, 1 if the property was built between 1980 and 1989, 0 otherwise</p>
</dd>
<dt>TypDetch</dt><dd><p>a numeric vector, 1 if the property is detached (i.e. it is a stand-alone house), 0 otherwise</p>
</dd>
<dt>TypSemiD</dt><dd><p>a numeric vector, 1 if the property is semi detached, 0 otherwise</p>
</dd>
<dt>TypFlat</dt><dd><p>a numeric vector, if the property is a flat (or 'apartment' in the USA), 0 otherwise</p>
</dd>
<dt>FlrArea</dt><dd><p>a numeric vector, floor area of the property in square metres</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E. (2002), Geographically Weighted Regression: 
The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
data(EWHP)
head(ewhp)
houses.spdf &lt;- SpatialPointsDataFrame(ewhp[, 1:2], ewhp)
 ####Get the border of England and Wales
data(EWOutline)
plot(ewoutline)
plot(houses.spdf, add = TRUE, pch = 16)
</code></pre>

<hr>
<h2 id='EWOutline'>Outline of England and Wales for data <a href="#topic+EWHP">EWHP</a></h2><span id='topic+ewoutline'></span>

<h3>Description</h3>

<p>Outline (SpatialPolygonsDataFrame) of the England and Wales house price data <a href="#topic+EWHP">EWHP</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EWOutline)</code></pre>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='Georgia'>Georgia census data set (csv file)</h2><span id='topic+Georgia'></span><span id='topic+Gedu.df'></span>

<h3>Description</h3>

<p>Census data from the county of Georgia, USA 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Georgia)</code></pre>


<h3>Format</h3>

<p>A data frame with 159 observations on the following 13 variables.
</p>

<dl>
<dt>AreaKey</dt><dd><p>An identification number for each county</p>
</dd>
<dt>Latitude</dt><dd><p>The latitude of the county centroid</p>
</dd>
<dt>Longitud</dt><dd><p>The longitude of the county centroid</p>
</dd>
<dt>TotPop90</dt><dd><p>Population of the county in 1990</p>
</dd>
<dt>PctRural</dt><dd><p>Percentage of the county population defined as rural</p>
</dd>
<dt>PctBach</dt><dd><p>Percentage of the county population with a bachelors degree</p>
</dd>
<dt>PctEld</dt><dd><p>Percentage of the county population aged 65 or over</p>
</dd>
<dt>PctFB</dt><dd><p>Percentage of the county population born outside the US</p>
</dd>
<dt>PctPov</dt><dd><p>Percentage of the county population living below the poverty line</p>
</dd>
<dt>PctBlack</dt><dd><p>Percentage of the county population who are black</p>
</dd>
<dt>ID</dt><dd><p>a numeric vector of IDs</p>
</dd>
<dt>X</dt><dd><p>a numeric vector of x coordinates</p>
</dd>
<dt>Y</dt><dd><p>a numeric vector of y coordinates</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set can also be found in GWR 3 and in spgwr.
</p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Georgia)
ls()
coords &lt;- cbind(Gedu.df$X, Gedu.df$Y)
educ.spdf &lt;- SpatialPointsDataFrame(coords, Gedu.df)
spplot(educ.spdf, names(educ.spdf)[4:10])
</code></pre>

<hr>
<h2 id='GeorgiaCounties'>Georgia counties data (SpatialPolygonsDataFrame)</h2><span id='topic+Gedu.counties'></span>

<h3>Description</h3>

<p>The Georgia census data with boundaries for mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GeorgiaCounties)</code></pre>


<h3>Details</h3>

<p>This data set can also be found in GWR 3 and in spgwr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GeorgiaCounties)
plot(Gedu.counties)
data(Georgia)
coords &lt;- cbind(Gedu.df$X, Gedu.df$Y)
educ.spdf &lt;- SpatialPointsDataFrame(coords, Gedu.df)
plot(educ.spdf, add=TRUE)

</code></pre>

<hr>
<h2 id='ggwr.basic'>Generalised GWR models with Poisson and Binomial options</h2><span id='topic+ggwr.basic'></span><span id='topic+gwr.generalised'></span><span id='topic+gwr.binomial'></span><span id='topic+gwr.binomial.wt'></span><span id='topic+gwr.poisson'></span><span id='topic+gwr.poisson.wt'></span><span id='topic+gwr.fitted'></span><span id='topic+print.ggwrm'></span>

<h3>Description</h3>

<p>This function implements generalised GWR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwr.basic(formula, data, regression.points, bw, family =
                 "poisson", kernel = "bisquare", adaptive = FALSE, cv =
                 T, tol = 1e-05, maxiter = 20, p = 2, theta = 0,
                 longlat = F, dMat, dMat1)

 ## S3 method for class 'ggwrm'
print(x, ...)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwr.basic_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by bw.ggwr();fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, which can be specified by &ldquo;poisson&rdquo; or &ldquo;binomial&rdquo;</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube:  wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar:   wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_cv">cv</code></td>
<td>
<p>if TRUE, cross-validation data will be calculated</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_tol">tol</code></td>
<td>
<p>the threshold that determines the convergence of the IRLS procedure</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of times to try the IRLS procedure</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix between regression points and observations, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_dmat1">dMat1</code></td>
<td>
<p>a square distance matrix between each pair of observations, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;ggwrm&rdquo;, returned by the function <a href="#topic+gwr.generalised">gwr.generalised</a></p>
</td></tr>
<tr><td><code id="ggwr.basic_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;ggwrm&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>glm.res</code></td>
<td>
<p>an object of class inheriting from &ldquo;glm&rdquo; which inherits from the class &ldquo;lm&rdquo;, see <a href="stats.html#topic+glm">glm</a>. </p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with fit.points,GWR coefficient estimates, y value,predicted values, coefficient standard errors and t-values in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>a data vector consisting of the cross-validation data</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that this function calibrates a Generalised GWR model via an approximating 
algorithm, which is different from the back-fitting algorithm used in the GWR4 software
by  Tomoki Nakaya.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Nakaya, T., A. S. Fotheringham, C. Brunsdon &amp; M. Charlton (2005) Geographically 
weighted Poisson regression for disease association mapping. Statistics in Medicine, 
24, 2695-2717.
</p>
<p>Nakaya, T., M. Charlton, S. Fotheringham &amp; C. Brunsdon. 2009. How to use SGWRWIN (GWR4.0). 
Maynooth, Ireland: National Centre for Geocomputation.
</p>
<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LondonHP)
## Not run: 
DM&lt;-gw.dist(dp.locat=coordinates(londonhp))
bw.f1 &lt;- bw.ggwr(BATH2~FLOORSZ,data=londonhp, dMat=DM)
res.poisson&lt;-ggwr.basic(BATH2~FLOORSZ, bw=bw.f1,data=londonhp, dMat=DM)
bw.f2 &lt;- bw.ggwr(BATH2~FLOORSZ,data=londonhp, dMat=DM,family ="binomial")
res.binomial&lt;-ggwr.basic(BATH2~FLOORSZ, bw=bw.f2,data=londonhp, dMat=DM,
              family ="binomial")

## End(Not run)
</code></pre>

<hr>
<h2 id='ggwr.cv'>Cross-validation score for a specified bandwidth for generalised GWR</h2><span id='topic+ggwr.cv'></span>

<h3>Description</h3>

<p>This function finds the cross-validation score for a specified bandwidth for generalised GWR.
It can be used to construct the bandwidth function across all possible bandwidths and compared to that found automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwr.cv(bw, X, Y,family="poisson", kernel="bisquare",adaptive=F, dp.locat,  
        p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwr.cv_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, which can be specified by &ldquo;poisson&rdquo; or &ldquo;binomial&rdquo;</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="ggwr.cv_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV.score</code></td>
<td>
<p>cross-validation score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='ggwr.cv.contrib'>Cross-validation data at each observation location for a generalised GWR model</h2><span id='topic+ggwr.cv.contrib'></span>

<h3>Description</h3>

<p>This function finds the individual cross-validation score at each observation location, for a generalised GWR model, for a specified bandwidth.
These data can be mapped to detect unusually high or low cross-validations scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwr.cv.contrib(bw, X, Y,family="poisson", kernel="bisquare",adaptive=F, 
                dp.locat, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwr.cv.contrib_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, which can be specified by &ldquo;poisson&rdquo; or &ldquo;binomial&rdquo;</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="ggwr.cv.contrib_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV</code></td>
<td>
<p>a data vector consisting of squared residuals, whose sum is the cross-validation score for the specified bandwidth</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gtwr'>Geographically and Temporally Weighted Regression</h2><span id='topic+gtwr'></span><span id='topic+print.gtwrm'></span><span id='topic+ti.distv'></span><span id='topic+ti.distm'></span><span id='topic+ti.dist'></span>

<h3>Description</h3>

<p>A function for calibrating a Geographically and Temporally Weighted Regression 
(GTWR) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtwr(formula, data, regression.points, obs.tv, reg.tv, st.bw, kernel="bisquare",
     adaptive=FALSE, p=2, theta=0, longlat=F,lamda=0.05,t.units = "auto",ksi=0,
     st.dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtwr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gtwr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gtwr_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>; Note that no diagnostic information will returned if it is assigned</p>
</td></tr>
<tr><td><code id="gtwr_+3A_obs.tv">obs.tv</code></td>
<td>
<p>a vector of time tags for each observation, which could be numeric or of <a href="base.html#topic+POSIXlt">POSIXlt</a> class</p>
</td></tr>
<tr><td><code id="gtwr_+3A_reg.tv">reg.tv</code></td>
<td>
<p>a vector of time tags for each regression location, which could be numeric or of <a href="base.html#topic+POSIXlt">POSIXlt</a> class</p>
</td></tr>
<tr><td><code id="gtwr_+3A_st.bw">st.bw</code></td>
<td>
<p>spatio-temporal bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gtwr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gtwr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) 
corresponds to the number of nearest neighbours (i.e. adaptive distance); default 
is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gtwr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gtwr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gtwr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gtwr_+3A_lamda">lamda</code></td>
<td>
<p>an parameter between 0 and 1 for calculating spatio-temporal distance</p>
</td></tr> 
<tr><td><code id="gtwr_+3A_t.units">t.units</code></td>
<td>
<p>	character string to define time unit</p>
</td></tr>
<tr><td><code id="gtwr_+3A_ksi">ksi</code></td>
<td>
<p>an parameter between 0 and PI for calculating spatio-temporal distance, 
see details in Wu et al. (2014)</p>
</td></tr> 
<tr><td><code id="gtwr_+3A_st.dmat">st.dMat</code></td>
<td>
<p>a pre-specified spatio-temporal distance matrix, and can be calculated via the function <a href="#topic+st.dist">st.dist</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gtwrm&rdquo;:
</p>
<table>
<tr><td><code>GTW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GTW.diagnostic</code></td>
<td>
<p>a list class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>an object of class inheriting from &ldquo;lm&rdquo;, see <a href="stats.html#topic+lm">lm</a>. </p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with fit.points,
GTWR coefficient estimates, y value,predicted values, coefficient standard errors 
and t-values in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function implements GTWR model proposed by Huang et al. (2010) and 
Wu et al. (2014).
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Huang, B., Wu, B., &amp; Barry, M. (2010). Geographically and temporally weighted 
regression for modeling spatio-temporal variation in house prices. International
Journal of Geographical Information Science, 24, 383-401.
</p>
<p>Wu, B., Li, R., &amp; Huang, B. (2014). A geographically and temporally weighted 
autoregressive model with application to housing prices. International Journal 
of Geographical Information Science, 28, 1186-1204. 
</p>
<p>Fotheringham, A. S., Crespo, R., &amp; Yao, J. (2015). Geographical and Temporal 
Weighted Regression (GTWR). Geographical Analysis, 47, 431-452.
</p>

<hr>
<h2 id='gw.dist'>Distance matrix calculation</h2><span id='topic+gw.dist'></span><span id='topic+gw_dist'></span>

<h3>Description</h3>

<p>Calculate a distance vector(matrix) between any GW model calibration point(s) and the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw.dist(dp.locat, rp.locat, focus=0, p=2, theta=0, longlat=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw.dist_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a numeric matrix of two columns giving the coordinates of the data points</p>
</td></tr>
<tr><td><code id="gw.dist_+3A_rp.locat">rp.locat</code></td>
<td>
<p>a numeric matrix of two columns giving the coordinates of the GW model calibration points</p>
</td></tr>
<tr><td><code id="gw.dist_+3A_focus">focus</code></td>
<td>
<p>an integer, indexing to the current GW model point, if focus=0, all the distances between all the GW model calibration points and data points will be calculated and a distance matrix will be returned; if 0&lt;focus&lt;length(rp.locat), then the distances between the 'focus'th GW model points and data points will be calculated and a distance vector will be returned</p>
</td></tr>
<tr><td><code id="gw.dist_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gw.dist_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gw.dist_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric distance matrix or vector;
matrix with its rows corresponding to the observations and its columns corresponds to the GW model calibration points.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code> in <span class="pkg">stats</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>dp&lt;-cbind(sample(100),sample(100))
rp&lt;-cbind(sample(10),sample(10))
#Euclidean distance metric is used.
dist.v1&lt;-gw.dist(dp.locat=dp, focus=5, p=2, theta=0, longlat=FALSE)
#Manhattan distance metric is used.
#The coordinate system is rotated by an angle 0.5 in radian.
dist.v2&lt;-gw.dist(dp.locat=dp, focus=5, p=1, theta=0.5)
#Great Circle distance metric is used.
dist.v3&lt;-gw.dist(dp.locat=dp, focus=5, longlat=TRUE)
#A generalized Minkowski distance metric is used with p= 0.75 .
#The coordinate system is rotated by an angle 0.8 in radian.
dist.v4&lt;-gw.dist(dp.locat=dp,rp.locat=rp, focus=5, p=0.75,theta=0.8)
################################
#matrix is calculated
#Euclidean distance metric is used.
dist.m1&lt;-gw.dist(dp.locat=dp, p=2, theta=0, longlat=FALSE)
#Manhattan distance metric is used.
#The coordinate system is rotated by an angle 0.5 in radian.
dist.m2&lt;-gw.dist(dp.locat=dp, p=1, theta=0.5)
#Great Circle distance metric is used.
#dist.m3&lt;-gw.dist(dp.locat=dp, longlat=TRUE)
#A generalized Minkowski distance metric is used with p= 0.75 .
#The coordinate system is rotated by an angle 0.8 in radian.
dist.m4&lt;-gw.dist(dp.locat=dp,rp.locat=rp, p=0.75,theta=0.8)
</code></pre>

<hr>
<h2 id='gw.pcplot'>Geographically weighted parallel coordinate plot for investigating multivariate data sets</h2><span id='topic+gw.pcplot'></span>

<h3>Description</h3>

<p>This function provides a geographically weighted parallel coordinate plot for locally investigating a multivariate data set.  It has an option that weights the lines of the plot with increasing levels of transparency, according to their observation's distance from a specified focal/observation point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw.pcplot(data,vars,focus,bw,adaptive = FALSE, ylim=NULL,ylab="",fixtrans=FALSE, 
          p=2, theta=0, longlat=F,dMat,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw.pcplot_+3A_data">data</code></td>
<td>
<p> a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_focus">focus</code></td>
<td>
<p>an integer, indexing to the observation point</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_fixtrans">fixtrans</code></td>
<td>
<p>if TRUE, the transparency of the neighbouring observation plot lines increases with distance; If FALSE a standard (non-spatial) parallel coordinate plot is returned.</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gw.pcplot_+3A_...">...</code></td>
<td>
<p>other graphical parameters, (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris P, Brunsdon C, Charlton M, Juggins S, Clarke A (2014) Multivariate spatial 
outlier detection using robust geographically weighted methods.  Mathematical 
Geosciences 46(1) 1-31
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2015) Enhancements to a 
geographically weighted principal components analysis in the context of an 
application to an environmental data set.  Geographical Analysis 47: 146-172
</p>

<hr>
<h2 id='gw.weight'>Weight matrix calculation</h2><span id='topic+gw.weight'></span><span id='topic+gw_weight_vec'></span><span id='topic+gw_weight_mat'></span><span id='topic+gw_weight'></span>

<h3>Description</h3>

<p>Calculate a weight vector(matrix) from a distance vector(matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw.weight(vdist,bw,kernel,adaptive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw.weight_+3A_vdist">vdist</code></td>
<td>
<p>a distance matrix or vector</p>
</td></tr>
<tr><td><code id="gw.weight_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gw.weight_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gw.weight_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric weight matrix or vector;
matrix with its rows corresponding to the observations and its columns corresponds to the GW model calibration points.
</p>


<h3>Note</h3>

<p>The gaussian and exponential kernel functions are continuous and valued in the interval (0,1]; while bisquare, tricube and 
boxcar kernel functions are discontinuous and valued in the interval [0,1]. Notably, the upper limit of the bandwidth is exactly
the number of observations when the adaptive kernel is used. In this function, the adaptive bandwidth will be specified as the number
of observations even though a larger number is assigned. The function will be the same as a global application function (i.e. all weights are 1) when 
the adaptive bandwidth is equal to or larger than the number of observations when using the boxcar kernel function.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwda'>GW Discriminant Analysis</h2><span id='topic+gwda'></span><span id='topic+print.gwda'></span><span id='topic+grouping.xy'></span><span id='topic+wqda'></span><span id='topic+wlda'></span><span id='topic+splitx'></span><span id='topic+wmean'></span><span id='topic+wvarcov'></span><span id='topic+wprior'></span><span id='topic+confusion.matrix'></span>

<h3>Description</h3>

<p>This function implements GW discriminant analysis, where location-wise probabilities and their associated entropy are also calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwda(formula, data, predict.data,validation = T, COV.gw=T, 
                 mean.gw=T, prior.gw=T, prior=NULL, wqda =F,
                kernel = "bisquare", adaptive = FALSE, bw,
                 p = 2, theta = 0, longlat = F,dMat)
## S3 method for class 'gwda'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwda_+3A_formula">formula</code></td>
<td>
<p>Model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwda_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame for training, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwda_+3A_predict.data">predict.data</code></td>
<td>
<p>a Spatial*DataFrame object for prediction, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as 
defined in package <span class="pkg">sp</span>; if it is not given, the traing data will be predicted using leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="gwda_+3A_validation">validation</code></td>
<td>
<p>If TRUE, the results from the prediction will be validated and the correct proportion will be calculated.</p>
</td></tr>
<tr><td><code id="gwda_+3A_cov.gw">COV.gw</code></td>
<td>
<p>if true, localised variance-covariance matrix is used for GW discriminant analysis; otherwise, global variance-covariance matrix is used</p>
</td></tr>
<tr><td><code id="gwda_+3A_mean.gw">mean.gw</code></td>
<td>
<p>if true, localised mean is used for GW discriminant analysis; otherwise, global mean is used</p>
</td></tr>
<tr><td><code id="gwda_+3A_prior.gw">prior.gw</code></td>
<td>
<p>if true, localised prior probability is used for GW discriminant analysis; otherwise, fixed prior probability is used</p>
</td></tr>
<tr><td><code id="gwda_+3A_prior">prior</code></td>
<td>
<p>a vector of given prior probability</p>
</td></tr>
<tr><td><code id="gwda_+3A_wqda">wqda</code></td>
<td>
<p>if TRUE, weighted quadratic discriminant analysis will be applied; otherwise weighted linear discriminant analysis will be applied</p>
</td></tr>
<tr><td><code id="gwda_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwda_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwda_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwpca">bw.gwpca</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwda_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwda_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwda_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwda_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwda_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwda&rdquo;</p>
</td></tr>
<tr><td><code id="gwda_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;gwda&rdquo;. This includes a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object, SDF, (see package &ldquo;sp&rdquo;) with, following the use of new version of <a href="#topic+gwda">gwda</a>, the probabilities for
each level, the highest probabiliity and the entropy of the probabilities in its &ldquo;data&rdquo; slot.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Brunsdon, C, Fotheringham S,  and Charlton, M (2007),
Geographically Weighted Discriminant Analysis, Geographical Analysis 39:376-396
</p>
<p>Lu B, Harris P, Charlton M, Brunsdon C (2014) The GWmodel R Package: further 
topics for exploring Spatial Heterogeneity using Geographically Weighted Models.
Geo-spatial Information Science 17(2): 85-101
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(USelect)
 dMat &lt;- gw.dist(coordinates(USelect2004))
 bw &lt;- bw.gwda(winner~unemploy+pctcoled+PEROVER65+pcturban+WHITE,data=USelect2004,
 adaptive=TRUE,dMat=dMat)
 ge.gwda &lt;- gwda(winner~unemploy+pctcoled+PEROVER65+pcturban+WHITE,data=USelect2004,
 bw=bw,adaptive=TRUE,dMat=dMat)
 table(USelect2004$winner,ge.gwda$SDF$group.predicted)
 spplot(ge.gwda$SDF, "entropy")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='gwpca'>GWPCA</h2><span id='topic+gwpca'></span><span id='topic+robustSvd'></span><span id='topic+rwpca'></span><span id='topic+wpca'></span><span id='topic+wt.median'></span><span id='topic+print.gwpca'></span>

<h3>Description</h3>

<p>This function implements basic or robust GWPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca(data, elocat, vars, k = 2, robust = FALSE, kernel = "bisquare",
                  adaptive = FALSE, bw, p = 2, theta = 0, longlat = F, cv = T, scores=F,
                  dMat)
## S3 method for class 'gwpca'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwpca_+3A_elocat">elocat</code></td>
<td>
<p>a two-column numeric array or Spatial*DataFrame object for providing evaluation locations, 
i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame 
as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwpca_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td></tr>
<tr><td><code id="gwpca_+3A_k">k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td></tr>
<tr><td><code id="gwpca_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="gwpca_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwpca_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwpca_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwpca">bw.gwpca</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwpca_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwpca_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwpca_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwpca_+3A_cv">cv</code></td>
<td>
<p>If TRUE, cross-validation data will be found that are used to calculate the cross-validation score for the specified bandwidth.</p>
</td></tr>
<tr><td><code id="gwpca_+3A_scores">scores</code></td>
<td>
<p>if scores = TRUE, the scores of the supplied data on the principal components will be calculated.</p>
</td></tr>
<tr><td><code id="gwpca_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwpca_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwpca&rdquo;, returned by the function <code><a href="#topic+gwpca">gwpca</a></code></p>
</td></tr>
<tr><td><code id="gwpca_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwpca&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>an object of class inheriting from &ldquo;princomp&rdquo;, see <a href="stats.html#topic+princomp">princomp</a>. </p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>the localised loadings</p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with local proportions of variance for each 
principle components, cumulative proportion and winning variable for the 1st principle component in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>gwpca.scores</code></td>
<td>
<p>the localised scores of the supplied data on the principal components </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The local amount of variance accounted for by each component</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>Vector of cross-validation data</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Harris P, Brunsdon C, Charlton M (2011)
Geographically weighted principal components analysis.
International Journal of Geographical Information Science 25:1717-1736
</p>
<p>Harris P, Brunsdon C, Charlton M, Juggins S, Clarke A (2014) Multivariate spatial 
outlier detection using robust geographically weighted methods.  Mathematical 
Geosciences 46(1) 1-31
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2014) Geographically 
weighted methods and their use in network re-designs for environmental monitoring. 
Stochastic Environmental Research and Risk Assessment 28: 1869-1887
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2015) Enhancements to a 
geographically weighted principal components analysis in the context of an 
application to an environmental data set.  Geographical Analysis 47: 146-172
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require("mvoutlier") &amp;&amp; require("RColorBrewer"))
{
  data(bsstop)
  Data.1 &lt;- bsstop[, 1:14]
  colnames(Data.1)
  Data.1.scaled &lt;- scale(as.matrix(Data.1[5:14]))  # standardised data...
  rownames(Data.1.scaled) &lt;- Data.1[, 1]
  #compute principal components:
  pca &lt;- princomp(Data.1.scaled, cor = FALSE, scores = TRUE)  
  # use covariance matrix to match the following...
  pca$loadings
  data(bss.background)
  backdrop &lt;- function() 
   plot(bss.background, asp = 1, type = "l", xaxt = "n", yaxt = "n", 
   xlab = "", ylab = "", bty = "n", col = "grey")
  pc1 &lt;- pca$scores[, 1]
  backdrop()
  points(Data.1$XCOO[pc1 &gt; 0], Data.1$YCOO[pc1 &gt; 0], pch = 16, col = "blue")
  points(Data.1$XCOO[pc1 &lt; 0], Data.1$YCOO[pc1 &lt; 0], pch = 16, col = "red")
  
  #Geographically Weighted PCA and mapping the local loadings
  # Coordinates of the sites
  Coords1 &lt;- as.matrix(cbind(Data.1$XCOO,Data.1$YCOO)) 
  d1s &lt;- SpatialPointsDataFrame(Coords1,as.data.frame(Data.1.scaled))
  pca.gw &lt;- gwpca(d1s,vars=colnames(d1s@data),bw=1000000,k=10)
  local.loadings &lt;- pca.gw$loadings[, , 1]  
  
  # Mapping the winning variable with the highest absolute loading
  # note first component only - would need to explore all components..
  
  lead.item &lt;- colnames(local.loadings)[max.col(abs(local.loadings))]
  df1p = SpatialPointsDataFrame(Coords1, data.frame(lead = lead.item))
  backdrop()
  colour &lt;- brewer.pal(8, "Dark2")[match(df1p$lead, unique(df1p$lead))]
  plot(df1p, pch = 18, col = colour, add = TRUE)
  legend("topleft", as.character(unique(df1p$lead)), pch = 18, col = 
      brewer.pal(8, "Dark2"))
  backdrop()
  
  #Glyph plots give a view of all the local loadings together
  glyph.plot(local.loadings, Coords1, add = TRUE)
  
  #it is not immediately clear how to interpret the glyphs fully, 
  #so inter-actively identify the full loading information using:
  check.components(local.loadings, Coords1)
  
  # GWPCA with an optimal bandwidth
  bw.choice &lt;- bw.gwpca(d1s,vars=colnames(d1s@data),k=2) 
  pca.gw.auto  &lt;- gwpca(d1s,vars=colnames(d1s@data),bw=bw.choice,k=2)
  # note first component only - would need to explore all components..
  local.loadings &lt;- pca.gw.auto$loadings[, , 1]  
  
  lead.item &lt;- colnames(local.loadings)[max.col(abs(local.loadings))]
  df1p = SpatialPointsDataFrame(Coords1, data.frame(lead = lead.item))
  backdrop()
  colour &lt;- brewer.pal(8, "Dark2")[match(df1p$lead, unique(df1p$lead))]
  plot(df1p, pch = 18, col = colour, add = TRUE)
  legend("topleft", as.character(unique(df1p$lead)), pch = 18, 
  col = brewer.pal(8, "Dark2"))
  
  # GWPCPLOT for investigating the raw multivariate data
  gw.pcplot(d1s, vars=colnames(d1s@data),focus=359, bw = bw.choice) 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='gwpca.check.components'>Interaction tool with the GWPCA glyph map</h2><span id='topic+gwpca.check.components'></span><span id='topic+check.components'></span>

<h3>Description</h3>

<p>The function interacts with the multivariate glyph plot of GWPCA loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.check.components(ld,loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.check.components_+3A_ld">ld</code></td>
<td>
<p>GWPCA loadings returned by <a href="#topic+gwpca">gwpca</a></p>
</td></tr>
<tr><td><code id="gwpca.check.components_+3A_loc">loc</code></td>
<td>
<p>a 2-column numeric array of GWPCA evaluation locations</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;check.components&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwpca.check.components&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><a href="#topic+gwpca.glyph.plot">gwpca.glyph.plot</a></p>

<hr>
<h2 id='gwpca.cv'>Cross-validation score for a specified bandwidth for GWPCA</h2><span id='topic+gwpca.cv'></span>

<h3>Description</h3>

<p>This function finds the cross-validation score for a specified bandwidth for basic or robust GWPCA.
It can be used to construct the bandwidth function across all possible bandwidths and compared to that found automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.cv(bw,x,loc,k=2,robust=FALSE,kernel="bisquare",adaptive=FALSE,p=2, 
         theta=0, longlat=F,dMat)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.cv_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_x">x</code></td>
<td>
<p>the variable matrix</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_loc">loc</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_k">k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwpca.cv_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV.score</code></td>
<td>
<p>cross-validation score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwpca.cv.contrib'>Cross-validation data at each observation location for a GWPCA</h2><span id='topic+gwpca.cv.contrib'></span>

<h3>Description</h3>

<p>This function finds the individual cross-validation score at each observation location, for a GWPCA model, for a specified bandwidth.
These data can be mapped to detect unusually high or low cross-validations scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.cv.contrib(x,loc,bw, k=2,robust=FALSE,kernel="bisquare",adaptive=FALSE,
                 p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.cv.contrib_+3A_x">x</code></td>
<td>
<p>the variable matrix</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_loc">loc</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_k">k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwpca.cv.contrib_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV</code></td>
<td>
<p>a data vector consisting of squared residuals, whose sum is the cross-validation score for the specified bandwidth (bw) and component (k).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwpca.glyph.plot'>Multivariate glyph plots of GWPCA loadings</h2><span id='topic+gwpca.glyph.plot'></span><span id='topic+glyph.plot'></span>

<h3>Description</h3>

<p>This function provides a multivariate glyph plot of GWPCA loadings at each output location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.glyph.plot(ld,loc, r1=50, add=FALSE,alpha=1,sep.contrasts=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.glyph.plot_+3A_ld">ld</code></td>
<td>
<p>GWPCA loadings returned by <a href="#topic+gwpca">gwpca</a></p>
</td></tr>
<tr><td><code id="gwpca.glyph.plot_+3A_loc">loc</code></td>
<td>
<p>a two-column numeric array for providing evaluation locations of GWPCA calibration</p>
</td></tr>
<tr><td><code id="gwpca.glyph.plot_+3A_r1">r1</code></td>
<td>
<p>argument for the size of the glyphs, default is 50; glyphs get larger as r1 is reduced</p>
</td></tr>
<tr><td><code id="gwpca.glyph.plot_+3A_add">add</code></td>
<td>
<p>if TRUE, add the plot to the existing window.</p>
</td></tr>
<tr><td><code id="gwpca.glyph.plot_+3A_alpha">alpha</code></td>
<td>
<p>the level of transparency of glyph from function rgb() and ranges from 0 to max (fully transparent to opaque)</p>
</td></tr>
<tr><td><code id="gwpca.glyph.plot_+3A_sep.contrasts">sep.contrasts</code></td>
<td>
<p>allows different types of glyphs and relates to whether absolute loadings are used (TRUE) or not</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;glyph.plot&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwpca.glyph.plot&rdquo;, while the old name is still kept valid.
</p>


<h3>References</h3>

<p>Harris P, Brunsdon C, Charlton M (2011)
Geographically weighted principal components analysis.
International Journal of Geographical Information Science 25:1717-1736
</p>

<hr>
<h2 id='gwpca.montecarlo.1'>Monte Carlo (randomisation) test for significance of GWPCA eigenvalue variability
for the first component only - option 1</h2><span id='topic+gwpca.montecarlo.1'></span><span id='topic+montecarlo.gwpca.1'></span><span id='topic+plot.mcsims'></span>

<h3>Description</h3>

<p>This function implements a Monte Carlo (randomisation) test for a basic or robust 
GW PCA with the bandwidth pre-specified  and constant. The test evaluates whether 
the GW eigenvalues vary significantly across space for the first component only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.montecarlo.1(data, bw, vars, k = 2, nsims=99,robust = FALSE, kernel = "bisquare",
                   adaptive = FALSE,  p = 2, theta = 0, longlat = F, dMat)
## S3 method for class 'mcsims'
plot(x, sname="SD of local eigenvalues from randomisations", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.montecarlo.1_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwpca">bw.gwpca</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_k">k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_nsims">nsims</code></td>
<td>
<p>the number of simulations for MontCarlo test</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;mcsims&rdquo;, returned by the function <a href="#topic+gwpca.montecarlo.1">gwpca.montecarlo.1</a> or <a href="#topic+gwpca.montecarlo.2">gwpca.montecarlo.2</a></p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_sname">sname</code></td>
<td>
<p>the label for the observed value on the plot</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.1_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components:
</p>
<table>
<tr><td><code>actual</code></td>
<td>
<p>the observed standard deviations (SD) of eigenvalues</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>a vector of the simulated SDs of eigenvalues</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;montecarlo.gwpca.1&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwpca.montecarlo.1&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris P, Brunsdon C, Charlton M (2011)
Geographically weighted principal components analysis.
International Journal of Geographical Information Science 25:1717-1736
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(DubVoter)
DM&lt;-gw.dist(dp.locat=coordinates(Dub.voter))
gmc.res&lt;-gwpca.montecarlo.1(data=Dub.voter, vars=c("DiffAdd", "LARent",
"SC1", "Unempl", "LowEduc"), bw=20,dMat=DM,adaptive=TRUE)
gmc.res
plot(gmc.res)

## End(Not run)
</code></pre>

<hr>
<h2 id='gwpca.montecarlo.2'>Monte Carlo (randomisation) test for significance of GWPCA eigenvalue variability
for the first component only - option 2</h2><span id='topic+gwpca.montecarlo.2'></span><span id='topic+montecarlo.gwpca.2'></span>

<h3>Description</h3>

<p>This function implements a Monte Carlo (randomisation) test for a basic or robust GW PCA with the bandwidth
automatically re-selected via the cross-validation approach. The test evaluates whether the GW eigenvalues 
vary significantly across space for the first component only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca.montecarlo.2(data, vars, k = 2, nsims=99,robust = FALSE, kernel = "bisquare",
                   adaptive = FALSE,  p = 2, theta = 0, longlat = F, dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca.montecarlo.2_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_k">k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_nsims">nsims</code></td>
<td>
<p>the number of simulations for MontCarlo test</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_robust">robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwpca.montecarlo.2_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components:
</p>
<table>
<tr><td><code>actual</code></td>
<td>
<p>the observed standard deviations (SD) of eigenvalues</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>a vector of the simulated SDs of eigenvalues</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;montecarlo.gwpca.2&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwpca.montecarlo.2&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris P, Brunsdon C, Charlton M (2011)
Geographically weighted principal components analysis.
International Journal of Geographical Information Science 25:1717-1736
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(DubVoter)
DM&lt;-gw.dist(dp.locat=coordinates(Dub.voter))
gmc.res.autow&lt;-gwpca.montecarlo.2(data=Dub.voter, vars=c("DiffAdd", "LARent",
"SC1", "Unempl", "LowEduc"), dMat=DM,adaptive=TRUE)
gmc.res.autow
plot.mcsims(gmc.res.autow)

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.basic'>Basic GWR model</h2><span id='topic+gwr.basic'></span><span id='topic+gw_reg'></span><span id='topic+gwr_diag'></span><span id='topic+Ci_mat'></span><span id='topic+gw_local_r2'></span><span id='topic+gw_reg_1'></span><span id='topic+gw_reg_2'></span><span id='topic+gw_reg_all'></span><span id='topic+gw_reg_all_cuda'></span><span id='topic+gw_cv_all_omp'></span><span id='topic+gw_reg_all_omp'></span><span id='topic+trhat2'></span><span id='topic+F1234.test'></span><span id='topic+print.gwrm'></span>

<h3>Description</h3>

<p>This function implements basic GWR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.basic(formula, data, regression.points, bw, kernel="bisquare",
adaptive=FALSE, p=2, theta=0, longlat=F,dMat,F123.test=F,cv=F, W.vect=NULL,
parallel.method=FALSE,parallel.arg=NULL)
## S3 method for class 'gwrm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.basic_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>; Note that no diagnostic information will returned if it is assigned</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_f123.test">F123.test</code></td>
<td>
<p>If TRUE, conduct three seperate F-tests according to Leung et al. (2000).</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_cv">cv</code></td>
<td>
<p>if TRUE, cross-validation data will be calculated and returned in the output Spatial*DataFrame</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_w.vect">W.vect</code></td>
<td>
<p>default NULL, if given it will be used to weight the distance weighting matrix</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwrm&rdquo;, returned by the function <code><a href="#topic+gwr.basic">gwr.basic</a></code></p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_parallel.method">parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
&quot;omp&quot;: multi-thread technique with the OpenMP API, 
&quot;cluster&quot;: multi-process technique with the <span class="pkg">parallel</span> package,
&quot;cuda&quot;: parallel computing technique with CUDA</p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is &quot;omp&quot;, parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cluster&quot;, parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cuda&quot;,  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td></tr>
<tr><td><code id="gwr.basic_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwrm&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>a list class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>an object of class inheriting from &ldquo;lm&rdquo;, see <a href="stats.html#topic+lm">lm</a>. </p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with fit.points,GWR coefficient estimates, y value,predicted values, coefficient standard errors and t-values in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
<tr><td><code>Ftest.res</code></td>
<td>
<p>results of Leung's F tests when F123.test is TRUE.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Requirements of using CUDA for high-performence computation in GWR functions:
</p>
<p>To run GWR-CUDA (i.e. parallel.method is pecified as &ldquo;cuda&rdquo;) with  
<code>gwr.basic</code> , <code>bw.gwr</code> and <code>gwr.model.selection</code>, 
the following conditions are required:
</p>
<p>1. There is at least one NVIDIA GPU supporting CUDA equipped on user's computer.
</p>
<p>2. CUDA (&gt;10.2) are installed with the environment variable 'CUDA_HOME' set properly. 
</p>
<p>3. The package should re-built from source. 
- For Linux user, 'GWmodelCUDA' will be automatically built if CUDA toolkit could be detected 
by the complier. 
- For Windows user, 'GWmodelCUDA.dll' and 'GWmodelCUDA.lib' will be automatically downloaded;
however, we would recommend users to build the 'GWmodelCUDA' library manually to avoid some potentially
unknown issues, and an 'CMakeLists.txt' file is provided for this procedure.
</p>
<p>If any condition above is not satisfied, the GWR-CUDA will not work even though the &ldquo;parallel.method&rdquo; is 
specified as &ldquo;cuda&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Brunsdon, C, Fotheringham, S, Charlton, M (1996), Geographically Weighted Regression: A Method for Exploring Spatial Nonstationarity. 
Geographical Analysis 28(4):281-298
</p>
<p>Charlton, M, Fotheringham, S, and Brunsdon, C (2007), GWR3.0, <a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a>.
</p>
<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Leung, Y, Mei, CL, and Zhang, WX (2000), Statistical tests for spatial nonstationarity 
based on the geographically weighted regression model. Environment and Planning A, 32, 9-32.
</p>
<p>Lu, B, Charlton, M, Harris, P, Fotheringham, AS (2014) Geographically weighted regression 
with a non-Euclidean distance metric: a case study using hedonic house price data. 
International Journal of Geographical Information Science 28(4): 660-681
</p>
<p>OpenMP: <a href="https://www.openmp.org/">https://www.openmp.org/</a>
</p>
<p>CUDA: <a href="https://developer.nvidia.com/cuda-zone">https://developer.nvidia.com/cuda-zone</a>
</p>
<p>R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical
Computing, Vienna, Austria.  <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LondonHP)
DM&lt;-gw.dist(dp.locat=coordinates(londonhp))
##Compare the time consumed with and without a specified distance matrix
## Not run: 
system.time(gwr.res&lt;-gwr.basic(PURCHASE~FLOORSZ, data=londonhp, bw=1000,
            kernel = "gaussian"))
system.time(DM&lt;-gw.dist(dp.locat=coordinates(londonhp)))
system.time(gwr.res&lt;-gwr.basic(PURCHASE~FLOORSZ, data=londonhp, bw=1000,
            kernel = "gaussian", dMat=DM))

## specify an optimum bandwidth by cross-validation appraoch
bw1&lt;-bw.gwr(PURCHASE~FLOORSZ, data=londonhp, kernel = "gaussian",dMat=DM)
gwr.res1&lt;-gwr.basic(PURCHASE~FLOORSZ, data=londonhp, bw=bw1,kernel = "gaussian", 
                   dMat=DM)
gwr.res1 
## End(Not run)
data(LondonBorough)

nsa = list("SpatialPolygonsRescale", layout.north.arrow(), offset = c(561900,200900), 
scale = 500, col=1)
## Not run: 
if(require("RColorBrewer"))
{
  mypalette&lt;-brewer.pal(6,"Spectral")
  x11()
  spplot(gwr.res1$SDF, "FLOORSZ", key.space = "right", cex=1.5, cuts=10,
  ylim=c(155840.8,200933.9), xlim=c(503568.2,561957.5),
  main="GWR estimated coefficients for FLOORSZ with a fixed bandwidth", 
  col.regions=mypalette, sp.layout=list(nsa, londonborough))}

## End(Not run)
## Not run: 
bw2&lt;-bw.gwr(PURCHASE~FLOORSZ,approach="aic",adaptive=TRUE, data=londonhp, 
            kernel = "gaussian", dMat=DM)
gwr.res2&lt;-gwr.basic(PURCHASE~FLOORSZ, data=londonhp, bw=bw2,adaptive=TRUE,
                    kernel = "gaussian", dMat=DM)
gwr.res2
if(require("RColorBrewer"))
{
  x11()
  spplot(gwr.res2$SDF, "FLOORSZ", key.space = "right", cex=1.5, cuts=10,
  ylim=c(155840.8,200933.9), xlim=c(503568.2,561957.5),
  main="GWR estimated coefficients for FLOORSZ with an adaptive bandwidth", 
  col.regions=mypalette, sp.layout=list(nsa,londonborough))}

## End(Not run)
## Not run: 
  ############HP-GWR test code
  simulate.data.generator &lt;- function(data.length) {
  x1 &lt;- rnorm(data.length)
  x2 &lt;- rnorm(data.length)
  x3 &lt;- rnorm(data.length)
  lon &lt;- rnorm(data.length, mean = 533200, sd = 10000)
  lat &lt;- rnorm(data.length, mean = 159400, sd = 10000)
  y &lt;- x1 + 5 * x2 + 2.5 * x3 + rnorm(data.length)
  simulate.data &lt;- data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, lon = lon, lat = lat)
  coordinates(simulate.data) &lt;- ~ lon + lat
  names(simulate.data)
  return(simulate.data)
}
simulate.data &lt;- simulate.data.generator(10000)
adaptive = TRUE

## GWR (not parallelized)
bw.CV.s &lt;- bw.gwr(data = simulate.data, formula = y ~ x1 + x2 + x3, approach="CV", 
                  kernel = "gaussian", adaptive = adaptive, parallel.method = FALSE)
model.s &lt;- gwr.model.selection(DeVar = "y", InDeVars = c("x1", "x2", "x3"), data = simulate.data, 
                              bw = bw.CV.s, approach="AIC", kernel = "gaussian", adaptive = T, 
                              parallel.method = FALSE)
system.time(
  betas.s &lt;- gwr.basic(data = simulate.data, formula = y ~ x1 + x2 + x3, bw = bw.CV.s, 
                       kernel = "gaussian", adaptive = TRUE)
)

## GWR-Omp
bw.CV.omp &lt;- bw.gwr(data = simulate.data, formula = y ~ x1 + x2 + x3, approach="CV", 
                    kernel = "gaussian", adaptive = adaptive, parallel.method = "omp")
model.omp &lt;- gwr.model.selection(DeVar = "y", InDeVars = c("x1", "x2", "x3"), data = simulate.data, 
                                bw = bw.CV.omp, approach="AIC", kernel = "gaussian", adaptive = T, 
                                parallel.method = "omp")
system.time(
  betas.omp &lt;- gwr.basic(data = simulate.data, formula = y ~ x1 + x2 + x3, bw = bw.CV.omp, 
                        kernel = "gaussian", adaptive = T, parallel.method = "omp"))

## GWR-CUDA
bw.CV.cuda &lt;- bw.gwr(data = simulate.data, formula = y ~ x1 + x2 + x3, approach="CV", 
                     kernel = "gaussian", adaptive = adaptive, parallel.method = "cuda", 
                     parallel.arg = 6*16)
model.cuda &lt;- gwr.model.selection(DeVar = "y", InDeVars = c("x1", "x2", "x3"), 
                                 data = simulate.data, bw = bw.CV.cuda, approach="AIC", 
                                 kernel = "gaussian", adaptive = T, 
                                 parallel.method = "cuda", parallel.arg = 6*16)
system.time(
  betas.cuda &lt;- gwr.basic(data = simulate.data, formula = y ~ x1 + x2 + x3, bw = bw.CV.cuda, 
                          kernel = "gaussian", adaptive = T, parallel.method = "cuda", 
                          parallel.arg = 6*8))

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.bootstrap'>Bootstrap GWR</h2><span id='topic+gwr.bootstrap'></span><span id='topic+print.gwrbsm'></span><span id='topic+generate.lm.data'></span><span id='topic+parametric.bs'></span><span id='topic+parametric.bs.local'></span><span id='topic+se.bs'></span><span id='topic+bias.bs'></span><span id='topic+ci.bs'></span><span id='topic+pval.bs'></span><span id='topic+gwrtvar'></span><span id='topic+gwrt.mlr'></span><span id='topic+gwrt.lag'></span><span id='topic+gwrt.err'></span><span id='topic+gwrt.sma'></span><span id='topic+bw.gwr3'></span>

<h3>Description</h3>

<p>This function implements bootstrap methods to test for coefficient variability 
found from GWR under model assumptions for each of four null hypotheses: MLR, 
ERR, SMA and LAG models.  Global test statistic results are found, as well local 
observation-specific test results that can be mapped. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.bootstrap(formula, data, kernel = "bisquare", approach = "AIC",
                 R = 99, k.nearneigh = 4, adaptive = FALSE, p = 2,
                 theta = 0, longlat = FALSE, dMat, verbose = FALSE,
                 parallel.method = FALSE, parallel.arg = NULL)

## S3 method for class 'gwrbsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.bootstrap_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_approach">approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_r">R</code></td>
<td>
<p>number of random samples reapted in the bootstrap procedure</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_k.nearneigh">k.nearneigh</code></td>
<td>
<p>number of nearest neighbours concerned in calbrating ERR, SMA and LAG models</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE and bandwidth selection is undertaken, the bandwidth searches are reported</p>
</td></tr> 
<tr><td><code id="gwr.bootstrap_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwrbsm&rdquo;, returned by the function <a href="#topic+gwr.bootstrap">gwr.bootstrap</a></p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_parallel.method">parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
&quot;omp&quot;: multi-thread technique with the OpenMP API, 
&quot;cluster&quot;: multi-process technique with the <span class="pkg">parallel</span> package,
&quot;cuda&quot;: parallel computing technique with CUDA</p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is &quot;omp&quot;, parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cluster&quot;, parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cuda&quot;,  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td></tr>
<tr><td><code id="gwr.bootstrap_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwrbsm&rdquo;:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>modified statistics reported from comparisons between GWR and MLR, ERR, SMA and LAG</p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object
(see package &ldquo;sp&rdquo;) integrated with fit.points,GWR coefficient estimates, y
value,predicted values, coefficient standard errors and bootstrap p-values in its &ldquo;data&rdquo; slot.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function implements the bootstrap methods introduced in Harris et al. (2017). 
It provides a global test statistic (the modified one given in Harris et al. 2017)
and a complementary localised version that can be mapped. The bootstrap methods 
test for coefficient variability found from GWR under model assumptions for each 
of four null hypotheses: i) multiple linear regression model (MLR); ii) simultaneous
autoregressive error model (ERR); iii) moving average error model (SMA) and iv) simultaneous
autoregressive lag model (LAG).
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris, P., Brunsdon, C., Lu, B., Nakaya, T., &amp; Charlton, M. (2017). Introducing 
bootstrap methods to investigate coefficient non-stationarity in spatial regression 
models. Spatial Statistics, 21, 241-261.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Example with the Georgia educational attainment data
data(Georgia)
data(GeorgiaCounties)
coords &lt;- cbind(Gedu.df$X, Gedu.df$Y)
Gedu.spdf &lt;- SpatialPointsDataFrame(coords, Gedu.df)
#Make a SpatialPolygonDataFrame
require(RColorBrewer)
gSRDF &lt;- SpatialPolygonsDataFrame(polygons(Gedu.counties), over(Gedu.counties, 
                                  Gedu.spdf),match.ID=T)  
mypalette.1 &lt;- brewer.pal(11,"Spectral")
X11(width=9,height=8)                   
spplot(gSRDF, names(gSRDF)[c(5,7:9)], col.regions=mypalette.1,
cuts=10, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Georgia educational attainment predictor data")))
bsm.res &lt;- gwr.bootstrap(PctBach~PctRural+PctEld+PctFB+PctPov, gSRDF, 
                         R=999, longlat=T)
bsm.res
#local bootstrap tests with respect to: MLR, ERR, SMA and LAG models.
mypalette.local.test &lt;- brewer.pal(10,"Spectral")
X11(width=12,height=16)
spplot(bsm.res$SDF, names(bsm.res$SDF)[14:17], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the MLR model 
                       null hypothesis")))

X11(width=12,height=16)
spplot(bsm.res$SDF, names(bsm.res$SDF)[19:22], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the ERR model 
                       null hypothesis")))
X11(width=12,height=16)
spplot(bsm.res$SDF, names(bsm.res$SDF)[24:27], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the SMA model null
                       hypothesis")))

X11(width=12,height=16)
spplot(bsm.res$SDF, names(bsm.res$SDF)[29:32], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the LAG model null
                       hypothesis")))
################################################################################
#Example with Dublin voter data
data(DubVoter)
X11(width=9,height=8)                   
spplot(Dub.voter, names(Dub.voter)[c(5,7,9,10)], col.regions=mypalette.1,
cuts=10, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Dublin voter turnout predictor data")))
bsm.res1 &lt;- gwr.bootstrap(GenEl2004~LARent+Unempl+Age18_24+Age25_44, Dub.voter
                         , R=999)
bsm.res1

#local bootstrap tests with respect to: MLR, ERR, SMA and LAG models.
X11(width=11,height=8)
spplot(bsm.res1$SDF, names(bsm.res1$SDF)[14:17], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the MLR model null
                        hypothesis")))
X11(width=11,height=8)
spplot(bsm.res1$SDF, names(bsm.res1$SDF)[19:22], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the ERR model null
                        hypothesis")))
X11(width=11,height=8)
spplot(bsm.res1$SDF, names(bsm.res1$SDF)[24:27], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the SMA model 
                            null hypothesis")))
X11(width=11,height=8)
spplot(bsm.res1$SDF, names(bsm.res1$SDF)[29:32], col.regions=mypalette.local.test,
cuts=9, par.settings=list(fontsize=list(text=15)),
main=expression(paste("Local p-values for each coefficient of the LAG model 
                            null hypothesis")))

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.collin.diagno'>Local collinearity diagnostics for basic GWR</h2><span id='topic+gwr.collin.diagno'></span>

<h3>Description</h3>

<p>This function provides a series of local collinearity diagnostics for the independent variables of a basic GWR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.collin.diagno(formula, data, bw, kernel="bisquare",
                    adaptive=FALSE, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.collin.diagno_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, probably calculated 
by <code>bw.gwr</code> or <code>bw.gwr.lcr</code>; fixed (distance) or 
adaptive bandwidth (number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.collin.diagno_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>corr.mat</code></td>
<td>
<p>Local correlation matrix</p>
</td></tr>
<tr><td><code>VIF</code></td>
<td>
<p>Local Variance inflation factors (VIFs) matrix</p>
</td></tr>
<tr><td><code>local_CN</code></td>
<td>
<p>Local condition numbers</p>
</td></tr>
<tr><td><code>VDP</code></td>
<td>
<p>Local variance-decomposition proportions</p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with VIF, local_CN, VDP and corr.mat</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Wheeler D, Tiefelsdorf M (2005) Multicollinearity and correlation among local 
regression coefficients in geographically weighted regression. Journal of 
Geographical Systems 7:161-187
</p>
<p>Wheeler D (2007) Diagnostic tools and a remedial method for collinearity in 
geographically weighted regression. Environment and Planning A 39:2464-2481
</p>
<p>Gollini I, Lu B, Charlton M, Brunsdon C, Harris P (2015) GWmodel: an R Package 
for exploring Spatial Heterogeneity using Geographically Weighted Models. Journal 
of Statistical Software, 63(17):1-50
</p>

<hr>
<h2 id='gwr.cv'>Cross-validation score for a specified bandwidth for basic GWR</h2><span id='topic+gwr.cv'></span>

<h3>Description</h3>

<p>This function finds the cross-validation score for a specified bandwidth for basic GWR.
It can be used to construct the bandwidth function across all possible bandwidths and compared to that found automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.cv(bw, X, Y, kernel="bisquare",adaptive=FALSE, dp.locat, p=2, theta=0, 
       longlat=F,dMat, verbose=T,
       parallel.method=F, parallel.arg=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.cv_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), reports the progress of search for bandwidth</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Specified by 'FALSE' for serial approach, 
by '&quot;omp&quot;' for multi-thread approach implemented via OpenMP, 
by '&quot;cluster&quot;' for multi-process approach implemented via 'parallel' package,
by '&quot;cuda&quot;' for parallel approach implemented via CUDA</p>
</td></tr>
<tr><td><code id="gwr.cv_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p>Set the argument for parallel approach. 
If 'parallel.method' is 'FALSE', there is no need to set its value. 
If 'parallel.method' is '&quot;omp&quot;', its value is used to set how many threads should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cluster&quot;', its value is used to set how many R session should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cuda&quot;', its value is used to set how many samples is included in one group during the calibration. This value should not be too big to avoid the overflow of GPU memory. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV.score</code></td>
<td>
<p>cross-validation score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwr.cv.contrib'>Cross-validation data at each observation location for a basic GWR model</h2><span id='topic+gwr.cv.contrib'></span>

<h3>Description</h3>

<p>This function finds the individual cross-validation score at each observation location, for a basic GWR model, for a specified bandwidth.
These data can be mapped to detect unusually high or low cross-validations scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.cv.contrib(bw, X, Y, kernel="bisquare",adaptive=FALSE, dp.locat, p=2, 
               theta=0, longlat=F,dMat,
               parallel.method=F, parallel.arg=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.cv.contrib_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Specified by 'FALSE' for serial approach, 
by '&quot;omp&quot;' for multi-thread approach implemented via OpenMP, 
by '&quot;cluster&quot;' for multi-process approach implemented via 'parallel' package,
by '&quot;cuda&quot;' for parallel approach implemented via CUDA</p>
</td></tr>
<tr><td><code id="gwr.cv.contrib_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p>Set the argument for parallel approach. 
If 'parallel.method' is 'FALSE', there is no need to set its value. 
If 'parallel.method' is '&quot;omp&quot;', its value is used to set how many threads should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cluster&quot;', its value is used to set how many R session should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cuda&quot;', its value is used to set how many samples is included in one group during the calibration. This value should not be too big to avoid the overflow of GPU memory. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV</code></td>
<td>
<p>a data vector consisting of squared residuals, whose sum is the cross-validation score for the specified bandwidth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwr.hetero'>Heteroskedastic GWR </h2><span id='topic+gwr.hetero'></span>

<h3>Description</h3>

<p>This function implements a heteroskedastic GWR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.hetero(formula, data, regression.points, bw, kernel="bisquare",
                    adaptive=FALSE, tol=0.0001,maxiter=50,verbose=T,
                    p=2, theta=0, longlat=F,dMat)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.hetero_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_tol">tol</code></td>
<td>
<p>the threshold that determines the convergence of the iterative procedure</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of times to try the iterative procedure</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE verbose output will be made from the iterative procedure</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.hetero_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with coefficient estimates in its &quot;data&quot; slot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Harris P, Fotheringham AS, Juggins S (2010) Robust geographically weighed regression: 
a technique for quantifying spatial relationships between freshwater acidification 
critical loads and catchment attributes. Annals of the Association of American Geographers 100(2): 286-306
</p>
<p>Harris P, Brunsdon C, Fotheringham AS (2011) Links, comparisons and extensions of the geographically 
weighted regression model when used as a spatial predictor.  Stochastic Environmental Research 
and Risk Assessment 25:123-138
</p>

<hr>
<h2 id='gwr.lcr'>GWR with a locally-compensated ridge term</h2><span id='topic+gwr.lcr'></span><span id='topic+ridge.lm'></span><span id='topic+print.gwrlcr'></span>

<h3>Description</h3>

<p>To address possible local collinearity problems in basic GWR, GWR-LCR finds local ridge parameters at affected
locations (set by a user-specified threshold for the design matrix condition number).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.lcr(formula, data, regression.points, bw, kernel="bisquare",
                    lambda=0,lambda.adjust=FALSE,cn.thresh=NA,
                    adaptive=FALSE, p=2, theta=0, longlat=F,cv=T,dMat)
## S3 method for class 'gwrlcr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.lcr_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame 
or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>,
or a two-column numeric array</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <code>bw.gwr.lcr</code>;
fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_lambda">lambda</code></td>
<td>
<p>option for a globally-defined (constant) ridge parameter. Default is lambda=0, which gives a basic GWR fit</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_lambda.adjust">lambda.adjust</code></td>
<td>
<p>a locally-varying ridge parameter. Default FALSE, refers to: (i) a basic GWR without
a local ridge adjustment (i.e. lambda=0, everywhere); or (ii) a penalised GWR with a global ridge adjustment 
(i.e. lambda is user-specified as some constant, other than 0 everywhere); if TRUE, use cn.tresh
to set the maximum condition number. Here for locations with a condition number (for its local design matrix) 
above this user-specified threshold, a local ridge parameter is found</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_cn.thresh">cn.thresh</code></td>
<td>
<p>maximum value for condition number, commonly set between 20 and 30</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_cv">cv</code></td>
<td>
<p>if TRUE, 'cross-validation data will be calculated and returned in the output Spatial*DataFrame</p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwrlcr&rdquo;, returned by the function <a href="#topic+gwr.lcr">gwr.lcr</a></p>
</td></tr>
<tr><td><code id="gwr.lcr_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;rgwr&rdquo;:
</p>
<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object 
(see package &quot;sp&quot;) with coordinates of regression.points in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>GW.arguments</code></td>
<td>
<p>parameters used for the LCR-GWR calibration</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>diagnostic information is given when data points are also used as regression locations</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>timing information for running this function</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Wheeler D (2007) Diagnostic tools and a remedial method for collinearity in geographically weighted regression. Environment and Planning A 39:2464-2481
</p>
<p>Brunsdon C, Charlton M, Harris P (2012) Living with collinearity in Local Regression Models. GISRUK 2012, Lancaster, UK
</p>
<p>Brunsdon C, Charlton M, Harris P (2012) Living with collinearity in Local Regression Models. Spatial Accuracy 2012, Brazil
</p>
<p>Gollini I, Lu B, Charlton M, Brunsdon C, Harris P (2015) GWmodel: an R Package for 
exploring Spatial Heterogeneity using Geographically Weighted Models.  Journal of 
Statistical Software 63(17): 1-50
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DubVoter)
require(RColorBrewer)

# Function to find the global condition number (CN)
BKW_cn &lt;- function (X) {
  p &lt;- dim(X)[2]
  Xscale &lt;- sweep(X, 2, sqrt(colSums(X^2)), "/")
  Xsvd &lt;- svd(Xscale)$d
  cn &lt;- Xsvd[1] / Xsvd[p]
  cn
}
#
X &lt;- cbind(1,Dub.voter@data[,3:10])
head(X)
CN.global &lt;- BKW_cn(X)
CN.global
## Not run: 
# gwr.lcr function with a global bandwidth to check that the global CN is found
gwr.lcr1 &lt;- gwr.lcr(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64, data=Dub.voter, bw=10000000000)
summary(gwr.lcr1$SDF$Local_CN)

# Find and map the local CNs from a basic GWR fit using the lcr-gwr function 
#(note this is NOT the locally-compensated ridge GWR fit as would need to set 
#lambda.adjust=TRUE and cn.thresh=30, say)

bw.lcr2 &lt;- bw.gwr.lcr(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64, data=Dub.voter, kernel="bisquare", adaptive=TRUE)
gwr.lcr2 &lt;- gwr.lcr(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64, data=Dub.voter, bw=bw.lcr2, kernel="bisquare", adaptive=TRUE)
if(require("RColorBrewer"))
  spplot(gwr.lcr2$SDF,"Local_CN",col.regions=brewer.pal(9,"YlOrRd"),cuts=8,
  main="Local CN")

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.lcr.cv'>Cross-validation score for a specified bandwidth for GWR-LCR model</h2><span id='topic+gwr.lcr.cv'></span>

<h3>Description</h3>

<p>This function finds the cross-validation score for a specified bandwidth for GWR-LCR.
It can be used to construct the bandwidth function across all possible bandwidths and compared to that found automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.lcr.cv(bw,X,Y,locs,kernel="bisquare",
                    lambda=0,lambda.adjust=FALSE,cn.thresh=NA,
                    adaptive=FALSE, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.lcr.cv_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_locs">locs</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_lambda">lambda</code></td>
<td>
<p>option for a globally-defined (constant) ridge parameter. Default is lambda=0, which gives a basic GWR fit</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_lambda.adjust">lambda.adjust</code></td>
<td>
<p>a locally-varying ridge parameter. Default FALSE, refers to: (i) a basic GWR without
a local ridge adjustment (i.e. lambda=0, everywhere); or (ii) a penalised GWR with a global ridge adjustment 
(i.e. lambda is user-specified as some constant, other than 0 everywhere); if TRUE, use cn.tresh
to set the maximum condition number. Here for locations with a condition number (for its local design matrix) 
above this user-specified threshold, a local ridge parameter is found</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_cn.thresh">cn.thresh</code></td>
<td>
<p>maximum value for condition number, commonly set between 20 and 30</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV.score</code></td>
<td>
<p>cross-validation score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwr.lcr.cv.contrib'>Cross-validation data at each observation location for the GWR-LCR model</h2><span id='topic+gwr.lcr.cv.contrib'></span>

<h3>Description</h3>

<p>This function finds the individual cross-validation score at each observation location, for a GWR-LCR model, for a specified bandwidth.
These data can be mapped to detect unusually high or low cross-validations scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.lcr.cv.contrib(bw,X,Y,locs,kernel="bisquare",
                    lambda=0,lambda.adjust=FALSE,cn.thresh=NA,
                    adaptive=FALSE, p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_x">X</code></td>
<td>
<p>a numeric matrix of the independent data with an extra column of &ldquo;ones&rdquo; for the 1st column</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_y">Y</code></td>
<td>
<p>a column vector of the dependent data</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_locs">locs</code></td>
<td>
<p>a two-column numeric array of observation coordinates</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_lambda">lambda</code></td>
<td>
<p>option for a globally-defined (constant) ridge parameter. Default is lambda=0, which gives a basic GWR fit</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_lambda.adjust">lambda.adjust</code></td>
<td>
<p>a locally-varying ridge parameter. Default FALSE, refers to: (i) a basic GWR without
a local ridge adjustment (i.e. lambda=0, everywhere); or (ii) a penalised GWR with a global ridge adjustment 
(i.e. lambda is user-specified as some constant, other than 0 everywhere); if TRUE, use cn.tresh
to set the maximum condition number. Here for locations with a condition number (for its local design matrix) 
above this user-specified threshold, a local ridge parameter is found</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_cn.thresh">cn.thresh</code></td>
<td>
<p>maximum value for condition number, commonly set between 20 and 30</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.lcr.cv.contrib_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CV</code></td>
<td>
<p>a data vector consisting of squared residuals, whose sum is the cross-validation score for the specified bandwidth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwr.mink.approach'>Minkovski approach for GWR</h2><span id='topic+gwr.mink.approach'></span><span id='topic+mink.approach'></span><span id='topic+bw.gwr1'></span><span id='topic+gwr.aic1'></span><span id='topic+gwr.cv1'></span>

<h3>Description</h3>

<p>This function implements the Minkovski approach to select an 'optimum' distance metric
for calibrating a GWR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.mink.approach(formula, data, criterion="AIC", bw, bw.sel.approach = "AIC",adaptive=F, 
              kernel="bisquare", p.vals=seq(from=0.25, to=8, length.out=32), p.inf = T,
                          theta.vals = seq(from=0, to=0.5*pi, length.out=10), verbose=F, 
                          nlower = 10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.mink.approach_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_criterion">criterion</code></td>
<td>
<p>the criterion used for distance metric selection, AICc (&quot;AICc&quot;) or cross-validation (&quot;CV&quot;) score; default is &quot;AICc&quot;</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_bw.sel.approach">bw.sel.approach</code></td>
<td>
<p>approach used to seclect an optimum bandwidth for each calibration if no bandwidth (bw) is given; 
specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_p.vals">p.vals</code></td>
<td>
<p> a collection of positive numbers used as the power of the Minkowski distance</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_p.inf">p.inf</code></td>
<td>
<p>if TRUE, Chebyshev distance is tried for model calibration, i.e. p is infinity</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_theta.vals">theta.vals</code></td>
<td>
<p>a collection of values used as angles in radians to rotate the coordinate system</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE and bandwidth selection is undertaken, the bandwidth searches are reported</p>
</td></tr>
<tr><td><code id="gwr.mink.approach_+3A_nlower">nlower</code></td>
<td>
<p>the minmum number of nearest neighbours if an adaptive kernel is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>diag.df</code></td>
<td>
<p>a data frame with four columns (p, theta, bandwidth, AICc/CV), each row corresponds to a calibration</p>
</td></tr>
<tr><td><code>coefs.all</code></td>
<td>
<p>a list class object including all the estimated coefficients</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;mink.approach&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwr.mink.approach&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Lu, B, Charlton, M, Brunsdon, C &amp; Harris, P(2016). The Minkowski approach for choosing the distance metric in Geographically Weighted Regression. International Journal of Geographical Information Science, 30(2): 351-368.
</p>

<hr>
<h2 id='gwr.mink.matrixview'>Visualisation of the results from <code><a href="#topic+gwr.mink.approach">gwr.mink.approach</a></code></h2><span id='topic+gwr.mink.matrixview'></span><span id='topic+mink.matrixview'></span>

<h3>Description</h3>

<p>This function visualises the AICc/CV results from the <code><a href="#topic+gwr.mink.approach">gwr.mink.approach</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.mink.matrixview(diag.df, znm=colnames(diag.df)[4], criterion="AIC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.mink.matrixview_+3A_diag.df">diag.df</code></td>
<td>
<p>the first part of a list object returned by <code><a href="#topic+gwr.mink.approach">gwr.mink.approach</a></code></p>
</td></tr>
<tr><td><code id="gwr.mink.matrixview_+3A_znm">znm</code></td>
<td>
<p>the name of the forth column in diag.df</p>
</td></tr>
<tr><td><code id="gwr.mink.matrixview_+3A_criterion">criterion</code></td>
<td>
<p>the criterion used for distance metric selection in <code><a href="#topic+gwr.mink.approach">gwr.mink.approach</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;mink.matrixview&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwr.mink.matrixview&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Lu, B, Charlton, M, Brunsdon, C &amp; Harris, P(2016). The Minkowski approach for choosing the distance metric in Geographically Weighted Regression. International Journal of Geographical Information Science, 30(2): 351-368.
</p>

<hr>
<h2 id='gwr.mink.pval'>Select the values of p for the Minkowski approach for GWR</h2><span id='topic+gwr.mink.pval'></span><span id='topic+gwr.mink.pval.forward'></span><span id='topic+gwr.mink.pval.backward'></span><span id='topic+plot.pvlas'></span>

<h3>Description</h3>

<p>These functions implement heuristics to select the values of p from two intervals: (0, 2] in a 'backward' direction and (2, Inf) in a 'forward' direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.mink.pval(formula, data, criterion="AIC", bw, bw.sel.approach = "AIC",
                       adaptive=F, kernel="bisquare", left.interval=0.25,
                       right.interval=0.5,drop.tol=3, theta0=0,verbose=F,nlower = 10)
gwr.mink.pval.forward(formula, data, bw, bw.sel.approach = "AIC",
                       adaptive=F, kernel="bisquare", p.max=Inf,p.min=2,
                       interval=0.5,drop.tol=3, theta0=0,verbose=F,nlower = 10)
gwr.mink.pval.backward(formula, data, bw, bw.sel.approach = "AIC",
                       adaptive=F, kernel="bisquare", p.max=2,p.min=0.1,
                       interval=0.5,drop.tol=3, theta0=0,verbose=F,nlower = 10)
## S3 method for class 'pvlas'
plot(x, ...)
                       </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.mink.pval_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_criterion">criterion</code></td>
<td>
<p>the criterion used for distance metric selection, AICc (&quot;AICc&quot;) or cross-validation (&quot;CV&quot;) score; default is &quot;AICc&quot;</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_bw.sel.approach">bw.sel.approach</code></td>
<td>
<p>approach used to seclect an optimum bandwidth for each calibration if no bandwidth (bw) is given; 
specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_left.interval">left.interval</code></td>
<td>
<p> the step-size for searching the left interval (0, 2] in a 'backward' direction</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_right.interval">right.interval</code></td>
<td>
<p>the step-size for searching the right interval (2, Inf) in a 'forward' direction</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_p.max">p.max</code></td>
<td>
<p> the maximum value of p</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_p.min">p.min</code></td>
<td>
<p> the minimum value of p</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_interval">interval</code></td>
<td>
<p>the step-size for searching the given interval in a 'backward' or 'forward' direction</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_drop.tol">drop.tol</code></td>
<td>
<p> an AICc difference threshold to define whether the values of p to be dropped or not</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_theta0">theta0</code></td>
<td>
<p>a fixed rotation angle in radians</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE and bandwidth selection is undertaken, the bandwidth searches are reported</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_nlower">nlower</code></td>
<td>
<p>the minmum number of nearest neighbours if an adaptive kernel is used</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;pvlas&rdquo;, returned by these functions</p>
</td></tr>
<tr><td><code id="gwr.mink.pval_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>p.vals</code></td>
<td>
<p>a vector of tried values of p</p>
</td></tr>
<tr><td><code>cretion.vals</code></td>
<td>
<p>a vector of criterion values (AICc or CV) for tried values of p</p>
</td></tr>
<tr><td><code>p.dropped</code></td>
<td>
<p>a vector of boolean to label whether a value of p to be dropped or not: TRUE means to be dropped and FALSE means to be used for the Minkowski approach</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Lu, B, Charlton, M, Brunsdon, C &amp; Harris, P(2016). The Minkowski approach for choosing the distance metric in Geographically Weighted Regression. International Journal of Geographical Information Science, 30(2): 351-368.
</p>

<hr>
<h2 id='gwr.mixed'>Mixed GWR</h2><span id='topic+gwr.mixed'></span><span id='topic+gwr.mixed.2'></span><span id='topic+gwr.mixed.trace'></span><span id='topic+print.mgwr'></span><span id='topic+gwr.q'></span><span id='topic+gwr.mixed.2.fast'></span><span id='topic+gwr.mixed.trace.fast'></span><span id='topic+gwr_mixed_2'></span><span id='topic+gwr_mixed_trace'></span><span id='topic+gwr_q'></span>

<h3>Description</h3>

<p>This function implements mixed (semiparametric) GWR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.mixed(formula, data, regression.points, fixed.vars,
                     intercept.fixed=FALSE, bw, diagnostic=T, kernel="bisquare", 
                     adaptive=FALSE, p=2, theta=0, longlat=F,dMat, dMat.rp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.mixed_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_regression.points">regression.points</code></td>
<td>
<p>a Spatial*DataFrame object, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_fixed.vars">fixed.vars</code></td>
<td>
<p>independent variables that appeared in the formula that are to be treated as global</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_intercept.fixed">intercept.fixed</code></td>
<td>
<p>logical, if TRUE the intercept will be treated as global</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_diagnostic">diagnostic</code></td>
<td>
<p>logical, if TRUE the diagnostics will be calculated</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.mixed_+3A_dmat.rp">dMat.rp</code></td>
<td>
<p>a distance matrix when an individual set of regression points are adopted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;mgwr&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AICc value from this calibration</p>
</td></tr>
<tr><td><code>df.used</code></td>
<td>
<p> effective degree of freedom</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>residual sum of squares</p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with coefficient estimates in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For an alternative formulation of mixed GWR, please refer to GWR 4, which provides useful tools for automatic bandwidth selection.
This windows-based software also implements generalised mixed GWR.
</p>
<p>The mixed GWR in the latest release of GWmodel (2.0-0) has been revised by Dr. Fiona H Evans from Centre for Digital Agriculture, Murdoch and Curtin Universities in terms of its computational efficiency.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Brunsdon C, Fotheringham AS, Charlton ME (1999) Some notes on parametric signficance 
tests for geographically weighted regression. Journal of Regional Science 39(3):497-524
</p>
<p>Mei L-M, He S-Y, Fang K-T (2004) A note on the mixed geographically weighted regression 
model. Journal of regional science 44(1):143-157
</p>
<p>Mei L-M, Wang N, Zhang W-X (2006) Testing the importance of the explanatory variables 
in a mixed geographically weighted regression model. Environment and Planning A 38:587-598
</p>
<p>Nakaya T, Fotheringham AS, Brunsdon C, Charlton M (2005) Geographically Weighted Poisson Regression for Disease Association Mapping,
Statistics in Medicine 24: 2695-2717
</p>
<p>Nakaya T et al. (2011) GWR4.0, <a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a>.
</p>

<hr>
<h2 id='gwr.model.selection'>Model selection for GWR with a given set of independent variables</h2><span id='topic+gwr.model.selection'></span><span id='topic+model.selection.gwr'></span><span id='topic+Generate.formula'></span><span id='topic+extract.mat'></span><span id='topic+AICc_rss'></span><span id='topic+AICc'></span><span id='topic+gw.fitted'></span><span id='topic+ehat'></span><span id='topic+rss'></span>

<h3>Description</h3>

<p>This function selects one GWR model from many alternatives based on the AICc values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.model.selection(DeVar=NULL,InDeVars=NULL, data=list(),bw=NULL,approach="CV",
               adaptive=F,kernel="bisquare",dMat=NULL,p=2, theta=0, longlat=F,
               parallel.method=F,parallel.arg=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.model.selection_+3A_devar">DeVar</code></td>
<td>
<p>dependent variable</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_indevars">InDeVars</code></td>
<td>
<p>a vector of independent variables for model selection</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>  
<tr><td><code id="gwr.model.selection_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <code><a href="#topic+bw.gwr">bw.gwr</a></code></p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_approach">approach</code></td>
<td>
<p>specified by <b>CV</b> (<b>cv</b>) for cross validation approach or <b>AIC</b> (<b>aic</b>) 
for selecting bandwidth by AICc values</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code> </p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Specified by 'FALSE' for serial approach, 
by '&quot;omp&quot;' for multi-thread approach implemented via OpenMP, 
by '&quot;cluster&quot;' for multi-process approach implemented via 'parallel' package,
by '&quot;cuda&quot;' for parallel approach implemented via CUDA</p>
</td></tr>
<tr><td><code id="gwr.model.selection_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p>Set the argument for parallel approach. 
If 'parallel.method' is 'FALSE', there is no need to set its value. 
If 'parallel.method' is '&quot;omp&quot;', its value is used to set how many threads should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cluster&quot;', its value is used to set how many R session should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '&quot;cuda&quot;', its value is used to set how many samples is included in one group during the calibration. This value should not be too big to avoid the overflow of GPU memory. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>model.list</code></td>
<td>
<p>a list of all the tried GWR models consisted of formulas and variables.</p>
</td></tr>
<tr><td><code>GWR.df</code></td>
<td>
<p>a data frame consited of four columns: bandwidth, AIC, AICc, RSS</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The algorithm for selecting GWR models consists of the following four steps:
</p>
<p>Step 1. Start by calibrating all the possible bivariate GWR models by sequentially regressing
a single independent variable against the dependent variable; 
</p>
<p>Step 2. Find the best performing model which produces the minimum AICc value, and permanently include the corresponding independent
variable in subsequent models; 
</p>
<p>Step 3. Sequentially introduce a variable from the remaining
group of independent variables to construct new models with the permanently included independent variables,
and determine the next permanently included variable from the best fitting model that has
the minimum AICc value; 
</p>
<p>Step 4. Repeat step 3 until all the independent variables are permanently
included in the model.
</p>
<p>In this procedure, the independent variables are iteratively included into the model in a &quot;forward&quot; direction.
Note that there is a clear distinction between the different number of involved variables in a
selection step, which can be called model levels.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Lu, B, Charlton, M, Harris, P, Fotheringham, AS (2014) Geographically weighted regression 
with a non-Euclidean distance metric: a case study using hedonic house price data. 
International Journal of Geographical Information Science 28(4): 660-681
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.model.view">gwr.model.view</a></code>, <code><a href="#topic+gwr.model.sort">gwr.model.sort</a></code></p>

<hr>
<h2 id='gwr.model.sort'>Sort the results of the GWR model selection function <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code>.</h2><span id='topic+gwr.model.sort'></span><span id='topic+model.sort.gwr'></span>

<h3>Description</h3>

<p>Sort the results from the GWR model selection function <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.model.sort(Sorting.list , numVars, ruler.vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.model.sort_+3A_sorting.list">Sorting.list</code></td>
<td>
<p>a list returned by function <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code></p>
</td></tr>
<tr><td><code id="gwr.model.sort_+3A_numvars">numVars</code></td>
<td>
<p>the number of independent variables involved in model selection</p>
</td></tr>
<tr><td><code id="gwr.model.sort_+3A_ruler.vector">ruler.vector</code></td>
<td>
<p>a numeric vector as the sorting basis</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function sorts the results of model selection within individual levels.
</p>
<p>The function &ldquo;model.sort.gwr&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwr.model.sort&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code>, <code><a href="#topic+gwr.model.view">gwr.model.view</a></code></p>

<hr>
<h2 id='gwr.model.view'>Visualise the GWR models from <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code></h2><span id='topic+gwr.model.view'></span><span id='topic+model.view.gwr'></span>

<h3>Description</h3>

<p>This function visualises the GWR models from <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.model.view(DeVar, InDeVars, model.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.model.view_+3A_devar">DeVar</code></td>
<td>
<p>dependent variable</p>
</td></tr>
<tr><td><code id="gwr.model.view_+3A_indevars">InDeVars</code></td>
<td>
<p>a vector of independent variables for model selection</p>
</td></tr>
<tr><td><code id="gwr.model.view_+3A_model.list">model.list</code></td>
<td>
<p>a list of all GWR model tried in <code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;model.view.gwr&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwr.model.view&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.model.selection">gwr.model.selection</a></code>, <code><a href="#topic+gwr.model.sort">gwr.model.sort</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(LondonHP)
DM&lt;-gw.dist(dp.locat=coordinates(londonhp))
DeVar&lt;-"PURCHASE"
InDeVars&lt;-c("FLOORSZ","GARAGE1","BLDPWW1","BLDPOSTW")
model.sel&lt;-gwr.model.selection(DeVar,InDeVars, data=londonhp,
kernel = "gaussian", dMat=DM,bw=5000)
model.list&lt;-model.sel[[1]]
gwr.model.view(DeVar, InDeVars, model.list=model.list)

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.montecarlo'>Monte Carlo (randomisation) test for significance of GWR parameter variability</h2><span id='topic+gwr.montecarlo'></span><span id='topic+montecarlo.gwr'></span>

<h3>Description</h3>

<p>This function implements a Monte Carlo (randomisation) test to test for significant 
(spatial) variability of a GWR model's parameters or coefficients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.montecarlo(formula, data = list(),nsims=99, kernel="bisquare",adaptive=F, bw,
                         p=2, theta=0, longlat=F,dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.montecarlo_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_nsims">nsims</code></td>
<td>
<p>the number of randomisations</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <code><a href="#topic+bw.gwr">bw.gwr</a></code></p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.montecarlo_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pmat</code></td>
<td>
<p>A vector containing p-values for all the GWR parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function &ldquo;montecarlo.gwr&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwr.montecarlo&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Brunsdon C, Fotheringham AS, Charlton ME (1998) Geographically weighted regression - modelling spatial non-stationarity. 
Journal of the Royal Statistical Society, Series D-The Statistician 47(3):431-443
</p>
<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Charlton, M, Fotheringham, S, and Brunsdon, C (2007), GWR3.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(LondonHP)
DM&lt;-gw.dist(dp.locat=coordinates(londonhp))
bw&lt;-bw.gwr(PURCHASE~FLOORSZ,data=londonhp,dMat=DM, kernel="gaussian")
#See any difference in the next two commands and why?
res.mont1&lt;-gwr.montecarlo(PURCHASE~PROF+FLOORSZ, data = londonhp,dMat=DM,
nsim=99, kernel="gaussian", adaptive=FALSE, bw=3000)
res.mont2&lt;-gwr.montecarlo(PURCHASE~PROF+FLOORSZ, data = londonhp,dMat=DM,
nsim=99, kernel="gaussian", adaptive=FALSE, bw=300000000000)

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.multiscale'>Multiscale GWR</h2><span id='topic+gwr.multiscale'></span><span id='topic+gwr.q2'></span><span id='topic+print.multiscalegwr'></span><span id='topic+gwr.backfit'></span><span id='topic+gw_fitted'></span>

<h3>Description</h3>

<p>This function implements multiscale GWR to detect variations in regression relationships across
different spatial scales. This function can not only find a different bandwidth for each 
relationship but also (and simultaneously) find a different distance metric for 
each relationship (if required to do so).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.multiscale(formula, data, kernel = "bisquare", adaptive = FALSE,
                 criterion = "dCVR", max.iterations = 2000, threshold =
                 1e-05, dMats, var.dMat.indx, p.vals, theta.vals,
                 longlat = FALSE, bws0, bw.seled, approach = "AIC", bws.thresholds, 
                 bws.reOpts = 5, verbose = F,
                 hatmatrix = T, predictor.centered = rep(T,
                 length(bws0) - 1), nlower = 10, parallel.method = F,
                 parallel.arg = NULL)
## S3 method for class 'multiscalegwr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.multiscale_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_criterion">criterion</code></td>
<td>
<p>criterion for determining the convergence of the back-fitting procedure, could be &quot;CVR&quot; or &quot;dCVR&quot;, which corespond to the changing value of RSS (CVR) and the differential version (dCVR), respectively; and &quot;dCVR&quot; is used as default.</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_max.iterations">max.iterations</code></td>
<td>
<p>maximum number of iterations in the back-fitting procedure</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_threshold">threshold</code></td>
<td>
<p>threshold value to terminate the back-fitting iterations</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_dmats">dMats</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> of distance matrices used for estimating each specific parameter</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_var.dmat.indx">var.dMat.indx</code></td>
<td>
<p>index corresponds to a specific distance matrix for each exploratory variable, if dMats is provided</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_p.vals">p.vals</code></td>
<td>
<p> a collection of positive numbers used as the power of the Minkowski distance</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_theta.vals">theta.vals</code></td>
<td>
<p>a collection of values used as angles in radians to rotate the coordinate system</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_bws0">bws0</code></td>
<td>
<p>a <a href="base.html#topic+vector">vector</a> of initializing bandwidths for the back-fitting procedure, of which the length should equal to the number of paramters if specified</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_bw.seled">bw.seled</code></td>
<td>
<p>a <a href="base.html#topic+vector">vector</a> of boolean variables to determine whether the corresponding bandwidth should be re-selected or not: if TRUE, the corresponding bandwiths for the specific parameters are                      supposed to be given in bws0; otherwise, the bandwidths for the specific parameters will be selected within the back-fitting iterations.</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_approach">approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_bws.thresholds">bws.thresholds</code></td>
<td>
<p>threshold values to define whether the bandwidth for a specific parameter has converged or not</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_bws.reopts">bws.reOpts</code></td>
<td>
<p>the number times of continually optimizing each parameter-specific bandwidth even though it meets the criterion of convergence, for avoiding  sub-optimal choice due to illusion of                           convergence;</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE and bandwidth selection is undertaken, the bandwidth searches are reported</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_predictor.centered">predictor.centered</code></td>
<td>
<p>a logical vector of length equalling to the number of predictors, and note intercept is not included; if the element is TRUE, the corresponding predictor will be centered.</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_hatmatrix">hatmatrix</code></td>
<td>
<p>if TRUE the hatmatrix for the whole model will be calculated, and AICc, adjusted-R2 values will be returned accordingly.</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_nlower">nlower</code></td>
<td>
<p>the minmum number of nearest neighbours if an adaptive kernel is used</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_parallel.method">parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
&quot;omp&quot;: multi-thread technique with the OpenMP API, 
&quot;cluster&quot;: multi-process technique with the <span class="pkg">parallel</span> package,
&quot;cuda&quot;: parallel computing technique with CUDA</p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is &quot;omp&quot;, parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cluster&quot;, parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cuda&quot;,  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;multiscalegwr&rdquo;, returned by the function <a href="#topic+gwr.multiscale">gwr.multiscale</a></p>
</td></tr>
<tr><td><code id="gwr.multiscale_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;psdmgwr&rdquo;:
</p>
<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with data locations,coefficient estimates from the PSDM GWR model,predicted y values,residuals, coefficient standard errors and t-values in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>a list class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>an object of class inheriting from &ldquo;lm&rdquo;, see <a href="stats.html#topic+lm">lm</a>. </p>
</td></tr>
<tr><td><code>bws.vars</code></td>
<td>
<p>bandwidths used for all the parameters within the back-fitting procedure</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function implements multiscale GWR to detect variations in regression 
relationships across different spatial scales. This function can not only find 
a different bandwidth for each relationship, but also (and simultaneously), find
a different distance metric for each relationship (i.e. Parameter-Specific Distance 
Metric GWR, i.e. PSDM GWR).  Note that multiscale GWR (MGWR) has also been referred 
to as flexible bandwidth GWR (FBGWR) and conditional GWR (CGWR) in the literature. 
All are one and the same model, but where PSDM-GWR additionally provides a different 
distance metric option for each relationship.  An MGWR model is calibrated if no &ldquo;dMats&rdquo; 
and &ldquo;p.vals&rdquo; are specified; a mixed GWR model will be calibrated if an 
infinite bandwidth and another regular bandwidth are used for estimating the global and local 
parameters (again when no &ldquo;dMats&rdquo; and &ldquo;p.vals&rdquo; are specified). 
In other words, the gwr.multiscale function is specified with Euclidean distances 
in both cases. Note that the results from this function for a mixed GWR model 
and gwr.mixed might be different, as a back-fitting algorithm is used in
<a href="#topic+gwr.multiscale">gwr.multiscale</a>, while an approximating algorithm is applied in gwr.mixed. 
The <a href="#topic+gwr.mixed">gwr.mixed</a> function performs better in computational efficiency, but 
poorer in prediction accuracy.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Yang, W. (2014). An Extension of Geographically Weighted Regression with 
Flexible Bandwidths. St Andrews, St Andrews, UK.
</p>
<p>Lu, B., Harris, P., Charlton, M., &amp; Brunsdon, C. (2015). Calibrating a 
Geographically Weighted Regression Model with Parameter-specific Distance 
Metrics. Procedia Environmental Sciences, 26, 109-114.
</p>
<p>Lu, B., Brunsdon, C., Charlton, M., &amp; Harris, P. (2017). Geographically weighted 
regression with parameter-specific distance metrics. International Journal of 
Geographical Information Science, 31, 982-998.
</p>
<p>Fotheringham, A. S., Yang, W. &amp; Kang, W. (2017). Multiscale Geographically 
Weighted Regression (MGWR). Annals of the American Association of Geographers, 
107, 1247-1265.
</p>
<p>Yu, H., A. S. Fotheringham, Z. Li, T. Oshan, W. Kang &amp; L. J. Wolf. 2019. Inference 
in multiscale geographically weighted regression. Geographical Analysis(In press).
</p>
<p>Leong, Y.Y., &amp; Yue, J.C. (2017). A modification to geographically weighted 
regression. International Journal of Health Geographics, 16 (1), 11.
</p>
<p>Lu, B., Yang, W. Ge, Y. &amp; Harris, P. (2018). Improvements to the calibration of 
a geographically weighted regression with parameter-specific distance metrics 
and bandwidths. Forthcoming Computers, Environment and Urban Systems.
</p>
<p>Wolf, L.J, Oshan, T.M, Fotheringham, A.S. (2018). Single and multiscale models of 
process spatial heterogeneity. Geographical Analysis, 50(3): 223-246.
</p>
<p>Murakami, D., Lu, B., Harris, P., Brunsdon, C., Charlton, M., Nakaya, T., &amp; Griffith, D. (2019) 
The importance of scale in spatially varying coefficient modelling. 
Forthcoming Annals of the Association of American Geographers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LondonHP)
EUDM &lt;- gw.dist(coordinates(londonhp))
#No bandwidth is selected, and bws0 values are used
## Not run: 
###Similar as the basic GWR
res1&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, criterion="dCVR",kernel="gaussian", 
adaptive=T, bws0=c(100, 100, 100),bw.seled=rep(T, 3), dMats=list(EUDM,EUDM,EUDM))
#FBGWR
res2&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, criterion="dCVR",kernel="gaussian",
adaptive=T, bws0=c(100, 100, 100), dMats=list(EUDM,EUDM,EUDM))
#Mixed GWR
res3&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, bws0=c(Inf, 100, 100, Inf),
               bw.seled=rep(T, 3),kernel="gaussian", dMats=list(EUDM,EUDM,EUDM))
#PSDM GWR
res4&lt;- gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, kernel="gaussian", p.vals=c(1,2,3))

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.predict'>GWR used as a spatial predictor</h2><span id='topic+gwr.predict'></span><span id='topic+gw.reg1'></span><span id='topic+print.gwrm.pred'></span>

<h3>Description</h3>

<p>This function implements basic GWR as a spatial predictor. The GWR prediction function is able to do leave-out-one predictions (when the observation locations are used for prediction) and
predictions at a set-aside data set (when unobserved locations are used for prediction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.predict(formula, data, predictdata, bw, kernel="bisquare",adaptive=FALSE, p=2,
           theta=0, longlat=F,dMat1, dMat2)
## S3 method for class 'gwrm.pred'
print(x, ...)
           </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.predict_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_predictdata">predictdata</code></td>
<td>
<p>a Spatial*DataFrame object to provide prediction locations, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_dmat1">dMat1</code></td>
<td>
<p>a pre-specified distance matrix between data points and prediction locations; if not given, it will be calculated by the given parameters</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_dmat2">dMat2</code></td>
<td>
<p>a pre-specified sysmetric distance matrix between data points; if not given, it will be calculated by the given parameters</p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwrm.pred&rdquo;, returned by the function <a href="#topic+gwr.predict">gwr.predict</a></p>
</td></tr>
<tr><td><code id="gwr.predict_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwrm.pred&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list of geographically weighted arguments</p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object (see package &quot;sp&quot;) with GWR coefficients, predictions and prediction variances in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Harris P, Fotheringham AS, Crespo R, Charlton M (2010) The use of geographically weighted regression for spatial 
prediction: an evaluation of models using simulated data sets. Mathematical Geosciences 42:657-680
</p>
<p>Harris P, Juggins S (2011) Estimating freshwater critical load exceedance data for Great Britain 
using space-varying relationship models. Mathematical Geosciences 43: 265-292
</p>
<p>Harris P, Brunsdon C, Fotheringham AS (2011) Links, comparisons and extensions of the geographically 
weighted regression model when used as a spatial predictor.  Stochastic Environmental Research and Risk Assessment 25:123-138
</p>
<p>Gollini I, Lu B, Charlton M, Brunsdon C, Harris P (2015) GWmodel: an R Package 
for exploring Spatial Heterogeneity using Geographically Weighted Models. Journal 
of Statistical Software, 63(17):1-50
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(LondonHP)
gwr.pred&lt;-gwr.predict(PURCHASE~FLOORSZ, data=londonhp, bw=2000,kernel = "gaussian")
gwr.pred
#########Global OLS regression results and comparison with gstat functions
if(require("gstat"))
{
  mlr.g &lt;- gstat(id = "xx1", formula = PURCHASE~FLOORSZ,data=londonhp)
  mlr.g1 &lt;- predict(mlr.g, newdata = londonhp, BLUE = TRUE)
  mlr.g1
}
############
ols.pred&lt;-gwr.predict(PURCHASE~FLOORSZ, data=londonhp, bw=100000000000000000000000)
ols.pred$SDF

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.robust'>Robust GWR model</h2><span id='topic+gwr.robust'></span>

<h3>Description</h3>

<p>This function implements two robust GWR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.robust(formula, data, bw,filtered=FALSE, kernel = "bisquare", adaptive = FALSE, p = 2, 
          theta = 0, longlat = F, dMat, F123.test = F, maxiter=20,cut.filter= 3,cut1=2,
          cut2=3,delta=1.0e-5, parallel.method = FALSE, parallel.arg = NULL)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.robust_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <a href="#topic+bw.gwr">bw.gwr</a>;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_filtered">filtered</code></td>
<td>
<p>default FALSE, the automatic approach is used, if TRUE the filtered data approach is employed, as that described in Fotheringham et al. (2002 p.73-80)</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_f123.test">F123.test</code></td>
<td>
<p>default FALSE, otherwise calculate F-test results (Leung et al. 2000)</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_maxiter">maxiter</code></td>
<td>
<p>default 20, maximum number of iterations for the automatic approach</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_cut.filter">cut.filter</code></td>
<td>
<p>If filtered is TRUE, it will be used as the residual cutoff for filtering data; default cutoff is 3</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_cut1">cut1</code></td>
<td>
<p>default 2, first cutoff for the residual weighting function. wr(e)=1 if |e|&lt;=cut1*sigma</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_cut2">cut2</code></td>
<td>
<p>default 3, second cutoff for the residual weighting function. wr(e)=(1-(|e|-2)^2)^2 if cut1*sigma&lt;|e|&lt;cut2*sigma, and wr(e)=0 if |e|&gt;=cut2*sigma; cut 1 and cut2 refer to the automatic approach</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_delta">delta</code></td>
<td>
<p>default 1.0e-5, tolerance of the iterative algorithm</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_parallel.method">parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
&quot;omp&quot;: multi-thread technique with the OpenMP API, 
&quot;cluster&quot;: multi-process technique with the <span class="pkg">parallel</span> package,
&quot;cuda&quot;: parallel computing technique with CUDA</p>
</td></tr>
<tr><td><code id="gwr.robust_+3A_parallel.arg">parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is &quot;omp&quot;, parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cluster&quot;, parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is &quot;cuda&quot;,  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwrm&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>an object of class inheriting from &ldquo;lm&rdquo;, see <a href="stats.html#topic+lm">lm</a>. </p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with fit.points,GWR coefficient estimates, y value,predicted values, coefficient standard errors and t-values in its &quot;data&quot; slot. 
Notably, E_weigts will be also included in the output SDF which represents the residual weighting when automatic approach is used; When the filtered approach is used, E_weight is a vector consisted of 0 and 1, where 0 means outlier to be excluded from calibration.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
<tr><td><code>Ftest.res</code></td>
<td>
<p>results of Leung's F tests when F123.test is TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Harris P, Fotheringham AS, Juggins S (2010) Robust geographically weighed regression: a technique for quantifying spatial relationships between freshwater acidification critical loads and catchment attributes. Annals of the Association of American Geographers 100(2): 286-306
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(DubVoter)
bw.a &lt;- bw.gwr(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64,
data=Dub.voter,approach="AICc",kernel="bisquare",adaptive=TRUE)
bw.a
gwr.res &lt;- gwr.basic(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64,
data=Dub.voter,bw=bw.a,kernel="bisquare",adaptive=TRUE,F123.test=TRUE)
print(gwr.res)

# Map of the estimated coefficients for LowEduc
names(gwr.res$SDF)
if(require("RColorBrewer"))
{
  mypalette&lt;-brewer.pal(6,"Spectral")
  X11(width=10,height=12)
  spplot(gwr.res$SDF,"LowEduc",key.space = "right",
  col.regions=mypalette,at=c(-8,-6,-4,-2,0,2,4),
  main="Basic GW regression coefficient estimates for LowEduc")
}
# Robust GW regression and map of the estimated coefficients for LowEduc
rgwr.res &lt;- gwr.robust(GenEl2004~DiffAdd+LARent+SC1+Unempl+LowEduc+Age18_24
+Age25_44+Age45_64, data=Dub.voter,bw=bw.a,kernel="bisquare",
adaptive=TRUE,F123.test=TRUE)
print(rgwr.res)
if(require("RColorBrewer"))
{
  X11(width=10,height=12)
  spplot(rgwr.res$SDF, "LowEduc", key.space = "right",
  col.regions=mypalette,at=c(-8,-6,-4,-2,0,2,4),
  main="Robust GW regression coefficient estimates for LowEduc")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.scalable'>Scalable GWR</h2><span id='topic+gwr.scalable'></span><span id='topic+scgwr_pre'></span><span id='topic+scgwr_loocv'></span><span id='topic+scgwr_reg'></span><span id='topic+AICc1'></span><span id='topic+gwr.scalable.loocv'></span><span id='topic+gwr_diag1'></span><span id='topic+print.scgwrm'></span>

<h3>Description</h3>

<p>This function implements Scalable GWR for large dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.scalable(formula, data, bw.adapt=100, kernel = "gaussian", polynomial = 4, 
             p = 2, theta = 0, longlat = F, dMat)
## S3 method for class 'scgwrm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.scalable_+3A_formula">formula</code></td>
<td>
<p>Regression model formula of a <a href="stats.html#topic+formula">formula</a> object </p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_bw.adapt">bw.adapt</code></td>
<td>
<p>adaptive bandwidth (i.e. number of nearest neighbours) used for geographically weighting</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function to calculate the spatial weights, but note only two continuous functions available:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_polynomial">polynomial</code></td>
<td>
<p>Degree of the polyunomial to approximate the kernel function, and default is 4.</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;scgwrm&rdquo;, returned by the function <code><a href="#topic+gwr.scalable">gwr.scalable</a></code></p>
</td></tr>
<tr><td><code id="gwr.scalable_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;scgwrm&rdquo;:
</p>
<table>
<tr><td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td></tr>
<tr><td><code>GW.diagnostic</code></td>
<td>
<p>a list class object including the diagnostic information of the model fitting</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>an object of class inheriting from &ldquo;lm&rdquo;, see <a href="stats.html#topic+lm">lm</a>. </p>
</td></tr>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;) integrated with fit.points,GWR coefficient estimates, y value,predicted values, coefficient standard errors and t-values in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Murakami, D., N. Tsutsumida, T. Yoshida, T. Nakaya &amp; B. Lu (2019) Scalable GWR: A 
linear-time algorithm for large-scale geographically weighted regression with polynomial kernels. arXiv:1905.00266.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(spData)
data(boston)
boston &lt;- boston.c
coordinates(boston) &lt;- ~ LON + LAT
res &lt;- gwr.scalable(formula = MEDV ~ CRIM + ZN + INDUS + CHAS + AGE, data = boston, bw.adapt = 100)
res

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.t.adjust'>Adjust p-values for multiple hypothesis tests in basic GWR</h2><span id='topic+gwr.t.adjust'></span>

<h3>Description</h3>

<p>Given a set of p-values from the pseudo t-tests of basic GWR outputs, this function returns adjusted p-values using: 
(a) Bonferroni, (b) Benjamini-Hochberg, (c) Benjamini-Yekutieli and
(d) Fotheringham-Byrne procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.t.adjust(gwm.Obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.t.adjust_+3A_gwm.obj">gwm.Obj</code></td>
<td>
<p>an object of class &ldquo;gwrm&rdquo;, returned by the function <a href="#topic+gwr.basic">gwr.basic</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Byrne, G., Charlton, M. and Fotheringham, S., 2009. Multiple dependent hypothesis tests 
in geographically weighted regression. In: Lees, B. and Laffan, S. eds. 10th 
International conference on geocomputation. Sydney.
</p>

<hr>
<h2 id='gwr.write'>Write the GWR results into files</h2><span id='topic+gwr.write'></span><span id='topic+writeGWR'></span><span id='topic+writeGWR.shp'></span><span id='topic+gwr.write.shp'></span>

<h3>Description</h3>

<p>This function writes the calibration result of function <a href="#topic+gwr.basic">gwr.basic</a> to a text file and shape files</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.write(x,fn="GWRresults")
gwr.write.shp(x,fn="GWRresults")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.write_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwrm&rdquo;, returned by the function <a href="#topic+gwr.basic">gwr.basic</a></p>
</td></tr>
<tr><td><code id="gwr.write_+3A_fn">fn</code></td>
<td>
<p>file name for the written results, by default the output files can be found in the working directory, &ldquo;GWRresults.txt&rdquo;, &ldquo;GWRresults(.shp, .shx, .dbf)&rdquo;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The projection file is missing for the writen shapefiles.
</p>
<p>The functions &ldquo;writeGWR&rdquo; and &ldquo;writeGWR.shp&rdquo; (in the early versions of GWmodel) have been renamed respectively as
&ldquo;gwr.write&rdquo; and &ldquo;gwr.write.shp&rdquo;, while the old names are still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='gwss'>Geographically weighted summary statistics (GWSS)</h2><span id='topic+gwss'></span><span id='topic+local.corr'></span><span id='topic+print.gwss'></span>

<h3>Description</h3>

<p>This function calculates basic and robust GWSS.  This includes geographically weighted means, standard deviations and skew. Robust alternatives include geographically weighted medians, inter-quartile ranges and quantile imbalances. This function also calculates basic geographically weighted covariances together with basic and robust
geographically weighted correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwss(data, summary.locat,vars,kernel="bisquare",adaptive=FALSE, bw,p=2, 
            theta=0, longlat=F,dMat,quantile=FALSE)
## S3 method for class 'gwss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwss_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwss_+3A_summary.locat">summary.locat</code></td>
<td>
<p>a Spatial*DataFrame object for providing summary locations, 
i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame 
as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwss_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be summarized</p>
</td></tr>
<tr><td><code id="gwss_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function</p>
</td></tr>
<tr><td><code id="gwss_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwss_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td></tr>
<tr><td><code id="gwss_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwss_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwss_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwss_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwss_+3A_quantile">quantile</code></td>
<td>
<p>if TRUE, median, interquartile range, quantile imbalance will be calculated</p>
</td></tr>
<tr><td><code id="gwss_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;gwss&rdquo;, returned by the function <a href="#topic+gwss">gwss</a></p>
</td></tr>
<tr><td><code id="gwss_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;lss&rdquo;:
</p>
<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package &ldquo;sp&rdquo;)
with local means,local standard deviations,local variance,
local skew,local coefficients of variation, local covariances, 
local correlations (Pearson's), local correlations (Spearman's),
local medians, local interquartile ranges, local quantile imbalances and coordinates.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>other information for reporting</p>
</td></tr>          
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Brunsdon C, Fotheringham AS, Charlton ME (2002) Geographically weighted summary statistics - a framework for localised exploratory data analysis. Computers, Environment and Urban Systems 26:501-524
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2014) Geographically 
weighted methods and their use in network re-designs for environmental monitoring. 
Stochastic Environmental Research and Risk Assessment 28: 1869-1887
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(EWHP)
data(EWOutline)
head(ewhp)
houses.spdf &lt;- SpatialPointsDataFrame(ewhp[, 1:2], ewhp)
localstats1 &lt;- gwss(houses.spdf, vars = c("PurPrice", "FlrArea"), bw = 50000)
head(data.frame(localstats1$SDF))
localstats1
##A function for mapping data
if(require("RColorBrewer"))
{
   quick.map &lt;- function(spdf,var,legend.title,main.title) 
   {
     x &lt;- spdf@data[,var]
     cut.vals &lt;- pretty(x)
     x.cut &lt;- cut(x,cut.vals)
     cut.levels &lt;- levels(x.cut)
     cut.band &lt;- match(x.cut,cut.levels)
     colors &lt;- brewer.pal(length(cut.levels), "YlOrRd")
     colors &lt;- rev(colors)
     par(mar=c(1,1,1,1))
     plot(ewoutline,col="olivedrab",bg="lightblue1")
     title(main.title)
     plot(spdf,add=TRUE,col=colors[cut.band],pch=16)
     legend("topleft",cut.levels,col=colors,pch=16,bty="n",title=legend.title)
  }
  quick.map(localstats1$SDF, "PurPrice_LM", "1000's Uk Pounds", 
  "Geographically Weighted Mean")
  par(mfrow = c(1, 2))
  quick.map(localstats1$SDF, "PurPrice_LSKe", "Skewness Level", "Local Skewness")
  quick.map(localstats1$SDF, "PurPrice_LSD", "1000's Pounds", "Local Standard Deviation")
  #Exploring Non-Stationarity of Relationships
  quick.map(localstats1$SDF, "Corr_PurPrice.FlrArea", expression(rho), 
  "Geographically Weighted Pearson Correlation")
  #Robust, Quantile Based Local Summary Statistics
  localstats2 &lt;- gwss(houses.spdf, vars = c("PurPrice", "FlrArea"), 
  bw = 50000, quantile = TRUE)
  quick.map(localstats2$SDF, "PurPrice_Median", "1000 UK Pounds", 
  "Geographically Weighted Median House Price")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='gwss.montecarlo'>Monte Carlo (randomisation) test for <a href="#topic+gwss">gwss</a></h2><span id='topic+gwss.montecarlo'></span><span id='topic+montecarlo.gwss'></span>

<h3>Description</h3>

<p>This function implements Monte Carlo (randomisation) tests for the GW summary 
statistics found in <a href="#topic+gwss">gwss</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwss.montecarlo(data, vars, kernel = "bisquare", 
                adaptive = FALSE, bw, p = 2, theta = 0, longlat = F, 
                dMat, quantile=FALSE,nsim=99) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwss.montecarlo_+3A_data">data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to be summarized</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_bw">bw</code></td>
<td>
<p>bandwidth used in the weighting function</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_kernel">kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_adaptive">adaptive</code></td>
<td>
<p>if TRUE calulate the adaptive kernel, and bw correspond to the 
number of nearest neighbours, default is FALSE.</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_dmat">dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code><a href="#topic+gw.dist">gw.dist</a></code></p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_quantile">quantile</code></td>
<td>
<p>if TRUE, median, interquartile range, quantile imbalance will be calculated</p>
</td></tr>
<tr><td><code id="gwss.montecarlo_+3A_nsim">nsim</code></td>
<td>
<p>default 99, the number of randomisations</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>test</code></td>
<td>
<p>probability of the test statistics of the GW summary statistics; 
if p&lt;0.025 or if p&gt;0.975 then the true local summary statistics can be said to 
be significantly different (at the 0.95 level) to such a local summary statistics found by chance.</p>
</td></tr>         
</table>


<h3>Note</h3>

<p>The function &ldquo;montecarlo.gwss&rdquo; (in the early versions of GWmodel) has been renamed as
&ldquo;gwss.montecarlo&rdquo;, while the old name is still kept valid.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Brunsdon C, Fotheringham AS, Charlton ME (2002) Geographically weighted summary statistics - a framework for localised exploratory data analysis. Computers, Environment and Urban Systems 26:501-524
</p>
<p>Harris P, Brunsdon C (2010) Exploring spatial variation and spatial relationships in a freshwater acidification critical load data set for Great Britain using geographically weighted summary statistics. Computers &amp; Geosciences 36:54-70
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(LondonHP)
DM&lt;-gw.dist(dp.locat=coordinates(londonhp))
test.lss&lt;-gwss.montecarlo(data=londonhp, vars=c("PURCHASE","FLOORSZ"), bw=5000,
          kernel ="gaussian", dMat=DM,nsim=99)
test.lss

## End(Not run)
</code></pre>

<hr>
<h2 id='LondonBorough'>London boroughs data</h2><span id='topic+LondonBorough'></span><span id='topic+londonborough'></span>

<h3>Description</h3>

<p>Outline (SpatialPolygonsDataFrame) of London boroughs for the <a href="#topic+LondonHP">LondonHP</a> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LondonBorough)</code></pre>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='LondonHP'>London house price data set (SpatialPointsDataFrame)</h2><span id='topic+LondonHP'></span><span id='topic+londonhp'></span>

<h3>Description</h3>

<p>A house price data set with 18 hedonic variables for London in 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LondonHP)</code></pre>


<h3>Format</h3>

<p>A SpatialPointsDataFrame object (proj4string set to &quot;+init=epsg:27700 +datum=OSGB36&quot;).
</p>
<p>The &quot;data&quot; slot is a data frame with 372 observations on the following 21 variables.
</p>

<dl>
<dt>X</dt><dd><p>a numeric vector, X coordinate</p>
</dd>
<dt>Y</dt><dd><p>a numeric vector, Y coordinate</p>
</dd>
<dt>PURCHASE</dt><dd><p>a numeric vector, the purchase price of the property</p>
</dd>
<dt>FLOORSZ</dt><dd><p>a numeric vector, floor area of the property in square metres</p>
</dd>
<dt>TYPEDETCH</dt><dd><p>a numeric vector, 1 if the property is detached (i.e. it is a stand-alone house), 0 otherwise</p>
</dd>
<dt>TPSEMIDTCH</dt><dd><p>a numeric vector, 1 if the property is semi detached, 0 otherwise</p>
</dd>
<dt>TYPETRRD</dt><dd><p>a numeric vector, 1 if the property is in a terrace of similar houses (commonly referred to as a 'row house' in the USA), 0 otherwise</p>
</dd>
<dt>TYPEBNGLW</dt><dd><p>a numeric vector, if the property is a bungalow (i.e. it has only one floor), 0 otherwise</p>
</dd>
<dt>TYPEFLAT</dt><dd><p>a numeric vector, if the property is a flat (or 'apartment' in the USA), 0 otherwise</p>
</dd>
<dt>BLDPWW1</dt><dd><p>a numeric vector, 1 if the property was built prior to 1914, 0 otherwise</p>
</dd>
<dt>BLDPOSTW</dt><dd><p>a numeric vector, 1 if the property was built between 1940 and 1959, 0 otherwise</p>
</dd>
<dt>BLD60S</dt><dd><p>a numeric vector, 1 if the property was built between 1960 and 1969, 0 otherwise</p>
</dd>
<dt>BLD70S</dt><dd><p>a numeric vector, 1 if the property was built between 1970 and 1979, 0 otherwise</p>
</dd>
<dt>BLD80S</dt><dd><p>a numeric vector, 1 if the property was built between 1980 and 1989, 0 otherwise</p>
</dd>
<dt>BLD90S</dt><dd><p>a numeric vector, 1 if the property was built between 1990 and 2000, 0 otherwise</p>
</dd>
<dt>BATH2</dt><dd><p>a numeric vector, 1 if the property has more than 2 bathrooms, 0 otherwise</p>
</dd>
<dt>GARAGE</dt><dd><p>a numeric vector,1 if the house has a garage, 0 otherwise</p>
</dd>
<dt>CENTHEAT</dt><dd><p>a numeric vector, 1 if the house has central heating, 0 otherwise</p>
</dd>
<dt>BEDS2</dt><dd><p>a numeric vector, 1 if the property has more than 2 bedrooms, 0 otherwise</p>
</dd>
<dt>UNEMPLOY</dt><dd><p>a numeric vector, the rate of unemployment in the census ward in which the house is located</p>
</dd>
<dt>PROF</dt><dd><p>a numeric vector, the proportion of the workforce in professional or managerial occupations in the census ward in which the house is located</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E. (2002), Geographically Weighted Regression: 
The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Lu, B, Charlton, M, Harris, P, Fotheringham, AS (2014) Geographically weighted regression 
with a non-Euclidean distance metric: a case study using hedonic house price data. 
International Journal of Geographical Information Science 28(4): 660-681
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LondonHP)
data(LondonBorough)
ls()
plot(londonborough)
plot(londonhp, add=TRUE)
</code></pre>

<hr>
<h2 id='st.dist'>Spatio-temporal distance matrix calculation</h2><span id='topic+st.dist'></span>

<h3>Description</h3>

<p>Calculate a distance vector(matrix) between any GW model calibration point(s) and the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st.dist(dp.locat, rp.locat, obs.tv, reg.tv,focus=0, p=2, 
        theta=0, longlat=F,lamda=0.05,t.units = "auto",
        ksi=0, s.dMat,t.dMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st.dist_+3A_dp.locat">dp.locat</code></td>
<td>
<p>a numeric matrix of two columns giving the coordinates of the data points</p>
</td></tr>
<tr><td><code id="st.dist_+3A_rp.locat">rp.locat</code></td>
<td>
<p>a numeric matrix of two columns giving the coordinates of the GW model calibration points</p>
</td></tr>
<tr><td><code id="st.dist_+3A_obs.tv">obs.tv</code></td>
<td>
<p>a vector of time tags for each observation, which could be numeric or of <a href="base.html#topic+POSIXlt">POSIXlt</a> class</p>
</td></tr>
<tr><td><code id="st.dist_+3A_reg.tv">reg.tv</code></td>
<td>
<p>a vector of time tags for each regression location, which could be numeric or of <a href="base.html#topic+POSIXlt">POSIXlt</a> class</p>
</td></tr>
<tr><td><code id="st.dist_+3A_focus">focus</code></td>
<td>
<p>an integer, indexing to the current GW model point, if focus=0, all the distances between all the GW model calibration points and data points will be calculated and a distance matrix will be returned; if 0&lt;focus&lt;length(rp.locat), then the distances between the 'focus'th GW model points and data points will be calculated and a distance vector will be returned</p>
</td></tr>
<tr><td><code id="st.dist_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td></tr>
<tr><td><code id="st.dist_+3A_theta">theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td></tr>
<tr><td><code id="st.dist_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td></tr>
<tr><td><code id="st.dist_+3A_lamda">lamda</code></td>
<td>
<p>an parameter between 0 and 1 for calculating spatio-temporal distance</p>
</td></tr> 
<tr><td><code id="st.dist_+3A_t.units">t.units</code></td>
<td>
<p>	character string to define time unit</p>
</td></tr>
<tr><td><code id="st.dist_+3A_ksi">ksi</code></td>
<td>
<p>an parameter between 0 and PI for calculating spatio-temporal distance, 
see details in Wu et al. (2014)</p>
</td></tr>
<tr><td><code id="st.dist_+3A_s.dmat">s.dMat</code></td>
<td>
<p>a predifined spatial distance matrix for calculating spatio-temporal distances</p>
</td></tr>
<tr><td><code id="st.dist_+3A_t.dmat">t.dMat</code></td>
<td>
<p>a predifined temporal distance matrix for calculating spatio-temporal distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric spatio-temporal distance matrix or vector;
or a matrix with its rows corresponding to the observations and its columns corresponds to the calibration points.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='USelect'>Results of the 2004 US presidential election at the county level (SpatialPolygonsDataFrame)</h2><span id='topic+USelect2004'></span>

<h3>Description</h3>

<p>Results of the 2004 US presidential election at the county level, together with five socio-economic (census) variables.
This data can be used with GW Discriminant Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USelect)</code></pre>


<h3>Format</h3>

<p>A SpatialPolygonsDataFrame with 3111 electoral divisions on the following 6 variables.
</p>

<dl>
<dt>winner</dt><dd><p>Categorical variable with three classes: i) Bush, ii) Kerry and iii) Borderline (supporting ratio for a candidate ranges from 0.45 to 0.55)</p>
</dd>
<dt>unemploy</dt><dd><p>percentage unemployed</p>
</dd>
<dt>pctcoled</dt><dd><p>percentage of adults over 25 with 4 or more years of college education</p>
</dd>
<dt>PEROVER65</dt><dd><p>percentage of persons over the age of 65</p>
</dd>
<dt>pcturban</dt><dd><p>percentage urban</p>
</dd>
<dt>WHITE</dt><dd><p>percentage white</p>
</dd>   
</dl>



<h3>References</h3>

<p>Robinson, A. C. (2013). Geovisualization of the 2004 Presidential Election. 
In: NATIONAL INSTITUTES OF HEALTH, P. S. U. (ed.). Penn State.
</p>
<p>Foley, P. &amp; Demsar, U. (2012). Using geovisual analytics to compare the 
performance of geographically weighted discriminant analysis versus its global 
counterpart, linear discriminant analysis. International Journal of Geographical 
Information Science, 27, 633-661.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USelect)
ls()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
