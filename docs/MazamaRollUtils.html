<!DOCTYPE html><html><head><title>Help for package MazamaRollUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MazamaRollUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#example_pm25'><p>Example timeseries dataset</p></a></li>
<li><a href='#findOutliers'><p>Outlier Detection with a Rolling Hampel Filter</p></a></li>
<li><a href='#MazamaRollUtils-package'>
<p>Mazama Science Rolling Utilities</p></a></li>
<li><a href='#roll_hampel'><p>Roll Hampel</p></a></li>
<li><a href='#roll_MAD'><p>Roll MAD</p></a></li>
<li><a href='#roll_max'><p>Roll Max</p></a></li>
<li><a href='#roll_mean'><p>Roll Mean</p></a></li>
<li><a href='#roll_median'><p>Roll Median</p></a></li>
<li><a href='#roll_min'><p>Roll Min</p></a></li>
<li><a href='#roll_prod'><p>Roll Product</p></a></li>
<li><a href='#roll_sd'><p>Roll Standard Deviation</p></a></li>
<li><a href='#roll_sum'><p>Roll Sum</p></a></li>
<li><a href='#roll_var'><p>Roll Variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Rolling Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Callahan [aut, cre],
  Hans Martin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Callahan &lt;jonathan.s.callahan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of compiled functions calculating rolling mins, means, 
    maxes and other statistics. This package is designed to meet the needs of
    data processing systems for environmental time series.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MazamaScience/MazamaRollUtils">https://github.com/MazamaScience/MazamaRollUtils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MazamaScience/MazamaRollUtils/issues">https://github.com/MazamaScience/MazamaRollUtils/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, roxygen2, testthat (&ge; 2.1.0),
zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-23 07:07:26 UTC; jonathancallahan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-23 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='example_pm25'>Example timeseries dataset</h2><span id='topic+example_pm25'></span>

<h3>Description</h3>

<p>The <code>example_pm25_data</code> dataset provides example timeseries
data for practicing and code examples. This data represents hourly air quality
measurements.
</p>
<p>This dataset was was generated on 2021-09-22 by running:
</p>
<pre>
library(AirSensor)

example_pm25 &lt;- example_sensor$data
names(example_pm25) &lt;- c("datetime", "pm25")

save(example_pm25, file = "data/example_pm25.rda")
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>example_pm25
</code></pre>


<h3>Format</h3>

<p>A dataframe with columns &quot;datetime&quot; and &quot;pm25&quot;.
</p>

<hr>
<h2 id='findOutliers'>Outlier Detection with a Rolling Hampel Filter</h2><span id='topic+findOutliers'></span>

<h3>Description</h3>

<p>A wrapper for the <code>roll_hampel()</code> function that counts
outliers using either a user specified threshold value or a threshold value
based on the statistics of the incoming data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOutliers(
  x,
  width = 25,
  thresholdMin = 7,
  selectivity = NA,
  fixedThreshold = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOutliers_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="findOutliers_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="findOutliers_+3A_thresholdmin">thresholdMin</code></td>
<td>
<p>Numeric threshold for outlier detection</p>
</td></tr>
<tr><td><code id="findOutliers_+3A_selectivity">selectivity</code></td>
<td>
<p>Value between [0-1] used in determining outliers, or
<code>NA</code> if <code>fixedThreshold=TRUE</code>.</p>
</td></tr>
<tr><td><code id="findOutliers_+3A_fixedthreshold">fixedThreshold</code></td>
<td>
<p>Logical specifying whether outlier detection uses
<code>selectivity</code>  (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>thresholdMin</code> level is similar to a sigma value for normally
distributed data. Hampel filter values above 6 indicate a data value that is
extremely unlikely to be part of a normal distribution  (~ 1/500 million) and
therefore very likely to be an outlier. By choosing a relatively large value
for <code>thresholdMin</code> we make it less likely that we will generate false
positives. False positives can include high frequency environmental noise.
</p>
<p>With the default setting of <code>fixedThreshold = TRUE</code> any value above the
threshold is considered an outlier and the <code>selectivity</code> is ignored.
</p>
<p>The <code>selectivity</code> is a value between 0 and 1 and is used to generate an
appropriate threshold for outlier detection based on the statistics of the
incoming data. A lower value for <code>selectivity</code> will result in more
outliers while a value closer to 1.0 will result in fewer. If
<code>fixedThreshold=TRUE</code>, <code>selectivity</code> may have a value of <code>NA</code>.
</p>
<p>When the user specifies <code>fixedThreshold=FALSE</code>, the <code>thresholdMin</code>
and <code>selectivity</code> parameters work like squelch and volume on a CB radio:
<code>thresholdMin</code> sets a noise threshold below which you don't want anything
returned while <code>selectivity</code> adjusts the number of points defined as
outliers by setting a new threshold defined by the maximum value of
<code>roll_hampel</code> multiplied by <code>selectivity</code>.
</p>
<p><code>width</code>, the window width, is a parameter that is passed to
<code>roll_hampel()</code>.
</p>


<h3>Value</h3>

<p>A vector of indices associated with outliers in the incoming data <code>x</code>.
</p>


<h3>Note</h3>

<p>This function is copied from the <span class="pkg">seismicRoll</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roll_hampel">roll_hampel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Noisy sinusoid with outliers
a &lt;- jitter(sin(0.1*seq(1e4)),amount=0.2)
indices &lt;- sample(seq(1e4),20)
a[indices] &lt;- a[indices]*10

# Outlier detection should identify many of these altered indices
sort(indices)
o_indices &lt;- findOutliers(a)
o_indices

plot(a)
points(o_indices, a[o_indices], pch = 16, cex = 0.8, col = 'red')
title("Outlier detection using a Hampel filter")
</code></pre>

<hr>
<h2 id='MazamaRollUtils-package'>
Mazama Science Rolling Utilities
</h2><span id='topic+MazamaRollUtils-package'></span><span id='topic+MazamaRollUtils'></span>

<h3>Description</h3>

<p>A suite of utility functions for calculating rolling mins, means,
maxes and other functions written with an efficient Rcpp/C++ backend.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan,
Hans Martin
</p>

<hr>
<h2 id='roll_hampel'>Roll Hampel</h2><span id='topic+roll_hampel'></span>

<h3>Description</h3>

<p>Apply a moving-window Hampel function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_hampel(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_hampel_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_hampel_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_hampel_+3A_by">by</code></td>
<td>
<p>Integer shift to use when sliding the window to the next location</p>
</td></tr>
<tr><td><code id="roll_hampel_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_hampel_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hampel filter is a robust outlier detector using Median Absolute Deviation (MAD).
</p>
<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the Hampel funcion of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

x &lt;- c(0, 0, 0, 1, 1, 2, 2, 4, 6, 9, 0, 0, 0)
roll_hampel(x, 3)
</code></pre>

<hr>
<h2 id='roll_MAD'>Roll MAD</h2><span id='topic+roll_MAD'></span>

<h3>Description</h3>

<p>Apply a moving-window Median Absolute Deviation function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_MAD(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_MAD_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_MAD_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_MAD_+3A_by">by</code></td>
<td>
<p>Integer shift to use when sliding the window to the next location</p>
</td></tr>
<tr><td><code id="roll_MAD_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_MAD_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the Median Absolute Deviation (MAD) of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Wikipedia example
x &lt;- c(0, 0, 0, 1, 1, 2, 2, 4, 6, 9, 0, 0, 0)
roll_MAD(x, 3)
roll_MAD(x, 5)
roll_MAD(x, 7)
</code></pre>

<hr>
<h2 id='roll_max'>Roll Max</h2><span id='topic+roll_max'></span>

<h3>Description</h3>

<p>Apply a moving-window maximum function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_max(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_max_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_max_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_max_+3A_by">by</code></td>
<td>
<p>Integer shift to use when sliding the window to the next location</p>
</td></tr>
<tr><td><code id="roll_max_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_max_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the maximum of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

plot(t, x, pch = 16, cex = 0.5)
lines(t, roll_max(x, width = 12), col = 'red')
lines(t, roll_min(x, width = 12), col = 'deepskyblue')
title("12-hr Rolling Max and Min")

plot(t, x, pch = 16, cex = 0.5)
points(t, roll_max(x, width = 12, na.rm = TRUE),
       pch = 16, col = 'red')
points(t, roll_max(x, width = 12, na.rm = FALSE),
       pch = 16, col = adjustcolor('black', 0.4))
legend("topright", pch = c(1, 16),
       col = c("red", adjustcolor("black", 0.4)),
       legend = c("na.rm = TRUE", "na.rm = FALSE"))
title("12-hr Rolling max with/out na.rm")

</code></pre>

<hr>
<h2 id='roll_mean'>Roll Mean</h2><span id='topic+roll_mean'></span>

<h3>Description</h3>

<p>Apply a moving-window mean function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_mean(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_mean_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_mean_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_mean_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_mean_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
<tr><td><code id="roll_mean_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of size <code>width</code> specifying each window
index weight. If <code>NULL</code>, unit weights are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the mean of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>
<p>The <code>roll_mean()</code> function supports an additional <code>weights</code>
argument that can be used to calculate a &quot;weighted moving average&quot; &ndash;
a convolution of the incoming data with the <em>kernel</em> (weighting function)
provided in <code>weights</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

plot(t, x, pch = 16, cex = 0.5)
lines(t, roll_mean(x, width = 3), col = "goldenrod")
lines(t, roll_mean(x, width = 23), col = "purple")
legend("topright", lty = c(1, 1),
       col = c("goldenrod", "purple"),
       legend = c("3-hr mean", "12-hr mean"))
title("3- and 23-hr Rolling mean")
</code></pre>

<hr>
<h2 id='roll_median'>Roll Median</h2><span id='topic+roll_median'></span>

<h3>Description</h3>

<p>Apply a moving-window median function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_median(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_median_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_median_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_median_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_median_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_median_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the median of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

plot(t, x, pch = 16, cex = 0.5)
lines(t, roll_median(x, width = 3), col = "goldenrod")
lines(t, roll_median(x, width = 23), col = "purple")
legend("topright", lty = c(1, 1),
       col = c("goldenrod", "purple"),
       legend = c("3-hr median", "12-hr median"))
title("3- and 23-hr Rolling median")
</code></pre>

<hr>
<h2 id='roll_min'>Roll Min</h2><span id='topic+roll_min'></span>

<h3>Description</h3>

<p>Apply a moving-window minimum function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_min(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_min_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_min_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_min_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_min_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_min_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the minimum of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

plot(t, x, pch = 16, cex = 0.5)
lines(t, roll_max(x, width = 12), col = 'red')
lines(t, roll_min(x, width = 12), col = 'deepskyblue')
title("12-hr Rolling Max and Min")

plot(t, x, pch = 16, cex = 0.5)
points(t, roll_min(x, width = 12, na.rm = TRUE),
       pch = 16, col = 'deepskyblue')
points(t, roll_min(x, width = 12, na.rm = FALSE),
       pch = 16, col = adjustcolor('black', 0.4))
legend("topright", pch = c(16, 16),
       col = c("deepskyblue", adjustcolor("black", 0.4)),
       legend = c("na.rm = TRUE", "na.rm = FALSE"))
title("12-hr Rolling min with/out na.rm")
</code></pre>

<hr>
<h2 id='roll_prod'>Roll Product</h2><span id='topic+roll_prod'></span>

<h3>Description</h3>

<p>Apply a moving-window product function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_prod(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_prod_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_prod_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_prod_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_prod_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_prod_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the product of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

x[1:10]
roll_prod(x, width = 5)[1:10]
</code></pre>

<hr>
<h2 id='roll_sd'>Roll Standard Deviation</h2><span id='topic+roll_sd'></span>

<h3>Description</h3>

<p>Apply a moving-window standard deviation function to a
numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_sd(x, width = 1L, by = 1L, align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_sd_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_sd_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_sd_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_sd_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the standard deviation of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Note</h3>

<p>No <code>na.rm</code> argument is provided as interpretation of the results
is not at all clear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

x[1:10]
roll_sd(x, width = 5)[1:10]
</code></pre>

<hr>
<h2 id='roll_sum'>Roll Sum</h2><span id='topic+roll_sum'></span>

<h3>Description</h3>

<p>Apply a moving-window sum to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_sum(
  x,
  width = 1L,
  by = 1L,
  align = c("center", "left", "right"),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_sum_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
<tr><td><code id="roll_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether <code>NA</code> values should be removed
before the calculations within each window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the sum of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

x[1:10]
roll_sum(x, width = 5)[1:10]
</code></pre>

<hr>
<h2 id='roll_var'>Roll Variance</h2><span id='topic+roll_var'></span>

<h3>Description</h3>

<p>Apply a moving-window variance function to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_var(x, width = 1L, by = 1L, align = c("center", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_var_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roll_var_+3A_width">width</code></td>
<td>
<p>Integer width of the rolling window.</p>
</td></tr>
<tr><td><code id="roll_var_+3A_by">by</code></td>
<td>
<p>Integer shift by which the window is moved each iteration.</p>
</td></tr>
<tr><td><code id="roll_var_+3A_align">align</code></td>
<td>
<p>Character position of the return value within the window. One of:
<code>"left" | "center" | "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every index in the incoming vector <code>x</code>, a value is returned that
is the variance of all values in <code>x</code> that fall within a window of width
<code>width</code>.
</p>
<p>The <code>align</code> parameter determines the alignment of the return value
within the window. Thus:
</p>

<ul>
<li><p><code>align = -1 [*------]</code> will cause the returned vector to have width-1 <code>NA</code> values at the right end.
</p>
</li>
<li><p><code>align = 0  [---*---]</code> will cause the returned vector to have width/2 <code>NA</code> values at either end.
</p>
</li>
<li><p><code>align = 1  [------*]</code> will cause the returned vector to have width-1 <code>NA</code> values at the left end.
</p>
</li></ul>

<p>For large vectors, the<code>by</code> parameter can be used to force the window
to jump ahead <code>by</code> indices for the next calculation. Indices that are
skipped over will be assigned <code>NA</code> values so that the return vector still has
the same length as the incoming vector. This can dramatically speed up
calculations for high resolution time series data.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>.
</p>


<h3>Note</h3>

<p>No <code>na.rm</code> argument is provided as interpretation of the results
is not at all clear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MazamaRollUtils)

# Example air quality time series
t &lt;- example_pm25$datetime
x &lt;- example_pm25$pm25

x[1:10]
roll_var(x, width = 5)[1:10]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
