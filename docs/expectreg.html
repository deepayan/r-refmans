<!DOCTYPE html><html lang="en"><head><title>Help for package expectreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {expectreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expectreg-package'>
<p>Expectile and Quantile Regression</p></a></li>
<li><a href='#cdf.qp'>
<p>Calculation of the conditional CDF based on expectile curves</p></a></li>
<li><a href='#dutchboys'>
<p>Data set about the growth of dutch children</p></a></li>
<li><a href='#enorm'>
<p>Expectiles of distributions</p></a></li>
<li><a href='#expectile'>
<p>Sample Expectiles</p></a></li>
<li><a href='#expectreg.boost'>
<p>Quantile and expectile regression using boosting</p></a></li>
<li><a href='#expectreg.ls'>
<p>Expectile regression of additive models</p></a></li>
<li><a href='#Gasoline'>
<p>Gasoline Consumption</p></a></li>
<li><a href='#india'>
<p>Malnutrition of Childen in India</p></a></li>
<li><a href='#india.bnd'>
<p>Regions of India - boundary format</p></a></li>
<li><a href='#methods'>
<p>Methods for expectile regression objects</p></a></li>
<li><a href='#Mqreg'>
<p>Semiparametric M-Quantile Regression</p></a></li>
<li><a href='#northger.bnd'>
<p>Regions of northern Germany - boundary format</p></a></li>
<li><a href='#pemq'>
<p>The &quot;expectiles-meet-quantiles&quot; distribution family.</p></a></li>
<li><a href='#plot.expectreg'>
<p>Default expectreg plotting</p></a></li>
<li><a href='#quant.bundle'>
<p>Restricted expectile regression of additive models</p></a></li>
<li><a href='#rb'>
<p>Creates base for a regression based on covariates</p></a></li>
<li><a href='#update.expectreg'>
<p>Update given expectreg model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.53</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Expectile and Quantile Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabian Otto-Sobotka [cre],
  Elmar Spiegel [aut],
  Sabine Schnabel [aut],
  Linda Schulze Waltrup [aut],
  Paul Eilers [ctb],
  Thomas Kneib [ths],
  Goeran Kauermann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabian Otto-Sobotka &lt;fabian.otto-sobotka@uni-oldenburg.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, parallel, mboost (&ge; 2.1.0), BayesX (&ge;
0.2-4), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2), splines, quadprog, colorspace (&ge; 0.97),
fields</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SemiPar</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Expectile and quantile regression of models with nonlinear effects
  e.g. spatial, random, ridge using least asymmetric weighed squares / absolutes
  as well as boosting; also supplies expectiles for common distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 15:43:04 UTC; fews</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='expectreg-package'>
Expectile and Quantile Regression
</h2><span id='topic+expectreg-package'></span><span id='topic+expectreg'></span>

<h3>Description</h3>

<p>Expectile and quantile regression of models with nonlinear effects
e.g. spatial, random, ridge using least asymmetric weighed squares / absolutes
as well as boosting; also supplies expectiles for common distributions.
</p>


<h3>Details</h3>


<ul>
<li><p> This package requires the packages <code>BayesX</code>, <code>mboost</code>, <code><a href="splines.html#topic+splines-package">splines</a></code> and <code>quadprog</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fabian Otto-Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Elmar Spiegel <br />
Helmholtz Centre Munich <br />
<a href="https://www.helmholtz-munich.de">https://www.helmholtz-munich.de</a> <br />
</p>
<p>Sabine Schnabel <br />
Wageningen University and Research Centre <br />
<a href="https://www.wur.nl">https://www.wur.nl</a>
</p>
<p>Linda Schulze Waltrup <br />
Ludwig Maximilian University Munich <br />
<a href="https://www.lmu.de">https://www.lmu.de</a> <br />
</p>
<p>with contributions from
</p>
<p>Paul Eilers <br />
Erasmus Medical Center Rotterdam <br />
<a href="https://www.erasmusmc.nl">https://www.erasmusmc.nl</a>
</p>
<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>
<p>Goeran Kauermann <br />
Ludwig Maximilian University Munich <br />
<a href="https://www.lmu.de">https://www.lmu.de</a> <br />
</p>
<p>Maintainer: Fabian Otto-Sobotka &lt;fabian.otto-sobotka@uni-oldenburg.de&gt;
</p>


<h3>References</h3>

<p>Fenske N and Kneib T and Hothorn T (2009)
<em> Identifying Risk Factors for Severe Childhood Malnutrition
by Boosting Additive Quantile Regression</em>
Technical Report 052, University of Munich
</p>
<p>He X (1997)
<em> Quantile Curves without Crossing </em>
The American Statistician, 51(2):186-192
</p>
<p>Koenker R (2005)
<em> Quantile Regression </em>
Cambridge University Press, New York
</p>
<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computational Statistics and Data Analysis, 53:4168-4177
</p>
<p>Schnabel S and Eilers P (2011)
<em> Expectile sheets for joint estimation of expectile curves </em>
(under review at Statistical Modelling)
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code>mboost</code>, <code>BayesX</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dutchboys)

## Expectile Regression using the restricted approach
ex = expectreg.ls(dist ~ rb(speed),data=cars,smooth="f",lambda=5,estimate="restricted")
names(ex)

## The calculation of expectiles for given distributions
enorm(0.1)
enorm(0.5)

## Introducing the expectiles-meet-quantiles distribution
x = seq(-5,5,length=100)
plot(x,demq(x),type="l")

## giving an expectile analogon to the 'quantile' function
y = rnorm(1000)

expectile(y)

eenorm(y)
</code></pre>

<hr>
<h2 id='cdf.qp'>
Calculation of the conditional CDF based on expectile curves
</h2><span id='topic+cdf.qp'></span><span id='topic+cdf.bundle'></span>

<h3>Description</h3>

<p>Estimating the CDF of the response for a given value of covariate. Additionally quantiles are computed
from the distribution function which allows for the calculation of regression quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf.qp(expectreg, x = NA, qout = NA, extrap = FALSE, e0 = NA, eR = NA,
       lambda = 0, var.dat = NA)

cdf.bundle(bundle, qout = NA, extrap = FALSE, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdf.qp_+3A_expectreg">expectreg</code>, <code id="cdf.qp_+3A_bundle">bundle</code></td>
<td>

<p>An object of class expectreg or subclass bundle respectively. The number of expectiles should be high enough to ensure accurate estimation. 
One approach would be to take as many expectiles as data points. Also make sure that extreme expectiles are incuded, e.g. expectiles corresponding to very small and large asymmetrie values.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_x">x</code></td>
<td>

<p>The covariate value where the CDF is estimated. By default the first covariate value.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_qout">qout</code></td>
<td>

<p>Vector of quantiles that will be computed from the CDF.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_extrap">extrap</code></td>
<td>

<p>If TRUE, extreme quantiles will be extrapolated linearly, otherwise the maximum of the CDF is used.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_e0">e0</code></td>
<td>

<p>Scalar number which offers the possibility to specify an artificial minimal expectile (for example the minimum of the data) used for the calculation. By default e0 = e1 + (e1 - e2) where e1 is the actual minimal expectile and e2 the second smallest expectile.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_er">eR</code></td>
<td>

<p>Scalar number which offers the possibility to specify an artificial maximal expectile (for example the maximum of the data) used for the calculation. By default eR = eR-1 + (eR-1 - eR-2) where eR-1 is the actual maximal expectile and eR-2 the second largest expectile.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_lambda">lambda</code></td>
<td>

<p>Positive Scalar. Penalty parameter steering the smoothness of the fitted CDF. By default equal to 0 which means no penalization.
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_var.dat">var.dat</code></td>
<td>

<p>Positive Scalar. If a penalization is applied (i.e. <code>lambda</code> unequal to 0), this argument can be used to let the penalty depend on the variance of the expectiles (which is the default).
</p>
</td></tr>
<tr><td><code id="cdf.qp_+3A_quietly">quietly</code></td>
<td>

<p>If programm should run quietly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expectile curves can describe very well the spread and location of a scatterplot. With
a set of curves they give good impression about the nature of the data. This information
can be used to estimate the conditional density from the expectile curves.
The results of the bundle model are especially suited in this case
as only one density will be estimated which can then be modulated to
over the independent variable x. The 
density estimation can be formulated as penalized least squares problem that results in a smooth non-negative
density.
The theoretical values of a quantile regression at this covariate value
are also returned for adjustable probabilities <code>qout</code>.
</p>


<h3>Value</h3>

<p>A list consisting of
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p> vector of expectiles where the CDF is computed. </p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p> vector of values of the CDF at the expectiles <code>x</code>. </p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p> vector of quantile values estimated from the CDF. </p>
</td></tr>
<tr><td><code>qout</code></td>
<td>
<p> vector of probabilities for the calculated quantiles. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Goeran Kauermann, Linda Schulze Waltrup <br />
Ludwig Maximilian University Munich <br />
<a href="https://www.lmu.de">https://www.lmu.de</a> <br />
</p>
<p>Fabian Sobotka <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>
<p>Sabine Schnabel <br />
Wageningen University and Research Centre <br />
<a href="https://www.wur.nl">https://www.wur.nl</a> <br />
</p>
<p>Paul Eilers <br />
Erasmus Medical Center Rotterdam <br />
<a href="https://www.erasmusmc.nl">https://www.erasmusmc.nl</a> <br />
</p>


<h3>References</h3>

<p>Schnabel SK and Eilers PHC (2010)
<em> A location scale model for non-crossing expectile curves </em>
(working paper)
</p>
<p>Schulze Waltrup L, Sobotka F, Kneib T and Kauermann G (2014)
<em> Expectile and Quantile Regression - David and Goliath? </em>
Statistical Modelling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="#topic+expectreg.qp">expectreg.qp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = expectreg.ls(dist ~ rb(speed),data=cars,smooth="f",lambda=5,estimate="restricted",
                 expectiles=c(0.0001,0.001,seq(0.01,0.99,0.01),0.999,0.9999))
e = cdf.qp(d,15,extrap=TRUE)
e 
</code></pre>

<hr>
<h2 id='dutchboys'>
Data set about the growth of dutch children
</h2><span id='topic+dutchboys'></span>

<h3>Description</h3>

<p>Data from the fourth dutch growth study in 1997.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dutchboys)</code></pre>


<h3>Format</h3>

<p>A data frame with 6848 observations on the following 10 variables.
</p>

<dl>
<dt><code>defnr</code></dt><dd><p>identification number</p>
</dd>
<dt><code>age</code></dt><dd><p>age in decimal years</p>
</dd>
<dt><code>hgt</code></dt><dd><p>length/height in cm</p>
</dd>
<dt><code>wgt</code></dt><dd><p>weight in kg</p>
</dd>
<dt><code>hc</code></dt><dd><p>head circumference in cm</p>
</dd>
<dt><code>hgt.z</code></dt><dd><p>z-score length/height</p>
</dd>
<dt><code>wgt.z</code></dt><dd><p>z-score weight</p>
</dd>
<dt><code>hc.z</code></dt><dd><p>z-score head circumference</p>
</dd>
<dt><code>bmi.z</code></dt><dd><p>z-score body mass index</p>
</dd>
<dt><code>hfw.z</code></dt><dd><p>z-score height for weight</p>
</dd>
</dl>

<p>z-scores were calculated relative to the Dutch references.  
</p>


<h3>Details</h3>

<p>The Fourth Dutch Growth Study is a cross-sectional study that measures growth and
development of the Dutch population between ages 0 and 21 years. The study is a follow-up
to earlier studies performed in 1955, 1965 and 1980, and its primary goal is to
update the 1980 references.
</p>


<h3>Source</h3>

<p>van Buuren S and Fredriks A (2001)
<em>Worm plot: A simple diagnostic device for modeling growth reference curves</em>
Statistics in Medicine, 20:1259-1277
</p>


<h3>References</h3>

<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computatational Statistics and Data Analysis, 53: 4168-4177 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dutchboys)

expreg &lt;- expectreg.ls(dutchboys[,3] ~ rb(dutchboys[,2],"pspline"),smooth="f",
                       estimate="restricted",expectiles=c(.05,.5,.95))
plot(expreg)
</code></pre>

<hr>
<h2 id='enorm'>
Expectiles of distributions
</h2><span id='topic+enorm'></span><span id='topic+ebeta'></span><span id='topic+eunif'></span><span id='topic+et'></span><span id='topic+egamma'></span><span id='topic+elnorm'></span><span id='topic+echisq'></span><span id='topic+eexp'></span><span id='topic+penorm'></span><span id='topic+pebeta'></span><span id='topic+peunif'></span><span id='topic+pet'></span><span id='topic+pegamma'></span><span id='topic+pelnorm'></span><span id='topic+pechisq'></span><span id='topic+peexp'></span>

<h3>Description</h3>

<p>Much like the 0.5 quantile of a distribution is the median,
the 0.5 expectile is the mean / expected value.
These functions add the possibility of calculating expectiles
of known distributions. The functions starting with 'e' calculate
an expectile value for given asymmetry values, the functions 
starting with 'pe' calculate vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enorm(asy, m = 0, sd = 1)
penorm(e, m = 0, sd = 1)

ebeta(asy, a = 1, b = 1)
pebeta(e, a = 1, b = 1)

eunif(asy, min = 0, max = 1)
peunif(e, min = 0, max = 1)

et(asy, df)
pet(e, df)

elnorm(asy, meanlog = 0, sdlog = 1)
pelnorm(e, meanlog = 0, sdlog = 1)

egamma(asy, shape, rate = 1, scale = 1/rate)
pegamma(e, shape, rate = 1, scale = 1/rate)

eexp(asy, rate = 1)
peexp(e, rate = 1)

echisq(asy, df)
pechisq(e, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enorm_+3A_asy">asy</code></td>
<td>

<p>vector of asymmetries with values between 0 and 1.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_e">e</code></td>
<td>

<p>vector of expectiles from the respective distribution.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_m">m</code>, <code id="enorm_+3A_sd">sd</code></td>
<td>

<p>mean and standard deviation of the Normal distribution.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_a">a</code>, <code id="enorm_+3A_b">b</code></td>
<td>

<p>positive parameters of the Beta distribution.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_min">min</code>, <code id="enorm_+3A_max">max</code></td>
<td>

<p>minimum, maximum of the uniform distribution.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_df">df</code></td>
<td>

<p>degrees of freedom of the student t and chi squared distribution.
</p>
</td></tr>
<tr><td><code id="enorm_+3A_meanlog">meanlog</code>, <code id="enorm_+3A_sdlog">sdlog</code></td>
<td>

<p>parameters of the lognormal distribution.  
</p>
</td></tr>
<tr><td><code id="enorm_+3A_shape">shape</code>, <code id="enorm_+3A_rate">rate</code>, <code id="enorm_+3A_scale">scale</code></td>
<td>

<p>parameters of the gamma distribution (with 2 different parametrizations)
and parameter of the exponential distribution which is a special case of the gamma
with shape=1.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An expectile of a distribution cannot be determined explicitely,
but instead is given by an equation.
The expectile z for an asymmetry p is:
<code class="reqn"> p = \frac{G(z) - z F(z)}{2(G(z) - z F(z)) + z - m}</code>
where m is the mean, F the cdf and G the partial moment function
<code class="reqn"> G(z) = \int\limits_{-\infty}^{z} uf(u) \mbox{d}u </code>.
</p>


<h3>Value</h3>

<p>Vector of the expectiles or asymmetry values for the desired distribution.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>References</h3>

<p>Newey W and Powell J (1987)
<em> Asymmetric least squares estimation and testing </em>
Econometrica, 55:819-847
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eemq">eemq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0.02,0.98,0.2)

e = enorm(x)
e
penorm(e)

</code></pre>

<hr>
<h2 id='expectile'>
Sample Expectiles
</h2><span id='topic+expectile'></span><span id='topic+eenorm'></span><span id='topic+eeplot'></span>

<h3>Description</h3>

<p>Expectiles are fitted to univariate samples with least asymmetrically weighted squares for asymmetries between 0 and 1.
For graphical representation an expectile - expectile plot is available. The corresponding functions <code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code>
and <code><a href="stats.html#topic+qqnorm">qqnorm</a></code> are mapped here for expectiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectile(x, probs = seq(0, 1, 0.25), dec = 4)

eenorm(y, main = "Normal E-E Plot",
       xlab = "Theoretical Expectiles", ylab = "Sample Expectiles",
       plot.it = TRUE, datax = FALSE, ...)
       
eeplot(x, y, plot.it = TRUE, xlab = deparse(substitute(x)),
       ylab = deparse(substitute(y)), main = "E-E Plot", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectile_+3A_x">x</code>, <code id="expectile_+3A_y">y</code></td>
<td>

<p>Numeric vector of univariate observations.
</p>
</td></tr>
<tr><td><code id="expectile_+3A_probs">probs</code></td>
<td>

<p>Numeric vector of asymmetries between 0 and 1 where 0.5 corresponds to the mean.  
</p>
</td></tr>
<tr><td><code id="expectile_+3A_dec">dec</code></td>
<td>

<p>Number of decimals remaining after rounding the results.  
</p>
</td></tr>
<tr><td><code id="expectile_+3A_plot.it">plot.it</code></td>
<td>

<p>logical. Should the result be plotted?
</p>
</td></tr>
<tr><td><code id="expectile_+3A_datax">datax</code></td>
<td>

<p>logical. Should data values be on the x-axis? 
</p>
</td></tr>
<tr><td><code id="expectile_+3A_xlab">xlab</code>, <code id="expectile_+3A_ylab">ylab</code>, <code id="expectile_+3A_main">main</code></td>
<td>

<p>plot labels. The xlab and ylab refer to the x and y axes respectively if <code>datax</code> = TRUE.
</p>
</td></tr>
<tr><td><code id="expectile_+3A_...">...</code></td>
<td>

<p>graphical parameters. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In least asymmetrically weighted squares (LAWS) each expectile is fitted independently from the others.
LAWS minimizes:
</p>
<p><code class="reqn"> S = \sum_{i=1}^{n}{ w_i(p)(x_i - \mu(p))^2} </code>
</p>
<p>with
</p>
<p><code class="reqn"> w_i(p) = p 1_{(x_i &gt; \mu(p))} + (1-p) 1_{(x_i &lt; \mu(p))} </code>.
</p>
<p><code class="reqn">\mu(p)</code> is determined by iteration process with recomputed weights <code class="reqn">w_i(p)</code>.
</p>


<h3>Value</h3>

<p>Numeric vector with the fitted expectiles.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto-Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>


<h3>References</h3>

<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dutchboys)

expectile(dutchboys[,3])

x = rnorm(1000)

expectile(x,probs=c(0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99))

eenorm(x)
</code></pre>

<hr>
<h2 id='expectreg.boost'>
Quantile and expectile regression using boosting
</h2><span id='topic+expectreg.boost'></span><span id='topic+quant.boost'></span>

<h3>Description</h3>

<p>Generalized additive models are fitted with gradient boosting for optimizing arbitrary 
loss functions to obtain the graphs of 11 different expectiles
for continuous, spatial or random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectreg.boost(formula, data, mstop = NA, expectiles = NA, cv = TRUE, 
BoostmaxCores = 1, quietly = FALSE)

quant.boost(formula, data, mstop = NA, quantiles = NA, cv = TRUE, 
BoostmaxCores = 1, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectreg.boost_+3A_formula">formula</code></td>
<td>

<p>An R formula object consisting of the response variable, '~'
and the sum of all effects that should be taken into consideration (see <code><a href="mboost.html#topic+gamboost">gamboost</a></code>).
Each effect can be linear or represented through a nonlinear or spatial base
(see <code><a href="mboost.html#topic+bbs">bbs</a></code>). Each variable has to be named consistently with <code>data</code>.
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_data">data</code></td>
<td>

<p>data frame (is required).
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_mstop">mstop</code></td>
<td>

<p>vector, number of bootstrap iterations for each of the 11 quantiles/expectiles that are fitted.
Default is 4000.
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_expectiles">expectiles</code>, <code id="expectreg.boost_+3A_quantiles">quantiles</code></td>
<td>

<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated.
You may specify your own set of expectiles in a vector.
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_cv">cv</code></td>
<td>

<p>A cross-validation can determine the optimal amount of boosting iterations between 1 and <code>mstop</code>.
Uses <code><a href="mboost.html#topic+cvrisk">cvrisk</a></code>. If set to <code>FALSE</code>, the results from <code>mstop</code> iterations are used.
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_boostmaxcores">BoostmaxCores</code></td>
<td>

<p>Maximum number of used cores for the different asymmetry parameters
</p>
</td></tr>
<tr><td><code id="expectreg.boost_+3A_quietly">quietly</code></td>
<td>

<p>If programm should run quietly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A (generalized) additive model is fitted using a boosting algorithm based on component-wise univariate base learners. 
The base learner can be specified via the formula object. After fitting the model a cross-validation is done using
<code><a href="mboost.html#topic+cvrisk">cvrisk</a></code> to determine the optimal stopping point for the boosting which results in the best fit.
</p>


<h3>Value</h3>

<p>An object of class 'expectreg', which is basically a list consisting of:
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or 'phi' for kriging. </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td></tr>
</table>
<p><code><a href="#topic+plot.expectreg">plot</a></code>, <code><a href="#topic+predict.expectreg">predict</a></code>, <code><a href="#topic+resid.expectreg">resid</a></code>, <code><a href="#topic+fitted.expectreg">fitted</a></code> and <code><a href="#topic+effects.expectreg">effects</a></code>
methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib, Elmar Spiegel <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>References</h3>

<p>Fenske N and Kneib T and Hothorn T (2009)
<em> Identifying Risk Factors for Severe Childhood Malnutrition
by Boosting Additive Quantile Regression</em>
Technical Report 052, University of Munich
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="mboost.html#topic+gamboost">gamboost</a></code>, <code><a href="mboost.html#topic+bbs">bbs</a></code>, <code><a href="mboost.html#topic+cvrisk">cvrisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lidar", package = "SemiPar")
ex &lt;- expectreg.boost(logratio ~ bbs(range),lidar, mstop=200, 
                      expectiles=c(0.1,0.5,0.95),quietly=TRUE)
plot(ex)

</code></pre>

<hr>
<h2 id='expectreg.ls'>
Expectile regression of additive models
</h2><span id='topic+expectreg.ls'></span><span id='topic+expectreg.qp'></span>

<h3>Description</h3>

<p>Additive models are fitted with least asymmetrically weighted squares
or quadratic programming to obtain expectiles
for parametric, continuous, spatial and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectreg.ls(formula, data = NULL, estimate = c("laws", "restricted", "bundle", "sheets"),
smooth = c("schall", "ocv", "gcv", "cvgrid", "aic", "bic", "lcurve", "fixed"), 
lambda = 1, expectiles = NA, ci = FALSE, LAWSmaxCores = 1, ...)

expectreg.qp(formula, data  = NULL, id = NA, smooth = c("schall", "acv", "fixed"), 
             lambda = 1, expectiles = NA) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectreg.ls_+3A_formula">formula</code></td>
<td>

<p>An R formula object consisting of the response variable, '~'
and the sum of all effects that should be taken into consideration.
Each effect has to be given through the function <code><a href="#topic+rb">rb</a></code>.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_data">data</code></td>
<td>

<p>Optional data frame containing the variables used in the model, if the data is not explicitely given in the
formula.  
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_id">id</code></td>
<td>

<p>Potential additional variable identifying individuals in a longitudinal data set. Allows for a random intercept estimation.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_estimate">estimate</code></td>
<td>

<p>Character string defining the estimation method that is used to fit the expectiles. Further detail on all available methods is given below.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_smooth">smooth</code></td>
<td>

<p>There are different smoothing algorithms that should prevent overfitting.
The 'schall' algorithm iterates the smoothing penalty <code>lambda</code> until it converges (REML).
The generalised cross-validation 'gcv',similar to the ordinary cross- validation 'ocv' minimizes a score-function using <code><a href="stats.html#topic+nlminb">nlminb</a></code> or with a grid search by 'cvgrid' or the function uses a fixed penalty. The numerical minimisatioin is also possible with AIC or BIC as score. The L-curve is a new experimental grid search by Frasso and Eilers.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_lambda">lambda</code></td>
<td>

<p>The fixed penalty can be adjusted. Also serves as starting value for
the smoothing algorithms.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_expectiles">expectiles</code></td>
<td>

<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated.
You may specify your own set of expectiles in a vector. The option may be set to 'density' for the calculation
of a dense set of expectiles that enhances the use of <code><a href="#topic+cdf.qp">cdf.qp</a></code> and <code><a href="#topic+cdf.bundle">cdf.bundle</a></code> afterwards.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_ci">ci</code></td>
<td>

<p>Whether a covariance matrix for confidence intervals and a <code><a href="#topic+summary.expectreg">summary</a></code> is calculated.
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_lawsmaxcores">LAWSmaxCores</code></td>
<td>

<p>How many cores should maximal be used by parallelization
</p>
</td></tr>
<tr><td><code id="expectreg.ls_+3A_...">...</code></td>
<td>

<p>Optional value for re-weight the model with estimate weights and combine selected models to one model. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In least asymmetrically weighted squares (LAWS) each expectile is fitted independently from the others.
LAWS minimizes:
</p>
<p><code class="reqn"> S = \sum_{i=1}^{n}{ w_i(p)(y_i - \mu_i(p))^2} </code>
</p>
<p>with
</p>
<p><code class="reqn"> w_i(p) = p 1_{(y_i &gt; \mu_i(p))} + (1-p) 1_{(y_i &lt; \mu_i(p))} </code>.
</p>
<p>The restricted version fits the 0.5 expectile at first and then the residuals.
Afterwards the other expectiles are fitted as deviation by a factor of the residuals from the mean expectile.
This algorithm is based on He(1997). The advantage is that expectile crossing cannot occur,
the disadvantage is a suboptimal fit in certain heteroscedastic settings.
Also, since the number of fits is significantly decreased, the restricted version is much faster.
</p>
<p>The expectile bundle has a resemblence to the restricted regression. At first, a trend curve is fitted
and then an iteration is performed between fitting the residuals and calculating the deviation factors
for all the expectiles until the results are stable. Therefore this function shares the (dis)advantages
of the restricted.
</p>
<p>The expectile sheets construct a p-spline basis for the expectiles and perform a continuous fit over all expectiles
by fitting the tensor product of the expectile spline basis and the basis of the covariates.
In consequence there will be most likely no crossing of expectiles but also a good fit in heteroscedastic scenarios.
</p>
<p>The function <code>expectreg.qp</code> also fits a sheet over all expectiles, but it uses quadratic programming with constraints,
so crossing of expectiles will definitely not happen. So far the function is implemented for one nonlinear or spatial covariate
and further parametric covariates. It works with all smoothing methods.
</p>


<h3>Value</h3>

<p>An object of class 'expectreg', which is basically a list consisting of:
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.
For the restricted and the bundle regression there are only the mean and the residual lambda.</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercept for each expectile.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> A matrix of all the coefficients, for each base element
a row and for each expectile a column. </p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p> List with the values of the covariates. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or 'phi' for kriging. </p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> Complete design matrix. </p>
</td></tr>
<tr><td><code>bases</code></td>
<td>
<p> Bases components of each covariate. </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p> Covariance matrix, estimated when <code>ci = TRUE</code>. </p>
</td></tr>
<tr><td><code>diag.hatma</code></td>
<td>
<p> Diagonal of the hat matrix. Used for model selection criteria. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> Original data </p>
</td></tr>
<tr><td><code>smooth_orig</code></td>
<td>
<p> Unchanged original type of smoothing. </p>
</td></tr>

</table>
<p><code><a href="#topic+plot.expectreg">plot</a></code>, <code><a href="#topic+predict.expectreg">predict</a></code>, <code><a href="#topic+resid.expectreg">resid</a></code>,
<code><a href="#topic+fitted.expectreg">fitted</a></code>, <code><a href="#topic+effects.expectreg">effects</a></code>
and further convenient methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto-Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>
<p>Sabine Schnabel <br />
Wageningen University and Research Centre <br />
<a href="https://www.wur.nl">https://www.wur.nl</a>
</p>
<p>Paul Eilers <br />
Erasmus Medical Center Rotterdam <br />
<a href="https://www.erasmusmc.nl">https://www.erasmusmc.nl</a>
</p>
<p>Linda Schulze Waltrup, Goeran Kauermann <br />
Ludwig Maximilians University Muenchen <br />
<a href="https://www.lmu.de">https://www.lmu.de</a> <br />
</p>


<h3>References</h3>

<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computational Statistics and Data Analysis, 53:4168-4177
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>
<p>Schnabel S and Eilers P (2011)
<em> Expectile sheets for joint estimation of expectile curves </em>
(under review at Statistical Modelling)
</p>
<p>Frasso G and Eilers P (2013)
<em> Smoothing parameter selection using the L-curve</em>
(under review)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rb">rb</a></code>, <code><a href="#topic+expectreg.boost">expectreg.boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(expectreg)
ex = expectreg.ls(dist ~ rb(speed),data=cars,smooth="b",lambda=5,expectiles=c(0.01,0.2,0.8,0.99))
ex = expectreg.ls(dist ~ rb(speed),data=cars,smooth="f",lambda=5,estimate="restricted")
plot(ex)


data("lidar", package = "SemiPar")

explaws &lt;- expectreg.ls(logratio~rb(range,"pspline"),data=lidar,smooth="gcv",
                        expectiles=c(0.05,0.5,0.95))
print(explaws)
plot(explaws)

###expectile regression using a fixed penalty
plot(expectreg.ls(logratio~rb(range,"pspline"),data=lidar,smooth="fixed",
     lambda=1,expectiles=c(0.05,0.25,0.75,0.95)))
plot(expectreg.ls(logratio~rb(range,"pspline"),data=lidar,smooth="fixed",
     lambda=0.0000001,expectiles=c(0.05,0.25,0.75,0.95)))
    #As can be seen in the plot, a too small penalty causes overfitting of the data.
plot(expectreg.ls(logratio~rb(range,"pspline"),data=lidar,smooth="fixed",
     lambda=50,expectiles=c(0.05,0.25,0.75,0.95)))
    #If the penalty parameter is chosen too large, 
    #the expectile curves are smooth but don't represent the data anymore.
</code></pre>

<hr>
<h2 id='Gasoline'>
Gasoline Consumption
</h2><span id='topic+Gasoline'></span>

<h3>Description</h3>

<p>A panel of 18 observations from 1960 to 1978 in OECD countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Gasoline")</code></pre>


<h3>Format</h3>

<p>A data frame with 342 observations on the following 6 variables.
</p>

<dl>
<dt><code>country</code></dt><dd><p>a factor with 18 levels <code>AUSTRIA</code> <code>BELGIUM</code> <code>CANADA</code> <code>DENMARK</code> <code>FRANCE</code> <code>GERMANY</code> <code>GREECE</code> <code>IRELAND</code> <code>ITALY</code> <code>JAPAN</code> <code>NETHERLA</code> <code>NORWAY</code> <code>SPAIN</code> <code>SWEDEN</code> <code>SWITZERL</code> <code>TURKEY</code> <code>U.K.</code> <code>U.S.A.</code></p>
</dd>
<dt><code>year</code></dt><dd><p>the year</p>
</dd>
<dt><code>lgaspcar</code></dt><dd><p>logarithm of motor gasoline consumption per car</p>
</dd>
<dt><code>lincomep</code></dt><dd><p>logarithm of real per-capita income</p>
</dd>
<dt><code>lrpmg</code></dt><dd><p>logarithm of real motor gasoline price</p>
</dd>
<dt><code>lcarpcap</code></dt><dd><p>logarithm of the stock of cars per capita</p>
</dd>
</dl>



<h3>Source</h3>

<p>Online complements to Baltagi (2001).
</p>
<p><a href="https://www.wiley.com/legacy/wileychi/baltagi/">https://www.wiley.com/legacy/wileychi/baltagi/</a>
</p>


<h3>References</h3>

<p>Baltagi, Badi H. (2001) &quot;Econometric Analysis of Panel Data&quot;, 2nd ed., John Wiley and Sons.
</p>
<p>Gibraltar, B.H. and J.M. Griffin (1983) ???Gasoline demand in the OECD: An application of pooling and testing procedures???, European Economic Review, 22(2), 117???137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gasoline)

expreg&lt;-expectreg.ls(lrpmg~rb(lcarpcap),smooth="fixed",data=Gasoline,
lambda=20,estimate="restricted",expectiles=c(0.01,0.05,0.2,0.8,0.95,0.99))

plot(expreg)
</code></pre>

<hr>
<h2 id='india'>
Malnutrition of Childen in India
</h2><span id='topic+india'></span>

<h3>Description</h3>

<p>Data sample from a 'Demographic and Health Survey' about malnutrition of children in india.
Data set only contains 1/10 of the observations and some basic variables to enable first analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(india)</code></pre>


<h3>Format</h3>

<p>A data frame with 4000 observations on the following 6 variables.
</p>

<dl>
<dt><code>stunting</code></dt><dd><p>A numeric malnutrition score with range (-600;600).</p>
</dd>
<dt><code>cbmi</code></dt><dd><p>BMI of the child.</p>
</dd>
<dt><code>cage</code></dt><dd><p>Age of the child in months.</p>
</dd>
<dt><code>mbmi</code></dt><dd><p>BMI of the mother.</p>
</dd>
<dt><code>mage</code></dt><dd><p>Age of the mother in years.</p>
</dd>
<dt><code>distH</code></dt><dd><p>The distict in India, where the child lives. Encoded in the region naming
of the map <code><a href="#topic+india.bnd">india.bnd</a></code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://dhsprogram.com">https://dhsprogram.com</a>
</p>


<h3>References</h3>

<p>Fenske N and Kneib T and Hothorn T (2009)
<em> Identifying Risk Factors for Severe Childhood Malnutrition
by Boosting Additive Quantile Regression</em>
Technical Report 052, University of Munich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(india)

expreg &lt;- expectreg.ls(stunting ~ rb(cbmi),smooth="fixed",data=india,
lambda=30,estimate="restricted",expectiles=c(0.01,0.05,0.2,0.8,0.95,0.99))
plot(expreg)
</code></pre>

<hr>
<h2 id='india.bnd'>
Regions of India - boundary format
</h2><span id='topic+india.bnd'></span>

<h3>Description</h3>

<p>Map of the country india, represented in the boundary format (bnd)
as defined in the package <code>BayesX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(india.bnd)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 449
- attr(*, &quot;class&quot;)= chr &quot;bnd&quot;
- attr(*, &quot;height2width&quot;)= num 0.96
- attr(*, &quot;surrounding&quot;)=List of 449
- attr(*, &quot;regions&quot;)= chr [1:440] &quot;84&quot; &quot;108&quot; &quot;136&quot; &quot;277&quot; ...
</p>


<h3>Details</h3>

<p>For details about the format see <code><a href="BayesX.html#topic+read.bnd">read.bnd</a></code>.
</p>


<h3>Source</h3>

<p>Jan Priebe
University of Goettingen
<a href="https://www.bnitm.de/forschung/forschungsgruppen/implementation/ag-gesundheitsoekonomie/team">https://www.bnitm.de/forschung/forschungsgruppen/implementation/ag-gesundheitsoekonomie/team</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(india)
data(india.bnd)

drawmap(data=india,map=india.bnd,regionvar=6,plotvar=1)
</code></pre>

<hr>
<h2 id='methods'>
Methods for expectile regression objects
</h2><span id='topic+print.expectreg'></span><span id='topic+predict.expectreg'></span><span id='topic+residuals.expectreg'></span><span id='topic+resid.expectreg'></span><span id='topic+coef.expectreg'></span><span id='topic+coefficients.expectreg'></span><span id='topic+fitted.expectreg'></span><span id='topic+fitted.values.expectreg'></span><span id='topic+effects.expectreg'></span><span id='topic++5B.expectreg'></span><span id='topic+summary.expectreg'></span><span id='topic+confint.expectreg'></span>

<h3>Description</h3>

<p>Methods for objects returned by expectile regression functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'expectreg'
print(x, ...)

## S3 method for class 'expectreg'
summary(object,...)

## S3 method for class 'expectreg'
predict(object, newdata = NULL, with_intercept = T, ...)

## S3 method for class 'expectreg'
x[i]

## S3 method for class 'expectreg'
residuals(object, ...)
## S3 method for class 'expectreg'
resid(object, ...)

## S3 method for class 'expectreg'
fitted(object, ...)
## S3 method for class 'expectreg'
fitted.values(object, ...)

## S3 method for class 'expectreg'
effects(object, ...)

## S3 method for class 'expectreg'
coef(object, ...)
## S3 method for class 'expectreg'
coefficients(object, ...)

## S3 method for class 'expectreg'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="methods_+3A_x">x</code>, <code id="methods_+3A_object">object</code></td>
<td>

<p>An object of class <code>expectreg</code> as returned e.g. by the function <code><a href="#topic+expectreg.ls">expectreg.ls</a></code>.
</p>
</td></tr>
<tr><td><code id="methods_+3A_newdata">newdata</code></td>
<td>
 
<p>Optionally, a data frame in which to look for variables with which to predict.
</p>
</td></tr>
<tr><td><code id="methods_+3A_with_intercept">with_intercept</code></td>
<td>

<p>Should the intercept be added to the prediction of splines?
</p>
</td></tr>
<tr><td><code id="methods_+3A_i">i</code></td>
<td>

<p>Covariate numbers to be kept in subset.
</p>
</td></tr>
<tr><td><code id="methods_+3A_level">level</code></td>
<td>

<p>Coverage probability of the generated confidence intervals.
</p>
</td></tr>
<tr><td><code id="methods_+3A_parm">parm</code></td>
<td>

<p>Optionally the confidence intervals may be restricted to certain covariates, to be named in a vector. Otherwise the confidence intervals for the fit are returned.  
</p>
</td></tr>
<tr><td><code id="methods_+3A_...">...</code></td>
<td>
<p> additional arguments passed over. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to extract details from fitted models.
<code>print</code> shows a dense representation of the model fit.
</p>
<p><code>[</code> can be used to define a new object with a subset of covariates from the original fit.
</p>
<p>The function <code>coef</code> extracts the regression coefficients for each covariate listed separately.
For the function <code><a href="#topic+expectreg.boost">expectreg.boost</a></code> this is not possible.
</p>


<h3>Value</h3>

<p><code>[</code> returns a new object of class expectreg with a subset of covariates from the original fit.
</p>
<p><code>resid</code> returns the residuals in order of the response.
</p>
<p><code>fitted</code> returns the overall fitted values <code class="reqn">\hat{y}</code> while <code>effects</code> returns the values
for each covariate in a list.
</p>
<p><code>coef</code> returns a list of all regression coefficients separately for each covariate.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Elmar Spiegel <br />
Georg August University Goettingen
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>References</h3>

<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computational Statistics and Data Analysis, 53:4168-4177
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="#topic+expectreg.boost">expectreg.boost</a></code>, <code><a href="#topic+expectreg.qp">expectreg.qp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dutchboys)

expreg &lt;- expectreg.ls(hgt ~ rb(age,"pspline"),data=dutchboys,smooth="f",
                       expectiles=c(0.05,0.2,0.8,0.95))

print(expreg)

coef(expreg)

new.d = dutchboys[1:10,]
new.d[,2] = 1:10

predict(expreg,newdata=new.d)
</code></pre>

<hr>
<h2 id='Mqreg'>
Semiparametric M-Quantile Regression
</h2><span id='topic+Mqreg'></span>

<h3>Description</h3>

<p>Robust M-quantiles are estimated using an iterative penalised reweighted least squares approach.
Effects using quadratic penalties can be included, such as P-splines, Markov random fields or Kriging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mqreg(formula, data = NULL, smooth = c("schall", "acv", "fixed"), 
      estimate = c("iprls", "restricted"),lambda = 1, tau = NA, robust = 1.345,
      adaptive = FALSE, ci = FALSE, LSMaxCores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mqreg_+3A_formula">formula</code></td>
<td>

<p>An R formula object consisting of the response variable, '~'
and the sum of all effects that should be taken into consideration.
Each effect has to be given through the function <code><a href="#topic+rb">rb</a></code>.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_data">data</code></td>
<td>

<p>Optional data frame containing the variables used in the model, if the data is not explicitely given in the
formula.  
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_estimate">estimate</code></td>
<td>

<p>Character string defining the estimation method that is used to fit the expectiles. Further detail on all available methods is given below.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_smooth">smooth</code></td>
<td>

<p>There are different smoothing algorithms that should prevent overfitting.
The 'schall' algorithm iterates the smoothing penalty <code>lambda</code> until it converges,
the asymmetric cross-validation 'acv' minimizes a score-function using <code><a href="stats.html#topic+nlm">nlm</a></code>
or the function uses a fixed penalty.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_lambda">lambda</code></td>
<td>

<p>The fixed penalty can be adjusted. Also serves as starting value for
the smoothing algorithms.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_tau">tau</code></td>
<td>

<p>In default setting, the expectiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated.
You may specify your own set of expectiles in a vector. The option may be set to 'density' for the calculation
of a dense set of expectiles that enhances the use of <code><a href="#topic+cdf.qp">cdf.qp</a></code> and <code><a href="#topic+cdf.bundle">cdf.bundle</a></code> afterwards.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_robust">robust</code></td>
<td>

<p>Robustness constant in M-estimation. See <code>Details</code> for definition.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_adaptive">adaptive</code></td>
<td>

<p>Logical. Whether the robustness constant is adapted along the covariates.  	
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_ci">ci</code></td>
<td>

<p>Whether a covariance matrix for confidence intervals and the summary function is calculated.
</p>
</td></tr>
<tr><td><code id="Mqreg_+3A_lsmaxcores">LSMaxCores</code></td>
<td>

<p>How many cores should maximal be used by parallelization
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the least squares approach the following loss function is minimised:
</p>
<p><code class="reqn"> S = \sum_{i=1}^{n}{ w_p(y_i - m_i(p))^2} </code>
</p>
<p>with weights
</p>
<p><code class="reqn"> w_p(u) = (-(1-p)*c*(u_i&lt; -c)+(1-p)*u_i*(u_i&lt;0 \&amp; u_i&gt;=-c)+p*u_i*(u_i&gt;=0 \&amp; u_i&lt;c)+p*c*(u_i&gt;=c)) / u_i </code>
</p>
<p>for quantiles and
</p>
<p><code class="reqn"> w_p(u) = -(1-p)*c*(u_i&lt; -c)+(1-p)*u_i*(u_i&lt;0 \&amp; u_i&gt;=-c)+p*u_i*(u_i&gt;=0 \&amp; u_i&lt;c)+p*c*(u_i&gt;=c) </code>
</p>
<p>for expectiles, with standardised residuals <code class="reqn">u_i = 0.6745*(y_i - m_i(p)) / median(y-m(p))</code> and robustness constant c.
</p>


<h3>Value</h3>

<p>An object of class 'expectreg', which is basically a list consisting of:
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.
For the restricted and the bundle regression there are only the mean and the residual lambda.</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercept for each expectile.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> A matrix of all the coefficients, for each base element
a row and for each expectile a column. </p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p> List with the values of the covariates. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or 'phi' for kriging. </p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> Complete design matrix. </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td></tr>
</table>
<p><code><a href="#topic+plot.expectreg">plot</a></code>, <code><a href="#topic+predict.expectreg">predict</a></code>, <code><a href="#topic+resid.expectreg">resid</a></code>,
<code><a href="#topic+fitted.expectreg">fitted</a></code>, <code><a href="#topic+effects.expectreg">effects</a></code>
and further convenient methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Monica Pratesi <br />
University Pisa <br />
<a href="https://www.unipi.it">https://www.unipi.it</a> <br />
</p>
<p>M. Giovanna Ranalli <br />
University Perugia <br />
<a href="https://www.unipg.it">https://www.unipg.it</a> <br />
</p>
<p>Nicola Salvati <br />
University Perugia <br />
<a href="https://www.unipg.it">https://www.unipg.it</a> <br />
</p>
<p>Fabian Otto-Sobotka <br />
University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>


<h3>References</h3>

<p>Pratesi M, Ranalli G and Salvati N (2009)
<em>Nonparametric M-quantile regression using penalised splines</em>
Journal of Nonparametric Statistics, 21:3, 287-304.
</p>
<p>Otto-Sobotka F, Ranalli G, Salvati N, Kneib T (2019)
<em>Adaptive Semiparametric M-quantile Regression</em>
Econometrics and Statistics 11, 116-129.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="quantreg.html#topic+rqss">rqss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lidar", package = "SemiPar")

m &lt;- Mqreg(logratio~rb(range,"pspline"),data=lidar,smooth="f",
                        tau=c(0.05,0.5,0.95),lambda=10)
plot(m,rug=FALSE)

</code></pre>

<hr>
<h2 id='northger.bnd'>
Regions of northern Germany - boundary format
</h2><span id='topic+northger.bnd'></span>

<h3>Description</h3>

<p>Map of northern Germany, represented in the boundary format (bnd)
as defined in the package <code>BayesX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(northger.bnd)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 145
- attr(*, &quot;class&quot;)= chr &quot;bnd&quot;
- attr(*, &quot;height2width&quot;)= num 1.54
- attr(*, &quot;surrounding&quot;)=List of 145
- attr(*, &quot;regions&quot;)= chr [1:145] &quot;1001&quot; &quot;1002&quot; &quot;1003&quot; &quot;1004&quot; ...
</p>


<h3>Details</h3>

<p>For details about the format see <code><a href="BayesX.html#topic+read.bnd">read.bnd</a></code>.
</p>


<h3>Source</h3>

<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(northger.bnd)

drawmap(map=northger.bnd,mar.min=NULL)
</code></pre>

<hr>
<h2 id='pemq'>
The &quot;expectiles-meet-quantiles&quot; distribution family.
</h2><span id='topic+pemq'></span><span id='topic+demq'></span><span id='topic+remq'></span><span id='topic+qemq'></span><span id='topic+eemq'></span><span id='topic+peemq'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation, expectile function
and expectile distribution function for a family of distributions
for which expectiles and quantiles coincide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pemq(z,ncp=0,s=1)
demq(z,ncp=0,s=1)
qemq(q,ncp=0,s=1)
remq(n,ncp=0,s=1)
eemq(asy,ncp=0,s=1)
peemq(e,ncp=0,s=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pemq_+3A_ncp">ncp</code></td>
<td>

<p>non centrality parameter and mean of the distribution.
</p>
</td></tr>
<tr><td><code id="pemq_+3A_s">s</code></td>
<td>

<p>scaling parameter, has to be positive.
</p>
</td></tr>
<tr><td><code id="pemq_+3A_z">z</code>, <code id="pemq_+3A_e">e</code></td>
<td>

<p>vector of quantiles / expectiles.
</p>
</td></tr>
<tr><td><code id="pemq_+3A_q">q</code>, <code id="pemq_+3A_asy">asy</code></td>
<td>

<p>vector of asymmetries / probabilities.
</p>
</td></tr>
<tr><td><code id="pemq_+3A_n">n</code></td>
<td>

<p>number of observations. If length(n) &gt; 1, the length is taken to be the number required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This distribution has the cumulative distribution function:
<code class="reqn"> F(x;ncp,s) = \frac{1}{2}(1 + sgn(\frac{x-ncp}{s}) \sqrt{1 - \frac{2}{2 + (\frac{x-ncp}{s})^2}}) </code>
</p>
<p>and the density:
<code class="reqn"> f(x;ncp,s) = \frac{1}{s}( \frac{1}{2 + (\frac{x-ncp}{s})^2} )^\frac{3}{2}
</code>
</p>
<p>It has infinite variance, still can be scaled by the parameter <code>s</code>.
It has mean <code>ncp</code>.
In the canonical parameters it is equal to a students-t distribution with 2 degrees of freedom.
For <code class="reqn"> s = \sqrt{2} </code> it is equal to a distribution introduced by Koenker(2005).
</p>


<h3>Value</h3>

<p><code>demq</code> gives the density, <code>pemq</code> and <code>peemq</code> give the distribution function,
<code>qemq</code> gives the quantile function, <code>eemq</code> computes the expectiles numerically and is only provided for completeness,
since the quantiles = expectiles can be determined analytically using <code>qemq</code>, 
and <code>remq</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>References</h3>

<p>Koenker R (2005)
<em> Quantile Regression </em>
Cambridge University Press, New York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enorm">enorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5,5,length=100)
plot(x,demq(x))
plot(x,pemq(x,ncp=1))

z &lt;- remq(100,s=sqrt(2))
plot(z)

y &lt;- seq(0.02,0.98,0.2)
qemq(y)
eemq(y)

pemq(x) - peemq(x)
</code></pre>

<hr>
<h2 id='plot.expectreg'>
Default expectreg plotting
</h2><span id='topic+plot.expectreg'></span>

<h3>Description</h3>

<p>Takes a <code>expectreg</code> object and plots the estimated effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'expectreg'
plot(x, rug = TRUE, xlab = NULL, ylab = NULL, ylim = NULL, 
legend = TRUE, ci = FALSE, ask = NULL, cex.main = 2, mar.min = 5, main = NULL, 
cols = "rainbow", hcl.par = list(h = c(260, 0), c = 185, l = c(30, 85)), 
ylim_spat = NULL, ylim_factor = NULL, range_warning = TRUE, add_intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.expectreg_+3A_x">x</code></td>
<td>

<p>An object of class <code>expectreg</code> as returned e.g. by the function <code><a href="#topic+expectreg.ls">expectreg.ls</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_rug">rug</code></td>
<td>

<p>Boolean. Whether nonlinear effects are displayed in a rug plot.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_xlab">xlab</code>, <code id="plot.expectreg_+3A_ylab">ylab</code>, <code id="plot.expectreg_+3A_ylim">ylim</code></td>
<td>

<p>Graphic parameters. <code>xlab</code> should match the number of covariates.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_legend">legend</code></td>
<td>

<p>Boolean. Decides whether a legend is added to the plots.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_ci">ci</code></td>
<td>

<p>Boolean. Whether confidence intervals and significances should be plotted.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_ask">ask</code></td>
<td>

<p>Should always be asked before a new plot is printed.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_cex.main">cex.main</code></td>
<td>

<p>Font size of main
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_mar.min">mar.min</code></td>
<td>

<p>Minimal margins, important when markov fields are plotted
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_main">main</code></td>
<td>

<p>Vector of main per plot
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_cols">cols</code></td>
<td>

<p>Colours sheme of plots. Default is rainbow. Alternatively <code>hcl</code> can be used.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_hcl.par">hcl.par</code></td>
<td>

<p>Parameters to specify the hcl coulour sheme.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_ylim_spat">ylim_spat</code></td>
<td>

<p>y_limits of the markov random field and all other spatial methods.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_ylim_factor">ylim_factor</code></td>
<td>

<p>y_limits of the plots of factor covariates.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_range_warning">range_warning</code></td>
<td>

<p>Should a warning be printed in the graphic if the range of the markov random field/factor plot is larger than the specified limits in <code>markov_ylim</code>/<code>factors_ylim</code>.
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_add_intercept">add_intercept</code></td>
<td>

<p>Should the intercept be added to the plots of splines?
</p>
</td></tr>
<tr><td><code id="plot.expectreg_+3A_...">...</code></td>
<td>

<p>Graphical parameters passesd on to the standard plot function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> function gives a visual representation of the fitted expectiles
separately for each covariate.
</p>


<h3>Value</h3>

<p>No return value, only graphical output.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Elmar Spiegel <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>


<h3>References</h3>

<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computational Statistics and Data Analysis, 53:4168-4177
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectreg.ls">expectreg.ls</a></code>, <code><a href="#topic+expectreg.boost">expectreg.boost</a></code>, <code><a href="#topic+expectreg.qp">expectreg.qp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dutchboys)

expreg &lt;- expectreg.ls(hgt ~ rb(age,"pspline"),data=dutchboys,smooth="f",
                       expectiles=c(0.05,0.2,0.8,0.95))
plot(expreg)
</code></pre>

<hr>
<h2 id='quant.bundle'>
Restricted expectile regression of additive models
</h2><span id='topic+quant.bundle'></span>

<h3>Description</h3>

<p>A location-scale model to fit generalized additive models with least asymmetrically weighted squares
to obtain the graphs of different expectiles or quantiles
for continuous, spatial or random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant.bundle(formula, data = NULL, smooth = c("schall", "acv", "fixed"), 
             lambda = 1, quantiles = NA, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quant.bundle_+3A_formula">formula</code></td>
<td>

<p>An R formula object consisting of the response variable, '~'
and the sum of all effects that should be taken into consideration.
Each effect has to be given through the function <code><a href="#topic+rb">rb</a></code>.
</p>
</td></tr>
<tr><td><code id="quant.bundle_+3A_data">data</code></td>
<td>

<p>Optional data frame containing the variables used in the model, if the data is not explicitely given in the
formula.  
</p>
</td></tr>
<tr><td><code id="quant.bundle_+3A_smooth">smooth</code></td>
<td>

<p>There are different smoothing algorithms that should prevent overfitting.
The 'schall' algorithm iterates the smoothing penalty <code>lambda</code> until it converges,
the asymmetric cross-validation 'acv' minimizes a score-function using <code><a href="stats.html#topic+nlm">nlm</a></code>
or the function uses a fixed penalty.
</p>
</td></tr>
<tr><td><code id="quant.bundle_+3A_lambda">lambda</code></td>
<td>

<p>The fixed penalty can be adjusted. Also serves as starting value for
the smoothing algorithms.
</p>
</td></tr>
<tr><td><code id="quant.bundle_+3A_quantiles">quantiles</code></td>
<td>

<p>In default setting, the quantiles (0.01,0.02,0.05,0.1,0.2,0.5,0.8,0.9,0.95,0.98,0.99) are calculated.
You may specify your own set of expectiles in a vector. 
</p>
</td></tr>
<tr><td><code id="quant.bundle_+3A_simple">simple</code></td>
<td>

<p>A binary variable depicting if the restricted expectiles (<code>TRUE</code>) or the bundle is used as basis for the quantile bundle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In least asymmetrically weighted squares (LAWS) each expectile is fitted by minimizing:
</p>
<p><code class="reqn"> S = \sum_{i=1}^{n}{ w_i(p)(y_i - \mu_i(p))^2} </code>
</p>
<p>with
</p>
<p><code class="reqn"> w_i(p) = p 1_{(y_i &gt; \mu_i(p))} + (1-p) 1_{(y_i &lt; \mu_i(p))} </code>.
</p>
<p>The restricted version fits the 0.5 expectile at first and then the residuals.
Afterwards the other expectiles are fitted as deviation by a factor of the residuals from the mean expectile.
This algorithm is based on He(1997). The advantage is that expectile crossing cannot occur,
the disadvantage is a suboptimal fit in certain heteroscedastic settings.
Also, since the number of fits is significantly decreased, the restricted version is much faster.
</p>
<p>The expectile bundle has a resemblence to the restricted regression. At first, a trend curve is fitted
and then an iteration is performed between fitting the residuals and calculating the deviation factors
for all the expectiles until the results are stable. Therefore this function shares the (dis)advantages
of the restricted.
</p>
<p>The quantile bundle uses either the restricted expectiles or the bundle to estimate a dense set of expectiles. Next 
this set is used to estimate a density with the function <code><a href="#topic+cdf.bundle">cdf.bundle</a></code>. From this density quantiles 
are determined and inserted to the calculated bundle model. This results in an estimated location-scale model for 
quantile regression. 
</p>


<h3>Value</h3>

<p> An object of class 'expectreg', which is basically a list consisting of: 
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The final smoothing parameters for all expectiles and for all effects in a list.
For the restricted and the bundle regression there are only the mean and the residual lambda.</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>
<p>The intercept for each expectile.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> A matrix of all the coefficients, for each base element
a row and for each expectile a column. </p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p> The fitted values for each observation and all expectiles,
separately in a list for each effect in the model,
sorted in order of ascending covariate values. </p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p> Vector of the response variable. </p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p> List with the values of the covariates. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> The formula object that was given to the function. </p>
</td></tr>
<tr><td><code>asymmetries</code></td>
<td>
<p> Vector of fitted expectile asymmetries as given by argument <code>expectiles</code>. </p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p> List of characters giving the types of covariates. </p>
</td></tr>
<tr><td><code>helper</code></td>
<td>
<p> List of additional parameters like neighbourhood structure for spatial effects or 'phi' for kriging. </p>
</td></tr>
<tr><td><code>trend.coef</code></td>
<td>
<p> Coefficients of the trend function. </p>
</td></tr>
<tr><td><code>residual.coef</code></td>
<td>
<p> Vector of the coefficients the residual curve was fitted with. </p>
</td></tr>
<tr><td><code>asymmetry</code></td>
<td>
<p> Vector of the asymmetry factors for all expectiles. </p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> Complete design matrix. </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values <code class="reqn"> \hat{y} </code>. </p>
</td></tr>
</table>
<p><code><a href="#topic+plot.expectreg">plot</a></code>, <code><a href="#topic+predict.expectreg">predict</a></code>, <code><a href="#topic+resid.expectreg">resid</a></code>, <code><a href="#topic+fitted.expectreg">fitted</a></code> and <code><a href="#topic+effects.expectreg">effects</a></code>
methods are available for class 'expectreg'.
</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>
<p>Sabine Schnabel <br />
Wageningen University and Research Centre <br />
<a href="https://www.wur.nl">https://www.wur.nl</a>
</p>
<p>Paul Eilers <br />
Erasmus Medical Center Rotterdam <br />
<a href="https://www.erasmusmc.nl">https://www.erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Schnabel S and Eilers P (2009)
<em> Optimal expectile smoothing </em>
Computational Statistics and Data Analysis, 53:4168-4177
</p>
<p>He X (1997)
<em> Quantile Curves without Crossing </em>
The American Statistician, 51(2):186-192
</p>
<p>Schnabel S and Eilers P (2011)
<em> A location scale model for non-crossing expectile curves</em>
(working paper)
</p>
<p>Sobotka F and Kneib T (2010)
<em> Geoadditive Expectile Regression </em>
Computational Statistics and Data Analysis,
doi: 10.1016/j.csda.2010.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rb">rb</a></code>, <code><a href="#topic+expectreg.boost">expectreg.boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qb = quant.bundle(dist ~ rb(speed),data=cars,smooth="f",lambda=5)
plot(qb)

qbund &lt;- quant.bundle(dist ~ rb(speed),data=cars,smooth="f",lambda=50000,simple=FALSE)
</code></pre>

<hr>
<h2 id='rb'>
Creates base for a regression based on covariates
</h2><span id='topic+rb'></span><span id='topic+mono'></span>

<h3>Description</h3>

<p>Based on given observations a matrix is created that creates a basis e.g.
of splines or a markov random field that is evaluated for each observation.
Additionally a penalty matrix is generated. Shape constraint p-spline bases can
also be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rb(x, type = c("pspline", "2dspline", "markov", "krig", "random", 
"ridge", "special", "parametric", "penalizedpart_pspline"), B_size = 20, 
B = NA, P = NA, bnd = NA, center = TRUE, by = NA, ...)

mono(x, constraint = c("increase", "decrease", "convex", "concave", "flatend"), 
by = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rb_+3A_x">x</code></td>
<td>

<p>Data vector, matrix or data frame. In case of '2dspline', or 'krig' <code>type</code>
number of variables of <code>x</code> has to be 2. More dimensions are allowed in 'ridge' and 'special' <code>type</code>.
'markov' and 'random' <code>type</code> require a vector of a factor.
</p>
</td></tr>
<tr><td><code id="rb_+3A_type">type</code></td>
<td>

<p>Character string defining the type of base that is generated for the given variable(s) <code>x</code>.
Further description of the possible options is given below in <code>details</code>.
</p>
</td></tr>
<tr><td><code id="rb_+3A_b_size">B_size</code></td>
<td>

<p>Number of basis functions of psplines. Default is 20.
</p>
</td></tr>
<tr><td><code id="rb_+3A_b">B</code></td>
<td>

<p>For the 'special' <code>type</code> the base <code>B</code> and penalization matrix <code>P</code>
are entered manually. The data frame or matrix needs as many rows as observations in <code>x</code>
and as many columns as <code>P</code>.
</p>
</td></tr>
<tr><td><code id="rb_+3A_p">P</code></td>
<td>

<p>Square matrix that has to be provided in 'special' case and with 'markov' <code>type</code>
if no <code>bnd</code> is given.
</p>
</td></tr>
<tr><td><code id="rb_+3A_bnd">bnd</code></td>
<td>

<p>Object of class <code>bnd</code>, required with 'markov' type if <code>P</code> is not given.
See <code><a href="BayesX.html#topic+read.bnd">read.bnd</a></code>.
</p>
</td></tr>
<tr><td><code id="rb_+3A_center">center</code></td>
<td>

<p>Logical to state whether the basis shall be centered in order to fit additive models
with one central intercept.  
</p>
</td></tr>
<tr><td><code id="rb_+3A_by">by</code></td>
<td>

<p>An optional variable defining varying coefficients, either a factor or numeric variable.
Per default treatment coding is used. Note that the main effect needs to be specified in a separate basis.
</p>
</td></tr>
<tr><td><code id="rb_+3A_constraint">constraint</code></td>
<td>

<p>Character string defining the type of shape constraint that is imposed on the spline curve. The last option
'flatend' results in constant functions at the covariate edges.
</p>
</td></tr>
<tr><td><code id="rb_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible <code>types</code> of bases:
</p>

<dl>
<dt>pspline</dt><dd><p>Penalized splines made upon <code>B_size</code> equidistant knots
with degree 3. The penalization matrix consists 
of differences of the second order, 
see <code><a href="base.html#topic+diff">diff</a></code>.</p>
</dd>
<dt>2dspline</dt><dd><p>Tensor product of 2 p-spline bases 
with the same properties as above.</p>
</dd>
<dt>markov</dt><dd><p>Gaussian markov random field with a neighbourhood 
structure given by <code>P</code> or <code>bnd</code>. </p>
</dd>
<dt>krig</dt><dd><p>'kriging' produces a 2-dimensional base, which is calculated as exp(-r/phi)*(1+r/phi)
where <code>phi</code> is the maximum euclidean distance 
between two knots divided by a constant. </p>
</dd>
<dt>random</dt><dd><p>A 'random' effect is like the 'markov' random field 
based on a categorial variable, 
and since there is no neighbourhood structure, P = I. </p>
</dd>
<dt>ridge</dt><dd><p>In a 'ridge' regression, the base is made 
from the independent variables while the goal is 
to determine significant variables from the coefficients. 
Therefore no penalization is used (P = I). </p>
</dd>
<dt>special</dt><dd><p>In the 'special' case, <code>B</code> and <code>P</code> are user defined.</p>
</dd>
<dt>parametric</dt><dd><p>A parametric effect. </p>
</dd>
<dt>penalizedpart_pspline</dt><dd><p>Penalized splines made upon <code>B_size</code> equidistant knots with degree 3. The penalization matrix consists of differences of the second order, 
see <code><a href="base.html#topic+diff">diff</a></code>. Generally a P-spline of degree 3 with 2 order penalty can be splited in a linear trend and the deviation of the linear trend. Here only the wiggly deviation of the linear trend is kept. It is possible to combine it with the same covariate of type <code>parametric</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>List consisting of:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p> Matrix of the evaluated base, one row for each observation,
one column for each base element. </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p> Penalty square matrix, needed for the smoothing in the regression. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> The observations <code>x</code> given to the function. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> The <code>type</code> as given to the function. </p>
</td></tr>
<tr><td><code>bnd</code></td>
<td>
<p> The <code>bnd</code> as given to the function, only needed with 'markov' <code>type</code>. </p>
</td></tr>
<tr><td><code>Zspathelp</code></td>
<td>
<p> Matrix that is also only needed with 'markov' <code>type</code>
for calculation of the fitted values. </p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p> Constant only needed with 'kriging' <code>type</code>,
otherwise 'NA'. </p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p> The boolean value of the argument <code>center</code>.</p>
</td></tr>
<tr><td><code>by</code></td>
<td>
<p> The variable included in the <code>by</code> argument if available. </p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p> Name of the variable <code>x</code> given to the function. Modified by its type.</p>
</td></tr>
<tr><td><code>constraint</code></td>
<td>
<p> Part of the penalty matrix. </p>
</td></tr>
<tr><td><code>B_size</code></td>
<td>
<p> Same as input </p>
</td></tr>
<tr><td><code>P_orig</code></td>
<td>
<p> Original penalty <code>P</code> before restructuring. Used for model selection. </p>
</td></tr>
<tr><td><code>B_mean</code></td>
<td>
<p> Original mean of design matrix <code>B</code> before centering. </p>
</td></tr>
<tr><td><code>param_center</code></td>
<td>
<p> Parameters of centering the covariate. </p>
</td></tr>
<tr><td><code>nbp</code></td>
<td>
<p> Number of penalized parameters in this covariate. </p>
</td></tr>
<tr><td><code>nbunp</code></td>
<td>
<p> Number of unpenalized parameters in this covariate. </p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The <code>pspline</code> is now centered around its mean. Thus different results compared to old versions of <code>expectreg</code> occure.</p>


<h3>Author(s)</h3>

<p>Fabian Otto- Sobotka <br />
Carl von Ossietzky University Oldenburg <br />
<a href="https://uol.de">https://uol.de</a> <br />
</p>
<p>Thomas Kneib, Elmar Spiegel <br />
Georg August University Goettingen <br />
<a href="https://www.uni-goettingen.de">https://www.uni-goettingen.de</a> <br />
</p>
<p>Sabine Schnabel <br />
Wageningen University and Research Centre <br />
<a href="https://www.wur.nl">https://www.wur.nl</a>
</p>
<p>Paul Eilers <br />
Erasmus Medical Center Rotterdam <br />
<a href="https://www.erasmusmc.nl">https://www.erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Fahrmeir L and Kneib T and Lang S (2009)
<em> Regression </em>
Springer, New York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quant.bundle">quant.bundle</a></code>, <code><a href="#topic+expectreg.ls">expectreg.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)

bx &lt;- rb(x,"pspline")

y &lt;- sample(10,100,replace=TRUE)

by &lt;- rb(y,"random")
</code></pre>

<hr>
<h2 id='update.expectreg'>
Update given expectreg model
</h2><span id='topic+update.expectreg'></span>

<h3>Description</h3>

<p>Updates a given expectreg model with the specified changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'expectreg'
update(object, add_formula, data = NULL, estimate = NULL, 
smooth = NULL, lambda = NULL, expectiles = NULL, delta_garrote = NULL, ci = NULL, 
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.expectreg_+3A_object">object</code></td>
<td>

<p>of class expectreg
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_add_formula">add_formula</code></td>
<td>

<p>update for formula
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_data">data</code></td>
<td>

<p>Should other data be used
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_estimate">estimate</code></td>
<td>

<p>Change estimate
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_smooth">smooth</code></td>
<td>

<p>Change smooth
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_lambda">lambda</code></td>
<td>

<p>Change lambda
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_expectiles">expectiles</code></td>
<td>

<p>Change asymmetries
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_delta_garrote">delta_garrote</code></td>
<td>

<p>Change delta_garrote
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_ci">ci</code></td>
<td>

<p>Change ci
</p>
</td></tr>
<tr><td><code id="update.expectreg_+3A_...">...</code></td>
<td>

<p>additional parameters passed on to <code>expectreg.ls</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Re-estimates the given model, with the specified changes. If nothing is specified the characteristics of the original model are used. Except lambda here the default 1 is used as initial value.
</p>


<h3>Value</h3>

<p>object of class <code>expectreg</code>
</p>


<h3>Author(s)</h3>

<p>Elmar Spiegel <br />
Helmholtz Zentrum Muenchen <br />
<a href="https://www.helmholtz-munich.de">https://www.helmholtz-munich.de</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update">update</a></code>, <code><a href="stats.html#topic+update.formula">update.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(india)

model1&lt;-expectreg.ls(stunting~rb(cbmi),smooth="fixed",data=india,lambda=30,
                     estimate="restricted",expectiles=c(0.01,0.05,0.2,0.8,0.95,0.99))
plot(model1)

# Change formula and update model
add_formula&lt;-.~.+rb(cage)
update_model1&lt;-update(model1,add_formula)
plot(update_model1)

# Use different asymmetries and update model
update_model2&lt;-update(model1,expectiles=c(0.1,0.5,0.9))
plot(update_model2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
