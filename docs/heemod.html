<!DOCTYPE html><html><head><title>Help for package heemod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heemod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#heemod-package'><p>Markov Models for Health Economic Evaluations</p></a></li>
<li><a href='#acceptability_curve'><p>Acceptability Curve from Probabilistic Analysis</p></a></li>
<li><a href='#add_hazards'><p>Add Hazards</p></a></li>
<li><a href='#apply_af'><p>Apply an Acceleration Factor</p></a></li>
<li><a href='#apply_hr'><p>Apply a Hazard Ratio</p></a></li>
<li><a href='#apply_or'><p>Apply an Odds Ratio</p></a></li>
<li><a href='#apply_shift'><p>Apply a time shift to a survival distribution</p></a></li>
<li><a href='#as_expr_list'><p>Convert Lazy Dots to Expression List</p></a></li>
<li><a href='#calc_prob_from_surv'><p>Calculate Probability of Event</p></a></li>
<li><a href='#calc_surv_from_prob'><p>Calculate Probability of Survival</p></a></li>
<li><a href='#calibrate_model'><p>Calibrate Model Parameters</p></a></li>
<li><a href='#check_cycle_inputs'><p>Check Cycle and Time Inputs</p></a></li>
<li><a href='#check_matrix'><p>Check Markov Model Transition Matrix</p></a></li>
<li><a href='#check_names'><p>Check Names</p></a></li>
<li><a href='#check_states'><p>Check Model States for Consistency</p></a></li>
<li><a href='#check_strategy_index'><p>Check Strategy Index</p></a></li>
<li><a href='#clean_factors'><p>Convert Data Frame Factor Variables to Character</p></a></li>
<li><a href='#cluster'><p>Run <code>heemod</code> on a Cluster</p></a></li>
<li><a href='#combine_models'><p>Combine Multiple Models</p></a></li>
<li><a href='#combine_probs'><p>Combine Probabilities</p></a></li>
<li><a href='#compute_counts.eval_part_surv'><p>Compute Count of Individual in Each State per Cycle</p></a></li>
<li><a href='#compute_icer'><p>Compute ICER</p></a></li>
<li><a href='#compute_surv'><p>Evaluate Survival Distributions</p></a></li>
<li><a href='#compute_values'><p>Compute State Values per Cycle</p></a></li>
<li><a href='#construct_part_surv_tib'><p>construct a survival object from tabular specification</p></a></li>
<li><a href='#create_demographic_table'><p>Read a Demographic Table</p></a></li>
<li><a href='#create_df_from_tabular'><p>Load Data From a Folder Into an Environment</p></a></li>
<li><a href='#create_matrix_from_tabular'><p>Create a Transition Matrix From Tabular Input</p></a></li>
<li><a href='#create_model_from_tabular'><p>Create a <code>heemod</code> Model From Tabular Files Info</p></a></li>
<li><a href='#create_model_list_from_tabular'><p>Read Models Specified by Files</p></a></li>
<li><a href='#create_options_from_tabular'><p>Create Model Options From a Tabular Input</p></a></li>
<li><a href='#create_parameters_from_tabular'><p>Create a Parameter Definition From Tabular Input</p></a></li>
<li><a href='#create_states_from_tabular'><p>Create State Definitions From Tabular Input</p></a></li>
<li><a href='#define_calibration_fn'><p>Define Calibration Function</p></a></li>
<li><a href='#define_correlation'><p>Define a Correlation Structure for Probabilistic</p>
Uncertainty Analysis</a></li>
<li><a href='#define_dsa'><p>Define a Sensitivity Analysis</p></a></li>
<li><a href='#define_inflow'><p>Define Inflow for a BIA</p></a></li>
<li><a href='#define_init'><p>Define Initial Counts</p></a></li>
<li><a href='#define_parameters'><p>Define Markov Model Parameters</p></a></li>
<li><a href='#define_part_surv'><p>Define Partitioned Survival</p></a></li>
<li><a href='#define_psa'><p>Define Parameters Distribution for Probabilistic Analysis</p></a></li>
<li><a href='#define_starting_values'><p>Define Starting State Values</p></a></li>
<li><a href='#define_state'><p>Define a Markov Model State</p></a></li>
<li><a href='#define_state_list'><p>Define Markov Model State List</p></a></li>
<li><a href='#define_strategy'><p>Define a Markov Model</p></a></li>
<li><a href='#define_surv_dist'><p>Define a Survival Distribution</p></a></li>
<li><a href='#define_surv_fit'><p>Define a Fitted Survival Model</p></a></li>
<li><a href='#define_surv_spline'><p>Define a Restricted Cubic Spline Survival Distribution</p></a></li>
<li><a href='#define_surv_table'><p>Define a survival distribution based on explicit survival probabilities</p></a></li>
<li><a href='#define_transition'><p>Define Transition Matrix for Markov Model</p></a></li>
<li><a href='#discount'><p>Discount a Quantity Over Time. Should be a scalar if time is</p>
specified, a vector otherwise</a></li>
<li><a href='#discount_hack'><p>Hack to Work Around a Discounting Issue</p></a></li>
<li><a href='#dispatch_strategy'><p>Dispatch Values According to Strategy</p></a></li>
<li><a href='#dispatch_strategy_hack'><p>Hack to Automate Use of Strategy Name</p></a></li>
<li><a href='#distributions'><p>Probability Density Functions for Probabilistic</p>
Uncertainty Analysis</a></li>
<li><a href='#eval_models_from_tabular'><p>Evaluate Models From a Tabular Source</p></a></li>
<li><a href='#eval_parameters'><p>Evaluate Markov model parameters</p></a></li>
<li><a href='#eval_resample'><p>Evaluate Resampling Definition</p></a></li>
<li><a href='#eval_state_list'><p>Evaluate Markov Model States</p></a></li>
<li><a href='#eval_strategy'><p>Evaluate Strategy</p></a></li>
<li><a href='#eval_strategy_newdata'><p>Iteratively Evaluate a Markov Model With New Parameter</p>
Values</a></li>
<li><a href='#eval_surv'><p>Evaluate Survival Distributions</p></a></li>
<li><a href='#eval_transition'><p>Evaluate Markov Model Transition Matrix</p></a></li>
<li><a href='#expand_if_necessary'><p>Expand States and Transition</p></a></li>
<li><a href='#expand_state'><p>Expand Time-Dependent States into Tunnel States</p></a></li>
<li><a href='#export_savi'><p>Export PSA Results for SAVI</p></a></li>
<li><a href='#extract_params'><p>Extract Evaluated Parameters</p></a></li>
<li><a href='#extract_strata'><p>Extract Product-Limit Tables</p></a></li>
<li><a href='#extract_stratum'><p>Extract Product-Limit Table for a Stratum</p></a></li>
<li><a href='#filter_blanks'><p>Remove Blank Rows From Table</p></a></li>
<li><a href='#gather_model_info'><p>Gather Information for Running a Model From Tabular Data</p></a></li>
<li><a href='#get_counts_diff'><p>Get count matrix and difference between two cycles</p></a></li>
<li><a href='#get_counts.updated_model'><p>Get State Membership Counts</p></a></li>
<li><a href='#get_frontier'><p>Return Efficiency Frontier</p></a></li>
<li><a href='#get_mat_total'><p>Get count number</p></a></li>
<li><a href='#get_matrix_order'><p>Return Markov Model Transition Matrix Order</p></a></li>
<li><a href='#get_parameter_names'><p>Return parameters names</p></a></li>
<li><a href='#get_state_names'><p>Get State Names</p></a></li>
<li><a href='#get_state_number'><p>Return Number of State</p></a></li>
<li><a href='#get_state_value_names'><p>Return Names of State Values</p></a></li>
<li><a href='#get_transition'><p>Get Markov Model Transition Matrix</p></a></li>
<li><a href='#get_values.updated_model'><p>Get Strategy Values</p></a></li>
<li><a href='#insert'><p>Insert Elements in Vector</p></a></li>
<li><a href='#interpolate'><p>Interpolate Quosures</p></a></li>
<li><a href='#is_csv'><p>Check File Type</p></a></li>
<li><a href='#is.wholenumber'><p>Check whole Numbers</p></a></li>
<li><a href='#join'><p>Project Beyond a Survival Distribution with Another</p></a></li>
<li><a href='#list_all_same'><p>Check if All the Elements of a List Are the Same</p></a></li>
<li><a href='#load_surv_models'><p>Load a set of survival fits</p></a></li>
<li><a href='#look_up'><p>Look Up Values in a Data Frame</p></a></li>
<li><a href='#make_names'><p>Make Syntactically Valid Names</p></a></li>
<li><a href='#mix'><p>Mix Two or More Survival Distributions</p></a></li>
<li><a href='#modify'><p>Modify Object</p></a></li>
<li><a href='#parse_multi_spec'><p>Specify Inputs for Multiple Models From a Single File</p></a></li>
<li><a href='#part_survs_from_surv_inputs'><p>Convert saved fits to partitioned survival objects</p></a></li>
<li><a href='#plot.dsa'><p>Plot Sensitivity Analysis</p></a></li>
<li><a href='#plot.psa'><p>Plot Results of Probabilistic Analysis</p></a></li>
<li><a href='#plot.run_model'><p>Plot Results of a Markov Model</p></a></li>
<li><a href='#plot.surv_object'><p>Plot general survival models</p></a></li>
<li><a href='#plur'><p>Returns &quot;s&quot; if x &gt; 1</p></a></li>
<li><a href='#probability'><p>Convenience Functions to Compute Probabilities</p></a></li>
<li><a href='#project_fn'><p>Project Beyond a Survival Distribution with Another</p>
(pairwise)</a></li>
<li><a href='#read_file'><p>Read the accepted file formats for tabular input</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reindent_transition'><p>Reindent Transition Matrix</p></a></li>
<li><a href='#resample_surv'><p>Resample survival distribution</p></a></li>
<li><a href='#rescale_discount_rate'><p>Rescale Discount Rate</p></a></li>
<li><a href='#run_bcea'><p>Use the BCEA package</p></a></li>
<li><a href='#run_dsa'><p>Run Sensitivity Analysis</p></a></li>
<li><a href='#run_model'><p>Run Markov Model</p></a></li>
<li><a href='#run_model_tabular'><p>Run Analyses From Files</p></a></li>
<li><a href='#run_psa'><p>Run Probabilistic Uncertainty Analysis</p></a></li>
<li><a href='#safe_conversion'><p>Safely Convert From Characters to Numbers</p></a></li>
<li><a href='#save_outputs'><p>Save Model Outputs</p></a></li>
<li><a href='#scale.combined_model'><p>Normalize Cost and Effect</p></a></li>
<li><a href='#set_covariates'><p>Set Covariates of a Survival Distribution</p></a></li>
<li><a href='#summary.run_model'><p>Summarise Markov Model Results</p></a></li>
<li><a href='#summary.surv_shift'><p>Summarize surv_shift objects</p></a></li>
<li><a href='#update_model'><p>Run Model on New Data</p></a></li>
<li><a href='#who_mortality'><p>Use WHO Mortality Rate</p></a></li>
<li><a href='#wtd_summary'><p>Weighted Summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Markov Models for Health Economic Evaluations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the modelling and reporting features described 
    in reference textbook and guidelines (Briggs, Andrew, et al. Decision 
    Modelling for Health Economic Evaluation. Oxford Univ. Press, 2011;
    Siebert, U. et al. State-Transition Modeling. Medical Decision Making 
    32, 690-700 (2012).): deterministic and probabilistic sensitivity analysis, 
    heterogeneity analysis, time dependency on state-time and model-time 
    (semi-Markov and non-homogeneous Markov models), etc.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), ggplot2 (&ge; 3.4.0), memoise (&ge; 2.0.0),
mvnfast (&ge; 0.2.5), tibble (&ge; 3.2.0), rlang (&ge; 1.1.0), purrr
(&ge; 1.0.0), glue (&ge; 1.6.0), lifecycle (&ge; 1.0.0), vctrs (&ge;
0.6.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BCEA, diagram, flexsurv, knitr, logitnorm, lpSolve, mgcv,
optimx, parallel, readxl, rgho (&ge; 3.0.0), rmarkdown, stringr,
survival, testthat (&ge; 3.0.0), triangle, magrittr, cli</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aphp/heemod/issues">https://github.com/aphp/heemod/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://aphp.github.io/heemod/">https://aphp.github.io/heemod/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 11:55:27 UTC; kevin</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Zarca [aut, cre],
  Antoine Filipovic-Pierucci [aut],
  Matthew Wiener [ctb],
  Zdenek Kabat [ctb],
  Vojtech Filipec [ctb],
  Jordan Amdahl [ctb],
  Yonatan Carranza Alarcon [ctb],
  Vince Daniels [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Zarca &lt;kevin.zarca@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='heemod-package'>Markov Models for Health Economic Evaluations</h2><span id='topic+heemod'></span><span id='topic+heemod-package'></span>

<h3>Description</h3>

<p>An implementation of the modelling and
reporting features described in reference
textbooks and guidelines: deterministic and
probabilistic sensitivity analysis,
heterogeneity analysis, time dependency
on state-time and model-time (semi-Markov
and non-homogeneous Markov models), etc.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kevin Zarca <a href="mailto:kevin.zarca@gmail.com">kevin.zarca@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Antoine Filipovic-Pierucci
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Matthew Wiener [contributor]
</p>
</li>
<li><p> Zdenek Kabat [contributor]
</p>
</li>
<li><p> Vojtech Filipec [contributor]
</p>
</li>
<li><p> Jordan Amdahl [contributor]
</p>
</li>
<li><p> Yonatan Carranza Alarcon [contributor]
</p>
</li>
<li><p> Vince Daniels [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://aphp.github.io/heemod/">https://aphp.github.io/heemod/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aphp/heemod/issues">https://github.com/aphp/heemod/issues</a>
</p>
</li></ul>


<hr>
<h2 id='acceptability_curve'>Acceptability Curve from Probabilistic Analysis</h2><span id='topic+acceptability_curve'></span>

<h3>Description</h3>

<p>Acceptability Curve from Probabilistic Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptability_curve(x, wtp_thresholds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptability_curve_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_psa">run_psa()</a></code>.</p>
</td></tr>
<tr><td><code id="acceptability_curve_+3A_wtp_thresholds">wtp_thresholds</code></td>
<td>
<p>willingness to pay thresholds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>.ceac</code> (the
cost-effectiveness acceptability threshold),
<code>.model</code> (treatments or models), <code>.n</code> (the
number of cases in which the treatment was most
cost-effective), and <code>.p</code> (the proportion of cases
where the treatment was most effective).
</p>

<hr>
<h2 id='add_hazards'>Add Hazards</h2><span id='topic+add_hazards'></span><span id='topic+add_hazards_'></span>

<h3>Description</h3>

<p>Get a survival distribution reflecting the independent
hazards from two or more survival distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_hazards(...)

add_hazards_(dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_hazards_+3A_...">...</code></td>
<td>
<p>Survival distributions to be used in the
projection.</p>
</td></tr>
<tr><td><code id="add_hazards_+3A_dots">dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_add_haz</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .125)
dist2 &lt;- define_surv_dist(distribution = "weibull", shape = 1.2, scale = 50)
combined_dist &lt;- add_hazards(dist1, dist2)

</code></pre>

<hr>
<h2 id='apply_af'>Apply an Acceleration Factor</h2><span id='topic+apply_af'></span>

<h3>Description</h3>

<p>Proportionally increase or reduce the time to event of a
survival distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_af(dist, af, log_af = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_af_+3A_dist">dist</code></td>
<td>
<p>A survival distribution.</p>
</td></tr>
<tr><td><code id="apply_af_+3A_af">af</code></td>
<td>
<p>An acceleration factor to be applied.</p>
</td></tr>
<tr><td><code id="apply_af_+3A_log_af">log_af</code></td>
<td>
<p>If <code>TRUE</code>, the acceleration factor is
exponentiated before being applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_aft</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .25)
aft_dist &lt;- apply_af(dist1, 1.5)
</code></pre>

<hr>
<h2 id='apply_hr'>Apply a Hazard Ratio</h2><span id='topic+apply_hr'></span>

<h3>Description</h3>

<p>Proportional reduce or increase the hazard rate of a
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_hr(dist, hr, log_hr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_hr_+3A_dist">dist</code></td>
<td>
<p>A survival distribution.</p>
</td></tr>
<tr><td><code id="apply_hr_+3A_hr">hr</code></td>
<td>
<p>A hazard ratio to be applied.</p>
</td></tr>
<tr><td><code id="apply_hr_+3A_log_hr">log_hr</code></td>
<td>
<p>If <code>TRUE</code>, the hazard ratio is exponentiated
before being applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_ph</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .25)
ph_dist &lt;- apply_hr(dist1, 0.5)

</code></pre>

<hr>
<h2 id='apply_or'>Apply an Odds Ratio</h2><span id='topic+apply_or'></span>

<h3>Description</h3>

<p>Proportionally increase or reduce the odds of an event of
a survival distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_or(dist, or, log_or = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_or_+3A_dist">dist</code></td>
<td>
<p>A survival distribution.</p>
</td></tr>
<tr><td><code id="apply_or_+3A_or">or</code></td>
<td>
<p>An odds ratio to be applied.</p>
</td></tr>
<tr><td><code id="apply_or_+3A_log_or">log_or</code></td>
<td>
<p>If <code>TRUE</code>, the odds ratio is exponentiated
before being applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_po</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .25)
po_dist &lt;- apply_or(dist1, 1.2)
</code></pre>

<hr>
<h2 id='apply_shift'>Apply a time shift to a survival distribution</h2><span id='topic+apply_shift'></span>

<h3>Description</h3>

<p>Apply a time shift to a survival distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_shift(dist, shift)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_shift_+3A_dist">dist</code></td>
<td>
<p>A survival distribution.</p>
</td></tr>
<tr><td><code id="apply_shift_+3A_shift">shift</code></td>
<td>
<p>A time shift to be applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A positive shift moves the fit backwards in time.   That is,
a shift of 4 will cause time 5 to be evaluated as time 1, and so on.
If <code>shift == 0</code>, <code>dist</code> is returned unchanged.
</p>


<h3>Value</h3>

<p>A <code>surv_shift</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "gamma", rate = 0.25, shape = 3)
shift_dist &lt;- apply_shift(dist1, 4)
compute_surv(dist1, 1:10)
compute_surv(shift_dist, 1:10)
</code></pre>

<hr>
<h2 id='as_expr_list'>Convert Lazy Dots to Expression List</h2><span id='topic+as_expr_list'></span>

<h3>Description</h3>

<p>This function is used by <code><a href="#topic+interpolate">interpolate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_expr_list(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_expr_list_+3A_.dots">.dots</code></td>
<td>
<p>A quosures object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of expression.
</p>

<hr>
<h2 id='calc_prob_from_surv'>Calculate Probability of Event</h2><span id='topic+calc_prob_from_surv'></span>

<h3>Description</h3>

<p>Calculates the per-cycle event probabilities from a
vector of survival probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prob_from_surv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_prob_from_surv_+3A_x">x</code></td>
<td>
<p>A vector of conditional event probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The per-cycle event probabilities.
</p>

<hr>
<h2 id='calc_surv_from_prob'>Calculate Probability of Survival</h2><span id='topic+calc_surv_from_prob'></span>

<h3>Description</h3>

<p>Calculates the probability of survival from a vector of
event probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_surv_from_prob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_surv_from_prob_+3A_x">x</code></td>
<td>
<p>A vector of per-cycle event probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The survival probabilities.
</p>

<hr>
<h2 id='calibrate_model'>Calibrate Model Parameters</h2><span id='topic+calibrate_model'></span>

<h3>Description</h3>

<p>Search for the appropriate value of unknown parameters to
obtain specific model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_model(
  x,
  parameter_names,
  fn_values,
  target_values,
  initial_values = NULL,
  method = c("Nelder-Mead", "BFGS", "L-BFGS-B"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_model_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code> or <code><a href="stats.html#topic+update">update()</a></code>.</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_parameter_names">parameter_names</code></td>
<td>
<p>Names of the parameters to
calibrate.</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_fn_values">fn_values</code></td>
<td>
<p>Function applied to the model that
returns the values of interest as a numeric vector.</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_target_values">target_values</code></td>
<td>
<p>Values to match, same length as the
output from <code>fn_values</code>.</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_initial_values">initial_values</code></td>
<td>
<p>Optional starting values. See
details.</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_method">method</code></td>
<td>
<p>Optimisation method (<code>Nelder-Mead</code>,
<code>BFGS</code>, or <code>L-BFGS-B</code>).</p>
</td></tr>
<tr><td><code id="calibrate_model_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to
<code><a href="optimx.html#topic+optimx">optimx::optimx()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters not being optimized are unchanged from the
values in the model run. If <code>initial_values</code> is <code>NULL</code>,
the initial parameter values will also be taken from the
model run.
</p>
<p><code>initial_values</code> can be a vector or a table. In the
second case each row corresponds to a set of initial
parameter values: the calibration will be run once per
set.
</p>
<p>Passing in multiple initial values allows (among other
things) the user to check whether the calibration gets
the same results from different starting points.
</p>
<p>Multi-dimensional problems are optimized with
<code><a href="optimx.html#topic+optimx">optimx::optimx()</a></code>, 1-dimensional problems with
<code><a href="stats.html#topic+optimize">stats::optimise()</a></code> (except when a <code>method</code> is given).
<code>convcode</code> is always <code>NA</code> with <code><a href="stats.html#topic+optimize">stats::optimise()</a></code>.
</p>
<p>Running <code><a href="#topic+calibrate_model">calibrate_model()</a></code> does not change the model
parameters; the user must create a new model and run it
if desired.
</p>
<p>See also <code>vignette("k-calibration")</code>.
</p>


<h3>Value</h3>

<p>A data frame in which each row has the calibrated
values of parameters given in <code>parameter_names</code>, for
the corresponding row of <code>initial_values</code>, along with
the convergence code for each run.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
param &lt;- define_parameters(p = 0.8)

mat &lt;- define_transition(
  p, C,
  0, 1
)
mod &lt;- define_strategy(
  transition = mat,
  A = define_state(cost=10, effect = 0.5), 
  B = define_state(cost = 5, effect = 0.8)
)

res_mod &lt;- run_model(
  mod = mod,
  parameters = param,
  init = c(1000L, 0L),
  cycles = 10,
  cost = cost,
  effect = effect,
  method = "end"
)

f &lt;- function(x) {
  dplyr::filter(
    get_counts(x),
    state_names == "A" &amp; model_time == 10
  )$count
}
f(res_mod)

#'\dontrun{
#'calibrate_model(
#'  res_mod,
#'  parameter_names = "p",
#'  fn_values = f,
#'  target_values = 130,
#'  initial_values = data.frame(p = c(0.5, 0.9)),
#'  lower = 0, upper = 1
#')
#'}
</code></pre>

<hr>
<h2 id='check_cycle_inputs'>Check Cycle and Time Inputs</h2><span id='topic+check_cycle_inputs'></span>

<h3>Description</h3>

<p>Performs checks on the cycle and time inputs to
<code><a href="#topic+eval_surv">eval_surv()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cycle_inputs(cycle, cycle_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cycle_inputs_+3A_cycle">cycle</code></td>
<td>
<p>The <code>model_time</code> or <code>state_time</code> for which
to predict.</p>
</td></tr>
<tr><td><code id="check_cycle_inputs_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The length of a Markov cycle in
absolute time units.</p>
</td></tr>
</table>

<hr>
<h2 id='check_matrix'>Check Markov Model Transition Matrix</h2><span id='topic+check_matrix'></span>

<h3>Description</h3>

<p>Check whether a matrix fulfills the conditions to be a
transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_matrix_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="#topic+eval_transition">eval_transition()</a></code>
and should not be used directly.
</p>
<p>Checks whether all rows sum to 1 and all probabilities
are between 0 and 1.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='check_names'>Check Names</h2><span id='topic+check_names'></span>

<h3>Description</h3>

<p>Throws an error if any of the names are reserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_names_+3A_x">x</code></td>
<td>
<p>A character vector of names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reserved names are <code>model_time</code> and anything
starting with <code>.</code>.
</p>


<h3>Value</h3>

<p>Nothing, just throws an error if a reserved name
is encountered.
</p>

<hr>
<h2 id='check_states'>Check Model States for Consistency</h2><span id='topic+check_states'></span>

<h3>Description</h3>

<p>For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_states(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_states_+3A_x">x</code></td>
<td>
<p>An object of class <code>uneval_states</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All states should have the same value names.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='check_strategy_index'>Check Strategy Index</h2><span id='topic+check_strategy_index'></span>

<h3>Description</h3>

<p>Check Strategy Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_strategy_index(x, i, allow_multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_strategy_index_+3A_x">x</code></td>
<td>
<p>A result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="check_strategy_index_+3A_i">i</code></td>
<td>
<p>A strategy index, character or numeric.</p>
</td></tr>
<tr><td><code id="check_strategy_index_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>logical. Allow multiple strategy
index?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Strategy names.
</p>

<hr>
<h2 id='clean_factors'>Convert Data Frame Factor Variables to Character</h2><span id='topic+clean_factors'></span>

<h3>Description</h3>

<p>Convert Data Frame Factor Variables to Character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_factors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_factors_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='cluster'>Run <code>heemod</code> on a Cluster</h2><span id='topic+cluster'></span><span id='topic+use_cluster'></span><span id='topic+status_cluster'></span><span id='topic+close_cluster'></span>

<h3>Description</h3>

<p>These functions create or delete a cluster for
<code>heemod</code>. When the cluster is created it is
automagically used by <code>heemod</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_cluster(num_cores, cluster = NULL, close = TRUE)

status_cluster(verbose = TRUE)

close_cluster()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_num_cores">num_cores</code></td>
<td>
<p>Number of core.</p>
</td></tr>
<tr><td><code id="cluster_+3A_cluster">cluster</code></td>
<td>
<p>A custom cluster. See details.</p>
</td></tr>
<tr><td><code id="cluster_+3A_close">close</code></td>
<td>
<p>Close existing cluster before defining a new
one?</p>
</td></tr>
<tr><td><code id="cluster_+3A_verbose">verbose</code></td>
<td>
<p>Print cluster info.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual workflow is to create the cluster with
<code>use_cluster</code>, then run functions such as
<code><a href="#topic+run_psa">run_psa()</a></code> that make use of the cluster. To
stop using the cluster run <code><a href="#topic+close_cluster">close_cluster()</a></code>.
</p>
<p>The cluster status is given by <code>status_cluster</code>.
</p>
<p>A custom cluster can be passed to <code>use_cluster</code> with
the <code>cluster</code> argument. This custom cluster needs to
work with <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h3>Value</h3>

<p><code>use_cluster</code> and <code>close_cluster</code>
return <code>TRUE</code> invisibly in case of success.
<code>status_cluster</code> returns <code>TRUE</code> if a cluster
is defined, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='combine_models'>Combine Multiple Models</h2><span id='topic+combine_models'></span>

<h3>Description</h3>

<p>Given a set of models run with different parameters,
return aggregated results to estimate population-level
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_models(newmodels, weights, oldmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_models_+3A_newmodels">newmodels</code></td>
<td>
<p>A list of models run over a set of
multiple parameters.</p>
</td></tr>
<tr><td><code id="combine_models_+3A_weights">weights</code></td>
<td>
<p>A vector of weights, same length as the
number of parameter sets.</p>
</td></tr>
<tr><td><code id="combine_models_+3A_oldmodel">oldmodel</code></td>
<td>
<p>The original model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>combined_models</code> object, mostly similar
to a result from <code><a href="#topic+run_model">run_model()</a></code>. <code>plot</code>
and <code>summary</code> methods are available.
</p>

<hr>
<h2 id='combine_probs'>Combine Probabilities</h2><span id='topic+combine_probs'></span>

<h3>Description</h3>

<p>Given several independent probabilities of an event,
return the final probability of the event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_probs(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_probs_+3A_...">...</code></td>
<td>
<p>Probability vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only correct if the probabilities are
independent!
</p>


<h3>Value</h3>

<p>A probability vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(p1 &lt;- runif(5))
(p2 &lt;- runif(5))
combine_probs(p1, p2)

</code></pre>

<hr>
<h2 id='compute_counts.eval_part_surv'>Compute Count of Individual in Each State per Cycle</h2><span id='topic+compute_counts.eval_part_surv'></span><span id='topic+compute_counts'></span><span id='topic+compute_counts.eval_matrix'></span>

<h3>Description</h3>

<p>Given an initial number of individual and an evaluated
transition matrix, returns the number of individual per
state per cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eval_part_surv'
compute_counts(x, init, inflow, ...)

compute_counts(x, ...)

## S3 method for class 'eval_matrix'
compute_counts(x, init, inflow, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_counts.eval_part_surv_+3A_x">x</code></td>
<td>
<p>An <code>eval_matrix</code> or
<code>eval_part_surv</code> object.</p>
</td></tr>
<tr><td><code id="compute_counts.eval_part_surv_+3A_init">init</code></td>
<td>
<p>numeric vector, same length as number of
model states. Number of individuals in each model state
at the beginning.</p>
</td></tr>
<tr><td><code id="compute_counts.eval_part_surv_+3A_inflow">inflow</code></td>
<td>
<p>numeric vector, similar to <code>init</code>.
Number of new individuals in each state per cycle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the <code>method</code> argument to specify if transitions
are supposed to happen at the beginning or the end of
each cycle. Alternatively linear interpolation between
cycles can be performed.
</p>


<h3>Value</h3>

<p>A <code>cycle_counts</code> object.
</p>

<hr>
<h2 id='compute_icer'>Compute ICER</h2><span id='topic+compute_icer'></span>

<h3>Description</h3>

<p>Compute ICER for Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_icer(x, strategy_order = order(x$.effect), threshold = 30000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_icer_+3A_x">x</code></td>
<td>
<p>Result of <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="compute_icer_+3A_strategy_order">strategy_order</code></td>
<td>
<p>Order in which the strategies
should be sorted. Default: by increasing effect.</p>
</td></tr>
<tr><td><code id="compute_icer_+3A_threshold">threshold</code></td>
<td>
<p>ICER threshold for net monetary benefit
computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models are ordered by effectiveness and ICER are computed
sequentially.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with computed ICER.
</p>

<hr>
<h2 id='compute_surv'>Evaluate Survival Distributions</h2><span id='topic+compute_surv'></span>

<h3>Description</h3>

<p>Generate either survival probabilities or conditional
probabilities of event for each model cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_surv(x, time, cycle_length = 1, type = c("prob", "survival"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_surv_+3A_x">x</code></td>
<td>
<p>A survival object</p>
</td></tr>
<tr><td><code id="compute_surv_+3A_time">time</code></td>
<td>
<p>The <code>model_time</code> or <code>state_time</code> for which
to predict.</p>
</td></tr>
<tr><td><code id="compute_surv_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The value of a Markov cycle in
absolute time units.</p>
</td></tr>
<tr><td><code id="compute_surv_+3A_type">type</code></td>
<td>
<p>Either <code>prob</code>, for transition probabilities,
or <code>surv</code>, for survival.</p>
</td></tr>
<tr><td><code id="compute_surv_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of <code>compute_surv()</code> are memoised for
<code>options("heemod.memotime")</code> (default: 1 hour) to
increase resampling performance.
</p>


<h3>Value</h3>

<p>Returns either the survival probabilities or
conditional probabilities of event for each cycle.
</p>

<hr>
<h2 id='compute_values'>Compute State Values per Cycle</h2><span id='topic+compute_values'></span>

<h3>Description</h3>

<p>Given states and counts, computes the total state values
per cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_values(states, count_list, strategy_starting_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_values_+3A_states">states</code></td>
<td>
<p>An object of class <code>eval_state_list</code>.</p>
</td></tr>
<tr><td><code id="compute_values_+3A_count_list">count_list</code></td>
<td>
<p>An object of class <code>cycle_counts</code>.</p>
</td></tr>
<tr><td><code id="compute_values_+3A_strategy_starting_values">strategy_starting_values</code></td>
<td>
<p>An object of class <code>uneval_starting_values</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of state values, one column per
state value and one row per cycle.
</p>

<hr>
<h2 id='construct_part_surv_tib'>construct a survival object from tabular specification</h2><span id='topic+construct_part_surv_tib'></span>

<h3>Description</h3>

<p>construct a survival object from tabular specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_part_surv_tib(surv_def, ref, state_names, env = new.env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_part_surv_tib_+3A_surv_def">surv_def</code></td>
<td>
<p>a data frame with the specification.  See details.</p>
</td></tr>
<tr><td><code id="construct_part_surv_tib_+3A_ref">ref</code></td>
<td>
<p>data frame with information about the fits.</p>
</td></tr>
<tr><td><code id="construct_part_surv_tib_+3A_state_names">state_names</code></td>
<td>
<p>names of the model states</p>
</td></tr>
<tr><td><code id="construct_part_surv_tib_+3A_env">env</code></td>
<td>
<p>an environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be used only from within
tabular_input.R.   It won't work well otherwise, in that
the environment is unlikely to have what you need.
</p>
<p>columns of surv_def:  .strategy, .type, .subset, dist, until
where dist can be either the name of a distribution
along with parameters, or a reference to a fit
for example:  fit('exp') or exp(rate = 0.5)
</p>


<h3>Value</h3>

<p>a list with one element for each strategy.   Each element
is in turn a <code>part_surv</code> object, a list with two elements,
pfs and os.   And those
elements are survival objects of various kinds, with the
commonality that they can be used in <code><a href="#topic+compute_surv">compute_surv()</a></code>.
</p>

<hr>
<h2 id='create_demographic_table'>Read a Demographic Table</h2><span id='topic+create_demographic_table'></span>

<h3>Description</h3>

<p>This function mostly checks whether the parameters are
correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_demographic_table(newdata, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_demographic_table_+3A_newdata">newdata</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="create_demographic_table_+3A_params">params</code></td>
<td>
<p>Parameters of a model, to check that all
the columns in the demographic table (other than the
weight column) are in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An optional <code>.weights</code> column can exist in the file.
</p>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='create_df_from_tabular'>Load Data From a Folder Into an Environment</h2><span id='topic+create_df_from_tabular'></span>

<h3>Description</h3>

<p>Reads files containing data frames (in tabular format)
from a directory, and loads them in an environment to be
available during an analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_df_from_tabular(df_dir, df_envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_df_from_tabular_+3A_df_dir">df_dir</code></td>
<td>
<p>A directory containing the files.</p>
</td></tr>
<tr><td><code id="create_df_from_tabular_+3A_df_envir">df_envir</code></td>
<td>
<p>An environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files must be in .csv, .xls, or .xlsx format. A file
my_df.csv (or my_df.xls, or my_df.xlsx) will be loaded as
a data frame my_df.
</p>


<h3>Value</h3>

<p>The environment with the data frames.
</p>

<hr>
<h2 id='create_matrix_from_tabular'>Create a Transition Matrix From Tabular Input</h2><span id='topic+create_matrix_from_tabular'></span>

<h3>Description</h3>

<p>Transforms tabular input defining a transition matrix
into an <code>heemod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_matrix_from_tabular(trans_probs, state_names, df_env = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_matrix_from_tabular_+3A_trans_probs">trans_probs</code></td>
<td>
<p>Result for one model of
<code><a href="#topic+parse_multi_spec">parse_multi_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="create_matrix_from_tabular_+3A_state_names">state_names</code></td>
<td>
<p>The names of the states used in the
transition matrix.</p>
</td></tr>
<tr><td><code id="create_matrix_from_tabular_+3A_df_env">df_env</code></td>
<td>
<p>An environment containing external data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame <code>trans_probs</code> should have columns
<code>from</code>, <code>to</code>, and <code>prob</code>, where
<code>prob</code> is the probability of a transition from the
<code>from</code> state to the <code>to</code> state. Prob can be
defined in terms of parameters, just as when using
<code>define_transition</code> at the keyboard. Probabilities of 0
need not be specified - they will be automatically
inserted.
</p>
<p>All state names must be used in the <code>from</code> column of
the transition matrix (otherwise you can just get rid of
the state). Absorbing states should have a transition
from and to themselves with probability 1.
</p>


<h3>Value</h3>

<p>A transition matrix.
</p>

<hr>
<h2 id='create_model_from_tabular'>Create a <code>heemod</code> Model From Tabular Files Info</h2><span id='topic+create_model_from_tabular'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+create_states_from_tabular">create_states_from_tabular()</a></code> and
<code><a href="#topic+create_matrix_from_tabular">create_matrix_from_tabular()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model_from_tabular(state_info, tm_info, df_env = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model_from_tabular_+3A_state_info">state_info</code></td>
<td>
<p>A state tabular file (file path or
parsed file).</p>
</td></tr>
<tr><td><code id="create_model_from_tabular_+3A_tm_info">tm_info</code></td>
<td>
<p>A transition matrix tabular file (file
path or parsed file).</p>
</td></tr>
<tr><td><code id="create_model_from_tabular_+3A_df_env">df_env</code></td>
<td>
<p>An environment containing external data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>heemod</code> model as returned by
<code><a href="#topic+define_strategy">define_strategy()</a></code>.
</p>

<hr>
<h2 id='create_model_list_from_tabular'>Read Models Specified by Files</h2><span id='topic+create_model_list_from_tabular'></span>

<h3>Description</h3>

<p>Read Models Specified by Files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model_list_from_tabular(ref, df_env = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model_list_from_tabular_+3A_ref">ref</code></td>
<td>
<p>Imported reference file.</p>
</td></tr>
<tr><td><code id="create_model_list_from_tabular_+3A_df_env">df_env</code></td>
<td>
<p>An environment containing external data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of unevaluated models.
</p>

<hr>
<h2 id='create_options_from_tabular'>Create Model Options From a Tabular Input</h2><span id='topic+create_options_from_tabular'></span>

<h3>Description</h3>

<p>Create Model Options From a Tabular Input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_options_from_tabular(opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_options_from_tabular_+3A_opt">opt</code></td>
<td>
<p>An option data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model options.
</p>

<hr>
<h2 id='create_parameters_from_tabular'>Create a Parameter Definition From Tabular Input</h2><span id='topic+create_parameters_from_tabular'></span>

<h3>Description</h3>

<p>If specified in the tabular file, DSA and PSA can also be
created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_parameters_from_tabular(param_defs, df_env = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_parameters_from_tabular_+3A_param_defs">param_defs</code></td>
<td>
<p>A parameter definition file.</p>
</td></tr>
<tr><td><code id="create_parameters_from_tabular_+3A_df_env">df_env</code></td>
<td>
<p>An environment containing external data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tabular parameter definition file can have the
following columns: <code>parameter</code> (the parameter name,
required), <code>value</code> (required), <code>low</code> and
<code>high</code> (if both are present, a deterministic
sensitivity analysis will be performed), and <code>psa</code>
(a definition of a distribution to use in a probabilistic
sensitivity analysis. Other columns will be ignored.
</p>


<h3>Value</h3>

<p>The parameter definition.
</p>

<hr>
<h2 id='create_states_from_tabular'>Create State Definitions From Tabular Input</h2><span id='topic+create_states_from_tabular'></span>

<h3>Description</h3>

<p>Transforms tabular input defining states into an
<code>heemod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_states_from_tabular(state_info, df_env = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_states_from_tabular_+3A_state_info">state_info</code></td>
<td>
<p>Result for one model of
<code><a href="#topic+parse_multi_spec">parse_multi_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="create_states_from_tabular_+3A_df_env">df_env</code></td>
<td>
<p>An environment containing external data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns of state_info besides .model and state include
costs and utilities we want to keep track of, with
appropriate values (these may include parameters). For
any cost or utility that should be discounted, an
additional column with the name &quot;.discount.\&lt;cost\&gt;&quot; or
&quot;.discount.\&lt;effect\&gt;&quot;, for the appropriate cost or effect,
can be included. If no discounting is desired for a
particular cost or effect, the corresponding column can
be omitted.
</p>
<p>A discount column can contain only a single value - a
cost or benefit must be discounted by the same amount in
each state. Discounts can be numbers or parameters (which
will then need to be defined like any other).
</p>
<p>The input data frame is expected to contain state
information for all the models you will use in an
analysis. For more information see the vignette:
<code>vignette("file-input", package = "heemod")</code>.
</p>


<h3>Value</h3>

<p>A state list.
</p>

<hr>
<h2 id='define_calibration_fn'>Define Calibration Function</h2><span id='topic+define_calibration_fn'></span>

<h3>Description</h3>

<p>Define a function to be passed to the <code>fn_values</code>
argument of <code><a href="#topic+calibrate_model">calibrate_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_calibration_fn(
  type,
  strategy_names,
  element_names,
  cycles,
  groups = NULL,
  aggreg_fn = sum
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_calibration_fn_+3A_type">type</code></td>
<td>
<p>Type of model values (<code>count</code> or <code>value</code>).</p>
</td></tr>
<tr><td><code id="define_calibration_fn_+3A_strategy_names">strategy_names</code></td>
<td>
<p>Names of strategies.</p>
</td></tr>
<tr><td><code id="define_calibration_fn_+3A_element_names">element_names</code></td>
<td>
<p>Names of states (for counts) or of
state values (for values).</p>
</td></tr>
<tr><td><code id="define_calibration_fn_+3A_cycles">cycles</code></td>
<td>
<p>Cycles of interest.</p>
</td></tr>
<tr><td><code id="define_calibration_fn_+3A_groups">groups</code></td>
<td>
<p>Optional grouping of values (values in a
same group have the same <code>groups</code>).</p>
</td></tr>
<tr><td><code id="define_calibration_fn_+3A_aggreg_fn">aggreg_fn</code></td>
<td>
<p>A function to aggregate values in a same
group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("run_model")

f &lt;- define_calibration_fn(
  type = c("count", "count", "value"),
  strategy_names = c("I", "I", "II"),
  element_names = c("A", "B", "ly"),
  cycles = c(3, 5, 9),
  groups = c(1, 1, 2),
  aggreg_fn = mean
)

</code></pre>

<hr>
<h2 id='define_correlation'>Define a Correlation Structure for Probabilistic
Uncertainty Analysis</h2><span id='topic+define_correlation'></span><span id='topic+define_correlation_'></span>

<h3>Description</h3>

<p>Not all correlation need to be specified for all variable
combinations, unspecified correlations are assumed to be
0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_correlation(...)

define_correlation_(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_correlation_+3A_...">...</code></td>
<td>
<p>A list of parameter names and correlation
coefficients of the form <code>var1, var2, cor(var1, 
  var2), var3, var4, cor(var3, var4), ...</code>.</p>
</td></tr>
<tr><td><code id="define_correlation_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>correlation_matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cm &lt;- define_correlation(
    var1, var2, .4,
    var1, var3, -.2,
    var2, var3, .1
  )

</code></pre>

<hr>
<h2 id='define_dsa'>Define a Sensitivity Analysis</h2><span id='topic+define_dsa'></span><span id='topic+define_dsa_'></span>

<h3>Description</h3>

<p>Define parameter variations for a Markov model
sensitivity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_dsa(...)

define_dsa_(par_names, low_dots, high_dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_dsa_+3A_...">...</code></td>
<td>
<p>A list of parameter names and min/max values
of the form <code>var1, min(var1), max(var1), var2,
  min(var2), max(var2), ...</code>.</p>
</td></tr>
<tr><td><code id="define_dsa_+3A_par_names">par_names</code></td>
<td>
<p>String vector of parameter names.</p>
</td></tr>
<tr><td><code id="define_dsa_+3A_low_dots">low_dots</code>, <code id="define_dsa_+3A_high_dots">high_dots</code></td>
<td>
<p>Used to work around
non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sensitivity</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
define_dsa(
  a, 10, 45,
  b, .5, 1.5
)

</code></pre>

<hr>
<h2 id='define_inflow'>Define Inflow for a BIA</h2><span id='topic+define_inflow'></span><span id='topic+define_inflow_'></span>

<h3>Description</h3>

<p>Define Inflow for a BIA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_inflow(...)

define_inflow_(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_inflow_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining
inflow counts.</p>
</td></tr>
<tr><td><code id="define_inflow_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object similar to the return value of
<code><a href="#topic+define_parameters">define_parameters()</a></code>.
</p>

<hr>
<h2 id='define_init'>Define Initial Counts</h2><span id='topic+define_init'></span><span id='topic+define_init_'></span>

<h3>Description</h3>

<p>Define Initial Counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_init(...)

define_init_(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_init_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining
initial counts.</p>
</td></tr>
<tr><td><code id="define_init_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object similar to the return value of
<code><a href="#topic+define_parameters">define_parameters()</a></code>.
</p>

<hr>
<h2 id='define_parameters'>Define Markov Model Parameters</h2><span id='topic+define_parameters'></span><span id='topic+define_parameters_'></span><span id='topic+modify.uneval_parameters'></span>

<h3>Description</h3>

<p>Define parameters called to compute the transition matrix
or state values for a Markov model. Parameters can be
time dependent by using the <code>model_time</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_parameters(...)

define_parameters_(.dots)

## S3 method for class 'uneval_parameters'
modify(.OBJECT, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_parameters_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining
parameters.</p>
</td></tr>
<tr><td><code id="define_parameters_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
<tr><td><code id="define_parameters_+3A_.object">.OBJECT</code></td>
<td>
<p>An object of class
<code>uneval_parameters</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are defined sequentially, parameters defined
earlier can be called in later expressions.
</p>
<p>Vector length should not be explicitly set, but should
instead be stated relatively to <code>model_time</code>
(whose length depends on the number of simulation
cycles). Alternatively, <code>dplyr</code> functions such as
<code><a href="dplyr.html#topic+context">dplyr::n()</a></code> can be used.
</p>
<p>This function relies heavily on the <code>dplyr</code> package.
Parameter definitions should thus mimic the use of
functions such as <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>.
</p>
<p>Variable names are searched first in the parameter
definition (only parameters defined earlier are visible)
then in the environment where <code>define_parameters</code>
was called.
</p>
<p>For the <code>modify</code> function, existing parameters are
modified, but no new parameter can be added. Parameter
order matters since only parameters defined earlier can
be referenced in later expressions.
</p>


<h3>Value</h3>

<p>An object of class <code>uneval_parameters</code>
(actually a named list of quosures).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# parameter 'age' depends on time:
# simulating a cohort starting at 60 yo

define_parameters(
  age_start = 60,
  age = age_start + model_time
)

# other uses of model_time are possible

define_parameters(
  top_time = ifelse(model_time &lt; 10, 1, 0)
)

# more elaborate: risk function

define_parameters(
  rate = 1 - exp(- model_time * .5)
)

# dont explicitly state lengths
# define_parameters(
#   var = seq(1, 15, 2)
# )


# instead rely on model_time or dplyr 
# functions such as n() or row_number()

define_parameters(
  var = seq(from = 1, length.out = n(), by = 3),
  var2 = seq(1, length(model_time), 2)
)

param &lt;- define_parameters(
  age_start = 60,
  age = age_start + model_time
)

# modify existing parameters

modify(
  param,
  age_start = 40
)

# cannot add new parameters

# modify(
#   param,
#   const = 4.4,
#   age_2 = age ^ 2
# )

</code></pre>

<hr>
<h2 id='define_part_surv'>Define Partitioned Survival</h2><span id='topic+define_part_surv'></span><span id='topic+define_part_surv_'></span>

<h3>Description</h3>

<p>Define a partitioned survival model with progression-free
survival and overall survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_part_surv(
  pfs,
  os,
  state_names,
  terminal_state = FALSE,
  cycle_length = 1
)

define_part_surv_(pfs, os, state_names, cycle_length = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_part_surv_+3A_pfs">pfs</code>, <code id="define_part_surv_+3A_os">os</code></td>
<td>
<p>Either results from
<code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code> or
<code><a href="#topic+define_surv_dist">define_surv_dist()</a></code>.</p>
</td></tr>
<tr><td><code id="define_part_surv_+3A_state_names">state_names</code></td>
<td>
<p>named character vector, length 3 or 4.
State names for progression-free state, progression,
(optionally terminal) and death respectively. Elements
should be named <code>"progression_free"</code>,
<code>"progression"</code>, (optionally <code>"terminal"</code>),
and <code>"death"</code>. See examples.</p>
</td></tr>
<tr><td><code id="define_part_surv_+3A_terminal_state">terminal_state</code></td>
<td>
<p>Should a terminal state be
included? Only used when state names are not provided.</p>
</td></tr>
<tr><td><code id="define_part_surv_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The value of a Markov cycle in
absolute time units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>part_surv</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_pfs &lt;- define_surv_dist("exp", rate = 1)
dist_os &lt;- define_surv_dist("exp", rate = .5)

define_part_surv(
  pfs = dist_pfs,
  os = dist_os,
  state_names = c(
    progression_free = "A",
    progression = "B",
    terminal = "C",
    death = "D"
  )
)
# identical to:
define_part_surv(
  pfs = dist_pfs,
  os = dist_os,
  terminal_state = TRUE
)

</code></pre>

<hr>
<h2 id='define_psa'>Define Parameters Distribution for Probabilistic Analysis</h2><span id='topic+define_psa'></span><span id='topic+define_psa_'></span>

<h3>Description</h3>

<p>Define the properties of parameter distributions and
their correlation structure for probabilistic uncertainty
analysis of Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_psa(..., correlation)

define_psa_(.dots = list(), correlation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_psa_+3A_...">...</code></td>
<td>
<p>Formulas defining parameter distributions.</p>
</td></tr>
<tr><td><code id="define_psa_+3A_correlation">correlation</code></td>
<td>
<p>A correlation matrix for parameters or
the output of <code><a href="#topic+define_correlation">define_correlation()</a></code>.</p>
</td></tr>
<tr><td><code id="define_psa_+3A_.dots">.dots</code></td>
<td>
<p>Pair/values of expressions coercible to quosures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distributions must be defined within <code>heemod</code>
(see <a href="#topic+distributions">distributions</a>), or defined with
<code><a href="#topic+define_distribution">define_distribution()</a></code>.
</p>
<p>If no correlation matrix is specified parameters are
assumed to be independant.
</p>
<p>The correlation matrix need only be specified for
correlated parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>resamp_definition</code>.
Contains <code>list_qdist</code>, a list of quantile
functions and <code>correlation</code> a correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc &lt;- define_correlation(
  age_init, cost_init, .4
)

define_psa(
    age_init ~ normal(60, 10),
    cost_init ~ normal(1000, 100),
    correlation = mc
)

# example with multinomial parameters

define_psa(
  rate1 + rate2 + rate3 ~ multinomial(10, 50, 40),
  a + b ~ multinomial(15, 30)
)
</code></pre>

<hr>
<h2 id='define_starting_values'>Define Starting State Values</h2><span id='topic+define_starting_values'></span><span id='topic+define_starting_values_'></span>

<h3>Description</h3>

<p>This function is meant to be used inside <code><a href="#topic+define_strategy">define_strategy()</a></code> and
<code><a href="#topic+define_state">define_state()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_starting_values(...)

define_starting_values_(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_starting_values_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining
starting values. The names must correspond to an existing state value.</p>
</td></tr>
<tr><td><code id="define_starting_values_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behaviour is different following the function using <code><a href="#topic+define_starting_values">define_starting_values()</a></code>
as an argument.
</p>

<ul>
<li><p> When used inside <code><a href="#topic+define_strategy">define_strategy()</a></code>, the state values are modified for the
first cycle in each state
</p>
</li>
<li><p> When used inside <code><a href="#topic+define_state">define_state()</a></code>, the state values are modified for counts
entering the state
</p>
</li></ul>



<h3>Value</h3>

<p>An object similar to the return value of
<code><a href="#topic+define_parameters">define_parameters()</a></code>.
</p>

<hr>
<h2 id='define_state'>Define a Markov Model State</h2><span id='topic+define_state'></span><span id='topic+define_state_'></span><span id='topic+modify.state'></span>

<h3>Description</h3>

<p>Define the values characterising a Markov Model state for
1 cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_state(..., starting_values = define_starting_values())

define_state_(x)

## S3 method for class 'state'
modify(.OBJECT, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_state_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining state
values.</p>
</td></tr>
<tr><td><code id="define_state_+3A_starting_values">starting_values</code></td>
<td>
<p>Optional starting values defined
with <code><a href="#topic+define_starting_values">define_starting_values()</a></code>.</p>
</td></tr>
<tr><td><code id="define_state_+3A_x">x</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
<tr><td><code id="define_state_+3A_.object">.OBJECT</code></td>
<td>
<p>An object of class <code>state</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with <code><a href="#topic+define_parameters">define_parameters()</a></code>, state values are
defined sequentially. Later state definition can thus
only refer to values defined earlier.
</p>
<p>For the <code>modify</code> function, existing values are
modified, no new values can be added. Values order
matters since only values defined earlier can be
referenced in later expressions.
</p>


<h3>Value</h3>

<p>An object of class <code>state</code> (actually a named
list of quosures).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- define_state(
  cost = 6453,
  utility = .876
)
st
</code></pre>

<hr>
<h2 id='define_state_list'>Define Markov Model State List</h2><span id='topic+define_state_list'></span><span id='topic+define_state_list_'></span><span id='topic+modify.uneval_state_list'></span>

<h3>Description</h3>

<p>Define the states of a Markov model by combining
<code>state</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_state_list(...)

define_state_list_(.dots)

## S3 method for class 'uneval_state_list'
modify(.OBJECT, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_state_list_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining model
states.</p>
</td></tr>
<tr><td><code id="define_state_list_+3A_.dots">.dots</code></td>
<td>
<p>List of states, only used by
<code>define_state_list_</code> to avoid using <code>...</code>.</p>
</td></tr>
<tr><td><code id="define_state_list_+3A_.object">.OBJECT</code></td>
<td>
<p>An <code>uneval_states</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>State names have to correspond to those specified through
<code><a href="#topic+define_transition">define_transition()</a></code>.
</p>
<p>All states should have the same value names.
</p>
<p>The <code>modify</code> function can modify existing states or
add new ones.
</p>


<h3>Value</h3>

<p>An object of class <code>uneval_state_list</code> (a
list of <code>state</code> objects).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
s1 &lt;- define_state(cost = 1, util = 1)
s2 &lt;- define_state(cost = 3, util = .4)

states_mod &lt;- define_state_list(
  healthy = s1,
  sick = s2
)

states_mod

s1_bis &lt;- define_state(cost = 0, util = 1)
s3 &lt;- define_state(cost = 10, util = .1)

modify(
  states_mod,
  healthy = s1_bis,
  sicker = s3
)

## End(Not run)
  
</code></pre>

<hr>
<h2 id='define_strategy'>Define a Markov Model</h2><span id='topic+define_strategy'></span><span id='topic+define_strategy_'></span>

<h3>Description</h3>

<p>Combine information on parameters, transition matrix and
states defined through <code><a href="#topic+define_parameters">define_parameters()</a></code>,
<code><a href="#topic+define_transition">define_transition()</a></code> and <code><a href="#topic+define_state">define_state()</a></code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_strategy(
  ...,
  transition = define_transition(),
  starting_values = define_starting_values()
)

define_strategy_(transition, states, starting_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_strategy_+3A_...">...</code></td>
<td>
<p>Objects generated by <code><a href="#topic+define_state">define_state()</a></code>. Each object should be named
with the state names of the transition matrix.</p>
</td></tr>
<tr><td><code id="define_strategy_+3A_transition">transition</code></td>
<td>
<p>An object generated by
<code><a href="#topic+define_transition">define_transition()</a></code>.</p>
</td></tr>
<tr><td><code id="define_strategy_+3A_starting_values">starting_values</code></td>
<td>
<p>Optional starting values defined
with <code><a href="#topic+define_starting_values">define_starting_values()</a></code>.</p>
</td></tr>
<tr><td><code id="define_strategy_+3A_states">states</code></td>
<td>
<p>List of states, only used by
<code>define_strategy_</code> to avoid using <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the objects are compatible
in the same model (same state names...).
</p>
<p>State values and transition probabilities referencing
<code>state_time</code> are automatically expanded to implicit
tunnel states.
</p>


<h3>Value</h3>

<p>An object of class <code>uneval_model</code> (a list
containing the unevaluated parameters, matrix and
states).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- define_transition(
  state_names = c("s1", "s2"),
  1 / c, 1 - 1/ c,
  0, 1
)

s1 &lt;- define_state(
  cost = 234,
  utility = 1
  )
s2 &lt;- define_state(
  cost = 421,
  utility = .5
  )

define_strategy(
  transition = mat,
  s1 = s1,
  s2 = s2
)
</code></pre>

<hr>
<h2 id='define_surv_dist'>Define a Survival Distribution</h2><span id='topic+define_surv_dist'></span>

<h3>Description</h3>

<p>Define a parametric survival distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_surv_dist(
  distribution = c("exp", "weibull", "weibullPH", "lnorm", "llogis", "gamma", "gompertz",
    "gengamma", "gengamma.orig", "genf", "genf.orig"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_surv_dist_+3A_distribution">distribution</code></td>
<td>
<p>A parametric survival distribution.</p>
</td></tr>
<tr><td><code id="define_surv_dist_+3A_...">...</code></td>
<td>
<p>Additional distribution parameters (see
respective distribution help pages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_dist</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
define_surv_dist(distribution = "exp", rate = .5)
define_surv_dist(distribution = "gompertz", rate = .5, shape = 1)

</code></pre>

<hr>
<h2 id='define_surv_fit'>Define a Fitted Survival Model</h2><span id='topic+define_surv_fit'></span>

<h3>Description</h3>

<p>Define a fitted survival models with a Kaplan-Meier estimator or
parametric distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_surv_fit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_surv_fit_+3A_x">x</code></td>
<td>
<p>a survfit or flexsurvreg object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_object</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

define_surv_fit(
  survfit(Surv(time, status) ~ 1, data = colon)
)

define_surv_fit(
  flexsurv::flexsurvreg(Surv(time, status) ~ 1, data = colon, dist = "exp")
)

</code></pre>

<hr>
<h2 id='define_surv_spline'>Define a Restricted Cubic Spline Survival Distribution</h2><span id='topic+define_surv_spline'></span>

<h3>Description</h3>

<p>Define a restricted cubic spline parametric survival
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_surv_spline(scale = c("hazard", "odds", "normal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_surv_spline_+3A_scale">scale</code></td>
<td>
<p>&quot;hazard&quot;, &quot;odds&quot;, or &quot;normal&quot;, as described
in flexsurvspline. With the default of no knots in
addition to the boundaries, these models reduce to the
Weibull, log-logistic and log-normal respectively. The
scale must be common to all times.</p>
</td></tr>
<tr><td><code id="define_surv_spline_+3A_...">...</code></td>
<td>
<p>Additional distribution parameters (see
respective distribution help pages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_dist</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
define_surv_spline(
  scale = "hazard", 
  gamma = c(-18.3122, 2.7511, 0.2292), 
  knots=c(4.276666, 6.470800, 7.806289)
)
define_surv_spline(
  scale = "odds", 
  gamma = c(-18.5809, 2.7973, 0.2035), 
  knots=c(4.276666, 6.470800, 7.806289)
)

</code></pre>

<hr>
<h2 id='define_surv_table'>Define a survival distribution based on explicit survival probabilities</h2><span id='topic+define_surv_table'></span><span id='topic+define_surv_table.data.frame'></span><span id='topic+define_surv_table.character'></span>

<h3>Description</h3>

<p>Define a survival distribution based on explicit survival probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_surv_table(x)

## S3 method for class 'data.frame'
define_surv_table(x)

## S3 method for class 'character'
define_surv_table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_surv_table_+3A_x">x</code></td>
<td>
<p>a data frame with columns <code>time</code> and <code>survival</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>surv_table</code> object, which can be used with <code><a href="#topic+compute_surv">compute_surv()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- data.frame(time = c(0, 1, 5, 10), survival = c(1, 0.9, 0.7, 0.5))
 define_surv_table(x)
 
</code></pre>

<hr>
<h2 id='define_transition'>Define Transition Matrix for Markov Model</h2><span id='topic+define_transition'></span><span id='topic+define_transition_'></span><span id='topic+modify.uneval_matrix'></span><span id='topic+plot.uneval_matrix'></span>

<h3>Description</h3>

<p>Define a matrix of transition probabilities. Probability
can depend on parameters defined with
<code><a href="#topic+define_parameters">define_parameters()</a></code>, and can thus be time-dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_transition(..., state_names)

define_transition_(.dots, state_names)

## S3 method for class 'uneval_matrix'
modify(.OBJECT, ...)

## S3 method for class 'uneval_matrix'
plot(x, relsize = 0.75, shadow.size = 0, latex = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_transition_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions defining matrix
cells. Can refer to parameters defined with
<code><a href="#topic+define_parameters">define_parameters()</a></code>. For <code>plot</code>, additional arguments
passed to <code><a href="diagram.html#topic+plotmat">diagram::plotmat()</a></code>.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_state_names">state_names</code></td>
<td>
<p>character vector, optional. State
names.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_.object">.OBJECT</code></td>
<td>
<p>An object of class <code>uneval_matrix</code>.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_x">x</code></td>
<td>
<p>An <code>uneval_matrix</code> to plot.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_relsize">relsize</code></td>
<td>
<p>Argument passed to <code><a href="diagram.html#topic+plotmat">diagram::plotmat()</a></code>.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_shadow.size">shadow.size</code></td>
<td>
<p>Argument passed to
<code><a href="diagram.html#topic+plotmat">diagram::plotmat()</a></code>.</p>
</td></tr>
<tr><td><code id="define_transition_+3A_latex">latex</code></td>
<td>
<p>Argument passed to <code><a href="diagram.html#topic+plotmat">diagram::plotmat()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matric cells are listed by row.
</p>
<p>Parameters names are searched first in a parameter object
defined with <code><a href="#topic+define_parameters">define_parameters()</a></code> and linked with the
matrix through <code><a href="#topic+define_strategy">define_strategy()</a></code>; then in the
environment where the matrix was defined.
</p>
<p>The complementary probability of all other row
probabilities can be conveniently referred to as <code>C</code>.
</p>
<p>The matrix code can be re-indented for readability with
<code><a href="#topic+reindent_transition">reindent_transition()</a></code>.
</p>
<p>Only matrix size is checked during this step (the matrix
must be square). Other conditions (such as row sums being
equal to 1) are tested later, during model evaluation.
</p>
<p>For the <code>modify</code> function, existing matrix cells are
replaced with the new expression. Cells are referenced by
name. Cell naming follows the <code>cell_x_y</code> convention, with
<code>x</code> being the row number and <code>y</code> the column number.
</p>


<h3>Value</h3>

<p>An object of class <code>uneval_matrix</code> (actually a
named list of <code>quosures</code> expressions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple 3x3 transition matrix

mat_1 &lt;- define_transition(
  .2, 0, .8,
  0, .1, .9,
  0, 0, 1
)
mat_1

plot(mat_1)

# referencing parameters
# rr must be present in a parameter object
# that must later be linked with define_strategy

mat_2 &lt;- define_transition(
  .5 - rr, rr,
  .4, .6
)
mat_2

reindent_transition(mat_2)

# can also use C

define_transition(
  C, rr,
  .4, .6
)

# updating cells from mat_1

modify(
  mat_1,
  cell_2_1 = .2,
  cell_2_3 = .7
)

# only matrix size is check, it is thus possible
# to define an incorrect matrix

# this matrix will generate an error later,
# during model evaluation

define_transition(
  .5, 3,
  -1, 2
)
</code></pre>

<hr>
<h2 id='discount'>Discount a Quantity Over Time. Should be a scalar if time is
specified, a vector otherwise</h2><span id='topic+discount'></span>

<h3>Description</h3>

<p>Discount a Quantity Over Time. Should be a scalar if time is
specified, a vector otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discount(x, r, first = FALSE, period = 1, linear = FALSE, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discount_+3A_x">x</code></td>
<td>
<p>numeric. A quantity to discount.</p>
</td></tr>
<tr><td><code id="discount_+3A_r">r</code></td>
<td>
<p>discount rate.</p>
</td></tr>
<tr><td><code id="discount_+3A_first">first</code></td>
<td>
<p>logical. Should discounting start at the
first value?</p>
</td></tr>
<tr><td><code id="discount_+3A_period">period</code></td>
<td>
<p>Number of cycle per unit of discount rate.</p>
</td></tr>
<tr><td><code id="discount_+3A_linear">linear</code></td>
<td>
<p>logical. Should the discount rate vary linearly along the
whole period?</p>
</td></tr>
<tr><td><code id="discount_+3A_time">time</code></td>
<td>
<p>The cycle number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the unit of discount rate is the year and a cycle duration is 1
month, period should be 12.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
discount(rep(10, 5), .02)
discount(rep(10, 5), .02, first = FALSE)
 
discount(1000, .05, time = 10)
discount(1000, .05, period = 2, time = 1:10)
discount(1000, .05, period = 2, time = 1:10, linear = TRUE)

</code></pre>

<hr>
<h2 id='discount_hack'>Hack to Work Around a Discounting Issue</h2><span id='topic+discount_hack'></span>

<h3>Description</h3>

<p>This function is a hack to avoid a problem with
discounting when the argument is a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discount_hack(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discount_hack_+3A_.dots">.dots</code></td>
<td>
<p>A state object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hack consists in replacing calls to
<code>discount(x)</code> by <code>discount(x * rep(1, dplyr::n()))</code> to
ensure <code>x</code> is recycled to the correct length.
</p>


<h3>Value</h3>

<p>A modified state object.
</p>

<hr>
<h2 id='dispatch_strategy'>Dispatch Values According to Strategy</h2><span id='topic+dispatch_strategy'></span>

<h3>Description</h3>

<p>Returns different values depending on the strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatch_strategy(.strategy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispatch_strategy_+3A_.strategy">.strategy</code></td>
<td>
<p>Optional strategy name. If not specified
it is implicitely added.</p>
</td></tr>
<tr><td><code id="dispatch_strategy_+3A_...">...</code></td>
<td>
<p>Values of the parameter named depending on the
strategy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
define_parameters(
  val = 456,
  x = dispatch_strategy(
    strat_1 = 1234,
    strat_2 = 9876,
    strat_3 = val * 2 + model_time
  )
)
</code></pre>

<hr>
<h2 id='dispatch_strategy_hack'>Hack to Automate Use of Strategy Name</h2><span id='topic+dispatch_strategy_hack'></span>

<h3>Description</h3>

<p>This function is a hack to automate the definition of the
argument <code>.strategy</code> in
<code><a href="#topic+dispatch_strategy">dispatch_strategy()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatch_strategy_hack(.dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispatch_strategy_hack_+3A_.dots">.dots</code></td>
<td>
<p>A <code>quosures</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hack consists in replacing calls to
<code>dispatch_strategy(...)</code> by
<code>dispatch_strategy(.strategy = strategy, ...)</code> if
<code>.strategy_name</code> is not already defined.
</p>


<h3>Value</h3>

<p>A modified <code>quosures</code> object.
</p>

<hr>
<h2 id='distributions'>Probability Density Functions for Probabilistic
Uncertainty Analysis</h2><span id='topic+distributions'></span><span id='topic+normal'></span><span id='topic+lognormal'></span><span id='topic+gamma'></span><span id='topic+binomial'></span><span id='topic+multinomial'></span><span id='topic+logitnormal'></span><span id='topic+beta'></span><span id='topic+triangle'></span><span id='topic+poisson'></span><span id='topic+define_distribution'></span><span id='topic+use_distribution'></span>

<h3>Description</h3>

<p>Define a distribution for PSA parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(mean, sd)

lognormal(mean, sd, meanlog, sdlog)

gamma(mean, sd)

binomial(prob, size)

multinomial(...)

logitnormal(mu, sigma)

beta(shape1, shape2)

triangle(lower, upper, peak = (lower + upper)/2)

poisson(mean)

define_distribution(x)

beta(shape1, shape2)

triangle(lower, upper, peak = (lower + upper)/2)

use_distribution(distribution, smooth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributions_+3A_mean">mean</code></td>
<td>
<p>Distribution mean.</p>
</td></tr>
<tr><td><code id="distributions_+3A_sd">sd</code></td>
<td>
<p>Distribution standard deviation.</p>
</td></tr>
<tr><td><code id="distributions_+3A_meanlog">meanlog</code></td>
<td>
<p>Mean on the log scale.</p>
</td></tr>
<tr><td><code id="distributions_+3A_sdlog">sdlog</code></td>
<td>
<p>SD on the log scale.</p>
</td></tr>
<tr><td><code id="distributions_+3A_prob">prob</code></td>
<td>
<p>Proportion.</p>
</td></tr>
<tr><td><code id="distributions_+3A_size">size</code></td>
<td>
<p>Size of sample used to estimate
proportion.</p>
</td></tr>
<tr><td><code id="distributions_+3A_...">...</code></td>
<td>
<p>Dirichlet distribution parameters.</p>
</td></tr>
<tr><td><code id="distributions_+3A_mu">mu</code></td>
<td>
<p>Mean on the logit scale.</p>
</td></tr>
<tr><td><code id="distributions_+3A_sigma">sigma</code></td>
<td>
<p>SD on the logit scale.</p>
</td></tr>
<tr><td><code id="distributions_+3A_shape1">shape1</code></td>
<td>
<p>for beta distribution</p>
</td></tr>
<tr><td><code id="distributions_+3A_shape2">shape2</code></td>
<td>
<p>for beta distribution</p>
</td></tr>
<tr><td><code id="distributions_+3A_lower">lower</code></td>
<td>
<p>lower bound of triangular
distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_upper">upper</code></td>
<td>
<p>upper bound of triangular
distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_peak">peak</code></td>
<td>
<p>peak of triangular distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_x">x</code></td>
<td>
<p>A distribution function, see details.</p>
</td></tr>
<tr><td><code id="distributions_+3A_distribution">distribution</code></td>
<td>
<p>A numeric vector of
observations defining a distribution, usually
the output from an MCMC fit.</p>
</td></tr>
<tr><td><code id="distributions_+3A_smooth">smooth</code></td>
<td>
<p>Use gaussian kernel smoothing?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not exported, but only used
in <code><a href="#topic+define_psa">define_psa()</a></code>. To specify a user-made
function use <code><a href="#topic+define_distribution">define_distribution()</a></code>.
</p>
<p><code><a href="#topic+use_distribution">use_distribution()</a></code> uses gaussian kernel
smoothing with a bandwidth parameter calculated
by <code><a href="stats.html#topic+density">stats::density()</a></code>. Values for unobserved
quantiles are calculated by linear
interpolation.
</p>
<p><code><a href="#topic+define_distribution">define_distribution()</a></code> takes as argument a
function with a single argument, <code>x</code>,
corresponding to a vector of quantiles. It
returns the distribution values for the given
quantiles. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>define_distribution(
  function(x) stats::qexp(p = x, rate = 0.5)
)

# a mixture of 2 gaussians
x &lt;- c(rnorm(100), rnorm(100, 6))
plot(density(x))

use_distribution(x)
</code></pre>

<hr>
<h2 id='eval_models_from_tabular'>Evaluate Models From a Tabular Source</h2><span id='topic+eval_models_from_tabular'></span>

<h3>Description</h3>

<p>Execute a full set of analyses, possibly including
discrete sensitivity analysis, probabilistic sensitivity
analysis, and analyses across demographics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_models_from_tabular(
  inputs,
  run_dsa = TRUE,
  run_psa = TRUE,
  run_demo = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_models_from_tabular_+3A_inputs">inputs</code></td>
<td>
<p>Result from
<code><a href="#topic+gather_model_info">gather_model_info()</a></code>.</p>
</td></tr>
<tr><td><code id="eval_models_from_tabular_+3A_run_dsa">run_dsa</code></td>
<td>
<p>Run DSA?</p>
</td></tr>
<tr><td><code id="eval_models_from_tabular_+3A_run_psa">run_psa</code></td>
<td>
<p>Run PSA?</p>
</td></tr>
<tr><td><code id="eval_models_from_tabular_+3A_run_demo">run_demo</code></td>
<td>
<p>Run demographic analysis?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list </p>
 <ul>
<li> <p><code>models</code> (always)
unevaluated model. </p>
</li>
<li> <p><code>model_runs</code> (always)
evaluated models </p>
</li>
<li> <p><code>dsa</code> (deterministic
sensitivity analysis) - if appropriate parameters
provided </p>
</li>
<li> <p><code>psa</code> (probabilistic sensitivity
analysis) - if appropriate parameters provided </p>
</li>
<li>
<p><code>demographics</code> results across different
demographic groups - if appropriate parameters
provided</p>
</li></ul>


<hr>
<h2 id='eval_parameters'>Evaluate Markov model parameters</h2><span id='topic+eval_parameters'></span>

<h3>Description</h3>

<p>Evaluate parameters specified through
<code>define_parameters</code>, for a given number of cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_parameters(x, cycles = 1, strategy_name = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_parameters_+3A_x">x</code></td>
<td>
<p>an <code>uneval_parameters</code> object.</p>
</td></tr>
<tr><td><code id="eval_parameters_+3A_cycles">cycles</code></td>
<td>
<p>integer. Number of cycles to simulate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>eval_parameters</code>
(actually a data.frame with one column per parameter
and one row per cycle).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- define_parameters(
  age_start = 60,
  age = age_start + model_time
)

heemod:::eval_parameters(param, cycles = 15)
</code></pre>

<hr>
<h2 id='eval_resample'>Evaluate Resampling Definition</h2><span id='topic+eval_resample'></span>

<h3>Description</h3>

<p>Evaluate Resampling Definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_resample(psa, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_resample_+3A_psa">psa</code></td>
<td>
<p>A <code><a href="#topic+define_psa">define_psa()</a></code> object.</p>
</td></tr>
<tr><td><code id="eval_resample_+3A_n">N</code></td>
<td>
<p>&gt; 0. Number of simulation to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of resampled values with on
column per parameter and <code>N</code> rows.
</p>

<hr>
<h2 id='eval_state_list'>Evaluate Markov Model States</h2><span id='topic+eval_state_list'></span>

<h3>Description</h3>

<p>Evaluate Markov Model States
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_state_list(x, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_state_list_+3A_x">x</code></td>
<td>
<p>An <code>uneval_state_list</code> object generated by
<code><a href="#topic+define_state_list">define_state_list()</a></code>.</p>
</td></tr>
<tr><td><code id="eval_state_list_+3A_parameters">parameters</code></td>
<td>
<p>An <code>eval_parameters</code> object
generated by <code><a href="#topic+eval_parameters">eval_parameters()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>eval_states</code> object, a list with one
data.frame per state containing a column per state
value and a line per cycle.
</p>

<hr>
<h2 id='eval_strategy'>Evaluate Strategy</h2><span id='topic+eval_strategy'></span>

<h3>Description</h3>

<p>Given an unevaluated strategy, an initial number of
individual and a number of cycle to compute, returns the
evaluated version of the objects and the count of
individual per state per model cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_strategy(
  strategy,
  parameters,
  cycles,
  init,
  method,
  expand_limit,
  inflow,
  strategy_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_strategy_+3A_strategy">strategy</code></td>
<td>
<p>An <code>uneval_strategy</code> object.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_parameters">parameters</code></td>
<td>
<p>Optional. An object generated by
<code><a href="#topic+define_parameters">define_parameters()</a></code>.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_cycles">cycles</code></td>
<td>
<p>positive integer. Number of Markov Cycles
to compute.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_init">init</code></td>
<td>
<p>numeric vector, same length as number of
model states. Number of individuals in each model state
at the beginning.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_method">method</code></td>
<td>
<p>Counting method.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_expand_limit">expand_limit</code></td>
<td>
<p>A named vector of state expansion
limits.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_inflow">inflow</code></td>
<td>
<p>Numeric vector, similar to <code>init</code>. Number
of new individuals in each state per cycle.</p>
</td></tr>
<tr><td><code id="eval_strategy_+3A_strategy_name">strategy_name</code></td>
<td>
<p>Name of the strategy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>init</code> need not be integer. E.g. <code>c(A = 1, B = 0.5, C = 0.1, ...)</code>.
</p>


<h3>Value</h3>

<p>An <code>eval_strategy</code> object (actually a list of
evaluated parameters, matrix, states and cycles
counts).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- define_parameters(
  a = model_time + 1 * 2
)

mat &lt;- define_transition(
  1-1/a, 1/a,
  .1,    .9
)

mod &lt;- define_strategy(
  transition = mat,
  A = define_state(cost = 10),
  B = define_state(cost = 2)
)

heemod:::eval_strategy(
  strategy = mod,
  parameters = param,
  init = define_init(A = 10, B = 5),
  cycles = 5,
  method = "end",
  inflow = define_inflow(A = 0, B = 0),
  strategy_name = "A",
  expand_limit = c(A = 5, B = 5)
)
</code></pre>

<hr>
<h2 id='eval_strategy_newdata'>Iteratively Evaluate a Markov Model With New Parameter
Values</h2><span id='topic+eval_strategy_newdata'></span>

<h3>Description</h3>

<p>Given a data.frame with on set of new parameters values
per row, iteratively evaluate the model over the set of
new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_strategy_newdata(x, strategy = 1, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_strategy_newdata_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="eval_strategy_newdata_+3A_strategy">strategy</code></td>
<td>
<p>Name or index of model to recompute.</p>
</td></tr>
<tr><td><code id="eval_strategy_newdata_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame whose names match parameters
names. <code>strategy</code> will be evaluated iteratively,
taking successive values from each row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New parameters with a missing value (<code>NA</code>) do not
replace existing parameters.
</p>


<h3>Value</h3>

<p>A data.frame containing the values of
<code>newdata</code> and each Markov Model evaluation in
<code>res</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par1 &lt;- define_parameters(
  a = 1,
  b = 1 / (model_time + a)
)

mat1 &lt;- define_transition(
  1-b, b,
  0, 1
)
mod1 &lt;- define_strategy(
  transition = mat1,
  define_state(var = a),
  define_state(var = a * model_time)
)

res1 &lt;- run_model(
  mod1,
  parameters = par1,
  cycles = 5,
  init = 1:0,
  method = "end"
)

new_tab &lt;- data.frame(
  a = 1:10
)

heemod:::eval_strategy_newdata(
  res1,
  newdata = new_tab
)
</code></pre>

<hr>
<h2 id='eval_surv'>Evaluate Survival Distributions</h2><span id='topic+eval_surv'></span><span id='topic+compute_surv_'></span><span id='topic+eval_surv.surv_fit'></span><span id='topic+eval_surv.default'></span><span id='topic+eval_surv.survfit'></span><span id='topic+eval_surv.flexsurvreg'></span><span id='topic+eval_surv.surv_model'></span><span id='topic+eval_surv.surv_projection'></span><span id='topic+eval_surv.surv_pooled'></span><span id='topic+eval_surv.surv_ph'></span><span id='topic+eval_surv.surv_shift'></span><span id='topic+eval_surv.surv_aft'></span><span id='topic+eval_surv.surv_po'></span><span id='topic+eval_surv.surv_add_haz'></span><span id='topic+eval_surv.surv_dist'></span><span id='topic+eval_surv.surv_table'></span>

<h3>Description</h3>

<p>Generate either survival probabilities or conditional
probabilities of event for each model cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_surv(x, time, ...)

compute_surv_(x, time, cycle_length = 1, type = c("prob", "survival"), ...)

## S3 method for class 'surv_fit'
eval_surv(x, time, ...)

## Default S3 method:
eval_surv(x, ...)

## S3 method for class 'survfit'
eval_surv(x, time, ...)

## S3 method for class 'flexsurvreg'
eval_surv(x, time, ...)

## S3 method for class 'surv_model'
eval_surv(x, time, ...)

## S3 method for class 'surv_projection'
eval_surv(x, time, ...)

## S3 method for class 'surv_pooled'
eval_surv(x, time, ...)

## S3 method for class 'surv_ph'
eval_surv(x, time, ...)

## S3 method for class 'surv_shift'
eval_surv(x, time, ...)

## S3 method for class 'surv_aft'
eval_surv(x, time, ...)

## S3 method for class 'surv_po'
eval_surv(x, time, ...)

## S3 method for class 'surv_add_haz'
eval_surv(x, time, ...)

## S3 method for class 'surv_dist'
eval_surv(x, time, ...)

## S3 method for class 'surv_table'
eval_surv(x, time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_surv_+3A_x">x</code></td>
<td>
<p>A survival object</p>
</td></tr>
<tr><td><code id="eval_surv_+3A_time">time</code></td>
<td>
<p>The <code>model_time</code> or <code>state_time</code> for which
to predict.</p>
</td></tr>
<tr><td><code id="eval_surv_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="eval_surv_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The value of a Markov cycle in
absolute time units.</p>
</td></tr>
<tr><td><code id="eval_surv_+3A_type">type</code></td>
<td>
<p>Either <code>prob</code>, for transition probabilities,
or <code>surv</code>, for survival.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of <code>compute_surv()</code> are memoised for
<code>options("heemod.memotime")</code> (default: 1 hour) to
increase resampling performance.
</p>


<h3>Value</h3>

<p>Returns either the survival probabilities or
conditional probabilities of event for each cycle.
</p>

<hr>
<h2 id='eval_transition'>Evaluate Markov Model Transition Matrix</h2><span id='topic+eval_transition'></span>

<h3>Description</h3>

<p>Evaluate a transition matrix using evaluated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_transition(x, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_transition_+3A_x">x</code></td>
<td>
<p>an <code>uneval_matrix</code> object.</p>
</td></tr>
<tr><td><code id="eval_transition_+3A_parameters">parameters</code></td>
<td>
<p>an <code>eval_parameters</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs checks on the transition matrix during evaluation.
</p>
<p>This functions has been heavily optimized, and thus can
be difficult to read. Good luck...
</p>


<h3>Value</h3>

<p>An <code>eval_matrix</code> object (actually a list of
transition matrices, one per cycle).
</p>

<hr>
<h2 id='expand_if_necessary'>Expand States and Transition</h2><span id='topic+expand_if_necessary'></span>

<h3>Description</h3>

<p>Given an unevaluated strategy, an initial number of
individual and a number of cycle to compute, returns the
evaluated version of the objects and the count of
individual per state per model cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_if_necessary(
  strategy,
  parameters,
  cycles,
  init,
  method,
  expand_limit,
  inflow,
  strategy_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_if_necessary_+3A_strategy">strategy</code></td>
<td>
<p>An <code>uneval_strategy</code> object.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_parameters">parameters</code></td>
<td>
<p>Optional. An object generated by
<code><a href="#topic+define_parameters">define_parameters()</a></code>.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_cycles">cycles</code></td>
<td>
<p>positive integer. Number of Markov Cycles
to compute.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_init">init</code></td>
<td>
<p>numeric vector, same length as number of
model states. Number of individuals in each model state
at the beginning.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_method">method</code></td>
<td>
<p>Counting method.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_expand_limit">expand_limit</code></td>
<td>
<p>A named vector of state expansion
limits.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_inflow">inflow</code></td>
<td>
<p>Numeric vector, similar to <code>init</code>. Number
of new individuals in each state per cycle.</p>
</td></tr>
<tr><td><code id="expand_if_necessary_+3A_strategy_name">strategy_name</code></td>
<td>
<p>Name of the strategy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>init</code> need not be integer. E.g. <code>c(A = 1, B = 0.5, C = 0.1, ...)</code>.
</p>


<h3>Value</h3>

<p>Expanded states, transitions, input and inflow
(if they require expansion; otherwise return inputs
unchanged).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- define_parameters(
  a = model_time + 1 * 2
)

mat &lt;- define_transition(
  1-1/a, 1/a,
  .1,    .9
)

mod &lt;- define_strategy(
  transition = mat,
  A = define_state(cost = 10),
  B = define_state(cost = 2)
)

heemod:::eval_strategy(
  strategy = mod,
  parameters = param,
  init = define_init(A = 10, B = 5),
  cycles = 5,
  method = "end",
  inflow = define_inflow(A = 0, B = 0),
  strategy_name = "A",
  expand_limit = c(A = 5, B = 5)
)
</code></pre>

<hr>
<h2 id='expand_state'>Expand Time-Dependent States into Tunnel States</h2><span id='topic+expand_state'></span><span id='topic+expand_state.uneval_matrix'></span><span id='topic+expand_state.uneval_state_list'></span><span id='topic+expand_state.uneval_inflow'></span><span id='topic+expand_state.uneval_init'></span>

<h3>Description</h3>

<p>This function for transition matrices and state values
expands states relying on <code>state_time</code> in a series
of tunnels states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_state(x, ...)

## S3 method for class 'uneval_matrix'
expand_state(x, state_pos, state_name, cycles, n = 1, ...)

## S3 method for class 'uneval_state_list'
expand_state(x, state_name, cycles, ...)

## S3 method for class 'uneval_inflow'
expand_state(x, ...)

## S3 method for class 'uneval_init'
expand_state(x, state_name, cycles, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_state_+3A_x">x</code></td>
<td>
<p>A transition matrix or a state list.</p>
</td></tr>
<tr><td><code id="expand_state_+3A_...">...</code></td>
<td>
<p>Addition parameters passed to methods.</p>
</td></tr>
<tr><td><code id="expand_state_+3A_state_pos">state_pos</code></td>
<td>
<p>Position of the state to expand.</p>
</td></tr>
<tr><td><code id="expand_state_+3A_state_name">state_name</code></td>
<td>
<p>Original name of the sate to expand.</p>
</td></tr>
<tr><td><code id="expand_state_+3A_cycles">cycles</code></td>
<td>
<p>Number of cycle of the model.</p>
</td></tr>
<tr><td><code id="expand_state_+3A_n">n</code></td>
<td>
<p>Position in the expansion process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object type as the input.
</p>

<hr>
<h2 id='export_savi'>Export PSA Results for SAVI</h2><span id='topic+export_savi'></span>

<h3>Description</h3>

<p>Export the result of a PSA in a format compatible with
Sheffield Accelerated Value of Information software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_savi(x, folder = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_savi_+3A_x">x</code></td>
<td>
<p>PSA result.</p>
</td></tr>
<tr><td><code id="export_savi_+3A_folder">folder</code></td>
<td>
<p>A folder where to save the <code>csv</code> files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves 3 files at the path given by
<code>folder</code>: <code>param.csv</code>, the parameter values,
<code>cost.csv</code> and <code>effect.csv</code> the cost and effect
results.
</p>
<p>The official SAVI website can be found at this URL:
https://savi.shef.ac.uk/SAVI/
</p>


<h3>Value</h3>

<p>Nothing. Creates 3 files.
</p>

<hr>
<h2 id='extract_params'>Extract Evaluated Parameters</h2><span id='topic+extract_params'></span>

<h3>Description</h3>

<p>Extracts the covariate-adjusted parameters from a
<code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_params(obj, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_params_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code> object.</p>
</td></tr>
<tr><td><code id="extract_params_+3A_data">data</code></td>
<td>
<p>An optional dataset of covariate values to
generate parameters for. Defaults to the original data
to which the model was fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame of curve parameters for each
covariate level.
</p>

<hr>
<h2 id='extract_strata'>Extract Product-Limit Tables</h2><span id='topic+extract_strata'></span>

<h3>Description</h3>

<p>Extracts the product-limit table from a survfit object
for all strata. Only <code>survfit</code> and unstratified
<code>survfit.coxph</code> objects are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_strata(sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_strata_+3A_sf">sf</code></td>
<td>
<p>A survfit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data.frame of the product-limit tables for
all strata.
</p>

<hr>
<h2 id='extract_stratum'>Extract Product-Limit Table for a Stratum</h2><span id='topic+extract_stratum'></span>

<h3>Description</h3>

<p>Extracts the product-limit table from a survfit object
for a given stratum. Only <code><a href="survival.html#topic+survfit">survival::survfit()</a></code> objects are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_stratum(sf, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_stratum_+3A_sf">sf</code></td>
<td>
<p>A survfit object.</p>
</td></tr>
<tr><td><code id="extract_stratum_+3A_index">index</code></td>
<td>
<p>The index number of the strata to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the product-limit table for the
given stratum.
</p>

<hr>
<h2 id='filter_blanks'>Remove Blank Rows From Table</h2><span id='topic+filter_blanks'></span>

<h3>Description</h3>

<p>Remove rows were all values are <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_blanks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_blanks_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some rows can be left blanks in the input table for
readability, this function ensures those rows are
removed.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> without blank rows.
</p>

<hr>
<h2 id='gather_model_info'>Gather Information for Running a Model From Tabular Data</h2><span id='topic+gather_model_info'></span>

<h3>Description</h3>

<p>Gather Information for Running a Model From Tabular Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_model_info(base_dir, ref_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_model_info_+3A_base_dir">base_dir</code></td>
<td>
<p>Directory where the files are located.</p>
</td></tr>
<tr><td><code id="gather_model_info_+3A_ref_file">ref_file</code></td>
<td>
<p>Name of the reference file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
 <ul>
<li><p> models (of
type <code>uneval_model</code>, created by
<code><a href="#topic+create_model_list_from_tabular">create_model_list_from_tabular()</a></code>) </p>
</li>
<li>
<p>param_info  </p>
</li>
<li><p> output_dir where to store output
files, if specified </p>
</li>
<li><p> demographic_file a table for
demographic analysis </p>
</li>
<li><p> model_options a list of
model options.</p>
</li></ul>


<hr>
<h2 id='get_counts_diff'>Get count matrix and difference between two cycles</h2><span id='topic+get_counts_diff'></span>

<h3>Description</h3>

<p>Get count matrix and difference between two cycles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts_diff(x, init, inflow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_counts_diff_+3A_x">x</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code id="get_counts_diff_+3A_init">init</code></td>
<td>
<p>numeric vector, same length as number of
model states. Number of individuals in each model state
at the beginning.</p>
</td></tr>
<tr><td><code id="get_counts_diff_+3A_inflow">inflow</code></td>
<td>
<p>numeric vector, similar to <code>init</code>.
Number of new individuals in each state per cycle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length 2 list of matrix : the count matrix for each cycle and the diff matrix
showing the difference of counts between two cycles.
</p>

<hr>
<h2 id='get_counts.updated_model'>Get State Membership Counts</h2><span id='topic+get_counts.updated_model'></span><span id='topic+get_counts.combined_model'></span><span id='topic+get_counts'></span><span id='topic+get_counts.run_model'></span><span id='topic+get_counts.eval_strategy'></span><span id='topic+get_counts.list'></span>

<h3>Description</h3>

<p>Given a result from <code><a href="#topic+run_model">run_model()</a></code>, return
state membership counts for a specific strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'updated_model'
get_counts(x, ...)

## S3 method for class 'combined_model'
get_counts(x, ...)

get_counts(x, ...)

## S3 method for class 'run_model'
get_counts(x, ...)

## S3 method for class 'eval_strategy'
get_counts(x, ...)

## S3 method for class 'list'
get_counts(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_counts.updated_model_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="get_counts.updated_model_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other
methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of counts per state.
</p>

<hr>
<h2 id='get_frontier'>Return Efficiency Frontier</h2><span id='topic+get_frontier'></span>

<h3>Description</h3>

<p>Return Efficiency Frontier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_frontier(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_frontier_+3A_x">x</code></td>
<td>
<p>An <code>eval_strategy_list</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of model names on the efficiency
frontier.
</p>

<hr>
<h2 id='get_mat_total'>Get count number</h2><span id='topic+get_mat_total'></span>

<h3>Description</h3>

<p>Get count number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mat_total(x, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mat_total_+3A_x">x</code></td>
<td>
<p>transition matrix</p>
</td></tr>
<tr><td><code id="get_mat_total_+3A_init">init</code></td>
<td>
<p>numeric vector, same length as number of
model states. Number of individuals in each model state
at the beginning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A count matrix
</p>

<hr>
<h2 id='get_matrix_order'>Return Markov Model Transition Matrix Order</h2><span id='topic+get_matrix_order'></span>

<h3>Description</h3>

<p>A generic that works both with <code>uneval_matrix</code> and
<code>eval_matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_matrix_order(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_matrix_order_+3A_x">x</code></td>
<td>
<p>A transition matrix, evaluated or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use.
</p>


<h3>Value</h3>

<p>An integer: matrix order.
</p>

<hr>
<h2 id='get_parameter_names'>Return parameters names</h2><span id='topic+get_parameter_names'></span>

<h3>Description</h3>

<p>Extract parameters names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameter_names_+3A_x">x</code></td>
<td>
<p>An object with parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameter names.
</p>

<hr>
<h2 id='get_state_names'>Get State Names</h2><span id='topic+get_state_names'></span>

<h3>Description</h3>

<p>Retrieve state names from an object containing states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_names_+3A_x">x</code></td>
<td>
<p>An object containing states.</p>
</td></tr>
<tr><td><code id="get_state_names_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of state names.
</p>

<hr>
<h2 id='get_state_number'>Return Number of State</h2><span id='topic+get_state_number'></span>

<h3>Description</h3>

<p>For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_number(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_number_+3A_x">x</code></td>
<td>
<p>An object containing states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Work with both <code>uneval_states</code> and
<code>eval_states</code>.
</p>


<h3>Value</h3>

<p>An integer: number of states.
</p>

<hr>
<h2 id='get_state_value_names'>Return Names of State Values</h2><span id='topic+get_state_value_names'></span>

<h3>Description</h3>

<p>Return Names of State Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state_value_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_value_names_+3A_x">x</code></td>
<td>
<p>An object containing states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of state value names.
</p>

<hr>
<h2 id='get_transition'>Get Markov Model Transition Matrix</h2><span id='topic+get_transition'></span>

<h3>Description</h3>

<p>Works on both unevaluated and evaluated models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_transition_+3A_x">x</code></td>
<td>
<p>An <code>uneval_model</code> or <code>eval_model</code>
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>uneval_matrix</code> or <code>uneval_matrix</code>
object.
</p>

<hr>
<h2 id='get_values.updated_model'>Get Strategy Values</h2><span id='topic+get_values.updated_model'></span><span id='topic+get_values.combined_model'></span><span id='topic+get_values'></span><span id='topic+get_values.run_model'></span><span id='topic+get_values.eval_strategy'></span><span id='topic+get_values.list'></span>

<h3>Description</h3>

<p>Given a result from <code><a href="#topic+run_model">run_model()</a></code>, return
cost and effect values for a specific strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'updated_model'
get_values(x, ...)

## S3 method for class 'combined_model'
get_values(x, ...)

get_values(x, ...)

## S3 method for class 'run_model'
get_values(x, ...)

## S3 method for class 'eval_strategy'
get_values(x, ...)

## S3 method for class 'list'
get_values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_values.updated_model_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="get_values.updated_model_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other
methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of values per state.
</p>

<hr>
<h2 id='insert'>Insert Elements in Vector</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>Insert a vector in another vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(x, pos, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_x">x</code></td>
<td>
<p>A vector (or a list).</p>
</td></tr>
<tr><td><code id="insert_+3A_pos">pos</code></td>
<td>
<p>Integer. Insert after which elements?</p>
</td></tr>
<tr><td><code id="insert_+3A_what">what</code></td>
<td>
<p>Vector of elements to insert.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To insert an element at the beginning use a <code>pos</code>
value of 0.
</p>
<p>Duplicated positions are not allowed.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
heemod:::insert(letters, c(0, 5, 26), c("xxx", "yyy"))

</code></pre>

<hr>
<h2 id='interpolate'>Interpolate Quosures</h2><span id='topic+interpolate'></span><span id='topic+interpolate.default'></span><span id='topic+interpolate.uneval_matrix'></span><span id='topic+interpolate.state'></span><span id='topic+interpolate.part_surv'></span><span id='topic+interpolate.uneval_state_list'></span>

<h3>Description</h3>

<p>Sequentially interpolates quosures, optionally using
external references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(x, ...)

## Default S3 method:
interpolate(x, more = NULL, ...)

## S3 method for class 'uneval_matrix'
interpolate(x, ...)

## S3 method for class 'state'
interpolate(x, ...)

## S3 method for class 'part_surv'
interpolate(x, ...)

## S3 method for class 'uneval_state_list'
interpolate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_x">x</code></td>
<td>
<p>A parameter, transition matrix or state list
object.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_...">...</code></td>
<td>
<p>Addition parameters passed to methods.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_more">more</code></td>
<td>
<p>A list of expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interpolation is sequential: the second dot is
interpolated using the first, the third using the
interpolated first two, and so on.
</p>


<h3>Value</h3>

<p>An interpolated quosures object.
</p>

<hr>
<h2 id='is_csv'>Check File Type</h2><span id='topic+is_csv'></span><span id='topic+is_xlsx'></span><span id='topic+is_xls'></span>

<h3>Description</h3>

<p>Check File Type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_csv(x)

is_xlsx(x)

is_xls(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_csv_+3A_x">x</code></td>
<td>
<p>A file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the file is (respectively)
csv, xlsx, or xls.
</p>

<hr>
<h2 id='is.wholenumber'>Check whole Numbers</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Check whole Numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>the smallest positive floating-point number x
such that 1 + x != 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar.
</p>

<hr>
<h2 id='join'>Project Beyond a Survival Distribution with Another</h2><span id='topic+join'></span><span id='topic+join_'></span>

<h3>Description</h3>

<p>Project survival from a survival distribution using one
or more survival distributions using the specified cut points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(..., at)

join_(dots, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p>Survival distributions to be used in the
projection.</p>
</td></tr>
<tr><td><code id="join_+3A_at">at</code></td>
<td>
<p>A vector of times corresponding to the cut
point(s) to be used.</p>
</td></tr>
<tr><td><code id="join_+3A_dots">dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_projection</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .5)
dist2 &lt;- define_surv_dist(distribution = "gompertz", rate = .5, shape = 1)
join_dist &lt;- join(dist1, dist2, at=20)
</code></pre>

<hr>
<h2 id='list_all_same'>Check if All the Elements of a List Are the Same</h2><span id='topic+list_all_same'></span>

<h3>Description</h3>

<p>Check if All the Elements of a List Are the Same
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_all_same(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_all_same_+3A_x">x</code></td>
<td>
<p>a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar.
</p>

<hr>
<h2 id='load_surv_models'>Load a set of survival fits</h2><span id='topic+load_surv_models'></span>

<h3>Description</h3>

<p>Load a set of survival fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_surv_models(location, survival_specs, use_envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_surv_models_+3A_location">location</code></td>
<td>
<p>base directory</p>
</td></tr>
<tr><td><code id="load_surv_models_+3A_survival_specs">survival_specs</code></td>
<td>
<p>information about fits</p>
</td></tr>
<tr><td><code id="load_surv_models_+3A_use_envir">use_envir</code></td>
<td>
<p>an environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:  </p>

<ul>
<li><p><code>best_models</code>,
a list with the fits for each data file passed in; and
</p>
</li>
<li><p><code>envir</code>,
an environment containing the models so they can be referenced to
get probabilities.
</p>
</li></ul>


<hr>
<h2 id='look_up'>Look Up Values in a Data Frame</h2><span id='topic+look_up'></span>

<h3>Description</h3>

<p>A convenience function to easily look for values in a
data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>look_up(data, ..., bin = FALSE, value = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="look_up_+3A_data">data</code></td>
<td>
<p>A reference data frame.</p>
</td></tr>
<tr><td><code id="look_up_+3A_...">...</code></td>
<td>
<p>Individual characteristics, should be named
like the columns of <code>data</code>.</p>
</td></tr>
<tr><td><code id="look_up_+3A_bin">bin</code></td>
<td>
<p>Either logical: should all numeric variable be
binned, or character vector giving the names of
variables to bin (see examples).</p>
</td></tr>
<tr><td><code id="look_up_+3A_value">value</code></td>
<td>
<p>The value to extract from the reference
data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly used to extract population
informations (such as mortality rates), given some
individual characteristics.
</p>
<p>If binning is activated, numeric individual
characteristics are matched to the corresponding
reference value that is directly inferior.
</p>


<h3>Value</h3>

<p>A vector of values, same length as <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempdf &lt;- expand.grid(arg1 = c("A", "B", "C"), arg2 = 1:4, arg3 = 1:5)
tempdf$value &lt;- 1:60

look_up(
  data = tempdf,
  value = "value",
  arg1 = c("A", "B", "C", "B", "A"),
  arg2 = c(1, 1, 3.2, 3.0, 5), 
  arg3 = c(-1, 1, 1, 2, 3)
)

# binning doesnt catch values lesser than the smaller
# reference value
look_up(
  data = tempdf,
  value = "value",
  arg1 = c("A", "B", "C", "B", "A"),
  arg2 = c(1, 1, 3.2, 3.0, 5), 
  arg3 = c(-1, 1, 1, 2, 3),
  bin = TRUE
)
# bin can alos be given as a charater vector
# to avoid binning all numeric variables
look_up(
  data = tempdf,
  value = "value",
  arg1 = c("A", "B", "C", "B", "A"),
  arg2 = c(1, 1, 3.2, 3.0, 5), 
  arg3 = c(-1, 1, 1, 2, 3),
  bin = c("arg2")
)

age_related_df &lt;- data.frame(age = 10 * 0:9, decade = 1:10)

look_up(age_related_df, age = c(0, 10, 20), value = "decade")

# binning might help in the situation
look_up(age_related_df, age = c(5, 15, 23.5), 
        value = "decade")
look_up(age_related_df, age = c(5, 15, 23.5), 
        value = "decade", bin = TRUE)
</code></pre>

<hr>
<h2 id='make_names'>Make Syntactically Valid Names</h2><span id='topic+make_names'></span>

<h3>Description</h3>

<p>Compared to <code><a href="base.html#topic+make.names">make.names()</a></code> this function also
converts characters to lower case and replaces <code>.</code>
by <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_names_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='mix'>Mix Two or More Survival Distributions</h2><span id='topic+mix'></span><span id='topic+mix_'></span>

<h3>Description</h3>

<p>Mix a set of survival distributions using the specified
weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix(..., weights = 1)

mix_(dots, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mix_+3A_...">...</code></td>
<td>
<p>Survival distributions to be used in the
projection.</p>
</td></tr>
<tr><td><code id="mix_+3A_weights">weights</code></td>
<td>
<p>A vector of weights used in pooling.</p>
</td></tr>
<tr><td><code id="mix_+3A_dots">dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_pooled</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dist1 &lt;- define_surv_dist(distribution = "exp", rate = .5)
dist2 &lt;- define_surv_dist(distribution = "gompertz", rate = .5, shape = 1)
pooled_dist &lt;- mix(dist1, dist2, weights = c(0.25, 0.75))

</code></pre>

<hr>
<h2 id='modify'>Modify Object</h2><span id='topic+modify'></span>

<h3>Description</h3>

<p>This generic function allows the modification of various
objects such as parameters, transitions matrix or states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify(.OBJECT, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_+3A_.object">.OBJECT</code></td>
<td>
<p>Various objects.</p>
</td></tr>
<tr><td><code id="modify_+3A_...">...</code></td>
<td>
<p>Modifications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available on the respective help page of
each object definition.
</p>


<h3>Value</h3>

<p>Same class as <code>x</code>.
</p>

<hr>
<h2 id='parse_multi_spec'>Specify Inputs for Multiple Models From a Single File</h2><span id='topic+parse_multi_spec'></span>

<h3>Description</h3>

<p>Parse a <code>data.frame</code> containing specifications for
multiple models into a list of inputs required for each
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_multi_spec(multi_spec, split_on = ".model", group_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_multi_spec_+3A_multi_spec">multi_spec</code></td>
<td>
<p><code style="white-space: pre;">&#8288;data frame&#8288;</code>.</p>
</td></tr>
<tr><td><code id="parse_multi_spec_+3A_split_on">split_on</code></td>
<td>
<p><code>character</code> of length 1, with the
name of the variable in <code>multi_spec</code> to be split
on.</p>
</td></tr>
<tr><td><code id="parse_multi_spec_+3A_group_vars">group_vars</code></td>
<td>
<p><code>character</code>, one or more variable
names from <code>multi_spec</code> that identify a line of
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each combination of values of the columns specified by
<code>group_vars</code> should either be unique in the file (in
which case it will be replicated for all values of
<code>split_on</code>), or must be repeated as many times as
unique values of <code>split_on</code>.
</p>
<p><code>split_on</code> is usually the model name.
</p>
<p><code>group_var</code> can be the state names, or from and to
lines for a matrix definition...
</p>


<h3>Value</h3>

<p>A list of data frames, one for each value of
<code>split_on.</code>
</p>

<hr>
<h2 id='part_survs_from_surv_inputs'>Convert saved fits to partitioned survival objects</h2><span id='topic+part_survs_from_surv_inputs'></span>

<h3>Description</h3>

<p>Convert saved fits to partitioned survival objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_survs_from_surv_inputs(surv_inputs, state_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="part_survs_from_surv_inputs_+3A_surv_inputs">surv_inputs</code></td>
<td>
<p>a list of matrices of <code>flexsurvreg</code> objects,
for example the first element of the output of <code>survival_from_data</code>.</p>
</td></tr>
<tr><td><code id="part_survs_from_surv_inputs_+3A_state_names">state_names</code></td>
<td>
<p>names of states of the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>surv_inputs is a tibble with columns
type (PFS or OS, not case sensitive), treatment,
set_name (for data subsets),
dist (for survival distribution assumptions),
fit (for the fitted survival object) and set_def
(how the subset of data was defined, just to keep it around)
</p>


<h3>Value</h3>

<p>a tibble of partitioned survival objects, similar to the
original tibble of survival fits, with all the columns
except type and fit, and a new column part_surv.
</p>

<hr>
<h2 id='plot.dsa'>Plot Sensitivity Analysis</h2><span id='topic+plot.dsa'></span>

<h3>Description</h3>

<p>Plot the results of a sensitivity analysis as a tornado
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsa'
plot(
  x,
  type = c("simple", "difference"),
  result = c("cost", "effect", "icer"),
  strategy = NULL,
  widest_on_top = TRUE,
  limits_by_bars = TRUE,
  resolve_labels = FALSE,
  shorten_labels = FALSE,
  remove_ns = FALSE,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dsa_+3A_x">x</code></td>
<td>
<p>A result of <code><a href="#topic+run_dsa">run_dsa()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_type">type</code></td>
<td>
<p>Type of plot (see details).</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_result">result</code></td>
<td>
<p>Plot cost, effect, or ICER.</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_strategy">strategy</code></td>
<td>
<p>Name or index of strategies to plot.</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_widest_on_top">widest_on_top</code></td>
<td>
<p>logical. Should bars be sorted so
widest are on top?</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_limits_by_bars">limits_by_bars</code></td>
<td>
<p>logical. Should the limits used
for each parameter be printed in the plot, next to the
bars?</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_resolve_labels">resolve_labels</code></td>
<td>
<p>logical. Should we resolve all
labels to numbers instead of expressions (if there are
any)?</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_shorten_labels">shorten_labels</code></td>
<td>
<p>logical. Should we shorten the
presentation of the parameters on the plot to highlight
where the values differ?</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_remove_ns">remove_ns</code></td>
<td>
<p>Remove variables that are not sensitive.</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_bw">bw</code></td>
<td>
<p>Black &amp; white plot for publications?</p>
</td></tr>
<tr><td><code id="plot.dsa_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot type <code>simple</code> plots variations of single strategy
values, while <code>difference</code> plots incremental values.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.psa'>Plot Results of Probabilistic Analysis</h2><span id='topic+plot.psa'></span>

<h3>Description</h3>

<p>Various plots for Markov models probabilistic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psa'
plot(
  x,
  type = c("ce", "ac", "cov", "evpi"),
  max_wtp = 1e+05,
  n = 100,
  log_scale = TRUE,
  diff = FALSE,
  threshold,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.psa_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_type">type</code></td>
<td>
<p>Type of plot, see details.</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_max_wtp">max_wtp</code></td>
<td>
<p>Maximal willingness to pay.</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_n">n</code></td>
<td>
<p>Number of CECA points to estimate (values above
100 may take significant time).</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_log_scale">log_scale</code></td>
<td>
<p>Show willingness to pay on a log scale?</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_diff">diff</code></td>
<td>
<p>Logical, perform covariance analysis on
strategy differences?</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_threshold">threshold</code></td>
<td>
<p>When <code>diff = TRUE</code>, threshold value
for net monetary benefit computation.</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_bw">bw</code></td>
<td>
<p>Black &amp; white plot for publications?</p>
</td></tr>
<tr><td><code id="plot.psa_+3A_...">...</code></td>
<td>
<p>Additional arguments, depends on <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type = "ac"</code> plots cost-effectiveness acceptability
curves, <code>type = "ce"</code> plots results on the
cost-efficiency plane, <code>type = "cov"</code> to perform
covariance analysis on the results, <code>type = "evpi"</code>
for expected value of perfect information.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.run_model'>Plot Results of a Markov Model</h2><span id='topic+plot.run_model'></span>

<h3>Description</h3>

<p>Various plots for Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'run_model'
plot(
  x,
  type = c("counts", "ce", "values"),
  panels = c("by_strategy", "by_state", "by_value"),
  values = NULL,
  strategy = NULL,
  states = NULL,
  free_y = FALSE,
  bw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.run_model_+3A_x">x</code></td>
<td>
<p>Result from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_type">type</code></td>
<td>
<p>Type of plot, see details.</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_panels">panels</code></td>
<td>
<p>Should plots be faceted by model, by
value or by state?</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_values">values</code></td>
<td>
<p>Names of values to be plotted. These can be
any of the costs or effects defined in states.</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_strategy">strategy</code></td>
<td>
<p>Name or position of model(s) of interest.</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_states">states</code></td>
<td>
<p>Names of states to be included in
the plot.</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_free_y">free_y</code></td>
<td>
<p>Should y limits be free between panels?</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_bw">bw</code></td>
<td>
<p>Black &amp; white plot for publications?</p>
</td></tr>
<tr><td><code id="plot.run_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>plot</code>.
</p>
<p><code>type = "counts"</code> represents state
memberships (corrected) by cycle, <code>type = "ce"</code>
plots models on the cost-efficiency plane with the
efficiency frontier, and <code>type = "values"</code> state
values per cycle.
</p>
<p>When <code>states</code> is specified, the states will be turned into
a factor with the ordering given in the variable, so that
plotting order can be controlled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These examples require \code{res_mod} from the hip replacement model discussed in
## `vignette("non-homogeneous", package = "heemod")`.

## Not run: 
  plot(res_mod)

  plot(res_mod, model = "all")
  plot(res_mod, model = "all", panels = "by_state")

  plot(res_mod, model = "all", include_states = c("RevisionTHR", "SuccessR"))
  plot(res_mod, model = "all", panels = "by_state", include_states = c("RevisionTHR", "SuccessR"))
 
  plot(res_mod, model = 2, panel = "by_state", include_states = c("RevisionTHR", "SuccessR"))
  

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.surv_object'>Plot general survival models</h2><span id='topic+plot.surv_object'></span>

<h3>Description</h3>

<p>Plot general survival models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'surv_object'
plot(
  x,
  times = seq.int(0, 30),
  type = c("surv", "prob"),
  psa,
  Nrep = 100,
  join_opts = list(join_col = "red", join_pch = 20, join_size = 3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.surv_object_+3A_x">x</code></td>
<td>
<p>a survival object of class <code>surv_aft</code>, <code>surv_add_haz</code>,
<code>surv_ph</code>, <code>surv_po</code>, <code>surv_model</code>, <code>surv_pooled</code>, or <code>surv_projection</code>.</p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_times">times</code></td>
<td>
<p>Times at which to evaluate and plot the survival object.</p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_type">type</code></td>
<td>
<p>either <code>surv</code> (the default) or <code>prob</code>, depending on whether
you want to plot survival from the start or conditional probabilities.</p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_psa">psa</code></td>
<td>
<p>a <code>define_psa</code> object</p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_nrep">Nrep</code></td>
<td>
<p>The number of replications to estimate the variability of <code>x</code></p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_join_opts">join_opts</code></td>
<td>
<p>A list of 3 graphical parameters for points at which different
survival functions are joined: join_col, join_pch and join_size.</p>
</td></tr>
<tr><td><code id="plot.surv_object_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>compute_surv</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently only highlights join points that are at
the top level; that is, for objects with class <code>surv_projection</code>.
To avoid plotting the join points, set join_size to a negative number.
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Evaluation of the variability of the survival distribution

surv1 &lt;- define_surv_dist("exp", rate = 0.1)
psa &lt;- define_psa(surv1 ~ resample_surv(n = 100))
plot(surv1, psa=psa)

## plot surv_projection object
surv2 &lt;- define_surv_dist("exp", rate = 0.5)
plot(join(surv1, surv2, at = 2), psa = psa, Nrep = 50)

## surv_fit object
library(survival)
km &lt;- define_surv_fit(survfit(formula = Surv(time, status) ~ 1, data = aml))
fs &lt;- flexsurv::flexsurvreg(formula = Surv(time, status) ~ 1, 
                        data = aml, 
                        dist = "weibull") |&gt;
  define_surv_fit()

psa2 &lt;- define_psa(km ~ resample_surv(),
                   fs ~ resample_surv(),
                   surv1 ~ resample_surv(100))
plot(km, psa = psa2)

plot(join(km, surv1, at = 6), psa = psa2)
plot(join(fs, surv1, at = 6), psa = psa2)

</code></pre>

<hr>
<h2 id='plur'>Returns &quot;s&quot; if x &gt; 1</h2><span id='topic+plur'></span><span id='topic+plur_y'></span>

<h3>Description</h3>

<p>Returns &quot;s&quot; if x &gt; 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plur(x)

plur_y(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plur_+3A_x">x</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"s"</code> or <code>""</code>.
</p>

<hr>
<h2 id='probability'>Convenience Functions to Compute Probabilities</h2><span id='topic+probability'></span><span id='topic+rescale_prob'></span><span id='topic+prob_to_prob'></span><span id='topic+rate_to_prob'></span><span id='topic+or_to_prob'></span><span id='topic+rr_to_prob'></span>

<h3>Description</h3>

<p>These convenience functions make it easier to compute
transition probabilities from incidence rates, OR, RR, or
probabilities estimated on a different timeframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_prob(p, to = 1, from = 1)

prob_to_prob(...)

rate_to_prob(r, to = 1, per = 1)

or_to_prob(or, p)

rr_to_prob(rr, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_+3A_p">p</code></td>
<td>
<p>Probability.</p>
</td></tr>
<tr><td><code id="probability_+3A_to">to</code></td>
<td>
<p>Compute probability for that timeframe.</p>
</td></tr>
<tr><td><code id="probability_+3A_from">from</code></td>
<td>
<p>Timeframe of the original probability.</p>
</td></tr>
<tr><td><code id="probability_+3A_...">...</code></td>
<td>
<p>For deprecated functions.</p>
</td></tr>
<tr><td><code id="probability_+3A_r">r</code></td>
<td>
<p>Rate.</p>
</td></tr>
<tr><td><code id="probability_+3A_per">per</code></td>
<td>
<p>Number of person-time corresponding to the
rate.</p>
</td></tr>
<tr><td><code id="probability_+3A_or">or</code></td>
<td>
<p>Odds ratio.</p>
</td></tr>
<tr><td><code id="probability_+3A_rr">rr</code></td>
<td>
<p>Relative risk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert 5-year probability 
# to 1-year probability
rescale_prob(p = .65, from = 5)

# convert 1-year probability 
# to 1-month probability
rescale_prob(p = .5, to = 1/12)

# convert rate per 1000 PY
# to 5-year probability
rate_to_prob(r = 162, per = 1000, to = 5)

# convert OR to probability
or_to_prob(or = 1.9, p = .51)

# convert RR to probability
rr_to_prob(rr = 1.9, p = .51)
</code></pre>

<hr>
<h2 id='project_fn'>Project Beyond a Survival Distribution with Another
(pairwise)</h2><span id='topic+project_fn'></span>

<h3>Description</h3>

<p>Project survival from a survival distribution using
another survival distribution at the specified cutpoint.
Used by project to reduce the list of distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_fn(dist1, dist2_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_fn_+3A_dist1">dist1</code></td>
<td>
<p>Survival distribution to project from.</p>
</td></tr>
<tr><td><code id="project_fn_+3A_dist2_list">dist2_list</code></td>
<td>
<p>A list containing distribution to
project with and the time at which projection begins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_projection</code> object.
</p>

<hr>
<h2 id='read_file'>Read the accepted file formats for tabular input</h2><span id='topic+read_file'></span>

<h3>Description</h3>

<p>Columns starting with '.comment' are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_file(file_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_file_+3A_file_name">file_name</code></td>
<td>
<p>File name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reindent_transition'>Reindent Transition Matrix</h2><span id='topic+reindent_transition'></span>

<h3>Description</h3>

<p>Reindent Transition Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindent_transition(x, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindent_transition_+3A_x">x</code></td>
<td>
<p>A transition matrix.</p>
</td></tr>
<tr><td><code id="reindent_transition_+3A_print">print</code></td>
<td>
<p>Print result?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reindented matrix as a text string,
invisibly.
</p>

<hr>
<h2 id='resample_surv'>Resample survival distribution</h2><span id='topic+resample_surv'></span><span id='topic+resample_surv_boot'></span><span id='topic+resample_surv_dist'></span><span id='topic+r_resample_surv_dist'></span><span id='topic+r_boot_survfit'></span>

<h3>Description</h3>

<p>Resample survival distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_surv(n)

resample_surv_boot(x)

resample_surv_dist(x, n)

r_resample_surv_dist(distribution, type, args)

r_boot_survfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_surv_+3A_n">n</code></td>
<td>
<p>the number of observations to generate if dist is specified or x is a <code>surv_dist</code>
object
</p>
<p>The lower n is, the higher is the variability</p>
</td></tr>
<tr><td><code id="resample_surv_+3A_x">x</code></td>
<td>
<p>a <code>surv_object</code></p>
</td></tr>
</table>

<hr>
<h2 id='rescale_discount_rate'>Rescale Discount Rate</h2><span id='topic+rescale_discount_rate'></span>

<h3>Description</h3>

<p>Rescale a discount rate between two time frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_discount_rate(x, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_discount_rate_+3A_x">x</code></td>
<td>
<p>Discount rate to rescale.</p>
</td></tr>
<tr><td><code id="rescale_discount_rate_+3A_from">from</code></td>
<td>
<p>Original time period.</p>
</td></tr>
<tr><td><code id="rescale_discount_rate_+3A_to">to</code></td>
<td>
<p>Final time period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Continuous discounting is assumed, i.e. when converting a
long-term discount rate into a short-term rate, we assume
that a partial gain from one short term is
multiplicatively discounted in all following short terms.
At the same time, we assume the short-term rate is
time-invariant.
</p>


<h3>Value</h3>

<p>Rate rescaled under the assumption of compound
discounting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## 1% monthly interest rate to annual
  rescale_discount_rate(0.01, 1, 12)
  ## 3% annual discount rate to (approximately) weekly 
  rescale_discount_rate(0.03, 52, 1)
</code></pre>

<hr>
<h2 id='run_bcea'>Use the BCEA package</h2><span id='topic+run_bcea'></span>

<h3>Description</h3>

<p>Interfaces the output of <code><a href="#topic+run_psa">run_psa()</a></code> into the BCEA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_bcea(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_bcea_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+run_psa">run_psa()</a></code>.</p>
</td></tr>
<tr><td><code id="run_bcea_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="BCEA.html#topic+bcea">BCEA::bcea()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BCEA package is needed for this function to work.
</p>


<h3>Value</h3>

<p>A BCEA analysis.
</p>

<hr>
<h2 id='run_dsa'>Run Sensitivity Analysis</h2><span id='topic+run_dsa'></span>

<h3>Description</h3>

<p>Run Sensitivity Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_dsa(model, dsa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_dsa_+3A_model">model</code></td>
<td>
<p>An evaluated Markov model.</p>
</td></tr>
<tr><td><code id="run_dsa_+3A_dsa">dsa</code></td>
<td>
<p>An object returned by
<code><a href="#topic+define_dsa">define_dsa()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per model and
parameter value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- define_parameters(
  p1 = .5,
  p2 = .2,
  r = .05
)
mod1 &lt;- define_strategy(
  transition = define_transition(
    C, p1,
    p2, C
  ),
  define_state(
    cost = discount(543, r),
    ly = 1
  ),
  define_state(
    cost = discount(432, r),
    ly = .5
  )
)

mod2 &lt;- define_strategy(
  transition = define_transition(
    C, p1,
    p2, C
  ),
  define_state(
    cost = 789,
    ly = 1
  ),
  define_state(
    cost = 456,
    ly = .8
  )
)

res2 &lt;- run_model(
  mod1, mod2,
  parameters = param,
  init = c(100, 0),
  cycles = 10,
  cost = cost,
  effect = ly
)

ds &lt;- define_dsa(
  p1, .1, .9,
  p2, .1, .3,
  r, .05, .1
)
print(ds)



#'\dontrun{
#'x &lt;- run_dsa(res2, ds)
#'plot(x, value = "cost")
#'}
#'
#'
# can be specified as a function of other parameters


ds2 &lt;- define_dsa(
  p2, p1 - .1, p1 + .1
)

#'\dontrun{
#'run_dsa(res2, ds2)
#'}
</code></pre>

<hr>
<h2 id='run_model'>Run Markov Model</h2><span id='topic+run_model'></span><span id='topic+run_model_'></span>

<h3>Description</h3>

<p>Runs one or more strategy. When more than one strategy is
provided, all strategies should have the same states and
state value names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_model(
  ...,
  parameters = define_parameters(),
  init = c(1000L, rep(0L, get_state_number(get_states(list(...)[[1]])) - 1)),
  cycles = 1,
  method = c("life-table", "beginning", "end"),
  cost = NULL,
  effect = NULL,
  state_time_limit = NULL,
  central_strategy = NULL,
  inflow = rep(0L, get_state_number(get_states(list(...)[[1]])))
)

run_model_(
  uneval_strategy_list,
  parameters,
  init,
  cycles,
  method,
  cost,
  effect,
  state_time_limit,
  central_strategy,
  inflow
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_model_+3A_...">...</code></td>
<td>
<p>One or more <code>uneval_model</code> object.</p>
</td></tr>
<tr><td><code id="run_model_+3A_parameters">parameters</code></td>
<td>
<p>Optional. An object generated by
<code><a href="#topic+define_parameters">define_parameters()</a></code>.</p>
</td></tr>
<tr><td><code id="run_model_+3A_init">init</code></td>
<td>
<p>numeric vector or result of <code><a href="#topic+define_init">define_init()</a></code>,
same length as number of states. Number of individuals
in each state at the beginning.</p>
</td></tr>
<tr><td><code id="run_model_+3A_cycles">cycles</code></td>
<td>
<p>positive integer. Number of Markov Cycles
to compute.</p>
</td></tr>
<tr><td><code id="run_model_+3A_method">method</code></td>
<td>
<p>Counting method. See details.</p>
</td></tr>
<tr><td><code id="run_model_+3A_cost">cost</code></td>
<td>
<p>Names or expression to compute cost on the
cost-effectiveness plane.</p>
</td></tr>
<tr><td><code id="run_model_+3A_effect">effect</code></td>
<td>
<p>Names or expression to compute effect on
the cost-effectiveness plane.</p>
</td></tr>
<tr><td><code id="run_model_+3A_state_time_limit">state_time_limit</code></td>
<td>
<p>Optional expansion limit for
<code>state_time</code>, see details.</p>
</td></tr>
<tr><td><code id="run_model_+3A_central_strategy">central_strategy</code></td>
<td>
<p>character. The name of the
strategy at the center of the cost-effectiveness plane,
for readability.</p>
</td></tr>
<tr><td><code id="run_model_+3A_inflow">inflow</code></td>
<td>
<p>numeric vector or result of
<code><a href="#topic+define_inflow">define_inflow()</a></code>, similar to <code>init</code>. Number of new
individuals in each state per cycle.</p>
</td></tr>
<tr><td><code id="run_model_+3A_uneval_strategy_list">uneval_strategy_list</code></td>
<td>
<p>List of models, only used by
<code><a href="#topic+run_model_">run_model_()</a></code> to avoid using <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to compute comparisons strategies must be
similar (same states and state value names). Thus
strategies can only differ through transition matrix cell
values and values attached to states (but not state value
names).
</p>
<p>The initial number of individuals in each state and the
number of cycle will be the same for all strategies
</p>
<p><code>state_time_limit</code> can be specified in 3 different ways:
</p>

<ol>
<li><p> As a single value: the limit is applied to all states
in all strategies. 2. As a named vector (where names are
state names): the limits are applied to the given state
names, for all strategies. 3. As a named list of named
vectors: the limits are applied to the given state names
for the given strategies.
</p>
</li></ol>

<p>Counting method represents where the transition should occur,
based on https://journals.sagepub.com/doi/10.1177/0272989X09340585:
&quot;beginning&quot; overestimates costs and &quot;end&quot; underestimates costs.
</p>


<h3>Value</h3>

<p>A list of evaluated models with computed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># running a single model

mod1 &lt;-
  define_strategy(
    transition = define_transition(
      .5, .5,
      .1, .9
    ),
    define_state(
      cost = 543,
      ly = 1
    ),
    define_state(
      cost = 432,
      ly = 1
    )
  )


res &lt;- run_model(
  mod1,
  init = c(100, 0),
  cycles = 2,
  cost = cost,
  effect = ly
)

# running several models
mod2 &lt;-
  define_strategy(
    transition = define_transition(
      .5, .5,
      .1, .9
    ),
    define_state(
      cost = 789,
      ly = 1
    ),
    define_state(
      cost = 456,
      ly = 1
    )
    
  )


res2 &lt;- run_model(
  mod1, mod2,
  init = c(100, 0),
  cycles = 10,
  cost = cost,
  effect = ly
)
</code></pre>

<hr>
<h2 id='run_model_tabular'>Run Analyses From Files</h2><span id='topic+run_model_tabular'></span>

<h3>Description</h3>

<p>This function runs a model from tabular input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_model_tabular(
  location,
  reference = "REFERENCE.csv",
  run_dsa = TRUE,
  run_psa = TRUE,
  run_demo = TRUE,
  save = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_model_tabular_+3A_location">location</code></td>
<td>
<p>Directory where the files are located.</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_reference">reference</code></td>
<td>
<p>Name of the reference file.</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_run_dsa">run_dsa</code></td>
<td>
<p>Run DSA?</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_run_psa">run_psa</code></td>
<td>
<p>Run PSA?.</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_run_demo">run_demo</code></td>
<td>
<p>Run demographic analysis?</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_save">save</code></td>
<td>
<p>Should the outputs be saved?</p>
</td></tr>
<tr><td><code id="run_model_tabular_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the outputs be overwritten?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reference file should have two columns. <code>data</code>
can be added, having value <code>TRUE</code> where an absolute
file path is provided. <code>data</code> values must include
<code>state</code>, <code>tm</code>, and <code>parameters</code>, and can
also include <code>options</code>, <code>demographics</code> and
<code>data</code>.  The corresponding values in the <code>file</code>
column give the names of the files (located in
<code>base_dir</code>) that contain the corresponding
information - or, in the case of <code>data</code>, the
directory containing the tables to be loaded.
</p>


<h3>Value</h3>

<p>A list of evaluated models (always), and, if
appropriate input is provided, dsa (deterministic
sensitivity analysis), psa (probabilistic sensitivity
analysis) and demographics (results across different
demographic groups).
</p>

<hr>
<h2 id='run_psa'>Run Probabilistic Uncertainty Analysis</h2><span id='topic+run_psa'></span>

<h3>Description</h3>

<p>Run Probabilistic Uncertainty Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_psa(model, psa, N, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_psa_+3A_model">model</code></td>
<td>
<p>The result of <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="run_psa_+3A_psa">psa</code></td>
<td>
<p>Resampling distribution for parameters defined
by <code><a href="#topic+define_psa">define_psa()</a></code>.</p>
</td></tr>
<tr><td><code id="run_psa_+3A_n">N</code></td>
<td>
<p>&gt; 0. Number of simulation to run.</p>
</td></tr>
<tr><td><code id="run_psa_+3A_keep">keep</code></td>
<td>
<p>logical; if TRUE, all models will be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements
</p>

<ul>
<li><p> psa:  a <code>data.frame</code> with one row per model.
</p>
</li>
<li><p> run_model: a <code>data.frame</code> with mean cost and utility for each strategy
</p>
</li>
<li><p> model: the initial model object
</p>
</li>
<li><p> N: the number of simulations ran
</p>
</li>
<li><p> resamp_par: the resampled parameters
</p>
</li>
<li><p> full: if <code>keep</code> is TRUE, a list of each model objects created at each iteration
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># example for run_psa

mod1 &lt;- define_strategy(
  transition = define_transition(
    .5, .5,
    .1, .9
  ),
  define_state(
    cost = cost_init + age * 5,
    ly = 1
  ),
  define_state(
    cost = cost_init + age,
    ly = 0
  )
)

mod2 &lt;- define_strategy(
  transition = define_transition(
    p_trans, C,
    .1, .9
  ),
  define_state(
    cost = 789 * age / 10,
    ly = 1
  ),
  define_state(
    cost = 456 * age / 10,
    ly = 0
  )
  
)

res2 &lt;- run_model(
  mod1, mod2,
  parameters = define_parameters(
    age_init = 60,
    cost_init = 1000,
    age = age_init + model_time,
    p_trans = .7
  ),
  init = 1:0,
  cycles = 10,
  cost = cost,
  effect = ly
)

rsp &lt;- define_psa(
  age_init ~ normal(60, 10),
  cost_init ~ normal(1000, 100),
  p_trans ~ binomial(.7, 100),
  correlation = matrix(c(
    1,  .4, 0,
    .4, 1,  0,
    0,  0,  1
  ), byrow = TRUE, ncol = 3)
)


# with run_model result
# (only 10 resample for speed)
ndt1 &lt;- run_psa(res2, psa = rsp, N = 10)
</code></pre>

<hr>
<h2 id='safe_conversion'>Safely Convert From Characters to Numbers</h2><span id='topic+safe_conversion'></span><span id='topic+safe_convert'></span><span id='topic+as_numeric_safe'></span><span id='topic+as_integer_safe'></span>

<h3>Description</h3>

<p>These function return an error if a conversion fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safe_convert(x, f)

as_numeric_safe(x)

as_integer_safe(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safe_conversion_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="safe_conversion_+3A_f">f</code></td>
<td>
<p>A conversion function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A converted vector.
</p>

<hr>
<h2 id='save_outputs'>Save Model Outputs</h2><span id='topic+save_outputs'></span>

<h3>Description</h3>

<p>Save Model Outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_outputs(outputs, output_dir, overwrite)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_outputs_+3A_outputs">outputs</code></td>
<td>
<p>Result from
<code><a href="#topic+run_model_tabular">run_model_tabular()</a></code>.</p>
</td></tr>
<tr><td><code id="save_outputs_+3A_output_dir">output_dir</code></td>
<td>
<p>Subdirectory in which to write output.</p>
</td></tr>
<tr><td><code id="save_outputs_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the outputs be overwritten?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. Used for its side effect of creating
files in the output directory.
</p>

<hr>
<h2 id='scale.combined_model'>Normalize Cost and Effect</h2><span id='topic+scale.combined_model'></span><span id='topic+scale.psa'></span><span id='topic+heemod_scale'></span><span id='topic+scale.run_model'></span><span id='topic+scale.dsa'></span>

<h3>Description</h3>

<p>Normalize cost and effect values taking base model as a
reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_model'
scale(x, center = TRUE, scale = TRUE)

## S3 method for class 'psa'
scale(x, center = TRUE, scale = TRUE)

## S3 method for class 'run_model'
scale(x, center = TRUE, scale = TRUE)

## S3 method for class 'dsa'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale.combined_model_+3A_x">x</code></td>
<td>
<p>Result of <code><a href="#topic+run_model">run_model()</a></code> or
<code><a href="#topic+run_psa">run_psa()</a></code>.</p>
</td></tr>
<tr><td><code id="scale.combined_model_+3A_center">center</code></td>
<td>
<p>Center results around base model?</p>
</td></tr>
<tr><td><code id="scale.combined_model_+3A_scale">scale</code></td>
<td>
<p>Scale results to individual values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input with normalized <code>.cost</code> and
<code>.effect</code>, ordered by <code>.effect</code>.
</p>

<hr>
<h2 id='set_covariates'>Set Covariates of a Survival Distribution</h2><span id='topic+set_covariates'></span><span id='topic+set_covariates_'></span>

<h3>Description</h3>

<p>Set the covariate levels of a survival model to be
represented in survival projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_covariates(dist, ..., data = NULL)

set_covariates_(dist, covariates, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_covariates_+3A_dist">dist</code></td>
<td>
<p>a survfit or flexsurvreg object</p>
</td></tr>
<tr><td><code id="set_covariates_+3A_...">...</code></td>
<td>
<p>Covariate values representing the group for
which survival probabilities will be generated when
evaluated.</p>
</td></tr>
<tr><td><code id="set_covariates_+3A_data">data</code></td>
<td>
<p>A an optional data frame representing
multiple sets of covariate values for which survival
probabilities will be generated. Can be used to
generate aggregate survival for a heterogeneous set of
subjects.</p>
</td></tr>
<tr><td><code id="set_covariates_+3A_covariates">covariates</code></td>
<td>
<p>Used to work around non-standard
evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surv_model</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs1 &lt;- flexsurv::flexsurvreg(
  survival::Surv(rectime, censrec)~group,
  data=flexsurv::bc,
  dist = "llogis"
)
good_model &lt;- set_covariates(fs1, group = "Good")
cohort &lt;- data.frame(group=c("Good", "Good", "Medium", "Poor"))
mixed_model &lt;- set_covariates(fs1, data = cohort)

</code></pre>

<hr>
<h2 id='summary.run_model'>Summarise Markov Model Results</h2><span id='topic+summary.run_model'></span>

<h3>Description</h3>

<p>Summarise Markov Model Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'run_model'
summary(object, threshold = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.run_model_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.run_model_+3A_threshold">threshold</code></td>
<td>
<p>ICER threshold (possibly several) for
net monetary benefit computation.</p>
</td></tr>
<tr><td><code id="summary.run_model_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary
produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary_run_model</code> object.
</p>

<hr>
<h2 id='summary.surv_shift'>Summarize surv_shift objects</h2><span id='topic+summary.surv_shift'></span>

<h3>Description</h3>

<p>Summarize surv_shift objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'surv_shift'
summary(object, summary_type = c("plot", "standard"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.surv_shift_+3A_object">object</code></td>
<td>
<p>a <code>surv_shift</code> object</p>
</td></tr>
<tr><td><code id="summary.surv_shift_+3A_summary_type">summary_type</code></td>
<td>
<p>&quot;standard&quot; or &quot;plot&quot; - &quot;standard&quot;
for the usual summary of a <code>survfit</code> object,
&quot;plot&quot; for a fuller version</p>
</td></tr>
<tr><td><code id="summary.surv_shift_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary.
</p>

<hr>
<h2 id='update_model'>Run Model on New Data</h2><span id='topic+update_model'></span><span id='topic+update.run_model'></span><span id='topic+plot.updated_model'></span>

<h3>Description</h3>

<p>Given a table of new parameter values with a new
parameter set per line, runs iteratively Markov models
over these sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'run_model'
update(object, newdata, ...)

## S3 method for class 'updated_model'
plot(
  x,
  type = c("simple", "difference", "counts", "ce", "values"),
  result = c("cost", "effect", "icer"),
  strategy = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_model_+3A_object">object</code></td>
<td>
<p>The result of <code><a href="#topic+run_model">run_model()</a></code>.</p>
</td></tr>
<tr><td><code id="update_model_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of new parameter sets,
one column per parameter and one row per parameter set.
An optional <code>.weights</code> column can be included for
a weighted analysis.</p>
</td></tr>
<tr><td><code id="update_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code>geom_histogram</code>. Especially useful to specify
<code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="update_model_+3A_x">x</code></td>
<td>
<p>Updated model to plot.</p>
</td></tr>
<tr><td><code id="update_model_+3A_type">type</code></td>
<td>
<p>Plot simple values or differences?</p>
</td></tr>
<tr><td><code id="update_model_+3A_result">result</code></td>
<td>
<p>The the result to plot (see details).</p>
</td></tr>
<tr><td><code id="update_model_+3A_strategy">strategy</code></td>
<td>
<p>A model index, character or numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>newdata</code> must be a <code>data.frame</code> with the
following properties: the column names must be parameter
names used in <code><a href="#topic+define_parameters">define_parameters()</a></code>; and an
optional column <code>.weights</code> can give the respective
weight of each row in the target population.
</p>
<p>Weights are automatically scaled. If no weights are
provided equal weights are used for each strata.
</p>
<p>For the plotting function, the <code>type</code> argument can
take the following values: <code>"cost"</code>, <code>"effect"</code>
or <code>"icer"</code> to plot the heterogeneity of the
respective values. Furthermore <code>"ce"</code> and
<code>"count"</code> can produce from the combined model plots
similar to those of <code><a href="#topic+run_model">run_model()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per model/value.
</p>


<h3>Warning</h3>

<p>Histograms do not account for weights. On the other
hand summary results do.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;-
  define_strategy(
    transition = define_transition(
      .5, .5,
      .1, .9
    ),
    define_state(
      cost = 543 + age * 5,
      ly = 1
    ),
    define_state(
      cost = 432 + age,
      ly = 1 * age / 100
    )
  )

mod2 &lt;-
  define_strategy(
    transition = define_transition(
      .5, .5,
      .1, .9
    ),
    define_state(
      cost = 789 * age / 10,
      ly = 1
    ),
    define_state(
      cost = 456 * age / 10,
      ly = 1 * age / 200
    )
  )

res &lt;- run_model(
  mod1, mod2,
  parameters = define_parameters(
    age_init = 60,
    age = age_init + model_time
  ),
  init = 1:0,
  cycles = 10,
  cost = cost,
  effect = ly
)

# generating table with new parameter sets
new_tab &lt;- data.frame(
  age_init = 40:45
)

# with run_model result
ndt &lt;- update(res, newdata = new_tab)

summary(ndt)

# using weights

new_tab2 &lt;- data.frame(
  age_init = 40:45,
  .weights = runif(6)
)

#'\dontrun{
#'ndt2 &lt;- update(res, newdata = new_tab2)
#'
#'summary(ndt2)
#'}
</code></pre>

<hr>
<h2 id='who_mortality'>Use WHO Mortality Rate</h2><span id='topic+who_mortality'></span><span id='topic+get_who_mr_memo'></span><span id='topic+get_who_mr'></span>

<h3>Description</h3>

<p>Returns age and sex-specific mortality probabilities for
a given country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_who_mr_memo(
  age,
  sex = NULL,
  region = NULL,
  country = NULL,
  year = "latest",
  local = FALSE
)

get_who_mr(
  age,
  sex = NULL,
  region = NULL,
  country = NULL,
  year = "latest",
  local = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="who_mortality_+3A_age">age</code></td>
<td>
<p>age as a continuous variable.</p>
</td></tr>
<tr><td><code id="who_mortality_+3A_sex">sex</code></td>
<td>
<p>sex as <code>"FMLE"</code>-<code>"MLE"</code>, <code>0</code>-<code>1</code> (male = 0,
female = 1) or <code>1</code>-<code>2</code> (male = 1, female = 2).</p>
</td></tr>
<tr><td><code id="who_mortality_+3A_region">region</code></td>
<td>
<p>Region code. Assumed <code>NULL</code> if provided along
with <code>country</code>.</p>
</td></tr>
<tr><td><code id="who_mortality_+3A_country">country</code></td>
<td>
<p>Country code (see details).</p>
</td></tr>
<tr><td><code id="who_mortality_+3A_year">year</code></td>
<td>
<p>Use data from that year. Defaults to
<code>"latest"</code>.</p>
</td></tr>
<tr><td><code id="who_mortality_+3A_local">local</code></td>
<td>
<p>Fetch mortality data from package cached
data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locally cached data is used in case of connection
problems, of if <code>local = TRUE</code>. For memory space reasons
local data is only available for WHO high-income
countries (pooled), and only for the latest year.
</p>
<p>The results of <code>get_who_mr</code> are memoised for
<code>options("heemod.memotime")</code> (default: 1 hour) to
increase resampling performance.
</p>


<h3>Value</h3>

<p>This function should be used within
<code><a href="#topic+define_transition">define_transition()</a></code> or <code><a href="#topic+define_parameters">define_parameters()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
define_transition(
  C, get_who_mr(age = 50 + model_time, sex = "FMLE", country = "FRA"),
  0, 1
)

</code></pre>

<hr>
<h2 id='wtd_summary'>Weighted Summary</h2><span id='topic+wtd_summary'></span>

<h3>Description</h3>

<p>Compute a weighted summary of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd_summary(x, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtd_summary_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="wtd_summary_+3A_weights">weights</code></td>
<td>
<p>A vector of weights, same length as
<code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>weights</code> is <code>NULL</code> an unweighted summary is
returned.
</p>


<h3>Value</h3>

<p>A vector with values <code>Min., 1st Qu., Median,
  Mean, 3rd Qu., Max.</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
