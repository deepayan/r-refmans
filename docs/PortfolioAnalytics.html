<!DOCTYPE html><html lang="en"><head><title>Help for package PortfolioAnalytics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PortfolioAnalytics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PortfolioAnalytics-package'>
<p>Numeric methods for optimization of portfolios</p></a></li>
<li><a href='#ac.ranking'><p>Asset Ranking</p></a></li>
<li><a href='#add.constraint'><p>General interface for adding and/or updating optimization constraints.</p></a></li>
<li><a href='#add.objective'><p>General interface for adding optimization objectives, including risk, return, and risk budget</p></a></li>
<li><a href='#add.sub.portfolio'><p>Add sub-portfolio</p></a></li>
<li><a href='#applyFUN'><p>Apply a risk or return function to a set of weights</p></a></li>
<li><a href='#backtest.plot'><p>generate plots of the cumulative returns and drawdown for back-testing</p></a></li>
<li><a href='#barplotGroupWeights'><p>barplot of group weights by group or category</p></a></li>
<li><a href='#black.litterman'><p>Black Litterman Estimates</p></a></li>
<li><a href='#BlackLittermanFormula'><p>Computes the Black-Litterman formula for the moments of the posterior normal.</p></a></li>
<li><a href='#box_constraint'><p>constructor for box_constraint.</p></a></li>
<li><a href='#CCCgarch.MM'><p>compute comoments for use by lower level optimization functions when the conditional covariance matrix is a CCC GARCH model</p></a></li>
<li><a href='#center'><p>Center</p></a></li>
<li><a href='#centroid.buckets'><p>Buckets Centroid</p></a></li>
<li><a href='#centroid.complete.mc'><p>Complete Cases Centroid</p></a></li>
<li><a href='#centroid.sectors'><p>Multiple Sectors Centroid</p></a></li>
<li><a href='#centroid.sign'><p>Positive and Negative View Centroid</p></a></li>
<li><a href='#chart.Concentration'><p>Classic risk reward scatter and concentration</p></a></li>
<li><a href='#chart.EF.Weights'><p>Chart weights along an efficient frontier</p></a></li>
<li><a href='#chart.EfficientFrontier'><p>Chart the efficient frontier and risk-return scatter</p></a></li>
<li><a href='#chart.EfficientFrontierCompare'><p>Overlay the efficient frontiers of different minRisk portfolio objects on a single plot.</p></a></li>
<li><a href='#chart.EfficientFrontierOverlay'><p>Plot multiple efficient frontiers</p></a></li>
<li><a href='#chart.GroupWeights'><p>Chart weights by group or category</p></a></li>
<li><a href='#chart.RiskBudget'><p>Generic method to chart risk contribution</p></a></li>
<li><a href='#chart.RiskReward'><p>classic risk reward scatter</p></a></li>
<li><a href='#chart.Weights'><p>boxplot of the weights of the optimal portfolios</p></a></li>
<li><a href='#check_constraints'><p>check if a set of weights satisfies the constraints</p></a></li>
<li><a href='#cokurtosisMF'><p>Cokurtosis Matrix Estimate</p></a></li>
<li><a href='#cokurtosisSF'><p>Cokurtosis Matrix Estimate</p></a></li>
<li><a href='#combine.optimizations'><p>Combine objects created by optimize.portfolio</p></a></li>
<li><a href='#combine.portfolios'><p>Combine a list of portfolio objects</p></a></li>
<li><a href='#constrained_objective'><p>calculate a numeric return value for a portfolio based on a set of constraints and objectives</p></a></li>
<li><a href='#constraint_ROI'><p>constructor for class constraint_ROI</p></a></li>
<li><a href='#constraint_v1'><p>constructors for class constraint</p></a></li>
<li><a href='#coskewnessMF'><p>Coskewness Matrix Estimate</p></a></li>
<li><a href='#coskewnessSF'><p>Coskewness Matrix Estimate</p></a></li>
<li><a href='#covarianceMF'><p>Covariance Matrix Estimate</p></a></li>
<li><a href='#covarianceSF'><p>Covariance Matrix Estimate</p></a></li>
<li><a href='#create.EfficientFrontier'><p>create an efficient frontier</p></a></li>
<li><a href='#custom.covRob.Mcd'><p>Compute returns mean vector and covariance matrix with custom.covRob.Mcd</p></a></li>
<li><a href='#custom.covRob.MM'><p>Compute returns mean vector and covariance matrix with custom.covRob.MM</p></a></li>
<li><a href='#custom.covRob.Rocke'><p>Compute returns mean vector and covariance matrix with custom.covRob.Rocke</p></a></li>
<li><a href='#custom.covRob.TSGS'><p>Compute returns mean vector and covariance matrix with custom.covRob.TSGS</p></a></li>
<li><a href='#diversification'><p>Function to compute diversification as a constraint</p></a></li>
<li><a href='#diversification_constraint'><p>constructor for diversification_constraint</p></a></li>
<li><a href='#EntropyProg'><p>Entropy pooling program for blending views on scenarios with a prior scenario-probability distribution</p></a></li>
<li><a href='#equal.weight'><p>Create an equal weight portfolio</p></a></li>
<li><a href='#etl_milp_opt'><p>Minimum ETL MILP Optimization</p></a></li>
<li><a href='#etl_opt'><p>Minimum ETL LP Optimization</p></a></li>
<li><a href='#extract_risk'><p>extract the risk value when knowing the weights</p></a></li>
<li><a href='#extractCokurtosis'><p>Cokurtosis Estimate</p></a></li>
<li><a href='#extractCoskewness'><p>Coskewness Estimate</p></a></li>
<li><a href='#extractCovariance'><p>Covariance Estimate</p></a></li>
<li><a href='#extractEfficientFrontier'><p>Extract the efficient frontier data points</p></a></li>
<li><a href='#extractGroups'><p>Extract the group and/or category weights</p></a></li>
<li><a href='#extractObjectiveMeasures'><p>Extract the objective measures</p></a></li>
<li><a href='#extractStats'><p>extract some stats and weights from a portfolio run via <code>optimize.portfolio</code></p></a></li>
<li><a href='#extractWeights'><p>Extract weights from a portfolio run via <code>optimize.portfolio</code> or <code>optimize.portfolio.rebalancing</code></p></a></li>
<li><a href='#factor_exposure_constraint'><p>Constructor for factor exposure constraint</p></a></li>
<li><a href='#fn_map'><p>mapping function to transform or penalize weights that violate constraints</p></a></li>
<li><a href='#generatesequence'><p>create a sequence of possible weights for random or brute force portfolios</p></a></li>
<li><a href='#get_constraints'><p>Helper function to get the enabled constraints out of the portfolio object</p>
</p>
<p>When the v1_constraint object is instantiated via constraint, the arguments</p>
min_sum, max_sum, min, and max are either specified by the user or default
values are assigned. These are required by other functions such as
<code>optimize.portfolio</code> and <code>constrained_objective</code> . This function
will check that these variables are in the portfolio object in the
constraints list. We will default to <code>min_sum=1</code> and <code>max_sum=1</code>
if leverage constraints are not specified. We will default to <code>min=-Inf</code>
and <code>max=Inf</code> if box constraints are not specified.
This function is used at the beginning of optimize.portfolio and other
functions to extract the constraints from the portfolio object. We Use the
same naming as the v1_constraint object.</a></li>
<li><a href='#gmv_opt'><p>GMV/QU QP Optimization</p></a></li>
<li><a href='#gmv_opt_leverage'><p>GMV/QU QP Optimization with Turnover Constraint</p></a></li>
<li><a href='#gmv_opt_ptc'><p>GMV/QU QP Optimization with Proportional Transaction Cost Constraint</p></a></li>
<li><a href='#gmv_opt_toc'><p>GMV/QU QP Optimization with Turnover Constraint</p></a></li>
<li><a href='#group_constraint'><p>constructor for group_constraint</p></a></li>
<li><a href='#group_fail'><p>Test if group constraints have been violated</p></a></li>
<li><a href='#HHI'><p>Concentration of weights</p></a></li>
<li><a href='#indexes'><p>Six Major Economic Indexes</p></a></li>
<li><a href='#insert_constraints'><p>Insert a list of constraints into the constraints slot of a portfolio object</p></a></li>
<li><a href='#insert_objectives'><p>Insert a list of objectives into the objectives slot of a portfolio object</p></a></li>
<li><a href='#inverse.volatility.weight'><p>Create an inverse volatility weighted portfolio</p></a></li>
<li><a href='#is.constraint'><p>check function for constraints</p></a></li>
<li><a href='#is.objective'><p>check class of an objective object</p></a></li>
<li><a href='#is.portfolio'><p>check function for portfolio</p></a></li>
<li><a href='#leverage_exposure_constraint'><p>constructor for leverage_exposure_constraint</p></a></li>
<li><a href='#maxret_milp_opt'><p>Maximum Return MILP Optimization</p></a></li>
<li><a href='#maxret_opt'><p>Maximum Return LP Optimization</p></a></li>
<li><a href='#meancsm.efficient.frontier'><p>Generate the efficient frontier for a mean-CSM portfolio</p></a></li>
<li><a href='#meanetl.efficient.frontier'><p>Generate the efficient frontier for a mean-etl portfolio</p></a></li>
<li><a href='#meanrisk.efficient.frontier'><p>Generate multiple efficient frontiers for the same portfolio</p></a></li>
<li><a href='#meanvar.efficient.frontier'><p>Generate the efficient frontier for a mean-variance portfolio</p></a></li>
<li><a href='#meucci.moments'><p>Compute moments</p></a></li>
<li><a href='#meucci.ranking'><p>Asset Ranking</p></a></li>
<li><a href='#minmax_objective'><p>constructor for class tmp_minmax_objective</p></a></li>
<li><a href='#mult.portfolio.spec'><p>Multple Layer Portfolio Specification</p></a></li>
<li><a href='#MycovRobMcd'><p>Control settings for custom.covRob.Mcd</p></a></li>
<li><a href='#MycovRobTSGS'><p>Control settings for custom.covRob.TSGS</p></a></li>
<li><a href='#name.replace'><p>utility function to replace awkward named from unlist</p></a></li>
<li><a href='#objective'><p>constructor for class 'objective'</p></a></li>
<li><a href='#opt.outputMvo'><p>Optimal Portfolio Weights and Performance Values</p></a></li>
<li><a href='#optimize.portfolio'><p>Constrained optimization of portfolios</p></a></li>
<li><a href='#optimize.portfolio.parallel'><p>Execute multiple optimize.portfolio calls, presumably in parallel</p></a></li>
<li><a href='#optimize.portfolio.rebalancing'><p>Portfolio Optimization with Rebalancing Periods</p></a></li>
<li><a href='#pHist'><p>Generates histogram</p></a></li>
<li><a href='#plot.optimize.portfolio.DEoptim'><p>plot method for objects of class <code>optimize.portfolio</code></p></a></li>
<li><a href='#plotFrontiers'><p>Generate efficient frontiers plot by providing frontiers.</p></a></li>
<li><a href='#portfolio_risk_objective'><p>constructor for class portfolio_risk_objective</p></a></li>
<li><a href='#portfolio.moments.bl'><p>Portfolio Moments</p></a></li>
<li><a href='#portfolio.moments.boudt'><p>Portfolio Moments</p></a></li>
<li><a href='#portfolio.spec'><p>constructor for class portfolio</p></a></li>
<li><a href='#pos_limit_fail'><p>function to check for violation of position limits constraints</p></a></li>
<li><a href='#position_limit_constraint'><p>constructor for filter_constraint</p></a></li>
<li><a href='#print.constraint'><p>print method for constraint objects</p></a></li>
<li><a href='#print.efficient.frontier'><p>Print an efficient frontier object</p></a></li>
<li><a href='#print.optimize.portfolio.rebalancing'><p>Printing output of optimize.portfolio.rebalancing</p></a></li>
<li><a href='#print.optimize.portfolio.ROI'><p>Printing output of optimize.portfolio</p></a></li>
<li><a href='#print.portfolio'><p>Printing Portfolio Specification Objects</p></a></li>
<li><a href='#print.summary.optimize.portfolio'><p>Printing summary output of optimize.portfolio</p></a></li>
<li><a href='#print.summary.optimize.portfolio.rebalancing'><p>Printing summary output of optimize.portfolio.rebalancing</p></a></li>
<li><a href='#quadratic_utility_objective'><p>constructor for quadratic utility objective</p></a></li>
<li><a href='#random_portfolios'><p>version 2 generate an arbitary number of constrained random portfolios</p></a></li>
<li><a href='#random_portfolios_v1'><p>generate an arbitary number of constrained random portfolios</p></a></li>
<li><a href='#random_walk_portfolios'><p>deprecated random portfolios wrapper until we write a random trades function</p></a></li>
<li><a href='#randomize_portfolio'><p>version 2 generate random permutations of a portfolio seed meeting your constraints on the weights of each asset</p></a></li>
<li><a href='#randomize_portfolio_v1'><p>Random portfolio sample method</p></a></li>
<li><a href='#regime.portfolios'><p>Regime Portfolios</p></a></li>
<li><a href='#return_constraint'><p>constructor for return_constraint</p></a></li>
<li><a href='#return_objective'><p>constructor for class return_objective</p></a></li>
<li><a href='#risk_budget_objective'><p>constructor for class risk_budget_objective</p></a></li>
<li><a href='#rp_grid'><p>Generate random portfolios based on grid search method</p></a></li>
<li><a href='#rp_sample'><p>Generate random portfolios using the sample method</p></a></li>
<li><a href='#rp_simplex'><p>Generate random portfolios using the simplex method</p></a></li>
<li><a href='#rp_transform'><p>Transform a weights vector to satisfy constraints</p></a></li>
<li><a href='#scatterFUN'><p>Apply a risk or return function to asset returns</p></a></li>
<li><a href='#set.portfolio.moments'><p>Portfolio Moments</p></a></li>
<li><a href='#set.portfolio.moments_v1'><p>set portfolio moments for use by lower level optimization functions</p></a></li>
<li><a href='#statistical.factor.model'><p>Statistical Factor Model</p></a></li>
<li><a href='#summary.efficient.frontier'><p>Summarize an efficient frontier object</p></a></li>
<li><a href='#summary.optimize.portfolio'><p>Summarizing output of optimize.portfolio</p></a></li>
<li><a href='#summary.optimize.portfolio.rebalancing'><p>summary method for optimize.portfolio.rebalancing</p></a></li>
<li><a href='#summary.portfolio'><p>Summarize Portfolio Specification Objects</p></a></li>
<li><a href='#trailingFUN'><p>apply a function over a configurable trailing period</p></a></li>
<li><a href='#transaction_cost_constraint'><p>constructor for transaction_cost_constraint</p></a></li>
<li><a href='#turnover'><p>Calculates turnover given two vectors of weights.</p>
This is used as an objective function and is called when the user adds an objective of type turnover with <code>add.objective</code></a></li>
<li><a href='#turnover_constraint'><p>constructor for turnover_constraint</p></a></li>
<li><a href='#turnover_objective'><p>constructor for class turnover_objective</p></a></li>
<li><a href='#update_constraint_v1tov2'><p>Helper function to update v1_constraint objects to v2 specification in the portfolio object</p></a></li>
<li><a href='#update.constraint'><p>function for updating constrints, not well tested, may be broken</p></a></li>
<li><a href='#var.portfolio'><p>Calculate portfolio variance</p></a></li>
<li><a href='#weight_concentration_objective'><p>Constructor for weight concentration objective</p></a></li>
<li><a href='#weight_sum_constraint'><p>constructor for weight_sum_constraint</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Portfolio Analysis, Including Numerical Methods for Optimization
of Portfolios</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-04</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian G. Peterson &lt;brian@braverock.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Portfolio optimization and analysis routines and graphics.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), zoo, xts (&ge; 0.10-1), foreach,
PerformanceAnalytics (&ge; 1.5.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>quantmod, DEoptim (&ge; 2.2.1), iterators, fGarch, Rglpk,
quadprog, ROI (&ge; 0.1.0), ROI.plugin.glpk (&ge; 0.0.2),
ROI.plugin.quadprog (&ge; 0.0.2), corpcor, testthat, nloptr (&ge;
1.0.0), MASS, robustbase, osqp, CVXR, data.table, knitr,
rmarkdown, GSE, RobStatTM, PCRA, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, GenSA, ROI.plugin.symphony, mco, pso</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/braverock/PortfolioAnalytics">https://github.com/braverock/PortfolioAnalytics</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>(c) 2004-2024</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-04 15:50:35 UTC; brian</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian G. Peterson [cre, aut, cph],
  Peter Carl [aut, cph],
  Ross Bennett [ctb, cph],
  Kris Boudt [ctb, cph],
  Xinran Zhao [cph],
  R. Douglas Martin [ctb],
  Guy Yollin [ctb],
  Hezky Varon [ctb],
  Xiaokang Feng [ctb],
  Yifu Kang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-04 16:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='PortfolioAnalytics-package'>
Numeric methods for optimization of portfolios
</h2><span id='topic+PortfolioAnalytics-package'></span><span id='topic+PortfolioAnalytics'></span>

<h3>Description</h3>

<p><kbd>PortfolioAnalytics</kbd> is an <span class="rlang"><b>R</b></span> package to provide numerical solutions for portfolio problems with complex constraints and objective sets. The goal of the package is to aid practicioners and researchers in solving portfolio optimization problems with complex constraints and objectives that mirror real-world applications.
</p>
<p>One of the goals of the packages is to provide a common interface to specify constraints and objectives that can be solved by any supported solver (i.e. optimization method). Currently supported optimization methods include
</p>

<ul>
<li><p> random portfolios
</p>
</li>
<li><p> differential evolution
</p>
</li>
<li><p> particle swarm optimization
</p>
</li>
<li><p> generalized simulated annealing
</p>
</li>
<li><p> linear and quadratic programming routines
</p>
</li></ul>

<p>The solver can be specified with the <code>optimize_method</code> argument in <code>optimize.portfolio</code> and <code>optimize.portfolio.rebalancing</code>. The <code>optimize_method</code> argument must be one of &quot;random&quot;, &quot;DEoptim&quot;, &quot;pso&quot;, &quot;GenSA&quot;, &quot;ROI&quot;, &quot;quadprog&quot;, &quot;glpk&quot;, or &quot;symphony&quot;.
</p>
<p>Additional information on random portfolios is provided below. The differential evolution algorithm is implemented via the <kbd>DEoptim</kbd> package, the particle swarm optimization algorithm via the <kbd>pso</kbd> package, the generalized simulated annealing via the <kbd>GenSA</kbd> package, and linear and quadratic programming are implemented via the <kbd>ROI</kbd> package which acts as an interface to the <kbd>Rglpk</kbd>, <kbd>Rsymphony</kbd>, and <kbd>quadprog</kbd> packages.
</p>
<p>A key strength of <kbd>PortfolioAnalytics</kbd> is the generalization of constraints and objectives that can be solved.
</p>
<p>If <code>optimize_method="ROI"</code> is specified, a default solver will be selected based on the optimization problem. The <code>glpk</code> solver is the default solver for LP and MILP optimization problems. The <code>quadprog</code> solver is the default solver for QP optimization problems. For example, <code>optimize_method = "quadprog"</code> can be specified and the optimization problem will be solved via ROI using the quadprog plugin package.
</p>
<p>The extension to ROI solves a limited type of convex optimization problems:
</p>

<ul>
<li><p>Maxmimize portfolio return subject leverage, box, group, position limit, target mean return, and/or factor exposure constraints on weights.
</p>
</li>
<li><p>Minimize portfolio variance subject to leverage, box, group, turnover, and/or factor exposure constraints (otherwise known as global minimum variance portfolio).
</p>
</li>
<li><p>Minimize portfolio variance subject to leverage, box, group, and/or factor exposure constraints and a desired portfolio return.
</p>
</li>
<li><p>Maximize quadratic utility subject to leverage, box, group, target mean return, turnover, and/or factor exposure constraints and risk aversion parameter.
(The risk aversion parameter is passed into <code>optimize.portfolio</code> as an added argument to the <code>portfolio</code> object).
</p>
</li>
<li><p>Maximize portfolio mean return per unit standard deviation (i.e. the Sharpe Ratio) can be done by specifying <code>maxSR=TRUE</code> in <code>optimize.portfolio</code>. 
If both mean and StdDev are specified as objective names, the default action is to maximize quadratic utility, therefore <code>maxSR=TRUE</code> must be specified to maximize Sharpe Ratio.
</p>
</li>
<li><p>Minimize portfolio ES/ETL/CVaR optimization subject to leverage, box, group, position limit, target mean return, and/or factor exposure constraints and target portfolio return.
</p>
</li>
<li><p>Maximize portfolio mean return per unit ES/ETL/CVaR (i.e. the STARR Ratio) can be done by specifying <code>maxSTARR=TRUE</code> in <code>optimize.portfolio</code>. 
If both mean and ES/ETL/CVaR are specified as objective names, the default action is to maximize mean return per unit ES/ETL/CVaR.
</p>
</li></ul>

<p>These problems also support a weight_concentration objective where concentration of weights as measured by HHI is added as a penalty term to the quadratic objective.
</p>
<p>Because these convex optimization problem are standardized, there is no need for a penalty term. The <code>multiplier</code> argument in <code><a href="#topic+add.objective">add.objective</a></code> passed into the complete constraint object are ingnored by the ROI solver.
</p>
<p>Many real-world portfolio optimization problems are global optimization problems, and therefore are not suitable for linear or quadratic programming routines. <kbd>PortfolioAnalytics</kbd> provides a random portfolio optimization method and also utilizes the <span class="rlang"><b>R</b></span> packages DEoptim, pso, and GenSA for solving non-convex global optimization problems.
</p>
<p><kbd>PortfolioAnalytics</kbd> supports three methods of generating random portfolios.
</p>

<ul>
<li><p> The sample method to generate random portfolios is based on an idea by Pat Burns. This is the most flexible method, but also the slowest, and can generate portfolios to satisfy leverage, box, group, position limit, and leverage constraints.
</p>
</li>
<li><p> The simplex method to generate random portfolios is based on a paper by W. T. Shaw. The simplex method is useful to generate random portfolios with the full investment constraint (where the sum of the weights is equal to 1) and min box constraints. Values for min_sum and max_sum of the leverage constraint will be ignored, the sum of weights will equal 1. All other constraints such as the box constraint max, group and position limit constraints will be handled by elimination. If the constraints are very restrictive, this may result in very few feasible portfolios remaining. Another key point to note is that the solution may not be along the vertexes depending on the objective. For example, a risk budget objective will likely place the portfolio somewhere on the interior.
</p>
</li>
<li><p> The grid method to generate random portfolios is based on the <code>gridSearch</code> function in package <kbd>NMOF</kbd>. The grid search method only satisfies the min and max box constraints. The min_sum and max_sum leverage constraint will likely be violated and the weights in the random portfolios should be normalized. Normalization may cause the box constraints to be violated and will be penalized in <code>constrained_objective</code>.
</p>
</li></ul>

<p><kbd>PortfolioAnalytics</kbd> leverages the <kbd>PerformanceAnalytics</kbd> package for many common objective functions. The objective types in <kbd>PortfolioAnalytics</kbd> are designed to be used with <kbd>PerformanceAnalytics</kbd> functions, but any user supplied valid <span class="rlang"><b>R</b></span> function can be used as an objective.
</p>


<h3>Optimization</h3>

<p>This summary attempts to provide an overview of how to construct a portfolio object with constraints and objectives, run the optimization, and chart the results.
</p>
<p>The portfolio object is initialized with the <code><a href="#topic+portfolio.spec">portfolio.spec</a></code> function. The main argument to <code><a href="#topic+portfolio.spec">portfolio.spec</a></code> is <code>assets</code>. The <code>assets</code> argument can be a scalar value for the number of assets, a character vector of fund names, or a named vector of initial weights.
</p>
<p>Adding constraints to the portfolio object is done with <code><a href="#topic+add.constraint">add.constraint</a></code>. The <code><a href="#topic+add.constraint">add.constraint</a></code> function is the main interface for adding and/or updating constraints to the portfolio object. This function allows the user to specify the portfolio to add the constraints to, the type of constraints, arguments for the constraint, and whether or not to enable the constraint. If updating an existing constraint, the <code>indexnum</code> argument can be specified.
</p>
<p>Objectives can be added to the portfolio object with <code><a href="#topic+add.objective">add.objective</a></code>. The <code><a href="#topic+add.objective">add.objective</a></code> function is the main function for adding and/or updating objectives to the portfolio object. This function allows the user to specify the portfolio to add the objectives to, the type, name of the objective function, arguments to the objective function, and whether or not to enable the objective. If updating an existing objective, the <code>indexnum</code> argument can be specified.
</p>
<p>With the constraints and objectives specified in the portfolio object, the portfolio object can be passed to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> or <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code> to run the optimization. Arguments to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> include asset returns, the portfolio obect specifying constraints and objectives, optimization method, and other parameters specific to the solver. <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code> adds support for backtesting portfolio optimization through time with rebalancing or rolling periods.
</p>


<h3>Advanced Optimization</h3>

<p>In addition to the more standard optimizations described above, <kbd>PortfolioAnalytics</kbd> also supports multi-layer optimization and regime switching optimization. 
</p>
<p>Support for multi-layer optimization allows one to construct a top level portfolio and several sub-portfolios with potentially different assets, constraints, and objectives. First, each sub-portfolio is optimized out-of-sample which creates a time series of returns. One can think of the out of sample returns for each sub-portfolio as the returns for a synthetic instrument. Finally, the out-of-sample returns of each sub-portfolio are then used as inputs for the top level optimization. The top level portfolio and sub-portfolios are created as normal using <code>portfolio.spec</code>, <code>add.constraint</code>, and <code>add.objective</code>. The multi-layer portfolio specification object is first initialized by passing the top level portfolio to <code>mult.portfolio.spec</code>. Sub-portfolios are then added with <code>add.sub.portfolio</code>. The multi-layer portfolio specification object can then be passed to <code>optimize.portfolio</code> and <code>optimize.portfolio.rebalancing</code>. See <code>demo(multi_layer_optimization)</code>.
</p>
<p>Support for regime switching models allows one to change constraints and objectives depending on the current regime. Portfolios are created as normal with <code>portfolio.spec</code>, <code>add.constraint</code>, and <code>add.objective</code>. The portfolios are then combined with a regime object using <code>regime.portfolios</code> to create a regime portfolio specification which can then be passed to <code>optimize.portfolio</code> and <code>optimize.portfolio.rebalancing</code>. Regime switching optimization is implemented in such a way that any arbitrary regime model can be used. See <code>demo(regime_switching)</code>.
</p>


<h3>Portfolio Moments</h3>

<p>The <kbd>PortfolioAnalytics</kbd> framework to estimate solutions to constrained optimization problems is implemented in such a way that the moments of the returns are set once for use in lower level optimization functions. The <code>set.portfolio.moments</code> function computes the first, second, third, and fourth moments depending on the objective function(s) in the <code>portfolio</code> object. For example, if the third and fourth moments do not need to be calculated for a given objective, then <code>set.portfolio.moments</code> will try to detect this and not compute those moments. Currently, <code>set.portfolio.moments</code> implements methods to compute moments based on sample estimates, higher moments from fitting a statistical factor model based on the work of Kris Boudt, the Black Litterman model, and the Fully Flexible Framework based on the work of Attilio Meucci (NEED REFERENCE HERE). See the Custom Moment and Objective Functions vignette for a more detailed description and examples. 
</p>


<h3>Charts and Graphs</h3>

<p>Intuition into the optimization can be aided through visualization. The goal of creating the charts is to provide visualization tools for optimal portfolios regardless of the chosen optimization method.
</p>
<p><code><a href="#topic+chart.Weights">chart.Weights</a></code> plots the weights of the optimal portfolio. <code><a href="#topic+chart.RiskReward">chart.RiskReward</a></code> plots the optimal portfolio in risk-reward space. The random portfolios, DEoptim, and pso solvers will return trace portfolio information at each iteration when <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> is run with <code>trace=TRUE</code>. If this is the case, <code><a href="#topic+chart.RiskReward">chart.RiskReward</a></code> will plot these portfolios so that the feasible space can be easily visualized. Although the GenSA and ROI solvers do not return trace portfolio information, random portfolios can be be generated with the argument <code>rp=TRUE</code> in <code><a href="#topic+chart.RiskReward">chart.RiskReward</a></code>. A <code>plot</code> function is provided that will plot the weights and risk-reward scatter chart. The component risk contribution can be charted for portfolio optimization problems with risk budget objectives with <code><a href="#topic+chart.RiskBudget">chart.RiskBudget</a></code>. Neighbor portfolios can be plotted in <code><a href="#topic+chart.RiskBudget">chart.RiskBudget</a></code>, <code><a href="#topic+chart.Weights">chart.Weights</a></code>, and <code><a href="#topic+chart.RiskReward">chart.RiskReward</a></code>.
</p>
<p>Efficient frontiers can be extracted from <code>optimize.portfolio</code> objects or created from a <code>portfolio</code> object. The efficient frontier can be charted in risk-reward space with <code><a href="#topic+chart.EfficientFrontier">chart.EfficientFrontier</a></code>. The weights along the efficient frontier can be charted with <code><a href="#topic+chart.EF.Weights">chart.EF.Weights</a></code>.
</p>
<p>Multiple objects created via <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> can be combined with <code><a href="#topic+combine.optimizations">combine.optimizations</a></code> for visual comparison. The weights of the optimal portfolios can be plotted with <code><a href="#topic+chart.Weights">chart.Weights</a></code>. The optimal portfolios can be compared in risk-reward space with <code><a href="#topic+chart.RiskReward">chart.RiskReward</a></code>. The portfolio component risk contributions of the multiple optimal portfolios can be plotted with <code><a href="#topic+chart.RiskBudget">chart.RiskBudget</a></code>.
</p>


<h3>Demos</h3>

<p><kbd>PortfolioAnalytics</kbd> contains a comprehensive collection of demos to demonstrate the functionality from very basic optimization problems such as estimating the solution to a minimum variance portfolio to more complex optimization problems with custom moment and objective functions.
</p>


<h3>Vignettes</h3>

<p>TODO
</p>


<h3>Package Dependencies</h3>

<p>Several of the functions in the <kbd>PortfolioAnalytics</kbd> package require time series data of returns and the <code><a href="xts.html#topic+xts">xts</a></code> package is used for working with time series data. 
</p>
<p>The <kbd>PerformanceAnalytics</kbd> package is used for many common objective functions. The objective types in <kbd>PortfolioAnalytics</kbd> are designed to be used with <kbd>PerformanceAnalytics</kbd> functions such as <code><a href="PerformanceAnalytics.html#topic+StdDev">StdDev</a></code>, <code><a href="PerformanceAnalytics.html#topic+VaR">VaR</a></code>, and <code><a href="PerformanceAnalytics.html#topic+ES">ES</a></code>.
</p>
<p>The <kbd>foreach</kbd> and <kbd>iterators</kbd> packages are used extensively throughout the package to support parallel programming. The primary functions where <code>foreach</code> loops are used is <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>, <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code>, and <code><a href="#topic+create.EfficientFrontier">create.EfficientFrontier</a></code>.
</p>
<p>In addition to a random portfolios optimzation method, <kbd>PortfolioAnalytics</kbd> supports backend solvers by leveraging the following packages: <kbd>DEoptim</kbd>, <kbd>pso</kbd>, <kbd>GenSA</kbd>, <kbd>ROI</kbd> and associated ROI plugin packages.
</p>


<h3>Further Work</h3>

<p>Continued work to improved charts and graphs.
</p>
<p>Continued work to improve features to combine and compare multiple optimal portfolio objects.
</p>
<p>Support for more solvers.
</p>
<p>Comments, suggestions, and/or code patches are welcome.
</p>


<h3>Acknowledgements</h3>

<p>TODO
</p>


<h3>Author(s)</h3>

<p>Ross Bennett <br />
Kris Boudt <br />
Peter Carl <br />
Brian G. Peterson <br />
</p>
<p>Maintainer: Brian G. Peterson <a href="mailto:brian@braverock.com">brian@braverock.com</a>
</p>


<h3>References</h3>

<p>Boudt, Kris and Lu, Wanbo and Peeters, Benedict, <em>Higher Order Comoments of Multifactor Models and Asset Allocation</em> (June 16, 2014). Available at SSRN: http://ssrn.com/abstract=2409603 or http://dx.doi.org/10.2139/ssrn.2409603
</p>
<p>Chriss, Neil A and Almgren, Robert, <em>Portfolios from Sorts</em> (April 27, 2005). Available at SSRN: http://ssrn.com/abstract=720041 or http://dx.doi.org/10.2139/ssrn.720041 <br />
</p>
<p>Meucci, Attilio, <em>The Black-Litterman Approach: Original Model and Extensions</em> (August 1, 2008). Shorter version in, THE ENCYCLOPEDIA OF QUANTITATIVE FINANCE, Wiley, 2010. Available at SSRN: http://ssrn.com/abstract=1117574 or http://dx.doi.org/10.2139/ssrn.1117574 <br />
</p>
<p>Meucci, Attilio, <em>Fully Flexible Views: Theory and Practice</em> (August 8, 2008). Fully Flexible Views: Theory and Practice, Risk, Vol. 21, No. 10, pp. 97-102, October 2008. Available at SSRN: http://ssrn.com/abstract=1213325
</p>
<p>Scherer, Bernd and Martin, Doug, <em>Modern Portfolio Optimization</em>. Springer. 2005. <br />
</p>
<p>Shaw, William Thornton, <em>Portfolio Optimization for VAR, CVaR, Omega and Utility with General Return Distributions: A Monte Carlo Approach for Long-Only and Bounded Short Portfolios with Optional Robustness and a Simplified Approach to Covariance Matching</em> (June 1, 2011). Available at SSRN: http://ssrn.com/abstract=1856476 or http://dx.doi.org/10.2139/ssrn.1856476 <br />
</p>


<h3>See Also</h3>

<p>CRAN task view on Empirical Finance <br /> <a href="https://cran.r-project.org/view=Econometrics">https://cran.r-project.org/view=Econometrics</a>
</p>
<p>CRAN task view on Optimization <br /> <a href="https://cran.r-project.org/view=Optimization">https://cran.r-project.org/view=Optimization</a>
</p>
<p>Large-scale portfolio optimization with DEoptim <br /> <a href="https://cran.r-project.org/package=DEoptim">https://cran.r-project.org/package=DEoptim</a>
</p>

<hr>
<h2 id='ac.ranking'>Asset Ranking</h2><span id='topic+ac.ranking'></span>

<h3>Description</h3>

<p>Compute the first moment from a single complete sort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ac.ranking(R, order, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ac.ranking_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="ac.ranking_+3A_order">order</code></td>
<td>
<p>a vector of indexes of the relative ranking of expected asset 
returns in ascending order. For example, <code>order = c(2, 3, 1, 4)</code> means 
that the expected returns of <code>R[,2] &lt; R[,3], &lt; R[,1] &lt; R[,4]</code>.</p>
</td></tr>
<tr><td><code id="ac.ranking_+3A_...">...</code></td>
<td>
<p>any other passthrough parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the estimated centroid vector from a single complete
sort using the analytical approximation as described in R. Almgren and 
N. Chriss, &quot;Portfolios from Sorts&quot;. The centroid is estimated and then 
scaled such that it is on a scale similar to the asset returns. By default,
the centroid vector is scaled according to the median of the asset mean 
returns.
</p>


<h3>Value</h3>

<p>The estimated first moments based on ranking views
</p>


<h3>References</h3>

<p>R. Almgren and N. Chriss, &quot;Portfolios from Sorts&quot; 
<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=720041">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=720041</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centroid.complete.mc">centroid.complete.mc</a></code> <code><a href="#topic+centroid.sectors">centroid.sectors</a></code>
<code><a href="#topic+centroid.sign">centroid.sign</a></code> <code><a href="#topic+centroid.buckets">centroid.buckets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
R &lt;- edhec[,1:4]
ac.ranking(R, c(2, 3, 1, 4))
</code></pre>

<hr>
<h2 id='add.constraint'>General interface for adding and/or updating optimization constraints.</h2><span id='topic+add.constraint'></span>

<h3>Description</h3>

<p>This is the main function for adding and/or updating constraints to the <code><a href="#topic+portfolio.spec">portfolio.spec</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.constraint(
  portfolio,
  type,
  enabled = TRUE,
  message = FALSE,
  ...,
  indexnum = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.constraint_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class 'portfolio' to add the constraint to, specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="add.constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint to add or update, currently 'weight_sum' (also 'leverage' or 'weight'), 'box', 'group', 'turnover', 'diversification', 'position_limit', 'return', 'factor_exposure', or 'leverage_exposure'</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE. The default is enabled=TRUE.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify constraints</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_indexnum">indexnum</code></td>
<td>
<p>if you are updating a specific constraint, the index number in the $constraints list to update</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following constraint types may be specified:
</p>

<dl>
<dt><code>weight_sum</code>, <code>weight</code>, <code>leverage</code></dt><dd><p> Specify constraint on the sum of the weights, see <code><a href="#topic+weight_sum_constraint">weight_sum_constraint</a></code> </p>
</dd>
<dt><code>full_investment</code></dt><dd><p> Special case to set <code>min_sum=1</code> and <code>max_sum=1</code> of weight sum constraints </p>
</dd>
<dt><code>dollar_neutral</code>, <code>active</code></dt><dd><p> Special case to set <code>min_sum=0</code> and <code>max_sum=0</code> of weight sum constraints </p>
</dd>
<dt><code>box</code></dt><dd><p> box constraints for the individual asset weights, see <code><a href="#topic+box_constraint">box_constraint</a></code> </p>
</dd>
<dt><code>long_only</code></dt><dd><p> Special case to set <code>min=0</code> and <code>max=1</code> of box constraints </p>
</dd>
<dt><code>group</code></dt><dd><p> specify the sum of weights within groups and the number of assets with non-zero weights in groups, see <code><a href="#topic+group_constraint">group_constraint</a></code> </p>
</dd>
<dt><code>turnover</code></dt><dd><p> Specify a constraint for target turnover. Turnover is calculated from a set of initial weights, see <code><a href="#topic+turnover_constraint">turnover_constraint</a></code> </p>
</dd>
<dt><code>diversification</code></dt><dd><p> target diversification of a set of weights, see <code><a href="#topic+diversification_constraint">diversification_constraint</a></code> </p>
</dd>
<dt><code>position_limit</code></dt><dd><p> Specify the number of non-zero, long, and/or short positions, see <code><a href="#topic+position_limit_constraint">position_limit_constraint</a></code> </p>
</dd>
<dt><code>return</code></dt><dd><p> Specify the target mean return, see <code><a href="#topic+return_constraint">return_constraint</a></code></p>
</dd>
<dt><code>factor_exposure</code></dt><dd><p> Specify risk factor exposures, see <code><a href="#topic+factor_exposure_constraint">factor_exposure_constraint</a></code></p>
</dd>
<dt><code>leverage_exposure</code></dt><dd><p> Specify a maximum leverage exposure, see <code><a href="#topic+leverage_exposure_constraint">leverage_exposure_constraint</a></code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
<code><a href="#topic+weight_sum_constraint">weight_sum_constraint</a></code>, 
<code><a href="#topic+box_constraint">box_constraint</a></code>, 
<code><a href="#topic+group_constraint">group_constraint</a></code>, 
<code><a href="#topic+turnover_constraint">turnover_constraint</a></code>, 
<code><a href="#topic+diversification_constraint">diversification_constraint</a></code>, 
<code><a href="#topic+position_limit_constraint">position_limit_constraint</a></code>, 
<code><a href="#topic+return_constraint">return_constraint</a></code>, 
<code><a href="#topic+factor_exposure_constraint">factor_exposure_constraint</a></code>,
<code><a href="#topic+leverage_exposure_constraint">leverage_exposure_constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
returns &lt;- edhec[, 1:4]
fund.names &lt;- colnames(returns)
pspec &lt;- portfolio.spec(assets=fund.names)

# Add the full investment constraint that specifies the weights must sum to 1.
pspec &lt;- add.constraint(portfolio=pspec, type="weight_sum", min_sum=1, max_sum=1)

# The full investment constraint can also be specified with type="full_investment"
pspec &lt;- add.constraint(portfolio=pspec, type="full_investment")

# Another common constraint is that portfolio weights sum to 0.
pspec &lt;- add.constraint(portfolio=pspec, type="weight_sum", min_sum=0, max_sum=0)
pspec &lt;- add.constraint(portfolio=pspec, type="dollar_neutral")
pspec &lt;- add.constraint(portfolio=pspec, type="active")

# Add box constraints
pspec &lt;- add.constraint(portfolio=pspec, type="box", min=0.05, max=0.4)

# min and max can also be specified per asset
pspec &lt;- add.constraint(portfolio=pspec, 
                        type="box", 
                        min=c(0.05, 0, 0.08, 0.1), 
                        max=c(0.4, 0.3, 0.7, 0.55))
                        
# A special case of box constraints is long only where min=0 and max=1
# The default action is long only if min and max are not specified
pspec &lt;- add.constraint(portfolio=pspec, type="box")
pspec &lt;- add.constraint(portfolio=pspec, type="long_only")

# Add group constraints
pspec &lt;- add.constraint(portfolio=pspec, 
                        type="group", 
                        groups=list(c(1, 2, 1), 4), 
                        group_min=c(0.1, 0.15), 
                        group_max=c(0.85, 0.55), 
                        group_labels=c("GroupA", "GroupB"), 
                        group_pos=c(2, 1))

# Add position limit constraint such that we have a maximum number 
# of three assets with non-zero weights.
pspec &lt;- add.constraint(portfolio=pspec, type="position_limit", max_pos=3)

# Add diversification constraint
pspec &lt;- add.constraint(portfolio=pspec, type="diversification", div_target=0.7)

# Add turnover constraint
pspec &lt;- add.constraint(portfolio=pspec, type="turnover", turnover_target=0.2)

# Add target mean return constraint
pspec &lt;- add.constraint(portfolio=pspec, type="return", return_target=0.007)

# Example using the indexnum argument
portf &lt;- portfolio.spec(assets=fund.names)
portf &lt;- add.constraint(portf, type="full_investment")
portf &lt;- add.constraint(portf, type="long_only")

# indexnum corresponds to the index number of the constraint
# The full_investment constraint was the first constraint added and has 
# indexnum=1
portf$constraints[[1]]

# View the constraint with indexnum=2
portf$constraints[[2]]

# Update the constraint to relax the sum of weights constraint
portf &lt;- add.constraint(portf, type="weight_sum", 
min_sum=0.99, max_sum=1.01, 
indexnum=1)

# Update the constraint to modify the box constraint
portf &lt;- add.constraint(portf, type="box", 
min=0.1, max=0.8, 
indexnum=2)
</code></pre>

<hr>
<h2 id='add.objective'>General interface for adding optimization objectives, including risk, return, and risk budget</h2><span id='topic+add.objective'></span><span id='topic+add.objective_v1'></span><span id='topic+add.objective_v2'></span>

<h3>Description</h3>

<p>This function is the main function for adding and updating business objectives in an object of type <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.objective_v1(
  constraints,
  type,
  name,
  arguments = NULL,
  enabled = TRUE,
  ...,
  indexnum = NULL
)

add.objective(
  portfolio,
  constraints = NULL,
  type,
  name,
  arguments = NULL,
  enabled = TRUE,
  ...,
  indexnum = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.objective_+3A_constraints">constraints</code></td>
<td>
<p>a 'v1_constraint' object for backwards compatibility, see <code><a href="#topic+constraint">constraint</a></code></p>
</td></tr>
<tr><td><code id="add.objective_+3A_type">type</code></td>
<td>
<p>character type of the objective to add or update, currently 'return','risk', 'risk_budget', 'quadratic_utility', or 'weight_concentration'</p>
</td></tr>
<tr><td><code id="add.objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="add.objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="add.objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="add.objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="add.objective_+3A_indexnum">indexnum</code></td>
<td>
<p>if you are updating a specific objective, the index number in the $objectives list to update</p>
</td></tr>
<tr><td><code id="add.objective_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type 'portfolio' to add the objective to, specifying the portfolio for the optimization, see <code><a href="#topic+portfolio">portfolio</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, you will define your objective as one of the following types: 'return', 'risk', 'risk_budget', 'quadratic utility', or 'weight_concentration'.  
These have special handling and intelligent defaults for dealing with the function most likely to be 
used as objectives, including mean, median, VaR, ES, etc.
</p>
<p>Objectives of type 'turnover' and 'minmax' are also supported.
</p>


<h3>Author(s)</h3>

<p>Brian G. Peterson and Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+objective">objective</a></code>, <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
returns &lt;- edhec[,1:4]
fund.names &lt;- colnames(returns)
portf &lt;- portfolio.spec(assets=fund.names)
# Add some basic constraints
portf &lt;- add.constraint(portf, type="full_investment")
portf &lt;- add.constraint(portf, type="long_only")

# Creates a new portfolio object using portf and adds a quadratic utility
# objective. This will add two objectives to the portfolio object; 1) mean and
# 2) var. The risk aversion parameter is commonly referred to as lambda in the
# quadratic utility formulation that controls how much the portfolio variance 
# is penalized.
portf.maxQU &lt;- add.objective(portf, type="quadratic_utility", 
                             risk_aversion=0.25)

# Creates a new portfolio object using portf and adds mean as an objective
portf.maxMean &lt;- add.objective(portf, type="return", name="mean")

# Creates a new portfolio object using portf and adds StdDev as an objective
portf.minStdDev &lt;- add.objective(portf, type="risk", name="StdDev")

# Creates a new portfolio object using portf and adds ES as an objective. 
# Note that arguments to ES are passed in as a named list.
portf.minES &lt;- add.objective(portf, type="risk", name="ES", 
                             arguments=list(p=0.925, clean="boudt"))

# Creates a new portfolio object using portf.minES and adds a risk budget 
# objective with limits on component risk contribution. 
# Note that arguments to ES are passed in as a named list.
portf.RiskBudgetES &lt;- add.objective(portf.minES, type="risk_budget", name="ES", 
                             arguments=list(p=0.925, clean="boudt"),
                             min_prisk=0, max_prisk=0.6)

# Creates a new portfolio object using portf.minES and adds a risk budget 
# objective with equal component risk contribution. 
# Note that arguments to ES are passed in as a named list.
portf.EqRiskES &lt;- add.objective(portf.minES, type="risk_budget", name="ES", 
                                    arguments=list(p=0.925, clean="boudt"),
                                    min_concentration=TRUE)

# Creates a new portfolio object using portf and adds a weight_concentration 
# objective. The conc_aversion parameter controls how much concentration is
# penalized. The portfolio concentration is defined as the Herfindahl Hirschman
# Index of the weights.
portf.conc &lt;- add.objective(portf, type="weight_concentration", 
                            name="HHI", conc_aversion=0.01)
</code></pre>

<hr>
<h2 id='add.sub.portfolio'>Add sub-portfolio</h2><span id='topic+add.sub.portfolio'></span>

<h3>Description</h3>

<p>Add a sub-portfolio to a multiple layer portfolio specification object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.sub.portfolio(
  mult.portfolio,
  portfolio,
  optimize_method = c("DEoptim", "random", "ROI", "pso", "GenSA"),
  search_size = 20000,
  rp = NULL,
  rebalance_on = NULL,
  training_period = NULL,
  trailing_periods = NULL,
  ...,
  indexnum = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.sub.portfolio_+3A_mult.portfolio">mult.portfolio</code></td>
<td>
<p>a <code>mult.portfolio.spec</code> object</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_portfolio">portfolio</code></td>
<td>
<p>a <code>portfolio</code> object to add as a sub portfolio.</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_optimize_method">optimize_method</code></td>
<td>
<p>optimization method for the sub portfolio</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_search_size">search_size</code></td>
<td>
<p>integer, how many portfolios to test, default 20,000</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_rp">rp</code></td>
<td>
<p>matrix of random portfolio weights, default NULL, mostly for automated use by rebalancing optimization or repeated tests on same portfolios</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_rebalance_on">rebalance_on</code></td>
<td>
<p>haracter string of period to rebalance on. See 
<code><a href="xts.html#topic+endpoints">endpoints</a></code> for valid names.</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_training_period">training_period</code></td>
<td>
<p>an integer of the number of periods to use as 
a training data in the front of the returns data</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_trailing_periods">trailing_periods</code></td>
<td>
<p>an integer with the number of periods to roll over
(i.e. width of the moving or rolling window), the default is NULL will 
run using the returns data from inception</p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_...">...</code></td>
<td>
<p>additonal passthrough parameters to <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code></p>
</td></tr>
<tr><td><code id="add.sub.portfolio_+3A_indexnum">indexnum</code></td>
<td>
<p>the index number of the sub portfolio. If <code>indexnum=NULL</code>
(the default), then the sub portfolio object is appended to the list of 
sub portfolios in the <code>mult.portfolio</code> object. If <code>indexnum</code> is 
specified, the portfolio in that index number is overwritten.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mult.portfolio.spec">mult.portfolio.spec</a></code> <code><a href="#topic+portfolio.spec">portfolio.spec</a></code> <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code>
</p>

<hr>
<h2 id='applyFUN'>Apply a risk or return function to a set of weights</h2><span id='topic+applyFUN'></span>

<h3>Description</h3>

<p>This function is used to calculate risk or return metrics given a matrix of
weights and is primarily used as a convenience function used in chart.Scatter functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyFUN(R, weights, FUN = "mean", arguments)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyFUN_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="applyFUN_+3A_weights">weights</code></td>
<td>
<p>a matrix of weights generated from random_portfolios or <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="applyFUN_+3A_fun">FUN</code></td>
<td>
<p>name of a function</p>
</td></tr>
<tr><td><code id="applyFUN_+3A_arguments">arguments</code></td>
<td>
<p>named list of arguments to FUN</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='backtest.plot'>generate plots of the cumulative returns and drawdown for back-testing</h2><span id='topic+backtest.plot'></span>

<h3>Description</h3>

<p>generate plots of the cumulative returns and drawdown for back-testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtest.plot(
  R,
  log_return = FALSE,
  drawdown_on = 1,
  plotType = "both",
  main = NULL,
  colorSet = NULL,
  ltySet = NULL,
  lwdSet = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backtest.plot_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_log_return">log_return</code></td>
<td>
<p>arithmetic return or log return, the default is arithmetic return</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_drawdown_on">drawdown_on</code></td>
<td>
<p>the plot will shadow the full time period of the maximum drawdown and recovery of the first portfolio.
Use number (e.g. 1, 2, 3) to indicate which portfolio drawdown interval you wish to track, or NULL to not shadow any period.</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_plottype">plotType</code></td>
<td>
<p>&quot;cumRet&quot;, &quot;drawdown&quot;, or the default is both</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_main">main</code></td>
<td>
<p>users can design title by providing a character of main</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_colorset">colorSet</code></td>
<td>
<p>users can design the color by providing a vector of color</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_ltyset">ltySet</code></td>
<td>
<p>users can design lty by providing a vector of lty</p>
</td></tr>
<tr><td><code id="backtest.plot_+3A_lwdset">lwdSet</code></td>
<td>
<p>users can design lwd by providing a vector of lwd</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Carl, Xinran Zhao, Yifu Kang
</p>

<hr>
<h2 id='barplotGroupWeights'>barplot of group weights by group or category</h2><span id='topic+barplotGroupWeights'></span>

<h3>Description</h3>

<p>This function is called by chart.GroupWeights function if chart.type=&quot;barplot&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barplotGroupWeights(
  object,
  ...,
  grouping = c("groups", "category"),
  main = "Group Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 0.8,
  element.color = "darkgray",
  cex.axis = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barplotGroupWeights_+3A_object">object</code></td>
<td>
<p>object of class <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_grouping">grouping</code></td>
<td>

<dl>
<dt>groups: </dt><dd><p>group the weights by group constraints</p>
</dd>
<dt>category_labels: </dt><dd><p>group the weights by category_labels in portfolio object</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the style of axis labels
</p>

<dl>
<dt>0:</dt><dd><p>always parallel to the axis [<em>default</em>],</p>
</dd>
<dt>1:</dt><dd><p>always horizontal,</p>
</dd>
<dt>2:</dt><dd><p>always perpendicular to the axis,</p>
</dd>
<dt>3:</dt><dd><p>always vertical.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of <code>cex</code></p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_element.color">element.color</code></td>
<td>
<p>color for the default border and axis</p>
</td></tr>
<tr><td><code id="barplotGroupWeights_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for x and y axis relative to the current setting of <code>cex</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='black.litterman'>Black Litterman Estimates</h2><span id='topic+black.litterman'></span>

<h3>Description</h3>

<p>Compute the Black Litterman estimate of moments for the posterior normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>black.litterman(R, P, Mu = NULL, Sigma = NULL, Views = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="black.litterman_+3A_r">R</code></td>
<td>
<p>returns</p>
</td></tr>
<tr><td><code id="black.litterman_+3A_p">P</code></td>
<td>
<p>a K x N pick matrix</p>
</td></tr>
<tr><td><code id="black.litterman_+3A_mu">Mu</code></td>
<td>
<p>vector of length N of the prior expected values. The sample mean
is used if <code>Mu=NULL</code>.</p>
</td></tr>
<tr><td><code id="black.litterman_+3A_sigma">Sigma</code></td>
<td>
<p>an N x N matrix of the prior covariance matrix. The sample 
covariance is used if <code>Sigma=NULL</code>.</p>
</td></tr>
<tr><td><code id="black.litterman_+3A_views">Views</code></td>
<td>
<p>a vector of length K of the views</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>BLMu:</dt><dd><p> posterior expected values</p>
</dd>
<dt>BLSigma:</dt><dd><p> posterior covariance matrix</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is largely based on the work of Xavier Valls to port
the matlab code of Attilio Meucci to <span class="rlang"><b>R</b></span> as documented in the Meucci package.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett, Xavier Valls
</p>


<h3>References</h3>

<p>A. Meucci - &quot;Exercises in Advanced Risk and Portfolio Management&quot; <a href="https://www.arpm.co/articles/exercises-in-advanced-risk-and-portfolio-management/">https://www.arpm.co/articles/exercises-in-advanced-risk-and-portfolio-management/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BlackLittermanFormula">BlackLittermanFormula</a></code>
</p>

<hr>
<h2 id='BlackLittermanFormula'>Computes the Black-Litterman formula for the moments of the posterior normal.</h2><span id='topic+BlackLittermanFormula'></span>

<h3>Description</h3>

<p>This function computes the Black-Litterman formula for the moments of the posterior normal, as described in  
A. Meucci, &quot;Risk and Asset Allocation&quot;, Springer, 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlackLittermanFormula(Mu, Sigma, P, v, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlackLittermanFormula_+3A_mu">Mu</code></td>
<td>
<p>[vector] (N x 1) prior expected values.</p>
</td></tr>
<tr><td><code id="BlackLittermanFormula_+3A_sigma">Sigma</code></td>
<td>
<p>[matrix] (N x N) prior covariance matrix.</p>
</td></tr>
<tr><td><code id="BlackLittermanFormula_+3A_p">P</code></td>
<td>
<p>[matrix] (K x N) pick matrix.</p>
</td></tr>
<tr><td><code id="BlackLittermanFormula_+3A_v">v</code></td>
<td>
<p>[vector] (K x 1) vector of views.</p>
</td></tr>
<tr><td><code id="BlackLittermanFormula_+3A_omega">Omega</code></td>
<td>
<p>[matrix] (K x K) matrix of confidence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BLMu     [vector] (N x 1) posterior expected values.
</p>
<p>BLSigma  [matrix] (N x N) posterior covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Xavier Valls <a href="mailto:flamejat@gmail.com">flamejat@gmail.com</a>
</p>


<h3>References</h3>

<p>A. Meucci - &quot;Exercises in Advanced Risk and Portfolio Management&quot; <a href="https://www.arpm.co/articles/exercises-in-advanced-risk-and-portfolio-management/">https://www.arpm.co/articles/exercises-in-advanced-risk-and-portfolio-management/</a>.
</p>
<p>See Meucci's script for &quot;BlackLittermanFormula.m&quot;
</p>

<hr>
<h2 id='box_constraint'>constructor for box_constraint.</h2><span id='topic+box_constraint'></span>

<h3>Description</h3>

<p>Box constraints specify the upper and lower bounds on the weights of the assets.
This function is called by add.constraint when type=&quot;box&quot; is specified. See <code><a href="#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_constraint(
  type = "box",
  assets,
  min,
  max,
  min_mult,
  max_mult,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="box_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying initial weights</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_min">min</code></td>
<td>
<p>numeric or named vector specifying minimum weight box constraints</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_max">max</code></td>
<td>
<p>numeric or named vector specifying minimum weight box constraints</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_min_mult">min_mult</code></td>
<td>
<p>numeric or named vector specifying minimum multiplier box constraint from initial weight in <code>assets</code></p>
</td></tr>
<tr><td><code id="box_constraint_+3A_max_mult">max_mult</code></td>
<td>
<p>numeric or named vector specifying maximum multiplier box constraint from initial weight in <code>assets</code></p>
</td></tr>
<tr><td><code id="box_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="box_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify box constraints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'box_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

# defaults to min=0 and max=1
pspec &lt;- add.constraint(pspec, type="box")

# specify box constraints as a scalar
pspec &lt;- add.constraint(pspec, type="box", min=0.05, max=0.45)

# specify box constraints per asset
pspec &lt;- add.constraint(pspec, 
                        type="box", 
                        min=c(0.05, 0.10, 0.08, 0.06), 
                        max=c(0.45, 0.55, 0.35, 0.65))
                        
</code></pre>

<hr>
<h2 id='CCCgarch.MM'>compute comoments for use by lower level optimization functions when the conditional covariance matrix is a CCC GARCH model</h2><span id='topic+CCCgarch.MM'></span>

<h3>Description</h3>

<p>it first estimates the conditional GARCH variances, then filters out the 
time-varying volatility and estimates the higher order comoments on the innovations 
rescaled such that their unconditional covariance matrix is the conditional covariance matrix forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCCgarch.MM(R, momentargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CCCgarch.MM_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="CCCgarch.MM_+3A_momentargs">momentargs</code></td>
<td>
<p>list containing arguments to be passed down to lower level functions, default NULL</p>
</td></tr>
<tr><td><code id="CCCgarch.MM_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>

<hr>
<h2 id='center'>Center</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>Center a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used primarily to center a time series of asset returns or 
factors. Each column should represent the returns of an asset or factor 
realizations. The expected value is taken as the sample mean.
</p>
<p>x.centered = x - mean(x)
</p>


<h3>Value</h3>

<p>matrix of centered data
</p>

<hr>
<h2 id='centroid.buckets'>Buckets Centroid</h2><span id='topic+centroid.buckets'></span>

<h3>Description</h3>

<p>Compute the centroid for buckets of assets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid.buckets(buckets, simulations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid.buckets_+3A_buckets">buckets</code></td>
<td>
<p>a list where each element contains the index of the assets in 
the respective bucket. The assets within each bucket have no order. 
The bucket elements are in ascending order such that 
R_bucket_1 &lt; ... &lt; R_bucket_n</p>
</td></tr>
<tr><td><code id="centroid.buckets_+3A_simulations">simulations</code></td>
<td>
<p>number of simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A common use of buckets is to divide the assets into quartiles or deciles,
but is generalized here for an arbitrary number of buckets and arbitrary
number of assets in each bucket.
</p>


<h3>Value</h3>

<p>the centroid vector
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='centroid.complete.mc'>Complete Cases Centroid</h2><span id='topic+centroid.complete.mc'></span>

<h3>Description</h3>

<p>Numerical method to estimate complete cases centroid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid.complete.mc(order, simulations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid.complete.mc_+3A_order">order</code></td>
<td>
<p>a vector of indexes of the relative ranking of expected asset 
returns in ascending order. For example, <code>order = c(2, 3, 1, 4)</code> 
expresses a view on the expected returns such that 
R_2 &lt; R_3 &lt; R_1 &lt; R_4</p>
</td></tr>
<tr><td><code id="centroid.complete.mc_+3A_simulations">simulations</code></td>
<td>
<p>number of simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the centroid vector
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Express a view on the assets such that
# R_2 &lt; R_1 &lt; R_3 &lt; R_4
centroid.complete.mc(c(2, 1, 3, 4))
</code></pre>

<hr>
<h2 id='centroid.sectors'>Multiple Sectors Centroid</h2><span id='topic+centroid.sectors'></span>

<h3>Description</h3>

<p>Compute the centroid for expressing views on the relative ranking of assets
within sectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid.sectors(sectors, simulations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid.sectors_+3A_sectors">sectors</code></td>
<td>
<p>a list where each list element contains the order of each 
asset in the given sector</p>
</td></tr>
<tr><td><code id="centroid.sectors_+3A_simulations">simulations</code></td>
<td>
<p>number of simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the centroid vector
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Express a view on the assets in two sectors
# Sector 1 View: R_2 &lt; R_1 &lt; R_3
# Sector 2 View: R_5 &lt; R_4
x &lt;- list()
x[[1]] &lt;- c(2, 1, 3)
x[[2]] &lt;- c(5, 4)
centroid.sectors(x)
</code></pre>

<hr>
<h2 id='centroid.sign'>Positive and Negative View Centroid</h2><span id='topic+centroid.sign'></span>

<h3>Description</h3>

<p>Compute the centroid for expressing a view on assets with positive or 
negative expected returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid.sign(positive, negative, simulations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid.sign_+3A_positive">positive</code></td>
<td>
<p>a vector of the index of assets with positive expected 
return in ascending order</p>
</td></tr>
<tr><td><code id="centroid.sign_+3A_negative">negative</code></td>
<td>
<p>a vector of the index of assets with negative expected 
return in ascending order.</p>
</td></tr>
<tr><td><code id="centroid.sign_+3A_simulations">simulations</code></td>
<td>
<p>number of simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the centroid vector
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Express a view that 
# R_1 &lt; R_2 &lt; 0 &lt; R_3 &lt; R_4
centroid.sign(c(1, 2), c(4, 3))
</code></pre>

<hr>
<h2 id='chart.Concentration'>Classic risk reward scatter and concentration</h2><span id='topic+chart.Concentration'></span>

<h3>Description</h3>

<p>This function charts the <code>optimize.portfolio</code> object in risk-return space
and the degree of concentration based on the weights or percentage component
contribution to risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.Concentration(
  object,
  ...,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  conc.type = c("weights", "pct_contrib"),
  col = heat.colors(20),
  element.color = "darkgray",
  cex.axis = 0.8,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.Concentration_+3A_object">object</code></td>
<td>
<p>optimal portfolio created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_...">...</code></td>
<td>
<p>any other passthru parameters.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_return.col">return.col</code></td>
<td>
<p>string matching the objective of a 'return' objective, on vertical axis.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_risk.col">risk.col</code></td>
<td>
<p>string matching the objective of a 'risk' objective, on horizontal axis.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE. Includes a risk reward scatter of the assets in the chart.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_conc.type">conc.type</code></td>
<td>
<p>concentration type can be based on the concentration of weights
or concentration of percentage component contribution to risk (only works with risk
budget objective for the optimization).</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_col">col</code></td>
<td>
<p>color palette or vector of colors to use.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_element.color">element.color</code></td>
<td>
<p>color for the border and axes.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.Concentration_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Carl and Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='chart.EF.Weights'>Chart weights along an efficient frontier</h2><span id='topic+chart.EF.Weights'></span><span id='topic+chart.EF.Weights.efficient.frontier'></span><span id='topic+chart.EF.Weights.optimize.portfolio'></span>

<h3>Description</h3>

<p>This function produces a stacked barplot of weights along an efficient frontier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.EF.Weights(object, ...)

## S3 method for class 'efficient.frontier'
chart.EF.Weights(
  object,
  ...,
  colorset = NULL,
  n.portfolios = 25,
  by.groups = FALSE,
  match.col = "ES",
  main = "",
  cex.lab = 0.8,
  cex.axis = 0.8,
  cex.legend = 0.8,
  legend.labels = NULL,
  element.color = "darkgray",
  legend.loc = "topright"
)

## S3 method for class 'optimize.portfolio'
chart.EF.Weights(
  object,
  ...,
  colorset = NULL,
  n.portfolios = 25,
  by.groups = FALSE,
  match.col = "ES",
  main = "",
  cex.lab = 0.8,
  cex.axis = 0.8,
  cex.legend = 0.8,
  legend.labels = NULL,
  element.color = "darkgray",
  legend.loc = "topright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.EF.Weights_+3A_object">object</code></td>
<td>
<p>object of class <code>efficient.frontier</code> or <code>optimize.portfolio</code>.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code>barplot</code>.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_colorset">colorset</code></td>
<td>
<p>color palette or vector of colors to use.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to extract along the efficient frontier.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_by.groups">by.groups</code></td>
<td>
<p>TRUE/FALSE. If TRUE, the group weights are charted.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_match.col">match.col</code></td>
<td>
<p>string name of column to use for risk (horizontal axis). Must match the name of an objective.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_main">main</code></td>
<td>
<p>title used in the plot.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_cex.lab">cex.lab</code></td>
<td>
<p>the magnification to be used for x-axis and y-axis labels relative to the current setting of 'cex'.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for sizing the axis text relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_cex.legend">cex.legend</code></td>
<td>
<p>the magnification to be used for sizing the legend relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_legend.labels">legend.labels</code></td>
<td>
<p>character vector to use for the legend labels.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.EF.Weights_+3A_legend.loc">legend.loc</code></td>
<td>
<p>NULL, &quot;topright&quot;, &quot;right&quot;, or &quot;bottomright&quot;. If legend.loc is NULL, the legend will not be plotted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='chart.EfficientFrontier'>Chart the efficient frontier and risk-return scatter</h2><span id='topic+chart.EfficientFrontier'></span><span id='topic+chart.EfficientFrontier.optimize.portfolio.CVXR'></span><span id='topic+chart.EfficientFrontier.optimize.portfolio.ROI'></span><span id='topic+chart.EfficientFrontier.optimize.portfolio'></span><span id='topic+chart.EfficientFrontier.efficient.frontier'></span>

<h3>Description</h3>

<p>Chart the efficient frontier and risk-return scatter of the assets for 
<code>optimize.portfolio</code> or <code>efficient.frontier</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.EfficientFrontier(object, ...)

## S3 method for class 'optimize.portfolio.CVXR'
chart.EfficientFrontier(
  object,
  ...,
  optimize_method = "CVXR",
  match.col = "ES",
  n.portfolios = 25,
  xlim = NULL,
  ylim = NULL,
  cex.axis = 0.8,
  element.color = "darkgray",
  main = "Efficient Frontier",
  RAR.text = "SR",
  rf = 0,
  tangent.line = TRUE,
  cex.legend = 0.8,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8
)

## S3 method for class 'optimize.portfolio.ROI'
chart.EfficientFrontier(
  object,
  ...,
  optimize_method = "ROI",
  match.col = "ES",
  n.portfolios = 25,
  xlim = NULL,
  ylim = NULL,
  cex.axis = 0.8,
  element.color = "darkgray",
  main = "Efficient Frontier",
  RAR.text = "SR",
  rf = 0,
  tangent.line = TRUE,
  cex.legend = 0.8,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8
)

## S3 method for class 'optimize.portfolio'
chart.EfficientFrontier(
  object,
  ...,
  match.col = "ES",
  n.portfolios = 25,
  xlim = NULL,
  ylim = NULL,
  cex.axis = 0.8,
  element.color = "darkgray",
  main = "Efficient Frontier",
  RAR.text = "SR",
  rf = 0,
  tangent.line = TRUE,
  cex.legend = 0.8,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8
)

## S3 method for class 'efficient.frontier'
chart.EfficientFrontier(
  object,
  ...,
  match.col = "ES",
  n.portfolios = NULL,
  xlim = NULL,
  ylim = NULL,
  cex.axis = 0.8,
  element.color = "darkgray",
  main = "Efficient Frontier",
  RAR.text = "SR",
  rf = 0,
  tangent.line = TRUE,
  cex.legend = 0.8,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.EfficientFrontier_+3A_object">object</code></td>
<td>
<p>object to chart.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_match.col">match.col</code></td>
<td>
<p>string name of column to use for risk (horizontal axis).
<code>match.col</code> must match the name of an objective measure in the 
<code>objective_measures</code> or <code>opt_values</code> slot in the object created 
by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to use to plot the efficient frontier.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_cex.axis">cex.axis</code></td>
<td>
<p>numerical value giving the amount by which the axis should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_rar.text">RAR.text</code></td>
<td>
<p>string name for risk adjusted return text to plot in the legend.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_rf">rf</code></td>
<td>
<p>risk free rate. If <code>rf</code> is not null, the maximum Sharpe Ratio or modified Sharpe Ratio tangency portfolio will be plotted.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_tangent.line">tangent.line</code></td>
<td>
<p>TRUE/FALSE to plot the tangent line.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_cex.legend">cex.legend</code></td>
<td>
<p>numerical value giving the amount by which the legend should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE to include the assets.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_labels.assets">labels.assets</code></td>
<td>
<p>TRUE/FALSE to include the asset names in the plot. 
<code>chart.assets</code> must be <code>TRUE</code> to plot asset names.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_pch.assets">pch.assets</code></td>
<td>
<p>plotting character of the assets, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontier_+3A_cex.assets">cex.assets</code></td>
<td>
<p>numerical value giving the amount by which the asset points and labels should be magnified relative to the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects created by optimize.portfolio with 'DEoptim', 'random', or 'pso'
specified as the optimize_method:
</p>

<ul>
<li><p> The efficient frontier plotted is based on the the trace information (sets of 
portfolios tested by the solver at each iteration) in objects created by 
<code>optimize.portfolio</code>.
</p>
</li></ul>

<p>For objects created by optimize.portfolio with 'ROI' specified as the 
optimize_method:
</p>

<ul>
<li><p> The mean-StdDev or mean-ETL efficient frontier can be plotted for optimal
portfolio objects created by <code>optimize.portfolio</code>.
</p>
</li>
<li><p> If <code>match.col="StdDev"</code>, the mean-StdDev efficient frontier is plotted.
</p>
</li>
<li><p> If <code>match.col="ETL"</code> (also &quot;ES&quot; or &quot;CVaR&quot;), the mean-ETL efficient frontier is plotted.
</p>
</li></ul>

<p>Note that <code>trace=TRUE</code> must be specified in <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>
<p>GenSA does not return any useable trace information for portfolios tested at 
each iteration, therfore we cannot extract and chart an efficient frontier.
</p>
<p>By default, the tangency portfolio (maximum Sharpe Ratio or modified Sharpe Ratio)
will be plotted using a risk free rate of 0. Set <code>rf=NULL</code> to omit 
this from the plot.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett, Xinran Zhao
</p>

<hr>
<h2 id='chart.EfficientFrontierCompare'>Overlay the efficient frontiers of different minRisk portfolio objects on a single plot.</h2><span id='topic+chart.EfficientFrontierCompare'></span>

<h3>Description</h3>

<p>Overlay the efficient frontiers of different minRisk portfolio objects on a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.EfficientFrontierCompare(
  R,
  portfolio,
  risk_type,
  n.portfolios = 25,
  match.col = c("StdDev", "ES"),
  guideline = NULL,
  main = "Efficient Frontiers",
  plot_type = "l",
  cex.axis = 0.5,
  element.color = "darkgray",
  legend.loc = NULL,
  legend.labels = NULL,
  cex.legend = 0.8,
  xlim = NULL,
  ylim = NULL,
  ...,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8,
  col = NULL,
  lty = NULL,
  lwd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.EfficientFrontierCompare_+3A_r">R</code></td>
<td>
<p>an xts object of asset returns</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_portfolio">portfolio</code></td>
<td>
<p>same constrained portfolio created by <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_risk_type">risk_type</code></td>
<td>
<p>type of risk that you want to compare</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to extract along the efficient frontier.
This is only used for objects of class <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_match.col">match.col</code></td>
<td>
<p>string name of column to use for portfolio object.
Must match the name of an objective.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_guideline">guideline</code></td>
<td>
<p>show the risk difference and mean difference between efficient frontiers</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_main">main</code></td>
<td>
<p>title used in the plot.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_plot_type">plot_type</code></td>
<td>
<p>define the plot_type, default is &quot;l&quot;</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for sizing the axis text relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_legend.loc">legend.loc</code></td>
<td>
<p>location of the legend; NULL, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_legend.labels">legend.labels</code></td>
<td>
<p>character vector to use for the legend labels.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for sizing the legend relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE to include the assets.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_labels.assets">labels.assets</code></td>
<td>
<p>TRUE/FALSE to include the asset names in the plot.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_pch.assets">pch.assets</code></td>
<td>
<p>plotting character of the assets, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_cex.assets">cex.assets</code></td>
<td>
<p>A numerical value giving the amount by which the asset points and labels should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_col">col</code></td>
<td>
<p>vector of colors with length equal to the number of portfolios in <code>portfolio_list</code>. Add two more to customize guideline color.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_lty">lty</code></td>
<td>
<p>vector of line types with length equal to the number of portfolios in <code>portfolio_list</code>. Add two more to customize guideline type.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierCompare_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths with length equal to the number of portfolios in <code>portfolio_list</code>. Add two more to customize guideline width.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinran Zhao
</p>

<hr>
<h2 id='chart.EfficientFrontierOverlay'>Plot multiple efficient frontiers</h2><span id='topic+chart.EfficientFrontierOverlay'></span>

<h3>Description</h3>

<p>Overlay the efficient frontiers of multiple portfolio objects on a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.EfficientFrontierOverlay(
  R,
  portfolio_list,
  type,
  n.portfolios = 25,
  match.col = "ES",
  search_size = 2000,
  main = "Efficient Frontiers",
  cex.axis = 0.8,
  element.color = "darkgray",
  legend.loc = NULL,
  legend.labels = NULL,
  cex.legend = 0.8,
  xlim = NULL,
  ylim = NULL,
  ...,
  chart.assets = TRUE,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8,
  col = NULL,
  lty = NULL,
  lwd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_r">R</code></td>
<td>
<p>an xts object of asset returns</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_portfolio_list">portfolio_list</code></td>
<td>
<p>list of portfolio objects created by 
<code><a href="#topic+portfolio.spec">portfolio.spec</a></code> and combined with <code><a href="#topic+combine.portfolios">combine.portfolios</a></code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_type">type</code></td>
<td>
<p>type of efficient frontier, see <code><a href="#topic+create.EfficientFrontier">create.EfficientFrontier</a></code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to extract along the efficient frontier.
This is only used for objects of class <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_match.col">match.col</code></td>
<td>
<p>string name of column to use for risk (horizontal axis).
Must match the name of an objective.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_search_size">search_size</code></td>
<td>
<p>passed to optimize.portfolio for type=&quot;DEoptim&quot; or type=&quot;random&quot;.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_main">main</code></td>
<td>
<p>title used in the plot.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for sizing the axis text relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_legend.loc">legend.loc</code></td>
<td>
<p>location of the legend; NULL, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_legend.labels">legend.labels</code></td>
<td>
<p>character vector to use for the legend labels.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for sizing the legend relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE to include the assets.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_labels.assets">labels.assets</code></td>
<td>
<p>TRUE/FALSE to include the asset names in the plot.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_pch.assets">pch.assets</code></td>
<td>
<p>plotting character of the assets, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_cex.assets">cex.assets</code></td>
<td>
<p>A numerical value giving the amount by which the asset points and labels should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_col">col</code></td>
<td>
<p>vector of colors with length equal to the number of portfolios in <code>portfolio_list</code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_lty">lty</code></td>
<td>
<p>vector of line types with length equal to the number of portfolios in <code>portfolio_list</code>.</p>
</td></tr>
<tr><td><code id="chart.EfficientFrontierOverlay_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths with length equal to the number of portfolios in <code>portfolio_list</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='chart.GroupWeights'>Chart weights by group or category</h2><span id='topic+chart.GroupWeights'></span>

<h3>Description</h3>

<p>Chart weights by group or category
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.GroupWeights(
  object,
  ...,
  grouping = c("groups", "category"),
  plot.type = "line",
  main = "Group Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 0.8,
  element.color = "darkgray",
  cex.axis = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.GroupWeights_+3A_object">object</code></td>
<td>
<p>object of class <code>optimize.portfolio</code>.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_grouping">grouping</code></td>
<td>

<dl>
<dt>groups: </dt><dd><p>group the weights by group constraints.</p>
</dd>
<dt>category_labels: </dt><dd><p>group the weights by category_labels in the <code>portfolio</code> object.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_plot.type">plot.type</code></td>
<td>
<p>&quot;line&quot; or &quot;barplot&quot;.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the style of axis labels
</p>

<dl>
<dt>0:</dt><dd><p>always parallel to the axis,</p>
</dd>
<dt>1:</dt><dd><p>always horizontal,</p>
</dd>
<dt>2:</dt><dd><p>always perpendicular to the axis,</p>
</dd>
<dt>3:</dt><dd><p>always vertical[<em>default</em>].</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_cex.lab">cex.lab</code></td>
<td>
<p>the magnification to be used for x and y labels relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_element.color">element.color</code></td>
<td>
<p>color for the default border and axis.</p>
</td></tr>
<tr><td><code id="chart.GroupWeights_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for x and y axis relative to the current setting of <code>cex</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='chart.RiskBudget'>Generic method to chart risk contribution</h2><span id='topic+chart.RiskBudget'></span><span id='topic+chart.RiskBudget.optimize.portfolio'></span><span id='topic+chart.RiskBudget.optimize.portfolio.rebalancing'></span><span id='topic+chart.RiskBudget.opt.list'></span>

<h3>Description</h3>

<p>This function is the generic method to chart risk budget objectives for 
<code>optimize.portfolio</code>, <code>optimize.portfolio.rebalancing</code>, and 
<code>opt.list</code> objects. This function charts the contribution or percent 
contribution of the resulting objective measures of a 
<code>risk_budget_objective</code>. The risk contributions for <code>optimize.portfolio.rebalancing</code>
objects are plotted through time with <code><a href="PerformanceAnalytics.html#topic+chart.StackedBar">chart.StackedBar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.RiskBudget(object, ...)

## S3 method for class 'optimize.portfolio'
chart.RiskBudget(
  object,
  ...,
  neighbors = NULL,
  risk.type = "absolute",
  main = "Risk Contribution",
  ylab = "",
  xlab = NULL,
  cex.axis = 0.8,
  cex.lab = 0.8,
  element.color = "darkgray",
  las = 3,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.rebalancing'
chart.RiskBudget(
  object,
  ...,
  match.col = "ES",
  risk.type = "absolute",
  regime = NULL,
  main = "Risk Contribution"
)

## S3 method for class 'opt.list'
chart.RiskBudget(
  object,
  ...,
  match.col = "ES",
  risk.type = "absolute",
  main = "Risk Budget",
  plot.type = "line",
  cex.axis = 0.8,
  cex.lab = 0.8,
  element.color = "darkgray",
  las = 3,
  ylim = NULL,
  colorset = NULL,
  legend.loc = NULL,
  cex.legend = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.RiskBudget_+3A_object">object</code></td>
<td>
<p>optimal portfolio object created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
or <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code></p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_neighbors">neighbors</code></td>
<td>
<p>risk contribution or pct_contrib of neighbor portfolios to be plotted, see Details.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_risk.type">risk.type</code></td>
<td>
<p>&quot;absolute&quot; or &quot;percentage&quot; to plot risk contribution in absolute terms or percentage contribution.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_main">main</code></td>
<td>
<p>main title for the chart.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_cex.lab">cex.lab</code></td>
<td>
<p>the magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the style of axis labels
</p>

<dl>
<dt>0:</dt><dd><p>always parallel to the axis [<em>default</em>],</p>
</dd>
<dt>1:</dt><dd><p>always horizontal,</p>
</dd>
<dt>2:</dt><dd><p>always perpendicular to the axis,</p>
</dd>
<dt>3:</dt><dd><p>always vertical.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_match.col">match.col</code></td>
<td>
<p>string of risk column to match. The <code>opt.list</code> object 
may contain risk budgets for ES or StdDev and this will match the proper 
column names of the objectives list outp (e.g. ES.contribution).</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_regime">regime</code></td>
<td>
<p>integer of the regime number. For use with 
<code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code> run with regime switching portfolios.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_plot.type">plot.type</code></td>
<td>
<p>&quot;line&quot; or &quot;barplot&quot;.</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_colorset">colorset</code></td>
<td>
<p>color palette or vector of colors to use</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_legend.loc">legend.loc</code></td>
<td>
<p>legend.loc NULL, &quot;topright&quot;, &quot;right&quot;, or &quot;bottomright&quot;. If legend.loc is NULL, the legend will not be plotted</p>
</td></tr>
<tr><td><code id="chart.RiskBudget_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for the legend relative to the current setting of <code>cex</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>neighbors</code> may be specified in three ways.  
The first is as a single number of neighbors. This will extract the 
<code>neighbors</code> closest to the portfolios in terms of the <code>out</code> 
numerical statistic.
The second method consists of a numeric vector for <code>neighbors</code>.
This will extract the <code>neighbors</code> with portfolio index numbers that 
correspond to the vector contents.
The third method for specifying <code>neighbors</code> is to pass in a matrix.  
This matrix should look like the output of <code><a href="#topic+extractStats">extractStats</a></code>, and 
should contain properly named contribution and pct_contrib columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code> <code><a href="PerformanceAnalytics.html#topic+chart.StackedBar">chart.StackedBar</a></code>
</p>

<hr>
<h2 id='chart.RiskReward'>classic risk reward scatter</h2><span id='topic+chart.RiskReward'></span><span id='topic+chart.RiskReward.optimize.portfolio.DEoptim'></span><span id='topic+chart.RiskReward.optimize.portfolio.GenSA'></span><span id='topic+chart.RiskReward.optimize.portfolio.pso'></span><span id='topic+chart.RiskReward.optimize.portfolio.ROI'></span><span id='topic+chart.RiskReward.optimize.portfolio.random'></span><span id='topic+chart.RiskReward.opt.list'></span>

<h3>Description</h3>

<p>This function charts the <code>optimize.portfolio</code> object in risk-return space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.RiskReward(object, ...)

## S3 method for class 'optimize.portfolio.DEoptim'
chart.RiskReward(
  object,
  ...,
  neighbors = NULL,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  element.color = "darkgray",
  cex.axis = 0.8,
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.GenSA'
chart.RiskReward(
  object,
  ...,
  neighbors = NULL,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  element.color = "darkgray",
  cex.axis = 0.8,
  ylim = NULL,
  xlim = NULL,
  rp = FALSE
)

## S3 method for class 'optimize.portfolio.pso'
chart.RiskReward(
  object,
  ...,
  neighbors = NULL,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  element.color = "darkgray",
  cex.axis = 0.8,
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.ROI'
chart.RiskReward(
  object,
  ...,
  neighbors = NULL,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  element.color = "darkgray",
  cex.axis = 0.8,
  xlim = NULL,
  ylim = NULL,
  rp = FALSE
)

## S3 method for class 'optimize.portfolio.random'
chart.RiskReward(
  object,
  ...,
  neighbors = NULL,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  element.color = "darkgray",
  cex.axis = 0.8,
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'opt.list'
chart.RiskReward(
  object,
  ...,
  risk.col = "ES",
  return.col = "mean",
  main = "",
  ylim = NULL,
  xlim = NULL,
  labels.assets = TRUE,
  chart.assets = FALSE,
  pch.assets = 1,
  cex.assets = 0.8,
  cex.axis = 0.8,
  cex.lab = 0.8,
  colorset = NULL,
  element.color = "darkgray"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.RiskReward_+3A_object">object</code></td>
<td>
<p>optimal portfolio created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_...">...</code></td>
<td>
<p>any other passthru parameters.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_neighbors">neighbors</code></td>
<td>
<p>set of 'neighbor' portfolios to overplot, see Details.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_return.col">return.col</code></td>
<td>
<p>string matching the objective of a 'return' objective, on vertical axis.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_risk.col">risk.col</code></td>
<td>
<p>string matching the objective of a 'risk' objective, on horizontal axis.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE. Includes a risk reward scatter of the assets in the chart.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_element.color">element.color</code></td>
<td>
<p>color for the default plot scatter points.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_rp">rp</code></td>
<td>
<p>TRUE/FALSE to generate random portfolios to plot the feasible space</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_labels.assets">labels.assets</code></td>
<td>
<p>TRUE/FALSE to include the names in the plot.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_pch.assets">pch.assets</code></td>
<td>
<p>plotting character of the assets, same as in <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_cex.assets">cex.assets</code></td>
<td>
<p>numerical value giving the amount by which the asset points should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_cex.lab">cex.lab</code></td>
<td>
<p>numerical value giving the amount by which the labels should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="chart.RiskReward_+3A_colorset">colorset</code></td>
<td>
<p>color palette or vector of colors to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>neighbors</code> may be specified in three ways.  
The first is as a single number of neighbors.  This will extract the <code>neighbors</code> closest 
portfolios in terms of the <code>out</code> numerical statistic.
The second method consists of a numeric vector for <code>neighbors</code>.
This will extract the <code>neighbors</code> with portfolio index numbers that correspond to the vector contents.
The third method for specifying <code>neighbors</code> is to pass in a matrix.  
This matrix should look like the output of <code><a href="#topic+extractStats">extractStats</a></code>, and should contain
<code>risk.col</code>,<code>return.col</code>, and weights columns all properly named.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='chart.Weights'>boxplot of the weights of the optimal portfolios</h2><span id='topic+chart.Weights'></span><span id='topic+chart.Weights.optimize.portfolio.rebalancing'></span><span id='topic+chart.Weights.optimize.portfolio.DEoptim'></span><span id='topic+chart.Weights.optimize.portfolio.GenSA'></span><span id='topic+chart.Weights.optimize.portfolio.pso'></span><span id='topic+chart.Weights.optimize.portfolio.ROI'></span><span id='topic+chart.Weights.optimize.portfolio.random'></span><span id='topic+chart.Weights.opt.list'></span>

<h3>Description</h3>

<p>This function charts the optimal weights of a portfolio run via 
<code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> or <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code>.
The upper and lower bounds on weights can be plotted for single period optimizations.
The optimal weights will be charted through time for <code>optimize.portfolio.rebalancing</code>
objects. For <code>optimize.portfolio.rebalancing</code> objects, the weights are
plotted with <code><a href="PerformanceAnalytics.html#topic+chart.StackedBar">chart.StackedBar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart.Weights(object, ...)

## S3 method for class 'optimize.portfolio.rebalancing'
chart.Weights(object, ..., main = "Weights")

## S3 method for class 'optimize.portfolio.DEoptim'
chart.Weights(
  object,
  ...,
  neighbors = NULL,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)

## S3 method for class 'optimize.portfolio.GenSA'
chart.Weights(
  object,
  ...,
  neighbors = NULL,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)

## S3 method for class 'optimize.portfolio.pso'
chart.Weights(
  object,
  ...,
  neighbors = NULL,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)

## S3 method for class 'optimize.portfolio.ROI'
chart.Weights(
  object,
  ...,
  neighbors = NULL,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)

## S3 method for class 'optimize.portfolio.random'
chart.Weights(
  object,
  ...,
  neighbors = NULL,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)

## S3 method for class 'opt.list'
chart.Weights(
  object,
  neighbors = NULL,
  ...,
  main = "Weights",
  las = 3,
  xlab = NULL,
  cex.lab = 1,
  element.color = "darkgray",
  cex.axis = 0.8,
  colorset = NULL,
  legend.loc = "topright",
  cex.legend = 0.8,
  plot.type = "line"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chart.Weights_+3A_object">object</code></td>
<td>
<p>optimal portfolio object created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_...">...</code></td>
<td>
<p>any other passthru parameters .</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_neighbors">neighbors</code></td>
<td>
<p>set of 'neighbor' portfolios to overplot. See Details.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the style of axis labels
</p>

<dl>
<dt>0:</dt><dd><p>always parallel to the axis,</p>
</dd>
<dt>1:</dt><dd><p>always horizontal,</p>
</dd>
<dt>2:</dt><dd><p>always perpendicular to the axis,</p>
</dd>
<dt>3:</dt><dd><p>always vertical [<em>default</em>].</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="chart.Weights_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of <code>cex</code></p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_colorset">colorset</code></td>
<td>
<p>color palette or vector of colors to use.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_legend.loc">legend.loc</code></td>
<td>
<p>location of the legend. If NULL, the legend will not be plotted.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for legend annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="chart.Weights_+3A_plot.type">plot.type</code></td>
<td>
<p>&quot;line&quot; or &quot;barplot&quot; to plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code> <code><a href="PerformanceAnalytics.html#topic+chart.StackedBar">chart.StackedBar</a></code>
</p>

<hr>
<h2 id='check_constraints'>check if a set of weights satisfies the constraints</h2><span id='topic+check_constraints'></span>

<h3>Description</h3>

<p>This function checks if a set of weights satisfies all constraints. This is
used as a helper function for random portfolios created with <code>rp_simplex</code>
and <code>rp_grid</code> to eliminate portfolios that do not satisfy the constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_constraints(weights, portfolio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_constraints_+3A_weights">weights</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_portfolio">portfolio</code></td>
<td>
<p>object of class 'portfolio'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all constraints are satisfied, FALSE if any constraint is violated
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='cokurtosisMF'>Cokurtosis Matrix Estimate</h2><span id='topic+cokurtosisMF'></span>

<h3>Description</h3>

<p>Estimate cokurtosis matrix using a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cokurtosisMF(beta, stockM2, stockM4, factorM2, factorM4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cokurtosisMF_+3A_beta">beta</code></td>
<td>
<p>(N x k) matrix of factor loadings (i.e. the betas) from a 
statistical factor model</p>
</td></tr>
<tr><td><code id="cokurtosisMF_+3A_stockm2">stockM2</code></td>
<td>
<p>vector of length N of the 2nd moment of the model residuals</p>
</td></tr>
<tr><td><code id="cokurtosisMF_+3A_stockm4">stockM4</code></td>
<td>
<p>vector of length N of the 4th moment of the model residuals</p>
</td></tr>
<tr><td><code id="cokurtosisMF_+3A_factorm2">factorM2</code></td>
<td>
<p>(k x k) matrix of the 2nd moment of the factor 
realizations from a statistical factor model</p>
</td></tr>
<tr><td><code id="cokurtosisMF_+3A_factorm4">factorM4</code></td>
<td>
<p>(k x k^3) matrix of the 4th moment of the factor 
realizations from a statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N^3) cokurtosis matrix from a statistical 
factor model with k factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N^3) cokurtosis matrix
</p>

<hr>
<h2 id='cokurtosisSF'>Cokurtosis Matrix Estimate</h2><span id='topic+cokurtosisSF'></span>

<h3>Description</h3>

<p>Estimate cokurtosis matrix using a single factor statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cokurtosisSF(beta, stockM2, stockM4, factorM2, factorM4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cokurtosisSF_+3A_beta">beta</code></td>
<td>
<p>vector of length N or (N x 1) matrix of factor loadings 
(i.e. the betas) from a single factor statistical factor model</p>
</td></tr>
<tr><td><code id="cokurtosisSF_+3A_stockm2">stockM2</code></td>
<td>
<p>vector of length N of the 2nd moment of the model residuals</p>
</td></tr>
<tr><td><code id="cokurtosisSF_+3A_stockm4">stockM4</code></td>
<td>
<p>vector of length N of the 4th moment of the model residuals</p>
</td></tr>
<tr><td><code id="cokurtosisSF_+3A_factorm2">factorM2</code></td>
<td>
<p>scalar of the 2nd moment of the factor realizations from a 
single factor statistical factor model</p>
</td></tr>
<tr><td><code id="cokurtosisSF_+3A_factorm4">factorM4</code></td>
<td>
<p>scalar of the 4th moment of the factor realizations from a 
single factor statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N^3) cokurtosis matrix from a statistical 
factor model with k factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N^3) cokurtosis matrix
</p>

<hr>
<h2 id='combine.optimizations'>Combine objects created by optimize.portfolio</h2><span id='topic+combine.optimizations'></span>

<h3>Description</h3>

<p>This function takes a list of objects created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
and sets the class name attribute to 'opt.list' for use in generic functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.optimizations(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.optimizations_+3A_x">x</code></td>
<td>
<p>a list of objects created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>opt.list</code> object
</p>

<hr>
<h2 id='combine.portfolios'>Combine a list of portfolio objects</h2><span id='topic+combine.portfolios'></span>

<h3>Description</h3>

<p>This function takes a list of objects created by <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
and sets the class name attribute to 'portfolio.list' for use in generic functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.portfolios(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.portfolios_+3A_x">x</code></td>
<td>
<p>a list of objects created by <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>portfolio.list</code> object
</p>

<hr>
<h2 id='constrained_objective'>calculate a numeric return value for a portfolio based on a set of constraints and objectives</h2><span id='topic+constrained_objective'></span><span id='topic+constrained_objective_v1'></span><span id='topic+constrained_objective_v2'></span>

<h3>Description</h3>

<p>Function to calculate a numeric return value for a portfolio based on a set of constraints and objectives.
We'll try to make as few assumptions as possible and only run objectives that are enabled by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrained_objective_v1(
  w,
  R,
  constraints,
  ...,
  trace = FALSE,
  normalize = TRUE,
  storage = FALSE
)

constrained_objective(
  w,
  R,
  portfolio,
  ...,
  trace = FALSE,
  normalize = TRUE,
  storage = FALSE,
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrained_objective_+3A_w">w</code></td>
<td>
<p>a vector of weights to test.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_constraints">constraints</code></td>
<td>
<p>a v1_constraint object for backwards compatibility with <code>constrained_objective_v1</code>.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE whether to include debugging and additional detail in the output list. The default is FALSE. Several charting functions require that <code>trace=TRUE</code>.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_normalize">normalize</code></td>
<td>
<p>TRUE/FALSE whether to normalize results to min/max sum (TRUE), or let the optimizer penalize portfolios that do not conform (FALSE)</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_storage">storage</code></td>
<td>
<p>TRUE/FALSE default TRUE for DEoptim with trace, otherwise FALSE. not typically user-called.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class <code>portfolio</code> specifying the constraints and objectives for the optimization, see <code><a href="#topic+portfolio">portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="constrained_objective_+3A_env">env</code></td>
<td>
<p>environment of moments calculated in <code>optimize.portfolio</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user has passed in either min_sum or max_sum constraints for the portfolio, or both, 
and are using a numerical optimization method like DEoptim, and normalize=TRUE,
we'll normalize the weights passed in to whichever boundary condition has been violated.  
If using random portfolios, all the portfolios generated will meet the constraints by construction.
NOTE: this means that the weights produced by a numeric optimization algorithm like DEoptim, pso, or GenSA
might violate constraints, and will need to be renormalized after optimizing.
We apply the same normalization in <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> so that the weights you see have been 
normalized to min_sum if the generated portfolio is smaller than min_sum or max_sum if the 
generated portfolio is larger than max_sum.  
This normalization increases the speed of optimization and convergence by several orders of magnitude in many cases.
</p>
<p>You may find that for some portfolios, normalization is not desirable, if the algorithm 
cannot find a direction in which to move to head towards an optimal portfolio.  In these cases, 
it may be best to set normalize=FALSE, and penalize the portfolios if the sum of the weighting 
vector lies outside the min_sum and/or max_sum.
</p>
<p>Whether or not we normalize the weights using min_sum and max_sum, and are using a numerical optimization 
engine like DEoptim, we will penalize portfolios that violate weight constraints in much the same way
we penalize other constraints.  If a min_sum/max_sum normalization has not occurred, convergence
can take a very long time.  We currently do not allow for a non-normalized full investment constraint.  
Future version of this function could include this additional constraint penalty. 
</p>
<p>When you are optimizing a return objective, you must specify a negative multiplier 
for the return objective so that the function will maximize return.  If you specify a target return,
any return that deviates from your target will be penalized.  If you do not specify a target return, 
you may need to specify a negative VTR (value to reach) , or the function will not converge.  
Try the maximum expected return times the multiplier (e.g. -1 or -10).  
Adding a return objective defaults the multiplier to -1.
</p>
<p>Additional parameters for other solvers 
(e.g. random portfolios or 
<code><a href="DEoptim.html#topic+DEoptim.control">DEoptim.control</a></code> or pso or GenSA 
may be passed in via ...
</p>


<h3>Author(s)</h3>

<p>Kris Boudt, Peter Carl, Brian G. Peterson, Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constraint">constraint</a></code>, <code><a href="#topic+objective">objective</a></code>, <code><a href="DEoptim.html#topic+DEoptim.control">DEoptim.control</a></code>
</p>

<hr>
<h2 id='constraint_ROI'>constructor for class constraint_ROI</h2><span id='topic+constraint_ROI'></span>

<h3>Description</h3>

<p>constructor for class constraint_ROI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint_ROI(
  assets = NULL,
  op.problem,
  solver = c("glpk", "quadprog"),
  weight_seq = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constraint_ROI_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying seed weights</p>
</td></tr>
<tr><td><code id="constraint_ROI_+3A_op.problem">op.problem</code></td>
<td>
<p>an object of type &quot;OP&quot; (optimization problem, of <code>ROI</code>) specifying the complete optimization problem, see ROI help pages for proper construction of OP object.</p>
</td></tr>
<tr><td><code id="constraint_ROI_+3A_solver">solver</code></td>
<td>
<p>string argument for what solver package to use, must have ROI plugin installed for that solver.  Currently support is for <code>glpk</code> and <code>quadprog</code>.</p>
</td></tr>
<tr><td><code id="constraint_ROI_+3A_weight_seq">weight_seq</code></td>
<td>
<p>seed sequence of weights, see <code><a href="#topic+generatesequence">generatesequence</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hezky Varon
</p>

<hr>
<h2 id='constraint_v1'>constructors for class constraint</h2><span id='topic+constraint_v1'></span><span id='topic+constraint'></span><span id='topic+constraint_v2'></span>

<h3>Description</h3>

<p>See main documentation entry in <code><a href="#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint_v1(
  assets = NULL,
  ...,
  min,
  max,
  min_mult,
  max_mult,
  min_sum = 0.99,
  max_sum = 1.01,
  weight_seq = NULL
)

constraint(type, enabled = TRUE, ..., constrclass = "v2_constraint")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constraint_v1_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying initial weights</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_min">min</code></td>
<td>
<p>numeric or named vector specifying minimum weight box constraints</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_max">max</code></td>
<td>
<p>numeric or named vector specifying minimum weight box constraints</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_min_mult">min_mult</code></td>
<td>
<p>numeric or named vector specifying minimum multiplier box constraint from initial weight in <code>assets</code></p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_max_mult">max_mult</code></td>
<td>
<p>numeric or named vector specifying maximum multiplier box constraint from initial weight in <code>assets</code></p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_min_sum">min_sum</code></td>
<td>
<p>minimum sum of all asset weights, default .99</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_max_sum">max_sum</code></td>
<td>
<p>maximum sum of all asset weights, default 1.01</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_weight_seq">weight_seq</code></td>
<td>
<p>seed sequence of weights, see <code><a href="#topic+generatesequence">generatesequence</a></code></p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_type">type</code></td>
<td>
<p>character type of the constraint to add or update</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE to enabled the constraint</p>
</td></tr>
<tr><td><code id="constraint_v1_+3A_constrclass">constrclass</code></td>
<td>
<p>name of class for the constraint</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This includes the deprecated constructor for the <code>v1_constraint</code> object for backwards compatibility.
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>

<hr>
<h2 id='coskewnessMF'>Coskewness Matrix Estimate</h2><span id='topic+coskewnessMF'></span>

<h3>Description</h3>

<p>Estimate coskewness matrix using a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coskewnessMF(beta, stockM3, factorM3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coskewnessMF_+3A_beta">beta</code></td>
<td>
<p>(N x k) matrix of factor loadings (i.e. the betas) from a 
statistical factor model</p>
</td></tr>
<tr><td><code id="coskewnessMF_+3A_stockm3">stockM3</code></td>
<td>
<p>vector of length N of the 3rd moment of the model residuals</p>
</td></tr>
<tr><td><code id="coskewnessMF_+3A_factorm3">factorM3</code></td>
<td>
<p>(k x k^2) matrix of the 3rd moment of the factor 
realizations from a statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N^2) coskewness matrix from a statistical 
factor model with k factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N^2) coskewness matrix
</p>

<hr>
<h2 id='coskewnessSF'>Coskewness Matrix Estimate</h2><span id='topic+coskewnessSF'></span>

<h3>Description</h3>

<p>Estimate coskewness matrix using a single factor statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coskewnessSF(beta, stockM3, factorM3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coskewnessSF_+3A_beta">beta</code></td>
<td>
<p>vector of length N or (N x 1) matrix of factor loadings 
(i.e. the betas) from a single factor statistical factor model</p>
</td></tr>
<tr><td><code id="coskewnessSF_+3A_stockm3">stockM3</code></td>
<td>
<p>vector of length N of the 3rd moment of the model residuals</p>
</td></tr>
<tr><td><code id="coskewnessSF_+3A_factorm3">factorM3</code></td>
<td>
<p>scalar of the 3rd moment of the factor realizations from a 
single factor statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N^2) coskewness matrix from a single factor 
statistical factor model with k=1 factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N^2) coskewness matrix
</p>

<hr>
<h2 id='covarianceMF'>Covariance Matrix Estimate</h2><span id='topic+covarianceMF'></span>

<h3>Description</h3>

<p>Estimate covariance matrix using a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarianceMF(beta, stockM2, factorM2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covarianceMF_+3A_beta">beta</code></td>
<td>
<p>(N x k) matrix of factor loadings (i.e. the betas) from a 
statistical factor model</p>
</td></tr>
<tr><td><code id="covarianceMF_+3A_stockm2">stockM2</code></td>
<td>
<p>vector of length N of the variance (2nd moment) of the 
model residuals (i.e. idiosyncratic variance of the stock)</p>
</td></tr>
<tr><td><code id="covarianceMF_+3A_factorm2">factorM2</code></td>
<td>
<p>(k x k) matrix of the covariance (2nd moment) of the factor 
realizations from a statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N) covariance matrix from a statistical 
factor model with k factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N) covariance matrix
</p>

<hr>
<h2 id='covarianceSF'>Covariance Matrix Estimate</h2><span id='topic+covarianceSF'></span>

<h3>Description</h3>

<p>Estimate covariance matrix using a single factor statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarianceSF(beta, stockM2, factorM2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covarianceSF_+3A_beta">beta</code></td>
<td>
<p>vector of length N or (N x 1) matrix of factor loadings 
(i.e. the betas) from a single factor statistical factor model</p>
</td></tr>
<tr><td><code id="covarianceSF_+3A_stockm2">stockM2</code></td>
<td>
<p>vector of length N of the variance (2nd moment) of the 
model residuals (i.e. idiosyncratic variance of the stock)</p>
</td></tr>
<tr><td><code id="covarianceSF_+3A_factorm2">factorM2</code></td>
<td>
<p>scalar value of the 2nd moment of the factor realizations 
from a single factor statistical factor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates an (N x N) covariance matrix from a single factor 
statistical factor model with k=1 factors, where N is the number of assets.
</p>


<h3>Value</h3>

<p>(N x N) covariance matrix
</p>

<hr>
<h2 id='create.EfficientFrontier'>create an efficient frontier</h2><span id='topic+create.EfficientFrontier'></span>

<h3>Description</h3>

<p>create an efficient frontier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.EfficientFrontier(
  R,
  portfolio,
  type,
  optimize_method = "CVXR",
  n.portfolios = 25,
  risk_aversion = NULL,
  match.col = "ES",
  search_size = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.EfficientFrontier_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_portfolio">portfolio</code></td>
<td>
<p>object of class 'portfolio' specifying the constraints and objectives, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>.</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_type">type</code></td>
<td>
<p>type of efficient frontier, see Details.</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier, default is CVXR</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to calculate along the efficient frontier</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_risk_aversion">risk_aversion</code></td>
<td>
<p>vector of risk_aversion values to construct the efficient frontier.
<code>n.portfolios</code> is ignored if <code>risk_aversion</code> is specified and the number
of points along the efficient frontier will be equal to the length of <code>risk_aversion</code>.</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_match.col">match.col</code></td>
<td>
<p>column to match when extracting the efficient frontier from an objected created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_search_size">search_size</code></td>
<td>
<p>passed to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> for type=&quot;DEoptim&quot; or type=&quot;random&quot;.</p>
</td></tr>
<tr><td><code id="create.EfficientFrontier_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there are 4 'types' supported to create an efficient frontier:
</p>

<dl>
<dt>&quot;mean-var&quot;, &quot;mean-sd&quot;, or &quot;mean-StdDev&quot;:</dt><dd><p> This is a special case for 
an efficient frontier that can be created by a QP solver.
The <code>portfolio</code> object should have two
objectives: 1) mean and 2) var. If the portfolio object does not contain these 
objectives, they will be added using default parameters.
The efficient frontier will be created via
<code><a href="#topic+meanvar.efficient.frontier">meanvar.efficient.frontier</a></code>.</p>
</dd>
<dt>&quot;mean-ETL&quot;, &quot;mean-ES&quot;, &quot;mean-CVaR&quot;, &quot;mean-etl&quot;:</dt><dd><p> This is a special 
case for an efficient frontier that can be created by an LP solver.
The <code>portfolio</code> object should have two objectives: 1) mean
and 2) ETL/ES/CVaR. If the portfolio object does not contain these 
objectives, they will be added using default parameters.
The efficient frontier is created via 
<code><a href="#topic+meanetl.efficient.frontier">meanetl.efficient.frontier</a></code>.</p>
</dd>
<dt>&quot;mean-CSM&quot;:</dt><dd><p> This is a special 
case for an efficient frontier that can be created by CVXR solvers.
The <code>portfolio</code> object should have two objectives: 1) mean
and 2) CSM. If the portfolio object does not contain these 
objectives, they will be added using default parameters.
The efficient frontier is created via 
<code><a href="#topic+meanrisk.efficient.frontier">meanrisk.efficient.frontier</a></code>.</p>
</dd>
<dt>&quot;mean-risk&quot;:</dt><dd><p> This is a special case for multiple efficient frontiers.
The efficient frontier is created via 
<code><a href="#topic+meanrisk.efficient.frontier">meanrisk.efficient.frontier</a></code>.</p>
</dd>
<dt>&quot;DEoptim&quot;:</dt><dd><p> This can handle more complex constraints and objectives
than the simple mean-var and mean-ETL cases. For this type, we actually 
call <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> with <code>optimize_method="DEoptim"</code>
and then extract the efficient frontier with 
<code>extract.efficient.frontier</code>.</p>
</dd>
<dt>&quot;random&quot;:</dt><dd><p> This can handle more complex constraints and objectives
than the simple mean-var and mean-ETL cases. For this type, we actually 
call <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> with <code>optimize_method="random"</code>
and then extract the efficient frontier with 
<code>extract.efficient.frontier</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>an object of class 'efficient.frontier' with the objective measures 
and weights of portfolios along the efficient frontier.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett, Xinran Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>, 
<code><a href="#topic+portfolio.spec">portfolio.spec</a></code>, 
<code><a href="#topic+meanvar.efficient.frontier">meanvar.efficient.frontier</a></code>, 
<code><a href="#topic+meanetl.efficient.frontier">meanetl.efficient.frontier</a></code>
</p>

<hr>
<h2 id='custom.covRob.Mcd'>Compute returns mean vector and covariance matrix with custom.covRob.Mcd</h2><span id='topic+custom.covRob.Mcd'></span>

<h3>Description</h3>

<p>custom.covRob.Mcd uses the robustbase package function covMcd to compute a robust
mean vector and robust covariance matrix for a portfolio's asset returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.covRob.Mcd(R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom.covRob.Mcd_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="custom.covRob.Mcd_+3A_...">...</code></td>
<td>
<p>parameters for covRob.Mcd</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parameter details, see covMcd in the robustbase Reference
Manual at <a href="https://CRAN.R-project.org/package=robustbase">https://CRAN.R-project.org/package=robustbase</a>
</p>


<h3>Value</h3>

<p>a list containing covariance matrix sigma and mean vector mu
</p>

<hr>
<h2 id='custom.covRob.MM'>Compute returns mean vector and covariance matrix with custom.covRob.MM</h2><span id='topic+custom.covRob.MM'></span>

<h3>Description</h3>

<p>custom.covRob.MM uses the RobStatTM package function covRobMM to compute a robust
mean vector and robust covariance matrix for a portfolio's asset returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.covRob.MM(R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom.covRob.MM_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="custom.covRob.MM_+3A_...">...</code></td>
<td>
<p>parameters for covRob.MM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing covariance matrix sigma and mean vector mu
</p>


<h3>Author(s)</h3>

<p>Yifu Kang, Xinran Zhao
</p>


<h3>References</h3>

<p>For parameter details, see covRobMM in the RobStatTM Reference
Manual at <a href="https://CRAN.R-project.org/package=RobStatTM">https://CRAN.R-project.org/package=RobStatTM</a>
</p>

<hr>
<h2 id='custom.covRob.Rocke'>Compute returns mean vector and covariance matrix with custom.covRob.Rocke</h2><span id='topic+custom.covRob.Rocke'></span>

<h3>Description</h3>

<p>custom.covRob.Rocke uses the RobStatTM package function covRobRocke to compute a robust
mean vector and robust covariance matrix for a portfolio's asset returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.covRob.Rocke(R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom.covRob.Rocke_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="custom.covRob.Rocke_+3A_...">...</code></td>
<td>
<p>parameters for covRob.Rocke</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parameter details, see covRobRocke in the RobStatTM Reference
Manual at <a href="https://CRAN.R-project.org/package=RobStatTM">https://CRAN.R-project.org/package=RobStatTM</a>
</p>


<h3>Value</h3>

<p>a list containing covariance matrix sigma and mean vector mu
</p>


<h3>Author(s)</h3>

<p>Yifu Kang
</p>

<hr>
<h2 id='custom.covRob.TSGS'>Compute returns mean vector and covariance matrix with custom.covRob.TSGS</h2><span id='topic+custom.covRob.TSGS'></span>

<h3>Description</h3>

<p>This is a function uses the TSGS function from GSE package to compute
the Two-Step Generalized S-Estimate, a robust estimate of location 
and scatter for data with cell-wise and case-wise contamination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.covRob.TSGS(R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom.covRob.TSGS_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="custom.covRob.TSGS_+3A_...">...</code></td>
<td>
<p>parameters for covRob.TSGS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list contains mean and covariance matrix of the stock return matrix
</p>


<h3>References</h3>

<p>Claudio Agostinelli, Andy Leung, &quot;Robust estimation of multivariate 
location and scatter in the presence of cellwise and casewise contamination&quot;,
2014.
</p>

<hr>
<h2 id='diversification'>Function to compute diversification as a constraint</h2><span id='topic+diversification'></span>

<h3>Description</h3>

<p>Diversification is defined as 1 minus the sum of the squared weights
</p>
<p style="text-align: center;"><code class="reqn">diversification = 1 - sum(w^2)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>diversification(weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diversification_+3A_weights">weights</code></td>
<td>
<p>vector of asset weights</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='diversification_constraint'>constructor for diversification_constraint</h2><span id='topic+diversification_constraint'></span>

<h3>Description</h3>

<p>The diversification constraint specifies a target diversification value. 
This function is called by add.constraint when type=&quot;diversification&quot; is 
specified, see <code><a href="#topic+add.constraint">add.constraint</a></code>. Diversification is computed
as <code>1 - sum(weights^2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversification_constraint(
  type = "diversification",
  div_target = NULL,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diversification_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="diversification_constraint_+3A_div_target">div_target</code></td>
<td>
<p>diversification target value</p>
</td></tr>
<tr><td><code id="diversification_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="diversification_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="diversification_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify diversification constraint
an object of class 'diversification_constraint'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="diversification", div_target=0.7)
</code></pre>

<hr>
<h2 id='EntropyProg'>Entropy pooling program for blending views on scenarios with a prior scenario-probability distribution</h2><span id='topic+EntropyProg'></span>

<h3>Description</h3>

<p>Entropy program will change the initial predictive distribution 'p' to a new set 'p_' that satisfies
specified moment conditions but changes other propoerties of the new distribution the least by
minimizing the relative entropy between the two distributions. Theoretical note: Relative Entropy (Kullback-Leibler information criterion KLIC) is an
asymmetric measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EntropyProg(p, A = NULL, b = NULL, Aeq, beq, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EntropyProg_+3A_p">p</code></td>
<td>
<p>a vector of initial probabilities based on prior (reference model, empirical distribution, etc.). Sum of 'p' must be 1</p>
</td></tr>
<tr><td><code id="EntropyProg_+3A_a">A</code></td>
<td>
<p>matrix consisting of inequality constraints (paired with argument 'b'). Denoted as 'F' in the Meucci paper</p>
</td></tr>
<tr><td><code id="EntropyProg_+3A_b">b</code></td>
<td>
<p>vector consisting of inequality constraints (paired with matrix A). Denoted as 'f' in the Meucci paper</p>
</td></tr>
<tr><td><code id="EntropyProg_+3A_aeq">Aeq</code></td>
<td>
<p>matrix consisting of equality constraints (paired with argument 'beq'). Denoted as 'H' in the Meucci paper. (denoted as 'H' in the &quot;Meucci - Flexible Views Theory &amp; Practice&quot; paper formlua 86 on page 22)</p>
</td></tr>
<tr><td><code id="EntropyProg_+3A_beq">beq</code></td>
<td>
<p>vector corresponding to the matrix of equality constraints (paired with argument 'Aeq'). Denoted as 'h' in the Meucci paper</p>
</td></tr>
<tr><td><code id="EntropyProg_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, prints out additional information. Default FALSE.
</p>
<p>' </p>
<p style="text-align: center;"><code class="reqn"> \tilde{p}  \equiv  argmin_{Fx \leq f, Hx  \equiv  h}  \big\{ \sum_1^J  x_{j}  \big(ln \big( x_{j} \big) - ln \big( p_{j} \big) \big)  \big\} 
\\ \ell  \big(x,  \lambda,  \nu \big)  \equiv  x'  \big(ln \big(x\big) - ln \big(p\big) \big) +   \lambda' \big(Fx - f\big)  +   \nu' \big(Hx - h\big)</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We retrieve a new set of probabilities for the joint-scenarios using the Entropy pooling method
Of the many choices of 'p' that satisfy the views, we choose 'p' that minimize the entropy or distance of the new probability
distribution to the prior joint-scenario probabilities.
</p>
<p>We use Kullback-Leibler divergence or relative entropy dist(p,q): Sum across all scenarios [ p-t * ln( p-t / q-t ) ]
Therefore we define solution as p* = argmin (choice of p ) [ sum across all scenarios: p-t * ln( p-t / q-t) ], 
such that 'p' satisfies views. The views modify the prior in a cohrent manner (minimizing distortion)
We forumulate the stress tests of the baseline scenarios as linear constraints on yet-to-be defined probabilities
Note that the numerical optimization acts on a very limited number of variables equal
to the number of views. It does not act directly on the very large number of variables
of interest, namely the probabilities of the Monte Carlo scenarios. This feature guarantees
the numerical feasability of entropy optimization.
</p>
<p>Note that new probabilities are generated in much the same way that the state-price density modifies
objective probabilities of pay-offs to risk-neutral probabilities in contingent-claims asset pricing
</p>
<p>Compute posterior (=change of measure) with Entropy Pooling, as described in
</p>


<h3>Value</h3>

<p>a list with
</p>
 
<dl>
<dt><code>p_</code>:</dt><dd><p> revised probabilities based on entropy pooling</p>
</dd>
<dt><code>optimizationPerformance</code>:</dt><dd><p> a list with status of optimization, 
value, number of iterations, and sum of probabilities</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ram Ahluwalia <a href="mailto:ram@wingedfootcapital.com">ram@wingedfootcapital.com</a>
</p>


<h3>References</h3>

<p>A. Meucci - &quot;Fully Flexible Views: Theory and Practice&quot;. See page 22 for illustration of numerical implementation
Symmys site containing original MATLAB source code <a href="https://www.arpm.co/">https://www.arpm.co/</a>
NLOPT open-source optimization site containing background on algorithms <a href="https://nlopt.readthedocs.io/en/latest/">https://nlopt.readthedocs.io/en/latest/</a>
We use the information-theoretic estimator of Kitamur and Stutzer (1997). 
Reversing 'p' and 'p_' leads to the empirical likelihood&quot; estimator of Qin and Lawless (1994). 
See Robertson et al, &quot;Forecasting Using Relative Entropy&quot; (2002) for more theory
</p>

<hr>
<h2 id='equal.weight'>Create an equal weight portfolio</h2><span id='topic+equal.weight'></span>

<h3>Description</h3>

<p>This function calculates objective measures for an equal weight portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal.weight(R, portfolio, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equal.weight_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="equal.weight_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints and objectives for the optimization</p>
</td></tr>
<tr><td><code id="equal.weight_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to <code>constrained_objective</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper around <code><a href="#topic+constrained_objective">constrained_objective</a></code>
to calculate the objective measures in the given <code>portfolio</code> object of
an equal weight portfolio. The portfolio object should include all objectives
to be calculated.
</p>


<h3>Value</h3>

<p>a list containing the returns, weights, objective measures, call, and portfolio object
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='etl_milp_opt'>Minimum ETL MILP Optimization</h2><span id='topic+etl_milp_opt'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum ETL problems 
via mixed integer linear programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etl_milp_opt(
  R,
  constraints,
  moments,
  target,
  alpha,
  solver = "glpk",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etl_milp_opt_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for ETL/ES/CVaR</p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="etl_milp_opt_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='etl_opt'>Minimum ETL LP Optimization</h2><span id='topic+etl_opt'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum ETL problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etl_opt(
  R,
  constraints,
  moments,
  target,
  alpha,
  solver = "glpk",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etl_opt_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="etl_opt_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="etl_opt_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="etl_opt_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="etl_opt_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for ETL/ES/CVaR</p>
</td></tr>
<tr><td><code id="etl_opt_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="etl_opt_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='extract_risk'>extract the risk value when knowing the weights</h2><span id='topic+extract_risk'></span>

<h3>Description</h3>

<p>extract the risk value when knowing the weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_risk(R, w, ES_alpha = 0.05, CSM_alpha = 0.05, moment_setting = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_risk_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="extract_risk_+3A_w">w</code></td>
<td>
<p>the weight of the portfolio</p>
</td></tr>
<tr><td><code id="extract_risk_+3A_es_alpha">ES_alpha</code></td>
<td>
<p>the default value is 0.05, but could be specified as any value between 0 and 1</p>
</td></tr>
<tr><td><code id="extract_risk_+3A_csm_alpha">CSM_alpha</code></td>
<td>
<p>the default value is 0.05, but could be specified as any value between 0 and 1</p>
</td></tr>
<tr><td><code id="extract_risk_+3A_moment_setting">moment_setting</code></td>
<td>
<p>the default is NULL, should provide moment_setting=list(mu=, sigma=) if customize momentFUN</p>
</td></tr>
</table>

<hr>
<h2 id='extractCokurtosis'>Cokurtosis Estimate</h2><span id='topic+extractCokurtosis'></span>

<h3>Description</h3>

<p>Extract the cokurtosis matrix estimate from a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCokurtosis(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCokurtosis_+3A_model">model</code></td>
<td>
<p>statistical factor model estimated via 
<code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code></p>
</td></tr>
<tr><td><code id="extractCokurtosis_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cokurtosis matrix estimate
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code>
</p>

<hr>
<h2 id='extractCoskewness'>Coskewness Estimate</h2><span id='topic+extractCoskewness'></span>

<h3>Description</h3>

<p>Extract the coskewness matrix estimate from a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCoskewness(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCoskewness_+3A_model">model</code></td>
<td>
<p>statistical factor model estimated via 
<code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code></p>
</td></tr>
<tr><td><code id="extractCoskewness_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coskewness matrix estimate
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code>
</p>

<hr>
<h2 id='extractCovariance'>Covariance Estimate</h2><span id='topic+extractCovariance'></span>

<h3>Description</h3>

<p>Extract the covariance matrix estimate from a statistical factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCovariance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCovariance_+3A_model">model</code></td>
<td>
<p>statistical factor model estimated via 
<code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code></p>
</td></tr>
<tr><td><code id="extractCovariance_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covariance matrix estimate
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code>
</p>

<hr>
<h2 id='extractEfficientFrontier'>Extract the efficient frontier data points</h2><span id='topic+extractEfficientFrontier'></span>

<h3>Description</h3>

<p>This function extracts the efficient frontier from an object created by
<code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractEfficientFrontier(
  object,
  match.col = "ES",
  n.portfolios = 25,
  risk_aversion = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractEfficientFrontier_+3A_object">object</code></td>
<td>
<p>an optimal portfolio object created by <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="extractEfficientFrontier_+3A_match.col">match.col</code></td>
<td>
<p>string name of column to use for risk (horizontal axis).
<code>match.col</code> must match the name of an objective measure in the 
<code>objective_measures</code> or <code>opt_values</code> slot in the object created 
by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>.</p>
</td></tr>
<tr><td><code id="extractEfficientFrontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to use to plot the efficient frontier</p>
</td></tr>
<tr><td><code id="extractEfficientFrontier_+3A_risk_aversion">risk_aversion</code></td>
<td>
<p>vector of risk_aversion values to construct the efficient frontier.
<code>n.portfolios</code> is ignored if <code>risk_aversion</code> is specified and the number
of points along the efficient frontier is equal to the length of <code>risk_aversion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object is an <code>optimize.portfolio.ROI</code> object and <code>match.col</code>
is &quot;ES&quot;, &quot;ETL&quot;, or &quot;CVaR&quot;, then the mean-ETL efficient frontier will be 
created via <code>meanetl.efficient.frontier</code>. 
</p>
<p>If the object is an <code>optimize.portfolio.ROI</code> object and <code>match.col</code>
is &quot;StdDev&quot;, then the mean-StdDev efficient frontier will be created via 
<code>meanvar.efficient.frontier</code>. Note that if 'var' is specified as the
name of an objective, the value returned will be 'StdDev'.
</p>
<p>For objects created by <code>optimize.portfolo</code> with the DEoptim, random, or
pso solvers, the efficient frontier will be extracted from the object via
<code>extract.efficient.frontier</code>. This means that <code>optimize.portfolio</code> must
be run with <code>trace=TRUE</code>.
</p>


<h3>Value</h3>

<p>an <code>efficient.frontier</code> object with weights and other metrics along the efficient frontier
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='extractGroups'>Extract the group and/or category weights</h2><span id='topic+extractGroups'></span>

<h3>Description</h3>

<p>This function extracts the weights by group and/or category from an object
of class <code>optimize.portfolio</code>. Group constraints or category_labels must
be specified for this to return group constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractGroups(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractGroups_+3A_object">object</code></td>
<td>
<p>object of class <code>optimize.portfolio</code></p>
</td></tr>
<tr><td><code id="extractGroups_+3A_...">...</code></td>
<td>
<p>passthrough parameters. Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements
</p>

<dl>
<dt>weights: </dt><dd><p>Optimal set of weights from the <code>optimize.portfolio</code> object</p>
</dd>
<dt>category_weights: </dt><dd><p>Weights by category if category_labels are supplied in the <code>portfolio</code> object</p>
</dd>
<dt>group_weights: </dt><dd><p>Weights by group if group is a constraint type</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='extractObjectiveMeasures'>Extract the objective measures</h2><span id='topic+extractObjectiveMeasures'></span>

<h3>Description</h3>

<p>This function will extract the objective measures from the optimal portfolio
run via <code>optimize.portfolio</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractObjectiveMeasures(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractObjectiveMeasures_+3A_object">object</code></td>
<td>
<p>list returned by optimize.portfolio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of objective measures
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='extractStats'>extract some stats and weights from a portfolio run via <code>optimize.portfolio</code></h2><span id='topic+extractStats'></span><span id='topic+extractStats.optimize.portfolio.DEoptim'></span><span id='topic+extractStats.optimize.portfolio.parallel'></span><span id='topic+extractStats.optimize.portfolio.random'></span><span id='topic+extractStats.optimize.portfolio.ROI'></span><span id='topic+extractStats.optimize.portfolio.pso'></span><span id='topic+extractStats.optimize.portfolio.GenSA'></span>

<h3>Description</h3>

<p>This function will dispatch to the appropriate class handler based on the
input class of the optimize.portfolio output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractStats(object, prefix = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractStats_+3A_object">object</code></td>
<td>
<p>list returned by optimize.portfolio</p>
</td></tr>
<tr><td><code id="extractStats_+3A_prefix">prefix</code></td>
<td>
<p>prefix to add to output row names</p>
</td></tr>
<tr><td><code id="extractStats_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>optimize.portfolio</code> objects:
</p>
<p>In general, <code>extractStats</code> will extract the values objective measures 
and weights at each iteration of a set of weights. This is the case for the
DEoptim, random portfolios, and pso solvers that return trace information. 
Note that <code>trace=TRUE</code> must be specified in <code>optimize.portfolio</code> 
to return the trace information.
</p>
<p>For <code>optimize.portfolio.pso</code> objects, this function will extract the 
weights (swarm positions) from the PSO output and the out values
(swarm fitness values) for each iteration of the optimization.
This function can be slow because we need to run <code>constrained_objective</code>
to calculate the objective measures on the transformed weights.
</p>
<p>For <code>optimize.portfolio.rebalancing</code> objects:
</p>
<p>The <code>extractStats</code> function will return a list of the objective measures 
and weights at each rebalance date for <code>optimize.portfolio.rebalancing</code>
objects. The objective measures and weights of each iteration or permutation 
will be returned if the optimization was done with DEoptim, random portfolios, 
or pso. This could potentially result in a very large list object where each 
list element has thousands of rows of at each rebalance period.
</p>
<p>The output from the GenSA solver does not store weights evaluated at each iteration
The GenSA output for trace.mat contains nb.steps, temperature, function.value, and current.minimum
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='extractWeights'>Extract weights from a portfolio run via <code>optimize.portfolio</code> or <code>optimize.portfolio.rebalancing</code></h2><span id='topic+extractWeights'></span>

<h3>Description</h3>

<p>This function will dispatch to the appropriate class handler based on the
input class of the optimize.portfolio or optimize.portfolio.rebalancing output object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractWeights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractWeights_+3A_object">object</code></td>
<td>
<p>list returned by optimize.portfolio</p>
</td></tr>
<tr><td><code id="extractWeights_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>, <code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code>
</p>

<hr>
<h2 id='factor_exposure_constraint'>Constructor for factor exposure constraint</h2><span id='topic+factor_exposure_constraint'></span>

<h3>Description</h3>

<p>The factor exposure constraint sets upper and lower bounds on exposures to risk factors.
This function is called by add.constraint when type=&quot;factor_exposure&quot; is specified, see <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_exposure_constraint(
  type = "factor_exposure",
  assets,
  B,
  lower,
  upper,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factor_exposure_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_assets">assets</code></td>
<td>
<p>named vector of assets specifying initial weights</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_b">B</code></td>
<td>
<p>vector or matrix of risk factor exposures</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds of constraints for risk factor exposures</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds of constraints for risk factor exposures</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="factor_exposure_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify risk factor exposure constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>B</code> can be either a vector or matrix of risk factor exposures (i.e. betas).
If <code>B</code> is a vector, the length of <code>B</code> must be equal to the number of 
assets and lower and upper must be scalars. If <code>B</code> is passed in as a vector,
it will be converted to a matrix with one column.
</p>
<p>If <code>B</code> is a matrix, the number of rows must be equal to the number 
of assets and the number of columns represent the number of  factors. The length
of lower and upper must be equal to the number of factors. The <code>B</code> matrix should
have column names specifying the factors and row names specifying the assets.
Default column names and row names will be assigned if the user passes in a 
<code>B</code> matrix without column names or row names.
</p>


<h3>Value</h3>

<p>an object of class 'factor_exposure_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>

<hr>
<h2 id='fn_map'>mapping function to transform or penalize weights that violate constraints</h2><span id='topic+fn_map'></span>

<h3>Description</h3>

<p>The purpose of the mapping function is to transform a weights vector
that does not meet all the constraints into a weights vector that
does meet the constraints, if one exists, hopefully with a minimum
of transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fn_map(weights, portfolio, relax = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fn_map_+3A_weights">weights</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="fn_map_+3A_portfolio">portfolio</code></td>
<td>
<p>object of class <code>portfolio</code></p>
</td></tr>
<tr><td><code id="fn_map_+3A_relax">relax</code></td>
<td>
<p>TRUE/FALSE, default FALSE. Enable constraints to be relaxed.</p>
</td></tr>
<tr><td><code id="fn_map_+3A_verbose">verbose</code></td>
<td>
<p>print error messages for debuggin purposes</p>
</td></tr>
<tr><td><code id="fn_map_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step is to test for violation of the constraint. If the constraint
is violated, we will apply a transformation such that the weights vector
satisfies the constraints. The following constraint types are tested in
the mapping function: leverage, box, group, and position limit. The 
transformation logic is based on code from the random portfolio sample method.
</p>
<p>If relax=TRUE, we will attempt to relax the constraints if a feasible 
portfolio could not be formed with an initial call to <code>rp_transform</code>. 
We will attempt to relax the constraints up to 5 times. If we do not have a 
feasible portfolio after attempting to relax the constraints, then we will 
default to returning the weights vector that violates the constraints.
</p>


<h3>Value</h3>


<dl>
<dt>weights:</dt><dd><p>vector of transformed weights meeting constraints.</p>
</dd>
<dt>min: </dt><dd><p>vector of min box constraints that may have been modified if relax=TRUE.</p>
</dd>
<dt>max: </dt><dd><p>vector of max box constraints that may have been modified if relax=TRUE.</p>
</dd>
<dt>cLO: </dt><dd><p>vector of lower bound group constraints that may have been modified if relax=TRUE.</p>
</dd>
<dt>cUP: </dt><dd><p>vector of upper bound group constraints that may have been modified if relax=TRUE.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='generatesequence'>create a sequence of possible weights for random or brute force portfolios</h2><span id='topic+generatesequence'></span>

<h3>Description</h3>

<p>This function creates the sequence of min&lt;-&gt;max weights for use by
random or brute force optimization engines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatesequence(min = 0.01, max = 1, by = min/max, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generatesequence_+3A_min">min</code></td>
<td>
<p>minimum value of the sequence</p>
</td></tr>
<tr><td><code id="generatesequence_+3A_max">max</code></td>
<td>
<p>maximum value of the sequence</p>
</td></tr>
<tr><td><code id="generatesequence_+3A_by">by</code></td>
<td>
<p>number to increment the sequence by</p>
</td></tr>
<tr><td><code id="generatesequence_+3A_rounding">rounding</code></td>
<td>
<p>integrer how many decimals should we round to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence created is not constrained by asset.
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constraint">constraint</a></code>, <code><a href="#topic+objective">objective</a></code>
</p>

<hr>
<h2 id='get_constraints'>Helper function to get the enabled constraints out of the portfolio object
When the v1_constraint object is instantiated via constraint, the arguments
min_sum, max_sum, min, and max are either specified by the user or default
values are assigned. These are required by other functions such as
<code>optimize.portfolio</code> and <code>constrained_objective</code> . This function 
will check that these variables are in the portfolio object in the 
constraints list. We will default to <code>min_sum=1</code> and <code>max_sum=1</code>
if leverage constraints are not specified. We will default to <code>min=-Inf</code>
and <code>max=Inf</code> if box constraints are not specified.
This function is used at the beginning of optimize.portfolio and other 
functions to extract the constraints from the portfolio object. We Use the 
same naming as the v1_constraint object.</h2><span id='topic+get_constraints'></span>

<h3>Description</h3>

<p>Helper function to get the enabled constraints out of the portfolio object
</p>
<p>When the v1_constraint object is instantiated via constraint, the arguments
min_sum, max_sum, min, and max are either specified by the user or default
values are assigned. These are required by other functions such as
<code>optimize.portfolio</code> and <code>constrained_objective</code> . This function 
will check that these variables are in the portfolio object in the 
constraints list. We will default to <code>min_sum=1</code> and <code>max_sum=1</code>
if leverage constraints are not specified. We will default to <code>min=-Inf</code>
and <code>max=Inf</code> if box constraints are not specified.
This function is used at the beginning of optimize.portfolio and other 
functions to extract the constraints from the portfolio object. We Use the 
same naming as the v1_constraint object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_constraints(portfolio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_constraints_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class 'portfolio'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'constraint' which is a flattened list of enabled constraints
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>

<hr>
<h2 id='gmv_opt'>GMV/QU QP Optimization</h2><span id='topic+gmv_opt'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum variance or 
maximum quadratic utility problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmv_opt(
  R,
  constraints,
  moments,
  lambda,
  target,
  lambda_hhi,
  conc_groups,
  solver = "quadprog",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmv_opt_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_lambda">lambda</code></td>
<td>
<p>risk_aversion parameter</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_lambda_hhi">lambda_hhi</code></td>
<td>
<p>concentration aversion parameter</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_conc_groups">conc_groups</code></td>
<td>
<p>list of vectors specifying the groups of the assets.</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="gmv_opt_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='gmv_opt_leverage'>GMV/QU QP Optimization with Turnover Constraint</h2><span id='topic+gmv_opt_leverage'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum variance or 
maximum quadratic utility problems with a leverage constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmv_opt_leverage(
  R,
  constraints,
  moments,
  lambda,
  target,
  solver = "quadprog",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmv_opt_leverage_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_lambda">lambda</code></td>
<td>
<p>risk_aversion parameter</p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="gmv_opt_leverage_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='gmv_opt_ptc'>GMV/QU QP Optimization with Proportional Transaction Cost Constraint</h2><span id='topic+gmv_opt_ptc'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum variance or 
maximum quadratic utility problems with proportional transaction cost constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmv_opt_ptc(
  R,
  constraints,
  moments,
  lambda,
  target,
  init_weights,
  solver = "quadprog",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmv_opt_ptc_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_lambda">lambda</code></td>
<td>
<p>risk_aversion parameter</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_init_weights">init_weights</code></td>
<td>
<p>initial weights to compute turnover</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="gmv_opt_ptc_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='gmv_opt_toc'>GMV/QU QP Optimization with Turnover Constraint</h2><span id='topic+gmv_opt_toc'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve minimum variance or 
maximum quadratic utility problems with turnover constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmv_opt_toc(
  R,
  constraints,
  moments,
  lambda,
  target,
  init_weights,
  solver = "quadprog",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmv_opt_toc_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_lambda">lambda</code></td>
<td>
<p>risk_aversion parameter</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_init_weights">init_weights</code></td>
<td>
<p>initial weights to compute turnover</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="gmv_opt_toc_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='group_constraint'>constructor for group_constraint</h2><span id='topic+group_constraint'></span>

<h3>Description</h3>

<p>Group constraints specify the grouping of the assets, weights of the groups, and number of postions (i.e. non-zero weights) iof the groups.
This function is called by add.constraint when type=&quot;group&quot; is specified. see <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_constraint(
  type = "group",
  assets,
  groups,
  group_labels = NULL,
  group_min,
  group_max,
  group_pos = NULL,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying initial weights</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_groups">groups</code></td>
<td>
<p>list of vectors specifying the groups of the assets</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_group_labels">group_labels</code></td>
<td>
<p>character vector to label the groups (e.g. size, asset class, style, etc.)</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_group_min">group_min</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_group_max">group_max</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_group_pos">group_pos</code></td>
<td>
<p>vector specifying the number of non-zero weights per group</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="group_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify group constraints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'group_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

# Assets 1 and 3 are groupA
# Assets 2 and 4 are groupB
pspec &lt;- add.constraint(portfolio=pspec, 
                        type="group", 
                        groups=list(groupA=c(1, 3),
                                    groupB=c(2, 4)),
                        group_min=c(0.15, 0.25),
                        group_max=c(0.65, 0.55))

# 2 levels of grouping (e.g. by sector and geography)
pspec &lt;- portfolio.spec(assets=5)
# Assets 1, 3, and 5 are Tech
# Assets 2 and 4 are Oil
# Assets 2, 4, and 5 are UK
# Assets 1 and are are US
group_list &lt;- list(group1=c(1, 3, 5),
                   group2=c(2, 4),
                   groupA=c(2, 4, 5),
                   groupB=c(1, 3))

pspec &lt;- add.constraint(portfolio=pspec, 
                        type="group", 
                        groups=group_list,
                        group_min=c(0.15, 0.25, 0.2, 0.1),
                        group_max=c(0.65, 0.55, 0.5, 0.4))
                        
</code></pre>

<hr>
<h2 id='group_fail'>Test if group constraints have been violated</h2><span id='topic+group_fail'></span>

<h3>Description</h3>

<p>The function loops through each group and tests if cLO or cUP have been violated
for the given group. This is a helper function for <code><a href="#topic+rp_transform">rp_transform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_fail(weights, groups, cLO, cUP, group_pos = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_fail_+3A_weights">weights</code></td>
<td>
<p>weights vector to test</p>
</td></tr>
<tr><td><code id="group_fail_+3A_groups">groups</code></td>
<td>
<p>list of vectors specifying the groups of the assets</p>
</td></tr>
<tr><td><code id="group_fail_+3A_clo">cLO</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="group_fail_+3A_cup">cUP</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="group_fail_+3A_group_pos">group_pos</code></td>
<td>
<p>vector specifying the number of non-zero weights per group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector: TRUE if group constraints are violated for a given group
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='HHI'>Concentration of weights</h2><span id='topic+HHI'></span>

<h3>Description</h3>

<p>This function computes the concentration of weights using the Herfindahl Hirschman Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HHI(weights, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HHI_+3A_weights">weights</code></td>
<td>
<p>set of portfolio weights</p>
</td></tr>
<tr><td><code id="HHI_+3A_groups">groups</code></td>
<td>
<p>list of vectors of grouping</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='indexes'>Six Major Economic Indexes</h2><span id='topic+indexes'></span>

<h3>Description</h3>

<p>Monthly data of five indexes beginning on 1980-01-31 and ending 2009-12-31.
The indexes are: US Bonds, US Equities, International Equities, Commodities, US T-Bills, and Inflation</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(indexes)</code></pre>


<h3>Format</h3>

<p>CSV converted into xts object with montly observations</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(indexes)

#preview the data
head(indexes)

#summary period statistics
summary(indexes)
</code></pre>

<hr>
<h2 id='insert_constraints'>Insert a list of constraints into the constraints slot of a portfolio object</h2><span id='topic+insert_constraints'></span>

<h3>Description</h3>

<p>This is a helper function primarily for backwards compatibility to insert
constraints from a 'v1_constraint' object into the v2 'portfolio' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_constraints(portfolio, constraints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_constraints_+3A_portfolio">portfolio</code></td>
<td>
<p>object of class 'portfolio'</p>
</td></tr>
<tr><td><code id="insert_constraints_+3A_constraints">constraints</code></td>
<td>
<p>list of constraint objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='insert_objectives'>Insert a list of objectives into the objectives slot of a portfolio object</h2><span id='topic+insert_objectives'></span>

<h3>Description</h3>

<p>This is a helper function primarily for backwards compatibility to insert
objectives from a 'v1_constraint' object into the v2 'portfolio' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_objectives(portfolio, objectives)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_objectives_+3A_portfolio">portfolio</code></td>
<td>
<p>object of class 'portfolio'</p>
</td></tr>
<tr><td><code id="insert_objectives_+3A_objectives">objectives</code></td>
<td>
<p>list of objective objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='inverse.volatility.weight'>Create an inverse volatility weighted portfolio</h2><span id='topic+inverse.volatility.weight'></span>

<h3>Description</h3>

<p>This function calculates objective measures for an equal weight portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse.volatility.weight(R, portfolio, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse.volatility.weight_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="inverse.volatility.weight_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints and objectives for the optimization</p>
</td></tr>
<tr><td><code id="inverse.volatility.weight_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to <code>constrained_objective</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper around <code><a href="#topic+constrained_objective">constrained_objective</a></code>
to calculate the objective measures in the given <code>portfolio</code> object of
an inverse volatility weight portfolio. The portfolio object should include all objectives
to be calculated.
</p>


<h3>Value</h3>

<p>a list containing the returns, weights, objective measures, call, and portfolio object
</p>


<h3>Author(s)</h3>

<p>Peter Carl
</p>

<hr>
<h2 id='is.constraint'>check function for constraints</h2><span id='topic+is.constraint'></span>

<h3>Description</h3>

<p>check function for constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.constraint(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.constraint_+3A_x">x</code></td>
<td>
<p>object to test for type <code>constraint</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>

<hr>
<h2 id='is.objective'>check class of an objective object</h2><span id='topic+is.objective'></span>

<h3>Description</h3>

<p>check class of an objective object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.objective(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.objective_+3A_x">x</code></td>
<td>
<p>an object potentially of type 'objective' to test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>

<hr>
<h2 id='is.portfolio'>check function for portfolio</h2><span id='topic+is.portfolio'></span>

<h3>Description</h3>

<p>check function for portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.portfolio(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.portfolio_+3A_x">x</code></td>
<td>
<p>object to test for type <code>portfolio</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='leverage_exposure_constraint'>constructor for leverage_exposure_constraint</h2><span id='topic+leverage_exposure_constraint'></span>

<h3>Description</h3>

<p>The leverage_exposure constraint specifies a maximum leverage where 
leverage is defined as the sum of the absolute value of the weights. 
Leverage exposure is computed as the sum of the absolute value of the
weights, <code>sum(abs(weights))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage_exposure_constraint(
  type = "leverage_exposure",
  leverage = NULL,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leverage_exposure_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="leverage_exposure_constraint_+3A_leverage">leverage</code></td>
<td>
<p>maximum leverage value</p>
</td></tr>
<tr><td><code id="leverage_exposure_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="leverage_exposure_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="leverage_exposure_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify diversification constraint
an object of class 'diversification_constraint'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should be used for constructing, for example, 130/30 portfolios or 
dollar neutral portfolios with 2:1 leverage. For the ROI solvers, this is 
implemented as a MILP problem and is not supported for problems formulated 
as a quadratic programming problem. This may change in the future if a MIQP
solver is added.
</p>
<p>This function is called by add.constraint when type=&quot;leverage_exposure&quot; 
is specified, see <code><a href="#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="leverage_exposure", leverage=1.6)
</code></pre>

<hr>
<h2 id='maxret_milp_opt'>Maximum Return MILP Optimization</h2><span id='topic+maxret_milp_opt'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve maximum return 
problems via mixed integer linear programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxret_milp_opt(
  R,
  constraints,
  moments,
  target,
  solver = "glpk",
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxret_milp_opt_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="maxret_milp_opt_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="maxret_milp_opt_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="maxret_milp_opt_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="maxret_milp_opt_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="maxret_milp_opt_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='maxret_opt'>Maximum Return LP Optimization</h2><span id='topic+maxret_opt'></span>

<h3>Description</h3>

<p>This function is called by optimize.portfolio to solve maximum return
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxret_opt(R, moments, constraints, target, solver = "glpk", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxret_opt_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="maxret_opt_+3A_moments">moments</code></td>
<td>
<p>object of moments computed based on objective functions</p>
</td></tr>
<tr><td><code id="maxret_opt_+3A_constraints">constraints</code></td>
<td>
<p>object of constraints in the portfolio object extracted with <code>get_constraints</code></p>
</td></tr>
<tr><td><code id="maxret_opt_+3A_target">target</code></td>
<td>
<p>target return value</p>
</td></tr>
<tr><td><code id="maxret_opt_+3A_solver">solver</code></td>
<td>
<p>solver to use</p>
</td></tr>
<tr><td><code id="maxret_opt_+3A_control">control</code></td>
<td>
<p>list of solver control parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='meancsm.efficient.frontier'>Generate the efficient frontier for a mean-CSM portfolio</h2><span id='topic+meancsm.efficient.frontier'></span>

<h3>Description</h3>

<p>This function generates the mean-CSM efficient frontier of a portfolio
specifying the constraints and objectives. The <code>portfolio</code> object 
should have two objectives: 1) mean and 2) CSM. If the 
portfolio object does not contain these objectives, they will be added 
using default parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meancsm.efficient.frontier(
  portfolio,
  R,
  optimize_method = "CVXR",
  n.portfolios = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meancsm.efficient.frontier_+3A_portfolio">portfolio</code></td>
<td>
<p>a portfolio object with constraints and objectives created via <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="meancsm.efficient.frontier_+3A_r">R</code></td>
<td>
<p>an xts or matrix of asset returns</p>
</td></tr>
<tr><td><code id="meancsm.efficient.frontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier, default is CVXR</p>
</td></tr>
<tr><td><code id="meancsm.efficient.frontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to generate the efficient frontier</p>
</td></tr>
<tr><td><code id="meancsm.efficient.frontier_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of objective measure values and weights along the efficient frontier
</p>


<h3>Author(s)</h3>

<p>Xinran Zhao
</p>

<hr>
<h2 id='meanetl.efficient.frontier'>Generate the efficient frontier for a mean-etl portfolio</h2><span id='topic+meanetl.efficient.frontier'></span>

<h3>Description</h3>

<p>This function generates the mean-ETL efficient frontier of a portfolio
specifying the constraints and objectives. The <code>portfolio</code> object 
should have two objectives: 1) mean and 2) ES (or ETL or cVaR). If the 
portfolio object does not contain these objectives, they will be added 
using default parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanetl.efficient.frontier(
  portfolio,
  R,
  optimize_method = "ROI",
  n.portfolios = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanetl.efficient.frontier_+3A_portfolio">portfolio</code></td>
<td>
<p>a portfolio object with constraints and objectives created via <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="meanetl.efficient.frontier_+3A_r">R</code></td>
<td>
<p>an xts or matrix of asset returns</p>
</td></tr>
<tr><td><code id="meanetl.efficient.frontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier, default is ROI</p>
</td></tr>
<tr><td><code id="meanetl.efficient.frontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to generate the efficient frontier</p>
</td></tr>
<tr><td><code id="meanetl.efficient.frontier_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of objective measure values and weights along the efficient frontier
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='meanrisk.efficient.frontier'>Generate multiple efficient frontiers for the same portfolio</h2><span id='topic+meanrisk.efficient.frontier'></span>

<h3>Description</h3>

<p>This function generates the mean-risk efficient frontier of a portfolio
specifying the constraints and objectives. The <code>risk_type</code> object 
is for the basic mean-risk efficient frontier, other efficient frontiers
will be generated with the same target returns. All mean-StdDev, mean-ES
and mean-CSM efficient frontiers will be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanrisk.efficient.frontier(
  portfolio,
  R,
  optimize_method = "CVXR",
  n.portfolios = 25,
  risk_type = "StdDev",
  compare_port = c("StdDev", "ES"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanrisk.efficient.frontier_+3A_portfolio">portfolio</code></td>
<td>
<p>a portfolio object with constraints and objectives created via <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_r">R</code></td>
<td>
<p>an xts or matrix of asset returns</p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier, default is CVXR</p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to generate the efficient frontier</p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_risk_type">risk_type</code></td>
<td>
<p>one of &quot;StdDev&quot;, &quot;ES&quot; and &quot;CSM&quot;, which determines the type of basic efficient frontier.</p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_compare_port">compare_port</code></td>
<td>
<p>vector composed of any risk &quot;StdDev&quot;, &quot;ES&quot;, &quot;CSM&quot;, for example, compare_port=c(&quot;StdDev&quot;, &quot;ES&quot;)</p>
</td></tr>
<tr><td><code id="meanrisk.efficient.frontier_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of objective measure values and weights along the efficient frontier
</p>


<h3>Author(s)</h3>

<p>Xinran Zhao
</p>

<hr>
<h2 id='meanvar.efficient.frontier'>Generate the efficient frontier for a mean-variance portfolio</h2><span id='topic+meanvar.efficient.frontier'></span>

<h3>Description</h3>

<p>This function generates the mean-variance efficient frontier of a portfolio
specifying the constraints and objectives. The <code>portfolio</code> object 
should have two objectives: 1) mean and 2) var (or sd or StdDev). If the 
portfolio object does not contain these objectives, they will be added 
using default parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanvar.efficient.frontier(
  portfolio,
  R,
  optimize_method = "ROI",
  n.portfolios = 25,
  risk_aversion = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanvar.efficient.frontier_+3A_portfolio">portfolio</code></td>
<td>
<p>a portfolio object with constraints created via <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="meanvar.efficient.frontier_+3A_r">R</code></td>
<td>
<p>an xts or matrix of asset returns</p>
</td></tr>
<tr><td><code id="meanvar.efficient.frontier_+3A_optimize_method">optimize_method</code></td>
<td>
<p>the optimize method to get the efficient frontier, default is ROI</p>
</td></tr>
<tr><td><code id="meanvar.efficient.frontier_+3A_n.portfolios">n.portfolios</code></td>
<td>
<p>number of portfolios to plot along the efficient frontier</p>
</td></tr>
<tr><td><code id="meanvar.efficient.frontier_+3A_risk_aversion">risk_aversion</code></td>
<td>
<p>vector of risk_aversion values to construct the efficient frontier.
<code>n.portfolios</code> is ignored if <code>risk_aversion</code> is specified and the number
of points along the efficient frontier is equal to the length of <code>risk_aversion</code>.</p>
</td></tr>
<tr><td><code id="meanvar.efficient.frontier_+3A_...">...</code></td>
<td>
<p>passthru parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of objective measure values and weights along the efficient frontier
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='meucci.moments'>Compute moments</h2><span id='topic+meucci.moments'></span>

<h3>Description</h3>

<p>Compute the first and second moments using the Fully Flexible Views 
framework as described in A. Meucci - &quot;Fully Flexible Views: Theory and Practice&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meucci.moments(R, posterior_p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meucci.moments_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="meucci.moments_+3A_posterior_p">posterior_p</code></td>
<td>
<p>vector of posterior probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the first and second moments
</p>

<dl>
<dt><code>mu</code>: </dt><dd><p>vector of expected returns</p>
</dd>
<dt><code>sigma</code>: </dt><dd><p>covariance matrix</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>References</h3>

<p>A. Meucci - &quot;Fully Flexible Views: Theory and Practice&quot;.
</p>

<hr>
<h2 id='meucci.ranking'>Asset Ranking</h2><span id='topic+meucci.ranking'></span>

<h3>Description</h3>

<p>Express views on the relative expected asset returns as in A. Meucci, 
&quot;Fully Flexible Views: Theory and Practice&quot; and compute the first 
and second moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meucci.ranking(R, p, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meucci.ranking_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="meucci.ranking_+3A_p">p</code></td>
<td>
<p>a vector of the prior probability values</p>
</td></tr>
<tr><td><code id="meucci.ranking_+3A_order">order</code></td>
<td>
<p>a vector of indexes of the relative ranking of expected asset 
returns in ascending order. For example, <code>order = c(2, 3, 1, 4)</code> means 
that the expected returns of <code>R[,2] &lt; R[,3], &lt; R[,1] &lt; R[,4]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated moments based on ranking views
</p>


<h3>Note</h3>

<p>This function is based on the <code>ViewRanking</code> function written by
Ram Ahluwalia in the Meucci package.
</p>


<h3>References</h3>

<p>A. Meucci, &quot;Fully Flexible Views: Theory and Practice&quot; <a href="https://www.arpm.co/articles/fully-flexible-views-theory-and-practice/">https://www.arpm.co/articles/fully-flexible-views-theory-and-practice/</a>
See Meucci script for &quot;RankingInformation/ViewRanking.m&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meucci.moments">meucci.moments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
R &lt;- edhec[,1:4]
p &lt;- rep(1 / nrow(R), nrow(R))
meucci.ranking(R, p, c(2, 3, 1, 4))
</code></pre>

<hr>
<h2 id='minmax_objective'>constructor for class tmp_minmax_objective</h2><span id='topic+minmax_objective'></span>

<h3>Description</h3>

<p>This objective allows for min and max targets to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmax_objective(
  name,
  target = NULL,
  arguments = NULL,
  multiplier = 1,
  enabled = TRUE,
  ...,
  min,
  max
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minmax_objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_min">min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code id="minmax_objective_+3A_max">max</code></td>
<td>
<p>maximum value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If target is set, we'll try to meet the metric
</p>
<p>If target is NULL and min and max are specified, then do the following:
</p>
<p>If max is violated to the upside, penalize the metric. If min is violated to 
the downside, penalize the metric. The purpose of this objective is to try
to meet the range between min and max
</p>


<h3>Value</h3>

<p>object of class 'minmax_objective'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='mult.portfolio.spec'>Multple Layer Portfolio Specification</h2><span id='topic+mult.portfolio.spec'></span>

<h3>Description</h3>

<p>Create and specify a multiple layer portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult.portfolio.spec(portfolio, levels = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mult.portfolio.spec_+3A_portfolio">portfolio</code></td>
<td>
<p>the &quot;top level&quot; portfolio</p>
</td></tr>
<tr><td><code id="mult.portfolio.spec_+3A_levels">levels</code></td>
<td>
<p>number of levels of sub-portfolios</p>
</td></tr>
<tr><td><code id="mult.portfolio.spec_+3A_...">...</code></td>
<td>
<p>any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sub.portfolios</code> slot is a list where each element contains the 
portfolio object and rebalancing parameters for the optimization of the 
sub portfolio.
This allows, for example, each sub portfolio to have different rebalancing 
frequencies (i.e. monthly or quarterly), optimization methods, etc.
</p>
<p>Each sub portfolio is optimized with <code>optimize.portfolio.rebalancing</code> 
to create a time series of proxy returns. 
</p>
<p>The &quot;top level&quot; portfolio is used to specify the constraints and objectives 
to control the optimization given the proxy returns of each sub portfolio.
</p>


<h3>Value</h3>

<p>a <code>mult.portfolio.spec</code> object with the top level portfolio 
and sub portfolios with optimization parameters for each sub portfolio
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='MycovRobMcd'>Control settings for custom.covRob.Mcd</h2><span id='topic+MycovRobMcd'></span>

<h3>Description</h3>

<p>Auxiliary function for passing the estimation options as parameters 
to the estimation function MCD.robust.moment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MycovRobMcd(
  alpha = 1/2,
  nsamp = 500,
  nmini = 300,
  kmini = 5,
  scalefn = "hrv2012",
  maxcsteps = 200,
  seed = NULL,
  tolSolve = 1e-14,
  wgtFUN = "01.original",
  beta,
  use.correction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MycovRobMcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets over 
which the determinant is minimized. Allowed values are between 
0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_nsamp">nsamp</code></td>
<td>
<p>number of subsets used for initial estimates or &quot;best&quot;, &quot;exact&quot;, 
or &quot;deterministic&quot;. Default is nsamp = 500. For nsamp = &quot;best&quot; 
exhaustive enumeration is done, as long as the number of trials 
does not exceed 100'000, which is the value of nlarge. For &quot;exact&quot;, 
exhaustive enumeration will be attempted however many samples are needed.
In this case a warning message may be displayed saying that 
the computation can take a very long time.
For &quot;deterministic&quot;, the deterministic MCD is computed; 
as proposed by Hubert et al. (2012) it starts from the h most 
central observations of six (deterministic) estimators.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_nmini">nmini</code>, <code id="MycovRobMcd_+3A_kmini">kmini</code></td>
<td>
<p>for n &gt;= 2*n0, n0 := nmini, the algorithm splits the data 
into maximally kmini (by default 5) subsets, of size approximately, 
but at least nmini. When nmini*kmini &lt; n, the initial search 
uses only a subsample of size nmini*kmini. The original algorithm 
had nmini = 300 and kmini = 5 hard coded.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_scalefn">scalefn</code></td>
<td>
<p>function to compute a robust scale estimate or character string 
specifying a rule determining such a function for the deterministic MCD.
The default is &quot;hrv2012&quot;. Another option value is &quot;v2014&quot;.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of concentration steps in the deterministic MCD</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_seed">seed</code></td>
<td>
<p>initial seed for random generator</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used for inversion of the covariance matrix</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_wgtfun">wgtFUN</code></td>
<td>
<p>a character string or function, specifying how the weights for 
the reweighting step should be computed. Default is &quot;01.originalz&quot;.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_beta">beta</code></td>
<td>
<p>a quantile, experimentally used for some of the prespecified wgtFUNs. For our 
MCD method, the default is 0.975.</p>
</td></tr>
<tr><td><code id="MycovRobMcd_+3A_use.correction">use.correction</code></td>
<td>
<p>whether to use finite sample correction factors; defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of passed parameters
</p>

<hr>
<h2 id='MycovRobTSGS'>Control settings for custom.covRob.TSGS</h2><span id='topic+MycovRobTSGS'></span>

<h3>Description</h3>

<p>Auxiliary function for passing the estimation options as parameters 
to the estimation function custom.TSGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MycovRobTSGS(
  filter = c("UBF-DDC", "UBF", "DDC", "UF"),
  partial.impute = FALSE,
  tol = 1e-04,
  maxiter = 150,
  loss = c("bisquare", "rocke"),
  init = c("emve", "qc", "huber", "imputed", "emve_c")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MycovRobTSGS_+3A_filter">filter</code></td>
<td>
<p>the filter to be used in the first step. Available choices are 
&quot;UBF-DDC&quot;,&quot;UBF&quot;,&quot;DDC&quot;,&quot;UF&quot;. The default one is &quot;UBF-DDC&quot;.</p>
</td></tr>
<tr><td><code id="MycovRobTSGS_+3A_partial.impute">partial.impute</code></td>
<td>
<p>whether partial imputation is used prior to estimation.
The default is FALSE.</p>
</td></tr>
<tr><td><code id="MycovRobTSGS_+3A_tol">tol</code></td>
<td>
<p>tolerance for the convergence criterion. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="MycovRobTSGS_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations. Default is 150.</p>
</td></tr>
<tr><td><code id="MycovRobTSGS_+3A_loss">loss</code></td>
<td>
<p>loss function to use, &quot;bisquare&quot; or &quot;rocke&quot;. Default is &quot;bisquare&quot;</p>
</td></tr>
<tr><td><code id="MycovRobTSGS_+3A_init">init</code></td>
<td>
<p>type of initial estimator. Options include &quot;emve&quot;, &quot;qc&quot;, &quot;huber&quot;,&quot;imputed&quot;,&quot;emve_c&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of passed parameters
</p>

<hr>
<h2 id='name.replace'>utility function to replace awkward named from unlist</h2><span id='topic+name.replace'></span>

<h3>Description</h3>

<p>utility function to replace awkward named from unlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.replace(rnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name.replace_+3A_rnames">rnames</code></td>
<td>
<p>character vector of names to check for cleanup</p>
</td></tr>
</table>

<hr>
<h2 id='objective'>constructor for class 'objective'</h2><span id='topic+objective'></span>

<h3>Description</h3>

<p>Typically called as a sub-function by the user function <code><a href="#topic+add.objective">add.objective</a></code>.
See main documentation there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective(
  name,
  target = NULL,
  arguments,
  enabled = TRUE,
  ...,
  multiplier = 1,
  objclass = "objective"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objective_+3A_name">name</code></td>
<td>
<p>name of the objective which will be used to call a function, like 'ES', 'VaR', 'mean'</p>
</td></tr>
<tr><td><code id="objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective, default NULL</p>
</td></tr>
<tr><td><code id="objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="objective_+3A_...">...</code></td>
<td>
<p>any other passthrough parameters</p>
</td></tr>
<tr><td><code id="objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="objective_+3A_objclass">objclass</code></td>
<td>
<p>string class to apply, default 'objective'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.objective">add.objective</a></code>, <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>

<hr>
<h2 id='opt.outputMvo'>Optimal Portfolio Weights and Performance Values</h2><span id='topic+opt.outputMvo'></span>

<h3>Description</h3>

<p>Converts output of 'optimize.portfolio' to a list of the
portfolio weights, mean, volatility and Sharpe Ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.outputMvo(
  opt,
  returns,
  digits = NULL,
  annualize = TRUE,
  frequency = "monthly",
  rf = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.outputMvo_+3A_opt">opt</code></td>
<td>
<p>List output of 'optimize.portfolio'</p>
</td></tr>
<tr><td><code id="opt.outputMvo_+3A_returns">returns</code></td>
<td>
<p>Multivariate xts object of portfolio assets returns</p>
</td></tr>
<tr><td><code id="opt.outputMvo_+3A_digits">digits</code></td>
<td>
<p>Integer number of significant digits with default NULL</p>
</td></tr>
<tr><td><code id="opt.outputMvo_+3A_annualize">annualize</code></td>
<td>
<p>Logical with default TRUE</p>
</td></tr>
<tr><td><code id="opt.outputMvo_+3A_frequency">frequency</code></td>
<td>
<p>Returns frequency: &quot;monthly&quot;, &quot;weekly&quot; or &quot;daily&quot;</p>
</td></tr>
<tr><td><code id="opt.outputMvo_+3A_rf">rf</code></td>
<td>
<p>Numeric value with default 0.0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the weights returned by optimize.portfolio,
along with the portfolio assets returns, and a risk-free rate, to
to compute the portfolio mean return, volatility, and Sharpe Ratio.
</p>


<h3>Value</h3>

<p>A list containing the portfolio numeric weights, mean value,
volatility and Sharpe Ratio.
</p>


<h3>Author(s)</h3>

<p>R. Douglas Martin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>args(opt.outputMvo)
</code></pre>

<hr>
<h2 id='optimize.portfolio'>Constrained optimization of portfolios</h2><span id='topic+optimize.portfolio'></span><span id='topic+optimize.portfolio_v1'></span><span id='topic+optimize.portfolio_v2'></span>

<h3>Description</h3>

<p>This function aims to provide a wrapper for constrained optimization of 
portfolios that specify constraints and objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize.portfolio_v1(
  R,
  constraints,
  optimize_method = c("DEoptim", "random", "ROI", "ROI_old", "pso", "GenSA"),
  search_size = 20000,
  trace = FALSE,
  ...,
  rp = NULL,
  momentFUN = "set.portfolio.moments_v1"
)

optimize.portfolio(
  R,
  portfolio = NULL,
  constraints = NULL,
  objectives = NULL,
  optimize_method = c("DEoptim", "random", "ROI", "pso", "GenSA", "Rglpk", "osqp", "mco",
    "CVXR", ...),
  search_size = 20000,
  trace = FALSE,
  ...,
  rp = NULL,
  momentFUN = "set.portfolio.moments",
  message = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize.portfolio_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_constraints">constraints</code></td>
<td>
<p>default=NULL, a list of constraint objects. An object of class 'v1_constraint' can be passed in here.</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_optimize_method">optimize_method</code></td>
<td>
<p>one of &quot;DEoptim&quot;, &quot;random&quot;, &quot;ROI&quot;, &quot;pso&quot;, &quot;GenSA&quot;, &quot;osqp&quot;, &quot;Rglpk&quot;, &quot;mco&quot;, &quot;CVXR&quot;, or a vector to specify CVXR solver.
A solver of ROI or CVXR can also be specified and will be solved via ROI or CVXR. See details.</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_search_size">search_size</code></td>
<td>
<p>integer, how many portfolios to test, default 20,000</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE if TRUE will attempt to return additional information on the path or portfolios searched</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_rp">rp</code></td>
<td>
<p>matrix of random portfolio weights, default NULL, mostly for automated use by rebalancing optimization or repeated tests on same portfolios</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_momentfun">momentFUN</code></td>
<td>
<p>the name of a function to call to set portfolio moments, default <code><a href="#topic+set.portfolio.moments_v2">set.portfolio.moments_v2</a></code></p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints and objectives for the optimization</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_objectives">objectives</code></td>
<td>
<p>default=NULL, a list of objective objects.</p>
</td></tr>
<tr><td><code id="optimize.portfolio_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently supports DEoptim, random portfolios, pso, GenSA, ROI, osqp, Rglpk, mco, and CVXR solvers as back ends.
Additional back end contributions for Rmetrics, ghyp, etc. would be welcome.
</p>
<p>When using random portfolios, search_size is precisely that, how many 
portfolios to test.  You need to make sure to set your feasible weights 
in generatesequence to make sure you have search_size unique 
portfolios to test, typically by manipulating the 'by' parameter 
to select something smaller than .01 
(I often use .002, as .001 seems like overkill)
</p>
<p>When using DE, search_size is decomposed into two other parameters 
which it interacts with, NP and itermax.
</p>
<p>NP, the number of members in each population, is set to cap at 2000 in 
DEoptim, and by default is the number of parameters (assets/weights) * 10.
</p>
<p>itermax, if not passed in dots, defaults to the number of parameters (assets/weights) * 50.
</p>
<p>When using GenSA and want to set <code>verbose=TRUE</code>, instead use <code>trace</code>. 
</p>
<p>If <code>optimize_method="ROI"</code> is specified, a default solver will be 
selected based on the optimization problem. The <code>glpk</code> solver is the
default solver for LP and MILP optimization problems. The <code>quadprog</code> 
solver is the default solver for QP optimization problems. For example,
<code>optimize_method = "quadprog"</code> can be specified and the optimization
problem will be solved via ROI using the quadprog solver.
</p>
<p>The extension to ROI solves a limited type of convex optimization problems:
</p>

<ul>
<li><p> Maxmimize portfolio return subject leverage, box, group, position limit, target mean return, and/or factor exposure constraints on weights.
</p>
</li>
<li><p> Minimize portfolio variance subject to leverage, box, group, turnover, and/or factor exposure constraints (otherwise known as global minimum variance portfolio).
</p>
</li>
<li><p> Minimize portfolio variance subject to leverage, box, group, and/or factor exposure constraints and a desired portfolio return.
</p>
</li>
<li><p> Maximize quadratic utility subject to leverage, box, group, target mean return, turnover, and/or factor exposure constraints and risk aversion parameter.
(The risk aversion parameter is passed into <code>optimize.portfolio</code> as an added argument to the <code>portfolio</code> object).
</p>
</li>
<li><p> Maximize portfolio mean return per unit standard deviation (i.e. the Sharpe Ratio) can be done by specifying <code>maxSR=TRUE</code> in <code>optimize.portfolio</code>. 
If both mean and StdDev are specified as objective names, the default action is to maximize quadratic utility, therefore <code>maxSR=TRUE</code> must be specified to maximize Sharpe Ratio.
</p>
</li>
<li><p> Minimize portfolio ES/ETL/CVaR optimization subject to leverage, box, group, position limit, target mean return, and/or factor exposure constraints and target portfolio return.
</p>
</li>
<li><p> Maximize portfolio mean return per unit ES/ETL/CVaR (i.e. the STARR Ratio) can be done by specifying <code>maxSTARR=TRUE</code> in <code>optimize.portfolio</code>. 
If both mean and ES/ETL/CVaR are specified as objective names, the default action is to maximize mean return per unit ES/ETL/CVaR.
</p>
</li></ul>

<p>These problems also support a weight_concentration objective where concentration
of weights as measured by HHI is added as a penalty term to the quadratic objective.
</p>
<p>Because these convex optimization problem are standardized, there is no need for a penalty term. 
The <code>multiplier</code> argument in <code><a href="#topic+add.objective">add.objective</a></code> passed into the complete constraint object are ignored by the ROI solver.
</p>
<p>If <code>optimize_method="CVXR"</code> is specified, a default solver will be selected based on the optimization problem.
The default solver for Quadratic Programming will be <code>OSQP</code>, 
and the default solver for Linear Problem and Second-Order Cone Programming will be <code>SCS</code>.
Specified CVXR solver can be given by using <code>optimize_method=c("CVXR", "CVXRsolver")</code>.
CVXR supports some commercial solvers, including CBC, CPLEX, GUROBI and MOSEK, and some open source solvers, including GLPK, GLPK_MI, OSQP, SCS and ECOS.
For example, <code>optimize_method = c("CVXR", "ECOS")</code> can be specified and the optimization problem will be solved via CVXR using the ECOS solver.
</p>
<p>The extension to CVXR solves a limited type of convex optimization problems:
</p>

<ul>
<li><p> Maxmimize portfolio mean return subject leverage, box, group, and/or target mean return constraints
</p>
</li>
<li><p> Minimize portfolio variance subject to leverage, box, group, and/or target mean return constraints (otherwise known as global minimum variance portfolio).
</p>
</li>
<li><p> Maximize quadratic utility subject to leverage, box, group, and/or target mean return constraints and risk aversion parameter.
(The default risk aversion is 1, and specified risk aversion could be given by <code>risk_aversion = 1</code>.
The risk aversion parameter is passed into <code>optimize.portfolio</code> as an added argument to the <code>portfolio</code> object.)
</p>
</li>
<li><p> Minimize portfolio ES/ETL/CVaR optimization subject to leverage, box, group, and/or target mean return constraints and tail probability parameter.
(The default tail probability is 0.05, and specified tail probability could be given by <code>arguments = list(p=0.95)</code>.
The tail probability parameter is passed into <code>optimize.portfolio</code> as an added argument to the <code>portfolio</code> object.)
</p>
</li>
<li><p> Minimize portfolio CSM optimization subject to leverage, box, group, and/or target mean return constraints and tail probability parameter.
(The default tail probability is 0.05, and specified tail probability could be given by <code>arguments = list(p=0.95)</code>.
The tail probability parameter is passed into <code>optimize.portfolio</code> as an added argument to the <code>portfolio</code> object.)
</p>
</li>
<li><p> Maximize portfolio mean return per unit standard deviation (i.e. the Sharpe Ratio) subject to leverage, box, group, and/or target mean return constraints.
It should be specified by <code>maxSR=TRUE</code> in <code>optimize.portfolio</code> with both mean and var/StdDev objectives.
Otherwise, the default action is to maximize quadratic utility.
</p>
</li>
<li><p> Maximize portfolio mean return per unit ES (i.e. the ES ratio/STARR) subject to leverage, box, group, and/or target mean return constraints.
It could be specified by <code>maxSTARR=TRUE</code> or <code>ESratio=TRUE</code> in <code>optimize.portfolio</code> with both mean and ES objectives.
The default action is to maximize ES ratio. If <code>maxSTARR=FALSE</code> or <code>ESratio=FALSE</code> is given, the action will be minimizing ES.
</p>
</li>
<li><p> Maximize portfolio mean return per unit CSM (i.e. the CSM ratio) subject to leverage, box, group, and/or target mean return constraints.
It could be specified by <code>CSMratio=TRUE</code> in <code>optimize.portfolio</code> with both mean and CSM objectives.
The default action is to maximize CSM ratio. If <code>CSMratio=FALSE</code> is given, the action will be minimizing CSM.
</p>
</li></ul>

<p>Because these convex optimization problem are standardized, there is no need for a penalty term. 
The <code>multiplier</code> argument in <code><a href="#topic+add.objective">add.objective</a></code> passed into the complete constraint object are ignored by the CVXR solver.
</p>


<h3>Value</h3>

<p>a list containing the following elements
</p>

<dl>
<dt><code>weights</code>:</dt><dd><p> The optimal set weights.</p>
</dd>
<dt><code>objective_measures</code>:</dt><dd><p> A list containing the value of each objective corresponding to the optimal weights.</p>
</dd>
<dt><code>opt_values</code>:</dt><dd><p> A list containing the value of each objective corresponding to the optimal weights.</p>
</dd>
<dt><code>out</code>:</dt><dd><p> The output of the solver.</p>
</dd>
<dt><code>call</code>:</dt><dd><p> The function call.</p>
</dd>
<dt><code>portfolio</code>:</dt><dd><p> The portfolio object.</p>
</dd>
<dt><code>R</code>:</dt><dd><p> The asset returns.</p>
</dd>
<dt><code>data summary:</code></dt><dd><p> The first row and last row of <code>R</code>.</p>
</dd>
<dt><code>elapsed_time:</code></dt><dd><p> The amount of time that elapses while the optimization is run.</p>
</dd>
<dt><code>end_t:</code></dt><dd><p> The date and time the optimization completed.</p>
</dd>
</dl>

<p>When Trace=TRUE is specified, the following elements will be returned in 
addition to the elements above. The output depends on the optimization 
method and is specific to each solver. Refer to the documentation of the
desired solver for more information.
</p>
<p><code>optimize_method="random"</code>
</p>

<dl>
<dt><code>random_portfolios</code>:</dt><dd><p> A matrix of the random portfolios.</p>
</dd>
<dt><code>random_portfolio_objective_results</code>:</dt><dd><p> A list of the following elements for each random portfolio.</p>
</dd>
</dl>

<dl>
<dt><code>out</code>:</dt><dd><p> The output value of the solver corresponding to the random portfolio weights.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p> The weights of the random portfolio.</p>
</dd>
<dt><code>objective_measures</code>:</dt><dd><p> A list of each objective measure corresponding to the random portfolio weights.</p>
</dd>
</dl>


<p><code>optimize_method="DEoptim"</code>
</p>

<dl>
<dt><code>DEoutput:</code></dt><dd><p> A list (of length 2) containing the following elements:</p>
</dd>
</dl>

<ul>
<li> <p><code>optim</code>
</p>
</li>
<li> <p><code>member</code>
</p>
</li></ul>

<dl>
<dt><code>DEoptim_objective_results</code>:</dt><dd><p> A list containing the following elements for each intermediate population.</p>
</dd>
</dl>

<ul>
<li> <p><code>out</code>: The output of the solver.
</p>
</li>
<li> <p><code>weights</code>: Population weights.
</p>
</li>
<li> <p><code>init_weights</code>: Initial population weights.
</p>
</li>
<li> <p><code>objective_measures</code>: A list of each objective measure corresponding to the weights
</p>
</li></ul>


<p><code>optimize_method="pso"</code>
</p>

<ul>
<li> <p><code>PSOoutput</code>: A list containing the following elements:
</p>

<ul>
<li><p> par
</p>
</li>
<li><p> value 
</p>
</li>
<li><p> counts 
</p>
</li>
<li><p> convergence
</p>
</li>
<li><p> message
</p>
</li>
<li><p> stats
</p>
</li></ul>

</li></ul>

<p><code>optimize_method="GenSA"</code>
</p>

<ul>
<li> <p><code>GenSAoutput</code>: A list containing the following elements:
</p>

<ul>
<li><p> value
</p>
</li>
<li><p> par
</p>
</li>
<li><p> trace.mat
</p>
</li>
<li><p> counts
</p>
</li></ul>

</li></ul>



<h3>Note</h3>

<p>An object of class <code>v1_constraint</code> can be passed in for the <code>constraints</code> argument.
The <code>v1_constraint</code> object was used in the previous 'v1' specification to specify the 
constraints and objectives for the optimization problem, see <code><a href="#topic+constraint">constraint</a></code>. 
We will attempt to detect if the object passed into the constraints argument 
is a <code>v1_constraint</code> object and update to the 'v2' specification by adding the 
constraints and objectives to the <code>portfolio</code> object.
</p>


<h3>Author(s)</h3>

<p>Kris Boudt, Peter Carl, Brian G. Peterson, Ross Bennett, Xiaokang Feng, Xinran Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>

<hr>
<h2 id='optimize.portfolio.parallel'>Execute multiple optimize.portfolio calls, presumably in parallel</h2><span id='topic+optimize.portfolio.parallel'></span>

<h3>Description</h3>

<p>This function will not speed up optimization!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize.portfolio.parallel(
  R,
  portfolio,
  optimize_method = c("DEoptim", "random", "ROI", "pso", "GenSA", "CVXR"),
  search_size = 20000,
  trace = FALSE,
  ...,
  rp = NULL,
  momentFUN = "set.portfolio.moments",
  message = FALSE,
  nodes = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize.portfolio.parallel_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints and objectives for the optimization</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_optimize_method">optimize_method</code></td>
<td>
<p>one of &quot;DEoptim&quot;, &quot;random&quot;, &quot;pso&quot;, &quot;GenSA&quot;.</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_search_size">search_size</code></td>
<td>
<p>integer, how many portfolios to test, default 20,000</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE if TRUE will attempt to return additional information on the path or portfolios searched</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_rp">rp</code></td>
<td>
<p>matrix of random portfolio weights, default NULL, mostly for automated use by rebalancing optimization or repeated tests on same portfolios</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_momentfun">momentFUN</code></td>
<td>
<p>the name of a function to call to set portfolio moments, default <code><a href="#topic+set.portfolio.moments_v2">set.portfolio.moments_v2</a></code></p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="optimize.portfolio.parallel_+3A_nodes">nodes</code></td>
<td>
<p>how many processes to run in the foreach loop, default 4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists to run multiple copies of optimize.portfolio, presumabley in parallel using foreach.
</p>
<p>This is typically done to test your parameter settings, specifically 
total population size, but also possibly to help tune your 
convergence settings, number of generations, stopping criteria,
etc.
</p>
<p>If you want to use all the cores on your multi-core computer, use 
the parallel version of the apppropriate optimization engine, not 
this function.
</p>


<h3>Value</h3>

<p>a list containing the optimal weights, some summary statistics, the function call, and optionally trace information
</p>


<h3>Author(s)</h3>

<p>Kris Boudt, Peter Carl, Brian G. Peterson
</p>

<hr>
<h2 id='optimize.portfolio.rebalancing'>Portfolio Optimization with Rebalancing Periods</h2><span id='topic+optimize.portfolio.rebalancing'></span><span id='topic+optimize.portfolio.rebalancing_v1'></span>

<h3>Description</h3>

<p>Portfolio optimization with support for rebalancing periods for 
out-of-sample testing (i.e. backtesting)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize.portfolio.rebalancing_v1(
  R,
  constraints,
  optimize_method = c("DEoptim", "random", "ROI"),
  search_size = 20000,
  trace = FALSE,
  ...,
  rp = NULL,
  rebalance_on = NULL,
  training_period = NULL,
  rolling_window = NULL
)

optimize.portfolio.rebalancing(
  R,
  portfolio = NULL,
  constraints = NULL,
  objectives = NULL,
  optimize_method = c("DEoptim", "random", "ROI", "CVXR"),
  search_size = 20000,
  trace = FALSE,
  ...,
  rp = NULL,
  rebalance_on = NULL,
  training_period = NULL,
  rolling_window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize.portfolio.rebalancing_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_constraints">constraints</code></td>
<td>
<p>default NULL, a list of constraint objects</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_optimize_method">optimize_method</code></td>
<td>
<p>one of &quot;DEoptim&quot;, &quot;random&quot;, &quot;pso&quot;, &quot;GenSA&quot;, or &quot;ROI&quot;</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_search_size">search_size</code></td>
<td>
<p>integer, how many portfolios to test, default 20,000</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE if TRUE will attempt to return additional 
information on the path or portfolios searched</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_rp">rp</code></td>
<td>
<p>a set of random portfolios passed into the function to prevent recalculation</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_rebalance_on">rebalance_on</code></td>
<td>
<p>character string of period to rebalance on. See 
<code><a href="xts.html#topic+endpoints">endpoints</a></code> for valid names.</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_training_period">training_period</code></td>
<td>
<p>an integer of the number of periods to use as 
a training data in the front of the returns data</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_rolling_window">rolling_window</code></td>
<td>
<p>an integer of the width (i.e. number of periods)
of the rolling window, the default of NULL will run the optimization 
using the data from inception.</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints 
and objectives for the optimization</p>
</td></tr>
<tr><td><code id="optimize.portfolio.rebalancing_+3A_objectives">objectives</code></td>
<td>
<p>default NULL, a list of objective objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run portfolio optimization with periodic rebalancing at specified time periods. 
Running the portfolio optimization with periodic rebalancing can help 
refine the constraints and objectives by evaluating the out of sample
performance of the portfolio based on historical data.
</p>
<p>If both <code>training_period</code> and <code>rolling_window</code> are <code>NULL</code>, 
then <code>training_period</code> is set to a default value of 36. 
</p>
<p>If <code>training_period</code> is <code>NULL</code> and a <code>rolling_window</code> is 
specified, then <code>training_period</code> is set to the value of 
<code>rolling_window</code>.
</p>
<p>The user should be aware of the following behavior when both 
<code>training_period</code> and <code>rolling_window</code> are specified and have 
different values
</p>

<dl>
<dt><code>training_period &lt; rolling_window</code>: </dt><dd><p>For example, if you have 
<code>rolling_window=60</code>, <code>training_period=50</code>, and the periodicity 
of the data is the same as the rebalance frequency (i.e. monthly data with 
<code>rebalance_on="months")</code> then the returns data used in the optimization 
at each iteration are as follows:
</p>

<ul>
<li><p> 1: R[1:50,]
</p>
</li>
<li><p> 2: R[1:51,]
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> 11: R[1:60,]
</p>
</li>
<li><p> 12: R[1:61,]
</p>
</li>
<li><p> 13: R[2:62,]
</p>
</li>
<li><p> ...
</p>
</li></ul>

<p>This results in a growing window for several optimizations initially while
the endpoint iterator (i.e. <code>[50, 51, ...]</code>) is less than the 
rolling window width.</p>
</dd>
<dt><code>training_period &gt; rolling_window</code>: </dt><dd><p>The data used in the initial 
optimization is <code>R[(training_period - rolling_window):training_period,]</code>. 
This results in some of the data being &quot;thrown away&quot;, i.e. periods 1 to 
<code>(training_period - rolling_window - 1)</code> are not used in the optimization.</p>
</dd>
</dl>

<p>This function is a essentially a wrapper around <code>optimize.portfolio</code> 
and thus the discussion in the Details section of the 
<code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code> help file is valid here as well.
</p>
<p>This function is massively parallel and requires the 'foreach' package. It
is suggested to register a parallel backend.
</p>


<h3>Value</h3>

<p>a list containing the following elements
</p>

<dl>
<dt><code>portfolio</code>:</dt><dd><p> The portfolio object.</p>
</dd>
<dt><code>R</code>:</dt><dd><p> The asset returns.</p>
</dd>
<dt><code>call</code>:</dt><dd><p> The function call.</p>
</dd>
<dt><code>elapsed_time:</code></dt><dd><p> The amount of time that elapses while the 
optimization is run.</p>
</dd>
<dt><code>opt_rebalancing:</code></dt><dd><p> A list of <code>optimize.portfolio</code> 
objects computed at each rebalancing period.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kris Boudt, Peter Carl, Brian G. Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code> <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(edhec)
R &lt;- edhec[,1:4]
funds &lt;- colnames(R)

portf &lt;- portfolio.spec(funds)
portf &lt;- add.constraint(portf, type="full_investment")
portf &lt;- add.constraint(portf, type="long_only")
portf &lt;- add.objective(portf, type="risk", name="StdDev")

# Quarterly rebalancing with 5 year training period
bt.opt1 &lt;- optimize.portfolio.rebalancing(R, portf,
optimize_method="ROI",
rebalance_on="quarters",
training_period=60)

# Monthly rebalancing with 5 year training period and 4 year rolling window
bt.opt2 &lt;- optimize.portfolio.rebalancing(R, portf,
optimize_method="ROI",
rebalance_on="months",
training_period=60,
rolling_window=48)

## End(Not run)
</code></pre>

<hr>
<h2 id='pHist'>Generates histogram</h2><span id='topic+pHist'></span>

<h3>Description</h3>

<p>Generates histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pHist(X, p, nBins, freq = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pHist_+3A_x">X</code></td>
<td>
<p>a vector containing the data points</p>
</td></tr>
<tr><td><code id="pHist_+3A_p">p</code></td>
<td>
<p>a vector containing the probabilities for each of the data points in X</p>
</td></tr>
<tr><td><code id="pHist_+3A_nbins">nBins</code></td>
<td>
<p>expected number of Bins the data set is to be broken down into</p>
</td></tr>
<tr><td><code id="pHist_+3A_freq">freq</code></td>
<td>
<p>a boolean variable to indicate whether the graphic is a representation of frequencies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 
f   the frequency for each midpoint
x   the midpoints of the nBins intervals
</p>


<h3>Author(s)</h3>

<p>Ram Ahluwalia <a href="mailto:ram@wingedfootcapital.com">ram@wingedfootcapital.com</a> and Xavier Valls <a href="mailto:flamejat@gmail.com">flamejat@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://www.arpm.co/">https://www.arpm.co/</a>
See Meucci script pHist.m used for plotting
</p>

<hr>
<h2 id='plot.optimize.portfolio.DEoptim'>plot method for objects of class <code>optimize.portfolio</code></h2><span id='topic+plot.optimize.portfolio.DEoptim'></span><span id='topic+plot.optimize.portfolio.GenSA'></span><span id='topic+plot.optimize.portfolio.pso'></span><span id='topic+plot.optimize.portfolio.ROI'></span><span id='topic+plot.optimize.portfolio.random'></span><span id='topic+plot.optimize.portfolio'></span>

<h3>Description</h3>

<p>Scatter and weights chart for portfolio optimizations run with trace=TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimize.portfolio.DEoptim'
plot(
  x,
  ...,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  neighbors = NULL,
  main = "optimized portfolio plot",
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.GenSA'
plot(
  x,
  ...,
  rp = FALSE,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  cex.axis = 0.8,
  element.color = "darkgray",
  neighbors = NULL,
  main = "GenSA.Portfolios",
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.pso'
plot(
  x,
  ...,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  cex.axis = 0.8,
  element.color = "darkgray",
  neighbors = NULL,
  main = "PSO.Portfolios",
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.ROI'
plot(
  x,
  ...,
  rp = FALSE,
  risk.col = "ES",
  return.col = "mean",
  chart.assets = FALSE,
  element.color = "darkgray",
  neighbors = NULL,
  main = "ROI.Portfolios",
  xlim = NULL,
  ylim = NULL
)

## S3 method for class 'optimize.portfolio.random'
plot(
  x,
  ...,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  neighbors = NULL,
  xlim = NULL,
  ylim = NULL,
  main = "optimized portfolio plot"
)

## S3 method for class 'optimize.portfolio'
plot(
  x,
  ...,
  return.col = "mean",
  risk.col = "ES",
  chart.assets = FALSE,
  neighbors = NULL,
  xlim = NULL,
  ylim = NULL,
  main = "optimized portfolio plot"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_x">x</code></td>
<td>
<p>set of portfolios created by <code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code></p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_return.col">return.col</code></td>
<td>
<p>string name of column to use for returns (vertical axis)</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_risk.col">risk.col</code></td>
<td>
<p>string name of column to use for risk (horizontal axis)</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_chart.assets">chart.assets</code></td>
<td>
<p>TRUE/FALSE to include risk-return scatter of assets</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_neighbors">neighbors</code></td>
<td>
<p>set of 'neighbor portfolios to overplot</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_xlim">xlim</code></td>
<td>
<p>set the limit on coordinates for the x-axis</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_ylim">ylim</code></td>
<td>
<p>set the limit on coordinates for the y-axis</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_rp">rp</code></td>
<td>
<p>TRUE/FALSE to plot feasible portfolios generated by <code><a href="#topic+random_portfolios">random_portfolios</a></code></p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for axis annotation relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="plot.optimize.portfolio.DEoptim_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>return.col</code> must be the name of a function used to compute the return metric on the random portfolio weights
<code>risk.col</code> must be the name of a function used to compute the risk metric on the random portfolio weights
</p>
<p><code>neighbors</code> may be specified in three ways.  
The first is as a single number of neighbors.  This will extract the <code>neighbors</code> closest 
portfolios in terms of the <code>out</code> numerical statistic.
The second method consists of a numeric vector for <code>neighbors</code>.
This will extract the <code>neighbors</code> with portfolio index numbers that correspond to the vector contents.
The third method for specifying <code>neighbors</code> is to pass in a matrix.  
This matrix should look like the output of <code><a href="#topic+extractStats">extractStats</a></code>, and should contain
<code>risk.col</code>,<code>return.col</code>, and weights columns all properly named.
</p>
<p>The ROI and GenSA solvers do not store the portfolio weights like DEoptim or random
portfolios, random portfolios can be generated for the scatter plot with the
<code>rp</code> argument.
</p>

<hr>
<h2 id='plotFrontiers'>Generate efficient frontiers plot by providing frontiers.</h2><span id='topic+plotFrontiers'></span>

<h3>Description</h3>

<p>Generate efficient frontiers plot by providing frontiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFrontiers(
  R,
  frontiers,
  risk,
  ES_alpha = 0.05,
  CSM_alpha = 0.05,
  moment_setting = NULL,
  main = "Efficient Frontiers",
  plot_type = "l",
  cex.axis = 0.5,
  element.color = "darkgray",
  legend.loc = NULL,
  legend.labels = NULL,
  cex.legend = 0.8,
  xlim = NULL,
  ylim = NULL,
  ...,
  labels.assets = TRUE,
  pch.assets = 21,
  cex.assets = 0.8,
  col = NULL,
  lty = NULL,
  lwd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFrontiers_+3A_r">R</code></td>
<td>
<p>an xts object of asset returns</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_frontiers">frontiers</code></td>
<td>
<p>a list of frontiers, for example, list(ef1=meanvar.efficient.frontier(), ef2=meanvar.efficient.frontier())</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_risk">risk</code></td>
<td>
<p>type of risk that you want to compare, could be 'StdDev', 'ES', 'CSM'</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_es_alpha">ES_alpha</code></td>
<td>
<p>the default value is 0.05, but could be specified as any value between 0 and 1</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_csm_alpha">CSM_alpha</code></td>
<td>
<p>the default value is 0.05, but could be specified as any value between 0 and 1</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_moment_setting">moment_setting</code></td>
<td>
<p>the default is NULL, if customize momentFUN please provide moment_setting=list(mu=, sigma=)</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_main">main</code></td>
<td>
<p>title used in the plot.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_plot_type">plot_type</code></td>
<td>
<p>define the plot_type, default is &quot;l&quot;</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for sizing the axis text relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_element.color">element.color</code></td>
<td>
<p>provides the color for drawing less-important chart elements, such as the box lines, axis lines, etc.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_legend.loc">legend.loc</code></td>
<td>
<p>location of the legend; NULL, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_legend.labels">legend.labels</code></td>
<td>
<p>character vector to use for the legend labels.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for sizing the legend relative to the current setting of 'cex', similar to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_xlim">xlim</code></td>
<td>
<p>set the x-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_ylim">ylim</code></td>
<td>
<p>set the y-axis limit, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_...">...</code></td>
<td>
<p>passthrough parameters to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_labels.assets">labels.assets</code></td>
<td>
<p>TRUE/FALSE to include the asset names in the plot.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_pch.assets">pch.assets</code></td>
<td>
<p>plotting character of the assets, same as in <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_cex.assets">cex.assets</code></td>
<td>
<p>A numerical value giving the amount by which the asset points and labels should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_col">col</code></td>
<td>
<p>vector of colors with length equal to the number of portfolios in <code>frontiers</code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_lty">lty</code></td>
<td>
<p>vector of line types with length equal to the number of portfolios in <code>frontiers</code>.</p>
</td></tr>
<tr><td><code id="plotFrontiers_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths with length equal to the number of portfolios in <code>frontiers</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the ability to plot frontiers based on the result of 
'meanvar.efficient.frontier', 'meanetl.efficient.frontier' or 'meancsm.efficient.frontier'.
</p>
<p>When using <code>meanvar.efficient.frontier</code>, <code>meanetl.efficient.frontier</code> 
and <code>meancsm.efficient.frontier</code>, the result will be frontiers data,
including the weights for each point on the mean-risk efficient frontiers. 
Before using this function, user should declare which risk that they want to 
compare, and what parameters that they want to use to calculate the risk, 
e.g. <code>ES_alpha</code> for ES, <code>moment_setting</code> for var. Then this function 
will calculate back mean and risk based on the weight, and draw a plot.
</p>
<p>Default settings use colors and line types to differentiate portfolios, and set 
the portfolio name as 'Portfolio 1' and so on. Users could customize col, lty, 
lwd and legend.labels to better the plot.
</p>


<h3>Author(s)</h3>

<p>Xinran Zhao
</p>

<hr>
<h2 id='portfolio_risk_objective'>constructor for class portfolio_risk_objective</h2><span id='topic+portfolio_risk_objective'></span>

<h3>Description</h3>

<p>if target is null, we'll try to minimize the risk metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio_risk_objective(
  name,
  target = NULL,
  arguments = NULL,
  multiplier = 1,
  enabled = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio_risk_objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="portfolio_risk_objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective</p>
</td></tr>
<tr><td><code id="portfolio_risk_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="portfolio_risk_objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="portfolio_risk_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="portfolio_risk_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'portfolio_risk_objective'
</p>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>

<hr>
<h2 id='portfolio.moments.bl'>Portfolio Moments</h2><span id='topic+portfolio.moments.bl'></span>

<h3>Description</h3>

<p>Set portfolio moments for use by lower level optimization functions using
a basic Black Litterman model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.moments.bl(
  R,
  portfolio,
  momentargs = NULL,
  P,
  Mu = NULL,
  Sigma = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.moments.bl_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of 
asset returns</p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type <code>portfolio</code> specifying the 
constraints and objectives for the optimization, see 
<code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_momentargs">momentargs</code></td>
<td>
<p>list containing arguments to be passed down to lower level 
functions, default NULL</p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_p">P</code></td>
<td>
<p>a K x N pick matrix representing views</p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_mu">Mu</code></td>
<td>
<p>vector of length N of the prior expected values. The sample mean
is used if <code>Mu=NULL</code>.</p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_sigma">Sigma</code></td>
<td>
<p>an N x N matrix of the prior covariance matrix. The sample 
covariance is used if <code>Sigma=NULL</code>.</p>
</td></tr>
<tr><td><code id="portfolio.moments.bl_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If any of the objectives in the <code>portfolio</code> object have 
<code>clean</code> as an argument, the cleaned returns are used to fit the model.
</p>

<hr>
<h2 id='portfolio.moments.boudt'>Portfolio Moments</h2><span id='topic+portfolio.moments.boudt'></span>

<h3>Description</h3>

<p>Set portfolio moments for use by lower level optimization functions using
a statistical factor model based on the work of Kris Boudt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.moments.boudt(R, portfolio, momentargs = NULL, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.moments.boudt_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of 
asset returns</p>
</td></tr>
<tr><td><code id="portfolio.moments.boudt_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type <code>portfolio</code> specifying the 
constraints and objectives for the optimization, see 
<code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="portfolio.moments.boudt_+3A_momentargs">momentargs</code></td>
<td>
<p>list containing arguments to be passed down to lower level 
functions, default NULL</p>
</td></tr>
<tr><td><code id="portfolio.moments.boudt_+3A_k">k</code></td>
<td>
<p>number of factors used for fitting statistical factor model</p>
</td></tr>
<tr><td><code id="portfolio.moments.boudt_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If any of the objectives in the <code>portfolio</code> object have 
<code>clean</code> as an argument, the cleaned returns are used to fit the model.
</p>

<hr>
<h2 id='portfolio.spec'>constructor for class portfolio</h2><span id='topic+portfolio.spec'></span><span id='topic+portfolio'></span>

<h3>Description</h3>

<p>The portfolio object is created with <code>portfolio.spec</code>. The portfolio
object is an S3 object of class 'portfolio' used to hold the initial asset weights,
constraints, objectives, and other information about the portfolio. The only
required argument to <code>portfolio.spec</code> is <code>assets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.spec(
  assets = NULL,
  name = "portfolio",
  category_labels = NULL,
  weight_seq = NULL,
  message = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.spec_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying seed weights. If seed weights are not specified, an equal weight portfolio will be assumed.</p>
</td></tr>
<tr><td><code id="portfolio.spec_+3A_name">name</code></td>
<td>
<p>give the portfolio a name, the default name will be 'portfolio'</p>
</td></tr>
<tr><td><code id="portfolio.spec_+3A_category_labels">category_labels</code></td>
<td>
<p>character vector to categorize assets by sector, industry, geography, market-cap, currency, etc. Default NULL</p>
</td></tr>
<tr><td><code id="portfolio.spec_+3A_weight_seq">weight_seq</code></td>
<td>
<p>seed sequence of weights, see <code><a href="#topic+generatesequence">generatesequence</a></code> Default NULL</p>
</td></tr>
<tr><td><code id="portfolio.spec_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The portfolio object contains the following elements:
</p>

<dl>
<dt><code>assets</code></dt><dd><p> named vector of the seed weights</p>
</dd>
<dt><code>category_labels</code></dt><dd><p> character vector to categorize the assets by sector, geography, etc.</p>
</dd>
<dt><code>weight_seq</code></dt><dd><p> sequence of weights used by <code><a href="#topic+random_portfolios">random_portfolios</a></code>. See <code><a href="#topic+generatesequence">generatesequence</a></code></p>
</dd>
<dt><code>constraints</code></dt><dd><p> a list of constraints added to the portfolio object with <code><a href="#topic+add.constraint">add.constraint</a></code></p>
</dd>
<dt><code>objectives</code></dt><dd><p> a list of objectives added to the portfolio object with <code><a href="#topic+add.objective">add.objective</a></code></p>
</dd>
<dt><code>call</code></dt><dd><p> the call to <code>portfolio.spec</code> with all of the specified arguments</p>
</dd>
</dl>



<h3>Value</h3>

<p>an object of class <code>portfolio</code>
</p>


<h3>Author(s)</h3>

<p>Ross Bennett, Brian G. Peterson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>,
<code><a href="#topic+add.objective">add.objective</a></code>,
<code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
pspec &lt;- portfolio.spec(assets=colnames(edhec))
pspec &lt;- portfolio.spec(assets=10, weight_seq=generatesequence())
</code></pre>

<hr>
<h2 id='pos_limit_fail'>function to check for violation of position limits constraints</h2><span id='topic+pos_limit_fail'></span>

<h3>Description</h3>

<p>This is used as a helper function for <code><a href="#topic+rp_transform">rp_transform</a></code> to check
for violation of position limit constraints. The position limit constraints
checked are max_pos, max_pos_long, and max_pos_short.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos_limit_fail(weights, max_pos, max_pos_long, max_pos_short)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pos_limit_fail_+3A_weights">weights</code></td>
<td>
<p>vector of weights to test</p>
</td></tr>
<tr><td><code id="pos_limit_fail_+3A_max_pos">max_pos</code></td>
<td>
<p>maximum number of assets with non-zero weights</p>
</td></tr>
<tr><td><code id="pos_limit_fail_+3A_max_pos_long">max_pos_long</code></td>
<td>
<p>maximum number of assets with long (i.e. buy) positions</p>
</td></tr>
<tr><td><code id="pos_limit_fail_+3A_max_pos_short">max_pos_short</code></td>
<td>
<p>maximum number of assets with short (i.e. sell) positions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if any position_limit is violated. FALSE if all position limits are satisfied
</p>

<hr>
<h2 id='position_limit_constraint'>constructor for filter_constraint</h2><span id='topic+position_limit_constraint'></span>

<h3>Description</h3>

<p>This function is called by add.constraint when type=&quot;filter&quot; is specified, <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_limit_constraint(
  type = "position_limit",
  filter_name = NULL,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_limit_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="position_limit_constraint_+3A_filter_name">filter_name</code></td>
<td>
<p>either a function to apply, or a name of a function to apply</p>
</td></tr>
<tr><td><code id="position_limit_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="position_limit_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="position_limit_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify position limit constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allows the user to specify a filter function which will take returns, weights,
and constraints as inputs, and can return a modified weights vector as output.
</p>
<p>Fundamentally, it could be used to filter out certain assets, or to ensure 
that they must be long or short.
</p>
<p>Typically, filter functions will be called by the random portfolio simulation
function or via the fn_map function.
</p>


<h3>Value</h3>

<p>an object of class 'position_limit_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="position_limit", max_pos=3)
pspec &lt;- add.constraint(portfolio=pspec, type="position_limit", max_pos_long=3, max_pos_short=1)
</code></pre>

<hr>
<h2 id='print.constraint'>print method for constraint objects</h2><span id='topic+print.constraint'></span>

<h3>Description</h3>

<p>print method for constraint objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constraint'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.constraint_+3A_x">x</code></td>
<td>
<p>object of class <code>constraint</code></p>
</td></tr>
<tr><td><code id="print.constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='print.efficient.frontier'>Print an efficient frontier object</h2><span id='topic+print.efficient.frontier'></span>

<h3>Description</h3>

<p>Print method for efficient frontier objects. Display the call to create or
extract the efficient frontier object and the portfolio from which the 
efficient frontier was created or extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efficient.frontier'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.efficient.frontier_+3A_x">x</code></td>
<td>
<p>objective of class <code>efficient.frontier</code></p>
</td></tr>
<tr><td><code id="print.efficient.frontier_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.EfficientFrontier">create.EfficientFrontier</a></code>
</p>

<hr>
<h2 id='print.optimize.portfolio.rebalancing'>Printing output of optimize.portfolio.rebalancing</h2><span id='topic+print.optimize.portfolio.rebalancing'></span>

<h3>Description</h3>

<p>print method for <code>optimize.portfolio.rebalancing</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimize.portfolio.rebalancing'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optimize.portfolio.rebalancing_+3A_x">x</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="print.optimize.portfolio.rebalancing_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="print.optimize.portfolio.rebalancing_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio.rebalancing">optimize.portfolio.rebalancing</a></code>
</p>

<hr>
<h2 id='print.optimize.portfolio.ROI'>Printing output of optimize.portfolio</h2><span id='topic+print.optimize.portfolio.ROI'></span><span id='topic+print.optimize.portfolio.CVXR'></span><span id='topic+print.optimize.portfolio.random'></span><span id='topic+print.optimize.portfolio.DEoptim'></span><span id='topic+print.optimize.portfolio.GenSA'></span><span id='topic+print.optimize.portfolio.pso'></span>

<h3>Description</h3>

<p>print method for <code>optimize.portfolio</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimize.portfolio.ROI'
print(x, ..., digits = 4)

## S3 method for class 'optimize.portfolio.CVXR'
print(x, ..., digits = 4)

## S3 method for class 'optimize.portfolio.random'
print(x, ..., digits = 4)

## S3 method for class 'optimize.portfolio.DEoptim'
print(x, ..., digits = 4)

## S3 method for class 'optimize.portfolio.GenSA'
print(x, ..., digits = 4)

## S3 method for class 'optimize.portfolio.pso'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optimize.portfolio.ROI_+3A_x">x</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="print.optimize.portfolio.ROI_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="print.optimize.portfolio.ROI_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='print.portfolio'>Printing Portfolio Specification Objects</h2><span id='topic+print.portfolio'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>portfolio</code> created with <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'portfolio'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.portfolio_+3A_x">x</code></td>
<td>
<p>an object of class <code>portfolio</code></p>
</td></tr>
<tr><td><code id="print.portfolio_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>

<hr>
<h2 id='print.summary.optimize.portfolio'>Printing summary output of optimize.portfolio</h2><span id='topic+print.summary.optimize.portfolio'></span>

<h3>Description</h3>

<p>print method for objects of class <code>summary.optimize.portfolio</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.optimize.portfolio'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.optimize.portfolio_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.optimize.portfolio</code>.</p>
</td></tr>
<tr><td><code id="print.summary.optimize.portfolio_+3A_...">...</code></td>
<td>
<p>any other passthru parameters. Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.optimize.portfolio">summary.optimize.portfolio</a></code>
</p>

<hr>
<h2 id='print.summary.optimize.portfolio.rebalancing'>Printing summary output of optimize.portfolio.rebalancing</h2><span id='topic+print.summary.optimize.portfolio.rebalancing'></span>

<h3>Description</h3>

<p>print method for objects of class <code>summary.optimize.portfolio.rebalancing</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.optimize.portfolio.rebalancing'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.optimize.portfolio.rebalancing_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.optimize.portfolio.rebalancing</code>.</p>
</td></tr>
<tr><td><code id="print.summary.optimize.portfolio.rebalancing_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="print.summary.optimize.portfolio.rebalancing_+3A_digits">digits</code></td>
<td>
<p>number of digits used for printing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.optimize.portfolio.rebalancing">summary.optimize.portfolio.rebalancing</a></code>
</p>

<hr>
<h2 id='quadratic_utility_objective'>constructor for quadratic utility objective</h2><span id='topic+quadratic_utility_objective'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+return_objective">return_objective</a></code> and <code><a href="#topic+portfolio_risk_objective">portfolio_risk_objective</a></code>
to create a list of the objectives to be added to the portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic_utility_objective(risk_aversion = 1, target = NULL, enabled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadratic_utility_objective_+3A_risk_aversion">risk_aversion</code></td>
<td>
<p>risk_aversion (i.e. lambda) parameter to penalize variance</p>
</td></tr>
<tr><td><code id="quadratic_utility_objective_+3A_target">target</code></td>
<td>
<p>target mean return value</p>
</td></tr>
<tr><td><code id="quadratic_utility_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE, default enabled=TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements
</p>

<ul>
<li> <p><code>return_objective</code>
</p>
</li>
<li> <p><code>portfolio_risk_objective</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='random_portfolios'>version 2 generate an arbitary number of constrained random portfolios</h2><span id='topic+random_portfolios'></span><span id='topic+random_portfolios_v2'></span>

<h3>Description</h3>

<p>Generate random portfolios using the 'sample', 'simplex', or 'grid' method. 
See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_portfolios(
  portfolio,
  permutations = 100,
  rp_method = "sample",
  eliminate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_portfolios_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class 'portfolio' specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="random_portfolios_+3A_permutations">permutations</code></td>
<td>
<p>integer: number of unique constrained random portfolios to generate</p>
</td></tr>
<tr><td><code id="random_portfolios_+3A_rp_method">rp_method</code></td>
<td>
<p>method to generate random portfolios. Currently &quot;sample&quot;, &quot;simplex&quot;, or &quot;grid&quot;. See Details.</p>
</td></tr>
<tr><td><code id="random_portfolios_+3A_eliminate">eliminate</code></td>
<td>
<p>TRUE/FALSE, eliminate portfolios that do not satisfy constraints</p>
</td></tr>
<tr><td><code id="random_portfolios_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random portfolios can be generate using one of three methods.
</p>

<dl>
<dt>sample: </dt><dd><p>The 'sample' method to generate random portfolios is based
on an idea pioneerd by Pat Burns. This is the most flexible method, but 
also the slowest, and can generate portfolios to satisfy leverage, box, 
group, position limit, and leverage exposure constraints.</p>
</dd>
<dt>simplex: </dt><dd><p>The 'simplex' method to generate random portfolios is 
based on a paper by W. T. Shaw. The simplex method is useful to generate 
random portfolios with the full investment constraint, where the sum of the 
weights is equal to 1, and min box constraints. Values for <code>min_sum</code> 
and <code>max_sum</code> of the leverage constraint will be ignored, the sum of 
weights will equal 1. All other constraints such as group and position 
limit constraints will be handled by elimination. If the constraints are 
very restrictive, this may result in very few feasible portfolios remaining.</p>
</dd>
<dt>grid: </dt><dd><p>The 'grid' method to generate random portfolios is based on
the <code>gridSearch</code> function in package 'NMOF'. The grid search method 
only satisfies the <code>min</code> and <code>max</code> box constraints. The 
<code>min_sum</code> and <code>max_sum</code> leverage constraints will likely be 
violated and the weights in the random portfolios should be normalized. 
Normalization may cause the box constraints to be violated and will be 
penalized in <code>constrained_objective</code>.</p>
</dd>
</dl>

<p>The constraint types checked are leverage, box, group, position limit, and 
leverage exposure. Any
portfolio that does not satisfy all these constraints will be eliminated. This
function is particularly sensitive to <code>min_sum</code> and <code>max_sum</code> 
leverage constraints. For the sample method, there should be some 
&quot;wiggle room&quot; between <code>min_sum</code> and <code>max_sum</code> in order to generate 
a sufficient number of feasible portfolios. For example, <code>min_sum=0.99</code> 
and <code>max_sum=1.01</code> is recommended instead of <code>min_sum=1</code> 
and <code>max_sum=1</code>. If <code>min_sum=1</code> and <code>max_sum=1</code>, the number of
feasible portfolios may be 1/3 or less depending on the other constraints.
</p>


<h3>Value</h3>

<p>matrix of random portfolio weights
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>, 
<code><a href="#topic+objective">objective</a></code>, 
<code><a href="#topic+rp_sample">rp_sample</a></code>,
<code><a href="#topic+rp_simplex">rp_simplex</a></code>,
<code><a href="#topic+rp_grid">rp_grid</a></code>
</p>

<hr>
<h2 id='random_portfolios_v1'>generate an arbitary number of constrained random portfolios</h2><span id='topic+random_portfolios_v1'></span>

<h3>Description</h3>

<p>repeatedly calls <code><a href="#topic+randomize_portfolio">randomize_portfolio</a></code> to generate an 
arbitrary number of constrained random portfolios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_portfolios_v1(rpconstraints, permutations = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_portfolios_v1_+3A_rpconstraints">rpconstraints</code></td>
<td>
<p>an object of type &quot;constraints&quot; specifying the constraints for the optimization, see <code><a href="#topic+constraint">constraint</a></code></p>
</td></tr>
<tr><td><code id="random_portfolios_v1_+3A_permutations">permutations</code></td>
<td>
<p>integer: number of unique constrained random portfolios to generate</p>
</td></tr>
<tr><td><code id="random_portfolios_v1_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of random portfolio weights
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, (based on an idea by Pat Burns)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constraint">constraint</a></code>, <code><a href="#topic+objective">objective</a></code>, <code><a href="#topic+randomize_portfolio">randomize_portfolio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rpconstraint&lt;-constraint_v1(assets=10, 
                         min_mult=-Inf, 
                         max_mult=Inf, 
                         min_sum=.99, 
                         max_sum=1.01, 
                         min=.01, 
                         max=.4, 
                         weight_seq=generatesequence())
                         
rp&lt;- random_portfolios_v1(rpconstraints=rpconstraint,permutations=1000)
head(rp)
</code></pre>

<hr>
<h2 id='random_walk_portfolios'>deprecated random portfolios wrapper until we write a random trades function</h2><span id='topic+random_walk_portfolios'></span>

<h3>Description</h3>

<p>deprecated random portfolios wrapper until we write a random trades function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk_portfolios(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_walk_portfolios_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>bpeterson
</p>

<hr>
<h2 id='randomize_portfolio'>version 2 generate random permutations of a portfolio seed meeting your constraints on the weights of each asset</h2><span id='topic+randomize_portfolio'></span><span id='topic+randomize_portfolio_v2'></span>

<h3>Description</h3>

<p>version 2 generate random permutations of a portfolio seed meeting your constraints on the weights of each asset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_portfolio(portfolio, max_permutations = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomize_portfolio_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="randomize_portfolio_+3A_max_permutations">max_permutations</code></td>
<td>
<p>integer: maximum number of iterations to try for a valid portfolio, default 200</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named weighting vector
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, (based on an idea by Pat Burns)
</p>

<hr>
<h2 id='randomize_portfolio_v1'>Random portfolio sample method</h2><span id='topic+randomize_portfolio_v1'></span>

<h3>Description</h3>

<p>This function generates random permutations of a portfolio seed meeting 
leverage and box constraints. The final step is to run <code><a href="#topic+fn_map">fn_map</a></code>
on the random portfolio weights to transform the weights so they satisfy
other constraints such as group or position limit constraints. This is the 
'sample' method for random portfolios and is based on an idea by Pat Burns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_portfolio_v1(rpconstraints, max_permutations = 200, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomize_portfolio_v1_+3A_rpconstraints">rpconstraints</code></td>
<td>
<p>an object of type &quot;constraints&quot; specifying the constraints for the optimization, see <code><a href="#topic+constraint">constraint</a></code></p>
</td></tr>
<tr><td><code id="randomize_portfolio_v1_+3A_max_permutations">max_permutations</code></td>
<td>
<p>integer: maximum number of iterations to try for a valid portfolio, default 200</p>
</td></tr>
<tr><td><code id="randomize_portfolio_v1_+3A_rounding">rounding</code></td>
<td>
<p>integer how many decimals should we round to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named weights vector
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, (based on an idea by Pat Burns)
</p>

<hr>
<h2 id='regime.portfolios'>Regime Portfolios</h2><span id='topic+regime.portfolios'></span>

<h3>Description</h3>

<p>Construct a <code>regime.portfolios</code> object that contains a time series of 
regimes and portfolios corresponding to the regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regime.portfolios(regime, portfolios)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regime.portfolios_+3A_regime">regime</code></td>
<td>
<p>xts or zoo object specifying the regime</p>
</td></tr>
<tr><td><code id="regime.portfolios_+3A_portfolios">portfolios</code></td>
<td>
<p>list of portfolios created by
<code>combine.portfolios</code> with corresponding regimes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a <code>regime.portfolios</code> object to support regime switching
optimization. This object is then passed in as the <code>portfolio</code>
argument in <code>optimize.portfolio</code>. The regime is detected and the
corresponding portfolio is selected. For example, if the current
regime is 1, then portfolio 1 will be selected and used in the 
optimization.
</p>


<h3>Value</h3>

<p>a <code>regime.portfolios</code> object with the following elements
</p>

<dl>
<dt>regime: </dt><dd><p>An xts object of the regime</p>
</dd>
<dt>portfolio: </dt><dd><p>List of portfolios corresponding to the regime</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='return_constraint'>constructor for return_constraint</h2><span id='topic+return_constraint'></span>

<h3>Description</h3>

<p>The return constraint specifes a target mean return value.
This function is called by add.constraint when type=&quot;return&quot; is specified, <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_constraint(
  type = "return",
  return_target,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="return_constraint_+3A_return_target">return_target</code></td>
<td>
<p>return target value</p>
</td></tr>
<tr><td><code id="return_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="return_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="return_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'return_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="return", return_target=mean(colMeans(ret)))
</code></pre>

<hr>
<h2 id='return_objective'>constructor for class return_objective</h2><span id='topic+return_objective'></span>

<h3>Description</h3>

<p>if target is null, we'll try to maximize the return metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_objective(
  name,
  target = NULL,
  arguments = NULL,
  multiplier = -1,
  enabled = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="return_objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective</p>
</td></tr>
<tr><td><code id="return_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="return_objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="return_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="return_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if target is set, we'll try to meet or exceed the metric, penalizing a shortfall
</p>


<h3>Value</h3>

<p>object of class 'return_objective'
</p>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>

<hr>
<h2 id='risk_budget_objective'>constructor for class risk_budget_objective</h2><span id='topic+risk_budget_objective'></span>

<h3>Description</h3>

<p>constructor for class risk_budget_objective
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risk_budget_objective(
  assets,
  name,
  target = NULL,
  arguments = NULL,
  multiplier = 1,
  enabled = TRUE,
  ...,
  min_prisk,
  max_prisk,
  min_concentration = FALSE,
  min_difference = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="risk_budget_objective_+3A_assets">assets</code></td>
<td>
<p>vector of assets to use, should come from constraints object</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_min_prisk">min_prisk</code></td>
<td>
<p>minimum percentage contribution to risk</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_max_prisk">max_prisk</code></td>
<td>
<p>maximum percentage contribution to risk</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_min_concentration">min_concentration</code></td>
<td>
<p>TRUE/FALSE whether to minimize concentration, default FALSE, always TRUE if min_prisk and max_prisk are NULL</p>
</td></tr>
<tr><td><code id="risk_budget_objective_+3A_min_difference">min_difference</code></td>
<td>
<p>TRUE/FALSE whether to minimize difference between concentration, default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'risk_budget_objective'
</p>


<h3>Author(s)</h3>

<p>Brian G. Peterson
</p>

<hr>
<h2 id='rp_grid'>Generate random portfolios based on grid search method</h2><span id='topic+rp_grid'></span>

<h3>Description</h3>

<p>This function generates random portfolios based on the <code>gridSearch</code> 
function from the 'NMOF' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp_grid(portfolio, permutations = 2000, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rp_grid_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class 'portfolio' specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="rp_grid_+3A_permutations">permutations</code></td>
<td>
<p>integer: number of unique constrained random portfolios to generate</p>
</td></tr>
<tr><td><code id="rp_grid_+3A_normalize">normalize</code></td>
<td>
<p>TRUE/FALSE to normalize the weghts to satisfy min_sum or max_sum</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of levels is calculated based on permutations and number of assets.
The number of levels must be an integer and may not result in the exact number
of permutations. We round up to the nearest integer for the levels so the
number of portfolios generated will be greater than or equal to permutations.
</p>
<p>The grid search method only satisfies the <code>min</code> and <code>max</code> box 
constraints. The <code>min_sum</code> and <code>max_sum</code> leverage constraints will
likely be violated and the weights in the random portfolios should be 
normalized. Normalization may cause the box constraints to be violated and
will be penalized in <code>constrained_objective</code>.
</p>


<h3>Value</h3>

<p>matrix of random portfolio weights
</p>

<hr>
<h2 id='rp_sample'>Generate random portfolios using the sample method</h2><span id='topic+rp_sample'></span>

<h3>Description</h3>

<p>This function generates random portfolios based on an idea by Pat Burns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp_sample(portfolio, permutations, max_permutations = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rp_sample_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="rp_sample_+3A_permutations">permutations</code></td>
<td>
<p>integer: number of unique constrained random portfolios to generate</p>
</td></tr>
<tr><td><code id="rp_sample_+3A_max_permutations">max_permutations</code></td>
<td>
<p>integer: maximum number of iterations to try for a valid portfolio, default 200</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'sample' method to generate random portfolios is based
on an idea pioneerd by Pat Burns. This is the most flexible method, but also
the slowest, and can generate portfolios to satisfy leverage, box, group, 
and position limit constraints.
</p>


<h3>Value</h3>

<p>a matrix of random portfolio weights
</p>

<hr>
<h2 id='rp_simplex'>Generate random portfolios using the simplex method</h2><span id='topic+rp_simplex'></span>

<h3>Description</h3>

<p>This function generates random portfolios based on the method outlined in the
Shaw paper. Need to add reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp_simplex(portfolio, permutations, fev = 0:5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rp_simplex_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of class 'portfolio' specifying the constraints for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="rp_simplex_+3A_permutations">permutations</code></td>
<td>
<p>integer: number of unique constrained random portfolios to generate</p>
</td></tr>
<tr><td><code id="rp_simplex_+3A_fev">fev</code></td>
<td>
<p>scalar or vector for FEV biasing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplex method is useful to generate random portfolios with the full
investment constraint where the sum of the weights is equal to 1 and min 
box constraints with no upper bound on max constraints. Values for min_sum 
and max_sum will be ignored, the sum of weights will equal 1. All other 
constraints such as group and position limit constraints will be handled by 
elimination. If the constraints are very restrictive, this may result in 
very few feasible portfolios remaining. 
</p>
<p>The random portfolios are created by first generating a set of uniform 
random numbers.
</p>
<p style="text-align: center;"><code class="reqn">U \sim [0, 1]</code>
</p>

<p>The portfolio weights are then transformed to satisfy the min of the
box constraints.
</p>
<p style="text-align: center;"><code class="reqn">w_{i} = min_{i} + (1 - \sum_{j=1}^{N} min_{j}) \frac{log(U_{i}^{q}}{\sum_{k=1}^{N}log(U_{k}^{q}}</code>
</p>

<p><code>fev</code> controls the Face-Edge-Vertex (FEV) biasing where </p>
<p style="text-align: center;"><code class="reqn">q=2^{fev}</code>
</p>

<p>As <code>q</code> approaches infinity, the set of weights will be concentrated in a 
single asset. To sample the interior and exterior, <code>fev</code> can be passed 
in as a vector. The number of portfolios, <code>permutations</code>, and the 
length of <code>fev</code> affect how the random portfolios are generated. For 
example, if <code>permutations=10000</code> and <code>fev=0:4</code>, 2000 portfolios will
be generated for each value of <code>fev</code>.
</p>


<h3>Value</h3>

<p>a matrix of random portfolio weights
</p>

<hr>
<h2 id='rp_transform'>Transform a weights vector to satisfy constraints</h2><span id='topic+rp_transform'></span>

<h3>Description</h3>

<p>This function uses a block of code from <code><a href="#topic+randomize_portfolio">randomize_portfolio</a></code> 
to transform the weight vector if either the weight_sum (leverage) 
constraints, box constraints, group constraints, position_limit constraints,
or leverage exposure constraints are violated. The logic from 
<code>randomize_portfolio</code> is heavily utilized here with extensions to
handle more complex constraints.
The resulting weights vector might be quite different from the original weights vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp_transform(
  w,
  min_sum,
  max_sum,
  min_box,
  max_box,
  groups = NULL,
  cLO = NULL,
  cUP = NULL,
  max_pos = NULL,
  group_pos = NULL,
  max_pos_long = NULL,
  max_pos_short = NULL,
  leverage = NULL,
  weight_seq = NULL,
  max_permutations = 200
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rp_transform_+3A_w">w</code></td>
<td>
<p>weights vector to be transformed</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_min_sum">min_sum</code></td>
<td>
<p>minimum sum of all asset weights, default 0.99</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_sum">max_sum</code></td>
<td>
<p>maximum sum of all asset weights, default 1.01</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_min_box">min_box</code></td>
<td>
<p>numeric or named vector specifying minimum weight box constraints</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_box">max_box</code></td>
<td>
<p>numeric or named vector specifying maximum weight box constraints</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_groups">groups</code></td>
<td>
<p>vector specifying the groups of the assets</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_clo">cLO</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_cup">cUP</code></td>
<td>
<p>numeric or vector specifying minimum weight group constraints</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_pos">max_pos</code></td>
<td>
<p>maximum assets with non-zero weights</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_group_pos">group_pos</code></td>
<td>
<p>vector specifying maximum number assets with non-zero weights per group</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_pos_long">max_pos_long</code></td>
<td>
<p>maximum number of assets with long (i.e. buy) positions</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_pos_short">max_pos_short</code></td>
<td>
<p>maximum number of assets with short (i.e. sell) positions</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_leverage">leverage</code></td>
<td>
<p>maximum leverage exposure where leverage is defined as <code>sum(abs(weights))</code></p>
</td></tr>
<tr><td><code id="rp_transform_+3A_weight_seq">weight_seq</code></td>
<td>
<p>vector of seed sequence of weights</p>
</td></tr>
<tr><td><code id="rp_transform_+3A_max_permutations">max_permutations</code></td>
<td>
<p>integer: maximum number of iterations to try for a valid portfolio, default 200</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named weighting vector
</p>


<h3>Author(s)</h3>

<p>Peter Carl, Brian G. Peterson, Ross Bennett (based on an idea by Pat Burns)
</p>

<hr>
<h2 id='scatterFUN'>Apply a risk or return function to asset returns</h2><span id='topic+scatterFUN'></span>

<h3>Description</h3>

<p>This function is used to calculate risk or return metrics given a matrix of
asset returns and will be used for a risk-reward scatter plot of the assets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatterFUN(R, FUN, arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatterFUN_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="scatterFUN_+3A_fun">FUN</code></td>
<td>
<p>name of function</p>
</td></tr>
<tr><td><code id="scatterFUN_+3A_arguments">arguments</code></td>
<td>
<p>named list of arguments to FUN</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='set.portfolio.moments'>Portfolio Moments</h2><span id='topic+set.portfolio.moments'></span><span id='topic+set.portfolio.moments_v2'></span>

<h3>Description</h3>

<p>Set portfolio moments for use by lower level optimization functions. Currently
three methods for setting the moments are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.portfolio.moments(
  R,
  portfolio,
  momentargs = NULL,
  method = c("sample", "boudt", "black_litterman", "meucci"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.portfolio.moments_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="set.portfolio.moments_+3A_portfolio">portfolio</code></td>
<td>
<p>an object of type &quot;portfolio&quot; specifying the constraints and objectives for the optimization, see <code><a href="#topic+portfolio.spec">portfolio.spec</a></code></p>
</td></tr>
<tr><td><code id="set.portfolio.moments_+3A_momentargs">momentargs</code></td>
<td>
<p>list containing arguments to be passed down to lower level functions, default NULL</p>
</td></tr>
<tr><td><code id="set.portfolio.moments_+3A_method">method</code></td>
<td>
<p>the method used to estimate portfolio moments. Valid choices include &quot;sample&quot;, &quot;boudt&quot;, and &quot;black_litterman&quot;.</p>
</td></tr>
<tr><td><code id="set.portfolio.moments_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>sample: </dt><dd><p>sample estimates are used for the moments</p>
</dd>
<dt>boudt: </dt><dd><p>estimate the second, third, and fourth moments using a 
statistical factor model based on the work of Kris Boudt.</p>
</dd>
</dl>
<p>See <code><a href="#topic+statistical.factor.model">statistical.factor.model</a></code>
</p>
<dl>
<dt>black_litterman: </dt><dd><p>estimate the first and second moments using the 
Black Litterman Formula. See <code><a href="#topic+black.litterman">black.litterman</a></code></p>
</dd></dl>
<p>.

</p>

<hr>
<h2 id='set.portfolio.moments_v1'>set portfolio moments for use by lower level optimization functions</h2><span id='topic+set.portfolio.moments_v1'></span>

<h3>Description</h3>

<p>set portfolio moments for use by lower level optimization functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.portfolio.moments_v1(R, constraints, momentargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.portfolio.moments_v1_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="set.portfolio.moments_v1_+3A_constraints">constraints</code></td>
<td>
<p>an object of type &quot;constraints&quot; specifying the constraints for the optimization, see <code><a href="#topic+constraint">constraint</a></code></p>
</td></tr>
<tr><td><code id="set.portfolio.moments_v1_+3A_momentargs">momentargs</code></td>
<td>
<p>list containing arguments to be passed down to lower level functions, default NULL</p>
</td></tr>
<tr><td><code id="set.portfolio.moments_v1_+3A_...">...</code></td>
<td>
<p>any other passthru parameters
FIXME NOTE: this isn't perfect as it overwrites the moments for all objectives, not just one with clean='boudt'</p>
</td></tr>
</table>

<hr>
<h2 id='statistical.factor.model'>Statistical Factor Model</h2><span id='topic+statistical.factor.model'></span>

<h3>Description</h3>

<p>Fit a statistical factor model using Principal Component Analysis (PCA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistical.factor.model(R, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statistical.factor.model_+3A_r">R</code></td>
<td>
<p>xts of asset returns</p>
</td></tr>
<tr><td><code id="statistical.factor.model_+3A_k">k</code></td>
<td>
<p>number of factors to use</p>
</td></tr>
<tr><td><code id="statistical.factor.model_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>prcomp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistical factor model is fitted using <code>prcomp</code>. The factor
loadings, factor realizations, and residuals are computed and returned
given the number of factors used for the model.
</p>


<h3>Value</h3>

<p>#' </p>

<dl>
<dt>factor_loadings</dt><dd><p> N x k matrix of factor loadings (i.e. betas)</p>
</dd>
<dt>factor_realizations</dt><dd><p> m x k matrix of factor realizations</p>
</dd>
<dt>residuals</dt><dd><p> m x N matrix of model residuals representing idiosyncratic 
risk factors</p>
</dd>
</dl>

<p>Where N is the number of assets, k is the number of factors, and m is the 
number of observations.
</p>

<hr>
<h2 id='summary.efficient.frontier'>Summarize an efficient frontier object</h2><span id='topic+summary.efficient.frontier'></span>

<h3>Description</h3>

<p>Summary method for efficient frontier objects. Display the call to create or
extract the efficient frontier object as well as the weights and risk and
return metrics along the efficient frontier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efficient.frontier'
summary(object, ..., digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.efficient.frontier_+3A_object">object</code></td>
<td>
<p>object of class <code>efficient.frontier</code></p>
</td></tr>
<tr><td><code id="summary.efficient.frontier_+3A_...">...</code></td>
<td>
<p>passthrough parameters</p>
</td></tr>
<tr><td><code id="summary.efficient.frontier_+3A_digits">digits</code></td>
<td>
<p>number of digits to round to</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='summary.optimize.portfolio'>Summarizing output of optimize.portfolio</h2><span id='topic+summary.optimize.portfolio'></span>

<h3>Description</h3>

<p>summary method for class <code>optimize.portfolio</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimize.portfolio'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.optimize.portfolio_+3A_object">object</code></td>
<td>
<p>an object of class <code>optimize.portfolio</code>.</p>
</td></tr>
<tr><td><code id="summary.optimize.portfolio_+3A_...">...</code></td>
<td>
<p>any other passthru parameters. Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimize.portfolio">optimize.portfolio</a></code>
</p>

<hr>
<h2 id='summary.optimize.portfolio.rebalancing'>summary method for optimize.portfolio.rebalancing</h2><span id='topic+summary.optimize.portfolio.rebalancing'></span>

<h3>Description</h3>

<p>summary method for optimize.portfolio.rebalancing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimize.portfolio.rebalancing'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.optimize.portfolio.rebalancing_+3A_object">object</code></td>
<td>
<p>object of type optimize.portfolio.rebalancing</p>
</td></tr>
<tr><td><code id="summary.optimize.portfolio.rebalancing_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>

<hr>
<h2 id='summary.portfolio'>Summarize Portfolio Specification Objects</h2><span id='topic+summary.portfolio'></span>

<h3>Description</h3>

<p>summary method for class <code>portfolio</code> created with <code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'portfolio'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.portfolio_+3A_object">object</code></td>
<td>
<p>an object of class <code>portfolio</code></p>
</td></tr>
<tr><td><code id="summary.portfolio_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>
</p>

<hr>
<h2 id='trailingFUN'>apply a function over a configurable trailing period</h2><span id='topic+trailingFUN'></span>

<h3>Description</h3>

<p>this function is primarily designed for use with portfolio functions passing 
'x' or 'R' and weights, but may be usable for other things as well, see Example for a vector example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trailingFUN(R, weights, n = 0, FUN, FUNargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trailingFUN_+3A_r">R</code></td>
<td>
<p>an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns</p>
</td></tr>
<tr><td><code id="trailingFUN_+3A_weights">weights</code></td>
<td>
<p>a vector of weights to test</p>
</td></tr>
<tr><td><code id="trailingFUN_+3A_n">n</code></td>
<td>
<p>numeric number of trailing periods</p>
</td></tr>
<tr><td><code id="trailingFUN_+3A_fun">FUN</code></td>
<td>
<p>string describing the function to be called</p>
</td></tr>
<tr><td><code id="trailingFUN_+3A_funargs">FUNargs</code></td>
<td>
<p>list describing any additional arguments</p>
</td></tr>
<tr><td><code id="trailingFUN_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>called with e.g.
</p>
<p>trailingFUN(seq(1:100), weights=NULL, n=12, FUN='mean',FUNargs=list())
</p>

<hr>
<h2 id='transaction_cost_constraint'>constructor for transaction_cost_constraint</h2><span id='topic+transaction_cost_constraint'></span>

<h3>Description</h3>

<p>The transaction cost constraint specifies a proportional cost value. 
This function is called by add.constraint when type=&quot;transaction_cost&quot; is specified, see <code><a href="#topic+add.constraint">add.constraint</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transaction_cost_constraint(
  type = "transaction_cost",
  assets,
  ptc,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transaction_cost_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="transaction_cost_constraint_+3A_assets">assets</code></td>
<td>
<p>number of assets, or optionally a named vector of assets specifying initial weights</p>
</td></tr>
<tr><td><code id="transaction_cost_constraint_+3A_ptc">ptc</code></td>
<td>
<p>proportional transaction cost value</p>
</td></tr>
<tr><td><code id="transaction_cost_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="transaction_cost_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="transaction_cost_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify box and/or group constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that with the ROI solvers, proportional transaction cost constraint is 
currently only supported for the global minimum variance and quadratic 
utility problems with ROI quadprog plugin.
</p>


<h3>Value</h3>

<p>an object of class 'transaction_cost_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="transaction_cost", ptc=0.01)
</code></pre>

<hr>
<h2 id='turnover'>Calculates turnover given two vectors of weights.
This is used as an objective function and is called when the user adds an objective of type turnover with <code><a href="#topic+add.objective">add.objective</a></code></h2><span id='topic+turnover'></span>

<h3>Description</h3>

<p>Calculates turnover given two vectors of weights.
This is used as an objective function and is called when the user adds an objective of type turnover with <code><a href="#topic+add.objective">add.objective</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover(weights, wts.init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turnover_+3A_weights">weights</code></td>
<td>
<p>vector of weights from optimization</p>
</td></tr>
<tr><td><code id="turnover_+3A_wts.init">wts.init</code></td>
<td>
<p>vector of initial weights used to calculate turnover from</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='turnover_constraint'>constructor for turnover_constraint</h2><span id='topic+turnover_constraint'></span>

<h3>Description</h3>

<p>The turnover constraint specifies a target turnover value. 
This function is called by add.constraint when type=&quot;turnover&quot; is specified, see <code><a href="#topic+add.constraint">add.constraint</a></code>.
Turnover is calculated from a set of initial weights. Turnover is 
computed as <code>sum(abs(initial_weights - weights)) / N</code> where <code>N</code> is
the number of assets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover_constraint(
  type = "turnover",
  turnover_target,
  enabled = TRUE,
  message = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turnover_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="turnover_constraint_+3A_turnover_target">turnover_target</code></td>
<td>
<p>target turnover value</p>
</td></tr>
<tr><td><code id="turnover_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="turnover_constraint_+3A_message">message</code></td>
<td>
<p>TRUE/FALSE. The default is message=FALSE. Display messages if TRUE.</p>
</td></tr>
<tr><td><code id="turnover_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify box and/or group constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that with the ROI solvers, turnover constraint is currently only 
supported for the global minimum variance and quadratic utility problems 
with ROI quadprog plugin.
</p>


<h3>Value</h3>

<p>an object of class 'turnover_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

pspec &lt;- add.constraint(portfolio=pspec, type="turnover", turnover_target=0.6)
</code></pre>

<hr>
<h2 id='turnover_objective'>constructor for class turnover_objective</h2><span id='topic+turnover_objective'></span>

<h3>Description</h3>

<p>if target is null, we'll try to minimize the turnover metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover_objective(
  name,
  target = NULL,
  arguments = NULL,
  multiplier = 1,
  enabled = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turnover_objective_+3A_name">name</code></td>
<td>
<p>name of the objective, should correspond to a function, though we will try to make allowances</p>
</td></tr>
<tr><td><code id="turnover_objective_+3A_target">target</code></td>
<td>
<p>univariate target for the objective</p>
</td></tr>
<tr><td><code id="turnover_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="turnover_objective_+3A_multiplier">multiplier</code></td>
<td>
<p>multiplier to apply to the objective, usually 1 or -1</p>
</td></tr>
<tr><td><code id="turnover_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="turnover_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if target is set, we'll try to meet the metric
</p>


<h3>Value</h3>

<p>an objective of class 'turnover_objective'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='update_constraint_v1tov2'>Helper function to update v1_constraint objects to v2 specification in the portfolio object</h2><span id='topic+update_constraint_v1tov2'></span>

<h3>Description</h3>

<p>The function takes the constraints and objectives specified in the v1_constraint
object and updates the portfolio object with those constraints and objectives. This
function is used inside optimize.portfolio to maintain backwards compatibility
if the user passes in a v1_constraint object for the constraint arg in
optimize.portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_constraint_v1tov2(portfolio, v1_constraint)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_constraint_v1tov2_+3A_portfolio">portfolio</code></td>
<td>
<p>portfolio object passed into optimize.portfolio</p>
</td></tr>
<tr><td><code id="update_constraint_v1tov2_+3A_v1_constraint">v1_constraint</code></td>
<td>
<p>object of type v1_constraint passed into optimize.portfolio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>portfolio object containing constraints and objectives from v1_constraint
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portfolio.spec">portfolio.spec</a></code>, <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>

<hr>
<h2 id='update.constraint'>function for updating constrints, not well tested, may be broken</h2><span id='topic+update.constraint'></span>

<h3>Description</h3>

<p>can we use the generic update.default function?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constraint'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.constraint_+3A_object">object</code></td>
<td>
<p>object of type <code><a href="#topic+constraint">constraint</a></code> to update</p>
</td></tr>
<tr><td><code id="update.constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters, used to call <code><a href="#topic+constraint">constraint</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>bpeterson
</p>

<hr>
<h2 id='var.portfolio'>Calculate portfolio variance</h2><span id='topic+var.portfolio'></span>

<h3>Description</h3>

<p>This function is used to calculate the portfolio variance via a call to 
constrained_objective when var is an object for mean variance or quadratic 
utility optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.portfolio(R, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.portfolio_+3A_r">R</code></td>
<td>
<p>xts object of asset returns</p>
</td></tr>
<tr><td><code id="var.portfolio_+3A_weights">weights</code></td>
<td>
<p>vector of asset weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the portfolio variance
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='weight_concentration_objective'>Constructor for weight concentration objective</h2><span id='topic+weight_concentration_objective'></span>

<h3>Description</h3>

<p>This function penalizes weight concentration using the Herfindahl-Hirschman Index
as a measure of concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_concentration_objective(
  name,
  conc_aversion,
  conc_groups = NULL,
  arguments = NULL,
  enabled = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weight_concentration_objective_+3A_name">name</code></td>
<td>
<p>name of concentration measure, currently only &quot;HHI&quot; is supported.</p>
</td></tr>
<tr><td><code id="weight_concentration_objective_+3A_conc_aversion">conc_aversion</code></td>
<td>
<p>concentration aversion value(s)</p>
</td></tr>
<tr><td><code id="weight_concentration_objective_+3A_conc_groups">conc_groups</code></td>
<td>
<p>list of vectors specifying the groups of the assets. Similar
to <code>groups</code> in <code><a href="#topic+group_constraint">group_constraint</a></code></p>
</td></tr>
<tr><td><code id="weight_concentration_objective_+3A_arguments">arguments</code></td>
<td>
<p>default arguments to be passed to an objective function when executed</p>
</td></tr>
<tr><td><code id="weight_concentration_objective_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="weight_concentration_objective_+3A_...">...</code></td>
<td>
<p>any other passthru parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>conc_aversion</code> argument can be a scalar or vector of concentration
aversion values. If <code>conc_aversion</code> is a scalar and <code>conc_groups</code> is
<code>NULL</code>, then the concentration aversion value will be applied to the overall
weights.
</p>
<p>If <code>conc_groups</code> is specified as an argument, then the concentration
aversion value(s) will be applied to each group.
</p>


<h3>Value</h3>

<p>an object of class 'weight_concentration_objective'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>

<hr>
<h2 id='weight_sum_constraint'>constructor for weight_sum_constraint</h2><span id='topic+weight_sum_constraint'></span>

<h3>Description</h3>

<p>The constraint specifies the upper and lower bound on the sum of the weights.
This function is called by add.constraint when &quot;weight_sum&quot;, &quot;leverage&quot;, &quot;full_investment&quot;, &quot;dollar_neutral&quot;, or &quot;active&quot; is specified as the type. see <code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_sum_constraint(
  type = "weight_sum",
  min_sum = 0.99,
  max_sum = 1.01,
  enabled = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weight_sum_constraint_+3A_type">type</code></td>
<td>
<p>character type of the constraint</p>
</td></tr>
<tr><td><code id="weight_sum_constraint_+3A_min_sum">min_sum</code></td>
<td>
<p>minimum sum of all asset weights, default 0.99</p>
</td></tr>
<tr><td><code id="weight_sum_constraint_+3A_max_sum">max_sum</code></td>
<td>
<p>maximum sum of all asset weights, default 1.01</p>
</td></tr>
<tr><td><code id="weight_sum_constraint_+3A_enabled">enabled</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="weight_sum_constraint_+3A_...">...</code></td>
<td>
<p>any other passthru parameters to specify weight_sum constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Special cases for the weight_sum constraint are &quot;full_investment&quot; and &quot;dollar_nuetral&quot; or &quot;active&quot;
</p>
<p>If <code>type="full_investment"</code>, <code>min_sum=1</code> and <code>max_sum=1</code>
</p>
<p>If <code>type="dollar_neutral"</code> or <code>type="active"</code>, <code>min_sum=0</code>, and <code>max_sum=0</code>
</p>


<h3>Value</h3>

<p>an object of class 'weight_sum_constraint'
</p>


<h3>Author(s)</h3>

<p>Ross Bennett
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(edhec)
ret &lt;- edhec[, 1:4]

pspec &lt;- portfolio.spec(assets=colnames(ret))

# min_sum and max_sum can be specified with type="weight_sum" or type="leverage"
pspec &lt;- add.constraint(pspec, type="weight_sum", min_sum=1, max_sum=1)

# Specify type="full_investment" to set min_sum=1 and max_sum=1
pspec &lt;- add.constraint(pspec, type="full_investment")

# Specify type="dollar_neutral" or type="active" to set min_sum=0 and max_sum=0
pspec &lt;- add.constraint(pspec, type="dollar_neutral")
pspec &lt;- add.constraint(pspec, type="active")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
