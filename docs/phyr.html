<!DOCTYPE html><html><head><title>Help for package phyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25nin+25'><p>Not in</p></a></li>
<li><a href='#align_comm_V'><p>Create phylogenetic var-cov matrix based on phylogeny and community data</p></a></li>
<li><a href='#boot_ci'><p>Generic method to output bootstrap confidence intervals from an object.</p></a></li>
<li><a href='#comm_a'><p>Example community data</p></a></li>
<li><a href='#comm_b'><p>Example community data</p></a></li>
<li><a href='#cor_phylo'><p>Correlations among multiple variates with phylogenetic signal</p></a></li>
<li><a href='#envi'><p>Example environmental data</p></a></li>
<li><a href='#family.communityPGLMM'><p>Family Objects for communityPGLMM objects</p></a></li>
<li><a href='#fitted.communityPGLMM'><p>Fitted values for communityPGLMM</p></a></li>
<li><a href='#fixef'><p>Extract fixed-effects estimates</p></a></li>
<li><a href='#get_design_matrix'><p><code>get_design_matrix</code> gets design matrix for gaussian, binomial, and poisson models</p></a></li>
<li><a href='#match_comm_tree'><p>Match phylogeny with community data</p></a></li>
<li><a href='#model.frame.communityPGLMM'><p>Extracting the Model Frame from a communityPGLMM Model</p>
object</a></li>
<li><a href='#nobs.communityPGLMM'><p>Number of Observation in a communityPGLMM Model</p></a></li>
<li><a href='#oldfield'><p>Phylogeny and community data from an Oldfield ecosystem in Southern Ontario, Canada</p></a></li>
<li><a href='#pcd'><p>pairwise site phylogenetic community dissimilarity (PCD) within a community</p></a></li>
<li><a href='#pcd_pred'><p>Predicted PCD with species pool</p></a></li>
<li><a href='#pglmm'><p>Phylogenetic Generalized Linear Mixed Model for Community Data</p></a></li>
<li><a href='#pglmm_compare'><p>Phylogenetic Generalized Linear Mixed Model for Comparative Data</p></a></li>
<li><a href='#pglmm_matrix_structure'><p><code>pglmm_matrix_structure</code> produces the entire</p>
covariance matrix structure (V) when you specify random effects.</a></li>
<li><a href='#pglmm_plot_ranef'><p>Visualize random terms of communityPGLMMs</p></a></li>
<li><a href='#pglmm_predicted_values'><p>Predicted values of PGLMM</p></a></li>
<li><a href='#pglmm_profile_LRT'><p><code>pglmm_profile_LRT</code> tests statistical significance of the</p>
phylogenetic random effect of binomial models on
species slopes using a likelihood ratio test.</a></li>
<li><a href='#phylotree'><p>Example phylogeny</p></a></li>
<li><a href='#plot_bayes'><p>plot_bayes generic</p></a></li>
<li><a href='#plot_data'><p>Plot the original dataset and predicted values (optional)</p></a></li>
<li><a href='#predict.communityPGLMM'><p>Predict Function for communityPGLMM Model Objects</p></a></li>
<li><a href='#prep_dat_pglmm'><p>Prepare data for <code>pglmm</code></p></a></li>
<li><a href='#print.communityPGLMM'><p>Print summary information of fitted model</p></a></li>
<li><a href='#print.pglmm_compare'><p>Print summary information of fitted model</p></a></li>
<li><a href='#psv'><p>Phylogenetic Species Diversity Metrics</p></a></li>
<li><a href='#ranef'><p>Extract random-effects estimates</p></a></li>
<li><a href='#refit_boots'><p>Refit bootstrap replicates that failed to converge in a call to <code>cor_phylo</code></p></a></li>
<li><a href='#residuals.communityPGLMM'><p>Residuals of communityPGLMM objects</p></a></li>
<li><a href='#rm_site_noobs'><p>Remove site that has no observations of any species</p></a></li>
<li><a href='#rm_sp_noobs'><p>Remove species that not observed in any site</p></a></li>
<li><a href='#simulate.communityPGLMM'><p>Simulate from a communityPGLMM object</p></a></li>
<li><a href='#summary.communityPGLMM'><p>Summary information of fitted model</p></a></li>
<li><a href='#summary.pglmm_compare'><p>Summary information of fitted pglmm_compare model</p></a></li>
<li><a href='#traits'><p>Example species traits data</p></a></li>
<li><a href='#vcv2'><p>Create phylogenetic var-cov matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Based Phylogenetic Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to do model-based phylogenetic analysis. 
    It includes functions to calculate community phylogenetic diversity,
    to estimate correlations among functional traits while accounting for 
    phylogenetic relationships, and to fit phylogenetic generalized linear
    mixed models. The Bayesian phylogenetic generalized linear mixed models
    are fitted with the 'INLA' package (<a href="https://www.r-inla.org">https://www.r-inla.org</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ape, Rcpp, Matrix, methods, graphics, dplyr, lme4,
nloptr, gridExtra, mvtnorm, latticeExtra, tidyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, pez, knitr, rmarkdown, covr, picante, rbenchmark,
INLA, MCMCglmm, logistf, phylolm, ggplot2, ggridges, DHARMa,
rr2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://daijiang.github.io/phyr/">https://daijiang.github.io/phyr/</a>,
<a href="https://github.com/daijiang/phyr/">https://github.com/daijiang/phyr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daijiang/phyr/issues">https://github.com/daijiang/phyr/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-18 04:35:45 UTC; dli</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Ives [aut],
  Russell Dinnage <a href="https://orcid.org/0000-0003-0846-2819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lucas A. Nell <a href="https://orcid.org/0000-0003-3209-0517"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Matthew Helmus [aut],
  Daijiang Li <a href="https://orcid.org/0000-0002-0925-3421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daijiang Li &lt;daijianglee@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-18 07:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25nin+25'>Not in</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p>This function will return elements of x not in y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %nin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25nin+2B25_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="+2B25nin+2B25_+3A_y">y</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='align_comm_V'>Create phylogenetic var-cov matrix based on phylogeny and community data</h2><span id='topic+align_comm_V'></span>

<h3>Description</h3>

<p>This function will remove species from community data that are not in the phylogeny.
It will also remove tips from the phylogeny that are not in the community data. And
then convert the phylogeny to a Var-cov matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_comm_V(comm, tree, prune.tree = FALSE, scale.vcv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_comm_V_+3A_comm">comm</code></td>
<td>
<p>A site by species data frame, with site names as row names.</p>
</td></tr>
<tr><td><code id="align_comm_V_+3A_tree">tree</code></td>
<td>
<p>A phylogeny with &quot;phylo&quot; as class; or a phylogenetic var-covar matrix.</p>
</td></tr>
<tr><td><code id="align_comm_V_+3A_prune.tree">prune.tree</code></td>
<td>
<p>Whether to prune the tree first then use vcv.phylo function. Default
is FALSE: use vcv.phylo first then subsetting the matrix.</p>
</td></tr>
<tr><td><code id="align_comm_V_+3A_scale.vcv">scale.vcv</code></td>
<td>
<p>Whether to scale vcv to a correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the community data and the phylogenetic var-cov matrix.
</p>

<hr>
<h2 id='boot_ci'>Generic method to output bootstrap confidence intervals from an object.</h2><span id='topic+boot_ci'></span>

<h3>Description</h3>

<p>Implemented only for <code>cor_phylo</code> objects thus far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ci(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ci_+3A_mod">mod</code></td>
<td>
<p>A <code>cor_phylo</code> object.</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of confidence intervals.
</p>

<hr>
<h2 id='comm_a'>Example community data</h2><span id='topic+comm_a'></span>

<h3>Description</h3>

<p>A data frame with site names as row names, species names as column names,
cells are the abundance of each species at each site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm_a
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 sites and 15 species.
</p>

<hr>
<h2 id='comm_b'>Example community data</h2><span id='topic+comm_b'></span>

<h3>Description</h3>

<p>A data frame with site names as row names, species names as column names,
cells are the abundance of each species at each site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm_b
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 sites and 9 species.
</p>

<hr>
<h2 id='cor_phylo'>Correlations among multiple variates with phylogenetic signal</h2><span id='topic+cor_phylo'></span><span id='topic+boot_ci.cor_phylo'></span><span id='topic+print.cor_phylo'></span>

<h3>Description</h3>

<p>This function calculates Pearson correlation coefficients for multiple continuous
variates that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of variate values at the tips of the phylogenetic tree.
Phylogenetic signal for each variate is estimated from the data assuming that variate
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple variates while incorporating
correlations among variates. It is also possible to include independent variables
(covariates) for each variate to remove possible confounding effects.
<code>cor_phylo</code> returns the correlation matrix for variate values, estimates
of phylogenetic signal for each variate, and regression coefficients for
independent variables affecting each variate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_phylo(variates, species, phy,
          covariates = NULL, 
          meas_errors = NULL,
          data = sys.frame(sys.parent()),
          REML = TRUE, 
          method = c("nelder-mead-r", "bobyqa",
              "subplex", "nelder-mead-nlopt", "sann"),
          no_corr = FALSE,
          constrain_d = FALSE,
          lower_d = 1e-7,
          rel_tol = 1e-6,
          max_iter = 1000,
          sann_options = NULL,
          verbose = FALSE,
          rcond_threshold = 1e-10,
          boot = 0,
          keep_boots = c("fail", "none", "all"))

## S3 method for class 'cor_phylo'
boot_ci(mod, refits = NULL, alpha = 0.05, ...)

## S3 method for class 'cor_phylo'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_phylo_+3A_variates">variates</code></td>
<td>
<p>A formula or a matrix specifying variates between which correlations
are being calculated.
The formula should be one-sided of the form <code>~ A + B + C</code> for variate vectors
<code>A</code>, <code>B</code>, and <code>C</code> that are present in <code>data</code>.
In the matrix case, the matrix must have <code>n</code> rows and <code>p</code> columns (for <code>p</code> variates);
if the matrix columns aren't named, <code>cor_phylo</code> will name them <code style="white-space: pre;">&#8288;par_1 ... par_p&#8288;</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_species">species</code></td>
<td>
<p>A one-sided formula implicating the variable inside <code>data</code>
representing species, or a vector directly specifying the species.
If a formula, it must be of the form <code>~ spp</code> for the <code>spp</code> object containing
the species information inside <code>data</code>.
If a vector, it must be the same length as that of the tip labels in <code>phy</code>,
and it will be coerced to a character vector like <code>phy</code>'s tip labels.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_phy">phy</code></td>
<td>
<p>Either a phylogeny of class <code>phylo</code> or a prepared variance-covariance
matrix.
If it is a phylogeny, we will coerce tip labels to a character vector, and
convert it to a variance-covariance matrix assuming brownian motion evolution.
We will also standardize all var-cov matrices to have determinant of one.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_covariates">covariates</code></td>
<td>
<p>A list specifying covariate(s) for each variate.
The list can contain only two-sided formulas or matrices.
Formulas should be of the typical form: <code>y ~ x1 + x2</code> or <code>y ~ x1 * x2</code>.
If using a list of matrices, each item must be named (e.g.,
<code>list(y = matrix(...))</code> specifying variate <code>y</code>'s covariates).
If the matrix columns aren't named, <code>cor_phylo</code> will name them <code style="white-space: pre;">&#8288;cov_1 ... cov_q&#8288;</code>,
where <code>q</code> is the total number of covariates for all variates.
Having factor covariates is not supported.
Defaults to <code>NULL</code>, which indicates no covariates.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_meas_errors">meas_errors</code></td>
<td>
<p>A list or matrix containing standard errors for each variate.
If a list, it must contain only two-sided formulas like those for <code>covariates</code>
(except that you can't have multiple measurement errors for a single variate).
You can additionally pass an <code>n</code>-row matrix with column names
corresponding to the associated variate names.
Defaults to <code>NULL</code>, which indicates no measurement errors.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_data">data</code></td>
<td>
<p>An optional data frame, list, or environment that contains the
variables in the model. By default, variables are taken from the environment
from which <code>cor_phylo</code> was called.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_reml">REML</code></td>
<td>
<p>Whether REML (versus ML) should be used for model fitting.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_method">method</code></td>
<td>
<p>Method of optimization using <code>nlopt</code> or <code><a href="stats.html#topic+optim">optim</a></code>.
Options include <code>"nelder-mead-nlopt"</code>, <code>"bobyqa"</code>, <code>"subplex"</code>, <code>"nelder-mead-r"</code>,
and <code>"sann"</code>.
The first three are carried out by <code>nlopt</code>, and the latter two by
<code><a href="stats.html#topic+optim">optim</a></code>.
See <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/</a> for information
on the <code>nlopt</code> algorithms.
Defaults to <code>"nelder-mead-r"</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_no_corr">no_corr</code></td>
<td>
<p>A single logical for whether to make all correlations zero.
Running <code>cor_phylo</code> with <code>no_corr = TRUE</code> is useful for comparing it to the same
model run with correlations != 0.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_constrain_d">constrain_d</code></td>
<td>
<p>If <code>constrain_d</code> is <code>TRUE</code>, the estimates of <code>d</code> are
constrained to be between zero and 1. This can make estimation more stable and
can be tried if convergence is problematic. This does not necessarily lead to
loss of generality of the results, because before using <code>cor_phylo</code>,
branch lengths of <code>phy</code> can be transformed so that the &quot;starter&quot; tree
has strong phylogenetic signal.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_lower_d">lower_d</code></td>
<td>
<p>Lower bound on the phylogenetic signal parameter.
Defaults to <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_rel_tol">rel_tol</code></td>
<td>
<p>A control parameter dictating the relative tolerance for convergence
in the optimization. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_max_iter">max_iter</code></td>
<td>
<p>A control parameter dictating the maximum number of iterations
in the optimization. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_sann_options">sann_options</code></td>
<td>
<p>A named list containing the control parameters for SANN
minimization.
This is only relevant if <code>method == "sann"</code>.
This list can only contain the names <code>"maxit"</code>, <code>"temp"</code>, and/or <code>"tmax"</code>,
which will control the maximum number of iterations,
starting temperature, and number of function evaluations at each temperature,
respectively.
Defaults to <code>NULL</code>, which results in <code>maxit = 1000</code>, <code>temp = 1</code>, and <code>tmax = 1</code>.
Note that these are different from the defaults for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, the model <code>logLik</code> and running estimates of the
correlation coefficients and values of <code>d</code> are printed each iteration
during optimization. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_rcond_threshold">rcond_threshold</code></td>
<td>
<p>Threshold for the reciprocal condition number of two
matrices inside the log likelihood function.
Increasing this threshold makes the optimization process more strongly
&quot;bounce away&quot; from badly conditioned matrices and can help with convergence
and with estimates that are nonsensical.
Defaults to <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_boot">boot</code></td>
<td>
<p>Number of parametric bootstrap replicates. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_keep_boots">keep_boots</code></td>
<td>
<p>Character specifying when to output data (indices, convergence codes,
and simulated variate data) from bootstrap replicates.
This is useful for troubleshooting when one or more bootstrap replicates
fails to converge or outputs ridiculous results.
Setting this to <code>"all"</code> keeps all <code>boot</code> parameter sets,
<code>"fail"</code> keeps parameter sets from replicates that failed to converge,
and <code>"none"</code> keeps no parameter sets.
Defaults to <code>"fail"</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_mod">mod</code></td>
<td>
<p><code>cor_phylo</code> object that was run with the <code>boot</code> argument &gt; 0.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_refits">refits</code></td>
<td>
<p>One or more <code>cp_refits</code> objects containing refits of <code>cor_phylo</code>
bootstrap replicates. These are used when the original fit did not converge.
Multiple <code>cp_refits</code> objects should be input as a list.
For a given bootstrap replicate, the original fit's estimates will be used
when the fit converged.
If multiple <code>cp_refits</code> objects are input and more than one converged for a given
replicate, the estimates from the first <code>cp_refits</code> object contain a converged
fit for that replicate will be used.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_alpha">alpha</code></td>
<td>
<p>Alpha used for the confidence intervals. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_...">...</code></td>
<td>
<p>arguments passed to and from other methods.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_x">x</code></td>
<td>
<p>an object of class <code>cor_phylo</code>.</p>
</td></tr>
<tr><td><code id="cor_phylo_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cor_phylo</code> returns an object of class <code>cor_phylo</code>:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>corrs</code></td>
<td>
<p>The <code>p</code> x <code>p</code> matrix of correlation coefficients.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Values of <code>d</code> from the OU process for each variate.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A matrix of regression-coefficient estimates, SE, Z-scores, and P-values,
respectively. Rownames indicate which coefficient it refers to.</p>
</td></tr>
<tr><td><code>B_cov</code></td>
<td>
<p>Covariance matrix for regression coefficients.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log likelihood for either the restricted likelihood
(<code>REML = TRUE</code>) or the overall likelihood (<code>REML = FALSE</code>).</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC for either the restricted likelihood (<code>REML = TRUE</code>) or the
overall likelihood (<code>REML = FALSE</code>).</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>BIC for either the restricted likelihood (<code>REML = TRUE</code>) or the
overall likelihood (<code>REML = FALSE</code>).</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations the optimizer used.</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p>Conversion code for the optimizer.
This number is <code>0</code> on success and positive on failure.
</p>

<dl>
<dt>1</dt><dd><p>iteration limit reached</p>
</dd>
<dt>2</dt><dd><p>generic failure code (nlopt optimizers only).</p>
</dd>
<dt>3</dt><dd><p>invalid arguments (nlopt optimizers only).</p>
</dd>
<dt>4</dt><dd><p>out of memory (nlopt optimizers only).</p>
</dd>
<dt>5</dt><dd><p>roundoff errors limited progress (nlopt optimizers only).</p>
</dd>
<dt>6</dt><dd><p>user-forced termination (nlopt optimizers only).</p>
</dd>
<dt>10</dt><dd><p>degeneracy of the Nelder-Mead simplex (<code>stats::optim</code> only).</p>
</dd>
</dl>

<p>For more information on the nlopt return codes, see
<a href="https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values">https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</a>.</p>
</td></tr>
<tr><td><code>rcond_vals</code></td>
<td>
<p>Reciprocal condition numbers for two matrices inside
the log likelihood function. These are provided to potentially help guide
the changing of the <code>rcond_threshold</code> parameter.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>A list of bootstrap output, which is simply <code>list()</code> if
<code>boot = 0</code>. If <code>boot &gt; 0</code>, then the list contains fields for
estimates of correlations (<code>corrs</code>), phylogenetic signals (<code>d</code>),
coefficients (<code>B0</code>), and coefficient covariances (<code>B_cov</code>).
It also contains the following information about the bootstrap replicates:
a vector of indices relating each set of information to the bootstrapped
estimates (<code>inds</code>),
convergence codes (<code>convcodes</code>), and
matrices of the bootstrapped parameters in the order they appear in the input
argument (<code>mats</code>);
these three fields will be empty if <code>keep_boots == "none"</code>.
To view bootstrapped confidence intervals, use <code>boot_ci</code>.</p>
</td></tr>
</table>
<p><code>boot_ci</code> returns a list of confidence intervals with the following fields:
</p>

<dl>
<dt><code>corrs</code></dt><dd>
<p>Estimates of correlations.
This is a matrix the values above the diagonal being the
upper limits and values below being the lower limits.</p>
</dd>
<dt><code>d</code></dt><dd><p>Phylogenetic signals.</p>
</dd>
<dt><code>B0</code></dt><dd><p>Coefficient estimates.</p>
</dd>
<dt><code>B_cov</code></dt><dd><p>Coefficient covariances.</p>
</dd>
</dl>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>boot_ci</code>: returns bootstrapped confidence intervals from a <code>cor_phylo</code> object
</p>
</li>
<li> <p><code>print</code>: prints <code>cor_phylo</code> objects
</p>
</li></ul>


<h3>Walkthrough</h3>

<p>For the case of two variables, the function estimates parameters for the model of
the form, for example,
</p>
<p style="text-align: center;"><code class="reqn">X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]</code>
</p>

<p style="text-align: center;"><code class="reqn">X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ Gaussian(0, V) </code>
</p>

<p>where <code class="reqn">B[1,0]</code>, <code class="reqn">B[1,1]</code>, <code class="reqn">B[2,0]</code>, and <code class="reqn">B[2,1]</code> are regression
coefficients, and <code class="reqn">V</code> is a variance-covariance matrix containing the correlation
coefficient r, parameters of the OU process <code class="reqn">d1</code> and <code class="reqn">d2</code>, and diagonal
matrices <code class="reqn">M1</code> and <code class="reqn">M2</code> of measurement standard errors for <code class="reqn">X[1]</code> and
<code class="reqn">X[2]</code>. The matrix <code class="reqn">V</code> is <code class="reqn">2n x 2n</code>, with <code class="reqn">n x n</code> blocks given by
</p>
<p style="text-align: center;"><code class="reqn">V[1,1] = C[1,1](d1) + M1</code>
</p>

<p style="text-align: center;"><code class="reqn">V[1,2] = C[1,2](d1,d2)</code>
</p>

<p style="text-align: center;"><code class="reqn">V[2,1] = C[2,1](d1,d2)</code>
</p>

<p style="text-align: center;"><code class="reqn">V[2,2] = C[2,2](d2) + M2</code>
</p>

<p>where <code class="reqn">C[i,j](d1,d2)</code> are derived from <code>phy</code> under the assumption of joint
OU evolutionary processes for each variate (see Zheng et al. 2009). This formulation
extends in the obvious way to more than two variates.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives, Lucas A. Nell
</p>


<h3>References</h3>

<p>Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao.
2009. New multivariate tests for phylogenetic signal and trait correlations
applied to ecophysiological phenotypes of nine <em>Manglietia</em> species.
<em>Functional Ecology</em> <b>23</b>:1059&ndash;1069.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# 
# ## Simple example using data without correlations or phylogenetic
# ## signal. This illustrates the structure of the input data.
# 
# set.seed(10)
# phy &lt;- ape::rcoal(10, tip.label = 1:10)
# data_df &lt;- data.frame(
#     species = phy$tip.label,
#     # variates:
#     par1 = rnorm(10),
#     par2 = rnorm(10),
#     par3 = rnorm(10),
#     # covariate for par2:
#     cov2 = rnorm(10, mean = 10, sd = 4),
#     # measurement error for par1 and par2, respectively:
#     se1 = 0.2,
#     se2 = 0.4
# )
# data_df$par2 &lt;- data_df$par2 + 0.5 * data_df$cov2
# 
# 
# # cor_phylo(variates = ~ par1 + par2 + par3,
# #           covariates = list(par2 ~ cov2),
# #           meas_errors = list(par1 ~ se1, par2 ~ se2),
# #           species = ~ species,
# #           phy = phy,
# #           data = data_df)
# 
# # If you've already created matrices/lists...
# X &lt;- as.matrix(data_df[,c("par1", "par2", "par3")])
# U &lt;- list(par2 = cbind(cov2 = data_df$cov2))
# M &lt;- cbind(par1 = data_df$se1, par2 = data_df$se2)
# 
# # ... you can also use those directly
# # (notice that I'm inputting an object for `species`
# # bc I ommitted `data`):
# # cor_phylo(variates = X, species = data_df$species,
# #           phy = phy, covariates = U,
# #           meas_errors = M)
# 
# 
# 
# 
# ## Simulation example for the correlation between two variables. The example
# ## compares the estimates of the correlation coefficients from cor_phylo when
# ## measurement error is incorporated into the analyses with three other cases:
# ## (i) when measurement error is excluded, (ii) when phylogenetic signal is
# ## ignored (assuming a "star" phylogeny), and (iii) neither measurement error
# ## nor phylogenetic signal are included.
# 
# # In the simulations, variable 2 is associated with a single independent variable.
# 
# library(ape)
# 
# set.seed(1)
# # Set up parameter values for simulating data
# n &lt;- 50
# phy &lt;- rcoal(n, tip.label = 1:n)
# trt_names &lt;- paste0("par", 1:2)
# 
# R &lt;- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
# d &lt;- c(0.3, 0.95)
# B2 &lt;- 1
# 
# Se &lt;- c(0.2, 1)
# M &lt;- matrix(Se, nrow = n, ncol = 2, byrow = TRUE)
# colnames(M) &lt;- trt_names
# 
# # Set up needed matrices for the simulations
# p &lt;- length(d)
# 
# star &lt;- stree(n)
# star$edge.length &lt;- array(1, dim = c(n, 1))
# star$tip.label &lt;- phy$tip.label
# 
# Vphy &lt;- vcv(phy)
# Vphy &lt;- Vphy/max(Vphy)
# Vphy &lt;- Vphy/exp(determinant(Vphy)$modulus[1]/n)
# 
# tau &lt;- matrix(1, nrow = n, ncol = 1) %*% diag(Vphy) - Vphy
# C &lt;- matrix(0, nrow = p * n, ncol = p * n)
# for (i in 1:p) for (j in 1:p) {
#   Cd &lt;- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
#   C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] &lt;- R[i, j] * Cd
# }
# MM &lt;- matrix(M^2, ncol = 1)
# V &lt;- C + diag(as.numeric(MM))
# 
# # Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic
# # signal: a vector of independent normal random variables, when multiplied by the
# # transpose of the Cholesky deposition of Vphy will have covariance matrix
# # equal to Vphy.
# iD &lt;- t(chol(V))
# 
# # Perform Nrep simulations and collect the results
# Nrep &lt;- 100
# cor.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
# cor.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
# cor.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
# cor.noMP.list &lt;- matrix(0, nrow = Nrep, ncol = 1)
# d.list &lt;- matrix(0, nrow = Nrep, ncol = 2)
# d.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 2)
# B.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
# B.noM.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
# B.noP.list &lt;- matrix(0, nrow = Nrep, ncol = 3)
# 
# 
# set.seed(2)
# for (rep in 1:Nrep) {
# 
#   XX &lt;- iD %*% rnorm(2 * n)
#   X &lt;- matrix(XX, n, p)
#   colnames(X) &lt;- trt_names
# 
#   U &lt;- list(cbind(rnorm(n, mean = 2, sd = 10)))
#   names(U) &lt;- trt_names[2]
# 
#   X[,2] &lt;- X[,2] + B2[1] * U[[1]][,1] - B2[1] * mean(U[[1]][,1])
# 
#   # Call cor_phylo with (i) phylogeny and measurement error,
#   # (ii) just phylogeny,
#   # and (iii) just measurement error
#   z &lt;- cor_phylo(variates = X,
#                  covariates = U,
#                  meas_errors = M,
#                  phy = phy,
#                  species = phy$tip.label)
#   z.noM &lt;- cor_phylo(variates = X,
#                      covariates = U,
#                      phy = phy,
#                      species = phy$tip.label)
#   z.noP &lt;- cor_phylo(variates = X,
#                      covariates = U,
#                      meas_errors = M,
#                      phy = star,
#                      species = phy$tip.label)
# 
#   cor.list[rep] &lt;- z$corrs[1, 2]
#   cor.noM.list[rep] &lt;- z.noM$corrs[1, 2]
#   cor.noP.list[rep] &lt;- z.noP$corrs[1, 2]
#   cor.noMP.list[rep] &lt;- cor(cbind(
#     lm(X[,1] ~ 1)$residuals,
#     lm(X[,2] ~ U[[1]])$residuals))[1,2]
# 
#   d.list[rep, ] &lt;- z$d
#   d.noM.list[rep, ] &lt;- z.noM$d
# 
#   B.list[rep, ] &lt;- z$B[,1]
#   B.noM.list[rep, ] &lt;- z.noM$B[,1]
#   B.noP.list[rep, ] &lt;- z.noP$B[,1]
# }
# 
# correlation &lt;- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
#                      mean(cor.noP.list), mean(cor.noMP.list))
# rownames(correlation) &lt;- c("True", "With M and Phy", "Without M",
#                            "Without Phy", "Without Phy or M")
# 
# signal.d &lt;- rbind(d, colMeans(d.list), colMeans(d.noM.list))
# rownames(signal.d) &lt;- c("True", "With M and Phy", "Without M")
# 
# est.B &lt;- rbind(c(0, 0, B2), colMeans(B.list),
#                colMeans(B.noM.list[-39,]),  # 39th rep didn't converge
#                colMeans(B.noP.list))
# rownames(est.B) &lt;- c("True", "With M and Phy", "Without M", "Without Phy")
# colnames(est.B) &lt;- rownames(z$B)
# 
# # Example simulation output:
# 
# correlation
# #                       [,1]
# # True             0.7000000
# # With M and Phy   0.6943712
# # Without M        0.2974162
# # Without Phy      0.3715406
# # Without Phy or M 0.3291473
# 
# signal.d
# #                     [,1]      [,2]
# # True           0.3000000 0.9500000
# # With M and Phy 0.3025853 0.9422067
# # Without M      0.2304527 0.4180208
# 
# est.B
# #                      par1_0    par2_0 par2_cov_1
# # True            0.000000000 0.0000000  1.0000000
# # With M and Phy -0.008838245 0.1093819  0.9995058
# # Without M      -0.008240453 0.1142330  0.9995625
# # Without Phy     0.002933341 0.1096578  1.0028474




</code></pre>

<hr>
<h2 id='envi'>Example environmental data</h2><span id='topic+envi'></span>

<h3>Description</h3>

<p>A data frame of site environmental variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envi
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 sites and 4 variables: sand proportion,
canopy shade proportion, precipitation, and minimum temperature.
</p>

<hr>
<h2 id='family.communityPGLMM'>Family Objects for communityPGLMM objects</h2><span id='topic+family.communityPGLMM'></span>

<h3>Description</h3>

<p>Family Objects for communityPGLMM objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.communityPGLMM_+3A_object">object</code></td>
<td>
<p>the function <code>family</code> accesses the <code>family</code>
objects which are stored within objects created by modelling
functions (e.g., <code>glm</code>).</p>
</td></tr>
<tr><td><code id="family.communityPGLMM_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='fitted.communityPGLMM'>Fitted values for communityPGLMM</h2><span id='topic+fitted.communityPGLMM'></span>

<h3>Description</h3>

<p>Fitted values for communityPGLMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.communityPGLMM_+3A_object">object</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="fitted.communityPGLMM_+3A_...">...</code></td>
<td>
<p>Additional arguments, ignored for method compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values. For binomial and poisson PGLMMs, this is equal to mu.
</p>

<hr>
<h2 id='fixef'>Extract fixed-effects estimates</h2><span id='topic+fixef'></span><span id='topic+fixef.communityPGLMM'></span><span id='topic+fixed.effects'></span>

<h3>Description</h3>

<p>Extract the fixed-effects estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="fixef_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the fixed-effects parameters from a fitted model.
For bayesian models, the p-values are simply to indicate whether the
credible intervals include 0 (p = 0.04) or not (p = 0.6).
</p>


<h3>Value</h3>

<p>A dataframe of fixed-effects estimates.
</p>

<hr>
<h2 id='get_design_matrix'><code>get_design_matrix</code> gets design matrix for gaussian, binomial, and poisson models</h2><span id='topic+get_design_matrix'></span>

<h3>Description</h3>

<p><code>get_design_matrix</code> gets design matrix for gaussian, binomial, and poisson models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_design_matrix(formula, data, random.effects, na.action = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_design_matrix_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
mixed effects of the model.
</p>
<p>To specify that a random term should have phylogenetic covariance matrix along
with non-phylogenetic one, add <code>__</code> (two underscores) at the end of the group variable;
e.g., <code>+ (1 | sp__)</code> will construct two random terms,
one with phylogenetic covariance matrix and another with non-phylogenetic (identity) matrix.
In contrast, <code>__</code> in the nested terms (below) will only create a phylogenetic covariance matrix.
Nested random terms have the general form <code>(1|sp__@site__)</code> which represents
phylogenetically related species nested within correlated sites.
This form can be used for bipartite questions. For example, species could be
phylogenetically related pollinators and sites could be phylogenetically related plants, leading to
the random effect <code>(1|insects__@plants__)</code>. If more than one phylogeny is used, remember to add
all to the argument <code>cov_ranef = list(insects = insect_phylo, plants = plant_phylo)</code>. Phylogenetic correlations can
be dropped by removing the <code>__</code> underscores. Thus, the form <code>(1|sp@site__)</code> excludes the phylogenetic
correlations among species, while the form <code>(1|sp__@site)</code> excludes the correlations among sites.
</p>
<p>Note that correlated random terms are not allowed. For example,
<code>(x|g)</code> will be the same as <code>(0 + x|g)</code> in the <code>lme4::lmer</code> syntax. However,
<code>(x1 + x2|g)</code> won't work, so instead use  <code>(x1|g) + (x2|g)</code>.</p>
</td></tr>
<tr><td><code id="get_design_matrix_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="get_design_matrix_+3A_random.effects">random.effects</code></td>
<td>
<p>Optional pre-build list of random effects. If <code>NULL</code> (the default),
the function <code><a href="#topic+prep_dat_pglmm">prep_dat_pglmm</a></code> will prepare the random effects for you from the information
in <code>formula</code>, <code>data</code>, and <code>cov_ranef</code>. <code>random.effect</code> allows a list of
pre-generated random effects terms to increase flexibility; for example, this makes it
possible to construct models with both phylogenetic correlation and spatio-temporal autocorrelation.
In preparing <code>random.effect</code>, make sure that the orders of rows and columns of
covariance matrices in the list are the same as their corresponding group variables
in the data. Also, this should be <em>a list of lists</em>, e.g.
<code>random.effects = list(re1 = list(matrix_a), re2 = list(1, sp = sp, covar = Vsp))</code>.</p>
</td></tr>
<tr><td><code id="get_design_matrix_+3A_na.action">na.action</code></td>
<td>
<p>What to do with NAs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of design matrices.
</p>

<hr>
<h2 id='match_comm_tree'>Match phylogeny with community data</h2><span id='topic+match_comm_tree'></span>

<h3>Description</h3>

<p>This function will remove species from community data that are not in the phylogeny.
It will also remove tips from the phylogeny that are not in the community data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_comm_tree(comm, tree, comm_2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_comm_tree_+3A_comm">comm</code></td>
<td>
<p>A site by species data frame, with site names as row names.</p>
</td></tr>
<tr><td><code id="match_comm_tree_+3A_tree">tree</code></td>
<td>
<p>A phylogeny with &quot;phylo&quot; as class.</p>
</td></tr>
<tr><td><code id="match_comm_tree_+3A_comm_2">comm_2</code></td>
<td>
<p>Another optional site by species data frame, if presented, both community data and the phylogeny
will have the same set of species. This can be useful for PCD with custom species pool.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the community data and the phylogeny.
</p>

<hr>
<h2 id='model.frame.communityPGLMM'>Extracting the Model Frame from a communityPGLMM Model
object</h2><span id='topic+model.frame.communityPGLMM'></span>

<h3>Description</h3>

<p>Extracting the Model Frame from a communityPGLMM Model
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.communityPGLMM_+3A_formula">formula</code></td>
<td>
<p>a model <code><a href="stats.html#topic+formula">formula</a></code> or <code><a href="stats.html#topic+terms">terms</a></code>
object or an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="model.frame.communityPGLMM_+3A_...">...</code></td>
<td>
<p>for <code>model.frame</code> methods, a mix of further
arguments such as <code>data</code>, <code>na.action</code>, <code>subset</code> to pass
to the default method.  Any additional arguments (such as
<code>offset</code> and <code>weights</code> or other named arguments) which
reach the default method are used to create further columns in the
model frame, with parenthesised names such as <code>"(offset)"</code>.
</p>
<p>For <code>get_all_vars</code>, further named columns to include
in the model frame.</p>
</td></tr>
</table>

<hr>
<h2 id='nobs.communityPGLMM'>Number of Observation in a communityPGLMM Model</h2><span id='topic+nobs.communityPGLMM'></span>

<h3>Description</h3>

<p>Number of Observation in a communityPGLMM Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
nobs(object, use.fallback = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.communityPGLMM_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.communityPGLMM_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical: should fallback methods be used to try to
guess the value?</p>
</td></tr>
<tr><td><code id="nobs.communityPGLMM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='oldfield'>Phylogeny and community data from an Oldfield ecosystem in Southern Ontario, Canada</h2><span id='topic+oldfield'></span>

<h3>Description</h3>

<p>A list containing a phylogeny for XX species of Oldfield forbs, as well as a
presence / absence dataset for their occurrence across several locations in
Southern Ontario see Dinnage (2009) for details. Sites each had two plots which
experienced a different treatment each; either they has been disturbed (ploughed
1 or 2 years previously), or they were a control plot (undisturbed in recent records).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oldfield
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt><code>phy</code></dt><dd><p>A phylogeny in <code>ape</code>'s <code>phy</code> format</p>
</dd>
<dt><code>data</code></dt><dd><p>A data.frame containing data on the occurrence of the species in <code>phy</code></p>
</dd>
</dl>

<p>oldfield$data is a data.frame with 1786 rows, and the following 7 columns:
</p>

<dl>
<dt><code>site_orig</code></dt><dd><p>integer. Site ID number.</p>
</dd>
<dt><code>habitat_type</code></dt><dd><p>character. Plot treatment: disturbed or undisturbed.</p>
</dd>
<dt><code>sp</code></dt><dd><p>character. Species name using underscore to separate binomial names (to match phylogeny).</p>
</dd>
<dt><code>abundance</code></dt><dd><p>integer. Recorded abundance of species in plot.</p>
</dd>
<dt><code>disturbance</code></dt><dd><p>integer. Whether the plot was disturbed or not. 0 or 1. 0 for undisturbed, 1 for disturbed</p>
</dd>
<dt><code>site_orig</code></dt><dd><p>character. A unique site descriptor concatenating the site number with the disturbance treatment.</p>
</dd>
<dt><code>pres</code></dt><dd><p>integer. Species presence or absence in plot. 0 or 1. 0 for absent, 1 for present</p>
</dd>
</dl>


<hr>
<h2 id='pcd'>pairwise site phylogenetic community dissimilarity (PCD) within a community</h2><span id='topic+pcd'></span>

<h3>Description</h3>

<p>Calculate pairwise site PCD, users can specify expected values from <code>pcd_pred()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcd(comm, tree, expectation = NULL, cpp = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcd_+3A_comm">comm</code></td>
<td>
<p>A site by species data frame or matrix, sites as rows.</p>
</td></tr>
<tr><td><code id="pcd_+3A_tree">tree</code></td>
<td>
<p>A phylogeny for species.</p>
</td></tr>
<tr><td><code id="pcd_+3A_expectation">expectation</code></td>
<td>
<p>nsp_pool, psv_bar, psv_pool, and nsr calculated from <code>pcd_pred()</code>.</p>
</td></tr>
<tr><td><code id="pcd_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use loops written with c++, default is TRUE.</p>
</td></tr>
<tr><td><code id="pcd_+3A_verbose">verbose</code></td>
<td>
<p>Do you want to see the progress?</p>
</td></tr>
<tr><td><code id="pcd_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a variety of pairwise dissimilarities.
</p>


<h3>References</h3>

<p>Ives, A. R., &amp; Helmus, M. R. 2010. Phylogenetic metrics of community similarity.
The American Naturalist, 176(5), E128-E142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = pcd_pred(comm_1 = comm_a, comm_2 = comm_b, tree = phylotree, reps = 100)
pcd(comm = comm_a, tree = phylotree, expectation = x1)
</code></pre>

<hr>
<h2 id='pcd_pred'>Predicted PCD with species pool</h2><span id='topic+pcd_pred'></span>

<h3>Description</h3>

<p>This function will calculate expected PCD from one or two sets of communities (depends on the species pool)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcd_pred(comm_1, comm_2 = NULL, tree, reps = 10^3, cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcd_pred_+3A_comm_1">comm_1</code></td>
<td>
<p>A site by species dataframe or matrix, with sites as rows and species as columns.</p>
</td></tr>
<tr><td><code id="pcd_pred_+3A_comm_2">comm_2</code></td>
<td>
<p>An optional second site by species data frame. It should have the same number of rows as comm_1.
This can be useful if we want to calculate temporal beta diversity, i.e. changes of the same site over time.
Because data of the same site are not independent, setting comm_2 will use both communities as species pool
to calculate expected PCD.</p>
</td></tr>
<tr><td><code id="pcd_pred_+3A_tree">tree</code></td>
<td>
<p>The phylogeny for all species, with &quot;phylo&quot; as class; or a var-cov matrix.</p>
</td></tr>
<tr><td><code id="pcd_pred_+3A_reps">reps</code></td>
<td>
<p>Number of random draws, default is 1000 times.</p>
</td></tr>
<tr><td><code id="pcd_pred_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use loops written with c++, default is TRUE. If you came across with errors, try to
set cpp = FALSE. This normally will run without errors, but slower.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with species richness of the pool, expected PSV, PSV of the pool,
and unique number of species richness across sites.
</p>

<hr>
<h2 id='pglmm'>Phylogenetic Generalized Linear Mixed Model for Community Data</h2><span id='topic+pglmm'></span><span id='topic+communityPGLMM'></span>

<h3>Description</h3>

<p>This function performs Generalized Linear Mixed Models for binary, count,
and continuous data, estimating regression coefficients with
approximate standard errors. It is specifically designed for community data
in which species occur within multiple sites (locations).
A Bayesian version of PGLMM uses the package <code>INLA</code>,
which is not available on CRAN yet. If you wish to use this option,
you must first install <code>INLA</code> from <a href="https://www.r-inla.org/">https://www.r-inla.org/</a> by running
<code>install.packages('INLA', repos='https://www.math.ntnu.no/inla/R/stable')</code> in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm(
  formula,
  data = NULL,
  family = "gaussian",
  cov_ranef = NULL,
  random.effects = NULL,
  REML = TRUE,
  optimizer = c("nelder-mead-nlopt", "bobyqa", "Nelder-Mead", "subplex"),
  repulsion = FALSE,
  add.obs.re = TRUE,
  verbose = FALSE,
  cpp = TRUE,
  bayes = FALSE,
  s2.init = NULL,
  B.init = NULL,
  reltol = 10^-6,
  maxit = 500,
  tol.pql = 10^-6,
  maxit.pql = 200,
  marginal.summ = "mean",
  calc.DIC = TRUE,
  calc.WAIC = TRUE,
  prior = "inla.default",
  prior_alpha = 0.1,
  prior_mu = 1,
  ML.init = FALSE,
  tree = NULL,
  tree_site = NULL,
  sp = NULL,
  site = NULL,
  bayes_options = NULL,
  bayes_nested_matrix_as_list = FALSE
)

communityPGLMM(
  formula,
  data = NULL,
  family = "gaussian",
  cov_ranef = NULL,
  random.effects = NULL,
  REML = TRUE,
  optimizer = c("nelder-mead-nlopt", "bobyqa", "Nelder-Mead", "subplex"),
  repulsion = FALSE,
  add.obs.re = TRUE,
  verbose = FALSE,
  cpp = TRUE,
  bayes = FALSE,
  s2.init = NULL,
  B.init = NULL,
  reltol = 10^-6,
  maxit = 500,
  tol.pql = 10^-6,
  maxit.pql = 200,
  marginal.summ = "mean",
  calc.DIC = TRUE,
  calc.WAIC = TRUE,
  prior = "inla.default",
  prior_alpha = 0.1,
  prior_mu = 1,
  ML.init = FALSE,
  tree = NULL,
  tree_site = NULL,
  sp = NULL,
  site = NULL,
  bayes_options = NULL,
  bayes_nested_matrix_as_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
mixed effects of the model.
</p>
<p>To specify that a random term should have phylogenetic covariance matrix along
with non-phylogenetic one, add <code>__</code> (two underscores) at the end of the group variable;
e.g., <code>+ (1 | sp__)</code> will construct two random terms,
one with phylogenetic covariance matrix and another with non-phylogenetic (identity) matrix.
In contrast, <code>__</code> in the nested terms (below) will only create a phylogenetic covariance matrix.
Nested random terms have the general form <code>(1|sp__@site__)</code> which represents
phylogenetically related species nested within correlated sites.
This form can be used for bipartite questions. For example, species could be
phylogenetically related pollinators and sites could be phylogenetically related plants, leading to
the random effect <code>(1|insects__@plants__)</code>. If more than one phylogeny is used, remember to add
all to the argument <code>cov_ranef = list(insects = insect_phylo, plants = plant_phylo)</code>. Phylogenetic correlations can
be dropped by removing the <code>__</code> underscores. Thus, the form <code>(1|sp@site__)</code> excludes the phylogenetic
correlations among species, while the form <code>(1|sp__@site)</code> excludes the correlations among sites.
</p>
<p>Note that correlated random terms are not allowed. For example,
<code>(x|g)</code> will be the same as <code>(0 + x|g)</code> in the <code>lme4::lmer</code> syntax. However,
<code>(x1 + x2|g)</code> won't work, so instead use  <code>(x1|g) + (x2|g)</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_family">family</code></td>
<td>
<p>Either &quot;gaussian&quot; for a Linear Mixed Model, or
&quot;binomial&quot; or &quot;poisson&quot; for Generalized Linear Mixed Models.
&quot;family&quot; should be specified as a character string (i.e., quoted). For binomial and
Poisson data, we use the canonical logit and log link functions, respectively.
Binomial data can be either presence/absence, or a two-column array of 'successes' and 'failures'.
For both binomial  and Poisson data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>. If <code>bayes = TRUE</code> there are
two additional families available: &quot;zeroinflated.binomial&quot;, and &quot;zeroinflated.poisson&quot;,
which add a zero inflation parameter; this parameter gives the probability that the response is
a zero. The rest of the parameters of the model then reflect the &quot;non-zero&quot; part part
of the model. Note that &quot;zeroinflated.binomial&quot; only makes sense for success/failure
response data.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>A named list of covariance matrices of random terms. The names should be the
group variables that are used as random terms with specified covariance matrices
(without the two underscores, e.g. <code>list(sp = tree1, site = tree2)</code>). The actual object
can be either a phylogeny with class &quot;phylo&quot; or a prepared covariance matrix. If it is a phylogeny,
<code>pglmm</code> will prune it and then convert it to a covariance matrix assuming Brownian motion evolution.
<code>pglmm</code> will also standardize all covariance matrices to have determinant of one. Group variables
will be converted to factors and all covariance matrices will be rearranged so that rows and
columns are in the same order as the levels of their corresponding group variables.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_random.effects">random.effects</code></td>
<td>
<p>Optional pre-build list of random effects. If <code>NULL</code> (the default),
the function <code><a href="#topic+prep_dat_pglmm">prep_dat_pglmm</a></code> will prepare the random effects for you from the information
in <code>formula</code>, <code>data</code>, and <code>cov_ranef</code>. <code>random.effect</code> allows a list of
pre-generated random effects terms to increase flexibility; for example, this makes it
possible to construct models with both phylogenetic correlation and spatio-temporal autocorrelation.
In preparing <code>random.effect</code>, make sure that the orders of rows and columns of
covariance matrices in the list are the same as their corresponding group variables
in the data. Also, this should be <em>a list of lists</em>, e.g.
<code>random.effects = list(re1 = list(matrix_a), re2 = list(1, sp = sp, covar = Vsp))</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_reml">REML</code></td>
<td>
<p>Whether REML or ML is used for model fitting the random effects. Ignored if
<code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_optimizer">optimizer</code></td>
<td>
<p>nelder-mead-nlopt (default), bobyqa, Nelder-Mead, or subplex.
Nelder-Mead is from the stats package and the other optimizers are from the nloptr package.
Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_repulsion">repulsion</code></td>
<td>
<p>When there are nested random terms specified, <code>repulsion = FALSE</code> tests
for phylogenetic underdispersion while <code>repulsion = FALSE</code> tests for overdispersion.
This argument is a logical vector of length either 1 or &gt;1.
If its length is 1, then all covariance matrices in nested terms will be either
inverted (overdispersion) or not. If its length is &gt;1, then you can select
which covariance matrix in the nested terms to be inverted. Make sure to get
the length right: for all the terms with <code>@</code>, count the number of &quot;__&quot;
to determine the length of repulsion. For example, <code>sp__@site</code> and <code>sp@site__</code>
will each require one element of <code>repulsion</code>, while <code>sp__@site__</code> will take two
elements (repulsion for sp and repulsion for site). Therefore, if your nested terms are
<code>(1|sp__@site) + (1|sp@site__) + (1|sp__@site__)</code>, then you should set the
repulsion to be something like <code>c(TRUE, FALSE, TRUE, TRUE)</code> (length of 4).</p>
</td></tr>
<tr><td><code id="pglmm_+3A_add.obs.re">add.obs.re</code></td>
<td>
<p>Whether to add an observation-level random term for binomial or Poisson
distributions. Normally it would be a good idea to add this to account for overdispersion,
so <code>add.obs.re = TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, the model deviance and running
estimates of <code>s2</code> and <code>B</code> are plotted each iteration
during optimization.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use C++ function for optim. Default is TRUE. Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_bayes">bayes</code></td>
<td>
<p>Whether to fit a Bayesian version of the PGLMM using <code>r-inla</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_s2.init">s2.init</code></td>
<td>
<p>An array of initial estimates of s2 for each random
effect that scales the variance. If s2.init is not provided for
<code>family="gaussian"</code>, these are estimated using <code><a href="stats.html#topic+lm">lm</a></code> assuming
no phylogenetic signal. A better approach might be to run <code>link[lme4:lmer]{lmer}</code>
and use the output random effects for <code>s2.init</code>. If <code>s2.init</code> is not
provided for <code>family = "binomial"</code>, these are set to 0.25.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_b.init">B.init</code></td>
<td>
<p>Initial estimates of <code class="reqn">B</code>, a matrix containing
regression coefficients in the model for the fixed effects. This
matrix must have <code>dim(B.init) = c(p + 1, 1)</code>, where <code>p</code> is the
number of predictor (independent) variables; the first element of
<code>B</code> corresponds to the intercept, and the remaining elements
correspond in order to the predictor (independent) variables in the
formula. If <code>B.init</code> is not provided, these are estimated
using <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> assuming no phylogenetic signal.
A better approach might be to run <code><a href="lme4.html#topic+lmer">lmer</a></code> and use the
output fixed effects for <code>B.init</code>. When <code>bayes = TRUE</code>, initial values are estimated
using the maximum likelihood fit unless <code>ML.init = FALSE</code>, in
which case the default <code>INLA</code> initial values will be used.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_reltol">reltol</code></td>
<td>
<p>A control parameter dictating the relative tolerance
for convergence in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_maxit">maxit</code></td>
<td>
<p>A control parameter dictating the maximum number of
iterations in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_tol.pql">tol.pql</code></td>
<td>
<p>A control parameter dictating the tolerance for
convergence in the PQL estimates of the mean components of the
GLMM. Ignored if <code>family = "gaussian"</code> or <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_maxit.pql">maxit.pql</code></td>
<td>
<p>A control parameter dictating the maximum number
of iterations in the PQL estimates of the mean components of the
GLMM. Ignored if <code>family = "gaussian"</code> or <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_marginal.summ">marginal.summ</code></td>
<td>
<p>Summary statistic to use for the estimate of coefficients when
doing a Bayesian PGLMM (when <code>bayes = TRUE</code>). Options are: &quot;mean&quot;,
&quot;median&quot;, or &quot;mode&quot;, referring to different characterizations of the central
tendency of the Bayesian posterior marginal distributions. Ignored if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_calc.dic">calc.DIC</code></td>
<td>
<p>Should the Deviance Information Criterion be calculated and returned
when doing a Bayesian PGLMM? Ignored if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_calc.waic">calc.WAIC</code></td>
<td>
<p>Should the WAIC be calculated and returned
when doing a Bayesian PGLMM? Ignored if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_prior">prior</code></td>
<td>
<p>Which type of default prior should be used by <code>pglmm</code>?
Only used if <code>bayes = TRUE</code>. There are currently four options:
&quot;inla.default&quot;, which uses the default <code>INLA</code> priors; &quot;pc.prior.auto&quot;, which uses a
complexity penalizing prior (as described in
<a href="https://arxiv.org/abs/1403.4630v3">Simpson et al. (2017)</a>) designed to automatically
choose good parameters (only available for gaussian and binomial responses); &quot;pc.prior&quot;, which
allows the user to set custom parameters on the &quot;pc.prior&quot; prior, using the <code>prior_alpha</code>
and <code>prior_mu</code> parameters (Run <code>INLA::inla.doc("pc.prec")</code> for details on these
parameters); and &quot;uninformative&quot;, which sets a very uninformative prior
(nearly uniform) by using a very flat exponential distribution. The last option is generally
not recommended but may in some cases give estimates closer to the maximum likelihood estimates.
&quot;pc.prior.auto&quot; is only implemented for <code>family = "gaussian"</code> and <code>family = "binomial"</code>
currently.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_prior_alpha">prior_alpha</code></td>
<td>
<p>Only used if <code>bayes = TRUE</code> and <code>prior = "pc.prior"</code>, in
which case it sets the alpha parameter of <code>INLA</code>'s complexity penalizing prior for the
random effects. The prior is an exponential distribution where prob(sd &gt; mu) = alpha,
where sd is the standard deviation of the random effect.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_prior_mu">prior_mu</code></td>
<td>
<p>Only used if <code>bayes = TRUE</code> and <code>prior = "pc.prior"</code>, in
which case it sets the mu parameter of <code>INLA</code>'s complexity penalizing prior for the
random effects. The prior is an exponential distribution where prob(sd &gt; mu) = alpha,
where sd is the standard deviation of the random effect.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_ml.init">ML.init</code></td>
<td>
<p>Only relevant if <code>bayes = TRUE</code>. Should maximum
likelihood estimates be calculated and used as initial values for
the Bayesian model fit? Sometimes this can be helpful, but it may not help; thus,
we set the default to <code>FALSE</code>. Also, it
does not work with the zero-inflated families.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_tree">tree</code></td>
<td>
<p>A phylogeny for column sp, with &quot;phylo&quot; class, or a covariance matrix for sp.
Make sure to have all species in the matrix; if the matrix is not standardized,
(i.e., det(tree) != 1), <code>pglmm</code> will try to standardize it for you.
No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_tree_site">tree_site</code></td>
<td>
<p>A second phylogeny for &quot;site&quot;. This is required only if the
site column contains species instead of sites. This can be used for bipartitie
questions; tree_site can also be a covariance matrix. Make sure to have all sites
in the matrix; if the matrix is not standardized (i.e., det(tree_site) != 1),
pglmm' will try to standardize it for you. No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_sp">sp</code></td>
<td>
<p>No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_site">site</code></td>
<td>
<p>No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_+3A_bayes_options">bayes_options</code></td>
<td>
<p>Additional options to pass to INLA for if <code>bayes = TRUE</code>. A named list where the names
correspond to parameters in the <code>inla</code> function. One special option is <code>diagonal</code>: if an element in
the options list is names <code>diagonal</code> this tells <code>INLA</code> to add its value to the diagonal of the random effects
precision matrices. This can help with numerical stability if the model is ill-conditioned (if you get a lot of warnings,
try setting this to <code>list(diagonal = 1e-4)</code>).</p>
</td></tr>
<tr><td><code id="pglmm_+3A_bayes_nested_matrix_as_list">bayes_nested_matrix_as_list</code></td>
<td>
<p>For <code>bayes = TRUE</code>, prepare the nested terms as a list of length of 4 as the old way?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Gaussian data, <code>pglmm</code> analyzes the phylogenetic linear mixed model
</p>
<p style="text-align: center;"><code class="reqn">Y = \beta_0 + \beta_1x + b_0 + b_1x</code>
</p>

<p style="text-align: center;"><code class="reqn">b_0 ~ Gaussian(0, \sigma_0^2I_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 ~ Gaussian(0, \sigma_0^2V_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">\eta ~ Gaussian(0,\sigma^2)</code>
</p>

<p>where <code class="reqn">\beta_0</code> and <code class="reqn">\beta_1</code> are fixed
effects, and <code class="reqn">V_{sp}</code> is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution). Here, the variation in the mean
(intercept) for each species is given by the random effect
<code class="reqn">b_0</code> that is assumed to be independent among
species. Variation in species' responses to predictor variable
<code class="reqn">x</code> is given by a random effect <code class="reqn">b_0</code> that is
assumed to depend on the phylogenetic relatedness among species
given by <code class="reqn">V_{sp}</code>; if species are closely related,
their specific responses to <code class="reqn">x</code> will be similar. This
particular model would be specified as
</p>
<p><code>z &lt;- pglmm(Y ~ X + (1|sp__), data = data, family = "gaussian", cov_ranef = list(sp = phy))</code>
</p>
<p>Or you can prepare the random terms manually (not recommended for simple models but may be necessary for complex models):
</p>
<p><code>re.1 &lt;- list(1, sp = dat$sp, covar = diag(nspp))</code>
</p>
<p><code>re.2 &lt;- list(dat$X, sp = dat$sp, covar = Vsp)</code>
</p>
<p><code>z &lt;- pglmm(Y ~ X, data = data, family = "gaussian", random.effects = list(re.1, re.2))</code>
</p>
<p>The covariance matrix covar is standardized to have its determinant
equal to 1. This in effect standardizes the interpretation of the
scalar <code class="reqn">\sigma^2</code>. Although mathematically this is
not required, it is a very good idea to standardize the predictor
(independent) variables to have mean 0 and variance 1. This will
make the function more robust and improve the interpretation of the
regression coefficients. For categorical (factor) predictor
variables, you will need to construct 0-1 dummy variables, and
these should not be standardized (for obvious reasons).
</p>
<p>For binary generalized linear mixed models (<code>family =
'binomial'</code>), the function estimates parameters for the model of
the form, for example,
</p>
<p style="text-align: center;"><code class="reqn">y = \beta_0 + \beta_1x + b_0 + b_1x</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = logit^{-1}(y)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_0 ~ Gaussian(0, \sigma_0^2I_{sp})</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 ~ Gaussian(0, \sigma_0^2V_{sp})</code>
</p>

<p>where <code class="reqn">\beta_0</code> and <code class="reqn">\beta_1</code> are fixed
effects, and <code class="reqn">V_{sp}</code> is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution).
</p>
<p><code>z &lt;- pglmm(Y ~ X + (1|sp__), data = data, family = "binomial", cov_ranef = list(sp = phy))</code>
</p>
<p>As with the linear mixed model, it is a very good idea to
standardize the predictor (independent) variables to have mean 0
and variance 1. This will make the function more robust and improve
the interpretation of the regression coefficients.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>communityPGLMM</code> with the following elements:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>the formula for fixed effects</p>
</td></tr>
<tr><td><code>formula_original</code></td>
<td>
<p>the formula for both fixed effects and random effects</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p><code>gaussian</code>, <code>binomial</code>, or <code>poisson</code> depending on the model fit</p>
</td></tr>
<tr><td><code>random.effects</code></td>
<td>
<p>the list of random effects</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimates of the regression coefficients</p>
</td></tr>
<tr><td><code>B.se</code></td>
<td>
<p>approximate standard errors of the fixed effects regression coefficients.
This is set to NULL if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code>B.ci</code></td>
<td>
<p>approximate Bayesian credible interval of the fixed effects regression coefficients.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>B.cov</code></td>
<td>
<p>approximate covariance matrix for the fixed effects regression coefficients</p>
</td></tr>
<tr><td><code>B.zscore</code></td>
<td>
<p>approximate Z scores for the fixed effects regression coefficients. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>B.pvalue</code></td>
<td>
<p>approximate tests for the fixed effects regression coefficients being different from zero. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>standard deviations of the random effects for the covariance matrix <code class="reqn">\sigma^2V</code> for each random effect in order. For the linear mixed model, the residual variance is listed last.</p>
</td></tr>
<tr><td><code>s2r</code></td>
<td>
<p>random effects variances for non-nested random effects</p>
</td></tr>
<tr><td><code>s2n</code></td>
<td>
<p>random effects variances for nested random effects</p>
</td></tr>
<tr><td><code>s2resid</code></td>
<td>
<p>for linear mixed models, the residual variance</p>
</td></tr>
<tr><td><code>s2r.ci</code></td>
<td>
<p>Bayesian credible interval for random effects variances for non-nested random effects.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>s2n.ci</code></td>
<td>
<p>Bayesian credible interval for random effects variances for nested random effects.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>s2resid.ci</code></td>
<td>
<p>Bayesian credible interval for linear mixed models, the residual variance.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>for linear mixed models, the log-likelihood for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalized linear mixed models. If <code>bayes = TRUE</code>, this is the marginal log-likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>for linear mixed models, the AIC for either the restricted likelihood (<code>REML = TRUE</code>) or the overall likelihood (<code>REML = FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>for linear mixed models, the BIC for either the restricted likelihood (<code>REML = TRUE</code>) or the overall likelihood (<code>REML = FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>for Bayesian PGLMM, this is the Deviance Information Criterion metric of model fit. This is set to NULL if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code>REML</code></td>
<td>
<p>whether or not REML is used (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>bayes</code></td>
<td>
<p>whether or not a Bayesian model was fit.</p>
</td></tr>
<tr><td><code>marginal.summ</code></td>
<td>
<p>The specified summary statistic used to summarize the Bayesian marginal distributions.
Only present if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>s2.init</code></td>
<td>
<p>the user-provided initial estimates of <code>s2</code></p>
</td></tr>
<tr><td><code>B.init</code></td>
<td>
<p>the user-provided initial estimates of <code>B</code></p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the response (dependent) variable returned in matrix form</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the predictor (independent) variables returned in matrix form (including 1s in the first column)</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the residuals. For linear mixed models, this does not account for random terms,
To get residuals after accounting for both fixed and random terms, use <code>residuals()</code>.
For the generalized linear mixed model, these are the predicted residuals in the
logit -1 space.</p>
</td></tr>
<tr><td><code>iV</code></td>
<td>
<p>the inverse of the covariance matrix for the entire system (of dimension (<code>nsp</code> * <code>nsite</code>)
by (<code>nsp</code> * <code>nsite</code>)). This is NULL if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>predicted mean values for the generalized linear mixed model (i.e., similar to <code>fitted(merMod)</code>).
Set to NULL for linear mixed models, for which we can use <code><a href="stats.html#topic+fitted">fitted()</a></code>.</p>
</td></tr>
<tr><td><code>nested</code></td>
<td>
<p>matrices used to construct the nested design matrix. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>Zt</code></td>
<td>
<p>the design matrix for random effects. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>St</code></td>
<td>
<p>diagonal matrix that maps the random effects variances onto the design matrix</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p>the convergence code provided by <code><a href="stats.html#topic+optim">optim</a></code>. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations performed by <code><a href="stats.html#topic+optim">optim</a></code>. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>inla.model</code></td>
<td>
<p>Model object fit by underlying <code>inla</code> function. Only returned
if <code>bayes = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anthony R. Ives, Daijiang Li, Russell Dinnage
</p>


<h3>References</h3>

<p>Ives, A. R. and M. R. Helmus. 2011. Generalized linear
mixed models for phylogenetic analyses of community
structure. Ecological Monographs 81:511-525.
</p>
<p>Ives A. R. 2018. Mixed and phylogenetic models: a conceptual introduction to correlated data.
https://leanpub.com/correlateddata.
</p>
<p>Rafferty, N. E., and A. R. Ives. 2013. Phylogenetic
trait-based analyses of ecological networks. Ecology 94:2321-2333.
</p>
<p>Simpson, Daniel, et al. 2017. Penalising model component complexity:
A principled, practical approach to constructing priors.
Statistical science 32(1): 1-28.
</p>
<p>Li, D., Ives, A. R., &amp; Waller, D. M. 2017.
Can functional traits account for phylogenetic signal in community composition?
New Phytologist, 214(2), 607-618.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Structure of examples:
# First, a (brief) description of model types, and how they are specified
# - these are *not* to be run 'as-is'; they show how models should be organised
# Second, a run-through of how to simulate, and then analyse, data
# - these *are* to be run 'as-is'; they show how to format and work with data


#############################################
### Brief summary of models and their use ###
#############################################
## Model structures from Ives &amp; Helmus (2011)
if(FALSE){
  # dat = data set for regression (note: must have a column "sp" and a column "site")
  # phy = phylogeny of class "phylo"
  # repulsion = to test phylogenetic repulsion or not
  
  # Model 1 (Eq. 1)
  z &lt;- pglmm(freq ~ sp + (1|site) + (1|sp__@site), data = dat, family = "binomial",
             cov_ranef = list(sp = phy), REML = TRUE, verbose = TRUE, s2.init = .1)
  
  # Model 2 (Eq. 2)
  z &lt;- pglmm(freq ~ sp + X + (1|site) + (X|sp__), data = dat, family = "binomial",
             cov_ranef = list(sp = phy), REML = TRUE, verbose = TRUE, s2.init = .1)
  
  # Model 3 (Eq. 3)
  z &lt;- pglmm(freq ~ sp*X + (1|site) + (1|sp__@site), data = dat, family = "binomial",
             cov_ranef = list(sp = phy), REML = TRUE, verbose = TRUE, s2.init = .1)
  
  ## Model structure from Rafferty &amp; Ives (2013) (Eq. 3)
  # dat = data set
  # phyPol = phylogeny for pollinators (pol)
  # phyPlt = phylogeny for plants (plt)
  
  z &lt;- pglmm(freq ~ pol * X + (1|pol__) + (1|plt__) + (1|pol__@plt) +
               (1|pol@plt__) + (1|pol__@plt__),
             data = dat, family = "binomial",
             cov_ranef = list(pol = phyPol, plt = phyPlt),
             REML = TRUE, verbose = TRUE, s2.init = .1)
}

#####################################################
### Detailed analysis showing covariance matrices ###
#####################################################

# This is the example from section 4.3 in Ives, A. R. (2018) Mixed 
# and phylogenetic models: a conceptual introduction to correlated data.

library(ape)
library(mvtnorm)

# Investigating covariance matrices for different types of model structure
nspp &lt;- 6
nsite &lt;- 4

# Simulate a phylogeny that has a lot of phylogenetic signal (power = 1.3)
phy &lt;- compute.brlen(rtree(n = nspp), method = "Grafen", power = 1.3)

# Simulate species means
sd.sp &lt;- 1
mean.sp &lt;- rTraitCont(phy, model = "BM", sigma=sd.sp^2)

# Replicate values of mean.sp over sites
Y.sp &lt;- rep(mean.sp, times=nsite)

# Simulate site means
sd.site &lt;- 1
mean.site &lt;- rnorm(nsite, sd=sd.site)

# Replicate values of mean.site over sp
Y.site &lt;- rep(mean.site, each=nspp)

# Compute a covariance matrix for phylogenetic attraction
sd.attract &lt;- 1
Vphy &lt;- vcv(phy)

# Standardize the phylogenetic covariance matrix to have determinant = 1. 
# (For an explanation of this standardization, see subsection 4.3.1 in Ives (2018))
Vphy &lt;- Vphy/(det(Vphy)^(1/nspp))

# Construct the overall covariance matrix for phylogenetic attraction. 
# (For an explanation of Kronecker products, see subsection 4.3.1 in the book)
V &lt;- kronecker(diag(nrow = nsite, ncol = nsite), Vphy)
Y.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.attract^2*V)))

# Simulate residual errors
sd.e &lt;- 1
Y.e &lt;- rnorm(nspp*nsite, sd = sd.e)

# Construct the dataset
d &lt;- data.frame(sp = rep(phy$tip.label, times = nsite), 
                site = rep(1:nsite, each = nspp))

# Simulate abundance data
d$Y &lt;- Y.sp + Y.site + Y.attract + Y.e

# Analyze the model
pglmm(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site), data = d, cov_ranef = list(sp = phy))

# Display random effects: the function `pglmm_plot_ranef()` does what 
# the name implies. You can set `show.image = TRUE` and `show.sim.image = TRUE` 
# to see the matrices and simulations.
re &lt;- pglmm_plot_ranef(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site), data = d, 
                    cov_ranef = list(sp = phy), show.image = FALSE, 
                    show.sim.image = FALSE)

#################################################
### Example of a bipartite phylogenetic model ###
#################################################

# Investigating covariance matrices for different types of model structure
nspp &lt;- 20
nsite &lt;- 15

# Simulate a phylogeny that has a lot of phylogenetic signal (power = 1.3)
phy.sp &lt;- compute.brlen(rtree(n = nspp), method = "Grafen", power = 1.3)
phy.site &lt;- compute.brlen(rtree(n = nsite), method = "Grafen", power = 1.3)

# Simulate species means
mean.sp &lt;- rTraitCont(phy.sp, model = "BM", sigma = 1)

# Replicate values of mean.sp over sites
Y.sp &lt;- rep(mean.sp, times = nsite)

# Simulate site means
mean.site &lt;- rTraitCont(phy.site, model = "BM", sigma = 1)

# Replicate values of mean.site over sp
Y.site &lt;- rep(mean.site, each = nspp)

# Generate covariance matrix for phylogenetic attraction among species
sd.sp.attract &lt;- 1
Vphy.sp &lt;- vcv(phy.sp)
Vphy.sp &lt;- Vphy.sp/(det(Vphy.sp)^(1/nspp))
V.sp &lt;- kronecker(diag(nrow = nsite, ncol = nsite), Vphy.sp)
Y.sp.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.sp.attract^2*V.sp)))
# Generate covariance matrix for phylogenetic attraction among sites
sd.site.attract &lt;- 1
Vphy.site &lt;- vcv(phy.site)
Vphy.site &lt;- Vphy.site/(det(Vphy.site)^(1/nsite))
V.site &lt;- kronecker(Vphy.site, diag(nrow = nspp, ncol = nspp))
Y.site.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.site.attract^2*V.site)))

# Generate covariance matrix for phylogenetic attraction of species:site interaction
sd.sp.site.attract &lt;- 1
V.sp.site &lt;- kronecker(Vphy.site, Vphy.sp)
Y.sp.site.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.sp.site.attract^2*V.sp.site)))

# Simulate residual error
sd.e &lt;- 0.5
Y.e &lt;- rnorm(nspp*nsite, sd = sd.e)

# Construct the dataset
d &lt;- data.frame(sp = rep(phy.sp$tip.label, times = nsite), 
                site = rep(phy.site$tip.label, each = nspp))

# Simulate abundance data
d$Y &lt;- Y.sp + Y.site + Y.sp.attract + Y.site.attract + Y.sp.site.attract + Y.e

# Plot random effects covariance matrices and then add phylogenies
# Note that, if show.image and show.sim are not specified, pglmm_plot_ranef() shows
# the covariance matrices if nspp * nsite &lt; 200 and shows simulations 
# if nspp * nsite &gt; 100
re &lt;- pglmm_plot_ranef(Y ~ 1 + (1|sp__) + (1|site__) + (1|sp__@site) + 
                    (1|sp@site__) + (1|sp__@site__),
                    data=d, cov_ranef = list(sp = phy.sp, site = phy.site))

# This flips the phylogeny to match to covariance matrices
rot.phy.site &lt;- phy.site
for(i in (nsite+1):(nsite+Nnode(phy.site))) 
   rot.phy.site &lt;- rotate(rot.phy.site, node = i)

plot(phy.sp, main = "Species", direction = "upward")
plot(rot.phy.site, main = "Site")

# Analyze the simulated data and compute a P-value for the (1|sp__@site__) 
# random effect using a LRT. It is often better to fit the reduced model before
# the full model, because it s numerically easier to fit the reduced model, 
# and then the parameter estimates from the reduced model can be given to the
# full model. In this case, I have used the estimates of the random effects 
# from the reduce model, mod.r$ss, as the initial estimates for the same 
# parameters in the full model in the statement s2.init=c(mod.r$ss, 0.01)^2. 
# The final 0.01 is for the last random effect in the full model, (1|sp__@site__). 
# Note also that the output of the random effects from communityPGLMM(), mod.r$ss, 
# are the standard deviations, so they have to be squared for use as initial 
# values of variances in mod.f.

mod.r &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site__) + (1|sp__@site) + (1|sp@site__), 
                        data = d, cov_ranef = list(sp = phy.sp, site = phy.site))
mod.f &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site__) + (1|sp__@site) + (1|sp@site__) + 
               (1|sp__@site__), data = d, 
               cov_ranef = list(sp = phy.sp, site = phy.site), 
               s2.init = c(mod.r$ss, 0.01)^2)
mod.f
pvalue &lt;- pchisq(2*(mod.f$logLik - mod.r$logLik), df = 1, lower.tail = FALSE)
pvalue
 
</code></pre>

<hr>
<h2 id='pglmm_compare'>Phylogenetic Generalized Linear Mixed Model for Comparative Data</h2><span id='topic+pglmm_compare'></span>

<h3>Description</h3>

<p><code>pglmm_compare</code> performs linear regression for Gaussian, binomial and Poisson
phylogenetic data, estimating regression coefficients with approximate standard
errors. It simultaneously estimates the strength of phylogenetic signal in the
residuals and gives an approximate conditional likelihood ratio test for the
hypothesis that there is no signal. Therefore, when applied without
predictor (independent) variables, it gives a test for phylogenetic signal.
<code>pglmm_compare</code> is a wrapper for <code>pglmm</code> tailored for comparative data in
which each value of the response (dependent) variable corresponds to a single tip
on a phylogenetic tree. If there are multiple measures for each species, <code>pglmm</code>
will be helpful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm_compare(
  formula,
  family = "gaussian",
  data = list(),
  phy,
  REML = TRUE,
  optimizer = c("nelder-mead-nlopt", "bobyqa", "Nelder-Mead", "subplex"),
  add.obs.re = TRUE,
  verbose = FALSE,
  cpp = TRUE,
  bayes = FALSE,
  reltol = 10^-6,
  maxit = 500,
  tol.pql = 10^-6,
  maxit.pql = 200,
  marginal.summ = "mean",
  calc.DIC = FALSE,
  prior = "inla.default",
  prior_alpha = 0.1,
  prior_mu = 1,
  ML.init = FALSE,
  s2.init = 1,
  B.init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_compare_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
fixed-effects of the model; for example, Y ~ X. Binomial data can be either
presence/absence, or a two-column array of 'successes' and 'failures'.
For both binomial and Poisson data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_family">family</code></td>
<td>
<p>Either &quot;gaussian&quot; for a Linear Mixed Model, or
&quot;binomial&quot; or &quot;poisson&quot; for Generalized Linear Mixed Models.
<code>family</code> should be specified as a character string (i.e., quoted). For binomial and
Poisson data, we use the canonical logit and log link functions, respectively.
Binomial data can be either presence/absence, or a two-column array of 'successes' and 'failures'.
For both Poisson and binomial data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>. If <code>bayes = TRUE</code> there are
two additional families available: &quot;zeroinflated.binomial&quot;, and &quot;zeroinflated.poisson&quot;,
which add a zero inflation parameter; this parameter gives the probability that the response is
a zero. The rest of the parameters of the model then reflect the &quot;non-zero&quot; part
of the model. Note that &quot;zeroinflated.binomial&quot; only makes sense for success/failure
response data.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables named in formula. It must has
the tip labels of the phylogeny as row names; if they are not in the same order,
the data frame will be arranged so that row names match the order of tip labels.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_phy">phy</code></td>
<td>
<p>A phylogenetic tree as an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_reml">REML</code></td>
<td>
<p>Whether REML or ML is used for model fitting the random effects. Ignored if
<code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_optimizer">optimizer</code></td>
<td>
<p>nelder-mead-nlopt (default), bobyqa, Nelder-Mead, or subplex.
Nelder-Mead is from the stats package and the other optimizers are from the nloptr package.
Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_add.obs.re">add.obs.re</code></td>
<td>
<p>Whether to add observation-level random term for binomial and  Poisson
families. Normally it would be a good idea to add this to account for overdispersion,
so <code>add.obs.re = TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, the model deviance and running
estimates of <code>s2</code> and <code>B</code> are plotted each iteration
during optimization.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use C++ function for optim. Default is TRUE. Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_bayes">bayes</code></td>
<td>
<p>Whether to fit a Bayesian version of the PGLMM using <code>r-inla</code>. We recommend
against Bayesian fitting for non-Gaussian data unless sample sizes are large (&gt;1000), because
the phylogenetic variance tends to get trapped near zero.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_reltol">reltol</code></td>
<td>
<p>A control parameter dictating the relative tolerance
for convergence in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_maxit">maxit</code></td>
<td>
<p>A control parameter dictating the maximum number of
iterations in the optimization; see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_tol.pql">tol.pql</code></td>
<td>
<p>A control parameter dictating the tolerance for
convergence in the PQL estimates of the mean components of the
GLMM. Ignored if <code>family = "gaussian"</code> or <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_maxit.pql">maxit.pql</code></td>
<td>
<p>A control parameter dictating the maximum number
of iterations in the PQL estimates of the mean components of the
GLMM. Ignored if <code>family = "gaussian"</code> or <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_marginal.summ">marginal.summ</code></td>
<td>
<p>Summary statistic to use for the estimate of coefficients when
doing a Bayesian PGLMM (when <code>bayes = TRUE</code>). Options are: &quot;mean&quot;,
&quot;median&quot;, or &quot;mode&quot;, referring to different characterizations of the central
tendency of the Bayesian posterior marginal distributions. Ignored if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_calc.dic">calc.DIC</code></td>
<td>
<p>Should the Deviance Information Criterion be calculated and returned,
when doing a Bayesian PGLMM? Ignored if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_prior">prior</code></td>
<td>
<p>Which type of default prior should be used by <code>pglmm</code>?
Only used if <code>bayes = TRUE</code>. There are currently four options:
&quot;inla.default&quot;, which uses the default <code>INLA</code> priors; &quot;pc.prior.auto&quot;, which uses a
complexity penalizing prior (as described in
<a href="https://arxiv.org/abs/1403.4630v3">Simpson et al. (2017)</a>) designed to automatically
choose good parameters (only available for gaussian and binomial responses); &quot;pc.prior&quot;, which
allows the user to set custom parameters on the &quot;pc.prior&quot; prior, using the <code>prior_alpha</code>
and <code>prior_mu</code> parameters (Run <code>INLA::inla.doc("pc.prec")</code> for details on these
parameters); and &quot;uninformative&quot;, which sets a very uninformative prior
(nearly uniform) by using a very flat exponential distribution. The last option is generally
not recommended but may in some cases give estimates closer to the maximum likelihood estimates.
&quot;pc.prior.auto&quot; is only implemented for <code>family = "gaussian"</code> and <code>family = "binomial"</code>
currently.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_prior_alpha">prior_alpha</code></td>
<td>
<p>Only used if <code>bayes = TRUE</code> and <code>prior = "pc.prior"</code>, in
which case it sets the alpha parameter of <code>INLA</code>'s complexity penalizing prior for the
random effects.The prior is an exponential distribution where prob(sd &gt; mu) = alpha,
where sd is the standard deviation of the random effect.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_prior_mu">prior_mu</code></td>
<td>
<p>Only used if <code>bayes = TRUE</code> and <code>prior = "pc.prior"</code>, in
which case it sets the mu parameter of <code>INLA</code>'s complexity penalizing prior for the
random effects.The prior is an exponential distribution where prob(sd &gt; mu) = alpha,
where sd is the standard deviation of the random effect.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_ml.init">ML.init</code></td>
<td>
<p>Only relevant if <code>bayes = TRUE</code>. Should maximum
likelihood estimates be calculated and used as initial values for
the bayesian model fit? Sometimes this can be helpful, but most of the
time it may not help; thus, we set the default to <code>FALSE</code>. Also, it
does not work with the zero-inflated families.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_s2.init">s2.init</code></td>
<td>
<p>An array of initial estimates of s2. If s2.init is not provided for
<code>family="gaussian"</code>, these are estimated using <code><a href="stats.html#topic+lm">lm</a></code> assuming
no phylogenetic signal. If <code>s2.init</code> is not
provided for <code>family = "binomial"</code>, these are set to 0.25.</p>
</td></tr>
<tr><td><code id="pglmm_compare_+3A_b.init">B.init</code></td>
<td>
<p>Initial estimates of <code class="reqn">B</code>, a matrix containing
regression coefficients in the model for the fixed effects. This
matrix must have <code>dim(B.init) = c(p + 1, 1)</code>, where <code>p</code> is the
number of predictor (independent) variables; the first element of
<code>B</code> corresponds to the intercept, and the remaining elements
correspond in order to the predictor (independent) variables in the
formula. If <code>B.init</code> is not provided, these are estimated
using <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> assuming no phylogenetic signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pglmm_compare</code> in the package <code>phyr</code> is similar to <code>binaryPGLMM</code> in
the package <code>ape</code>, although it has much broader functionality, including
accepting more than just binary data, implementing Bayesian analyses, etc.
</p>
<p>For non-Gaussian data, the function estimates parameters for the model
</p>
<p style="text-align: center;"><code class="reqn">Pr(Y = 1) = \theta </code>
</p>
 <p style="text-align: center;"><code class="reqn">\theta = inverse.link(b0 + b1 * x1 + b2 * x2 + \dots
+ \epsilon)</code>
</p>
 <p style="text-align: center;"><code class="reqn">\epsilon ~ Gaussian(0, s2 * V) </code>
</p>

<p>where <code class="reqn">V</code> is a covariance matrix derived from a phylogeny
(typically under the assumption of Brownian motion evolution). Although
mathematically there is no requirement for <code class="reqn">V</code> to be ultrametric,
forcing <code class="reqn">V</code> into ultrametric form can aide in the interpretation of the
model. This is especially true for binary data, because in regression for
binary dependent variables, only the off-diagonal elements (i.e., covariances)
of matrix <code class="reqn">V</code> are biologically meaningful (see Ives &amp; Garland 2014).
The function converts a phylo tree object into a covariance matrix,
and further standardizes this matrix to have determinant = 1. This in effect
standardizes the interpretation of the scalar <code>s2</code>. Although mathematically
not required, it is a very good idea to standardize the predictor
(independent) variables to have mean 0 and variance 1. This will make the
function more robust and improve the interpretation of the regression
coefficients.
</p>
<p>For Gaussian data, the function estimates parameters for the model
</p>
<p style="text-align: center;"><code class="reqn">Y = b0 + b1 * x1 + b2 * x2 + \dots + \epsilon)</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ Gaussian(0, s2 * V + s2resid * I) </code>
</p>

<p>where <code class="reqn">s2resid * I</code> gives the non-phylogenetic residual variance. Note that this
is equivalent to a model with Pagel's lambda transformation.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>pglmm_compare</code> with the following elements:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>the formula for fixed effects</p>
</td></tr>
<tr><td><code>formula_original</code></td>
<td>
<p>the formula for both fixed effects and random effects</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>either <code>gaussian</code> or <code>binomial</code> or <code>poisson</code> depending on the model fit</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimates of the regression coefficients</p>
</td></tr>
<tr><td><code>B.se</code></td>
<td>
<p>approximate standard errors of the fixed effects regression coefficients.
This is set to NULL if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code>B.ci</code></td>
<td>
<p>approximate bayesian credible interval of the fixed effects regression coefficients.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>B.cov</code></td>
<td>
<p>approximate covariance matrix for the fixed effects regression coefficients</p>
</td></tr>
<tr><td><code>B.zscore</code></td>
<td>
<p>approximate Z scores for the fixed effects regression coefficients. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>B.pvalue</code></td>
<td>
<p>approximate tests for the fixed effects regression coefficients being different from zero. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>random effects' standard deviations for the covariance matrix <code class="reqn">\sigma^2V</code> for each random effect in order. For the linear mixed model, the residual variance is listed last</p>
</td></tr>
<tr><td><code>s2r</code></td>
<td>
<p>random effects variances for non-nested random effects</p>
</td></tr>
<tr><td><code>s2n</code></td>
<td>
<p>random effects variances for nested random effects</p>
</td></tr>
<tr><td><code>s2resid</code></td>
<td>
<p>for linear mixed models, the residual variance</p>
</td></tr>
<tr><td><code>s2r.ci</code></td>
<td>
<p>Bayesian credible interval for random effects variances for non-nested random effects.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>s2n.ci</code></td>
<td>
<p>Bayesian credible interval for random effects variances for nested random effects.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>s2resid.ci</code></td>
<td>
<p>Bayesian credible interval for linear mixed models, the residual variance.
This is set to NULL if <code>bayes = FALSE</code></p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>for linear mixed models, the log-likelihood for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models. If <code>bayes = TRUE</code>, this is the marginal log-likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>for linear mixed models, the AIC for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>for linear mixed models, the BIC for either the restricted likelihood (<code>REML=TRUE</code>) or the overall likelihood (<code>REML=FALSE</code>). This is set to NULL for generalised linear mixed models</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>for bayesian PGLMM, this is the Deviance Information Criterion metric of model fit. This is set to NULL if <code>bayes = FALSE</code>.</p>
</td></tr>
<tr><td><code>REML</code></td>
<td>
<p>whether or not REML is used (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>bayes</code></td>
<td>
<p>whether or not a Bayesian model was fit.</p>
</td></tr>
<tr><td><code>marginal.summ</code></td>
<td>
<p>The specified summary statistic used to summarise the Bayesian marginal distributions.
Only present if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>s2.init</code></td>
<td>
<p>the user-provided initial estimates of <code>s2</code></p>
</td></tr>
<tr><td><code>B.init</code></td>
<td>
<p>the user-provided initial estimates of <code>B</code></p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the response (dependent) variable returned in matrix form</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the predictor (independent) variables returned in matrix form (including 1s in the first column)</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the residuals. For linear mixed models, this does not account for random terms,
To get residuals after accounting for both fixed and random terms, use <code>residuals()</code>.
For the generalized linear mixed model, these are the predicted residuals in the
logit -1 space.</p>
</td></tr>
<tr><td><code>iV</code></td>
<td>
<p>the inverse of the covariance matrix. This is NULL if <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>predicted mean values for the generalized linear mixed model (i.e. similar to <code>fitted(merMod)</code>).
Set to NULL for linear mixed models, for which we can use <code><a href="stats.html#topic+fitted">fitted()</a></code>.</p>
</td></tr>
<tr><td><code>Zt</code></td>
<td>
<p>the design matrix for random effects. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>St</code></td>
<td>
<p>diagonal matrix that maps the random effects variances onto the design matrix</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p>the convergence code provided by <code><a href="stats.html#topic+optim">optim</a></code>. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations performed by <code><a href="stats.html#topic+optim">optim</a></code>. This is set to NULL if <code>bayes = TRUE</code></p>
</td></tr>
<tr><td><code>inla.model</code></td>
<td>
<p>Model object fit by underlying <code>inla</code> function. Only returned
if <code>bayes = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives, A. R. and Helmus, M. R. (2011) Generalized linear mixed
models for phylogenetic analyses of community structure. <em>Ecological
Monographs</em>, <b>81</b>, 511&ndash;525.
</p>
<p>Ives, A. R. and Garland, T., Jr. (2014) Phylogenetic regression for binary
dependent variables. Pages 231&ndash;261 <em>in</em> L. Z. Garamszegi, editor.
<em>Modern Phylogenetic Comparative Methods and Their Application in
Evolutionary Biology</em>. Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pglmm">pglmm</a></code>; package <span class="pkg">ape</span> and its function <code>binaryPGLMM</code>;
package <span class="pkg">phylolm</span> and its function <code>phyloglm</code>; package <span class="pkg">MCMCglmm</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Illustration of `pglmm_compare` with simulated data

# Generate random phylogeny

library(ape)

n &lt;- 100
phy &lt;- compute.brlen(rtree(n=n), method = "Grafen", power = 1)

# Generate random data and standardize to have mean 0 and variance 1
X1 &lt;- rTraitCont(phy, model = "BM", sigma = 1)
X1 &lt;- (X1 - mean(X1))/var(X1)

# Simulate binary Y
sim.dat &lt;- data.frame(Y = array(0, dim = n), X1 = X1, row.names = phy$tip.label)
sim.dat$Y &lt;- ape::binaryPGLMM.sim(Y ~ X1, phy = phy, data=sim.dat, s2 = 1,
                             B = matrix(c(0, .25), nrow = 2, ncol = 1), 
                             nrep = 1)$Y

# Fit model
pglmm_compare(Y ~ X1, family = "binomial", phy = phy, data = sim.dat)

# Compare with `binaryPGLMM`
ape::binaryPGLMM(Y ~ X1, phy = phy, data = sim.dat)

# Compare with `phyloglm`
summary(phylolm::phyloglm(Y ~ X1, phy = phy, data = sim.dat))

# Compare with `glm` that does not account for phylogeny
summary(glm(Y ~ X1, data = sim.dat, family = "binomial"))

# Compare with logistf() that does not account
# for phylogeny but is less biased than glm()
logistf::logistf(Y ~ X1, data = sim.dat)

## Fit model with bayes = TRUE
# pglmm_compare(Y ~ X1, family = "binomial", phy = phy, data = sim.dat, 
#               bayes = TRUE, calc.DIC = TRUE)

# Compare with `MCMCglmm`

V &lt;- vcv(phy)
V &lt;- V/max(V)
detV &lt;- exp(determinant(V)$modulus[1])
V &lt;- V/detV^(1/n)

invV &lt;- Matrix::Matrix(solve(V),sparse = TRUE)
sim.dat$species &lt;- phy$tip.label
rownames(invV) &lt;- sim.dat$species

nitt &lt;- 43000
thin &lt;- 10
burnin &lt;- 3000

prior &lt;- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=1000, alpha.mu=0, alpha.V=1)))
# commented out to save time
# summary(MCMCglmm::MCMCglmm(Y ~ X1, random = ~species, ginvers = list(species = invV),
#     data = sim.dat, slice = TRUE, nitt = nitt, thin = thin, burnin = burnin,
#    family = "categorical", prior = prior, verbose = FALSE))

</code></pre>

<hr>
<h2 id='pglmm_matrix_structure'><code>pglmm_matrix_structure</code> produces the entire
covariance matrix structure (V) when you specify random effects.</h2><span id='topic+pglmm_matrix_structure'></span><span id='topic+communityPGLMM.matrix.structure'></span>

<h3>Description</h3>

<p><code>pglmm_matrix_structure</code> produces the entire
covariance matrix structure (V) when you specify random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm_matrix_structure(
  formula,
  data = list(),
  family = "binomial",
  cov_ranef,
  repulsion = FALSE,
  ss = 1,
  cpp = TRUE
)

communityPGLMM.matrix.structure(
  formula,
  data = list(),
  family = "binomial",
  cov_ranef,
  repulsion = FALSE,
  ss = 1,
  cpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_matrix_structure_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
mixed effects of the model.
</p>
<p>To specify that a random term should have phylogenetic covariance matrix along
with non-phylogenetic one, add <code>__</code> (two underscores) at the end of the group variable;
e.g., <code>+ (1 | sp__)</code> will construct two random terms,
one with phylogenetic covariance matrix and another with non-phylogenetic (identity) matrix.
In contrast, <code>__</code> in the nested terms (below) will only create a phylogenetic covariance matrix.
Nested random terms have the general form <code>(1|sp__@site__)</code> which represents
phylogenetically related species nested within correlated sites.
This form can be used for bipartite questions. For example, species could be
phylogenetically related pollinators and sites could be phylogenetically related plants, leading to
the random effect <code>(1|insects__@plants__)</code>. If more than one phylogeny is used, remember to add
all to the argument <code>cov_ranef = list(insects = insect_phylo, plants = plant_phylo)</code>. Phylogenetic correlations can
be dropped by removing the <code>__</code> underscores. Thus, the form <code>(1|sp@site__)</code> excludes the phylogenetic
correlations among species, while the form <code>(1|sp__@site)</code> excludes the correlations among sites.
</p>
<p>Note that correlated random terms are not allowed. For example,
<code>(x|g)</code> will be the same as <code>(0 + x|g)</code> in the <code>lme4::lmer</code> syntax. However,
<code>(x1 + x2|g)</code> won't work, so instead use  <code>(x1|g) + (x2|g)</code>.</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_family">family</code></td>
<td>
<p>Either &quot;gaussian&quot; for a Linear Mixed Model, or
&quot;binomial&quot; or &quot;poisson&quot; for Generalized Linear Mixed Models.
&quot;family&quot; should be specified as a character string (i.e., quoted). For binomial and
Poisson data, we use the canonical logit and log link functions, respectively.
Binomial data can be either presence/absence, or a two-column array of 'successes' and 'failures'.
For both binomial  and Poisson data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>. If <code>bayes = TRUE</code> there are
two additional families available: &quot;zeroinflated.binomial&quot;, and &quot;zeroinflated.poisson&quot;,
which add a zero inflation parameter; this parameter gives the probability that the response is
a zero. The rest of the parameters of the model then reflect the &quot;non-zero&quot; part part
of the model. Note that &quot;zeroinflated.binomial&quot; only makes sense for success/failure
response data.</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>A named list of covariance matrices of random terms. The names should be the
group variables that are used as random terms with specified covariance matrices
(without the two underscores, e.g. <code>list(sp = tree1, site = tree2)</code>). The actual object
can be either a phylogeny with class &quot;phylo&quot; or a prepared covariance matrix. If it is a phylogeny,
<code>pglmm</code> will prune it and then convert it to a covariance matrix assuming Brownian motion evolution.
<code>pglmm</code> will also standardize all covariance matrices to have determinant of one. Group variables
will be converted to factors and all covariance matrices will be rearranged so that rows and
columns are in the same order as the levels of their corresponding group variables.</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_repulsion">repulsion</code></td>
<td>
<p>When there are nested random terms specified, <code>repulsion = FALSE</code> tests
for phylogenetic underdispersion while <code>repulsion = FALSE</code> tests for overdispersion.
This argument is a logical vector of length either 1 or &gt;1.
If its length is 1, then all covariance matrices in nested terms will be either
inverted (overdispersion) or not. If its length is &gt;1, then you can select
which covariance matrix in the nested terms to be inverted. Make sure to get
the length right: for all the terms with <code>@</code>, count the number of &quot;__&quot;
to determine the length of repulsion. For example, <code>sp__@site</code> and <code>sp@site__</code>
will each require one element of <code>repulsion</code>, while <code>sp__@site__</code> will take two
elements (repulsion for sp and repulsion for site). Therefore, if your nested terms are
<code>(1|sp__@site) + (1|sp@site__) + (1|sp__@site__)</code>, then you should set the
repulsion to be something like <code>c(TRUE, FALSE, TRUE, TRUE)</code> (length of 4).</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_ss">ss</code></td>
<td>
<p>Which of the <code>random.effects</code> to produce.</p>
</td></tr>
<tr><td><code id="pglmm_matrix_structure_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use C++ function for optim. Default is TRUE. Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix.
</p>

<hr>
<h2 id='pglmm_plot_ranef'>Visualize random terms of communityPGLMMs</h2><span id='topic+pglmm_plot_ranef'></span><span id='topic+pglmm_plot_re'></span><span id='topic+communityPGLMM.show.re'></span><span id='topic+communityPGLMM.plot.re'></span>

<h3>Description</h3>

<p>Plot variance-cov matrix of random terms; also it is optional to simulate and
visualize data based on these var-cov matrices. The input can be a communityPGLMM
model (by setting argument <code>x</code>). If no model has been fitted, you can also specify
data, formula, and family, etc. without actually fitting the model, which will
save time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm_plot_ranef(
  formula = NULL,
  data = NULL,
  family = "gaussian",
  sp.var = "sp",
  site.var = "site",
  tree = NULL,
  tree_site = NULL,
  repulsion = FALSE,
  x = NULL,
  show.image = TRUE,
  show.sim.image = FALSE,
  random.effects = NULL,
  add.tree.sp = TRUE,
  add.tree.site = FALSE,
  cov_ranef = NULL,
  tree.panel.space = 0.5,
  title.space = 5,
  tree.size = 3,
  ...
)

communityPGLMM.show.re(
  formula = NULL,
  data = NULL,
  family = "gaussian",
  sp.var = "sp",
  site.var = "site",
  tree = NULL,
  tree_site = NULL,
  repulsion = FALSE,
  x = NULL,
  show.image = TRUE,
  show.sim.image = FALSE,
  random.effects = NULL,
  add.tree.sp = TRUE,
  add.tree.site = FALSE,
  cov_ranef = NULL,
  tree.panel.space = 0.5,
  title.space = 5,
  tree.size = 3,
  ...
)

pglmm_plot_re(
  formula = NULL,
  data = NULL,
  family = "gaussian",
  sp.var = "sp",
  site.var = "site",
  tree = NULL,
  tree_site = NULL,
  repulsion = FALSE,
  x = NULL,
  show.image = TRUE,
  show.sim.image = FALSE,
  random.effects = NULL,
  add.tree.sp = TRUE,
  add.tree.site = FALSE,
  cov_ranef = NULL,
  tree.panel.space = 0.5,
  title.space = 5,
  tree.size = 3,
  ...
)

communityPGLMM.plot.re(
  formula = NULL,
  data = NULL,
  family = "gaussian",
  sp.var = "sp",
  site.var = "site",
  tree = NULL,
  tree_site = NULL,
  repulsion = FALSE,
  x = NULL,
  show.image = TRUE,
  show.sim.image = FALSE,
  random.effects = NULL,
  add.tree.sp = TRUE,
  add.tree.site = FALSE,
  cov_ranef = NULL,
  tree.panel.space = 0.5,
  title.space = 5,
  tree.size = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_plot_ranef_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
mixed effects of the model.
</p>
<p>To specify that a random term should have phylogenetic covariance matrix along
with non-phylogenetic one, add <code>__</code> (two underscores) at the end of the group variable;
e.g., <code>+ (1 | sp__)</code> will construct two random terms,
one with phylogenetic covariance matrix and another with non-phylogenetic (identity) matrix.
In contrast, <code>__</code> in the nested terms (below) will only create a phylogenetic covariance matrix.
Nested random terms have the general form <code>(1|sp__@site__)</code> which represents
phylogenetically related species nested within correlated sites.
This form can be used for bipartite questions. For example, species could be
phylogenetically related pollinators and sites could be phylogenetically related plants, leading to
the random effect <code>(1|insects__@plants__)</code>. If more than one phylogeny is used, remember to add
all to the argument <code>cov_ranef = list(insects = insect_phylo, plants = plant_phylo)</code>. Phylogenetic correlations can
be dropped by removing the <code>__</code> underscores. Thus, the form <code>(1|sp@site__)</code> excludes the phylogenetic
correlations among species, while the form <code>(1|sp__@site)</code> excludes the correlations among sites.
</p>
<p>Note that correlated random terms are not allowed. For example,
<code>(x|g)</code> will be the same as <code>(0 + x|g)</code> in the <code>lme4::lmer</code> syntax. However,
<code>(x1 + x2|g)</code> won't work, so instead use  <code>(x1|g) + (x2|g)</code>.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_family">family</code></td>
<td>
<p>Either &quot;gaussian&quot; for a Linear Mixed Model, or
&quot;binomial&quot; or &quot;poisson&quot; for Generalized Linear Mixed Models.
&quot;family&quot; should be specified as a character string (i.e., quoted). For binomial and
Poisson data, we use the canonical logit and log link functions, respectively.
Binomial data can be either presence/absence, or a two-column array of 'successes' and 'failures'.
For both binomial  and Poisson data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>. If <code>bayes = TRUE</code> there are
two additional families available: &quot;zeroinflated.binomial&quot;, and &quot;zeroinflated.poisson&quot;,
which add a zero inflation parameter; this parameter gives the probability that the response is
a zero. The rest of the parameters of the model then reflect the &quot;non-zero&quot; part part
of the model. Note that &quot;zeroinflated.binomial&quot; only makes sense for success/failure
response data.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_sp.var">sp.var</code></td>
<td>
<p>The variable name of &quot;species&quot;; y-axis of the image.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_site.var">site.var</code></td>
<td>
<p>The variable name of &quot;site&quot;; x-axis of the image.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_tree">tree</code></td>
<td>
<p>A phylogeny for column sp, with &quot;phylo&quot; class, or a covariance matrix for sp.
Make sure to have all species in the matrix; if the matrix is not standardized,
(i.e., det(tree) != 1), <code>pglmm</code> will try to standardize it for you.
No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_tree_site">tree_site</code></td>
<td>
<p>A second phylogeny for &quot;site&quot;. This is required only if the
site column contains species instead of sites. This can be used for bipartitie
questions; tree_site can also be a covariance matrix. Make sure to have all sites
in the matrix; if the matrix is not standardized (i.e., det(tree_site) != 1),
pglmm' will try to standardize it for you. No longer used: keep here for compatibility.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_repulsion">repulsion</code></td>
<td>
<p>When there are nested random terms specified, <code>repulsion = FALSE</code> tests
for phylogenetic underdispersion while <code>repulsion = FALSE</code> tests for overdispersion.
This argument is a logical vector of length either 1 or &gt;1.
If its length is 1, then all covariance matrices in nested terms will be either
inverted (overdispersion) or not. If its length is &gt;1, then you can select
which covariance matrix in the nested terms to be inverted. Make sure to get
the length right: for all the terms with <code>@</code>, count the number of &quot;__&quot;
to determine the length of repulsion. For example, <code>sp__@site</code> and <code>sp@site__</code>
will each require one element of <code>repulsion</code>, while <code>sp__@site__</code> will take two
elements (repulsion for sp and repulsion for site). Therefore, if your nested terms are
<code>(1|sp__@site) + (1|sp@site__) + (1|sp__@site__)</code>, then you should set the
repulsion to be something like <code>c(TRUE, FALSE, TRUE, TRUE)</code> (length of 4).</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_x">x</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_show.image">show.image</code></td>
<td>
<p>Whether to show the images of random effects.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_show.sim.image">show.sim.image</code></td>
<td>
<p>Whether to show the images of simulated site by sp matrix.
This can be useful to see how the phylogenetic information were included.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_random.effects">random.effects</code></td>
<td>
<p>Optional pre-build list of random effects. If <code>NULL</code> (the default),
the function <code><a href="#topic+prep_dat_pglmm">prep_dat_pglmm</a></code> will prepare the random effects for you from the information
in <code>formula</code>, <code>data</code>, and <code>cov_ranef</code>. <code>random.effect</code> allows a list of
pre-generated random effects terms to increase flexibility; for example, this makes it
possible to construct models with both phylogenetic correlation and spatio-temporal autocorrelation.
In preparing <code>random.effect</code>, make sure that the orders of rows and columns of
covariance matrices in the list are the same as their corresponding group variables
in the data. Also, this should be <em>a list of lists</em>, e.g.
<code>random.effects = list(re1 = list(matrix_a), re2 = list(1, sp = sp, covar = Vsp))</code>.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_add.tree.sp">add.tree.sp</code></td>
<td>
<p>Whether to add a phylogeny of species at the top of the
simulated site by sp matrix plot, default is TRUE.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_add.tree.site">add.tree.site</code></td>
<td>
<p>Whether to add a phylogeny of sites at the right of the
simulated site by sp matrix plot, default is FALSE.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>A named list of covariance matrices of random terms. The names should be the
group variables that are used as random terms with specified covariance matrices
(without the two underscores, e.g. <code>list(sp = tree1, site = tree2)</code>). The actual object
can be either a phylogeny with class &quot;phylo&quot; or a prepared covariance matrix. If it is a phylogeny,
<code>pglmm</code> will prune it and then convert it to a covariance matrix assuming Brownian motion evolution.
<code>pglmm</code> will also standardize all covariance matrices to have determinant of one. Group variables
will be converted to factors and all covariance matrices will be rearranged so that rows and
columns are in the same order as the levels of their corresponding group variables.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_tree.panel.space">tree.panel.space</code></td>
<td>
<p>The number of lines between the phylogeny and
the matrix plot, if add.tree is TRUE.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_title.space">title.space</code></td>
<td>
<p>The number of lines between the title and the matrix plot, if add.tree is TRUE.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_tree.size">tree.size</code></td>
<td>
<p>The height of the phylogeny to be plotted (number of lines), if add.tree is TRUE.</p>
</td></tr>
<tr><td><code id="pglmm_plot_ranef_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>Matrix::image()</code> or <code>lattice::levelplot()</code>.
Common ones are:
</p>

<ul>
<li> <p><code>useAbs</code> whether to use absolute values of the matrix; if no negative values,
this will be set to TRUE if not specified. When <code>useAbs = TRUE</code> the color scheme
will be black-white, otherwise, it will be red/blue.
</p>
</li>
<li> <p><code>colorkey</code> whether to draw the scale legend at the right side of each plot?
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A hidden list, including the covariance matrices and simulated site by species matrices.
Individual plots are saved as <code>plt_re_list</code> and <code>plt_sim_list</code>. If <code>show.image</code> or
<code>show.sim.image</code> is TRUE, the corresponding final plot (<code>plt_re_all_in_one</code> or
<code>plt_sim_all_in_one</code>) can be saved as external file using <code>ggplot2::ggsave</code> as
it is a grid object.
</p>

<hr>
<h2 id='pglmm_predicted_values'>Predicted values of PGLMM</h2><span id='topic+pglmm_predicted_values'></span><span id='topic+communityPGLMM.predicted.values'></span>

<h3>Description</h3>

<p><code>pglmm_predicted_values</code> calculates the predicted
values of Y; for the generalized linear mixed model (family %in%
c(&quot;binomial&quot;,&quot;poisson&quot;), these values are in the transformed space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm_predicted_values(
  x,
  cpp = TRUE,
  gaussian.pred = c("nearest_node", "tip_rm"),
  re.form = NULL,
  type = c("link", "response"),
  ...
)

communityPGLMM.predicted.values(
  x,
  cpp = TRUE,
  gaussian.pred = c("nearest_node", "tip_rm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_predicted_values_+3A_x">x</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="pglmm_predicted_values_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use c++ code. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pglmm_predicted_values_+3A_gaussian.pred">gaussian.pred</code></td>
<td>
<p>When family is gaussian, which type of prediction to calculate?
Option nearest_node will predict values to the nearest node, which is same as lme4::predict or
fitted. Option tip_rm will remove the point then predict the value of this point with remaining ones.</p>
</td></tr>
<tr><td><code id="pglmm_predicted_values_+3A_re.form">re.form</code></td>
<td>
<p>(formula, <code>NULL</code>, or <code>NA</code>) specify which random effects to condition on when predicting.
If <code>NULL</code>, include all random effects (i.e Xb + Zu);
if <code>NA</code> or <code>~0</code>, include no random effects (i.e. Xb).</p>
</td></tr>
<tr><td><code id="pglmm_predicted_values_+3A_type">type</code></td>
<td>
<p>character string - either <code>"link"</code>, the default, or
<code>"response"</code> indicating the type of prediction object returned.</p>
</td></tr>
<tr><td><code id="pglmm_predicted_values_+3A_...">...</code></td>
<td>
<p>Optional additional parameters. None are used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with column Y_hat (predicted values accounting for
both fixed and random terms).
</p>

<hr>
<h2 id='pglmm_profile_LRT'><code>pglmm_profile_LRT</code> tests statistical significance of the
phylogenetic random effect of binomial models on
species slopes using a likelihood ratio test.</h2><span id='topic+pglmm_profile_LRT'></span><span id='topic+communityPGLMM.profile.LRT'></span>

<h3>Description</h3>

<p><code>pglmm_profile_LRT</code> tests statistical significance of the
phylogenetic random effect of binomial models on
species slopes using a likelihood ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pglmm_profile_LRT(x, re.number = 0, cpp = TRUE)

communityPGLMM.profile.LRT(x, re.number = 0, cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pglmm_profile_LRT_+3A_x">x</code></td>
<td>
<p>A fitted model with class communityPGLMM and family &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="pglmm_profile_LRT_+3A_re.number">re.number</code></td>
<td>
<p>Which random term to test? Can be a vector with length &gt;1</p>
</td></tr>
<tr><td><code id="pglmm_profile_LRT_+3A_cpp">cpp</code></td>
<td>
<p>Whether to use C++ function for optim. Default is TRUE. Ignored if <code>bayes = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of likelihood, df, and p-value.
</p>

<hr>
<h2 id='phylotree'>Example phylogeny</h2><span id='topic+phylotree'></span>

<h3>Description</h3>

<p>A phylogeny with more species than the community data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylotree
</code></pre>


<h3>Format</h3>

<p>Newick format.
</p>

<hr>
<h2 id='plot_bayes'>plot_bayes generic</h2><span id='topic+plot_bayes'></span>

<h3>Description</h3>

<p>plot_bayes generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bayes(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bayes_+3A_x">x</code></td>
<td>
<p>A communityPGLMM object fit with <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_bayes_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot_data'>Plot the original dataset and predicted values (optional)</h2><span id='topic+plot_data'></span><span id='topic+plot_bayes.communityPGLMM'></span>

<h3>Description</h3>

<p>Plots a representation of the marginal posterior distribution of model parameters. Note this
function requires the packages <code>ggplot2</code> and <code>ggridges</code> to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_data(
  x,
  sp.var = "sp",
  site.var = "site",
  show.sp.names = FALSE,
  show.site.names = FALSE,
  digits = max(3, getOption("digits") - 3),
  predicted = FALSE,
  ...
)

## S3 method for class 'communityPGLMM'
plot_bayes(x, n_samp = 1000, sort = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_data_+3A_x">x</code></td>
<td>
<p>A communityPGLMM object fit with <code>bayes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_sp.var">sp.var</code></td>
<td>
<p>The variable name of &quot;species&quot;; y-axis of the image.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_site.var">site.var</code></td>
<td>
<p>The variable name of &quot;site&quot;; x-axis of the image.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_show.sp.names">show.sp.names</code></td>
<td>
<p>Whether to print species names as y-axis labels.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_show.site.names">show.site.names</code></td>
<td>
<p>Whether to print site names as x-axis labels.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_digits">digits</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_predicted">predicted</code></td>
<td>
<p>Whether to plot predicted values side by side with observed ones.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to or from other methods.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_n_samp">n_samp</code></td>
<td>
<p>Number of sample from the marginal posterior to take in order to estimate the posterior density.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_sort">sort</code></td>
<td>
<p>Whether to plot different terms in the order of their estimations. Default is 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Note</h3>

<p>The underlying plot grid object is returned but invisible. It can be saved for later uses.
</p>

<hr>
<h2 id='predict.communityPGLMM'>Predict Function for communityPGLMM Model Objects</h2><span id='topic+predict.communityPGLMM'></span>

<h3>Description</h3>

<p>Predict Function for communityPGLMM Model Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.communityPGLMM_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"lm"</code></p>
</td></tr>
<tr><td><code id="predict.communityPGLMM_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict.  If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.communityPGLMM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>predict</code> depends on the
class of its argument.  See the documentation of the
particular methods for details of what is produced by that method.
</p>

<hr>
<h2 id='prep_dat_pglmm'>Prepare data for <code>pglmm</code></h2><span id='topic+prep_dat_pglmm'></span>

<h3>Description</h3>

<p>This function is mainly used within <code>pglmm</code> but can also be used independently to
prepare a list of random effects, which then can be updated by users for more complex models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_dat_pglmm(
  formula,
  data,
  cov_ranef = NULL,
  repulsion = FALSE,
  prep.re.effects = TRUE,
  family = "gaussian",
  add.obs.re = TRUE,
  bayes = FALSE,
  bayes_nested_matrix_as_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_dat_pglmm_+3A_formula">formula</code></td>
<td>
<p>A two-sided linear formula object describing the
mixed effects of the model.
</p>
<p>To specify that a random term should have phylogenetic covariance matrix along
with non-phylogenetic one, add <code>__</code> (two underscores) at the end of the group variable;
e.g., <code>+ (1 | sp__)</code> will construct two random terms,
one with phylogenetic covariance matrix and another with non-phylogenetic (identity) matrix.
In contrast, <code>__</code> in the nested terms (below) will only create a phylogenetic covariance matrix.
Nested random terms have the general form <code>(1|sp__@site__)</code> which represents
phylogenetically related species nested within correlated sites.
This form can be used for bipartite questions. For example, species could be
phylogenetically related pollinators and sites could be phylogenetically related plants, leading to
the random effect <code>(1|insects__@plants__)</code>. If more than one phylogeny is used, remember to add
all to the argument <code>cov_ranef = list(insects = insect_phylo, plants = plant_phylo)</code>. Phylogenetic correlations can
be dropped by removing the <code>__</code> underscores. Thus, the form <code>(1|sp@site__)</code> excludes the phylogenetic
correlations among species, while the form <code>(1|sp__@site)</code> excludes the correlations among sites.
</p>
<p>Note that correlated random terms are not allowed. For example,
<code>(x|g)</code> will be the same as <code>(0 + x|g)</code> in the <code>lme4::lmer</code> syntax. However,
<code>(x1 + x2|g)</code> won't work, so instead use  <code>(x1|g) + (x2|g)</code>.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables named in formula.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>A named list of covariance matrices of random terms. The names should be the
group variables that are used as random terms with specified covariance matrices
(without the two underscores, e.g. <code>list(sp = tree1, site = tree2)</code>). The actual object
can be either a phylogeny with class &quot;phylo&quot; or a prepared covariance matrix. If it is a phylogeny,
<code>pglmm</code> will prune it and then convert it to a covariance matrix assuming Brownian motion evolution.
<code>pglmm</code> will also standardize all covariance matrices to have determinant of one. Group variables
will be converted to factors and all covariance matrices will be rearranged so that rows and
columns are in the same order as the levels of their corresponding group variables.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_repulsion">repulsion</code></td>
<td>
<p>When there are nested random terms specified, <code>repulsion = FALSE</code> tests
for phylogenetic underdispersion while <code>repulsion = FALSE</code> tests for overdispersion.
This argument is a logical vector of length either 1 or &gt;1.
If its length is 1, then all covariance matrices in nested terms will be either
inverted (overdispersion) or not. If its length is &gt;1, then you can select
which covariance matrix in the nested terms to be inverted. Make sure to get
the length right: for all the terms with <code>@</code>, count the number of &quot;__&quot;
to determine the length of repulsion. For example, <code>sp__@site</code> and <code>sp@site__</code>
will each require one element of <code>repulsion</code>, while <code>sp__@site__</code> will take two
elements (repulsion for sp and repulsion for site). Therefore, if your nested terms are
<code>(1|sp__@site) + (1|sp@site__) + (1|sp__@site__)</code>, then you should set the
repulsion to be something like <code>c(TRUE, FALSE, TRUE, TRUE)</code> (length of 4).</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_prep.re.effects">prep.re.effects</code></td>
<td>
<p>Whether to prepare random effects for users.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_family">family</code></td>
<td>
<p>Either &quot;gaussian&quot; for a Linear Mixed Model, or
&quot;binomial&quot; or &quot;poisson&quot; for Generalized Linear Mixed Models.
&quot;family&quot; should be specified as a character string (i.e., quoted). For binomial and
Poisson data, we use the canonical logit and log link functions, respectively.
Binomial data can be either presence/absence, or a two-column array of 'successes' and 'failures'.
For both binomial  and Poisson data, we add an observation-level
random term by default via <code>add.obs.re = TRUE</code>. If <code>bayes = TRUE</code> there are
two additional families available: &quot;zeroinflated.binomial&quot;, and &quot;zeroinflated.poisson&quot;,
which add a zero inflation parameter; this parameter gives the probability that the response is
a zero. The rest of the parameters of the model then reflect the &quot;non-zero&quot; part part
of the model. Note that &quot;zeroinflated.binomial&quot; only makes sense for success/failure
response data.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_add.obs.re">add.obs.re</code></td>
<td>
<p>Whether to add an observation-level random term for binomial or Poisson
distributions. Normally it would be a good idea to add this to account for overdispersion,
so <code>add.obs.re = TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_bayes">bayes</code></td>
<td>
<p>Whether to fit a Bayesian version of the PGLMM using <code>r-inla</code>.</p>
</td></tr>
<tr><td><code id="prep_dat_pglmm_+3A_bayes_nested_matrix_as_list">bayes_nested_matrix_as_list</code></td>
<td>
<p>For <code>bayes = TRUE</code>, prepare the nested terms as a list of length of 4 as the old way?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with updated formula, random.effects, and updated cov_ranef.
</p>

<hr>
<h2 id='print.communityPGLMM'>Print summary information of fitted model</h2><span id='topic+print.communityPGLMM'></span>

<h3>Description</h3>

<p>Print summary information of fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.communityPGLMM_+3A_x">x</code></td>
<td>
<p>A fitted communityPGLMM model.</p>
</td></tr>
<tr><td><code id="print.communityPGLMM_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits for printing, as in <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.communityPGLMM_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.pglmm_compare'>Print summary information of fitted model</h2><span id='topic+print.pglmm_compare'></span>

<h3>Description</h3>

<p>Print summary information of fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pglmm_compare'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pglmm_compare_+3A_x">x</code></td>
<td>
<p>A fitted pglmm_compare.</p>
</td></tr>
<tr><td><code id="print.pglmm_compare_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits for printing, as in <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.pglmm_compare_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='psv'>Phylogenetic Species Diversity Metrics</h2><span id='topic+psv'></span><span id='topic+psr'></span><span id='topic+pse'></span><span id='topic+psc'></span><span id='topic+psv.spp'></span><span id='topic+psd'></span>

<h3>Description</h3>

<p>Calculate the bounded phylogenetic biodiversity metrics:
phylogenetic species variability, richness, evenness and clustering for one or multiple communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psv(
  comm,
  tree,
  compute.var = TRUE,
  scale.vcv = TRUE,
  prune.tree = FALSE,
  cpp = TRUE
)

psr(
  comm,
  tree,
  compute.var = TRUE,
  scale.vcv = TRUE,
  prune.tree = FALSE,
  cpp = TRUE
)

pse(comm, tree, scale.vcv = TRUE, prune.tree = FALSE, cpp = TRUE)

psc(comm, tree, scale.vcv = TRUE, prune.tree = FALSE)

psv.spp(comm, tree, scale.vcv = TRUE, prune.tree = FALSE, cpp = TRUE)

psd(
  comm,
  tree,
  compute.var = TRUE,
  scale.vcv = TRUE,
  prune.tree = FALSE,
  cpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psv_+3A_comm">comm</code></td>
<td>
<p>Community data matrix, site as rows and species as columns, site names as row names.</p>
</td></tr>
<tr><td><code id="psv_+3A_tree">tree</code></td>
<td>
<p>A phylo tree object with class &quot;phylo&quot; or a phylogenetic covariance matrix.</p>
</td></tr>
<tr><td><code id="psv_+3A_compute.var">compute.var</code></td>
<td>
<p>Logical, default is TRUE, computes the expected variances
for PSV and PSR for each community.</p>
</td></tr>
<tr><td><code id="psv_+3A_scale.vcv">scale.vcv</code></td>
<td>
<p>Logical, default is TRUE, scale the phylogenetic covariance
matrix to bound the metric between 0 and 1 (i.e. correlations).</p>
</td></tr>
<tr><td><code id="psv_+3A_prune.tree">prune.tree</code></td>
<td>
<p>Logical, default is FALSE, prune the phylogeny before converting
to var-cov matrix? Pruning and then converting VS converting then subsetting may
have different var-cov matrix resulted.</p>
</td></tr>
<tr><td><code id="psv_+3A_cpp">cpp</code></td>
<td>
<p>Logical, default is TRUE, whether to use cpp for internal calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Phylogenetic species variability (PSV)</em> quantifies how
phylogenetic relatedness decreases the variance of a hypothetical
unselected/neutral trait shared by all species in a community.
The expected value of PSV is statistically independent of species richness,
is one when all species in a community are unrelated (i.e., a star phylogeny)
and approaches zero as species become more related. PSV is directly related
to mean phylogenetic distance, except except calculated on a scaled phylogenetic
covariance matrix. The expected variance around PSV for any community of a particular
species richness can be approximated. To address how individual species
contribute to the mean PSV of a data set, the function <code>psv.spp</code> gives
signed proportions of the total deviation from the mean PSV that occurs when
all species are removed from the data set one at a time. The absolute values
of these &ldquo;species effects&rdquo; tend to positively correlate with species prevalence.
</p>


<h3>Value</h3>

<p>Returns a dataframe of the respective phylogenetic species diversity metric values
</p>


<h3>Note</h3>

<p>These metrics are bounded either between zero and one (PSV, PSE, PSC)
or zero and species richness (PSR); but the metrics asymptotically approach
zero as relatedness increases. Zero can be assigned to communities with less
than two species, but conclusions drawn from assigning communities zero values
need be carefully explored for any data set. The data sets need not be
species-community data sets but may be any community data set with an associated phylogeny.
</p>


<h3>Author(s)</h3>

<p>Matthew Helmus <a href="mailto:mrhelmus@gmail.com">mrhelmus@gmail.com</a>
</p>


<h3>References</h3>

<p>Helmus M.R., Bland T.J., Williams C.K. &amp; Ives A.R. 2007.
Phylogenetic measures of biodiversity. American Naturalist, 169, E68-E83
</p>


<h3>Examples</h3>

<pre><code class='language-R'>psv(comm = comm_a, tree = phylotree) 
</code></pre>

<hr>
<h2 id='ranef'>Extract random-effects estimates</h2><span id='topic+ranef'></span><span id='topic+ranef.communityPGLMM'></span><span id='topic+random.effects'></span>

<h3>Description</h3>

<p>Extract the random-effects estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the random-effects parameters from a fitted model.
</p>


<h3>Value</h3>

<p>A dataframe of random-effects estimates.
</p>

<hr>
<h2 id='refit_boots'>Refit bootstrap replicates that failed to converge in a call to <code>cor_phylo</code></h2><span id='topic+refit_boots'></span><span id='topic+print.cp_refits'></span>

<h3>Description</h3>

<p>This function is to be called on a <code>cor_phylo</code> object if when one or more bootstrap
replicates fail to converge.
It allows the user to change parameters for the optimizer to get it to converge.
One or more of the resulting <code>cp_refits</code> object(s) can be supplied to
<code>boot_ci</code> along with the original <code>cor_phylo</code> object to calculate confidence
intervals from only bootstrap replicates that converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit_boots(cp_obj, inds = NULL, ...)

## S3 method for class 'cp_refits'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_boots_+3A_cp_obj">cp_obj</code></td>
<td>
<p>The original <code>cor_phylo</code> object that was bootstrapped.</p>
</td></tr>
<tr><td><code id="refit_boots_+3A_inds">inds</code></td>
<td>
<p>Vector of indices indicating the bootstraps you want to refit.
This is useful if you want to try refitting only a portion of bootstrap
replicates.
By passing <code>NULL</code>, it refits all bootstrap replicates present in
<code>cp_obj$bootstrap$mats</code>.
Any bootstrap replicates not present in <code>inds</code> will have <code>NA</code> in the output
object.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="refit_boots_+3A_...">...</code></td>
<td>
<p>Arguments that should be changed from the original call to <code>cor_phylo</code>.
The <code>boot</code> argument is always set to <code>0</code> for refits because you don't want
to bootstrap your bootstraps.</p>
</td></tr>
<tr><td><code id="refit_boots_+3A_x">x</code></td>
<td>
<p>an object of class <code>cp_refits</code>.</p>
</td></tr>
<tr><td><code id="refit_boots_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cp_refits</code> object, which is a list of <code>cor_phylo</code> objects
corresponding to each matrix in <code style="white-space: pre;">&#8288;&lt;original cor_phylo object&gt;$bootstrap$mats&#8288;</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print</code>: prints <code>cp_refits</code> objects
</p>
</li></ul>

<hr>
<h2 id='residuals.communityPGLMM'>Residuals of communityPGLMM objects</h2><span id='topic+residuals.communityPGLMM'></span>

<h3>Description</h3>

<p>Getting different types of residuals for communityPGLMM objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
residuals(
  object,
  type = if (object$family %in% c("binomial", "poisson")) "deviance" else "response",
  scaled = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.communityPGLMM_+3A_object">object</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="residuals.communityPGLMM_+3A_type">type</code></td>
<td>
<p>Type of residuals, currently only &quot;response&quot; for gaussian pglmm;
&quot;deviance&quot; (default) and &quot;response&quot; for binomial and poisson pglmm.</p>
</td></tr>
<tr><td><code id="residuals.communityPGLMM_+3A_scaled">scaled</code></td>
<td>
<p>Scale residuals by residual standard deviation for gaussian pglmm.</p>
</td></tr>
<tr><td><code id="residuals.communityPGLMM_+3A_...">...</code></td>
<td>
<p>Additional arguments, ignored for method compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>

<hr>
<h2 id='rm_site_noobs'>Remove site that has no observations of any species</h2><span id='topic+rm_site_noobs'></span>

<h3>Description</h3>

<p>This function will remove site that has no observations in a site by species data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_site_noobs(df, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_site_noobs_+3A_df">df</code></td>
<td>
<p>A data frame in wide form, i.e. site by species data frame, with site names as row name.</p>
</td></tr>
<tr><td><code id="rm_site_noobs_+3A_warn">warn</code></td>
<td>
<p>Whether to warn when any site has no species? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A site by species data frame.
</p>


<h3>Author(s)</h3>

<p>Daijiang Li
</p>

<hr>
<h2 id='rm_sp_noobs'>Remove species that not observed in any site</h2><span id='topic+rm_sp_noobs'></span>

<h3>Description</h3>

<p>Remove species that not observed in any site
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_sp_noobs(df, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_sp_noobs_+3A_df">df</code></td>
<td>
<p>A data frame in wide form, i.e. site by species data frame, with site names as row name.</p>
</td></tr>
<tr><td><code id="rm_sp_noobs_+3A_warn">warn</code></td>
<td>
<p>Whether to warn when any species does not occur in at least one site? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A site by species data frame.
</p>


<h3>Author(s)</h3>

<p>Daijiang Li
</p>
<p>This function will remove species that has no observations in any site.
</p>

<hr>
<h2 id='simulate.communityPGLMM'>Simulate from a communityPGLMM object</h2><span id='topic+simulate.communityPGLMM'></span>

<h3>Description</h3>

<p>Note that this function currently only works for model fit with <code>bayes = TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
simulate(object, nsim = 1, seed = NULL, re.form = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.communityPGLMM_+3A_object">object</code></td>
<td>
<p>A fitted model object with class 'communityPGLMM'.</p>
</td></tr>
<tr><td><code id="simulate.communityPGLMM_+3A_nsim">nsim</code></td>
<td>
<p>positive integer scalar - the number of responses to simulate.</p>
</td></tr>
<tr><td><code id="simulate.communityPGLMM_+3A_seed">seed</code></td>
<td>
<p>an optional seed to be used in <code><a href="base.html#topic+set.seed">set.seed</a></code>
immediately before the simulation so as to generate a reproducible sample.</p>
</td></tr>
<tr><td><code id="simulate.communityPGLMM_+3A_re.form">re.form</code></td>
<td>
<p>(formula, <code>NULL</code>, or <code>NA</code>) specify which random effects to condition on when predicting.
If <code>NULL</code>, include all random effects and the conditional modes of those random effects will be included in the deterministic part of the simulation (i.e Xb + Zu);
if <code>NA</code> or <code>~0</code>, include no random effects and new values will be chosen for each group based on the estimated random-effects variances (i.e. Xb + Zu * u_random).</p>
</td></tr>
<tr><td><code id="simulate.communityPGLMM_+3A_...">...</code></td>
<td>
<p>optional additional arguments: none are used at present.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.communityPGLMM'>Summary information of fitted model</h2><span id='topic+summary.communityPGLMM'></span>

<h3>Description</h3>

<p>Summary information of fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'communityPGLMM'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.communityPGLMM_+3A_object">object</code></td>
<td>
<p>A fitted model with class communityPGLMM.</p>
</td></tr>
<tr><td><code id="summary.communityPGLMM_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits for printing, as in <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="summary.communityPGLMM_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.pglmm_compare'>Summary information of fitted pglmm_compare model</h2><span id='topic+summary.pglmm_compare'></span>

<h3>Description</h3>

<p>Summary information of fitted pglmm_compare model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pglmm_compare'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pglmm_compare_+3A_object">object</code></td>
<td>
<p>A fitted model with class pglmm_compare.</p>
</td></tr>
<tr><td><code id="summary.pglmm_compare_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits for printing, as in <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="summary.pglmm_compare_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='traits'>Example species traits data</h2><span id='topic+traits'></span>

<h3>Description</h3>

<p>A data frame of species functional traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 species and 3 variables: sla,
height, and seed dispersal mode.
</p>

<hr>
<h2 id='vcv2'>Create phylogenetic var-cov matrix</h2><span id='topic+vcv2'></span>

<h3>Description</h3>

<p>This function will convert a phylogeny to a Var-cov matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcv2(phy, corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcv2_+3A_phy">phy</code></td>
<td>
<p>A phylogeny with &quot;phylo&quot; as class.</p>
</td></tr>
<tr><td><code id="vcv2_+3A_corr">corr</code></td>
<td>
<p>Whether to return a correlation matrix instead of Var-cov matrix. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylogenetic var-cov matrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
