<!DOCTYPE html><html lang="en"><head><title>Help for package PTSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PTSR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ddist'><p>Reparametrized Distributions</p></a></li>
<li><a href='#predict.ptsr'><p>Predict method for PTSR</p></a></li>
<li><a href='#print.ptsr'><p>Print Method of class PTSR</p></a></li>
<li><a href='#ptsr.fit'><p>Title Function to fit a PTSR model</p></a></li>
<li><a href='#ptsr.link'><p>Create a Link for PTSR models</p></a></li>
<li><a href='#ptsr.sim'><p>Function to simulate a PTSR model</p></a></li>
<li><a href='#summary'><p>Summary Method of class PTSR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Positive Time Series Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>extraDistr, SuppDists, actuar, numDeriv</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to simulate, estimate and forecast a wide range of regression based dynamic models for positive time series. 
	This package implements the results presented in Prass, T.S.; Carlos, J.H.; Taufemback, C.G. and Pumi, G. (2022). "Positive Time Series Regression" &lt;<a href="https://doi.org/10.48550/arXiv.2201.03667">doi:10.48550/arXiv.2201.03667</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-07 21:58:09 UTC; Taiane</td>
</tr>
<tr>
<td>Author:</td>
<td>Taiane Schaedler Prass
    <a href="https://orcid.org/0000-0003-3136-909X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    com],
  Jonas Hendler Carlos [aut],
  Cleiton Guollo Taufemback [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taiane Schaedler Prass &lt;taianeprass@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-08 07:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ddist'>Reparametrized Distributions</h2><span id='topic+ddist'></span><span id='topic+rdist'></span><span id='topic+d.betap'></span><span id='topic+r.betap'></span><span id='topic+d.F'></span><span id='topic+r.F'></span><span id='topic+d.gamma'></span><span id='topic+r.gamma'></span><span id='topic+d.invGauss'></span><span id='topic+r.invGauss'></span><span id='topic+d.logLogis'></span><span id='topic+r.logLogis'></span><span id='topic+d.logNorm'></span><span id='topic+r.logNorm'></span><span id='topic+d.chi'></span><span id='topic+r.chi'></span><span id='topic+d.ray'></span><span id='topic+r.ray'></span>

<h3>Description</h3>

<p>Density function and random numbers generation for models with support on the positive real line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.betap(x, mu, varphi, log = FALSE)

r.betap(n, mu, varphi)

d.F(x, mu, varphi, log = FALSE)

r.F(n, mu, varphi)

d.gamma(x, mu, varphi, log = FALSE)

r.gamma(n, mu, varphi)

d.invGauss(x, mu, varphi, log = FALSE)

r.invGauss(n, mu, varphi)

d.logLogis(x, mu, varphi, log = FALSE)

r.logLogis(n, mu, varphi)

d.logNorm(x, mu, varphi, log = FALSE)

r.logNorm(n, mu, varphi)

d.chi(x, mu, log = FALSE, ...)

r.chi(n, mu, ...)

d.ray(x, mu, log = FALSE, ...)

r.ray(n, mu, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ddist_+3A_x">x</code></td>
<td>
<p>vector of real values</p>
</td></tr>
<tr><td><code id="ddist_+3A_mu">mu</code></td>
<td>
<p>non-negative parameter (the distribution's mean. See &lsquo;Details&rsquo;)</p>
</td></tr>
<tr><td><code id="ddist_+3A_varphi">varphi</code></td>
<td>
<p>non-negative parameter</p>
</td></tr>
<tr><td><code id="ddist_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">log(p)</code>.</p>
</td></tr>
<tr><td><code id="ddist_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ddist_+3A_...">...</code></td>
<td>
<p>for compatibility with other functions</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For the reparametrized Beta-Prime distribution, the functions <a href="extraDistr.html#topic+BetaPrime">dbetapr</a> and <a href="extraDistr.html#topic+BetaPrime">rbetapr</a> are imported from the package <code><a href="extraDistr.html#topic+extraDistr">extraDistr</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">shape1 = mu*varphi</code>
</p>

<p style="text-align: center;"><code class="reqn">shape2 = varphi + 1</code>
</p>

<p style="text-align: center;"><code class="reqn">scale = 1</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized F distribution, the functions <a href="stats.html#topic+Fdist">df</a> and  <a href="stats.html#topic+Fdist">rf</a> are imported from <code><a href="stats.html#topic+stats">stats</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">df1 = varphi</code>
</p>

<p style="text-align: center;"><code class="reqn">df2 = 2*mu/(mu - 1)</code>
</p>

<p>so that the parameter <code class="reqn">\mu</code> must satisfy <code class="reqn">\mu &gt; 1</code>.
</p>
</li></ul>


<ul>
<li><p> For the reparametrized Gamma distribution, the functions <a href="stats.html#topic+GammaDist">dgamma</a> and  <a href="stats.html#topic+GammaDist">rgamma</a> are imported from <code><a href="stats.html#topic+stats">stats</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">shape = varphi</code>
</p>

<p style="text-align: center;"><code class="reqn">rate = varphi/mu</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized Inverse Gaussian distribution, the functions <a href="SuppDists.html#topic+invGauss">dinvGauss</a> and <a href="SuppDists.html#topic+invGauss">rinvGauss</a> are imported from <code>SuppDists</code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">nu = mu</code>
</p>

<p style="text-align: center;"><code class="reqn">lambda = 1/varphi</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized Log-logistic distribution, the functions <a href="actuar.html#topic+Loglogistic">dllogis</a> and <a href="actuar.html#topic+Loglogistic">rllogis</a> a are imported from <code>actuar</code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">shape = varphi</code>
</p>

<p style="text-align: center;"><code class="reqn">rate = (pi/varphi)/(mu*sin(pi/varphi))</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized Log-Normal distribution, the functions <a href="stats.html#topic+Lognormal">dlnorm</a> and <a href="stats.html#topic+Lognormal">rlnorm</a> are imported from <code><a href="stats.html#topic+stats">stats</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">meanlog = log(mu) - varphi^2/2</code>
</p>

<p style="text-align: center;"><code class="reqn">sdlog = varphi</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized Chi-squared F distribution, the functions <a href="stats.html#topic+Chisquare">dchisq</a> and <a href="stats.html#topic+Chisquare">rchisq</a> are imported from <code><a href="stats.html#topic+stats">stats</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">df = mu</code>
</p>

</li></ul>


<ul>
<li><p> For the reparametrized Rayleigh distribution, the functions <a href="extraDistr.html#topic+Rayleigh">drayleigh</a> and <a href="extraDistr.html#topic+Rayleigh">rrayleigh</a> are imported from <code><a href="extraDistr.html#topic+extraDistr">extraDistr</a></code>. The following holds
</p>
<p style="text-align: center;"><code class="reqn">sigma = mu/sqrt(pi/2)</code>
</p>

</li></ul>



<h3>Value</h3>

<p>For any avaliable <code>dist</code>, <code>ddist</code> gives the density and <code>rdist</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rdist</code>, and is the maximum of the lengths of the numerical arguments for <code>rdist</code>.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>

<hr>
<h2 id='predict.ptsr'>Predict method for PTSR</h2><span id='topic+predict.ptsr'></span>

<h3>Description</h3>

<p>Predicted values based on ptsr object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptsr'
predict(object, newdata, nnew = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ptsr_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"ptsr"</code></p>
</td></tr>
<tr><td><code id="predict.ptsr_+3A_newdata">newdata</code></td>
<td>
<p>A matrix with new values for the regressors.   If omitted
and <code>"xreg"</code> is present in the model, the fitted values are returned.
If the model does not include regressors, the functions will use
the value of <code>nnew</code>.</p>
</td></tr>
<tr><td><code id="predict.ptsr_+3A_nnew">nnew</code></td>
<td>
<p>number of out-of-sample forecasts required. If <code>newdata</code> is
provided, <code>nnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="predict.ptsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.ptsr</code> produces predicted values, obtained by evaluating
the regression function in the frame <code>newdata</code>.
</p>
<p>If <code>newdata</code> is omitted the predictions are based on the data
used for the fit.
</p>
<p>For now, prediction intervals are not provided.
</p>


<h3>Value</h3>

<p>A list with the following arguments
</p>
<table role = "presentation">
<tr><td><code>series</code></td>
<td>
<p>The original time series yt.</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The original regressors (if any).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The in-sample forecast given by <code class="reqn">\mu_t</code>.</p>
</td></tr>
<tr><td><code>etat</code></td>
<td>
<p>In-sample values of <code class="reqn">g(\mu[t])</code>.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>The error term</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The (in-sample) residuals, that is, the observed minus the predicted values.</p>
</td></tr>
<tr><td><code>forecast</code></td>
<td>
<p>The predicted values for yt.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ptsr'>Print Method of class PTSR</h2><span id='topic+print.ptsr'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>ptsr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptsr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ptsr_+3A_x">x</code></td>
<td>
<p>object of class <code>ptsr</code>.</p>
</td></tr>
<tr><td><code id="print.ptsr_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.ptsr_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users are not encouraged to call these internal functions directly.
Internal functions for package PTSR.
</p>


<h3>Value</h3>

<p>Invisibly returns its argument, <code>x</code>.
</p>

<hr>
<h2 id='ptsr.fit'>Title Function to fit a PTSR model</h2><span id='topic+ptsr.fit'></span>

<h3>Description</h3>

<p>Title Function to fit a PTSR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptsr.fit(start, yt, xreg = NULL, xregar = TRUE, fit.alpha = TRUE,
  p = 0, q = 0, arlag = NULL, malag = NULL, ddist = d.gamma,
  link1 = "log", link2 = "identity", g1 = NULL, g1.inv = NULL,
  g2 = NULL, method = "L-BFGS-B", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptsr.fit_+3A_start">start</code></td>
<td>
<p>a vector with the starting values for the non-fixed coefficients
of the model.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_yt">yt</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_xregar">xregar</code></td>
<td>
<p>logical, if <code>FALSE</code>, the regressors are not included in the
AR component of the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_fit.alpha">fit.alpha</code></td>
<td>
<p>logical, if FALSE, alpha is set to zero. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_p">p</code></td>
<td>
<p>order of the AR polinomial</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_q">q</code></td>
<td>
<p>order of the MA polinomial</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_arlag">arlag</code></td>
<td>
<p>the lags to be included in the AR polinomial. Default is <code>NULL</code>, meaning that all lags will be included.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_malag">malag</code></td>
<td>
<p>the lags to be included in the MA polinomial. Default is <code>NULL</code>, meaning that all lags will be included.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_ddist">ddist</code></td>
<td>
<p>function, the density function to be used</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_link1">link1</code></td>
<td>
<p>character indicating which link must be used for <code class="reqn">\mu_t</code>.  See <code><a href="#topic+ptsr.link">ptsr.link</a></code> for available links. Default is &lsquo;log&rsquo;.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_link2">link2</code></td>
<td>
<p>character indicating which link must be used for <code class="reqn">y_t</code> in the AR recursion.  See <code><a href="#topic+ptsr.link">ptsr.link</a></code> for available links. Default is &lsquo;identity&rsquo;.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_g1">g1</code></td>
<td>
<p>optionally, a link function to be used  for <code class="reqn">\mu_t</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link1</code>.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_g1.inv">g1.inv</code></td>
<td>
<p>optionally, a the inverse link function to be used  for <code class="reqn">\eta_t</code>. It must the the ivnerse of <code>g1</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link1</code>.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_g2">g2</code></td>
<td>
<p>optionally, a link function to be used  for <code class="reqn">y_t</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link2</code>.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_method">method</code></td>
<td>
<p>The method to be used. See [optim][stats::optim] for details.</p>
</td></tr>
<tr><td><code id="ptsr.fit_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>optim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same arguments return by <code>optim</code> plus a the  following arguments
</p>

<ul>
<li> <p><code>coefficients</code>: a vector with the estimated coefficients;
</p>
</li>
<li> <p><code>sll</code>: the sum of the log-likelihood for the fitted model;
</p>
</li>
<li> <p><code>series</code>: the original time series;
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if any);
</p>
</li>
<li> <p><code>fitted.values</code>:  the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values;
</p>
</li>
<li> <p><code>residuals</code>: the observed minus the fitted values;
</p>
</li>
<li> <p><code>model</code>: a list with the configurations used to fit the model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------
# Gamma-ARMA(1,1) model with no regressors
#-------------------------------------------------------------------

simu = ptsr.sim(n = 3000, burn = 50,
                varphi = 20, alpha = 0,
                phi = 0.35, theta = 0.2,
                seed = 1234, rdist = r.gamma,
                link1 = "log", link2 = "log")

fit1 = ptsr.fit(start =  c(0,0,0,10), yt = simu$yt,
               fit.alpha = TRUE, p = 1, q = 1,
               ddist = d.gamma, link1 = "log",
               link2 = "log", method = "L-BFGS-B")
summary(fit1)

# removing alpha from the model
fit2 = ptsr.fit(start =  c(0,0,10), yt = simu$yt,
               fit.alpha = FALSE, p = 1, q = 1,
               ddist = d.gamma, link1 = "log",
               link2 = "log", method = "L-BFGS-B")
summary(fit2)

</code></pre>

<hr>
<h2 id='ptsr.link'>Create a Link for PTSR models</h2><span id='topic+ptsr.link'></span>

<h3>Description</h3>

<p>Given the name of a link, this function returns a link function,
an inverse link function, the derivative   <code class="reqn">d\eta / d\mu</code>
and the derivative <code class="reqn">d\mu / d\eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptsr.link(link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptsr.link_+3A_link">link</code></td>
<td>
<p>character; one of  <code>"log"</code>, <code>"log1"</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available links are:
</p>
<p>log:    <code class="reqn">f(x) = log(x)</code>
</p>
<p>log1: <code class="reqn">f(x) = log(x-1)</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"link-ptsr"</code>, a list with components
</p>
<table role = "presentation">
<tr><td><code>linkfun</code></td>
<td>
<p>Link function <code>function(mu)</code></p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>Inverse link function <code>function(eta)</code></p>
</td></tr>
<tr><td><code>linkdif</code></td>
<td>
<p>Derivative <code>function(mu)</code> <code class="reqn">d\eta / d\mu</code></p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>Derivative <code>function(eta)</code> <code class="reqn">d\mu / d\eta</code></p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a name to be used for the link</p>
</td></tr>
</table>

<hr>
<h2 id='ptsr.sim'>Function to simulate a PTSR model</h2><span id='topic+ptsr.sim'></span>

<h3>Description</h3>

<p>Function to simulate a PTSR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptsr.sim(n = 1, burn = 0, xreg = NULL, xregar = TRUE, varphi = 1,
  alpha = 0, beta = NULL, phi = NULL, theta = NULL,
  seed = stats::runif(1, 1000, 10000), rdist = r.gamma, link1 = "log",
  link2 = "identity", g1 = NULL, g1.inv = NULL, g2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptsr.sim_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. length of &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_xregar">xregar</code></td>
<td>
<p>logical, if <code>FALSE</code>, the regressors are not included in the
AR component of the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_varphi">varphi</code></td>
<td>
<p>non-negative parameter. Default is 1.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value corresponding to the intercept.  Default is 0.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_beta">beta</code></td>
<td>
<p>optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_phi">phi</code></td>
<td>
<p>optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_theta">theta</code></td>
<td>
<p>optionally, for the simulation function this must be a vector
of size <code class="reqn">q</code>, corresponding to the moving average coefficients
(including the ones that are zero), where <code class="reqn">q</code> is the MA order.
Default is <code>NULL</code>.
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_rdist">rdist</code></td>
<td>
<p>function, the random number generator to be used</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_link1">link1</code></td>
<td>
<p>character indicating which link must be used for <code class="reqn">\mu_t</code>.  See <code><a href="#topic+ptsr.link">ptsr.link</a></code> for available links. Default is &lsquo;log&rsquo;.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_link2">link2</code></td>
<td>
<p>character indicating which link must be used for <code class="reqn">y_t</code> in the AR recursion.  See <code><a href="#topic+ptsr.link">ptsr.link</a></code> for available links. Default is &lsquo;identity&rsquo;.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_g1">g1</code></td>
<td>
<p>optionally, a link function to be used  for <code class="reqn">\mu_t</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link1</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_g1.inv">g1.inv</code></td>
<td>
<p>optionally, a the inverse link function to be used  for <code class="reqn">\eta_t</code>. It must the the ivnerse of <code>g1</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link1</code>.</p>
</td></tr>
<tr><td><code id="ptsr.sim_+3A_g2">g2</code></td>
<td>
<p>optionally, a link function to be used  for <code class="reqn">y_t</code>. Default is <code>NULL</code>, so that it is calculated internally, using <code>link2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ptsr.sim</code> generates a random sample from a positive time
series regression model, with a given distribution.
</p>


<h3>Value</h3>

<p>Returns a list with the following components
</p>

<ul>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------
# Generating a sample of a Gamma-ARMA(1,1) model with no regressors
#-------------------------------------------------------------------

simu = ptsr.sim(n = 300, burn = 50,
                varphi = 20, alpha = 0,
                phi = 0.35, theta = 0.2,
                seed = 1234, rdist = r.gamma,
                link1 = "log", link2 = "log")

names(simu)
plot.ts(simu$yt)
lines(simu$mut, col= "red")

</code></pre>

<hr>
<h2 id='summary'>Summary Method of class PTSR</h2><span id='topic+summary'></span><span id='topic+summary.ptsr'></span><span id='topic+print.summary.ptsr'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"ptsr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptsr'
summary(object, ...)

## S3 method for class 'summary.ptsr'
print(x, digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>object of class <code>"ptsr"</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.ptsr"</code>,
usually, a result of a call to <code>summary.ptsr</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>,
&lsquo;significance stars&rsquo; are printed for each coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.btsr</code> tries to be smart about formatting the
coefficients, standard errors, etc. and additionally provides
&lsquo;significance stars&rsquo;.
</p>


<h3>Value</h3>

<p>The function <code>summary.ptsr</code> computes and returns a list
of summary statistics of the fitted model given in <code>object</code>.
Returns a list of class <code>summary.ptsr</code>, which contains the
following components:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the model.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">k \times 4</code> matrix with columns for
the estimated coefficient, its standard error, z-statistic and corresponding
(two-sided) p-value.</p>
</td></tr>
<tr><td><code>sigma.res</code></td>
<td>
<p>the square root of the estimated variance of the random
error </p>
<p style="text-align: center;"><code class="reqn">\hat\sigma^2 = \frac{1}{n-k}\sum_i{r_i^2},</code>
</p>

<p>where <code class="reqn">r_i</code> is the <code class="reqn">i</code>-th residual, <code>residuals[i]</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">(k, n-k, k*)</code>, the first
being the number of non-aliased coefficients, the last being the total
number of coefficients.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>a <code class="reqn">k \times k</code> matrix of (unscaled) covariances.
The inverse ov the information matrix.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the sum of the log-likelihood values</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the AIC value. <code class="reqn">AIC = -2*loglik+2*k</code>.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the BIC value. <code class="reqn">BIC = -2*loglik + log(n)*k</code>.</p>
</td></tr>
<tr><td><code>hqc</code></td>
<td>
<p>the HQC value. <code class="reqn">HQC = -2*loglik + log(log(n))*k</code>.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
