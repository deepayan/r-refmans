<!DOCTYPE html><html lang="en"><head><title>Help for package mlr3mbo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3mbo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlr3mbo-package'><p>mlr3mbo: Flexible Bayesian Optimization</p></a></li>
<li><a href='#acqf'><p>Syntactic Sugar Acquisition Function Construction</p></a></li>
<li><a href='#acqfs'><p>Syntactic Sugar Acquisition Functions Construction</p></a></li>
<li><a href='#AcqFunction'><p>Acquisition Function Base Class</p></a></li>
<li><a href='#acqo'><p>Syntactic Sugar Acquisition Function Optimizer Construction</p></a></li>
<li><a href='#AcqOptimizer'><p>Acquisition Function Optimizer</p></a></li>
<li><a href='#default_acqfunction'><p>Default Acquisition Function</p></a></li>
<li><a href='#default_acqoptimizer'><p>Default Acquisition Function Optimizer</p></a></li>
<li><a href='#default_gp'><p>Default Gaussian Process</p></a></li>
<li><a href='#default_loop_function'><p>Default Loop Function</p></a></li>
<li><a href='#default_result_assigner'><p>Default Result Assigner</p></a></li>
<li><a href='#default_rf'><p>Default Random Forest</p></a></li>
<li><a href='#default_surrogate'><p>Default Surrogate</p></a></li>
<li><a href='#loop_function'><p>Loop Functions for Bayesian Optimization</p></a></li>
<li><a href='#mbo_defaults'><p>Defaults for OptimizerMbo</p></a></li>
<li><a href='#mlr_acqfunctions'><p>Dictionary of Acquisition Functions</p></a></li>
<li><a href='#mlr_acqfunctions_aei'><p>Acquisition Function Augmented Expected Improvement</p></a></li>
<li><a href='#mlr_acqfunctions_cb'><p>Acquisition Function Confidence Bound</p></a></li>
<li><a href='#mlr_acqfunctions_ehvi'><p>Acquisition Function Expected Hypervolume Improvement</p></a></li>
<li><a href='#mlr_acqfunctions_ehvigh'><p>Acquisition Function Expected Hypervolume Improvement via Gauss-Hermite Quadrature</p></a></li>
<li><a href='#mlr_acqfunctions_ei'><p>Acquisition Function Expected Improvement</p></a></li>
<li><a href='#mlr_acqfunctions_eips'><p>Acquisition Function Expected Improvement Per Second</p></a></li>
<li><a href='#mlr_acqfunctions_mean'><p>Acquisition Function Mean</p></a></li>
<li><a href='#mlr_acqfunctions_multi'><p>Acquisition Function Wrapping Multiple Acquisition Functions</p></a></li>
<li><a href='#mlr_acqfunctions_pi'><p>Acquisition Function Probability of Improvement</p></a></li>
<li><a href='#mlr_acqfunctions_sd'><p>Acquisition Function Standard Deviation</p></a></li>
<li><a href='#mlr_acqfunctions_smsego'><p>Acquisition Function SMS-EGO</p></a></li>
<li><a href='#mlr_acqfunctions_stochastic_cb'><p>Acquisition Function Stochastic Confidence Bound</p></a></li>
<li><a href='#mlr_acqfunctions_stochastic_ei'><p>Acquisition Function Stochastic Expected Improvement</p></a></li>
<li><a href='#mlr_loop_functions'><p>Dictionary of Loop Functions</p></a></li>
<li><a href='#mlr_loop_functions_ego'><p>Sequential Single-Objective Bayesian Optimization</p></a></li>
<li><a href='#mlr_loop_functions_emo'><p>Sequential Multi-Objective Bayesian Optimization</p></a></li>
<li><a href='#mlr_loop_functions_mpcl'><p>Single-Objective Bayesian Optimization via Multipoint Constant Liar</p></a></li>
<li><a href='#mlr_loop_functions_parego'><p>Multi-Objective Bayesian Optimization via ParEGO</p></a></li>
<li><a href='#mlr_loop_functions_smsego'><p>Sequential Multi-Objective Bayesian Optimization via SMS-EGO</p></a></li>
<li><a href='#mlr_optimizers_adbo'><p>Asynchronous Decentralized Bayesian Optimization</p></a></li>
<li><a href='#mlr_optimizers_async_mbo'><p>Asynchronous Model Based Optimization</p></a></li>
<li><a href='#mlr_optimizers_mbo'><p>Model Based Optimization</p></a></li>
<li><a href='#mlr_result_assigners'><p>Dictionary of Result Assigners</p></a></li>
<li><a href='#mlr_result_assigners_archive'><p>Result Assigner Based on the Archive</p></a></li>
<li><a href='#mlr_result_assigners_surrogate'><p>Result Assigner Based on a Surrogate Mean Prediction</p></a></li>
<li><a href='#mlr_tuners_adbo'><p>TunerAsync using Asynchronous Decentralized Bayesian Optimization</p></a></li>
<li><a href='#mlr_tuners_async_mbo'><p>TunerAsync using Asynchronous Model Based Optimization</p></a></li>
<li><a href='#mlr_tuners_mbo'><p>TunerBatch using Model Based Optimization</p></a></li>
<li><a href='#ras'><p>Syntactic Sugar Result Assigner Construction</p></a></li>
<li><a href='#redis_available'><p>Check if Redis Server is Available</p></a></li>
<li><a href='#ResultAssigner'><p>Result Assigner Base Class</p></a></li>
<li><a href='#srlrn'><p>Syntactic Sugar Surrogate Construction</p></a></li>
<li><a href='#Surrogate'><p>Surrogate Model</p></a></li>
<li><a href='#SurrogateLearner'><p>Surrogate Model Containing a Single Learner</p></a></li>
<li><a href='#SurrogateLearnerCollection'><p>Surrogate Model Containing Multiple Learners</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Bayesian Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.9</td>
</tr>
<tr>
<td>Description:</td>
<td>A modern and flexible approach to Bayesian Optimization / Model
    Based Optimization building on the 'bbotk' package. 'mlr3mbo' is a toolbox
    providing both ready-to-use optimization algorithms as well as their fundamental
    building blocks allowing for straightforward implementation of custom
    algorithms. Single- and multi-objective optimization is supported as well as
    mixed continuous, categorical and conditional search spaces. Moreover, using
    'mlr3mbo' for hyperparameter optimization of machine learning models within the
    'mlr3' ecosystem is straightforward via 'mlr3tuning'. Examples of ready-to-use
    optimization algorithms include Efficient Global Optimization by Jones et al.
    (1998) &lt;<a href="https://doi.org/10.1023%2FA%3A1008306431147">doi:10.1023/A:1008306431147</a>&gt;, ParEGO by Knowles (2006)
    &lt;<a href="https://doi.org/10.1109%2FTEVC.2005.851274">doi:10.1109/TEVC.2005.851274</a>&gt; and SMS-EGO by Ponweiser et al. (2008)
    &lt;<a href="https://doi.org/10.1007%2F978-3-540-87700-4_78">doi:10.1007/978-3-540-87700-4_78</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlr3mbo.mlr-org.com">https://mlr3mbo.mlr-org.com</a>, <a href="https://github.com/mlr-org/mlr3mbo">https://github.com/mlr-org/mlr3mbo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3mbo/issues">https://github.com/mlr-org/mlr3mbo/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3tuning (&ge; 1.1.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bbotk (&ge; 1.2.0), checkmate (&ge; 2.0.0), data.table, lgr (&ge;
0.3.4), mlr3 (&ge; 0.22.1), mlr3misc (&ge; 0.11.0), paradox (&ge;
1.0.1), spacefillr, R6 (&ge; 2.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiceKriging, emoa, fastGHQuad, lhs, mlr3learners (&ge; 0.5.4),
mlr3pipelines (&ge; 0.4.2), nloptr, ranger, rgenoud, rpart,
redux, rush, stringi, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'mlr_acqfunctions.R' 'AcqFunction.R' 'AcqFunctionAEI.R'
'AcqFunctionCB.R' 'AcqFunctionEHVI.R' 'AcqFunctionEHVIGH.R'
'AcqFunctionEI.R' 'AcqFunctionEIPS.R' 'AcqFunctionMean.R'
'AcqFunctionMulti.R' 'AcqFunctionPI.R' 'AcqFunctionSD.R'
'AcqFunctionSmsEgo.R' 'AcqFunctionStochasticCB.R'
'AcqFunctionStochasticEI.R' 'AcqOptimizer.R' 'aaa.R'
'OptimizerADBO.R' 'OptimizerAsyncMbo.R' 'OptimizerMbo.R'
'mlr_result_assigners.R' 'ResultAssigner.R'
'ResultAssignerArchive.R' 'ResultAssignerSurrogate.R'
'Surrogate.R' 'SurrogateLearner.R'
'SurrogateLearnerCollection.R' 'TunerADBO.R' 'TunerAsyncMbo.R'
'TunerMbo.R' 'mlr_loop_functions.R' 'bayesopt_ego.R'
'bayesopt_emo.R' 'bayesopt_mpcl.R' 'bayesopt_parego.R'
'bayesopt_smsego.R' 'bibentries.R' 'helper.R' 'loop_function.R'
'mbo_defaults.R' 'sugar.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-04 08:39:10 UTC; lps</td>
</tr>
<tr>
<td>Author:</td>
<td>Lennart Schneider <a href="https://orcid.org/0000-0003-4152-5308"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Jakob Richter <a href="https://orcid.org/0000-0003-4481-5554"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Florian Pfisterer <a href="https://orcid.org/0000-0001-8867-762X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Binder [aut],
  Sebastian Fischer <a href="https://orcid.org/0000-0002-9609-3197"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michael H. Buselli [cph],
  Wessel Dankers [cph],
  Carlos Fonseca [cph],
  Manuel Lopez-Ibanez [cph],
  Luis Paquete [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lennart Schneider &lt;lennart.sch@web.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-04 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlr3mbo-package'>mlr3mbo: Flexible Bayesian Optimization</h2><span id='topic+mlr3mbo'></span><span id='topic+mlr3mbo-package'></span>

<h3>Description</h3>

<p>A modern and flexible approach to Bayesian Optimization / Model Based Optimization building on the 'bbotk' package. 'mlr3mbo' is a toolbox providing both ready-to-use optimization algorithms as well as their fundamental building blocks allowing for straightforward implementation of custom algorithms. Single- and multi-objective optimization is supported as well as mixed continuous, categorical and conditional search spaces. Moreover, using 'mlr3mbo' for hyperparameter optimization of machine learning models within the 'mlr3' ecosystem is straightforward via 'mlr3tuning'. Examples of ready-to-use optimization algorithms include Efficient Global Optimization by Jones et al. (1998) <a href="https://doi.org/10.1023/A%3A1008306431147">doi:10.1023/A:1008306431147</a>, ParEGO by Knowles (2006) <a href="https://doi.org/10.1109/TEVC.2005.851274">doi:10.1109/TEVC.2005.851274</a> and SMS-EGO by Ponweiser et al. (2008) <a href="https://doi.org/10.1007/978-3-540-87700-4_78">doi:10.1007/978-3-540-87700-4_78</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lennart Schneider <a href="mailto:lennart.sch@web.de">lennart.sch@web.de</a> (<a href="https://orcid.org/0000-0003-4152-5308">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jakob Richter <a href="mailto:jakob1richter@gmail.com">jakob1richter@gmail.com</a> (<a href="https://orcid.org/0000-0003-4481-5554">ORCID</a>)
</p>
</li>
<li><p> Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
</li>
<li><p> Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>)
</p>
</li>
<li><p> Florian Pfisterer <a href="mailto:pfistererf@googlemail.com">pfistererf@googlemail.com</a> (<a href="https://orcid.org/0000-0001-8867-762X">ORCID</a>)
</p>
</li>
<li><p> Martin Binder <a href="mailto:mlr.developer@mb706.com">mlr.developer@mb706.com</a>
</p>
</li>
<li><p> Sebastian Fischer <a href="mailto:sebf.fischer@gmail.com">sebf.fischer@gmail.com</a> (<a href="https://orcid.org/0000-0002-9609-3197">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Michael H. Buselli [copyright holder]
</p>
</li>
<li><p> Wessel Dankers [copyright holder]
</p>
</li>
<li><p> Carlos Fonseca [copyright holder]
</p>
</li>
<li><p> Manuel Lopez-Ibanez [copyright holder]
</p>
</li>
<li><p> Luis Paquete [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mlr3mbo.mlr-org.com">https://mlr3mbo.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3mbo">https://github.com/mlr-org/mlr3mbo</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3mbo/issues">https://github.com/mlr-org/mlr3mbo/issues</a>
</p>
</li></ul>


<hr>
<h2 id='acqf'>Syntactic Sugar Acquisition Function Construction</h2><span id='topic+acqf'></span>

<h3>Description</h3>

<p>This function complements <a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> with functions in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acqf(.key, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acqf_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
the object.</p>
</td></tr>
<tr><td><code id="acqf_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>, or to be set as public field. See
<code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+AcqFunction">AcqFunction</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acqf("ei")
</code></pre>

<hr>
<h2 id='acqfs'>Syntactic Sugar Acquisition Functions Construction</h2><span id='topic+acqfs'></span>

<h3>Description</h3>

<p>This function complements <a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> with functions in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acqfs(.keys, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acqfs_+3A_.keys">.keys</code></td>
<td>
<p>(<code>character()</code>)<br />
Keys passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
multiple objects.</p>
</td></tr>
<tr><td><code id="acqfs_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>, or to be set as public field. See
<code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of <a href="#topic+AcqFunction">AcqFunction</a>s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acqfs(c("ei", "pi", "cb"))
</code></pre>

<hr>
<h2 id='AcqFunction'>Acquisition Function Base Class</h2><span id='topic+AcqFunction'></span>

<h3>Description</h3>

<p>Abstract acquisition function class.
</p>
<p>Based on the predictions of a <a href="#topic+Surrogate">Surrogate</a>, the acquisition function encodes the preference to evaluate a new point.
</p>


<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code>AcqFunction</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>direction</code></dt><dd><p>(<code>"same"</code> | <code>"minimize"</code> | <code>"maximize"</code>)<br />
Optimization direction of the acquisition function relative to the direction of the
objective function of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> related to the passed <a href="bbotk.html#topic+Archive">bbotk::Archive</a>.
Must be <code>"same"</code>, <code>"minimize"</code>, or <code>"maximize"</code>.</p>
</dd>
<dt><code>surrogate_max_to_min</code></dt><dd><p>(<code>-1</code> | <code>1</code>)<br />
Multiplicative factor to correct for minimization or maximization of the acquisition
function.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="bbotk.html#topic+Archive">bbotk::Archive</a>)<br />
Points to the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the surrogate.</p>
</dd>
<dt><code>fun</code></dt><dd><p>(<code>function</code>)<br />
Points to the private acquisition function to be implemented by subclasses.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a>)<br />
Surrogate.</p>
</dd>
<dt><code>requires_predict_type_se</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the acquisition function requires the surrogate to have <code>"se"</code> as <code style="white-space: pre;">&#8288;$predict_type&#8288;</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunction-new"><code>AcqFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunction-update"><code>AcqFunction$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunction-reset"><code>AcqFunction$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunction-eval_many"><code>AcqFunction$eval_many()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunction-eval_dt"><code>AcqFunction$eval_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunction-clone"><code>AcqFunction$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>
<p>Note that the surrogate can be initialized lazy and can later be set via the active binding <code style="white-space: pre;">&#8288;$surrogate&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$new(
  id,
  constants = ParamSet$new(),
  surrogate,
  requires_predict_type_se,
  direction,
  packages = NULL,
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>constants</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>).
Changeable constants or parameters.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+Surrogate">Surrogate</a>).
Surrogate whose predictions are used in the acquisition function.</p>
</dd>
<dt><code>requires_predict_type_se</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the acquisition function requires the surrogate to have <code>"se"</code> as <code style="white-space: pre;">&#8288;$predict_type&#8288;</code>.</p>
</dd>
<dt><code>direction</code></dt><dd><p>(<code>"same"</code> | <code>"minimize"</code> | <code>"maximize"</code>).
Optimization direction of the acquisition function relative to the direction of the
objective function of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.
Must be <code>"same"</code>, <code>"minimize"</code>, or <code>"maximize"</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to construction if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunction-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function.
</p>
<p>Can be implemented by subclasses.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$update()</pre></div>


<hr>
<a id="method-AcqFunction-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the acquisition function.
</p>
<p>Can be implemented by subclasses.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$reset()</pre></div>


<hr>
<a id="method-AcqFunction-eval_many"></a>



<h4>Method <code>eval_many()</code></h4>

<p>Evaluates multiple input values on the acquisition function.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$eval_many(xss)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xss</code></dt><dd><p>(<code>list()</code>)<br />
A list of lists that contains multiple x values, e.g.
<code>list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data.table::data.table() that contains one y-column for
single-objective acquisition functions and multiple y-columns for multi-objective
acquisition functions, e.g. <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
</p>


<hr>
<a id="method-AcqFunction-eval_dt"></a>



<h4>Method <code>eval_dt()</code></h4>

<p>Evaluates multiple input values on the objective function
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$eval_dt(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
One point per row, e.g. <code>data.table(x1 = c(1, 3), x2 = c(2, 4))</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data.table::data.table() that contains one y-column for
single-objective acquisition functions and multiple y-columns for multi-objective
acquisition functions, e.g. <code>data.table(y = 1:2)</code> or <code>data.table(y1 = 1:2, y2 = 3:4)</code>.
</p>


<hr>
<a id="method-AcqFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>

<hr>
<h2 id='acqo'>Syntactic Sugar Acquisition Function Optimizer Construction</h2><span id='topic+acqo'></span>

<h3>Description</h3>

<p>This function allows to construct an <a href="#topic+AcqOptimizer">AcqOptimizer</a> in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acqo(optimizer, terminator, acq_function = NULL, callbacks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acqo_+3A_optimizer">optimizer</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a>)<br />
<a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a> that is to be used.</p>
</td></tr>
<tr><td><code id="acqo_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> that is to be used.</p>
</td></tr>
<tr><td><code id="acqo_+3A_acq_function">acq_function</code></td>
<td>
<p>(<code>NULL</code> | <a href="#topic+AcqFunction">AcqFunction</a>)<br />
<a href="#topic+AcqFunction">AcqFunction</a> that is to be used.
Can also be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="acqo_+3A_callbacks">callbacks</code></td>
<td>
<p>(<code>NULL</code> | list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>)
Callbacks used during acquisition function optimization.</p>
</td></tr>
<tr><td><code id="acqo_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+AcqOptimizer">AcqOptimizer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bbotk)
acqo(opt("random_search"), trm("evals"), catch_errors = FALSE)
</code></pre>

<hr>
<h2 id='AcqOptimizer'>Acquisition Function Optimizer</h2><span id='topic+AcqOptimizer'></span>

<h3>Description</h3>

<p>Optimizer for <a href="#topic+AcqFunction">AcqFunction</a>s which performs the acquisition function optimization.
Wraps an <a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a> and <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>n_candidates</code></dt><dd><p><code>integer(1)</code><br />
Number of candidate points to propose.
Note that this does not affect how the acquisition function itself is calculated (e.g., setting <code>n_candidates &gt; 1</code> will not
result in computing the q- or multi-Expected Improvement) but rather the top <code>n_candidates</code> are selected from the
<a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the acquisition function <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a>.
Note that setting <code>n_candidates &gt; 1</code> is usually not a sensible idea but it is still supported for experimental reasons.
Note that in the case of the acquisition function <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> being multi-objective, due to using an <a href="#topic+AcqFunctionMulti">AcqFunctionMulti</a>,
selection of the best candidates is performed via non-dominated-sorting.
Default is <code>1</code>.
</p>
</dd>
<dt><code>logging_level</code></dt><dd><p><code>character(1)</code><br />
Logging level during the acquisition function optimization.
Can be <code>"fatal"</code>, <code>"error"</code>, <code>"warn"</code>, <code>"info"</code>, <code>"debug"</code> or <code>"trace"</code>.
Default is <code>"warn"</code>, i.e., only warnings are logged.
</p>
</dd>
<dt><code>warmstart</code></dt><dd><p><code>logical(1)</code><br />
Should the acquisition function optimization be warm-started by evaluating the best point(s) present in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of
the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> (which is contained in the archive of the <a href="#topic+AcqFunction">AcqFunction</a>)?
This is sensible when using a population based acquisition function optimizer, e.g., local search or mutation.
Default is <code>FALSE</code>.
Note that in the case of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> being multi-objective, selection of the best point(s) is performed via non-dominated-sorting.
</p>
</dd>
<dt><code>warmstart_size</code></dt><dd><p><code>integer(1) | "all"</code><br />
Number of best points selected from the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> that are to be used for warm starting.
Can either be an integer or &quot;all&quot; to use all available points.
Only relevant if <code>warmstart = TRUE</code>.
Default is <code>1</code>.
</p>
</dd>
<dt><code>skip_already_evaluated</code></dt><dd><p><code>logical(1)</code><br />
It can happen that the candidate(s) resulting of the acquisition function optimization were already evaluated on the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.
Should such candidate proposals be ignored and only candidates that were yet not evaluated be considered?
Default is <code>TRUE</code>.
</p>
</dd>
<dt><code>catch_errors</code></dt><dd><p><code>logical(1)</code><br />
Should errors during the acquisition function optimization be caught and propagated to the <code>loop_function</code> which can then handle
the failed acquisition function optimization appropriately by, e.g., proposing a randomly sampled point for evaluation?
Setting this to <code>FALSE</code> can be helpful for debugging.
Default is <code>TRUE</code>.
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a>).</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>).</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a>).</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(<code>NULL</code> | list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>print_id</code></dt><dd><p>(<code>character</code>)<br />
Id used when printing.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of hyperparameters.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqOptimizer-new"><code>AcqOptimizer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqOptimizer-format"><code>AcqOptimizer$format()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqOptimizer-print"><code>AcqOptimizer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqOptimizer-optimize"><code>AcqOptimizer$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqOptimizer-reset"><code>AcqOptimizer$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqOptimizer-clone"><code>AcqOptimizer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AcqOptimizer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$new(optimizer, terminator, acq_function = NULL, callbacks = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a>).</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>).</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+AcqFunction">AcqFunction</a>).</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(<code>NULL</code> | list of <a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a>)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqOptimizer-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$format()</pre></div>



<h5>Returns</h5>

<p>(<code>character(1)</code>).
</p>


<hr>
<a id="method-AcqOptimizer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-AcqOptimizer-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Optimize the acquisition function.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$optimize()</pre></div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with 1 row per candidate.
</p>


<hr>
<a id="method-AcqOptimizer-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the acquisition function optimizer.
</p>
<p>Currently not used.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$reset()</pre></div>


<hr>
<a id="method-AcqOptimizer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqOptimizer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("ei", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 1000),
    terminator = trm("evals", n_evals = 1000),
    acq_function = acq_function)

  acq_optimizer$optimize()
}
</code></pre>

<hr>
<h2 id='default_acqfunction'>Default Acquisition Function</h2><span id='topic+default_acqfunction'></span>

<h3>Description</h3>

<p>Chooses a default acquisition function, i.e. the criterion used to propose future points.
For synchronous single-objective optimization, defaults to <a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a>.
For synchronous multi-objective optimization, defaults to <a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a>.
For asynchronous single-objective optimization, defaults to <a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_acqfunction(instance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_acqfunction_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>).
An object that inherits from <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+AcqFunction">AcqFunction</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_acqoptimizer'>Default Acquisition Function Optimizer</h2><span id='topic+default_acqoptimizer'></span>

<h3>Description</h3>

<p>Chooses a default acquisition function optimizer.
Defaults to wrapping <a href="bbotk.html#topic+mlr_optimizers_random_search">bbotk::OptimizerBatchRandomSearch</a> allowing 10000 function evaluations (with a batch size of 1000) via a <a href="bbotk.html#topic+mlr_terminators_evals">bbotk::TerminatorEvals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_acqoptimizer(acq_function)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_acqoptimizer_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+AcqFunction">AcqFunction</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+AcqOptimizer">AcqOptimizer</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_gp'>Default Gaussian Process</h2><span id='topic+default_gp'></span>

<h3>Description</h3>

<p>This is a helper function that constructs a default Gaussian Process <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> which is for example used in
<a href="#topic+default_surrogate">default_surrogate</a>.
</p>
<p>Constructs a Kriging learner &ldquo;&quot;regr.km&quot;&rdquo; with kernel &ldquo;&quot;matern5_2&quot;&rdquo;.
If <code>noisy = FALSE</code> (default) a small nugget effect is added <code>nugget.stability = 10^-8</code> to increase
numerical stability to hopefully prevent crashes of <a href="https://CRAN.R-project.org/package=DiceKriging"><span class="pkg">DiceKriging</span></a>.
If <code>noisy = TRUE</code> the nugget effect will be estimated with <code>nugget.estim = TRUE</code>.
If <code>noisy = TRUE</code> <code>jitter</code> is set to <code>TRUE</code> to circumvent a problem with <a href="https://CRAN.R-project.org/package=DiceKriging"><span class="pkg">DiceKriging</span></a> where
already trained input values produce the exact trained output.
In general, instead of the default <code>"BFGS"</code> optimization method we use rgenoud (<code>"gen"</code>), which is a hybrid
algorithm, to combine global search based on genetic algorithms and local search based on gradients.
This may improve the model fit and will less frequently produce a constant model prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_gp(noisy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_gp_+3A_noisy">noisy</code></td>
<td>
<p>(logical(1))<br />
Whether the learner will be used in a noisy objective function scenario.
See above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_loop_function'>Default Loop Function</h2><span id='topic+default_loop_function'></span>

<h3>Description</h3>

<p>Chooses a default <a href="#topic+loop_function">loop_function</a>, i.e. the Bayesian Optimization flavor to be used for optimization.
For single-objective optimization, defaults to <a href="#topic+bayesopt_ego">bayesopt_ego</a>.
For multi-objective optimization, defaults to <a href="#topic+bayesopt_smsego">bayesopt_smsego</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_loop_function(instance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_loop_function_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>)<br />
An object that inherits from <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+loop_function">loop_function</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_result_assigner'>Default Result Assigner</h2><span id='topic+default_result_assigner'></span>

<h3>Description</h3>

<p>Chooses a default result assigner.
Defaults to <a href="#topic+ResultAssignerArchive">ResultAssignerArchive</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_result_assigner(instance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_result_assigner_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>)<br />
An object that inherits from <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ResultAssigner">ResultAssigner</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_rf'>Default Random Forest</h2><span id='topic+default_rf'></span>

<h3>Description</h3>

<p>This is a helper function that constructs a default random forest <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> which is for example used in
<a href="#topic+default_surrogate">default_surrogate</a>.
</p>
<p>Constructs a ranger learner &ldquo;&quot;regr.ranger&quot;&rdquo; with <code>num.trees = 100</code>, <code>keep.inbag = TRUE</code> and
<code>se.method = "jack"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_rf(noisy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_rf_+3A_noisy">noisy</code></td>
<td>
<p>(logical(1))<br />
Whether the learner will be used in a noisy objective function scenario.
Currently has no effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>
</p>


<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='default_surrogate'>Default Surrogate</h2><span id='topic+default_surrogate'></span>

<h3>Description</h3>

<p>This is a helper function that constructs a default <a href="#topic+Surrogate">Surrogate</a> based on properties of the
<a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.
</p>
<p>For numeric-only (including integers) parameter spaces without any dependencies a Gaussian Process is constricted via
<code><a href="#topic+default_gp">default_gp()</a></code>.
For mixed numeric-categorical parameter spaces, or spaces with conditional parameters a random forest is constructed via
<code><a href="#topic+default_rf">default_rf()</a></code>.
</p>
<p>In any case, learners are encapsulated using &ldquo;&quot;evaluate&quot;&rdquo;, and a fallback learner is set,
in cases where the surrogate learner errors.
Currently, the following learner is used as a fallback:
<code>lrn("regr.ranger", num.trees = 10L, keep.inbag = TRUE, se.method = "jack")</code>.
</p>
<p>If additionally dependencies are present in the parameter space, inactive conditional parameters
are represented by missing <code>NA</code> values in the training design data.
We simply handle those with an imputation method, added to the random forest, more
concretely we use <code>po("imputesample")</code> (for logicals) and <code>po("imputeoor")</code> (for anything else) from
package <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>.
Characters are always encoded as factors via <code>po("colapply")</code>.
Out of range imputation makes sense for tree-based methods and is usually hard to beat, see Ding et al. (2010).
In the case of dependencies, the following learner is used as a fallback:
<code>lrn("regr.featureless")</code>.
</p>
<p>If <code>n_learner</code> is <code>1</code>, the learner is wrapped as a <a href="#topic+SurrogateLearner">SurrogateLearner</a>.
Otherwise, if <code>n_learner</code> is larger than <code>1</code>, multiple deep clones of the learner are wrapped as a <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_surrogate(
  instance,
  learner = NULL,
  n_learner = NULL,
  force_random_forest = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_surrogate_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>)<br />
An object that inherits from <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</td></tr>
<tr><td><code id="default_surrogate_+3A_learner">learner</code></td>
<td>
<p>(<code>NULL</code> | <a href="mlr3.html#topic+Learner">mlr3::Learner</a>).
If specified, this learner will be used instead of the defaults described above.</p>
</td></tr>
<tr><td><code id="default_surrogate_+3A_n_learner">n_learner</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>).
Number of learners to be considered in the construction of the <a href="#topic+Surrogate">Surrogate</a>.
If not specified will be based on the number of objectives as stated by the instance.</p>
</td></tr>
<tr><td><code id="default_surrogate_+3A_force_random_forest">force_random_forest</code></td>
<td>
<p>(<code>logical(1)</code>).
If <code>TRUE</code>, a random forest is constructed even if the parameter space is numeric-only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+Surrogate">Surrogate</a>
</p>


<h3>References</h3>


<ul>
<li><p> Ding, Yufeng, Simonoff, S J (2010).
&ldquo;An Investigation of Missing Data Methods for Classification Trees Applied to Binary Response Data.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>11</b>(1), 131&ndash;170.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+mbo_defaults">mbo_defaults</a></code>
</p>

<hr>
<h2 id='loop_function'>Loop Functions for Bayesian Optimization</h2><span id='topic+loop_function'></span>

<h3>Description</h3>

<p>Loop functions determine the behavior of the Bayesian Optimization algorithm on a global level.
For an overview of readily available loop functions, see <code>as.data.table(mlr_loop_functions)</code>.
</p>
<p>In general, a loop function is simply a decorated member of the S3 class <code>loop_function</code>.
Attributes must include: <code>id</code> (id of the loop function), <code>label</code> (brief description), <code>instance</code> (&quot;single-crit&quot; and
or &quot;multi_crit&quot;), and <code>man</code> (link to the manual page).
</p>
<p>As an example, see, e.g., <a href="#topic+bayesopt_ego">bayesopt_ego</a>.
</p>


<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>

<hr>
<h2 id='mbo_defaults'>Defaults for OptimizerMbo</h2><span id='topic+mbo_defaults'></span>

<h3>Description</h3>

<p>The following defaults are set for <a href="#topic+OptimizerMbo">OptimizerMbo</a> during optimization if the
respective fields are not set during initialization.
</p>

<ul>
<li><p> Optimization Loop: <a href="#topic+default_loop_function">default_loop_function</a><br />
</p>
</li>
<li><p> Surrogate: <a href="#topic+default_surrogate">default_surrogate</a><br />
</p>
</li>
<li><p> Acquisition Function: <a href="#topic+default_acqfunction">default_acqfunction</a><br />
</p>
</li>
<li><p> Acqfun Optimizer: <a href="#topic+default_acqoptimizer">default_acqoptimizer</a><br />
</p>
</li>
<li><p> Result Assigner: <a href="#topic+default_result_assigner">default_result_assigner</a><br />
</p>
</li></ul>



<h3>See Also</h3>

<p>Other mbo_defaults: 
<code><a href="#topic+default_acqfunction">default_acqfunction</a>()</code>,
<code><a href="#topic+default_acqoptimizer">default_acqoptimizer</a>()</code>,
<code><a href="#topic+default_gp">default_gp</a>()</code>,
<code><a href="#topic+default_loop_function">default_loop_function</a>()</code>,
<code><a href="#topic+default_result_assigner">default_result_assigner</a>()</code>,
<code><a href="#topic+default_rf">default_rf</a>()</code>,
<code><a href="#topic+default_surrogate">default_surrogate</a>()</code>
</p>

<hr>
<h2 id='mlr_acqfunctions'>Dictionary of Acquisition Functions</h2><span id='topic+mlr_acqfunctions'></span>

<h3>Description</h3>

<p>A simple <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <a href="#topic+AcqFunction">AcqFunction</a>.
Each acquisition function has an associated help page, see <code>mlr_acqfunctions_[id]</code>.
</p>
<p>For a more convenient way to retrieve and construct an acquisition function, see <code><a href="#topic+acqf">acqf()</a></code> and <code><a href="#topic+acqfs">acqfs()</a></code>.
</p>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>See Also</h3>

<p>Sugar functions: <code><a href="#topic+acqf">acqf()</a></code>, <code><a href="#topic+acqfs">acqfs()</a></code>
</p>
<p>Other Dictionary: 
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_result_assigners">mlr_result_assigners</a></code>
</p>
<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
as.data.table(mlr_acqfunctions)
acqf("ei")
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_aei'>Acquisition Function Augmented Expected Improvement</h2><span id='topic+mlr_acqfunctions_aei'></span><span id='topic+AcqFunctionAEI'></span>

<h3>Description</h3>

<p>Augmented Expected Improvement.
Useful when working with noisy objectives.
Currently only works correctly with <code>"regr.km"</code> as surrogate model and <code>nugget.estim = TRUE</code> or given.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("aei")
acqf("aei")
</pre></div>


<h3>Parameters</h3>


<ul>
<li> <p><code>"c"</code> (<code>numeric(1)</code>)<br />
Constant <code class="reqn">c</code> as used in Formula (14) of Huang (2012) to reflect the degree of risk aversion. Defaults to <code>1</code>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionAEI</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y_effective_best</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Best effective objective value observed so far.
In the case of maximization, this already includes the necessary change of sign.</p>
</dd>
<dt><code>noise_var</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Estimate of the variance of the noise.
This corresponds to the <code>nugget</code> estimate when using a <a href="mlr3learners.html#topic+mlr_learners_regr.km">mlr3learners</a> as surrogate model.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionAEI-new"><code>AcqFunctionAEI$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionAEI-update"><code>AcqFunctionAEI$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionAEI-clone"><code>AcqFunctionAEI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionAEI-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionAEI$new(surrogate = NULL, c = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
<dt><code>c</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionAEI-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>y_effective_best</code> and <code>noise_var</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionAEI$update()</pre></div>


<hr>
<a id="method-AcqFunctionAEI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionAEI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Huang D, Allen TT, Notz WI, Zheng N (2012).
&ldquo;Erratum To: Global Optimization of Stochastic Black-box Systems via Sequential Kriging Meta-Models.&rdquo;
<em>Journal of Global Optimization</em>, <b>54</b>(2), 431&ndash;431.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  set.seed(2906)
  fun = function(xs) {
    list(y = xs$x ^ 2 + rnorm(length(xs$x), mean = 0, sd = 1))
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun,
    domain = domain,
    codomain = codomain,
    properties = "noisy")

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = lrn("regr.km",
    covtype = "matern5_2",
    optim.method = "gen",
    nugget.estim = TRUE,
    jitter = 1e-12,
    control = list(trace = FALSE))

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("aei", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_cb'>Acquisition Function Confidence Bound</h2><span id='topic+mlr_acqfunctions_cb'></span><span id='topic+AcqFunctionCB'></span>

<h3>Description</h3>

<p>Lower / Upper Confidence Bound.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("cb")
acqf("cb")
</pre></div>


<h3>Parameters</h3>


<ul>
<li> <p><code>"lambda"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\lambda</code> value used for the confidence bound.
Defaults to <code>2</code>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionCB</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionCB-new"><code>AcqFunctionCB$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionCB-clone"><code>AcqFunctionCB$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="update"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-update'><code>mlr3mbo::AcqFunction$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionCB-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionCB$new(surrogate = NULL, lambda = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionCB-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionCB$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Snoek, Jasper, Larochelle, Hugo, Adams, P R (2012).
&ldquo;Practical Bayesian Optimization of Machine Learning Algorithms.&rdquo;
In Pereira F, Burges CJC, Bottou L, Weinberger KQ (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 25, 2951&ndash;2959.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("cb", surrogate = surrogate, lambda = 3)

  acq_function$surrogate$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_ehvi'>Acquisition Function Expected Hypervolume Improvement</h2><span id='topic+mlr_acqfunctions_ehvi'></span><span id='topic+AcqFunctionEHVI'></span>

<h3>Description</h3>

<p>Exact Expected Hypervolume Improvement.
Calculates the exact expected hypervolume improvement in the case of two objectives.
In the case of optimizing more than two objective functions, <a href="#topic+AcqFunctionEHVIGH">AcqFunctionEHVIGH</a> can be used.
See Emmerich et al. (2016) for details.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionEHVI</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ys_front</code></dt><dd><p>(<code>matrix()</code>)<br />
Approximated Pareto front. Sorted by the first objective.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>ref_point</code></dt><dd><p>(<code>numeric()</code>)<br />
Reference point.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>ys_front_augmented</code></dt><dd><p>(<code>matrix()</code>)<br />
Augmented approximated Pareto front. Sorted by the first objective.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionEHVI-new"><code>AcqFunctionEHVI$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEHVI-update"><code>AcqFunctionEHVI$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEHVI-clone"><code>AcqFunctionEHVI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionEHVI-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVI$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionEHVI-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>ys_front</code> and <code>ref_point</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVI$update()</pre></div>


<hr>
<a id="method-AcqFunctionEHVI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Emmerich, Michael, Yang, Kaifeng, Deutz, André, Wang, Hao, Fonseca, M. C (2016).
&ldquo;A Multicriteria Generalization of Bayesian Global Optimization.&rdquo;
In Pardalos, M. P, Zhigljavsky, Anatoly, Žilinskas, Julius (eds.), <em>Advances in Stochastic and Deterministic Global Optimization</em>, 229&ndash;242.
Springer International Publishing, Cham.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(list(learner, learner$clone(deep = TRUE)), archive = instance$archive)

  acq_function = acqf("ehvi", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_ehvigh'>Acquisition Function Expected Hypervolume Improvement via Gauss-Hermite Quadrature</h2><span id='topic+mlr_acqfunctions_ehvigh'></span><span id='topic+AcqFunctionEHVIGH'></span>

<h3>Description</h3>

<p>Expected Hypervolume Improvement.
Computed via Gauss-Hermite quadrature.
</p>
<p>In the case of optimizing only two objective functions <a href="#topic+AcqFunctionEHVI">AcqFunctionEHVI</a> is to be preferred.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>"k"</code> (<code>integer(1)</code>)<br />
Number of nodes per objective used for the numerical integration via Gauss-Hermite quadrature.
Defaults to <code>15</code>.
For example, if two objectives are to be optimized, the total number of nodes will therefore be 225 per default.
Changing this value after construction requires a call to <code style="white-space: pre;">&#8288;$update()&#8288;</code> to update the <code style="white-space: pre;">&#8288;$gh_data&#8288;</code> field.
</p>
</li>
<li> <p><code>"r"</code> (<code>numeric(1)</code>)<br />
Pruning rate between 0 and 1 that determines the fraction of nodes of the Gauss-Hermite quadrature rule that are ignored based on their weight value (the nodes with the lowest weights being ignored).
Default is <code>0.2</code>.
Changing this value after construction does not require a call to <code style="white-space: pre;">&#8288;$update()&#8288;</code>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionEHVIGH</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ys_front</code></dt><dd><p>(<code>matrix()</code>)<br />
Approximated Pareto front.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>ref_point</code></dt><dd><p>(<code>numeric()</code>)<br />
Reference point.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>hypervolume</code></dt><dd><p>(<code>numeric(1)</code>).
Current hypervolume of the approximated Pareto front with respect to the reference point.</p>
</dd>
<dt><code>gh_data</code></dt><dd><p>(<code>matrix()</code>)<br />
Data required for the Gauss-Hermite quadrature rule in the form of a matrix of dimension (k x 2).
Each row corresponds to one Gauss-Hermite node (column <code>"x"</code>) and corresponding weight (column <code>"w"</code>).
Computed via <a href="fastGHQuad.html#topic+gaussHermiteData">fastGHQuad::gaussHermiteData</a>.
Nodes are scaled by a factor of <code>sqrt(2)</code> and weights are normalized under a sum to one constraint.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionEHVIGH-new"><code>AcqFunctionEHVIGH$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEHVIGH-update"><code>AcqFunctionEHVIGH$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEHVIGH-clone"><code>AcqFunctionEHVIGH$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionEHVIGH-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVIGH$new(surrogate = NULL, k = 15L, r = 0.2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>).</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integer(1)</code>).</p>
</dd>
<dt><code>r</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionEHVIGH-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>ys_front</code>, <code>ref_point</code>, <code>hypervolume</code> and <code>gh_data</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVIGH$update()</pre></div>


<hr>
<a id="method-AcqFunctionEHVIGH-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEHVIGH$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Rahat, Alma, Chugh, Tinkle, Fieldsend, Jonathan, Allmendinger, Richard, Miettinen, Kaisa (2022).
&ldquo;Efficient Approximation of Expected Hypervolume Improvement using Gauss-Hermit Quadrature.&rdquo;
In Rudolph, Günter, Kononova, V. A, Aguirre, Hernán, Kerschke, Pascal, Ochoa, Gabriela, Tušar, Tea (eds.), <em>Parallel Problem Solving from Nature &ndash; PPSN XVII</em>, 90&ndash;103.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(list(learner, learner$clone(deep = TRUE)), archive = instance$archive)

  acq_function = acqf("ehvigh", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_ei'>Acquisition Function Expected Improvement</h2><span id='topic+mlr_acqfunctions_ei'></span><span id='topic+AcqFunctionEI'></span>

<h3>Description</h3>

<p>Expected Improvement.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("ei")
acqf("ei")
</pre></div>


<h3>Parameters</h3>


<ul>
<li> <p><code>"epsilon"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\epsilon</code> value used to determine the amount of exploration.
Higher values result in the importance of improvements predicted by the posterior mean
decreasing relative to the importance of potential improvements in regions of high predictive uncertainty.
Defaults to <code>0</code> (standard Expected Improvement).
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionEI</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y_best</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Best objective function value observed so far.
In the case of maximization, this already includes the necessary change of sign.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionEI-new"><code>AcqFunctionEI$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEI-update"><code>AcqFunctionEI$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEI-clone"><code>AcqFunctionEI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionEI-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEI$new(surrogate = NULL, epsilon = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionEI-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>y_best</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEI$update()</pre></div>


<hr>
<a id="method-AcqFunctionEI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Jones, R. D, Schonlau, Matthias, Welch, J. W (1998).
&ldquo;Efficient Global Optimization of Expensive Black-Box Functions.&rdquo;
<em>Journal of Global optimization</em>, <b>13</b>(4), 455&ndash;492.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("ei", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_eips'>Acquisition Function Expected Improvement Per Second</h2><span id='topic+mlr_acqfunctions_eips'></span><span id='topic+AcqFunctionEIPS'></span>

<h3>Description</h3>

<p>Expected Improvement per Second.
</p>
<p>It is assumed that calculations are performed on an <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a>.
Additionally to target values of the codomain that should be minimized or maximized, the
<a href="bbotk.html#topic+Objective">bbotk::Objective</a> of the <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> should return time values.
The column names of the target variable and time variable must be passed as <code>cols_y</code> in the
order <code style="white-space: pre;">&#8288;(target, time)&#8288;</code> when constructing the <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a> that is being used as a
surrogate.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("eips")
acqf("eips")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionEIPS</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y_best</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Best objective function value observed so far.
In the case of maximization, this already includes the necessary change of sign.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>col_y</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>col_time</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionEIPS-new"><code>AcqFunctionEIPS$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEIPS-update"><code>AcqFunctionEIPS$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionEIPS-clone"><code>AcqFunctionEIPS$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionEIPS-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEIPS$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionEIPS-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>y_best</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEIPS$update()</pre></div>


<hr>
<a id="method-AcqFunctionEIPS-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionEIPS$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Snoek, Jasper, Larochelle, Hugo, Adams, P R (2012).
&ldquo;Practical Bayesian Optimization of Machine Learning Algorithms.&rdquo;
In Pereira F, Burges CJC, Bottou L, Weinberger KQ (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 25, 2951&ndash;2959.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2, time = abs(xs$x))
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"), time = p_dbl(tags = "time"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(list(learner, learner$clone(deep = TRUE)), archive = instance$archive)
  surrogate$cols_y = c("y", "time")

  acq_function = acqf("eips", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_mean'>Acquisition Function Mean</h2><span id='topic+mlr_acqfunctions_mean'></span><span id='topic+AcqFunctionMean'></span>

<h3>Description</h3>

<p>Posterior Mean.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("mean")
acqf("mean")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionMean</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionMean-new"><code>AcqFunctionMean$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionMean-clone"><code>AcqFunctionMean$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="update"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-update'><code>mlr3mbo::AcqFunction$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionMean-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionMean$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionMean-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionMean$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("mean", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_multi'>Acquisition Function Wrapping Multiple Acquisition Functions</h2><span id='topic+mlr_acqfunctions_multi'></span><span id='topic+AcqFunctionMulti'></span>

<h3>Description</h3>

<p>Wrapping multiple <a href="#topic+AcqFunction">AcqFunction</a>s resulting in a multi-objective acquisition function composed of the individual ones.
Note that the optimization direction of each wrapped acquisition function is corrected for maximization.
</p>
<p>For each acquisition function, the same <a href="#topic+Surrogate">Surrogate</a> must be used.
If acquisition functions passed during construction already have been initialized with a surrogate, it is checked whether
the surrogate is the same for all acquisition functions.
If acquisition functions have not been initialized with a surrogate, the surrogate passed during construction or lazy initialization
will be used for all acquisition functions.
</p>
<p>For optimization, <a href="#topic+AcqOptimizer">AcqOptimizer</a> can be used as for any other <a href="#topic+AcqFunction">AcqFunction</a>, however, the <a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a> wrapped within the <a href="#topic+AcqOptimizer">AcqOptimizer</a>
must support multi-objective optimization as indicated via the <code>multi-crit</code> property.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("multi")
acqf("multi")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionMulti</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a>)<br />
Surrogate.</p>
</dd>
<dt><code>acq_functions</code></dt><dd><p>(list of <a href="#topic+AcqFunction">AcqFunction</a>)<br />
Points to the list of the individual acquisition functions.</p>
</dd>
<dt><code>acq_function_ids</code></dt><dd><p>(character())<br />
Points to the ids of the individual acquisition functions.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionMulti-new"><code>AcqFunctionMulti$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionMulti-update"><code>AcqFunctionMulti$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionMulti-clone"><code>AcqFunctionMulti$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionMulti-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionMulti$new(acq_functions, surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acq_functions</code></dt><dd><p>(list of <a href="#topic+AcqFunction">AcqFunction</a>s).</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+Surrogate">Surrogate</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionMulti-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update each of the wrapped acquisition functions.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionMulti$update()</pre></div>


<hr>
<a id="method-AcqFunctionMulti-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionMulti$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("multi",
    acq_functions = acqfs(c("ei", "pi", "cb")),
    surrogate = surrogate
  )

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_pi'>Acquisition Function Probability of Improvement</h2><span id='topic+mlr_acqfunctions_pi'></span><span id='topic+AcqFunctionPI'></span>

<h3>Description</h3>

<p>Probability of Improvement.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("pi")
acqf("pi")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionPI</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y_best</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Best objective function value observed so far.
In the case of maximization, this already includes the necessary change of sign.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionPI-new"><code>AcqFunctionPI$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionPI-update"><code>AcqFunctionPI$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionPI-clone"><code>AcqFunctionPI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionPI-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionPI$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionPI-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>y_best</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionPI$update()</pre></div>


<hr>
<a id="method-AcqFunctionPI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionPI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Kushner, J. H (1964).
&ldquo;A New Method of Locating the Maximum Point of an Arbitrary Multipeak Curve in the Presence of Noise.&rdquo;
<em>Journal of Basic Engineering</em>, <b>86</b>(1), 97&ndash;106.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("pi", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_sd'>Acquisition Function Standard Deviation</h2><span id='topic+mlr_acqfunctions_sd'></span><span id='topic+AcqFunctionSD'></span>

<h3>Description</h3>

<p>Posterior Standard Deviation.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("sd")
acqf("sd")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionSD</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionSD-new"><code>AcqFunctionSD$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionSD-clone"><code>AcqFunctionSD$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="reset"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-reset'><code>mlr3mbo::AcqFunction$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="update"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-update'><code>mlr3mbo::AcqFunction$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionSD-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSD$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionSD-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSD$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("sd", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_smsego'>Acquisition Function SMS-EGO</h2><span id='topic+mlr_acqfunctions_smsego'></span><span id='topic+AcqFunctionSmsEgo'></span>

<h3>Description</h3>

<p>S-Metric Selection Evolutionary Multi-Objective Optimization Algorithm Acquisition Function.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>"lambda"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\lambda</code> value used for the confidence bound.
Defaults to <code>1</code>.
Based on <code>confidence = (1 - 2 * dnorm(lambda)) ^ m</code> you can calculate a
lambda for a given confidence level, see Ponweiser et al. (2008).
</p>
</li>
<li> <p><code>"epsilon"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\epsilon</code> used for the additive epsilon dominance.
Can either be a single numeric value &gt; 0 or <code>NULL</code> (default).
In the case of being <code>NULL</code>, an epsilon vector is maintained dynamically as
described in Horn et al. (2015).
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> This acquisition function always also returns its current epsilon values in a list column (<code>acq_epsilon</code>).
These values will be logged into the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> of the <a href="#topic+AcqOptimizer">AcqOptimizer</a> and
therefore also in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> that is to be optimized.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionSmsEgo</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ys_front</code></dt><dd><p>(<code>matrix()</code>)<br />
Approximated Pareto front.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>ref_point</code></dt><dd><p>(<code>numeric()</code>)<br />
Reference point.
Signs are corrected with respect to assuming minimization of objectives.</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric()</code>)<br />
Epsilon used for the additive epsilon dominance.</p>
</dd>
<dt><code>progress</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimization progress (typically, the number of function evaluations left).
Note that this requires the <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> to be terminated via a <a href="bbotk.html#topic+mlr_terminators_evals">bbotk::TerminatorEvals</a>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionSmsEgo-new"><code>AcqFunctionSmsEgo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionSmsEgo-update"><code>AcqFunctionSmsEgo$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionSmsEgo-reset"><code>AcqFunctionSmsEgo$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionSmsEgo-clone"><code>AcqFunctionSmsEgo$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionSmsEgo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSmsEgo$new(surrogate = NULL, lambda = 1, epsilon = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>NULL</code> | <code>numeric(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionSmsEgo-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function and set <code>ys_front</code>, <code>ref_point</code> and <code>epsilon</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSmsEgo$update()</pre></div>


<hr>
<a id="method-AcqFunctionSmsEgo-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the acquisition function.
Resets <code>epsilon</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSmsEgo$reset()</pre></div>


<hr>
<a id="method-AcqFunctionSmsEgo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionSmsEgo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Ponweiser, Wolfgang, Wagner, Tobias, Biermann, Dirk, Vincze, Markus (2008).
&ldquo;Multiobjective Optimization on a Limited Budget of Evaluations Using Model-Assisted S-Metric Selection.&rdquo;
In <em>Proceedings of the 10th International Conference on Parallel Problem Solving from Nature</em>, 784&ndash;794.
</p>
</li>
<li><p> Horn, Daniel, Wagner, Tobias, Biermann, Dirk, Weihs, Claus, Bischl, Bernd (2015).
&ldquo;Model-Based Multi-objective Optimization: Taxonomy, Multi-Point Proposal, Toolbox and Benchmark.&rdquo;
In <em>International Conference on Evolutionary Multi-Criterion Optimization</em>, 64&ndash;78.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(list(learner, learner$clone(deep = TRUE)), archive = instance$archive)

  acq_function = acqf("smsego", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$progress = 5 - 4 # n_evals = 5 and 4 points already evaluated
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_stochastic_cb'>Acquisition Function Stochastic Confidence Bound</h2><span id='topic+mlr_acqfunctions_stochastic_cb'></span><span id='topic+AcqFunctionStochasticCB'></span>

<h3>Description</h3>

<p>Lower / Upper Confidence Bound with lambda sampling and decay.
The initial <code class="reqn">\lambda</code> is drawn from an uniform distribution between <code>min_lambda</code> and <code>max_lambda</code> or from an exponential distribution with rate <code>1 / lambda</code>.
<code class="reqn">\lambda</code> is updated after each update by the formula <code>lambda * exp(-rate * (t %% period))</code>, where <code>t</code> is the number of times the acquisition function has been updated.
</p>
<p>While this acquisition function usually would be used within an asynchronous optimizer, e.g., <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>,
it can in principle also be used in synchronous optimizers, e.g., <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("stochastic_cb")
acqf("stochastic_cb")
</pre></div>


<h3>Parameters</h3>


<ul>
<li> <p><code>"lambda"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\lambda</code> value for sampling from the exponential distribution.
Defaults to <code>1.96</code>.
</p>
</li>
<li> <p><code>"min_lambda"</code> (<code>numeric(1)</code>)<br />
Minimum value of <code class="reqn">\lambda</code>for sampling from the uniform distribution.
Defaults to <code>0.01</code>.
</p>
</li>
<li> <p><code>"max_lambda"</code> (<code>numeric(1)</code>)<br />
Maximum value of <code class="reqn">\lambda</code> for sampling from the uniform distribution.
Defaults to <code>10</code>.
</p>
</li>
<li> <p><code>"distribution"</code> (<code>character(1)</code>)<br />
Distribution to sample <code class="reqn">\lambda</code> from.
One of <code>c("uniform", "exponential")</code>.
Defaults to <code>uniform</code>.
</p>
</li>
<li> <p><code>"rate"</code> (<code>numeric(1)</code>)<br />
Rate of the exponential decay.
Defaults to <code>0</code> i.e. no decay.
</p>
</li>
<li> <p><code>"period"</code> (<code>integer(1)</code>)<br />
Period of the exponential decay.
Defaults to <code>NULL</code>, i.e., the decay has no period.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> This acquisition function always also returns its current (<code>acq_lambda</code>) and original (<code>acq_lambda_0</code>) <code class="reqn">\lambda</code>.
These values will be logged into the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> of the <a href="#topic+AcqOptimizer">AcqOptimizer</a> and
therefore also in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> that is to be optimized.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionStochasticCB</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionStochasticCB-new"><code>AcqFunctionStochasticCB$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticCB-update"><code>AcqFunctionStochasticCB$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticCB-reset"><code>AcqFunctionStochasticCB$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticCB-clone"><code>AcqFunctionStochasticCB$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionStochasticCB-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticCB$new(
  surrogate = NULL,
  lambda = 1.96,
  min_lambda = 0.01,
  max_lambda = 10,
  distribution = "uniform",
  rate = 0,
  period = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>min_lambda</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>max_lambda</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>distribution</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>rate</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>period</code></dt><dd><p>(<code>NULL</code> | <code>integer(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionStochasticCB-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function.
Samples and decays lambda.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticCB$update()</pre></div>


<hr>
<a id="method-AcqFunctionStochasticCB-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the acquisition function.
Resets the private update counter <code>.t</code> used within the epsilon decay.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticCB$reset()</pre></div>


<hr>
<a id="method-AcqFunctionStochasticCB-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticCB$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Snoek, Jasper, Larochelle, Hugo, Adams, P R (2012).
&ldquo;Practical Bayesian Optimization of Machine Learning Algorithms.&rdquo;
In Pereira F, Burges CJC, Bottou L, Weinberger KQ (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 25, 2951&ndash;2959.
</p>
</li>
<li><p> Egelé, Romain, Guyon, Isabelle, Vishwanath, Venkatram, Balaprakash, Prasanna (2023).
&ldquo;Asynchronous Decentralized Bayesian Optimization for Large Scale Hyperparameter Optimization.&rdquo;
In <em>2023 IEEE 19th International Conference on e-Science (e-Science)</em>, 1&ndash;10.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_ei">mlr_acqfunctions_stochastic_ei</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("stochastic_cb", surrogate = surrogate, lambda = 3)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_acqfunctions_stochastic_ei'>Acquisition Function Stochastic Expected Improvement</h2><span id='topic+mlr_acqfunctions_stochastic_ei'></span><span id='topic+AcqFunctionStochasticEI'></span>

<h3>Description</h3>

<p>Expected Improvement with epsilon decay.
<code class="reqn">\epsilon</code> is updated after each update by the formula <code>epsilon * exp(-rate * (t %% period))</code> where <code>t</code> is the number of times the acquisition function has been updated.
</p>
<p>While this acquisition function usually would be used within an asynchronous optimizer, e.g., <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>,
it can in principle also be used in synchronous optimizers, e.g., <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+AcqFunction">AcqFunction</a> can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a> or with the associated sugar function <code><a href="#topic+acqf">acqf()</a></code>:
</p>
<div class="sourceCode"><pre>mlr_acqfunctions$get("stochastic_ei")
acqf("stochastic_ei")
</pre></div>


<h3>Parameters</h3>


<ul>
<li> <p><code>"epsilon"</code> (<code>numeric(1)</code>)<br />
<code class="reqn">\epsilon</code> value used to determine the amount of exploration.
Higher values result in the importance of improvements predicted by the posterior mean
decreasing relative to the importance of potential improvements in regions of high predictive uncertainty.
Defaults to <code>0.1</code>.
</p>
</li>
<li> <p><code>"rate"</code> (<code>numeric(1)</code>)<br />
Defaults to <code>0.05</code>.
</p>
</li>
<li> <p><code>"period"</code> (<code>integer(1)</code>)<br />
Period of the exponential decay.
Defaults to <code>NULL</code>, i.e., the decay has no period.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> This acquisition function always also returns its current (<code>acq_epsilon</code>) and original (<code>acq_epsilon_0</code>) <code class="reqn">\epsilon</code>.
These values will be logged into the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> of the <a href="#topic+AcqOptimizer">AcqOptimizer</a> and
therefore also in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the actual <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> that is to be optimized.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+AcqFunction">mlr3mbo::AcqFunction</a></code> -&gt; <code>AcqFunctionStochasticEI</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y_best</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Best objective function value observed so far.
In the case of maximization, this already includes the necessary change of sign.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AcqFunctionStochasticEI-new"><code>AcqFunctionStochasticEI$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticEI-update"><code>AcqFunctionStochasticEI$update()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticEI-reset"><code>AcqFunctionStochasticEI$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-AcqFunctionStochasticEI-clone"><code>AcqFunctionStochasticEI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_dt"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_dt'><code>mlr3mbo::AcqFunction$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="AcqFunction" data-id="eval_many"><a href='../../mlr3mbo/html/AcqFunction.html#method-AcqFunction-eval_many'><code>mlr3mbo::AcqFunction$eval_many()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AcqFunctionStochasticEI-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticEI$new(
  surrogate = NULL,
  epsilon = 0.1,
  rate = 0.05,
  period = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<code>NULL</code> | <a href="#topic+SurrogateLearner">SurrogateLearner</a>).</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>rate</code></dt><dd><p>(<code>numeric(1)</code>).</p>
</dd>
<dt><code>period</code></dt><dd><p>(<code>NULL</code> | <code>integer(1)</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AcqFunctionStochasticEI-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the acquisition function.
Sets <code>y_best</code> to the best observed objective function value.
Decays epsilon.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticEI$update()</pre></div>


<hr>
<a id="method-AcqFunctionStochasticEI-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the acquisition function.
Resets the private update counter <code>.t</code> used within the epsilon decay.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticEI$reset()</pre></div>


<hr>
<a id="method-AcqFunctionStochasticEI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AcqFunctionStochasticEI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Jones, R. D, Schonlau, Matthias, Welch, J. W (1998).
&ldquo;Efficient Global Optimization of Expensive Black-Box Functions.&rdquo;
<em>Journal of Global optimization</em>, <b>13</b>(4), 455&ndash;492.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Acquisition Function: 
<code><a href="#topic+AcqFunction">AcqFunction</a></code>,
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_acqfunctions_aei">mlr_acqfunctions_aei</a></code>,
<code><a href="#topic+mlr_acqfunctions_cb">mlr_acqfunctions_cb</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvi">mlr_acqfunctions_ehvi</a></code>,
<code><a href="#topic+mlr_acqfunctions_ehvigh">mlr_acqfunctions_ehvigh</a></code>,
<code><a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a></code>,
<code><a href="#topic+mlr_acqfunctions_eips">mlr_acqfunctions_eips</a></code>,
<code><a href="#topic+mlr_acqfunctions_mean">mlr_acqfunctions_mean</a></code>,
<code><a href="#topic+mlr_acqfunctions_multi">mlr_acqfunctions_multi</a></code>,
<code><a href="#topic+mlr_acqfunctions_pi">mlr_acqfunctions_pi</a></code>,
<code><a href="#topic+mlr_acqfunctions_sd">mlr_acqfunctions_sd</a></code>,
<code><a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a></code>,
<code><a href="#topic+mlr_acqfunctions_stochastic_cb">mlr_acqfunctions_stochastic_cb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)
  library(data.table)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  instance$eval_batch(data.table(x = c(-6, -5, 3, 9)))

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  acq_function = acqf("stochastic_ei", surrogate = surrogate)

  acq_function$surrogate$update()
  acq_function$update()
  acq_function$eval_dt(data.table(x = c(-1, 0, 1)))
}
</code></pre>

<hr>
<h2 id='mlr_loop_functions'>Dictionary of Loop Functions</h2><span id='topic+mlr_loop_functions'></span>

<h3>Description</h3>

<p>A simple <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <code>loop_function</code>.
Each loop function has an associated help page, see <code>mlr_loop_functions_[id]</code>.
</p>
<p>Retrieves object with key <code>key</code> from the dictionary.
Additional arguments must be named and are passed to the constructor of the stored object.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_+3A_key">key</code></td>
<td>
<p>(<code>character(1)</code>).</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_+3A_...">...</code></td>
<td>
<p>(<code>any</code>)<br />
Passed down to constructor.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Value</h3>

<p>Object with corresponding key.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>See Also</h3>

<p>Other Dictionary: 
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_result_assigners">mlr_result_assigners</a></code>
</p>
<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
as.data.table(mlr_loop_functions)
</code></pre>

<hr>
<h2 id='mlr_loop_functions_ego'>Sequential Single-Objective Bayesian Optimization</h2><span id='topic+mlr_loop_functions_ego'></span><span id='topic+bayesopt_ego'></span>

<h3>Description</h3>

<p>Loop function for sequential single-objective Bayesian Optimization.
Normally used inside an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>
<p>In each iteration after the initial design, the surrogate and acquisition function are updated and the next candidate
is chosen based on optimizing the acquisition function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesopt_ego(
  instance,
  surrogate,
  acq_function,
  acq_optimizer,
  init_design_size = NULL,
  random_interleave_iter = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_ego_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> to be optimized.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_ego_+3A_surrogate">surrogate</code></td>
<td>
<p>(<a href="#topic+Surrogate">Surrogate</a>)<br />
<a href="#topic+Surrogate">Surrogate</a> to be used as a surrogate.
Typically a <a href="#topic+SurrogateLearner">SurrogateLearner</a>.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_ego_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+AcqFunction">AcqFunction</a>)<br />
<a href="#topic+AcqFunction">AcqFunction</a> to be used as acquisition function.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_ego_+3A_acq_optimizer">acq_optimizer</code></td>
<td>
<p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a>)<br />
<a href="#topic+AcqOptimizer">AcqOptimizer</a> to be used as acquisition function optimizer.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_ego_+3A_init_design_size">init_design_size</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>)<br />
Size of the initial design.
If <code>NULL</code> and the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> contains no evaluations, <code>4 * d</code> is used with <code>d</code> being the
dimensionality of the search space.
Points are generated via a Sobol sequence.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_ego_+3A_random_interleave_iter">random_interleave_iter</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Every <code>random_interleave_iter</code> iteration (starting after the initial design), a point is
sampled uniformly at random and evaluated (instead of a model based proposal).
For example, if <code>random_interleave_iter = 2</code>, random interleaving is performed in the second,
fourth, sixth, ... iteration.
Default is <code>0</code>, i.e., no random interleaving is performed at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(instance)<br />
The original instance is modified in-place and returned invisible.
</p>


<h3>Note</h3>


<ul>
<li><p> The <code>acq_function$surrogate</code>, even if already populated, will always be overwritten by the <code>surrogate</code>.
</p>
</li>
<li><p> The <code>acq_optimizer$acq_function</code>, even if already populated, will always be overwritten by <code>acq_function</code>.
</p>
</li>
<li><p> The <code>surrogate$archive</code>, even if already populated, will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Jones, R. D, Schonlau, Matthias, Welch, J. W (1998).
&ldquo;Efficient Global Optimization of Expensive Black-Box Functions.&rdquo;
<em>Journal of Global optimization</em>, <b>13</b>(4), 455&ndash;492.
</p>
</li>
<li><p> Snoek, Jasper, Larochelle, Hugo, Adams, P R (2012).
&ldquo;Practical Bayesian Optimization of Machine Learning Algorithms.&rdquo;
In Pereira F, Burges CJC, Bottou L, Weinberger KQ (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 25, 2951&ndash;2959.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance)

  acq_function = acqf("ei")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_ego,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)

  # expected improvement per second example
  fun = function(xs) {
    list(y = xs$x ^ 2, time = abs(xs$x))
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"), time = p_dbl(tags = "time"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance, n_learner = 2)
  surrogate$cols_y = c("y", "time")

  optimizer = opt("mbo",
    loop_function = bayesopt_ego,
    surrogate = surrogate,
    acq_function = acqf("eips"),
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_loop_functions_emo'>Sequential Multi-Objective Bayesian Optimization</h2><span id='topic+mlr_loop_functions_emo'></span><span id='topic+bayesopt_emo'></span>

<h3>Description</h3>

<p>Loop function for sequential multi-objective Bayesian Optimization.
Normally used inside an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
The conceptual counterpart to <a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a>.
</p>
<p>In each iteration after the initial design, the surrogate and acquisition function are updated and the next candidate
is chosen based on optimizing the acquisition function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesopt_emo(
  instance,
  surrogate,
  acq_function,
  acq_optimizer,
  init_design_size = NULL,
  random_interleave_iter = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_emo_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> to be optimized.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_emo_+3A_surrogate">surrogate</code></td>
<td>
<p>(<a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>)<br />
<a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a> to be used as a surrogate.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_emo_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+AcqFunction">AcqFunction</a>)<br />
<a href="#topic+AcqFunction">AcqFunction</a> to be used as acquisition function.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_emo_+3A_acq_optimizer">acq_optimizer</code></td>
<td>
<p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a>)<br />
<a href="#topic+AcqOptimizer">AcqOptimizer</a> to be used as acquisition function optimizer.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_emo_+3A_init_design_size">init_design_size</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>)<br />
Size of the initial design.
If <code>NULL</code> and the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> contains no evaluations, <code>4 * d</code> is used with <code>d</code> being the
dimensionality of the search space.
Points are generated via a Sobol sequence.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_emo_+3A_random_interleave_iter">random_interleave_iter</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Every <code>random_interleave_iter</code> iteration (starting after the initial design), a point is
sampled uniformly at random and evaluated (instead of a model based proposal).
For example, if <code>random_interleave_iter = 2</code>, random interleaving is performed in the second,
fourth, sixth, ... iteration.
Default is <code>0</code>, i.e., no random interleaving is performed at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(instance)<br />
The original instance is modified in-place and returned invisible.
</p>


<h3>Note</h3>


<ul>
<li><p> The <code>acq_function$surrogate</code>, even if already populated, will always be overwritten by the <code>surrogate</code>.
</p>
</li>
<li><p> The <code>acq_optimizer$acq_function</code>, even if already populated, will always be overwritten by <code>acq_function</code>.
</p>
</li>
<li><p> The <code>surrogate$archive</code>, even if already populated, will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance)

  acq_function = acqf("ehvi")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_emo,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_loop_functions_mpcl'>Single-Objective Bayesian Optimization via Multipoint Constant Liar</h2><span id='topic+mlr_loop_functions_mpcl'></span><span id='topic+bayesopt_mpcl'></span>

<h3>Description</h3>

<p>Loop function for single-objective Bayesian Optimization via multipoint constant liar.
Normally used inside an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>
<p>In each iteration after the initial design, the surrogate and acquisition function are updated.
The acquisition function is then optimized, to find a candidate but instead of evaluating this candidate, the
objective function value is obtained by applying the <code>liar</code> function to all previously obtained objective function values.
This is repeated <code>q - 1</code> times to obtain a total of <code>q</code> candidates that are then evaluated in a single batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesopt_mpcl(
  instance,
  surrogate,
  acq_function,
  acq_optimizer,
  init_design_size = NULL,
  q = 2L,
  liar = mean,
  random_interleave_iter = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_mpcl_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> to be optimized.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_surrogate">surrogate</code></td>
<td>
<p>(<a href="#topic+Surrogate">Surrogate</a>)<br />
<a href="#topic+Surrogate">Surrogate</a> to be used as a surrogate.
Typically a <a href="#topic+SurrogateLearner">SurrogateLearner</a>.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+AcqFunction">AcqFunction</a>)<br />
<a href="#topic+AcqFunction">AcqFunction</a> to be used as acquisition function.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_acq_optimizer">acq_optimizer</code></td>
<td>
<p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a>)<br />
<a href="#topic+AcqOptimizer">AcqOptimizer</a> to be used as acquisition function optimizer.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_init_design_size">init_design_size</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>)<br />
Size of the initial design.
If <code>NULL</code> and the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> contains no evaluations, <code>4 * d</code> is used with <code>d</code> being the
dimensionality of the search space.
Points are generated via a Sobol sequence.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_q">q</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Batch size &gt; <code>1</code>.
Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_liar">liar</code></td>
<td>
<p>(<code>function</code>)<br />
Any function accepting a numeric vector as input and returning a single numeric output.
Default is <code>mean</code>. Other sensible functions include <code>min</code> (or <code>max</code>, depending on the optimization direction).</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_mpcl_+3A_random_interleave_iter">random_interleave_iter</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Every <code>random_interleave_iter</code> iteration (starting after the initial design), a point is
sampled uniformly at random and evaluated (instead of a model based proposal).
For example, if <code>random_interleave_iter = 2</code>, random interleaving is performed in the second,
fourth, sixth, ... iteration.
Default is <code>0</code>, i.e., no random interleaving is performed at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(instance)<br />
The original instance is modified in-place and returned invisible.
</p>


<h3>Note</h3>


<ul>
<li><p> The <code>acq_function$surrogate</code>, even if already populated, will always be overwritten by the <code>surrogate</code>.
</p>
</li>
<li><p> The <code>acq_optimizer$acq_function</code>, even if already populated, will always be overwritten by <code>acq_function</code>.
</p>
</li>
<li><p> The <code>surrogate$archive</code>, even if already populated, will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a>.
</p>
</li>
<li><p> To make use of parallel evaluations in the case of 'q &gt; 1, the objective
function of the <a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> must be implemented accordingly.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Ginsbourger, David, Le Riche, Rodolphe, Carraro, Laurent (2008).
&ldquo;A Multi-Points Criterion for Deterministic Parallel Global Optimization Based on Gaussian Processes.&rdquo;
</p>
</li>
<li><p> Wang, Jialei, Clark, C. S, Liu, Eric, Frazier, I. P (2020).
&ldquo;Parallel Bayesian Global Optimization of Expensive Functions.&rdquo;
<em>Operations Research</em>, <b>68</b>(6), 1850&ndash;1865.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 7))

  surrogate = default_surrogate(instance)

  acq_function = acqf("ei")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_mpcl,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer,
    args = list(q = 3))

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_loop_functions_parego'>Multi-Objective Bayesian Optimization via ParEGO</h2><span id='topic+mlr_loop_functions_parego'></span><span id='topic+bayesopt_parego'></span>

<h3>Description</h3>

<p>Loop function for multi-objective Bayesian Optimization via ParEGO.
Normally used inside an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>
<p>In each iteration after the initial design, the observed objective function values are normalized and <code>q</code> candidates are
obtained by scalarizing these values via the augmented Tchebycheff function, updating the surrogate with respect to
these scalarized values and optimizing the acquisition function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesopt_parego(
  instance,
  surrogate,
  acq_function,
  acq_optimizer,
  init_design_size = NULL,
  q = 1L,
  s = 100L,
  rho = 0.05,
  random_interleave_iter = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_parego_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> to be optimized.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_surrogate">surrogate</code></td>
<td>
<p>(<a href="#topic+SurrogateLearner">SurrogateLearner</a>)<br />
<a href="#topic+SurrogateLearner">SurrogateLearner</a> to be used as a surrogate.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+AcqFunction">AcqFunction</a>)<br />
<a href="#topic+AcqFunction">AcqFunction</a> to be used as acquisition function.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_acq_optimizer">acq_optimizer</code></td>
<td>
<p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a>)<br />
<a href="#topic+AcqOptimizer">AcqOptimizer</a> to be used as acquisition function optimizer.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_init_design_size">init_design_size</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>)<br />
Size of the initial design.
If <code>NULL</code> and the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> contains no evaluations, <code>4 * d</code> is used with <code>d</code> being the
dimensionality of the search space.
Points are generated via a Sobol sequence.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_q">q</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Batch size, i.e., the number of candidates to be obtained for a single batch.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_s">s</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
<code class="reqn">s</code> in Equation 1 in Knowles (2006).
Determines the total number of possible random weight vectors.
Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_rho">rho</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
<code class="reqn">\rho</code> in Equation 2 in Knowles (2006) scaling the linear part of the augmented Tchebycheff function.
Default is <code>0.05</code></p>
</td></tr>
<tr><td><code id="mlr_loop_functions_parego_+3A_random_interleave_iter">random_interleave_iter</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Every <code>random_interleave_iter</code> iteration (starting after the initial design), a point is
sampled uniformly at random and evaluated (instead of a model based proposal).
For example, if <code>random_interleave_iter = 2</code>, random interleaving is performed in the second,
fourth, sixth, ... iteration.
Default is <code>0</code>, i.e., no random interleaving is performed at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(instance)<br />
The original instance is modified in-place and returned invisible.
</p>


<h3>Note</h3>


<ul>
<li><p> The <code>acq_function$surrogate</code>, even if already populated, will always be overwritten by the <code>surrogate</code>.
</p>
</li>
<li><p> The <code>acq_optimizer$acq_function</code>, even if already populated, will always be overwritten by <code>acq_function</code>.
</p>
</li>
<li><p> The <code>surrogate$archive</code>, even if already populated, will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>.
</p>
</li>
<li><p> The scalarizations of the objective function values are stored as the <code>y_scal</code> column in the
<a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>.
</p>
</li>
<li><p> To make use of parallel evaluations in the case of 'q &gt; 1, the objective
function of the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> must be implemented accordingly.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Knowles, Joshua (2006).
&ldquo;ParEGO: A Hybrid Algorithm With On-Line Landscape Approximation for Expensive Multiobjective Optimization Problems.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>10</b>(1), 50&ndash;66.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_smsego">mlr_loop_functions_smsego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance, n_learner = 1)

  acq_function = acqf("ei")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_parego,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_loop_functions_smsego'>Sequential Multi-Objective Bayesian Optimization via SMS-EGO</h2><span id='topic+mlr_loop_functions_smsego'></span><span id='topic+bayesopt_smsego'></span>

<h3>Description</h3>

<p>Loop function for sequential multi-objective Bayesian Optimization via SMS-EGO.
Normally used inside an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>
<p>In each iteration after the initial design, the surrogate and acquisition function (<a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a>) are
updated and the next candidate is chosen based on optimizing the acquisition function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesopt_smsego(
  instance,
  surrogate,
  acq_function,
  acq_optimizer,
  init_design_size = NULL,
  random_interleave_iter = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_loop_functions_smsego_+3A_instance">instance</code></td>
<td>
<p>(<a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> to be optimized.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_smsego_+3A_surrogate">surrogate</code></td>
<td>
<p>(<a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>)<br />
<a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a> to be used as a surrogate.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_smsego_+3A_acq_function">acq_function</code></td>
<td>
<p>(<a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a>)<br />
<a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a> to be used as acquisition function.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_smsego_+3A_acq_optimizer">acq_optimizer</code></td>
<td>
<p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a>)<br />
<a href="#topic+AcqOptimizer">AcqOptimizer</a> to be used as acquisition function optimizer.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_smsego_+3A_init_design_size">init_design_size</code></td>
<td>
<p>(<code>NULL</code> | <code>integer(1)</code>)<br />
Size of the initial design.
If <code>NULL</code> and the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> contains no evaluations, <code>4 * d</code> is used with <code>d</code> being the
dimensionality of the search space.
Points are generated via a Sobol sequence.</p>
</td></tr>
<tr><td><code id="mlr_loop_functions_smsego_+3A_random_interleave_iter">random_interleave_iter</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Every <code>random_interleave_iter</code> iteration (starting after the initial design), a point is
sampled uniformly at random and evaluated (instead of a model based proposal).
For example, if <code>random_interleave_iter = 2</code>, random interleaving is performed in the second,
fourth, sixth, ... iteration.
Default is <code>0</code>, i.e., no random interleaving is performed at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(instance)<br />
The original instance is modified in-place and returned invisible.
</p>


<h3>Note</h3>


<ul>
<li><p> The <code>acq_function$surrogate</code>, even if already populated, will always be overwritten by the <code>surrogate</code>.
</p>
</li>
<li><p> The <code>acq_optimizer$acq_function</code>, even if already populated, will always be overwritten by <code>acq_function</code>.
</p>
</li>
<li><p> The <code>surrogate$archive</code>, even if already populated, will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a>.
</p>
</li>
<li><p> Due to the iterative computation of the epsilon within the <a href="#topic+mlr_acqfunctions_smsego">mlr_acqfunctions_smsego</a>, requires the <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> of
the <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> to be a <a href="bbotk.html#topic+mlr_terminators_evals">bbotk::TerminatorEvals</a>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Beume N, Naujoks B, Emmerich M (2007).
&ldquo;SMS-EMOA: Multiobjective selection based on dominated hypervolume.&rdquo;
<em>European Journal of Operational Research</em>, <b>181</b>(3), 1653&ndash;1669.
</p>
</li>
<li><p> Ponweiser, Wolfgang, Wagner, Tobias, Biermann, Dirk, Vincze, Markus (2008).
&ldquo;Multiobjective Optimization on a Limited Budget of Evaluations Using Model-Assisted S-Metric Selection.&rdquo;
In <em>Proceedings of the 10th International Conference on Parallel Problem Solving from Nature</em>, 784&ndash;794.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Loop Function: 
<code><a href="#topic+loop_function">loop_function</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>,
<code><a href="#topic+mlr_loop_functions_ego">mlr_loop_functions_ego</a></code>,
<code><a href="#topic+mlr_loop_functions_emo">mlr_loop_functions_emo</a></code>,
<code><a href="#topic+mlr_loop_functions_mpcl">mlr_loop_functions_mpcl</a></code>,
<code><a href="#topic+mlr_loop_functions_parego">mlr_loop_functions_parego</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance)

  acq_function = acqf("smsego")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_smsego,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_optimizers_adbo'>Asynchronous Decentralized Bayesian Optimization</h2><span id='topic+mlr_optimizers_adbo'></span><span id='topic+OptimizerADBO'></span>

<h3>Description</h3>

<p><code>OptimizerADBO</code> class that implements Asynchronous Decentralized Bayesian Optimization (ADBO).
ADBO is a variant of Asynchronous Model Based Optimization (AMBO) that uses <a href="#topic+AcqFunctionStochasticCB">AcqFunctionStochasticCB</a> with exponential lambda decay.
</p>
<p>Currently, only single-objective optimization is supported and <a href="#topic+OptimizerADBO">OptimizerADBO</a> is considered an experimental feature and API might be subject to changes.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>lambda</code></dt><dd><p><code>numeric(1)</code><br />
Value used for sampling the lambda for each worker from an exponential distribution.</p>
</dd>
<dt><code>rate</code></dt><dd><p><code>numeric(1)</code><br />
Rate of the exponential decay.</p>
</dd>
<dt><code>period</code></dt><dd><p><code>integer(1)</code><br />
Period of the exponential decay.</p>
</dd>
<dt><code>initial_design</code></dt><dd><p><code>data.table::data.table()</code><br />
Initial design of the optimization.
If <code>NULL</code>, a design of size <code>design_size</code> is generated with the specified <code>design_function</code>.
Default is <code>NULL</code>.</p>
</dd>
<dt><code>design_size</code></dt><dd><p><code>integer(1)</code><br />
Size of the initial design if it is to be generated.
Default is <code>100</code>.</p>
</dd>
<dt><code>design_function</code></dt><dd><p><code>character(1)</code><br />
Sampling function to generate the initial design.
Can be <code>random</code> <a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a>, <code>lhs</code> <a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a>, or <code>sobol</code> <a href="paradox.html#topic+generate_design_sobol">paradox::generate_design_sobol</a>.
Default is <code>sobol</code>.</p>
</dd>
<dt><code>n_workers</code></dt><dd><p><code>integer(1)</code><br />
Number of parallel workers.
If <code>NULL</code>, all rush workers specified via <code><a href="rush.html#topic+rush_plan">rush::rush_plan()</a></code> are used.
Default is <code>NULL</code>.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code><a href="bbotk.html#topic+OptimizerAsync">bbotk::OptimizerAsync</a></code> -&gt; <code><a href="#topic+OptimizerAsyncMbo">mlr3mbo::OptimizerAsyncMbo</a></code> -&gt; <code>OptimizerADBO</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerADBO-new"><code>OptimizerADBO$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerADBO-optimize"><code>OptimizerADBO$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerADBO-clone"><code>OptimizerADBO$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="OptimizerAsyncMbo" data-id="print"><a href='../../mlr3mbo/html/OptimizerAsyncMbo.html#method-OptimizerAsyncMbo-print'><code>mlr3mbo::OptimizerAsyncMbo$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="OptimizerAsyncMbo" data-id="reset"><a href='../../mlr3mbo/html/OptimizerAsyncMbo.html#method-OptimizerAsyncMbo-reset'><code>mlr3mbo::OptimizerAsyncMbo$reset()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerADBO-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerADBO$new()</pre></div>


<hr>
<a id="method-OptimizerADBO-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the optimization on an <a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> until termination.
The single evaluations will be written into the <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a>.
The result will be written into the instance object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerADBO$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-OptimizerADBO-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerADBO$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The lambda parameter of the confidence bound acquisition function controls the trade-off between exploration and exploitation.
A large lambda value leads to more exploration, while a small lambda value leads to more exploitation.
The initial lambda value of the acquisition function used on each worker is drawn from an exponential distribution with rate <code>1 / lambda</code>.
ADBO can use periodic exponential decay to reduce lambda periodically for a given time step <code>t</code> with the formula <code>lambda * exp(-rate * (t %% period))</code>.
The <a href="#topic+SurrogateLearner">SurrogateLearner</a> is configured to use a random forest and the <a href="#topic+AcqOptimizer">AcqOptimizer</a> is a random search with a batch size of 1000 and a budget of 10000 evaluations.
</p>


<h3>References</h3>


<ul>
<li><p> Egelé, Romain, Guyon, Isabelle, Vishwanath, Venkatram, Balaprakash, Prasanna (2023).
&ldquo;Asynchronous Decentralized Bayesian Optimization for Large Scale Hyperparameter Optimization.&rdquo;
In <em>2023 IEEE 19th International Conference on e-Science (e-Science)</em>, 1&ndash;10.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rush") &amp;
    requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  if (redis_available()) {

    library(bbotk)
    library(paradox)
    library(mlr3learners)

    fun = function(xs) {
      list(y = xs$x ^ 2)
    }
    domain = ps(x = p_dbl(lower = -10, upper = 10))
    codomain = ps(y = p_dbl(tags = "minimize"))
    objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

    instance = OptimInstanceAsyncSingleCrit$new(
      objective = objective,
      terminator = trm("evals", n_evals = 10))

    rush::rush_plan(n_workers=2)

    optimizer = opt("adbo", design_size = 4, n_workers = 2)

    optimizer$optimize(instance)
  } else {
    message("Redis server is not available.\nPlease set up Redis prior to running the example.")
  }
}

</code></pre>

<hr>
<h2 id='mlr_optimizers_async_mbo'>Asynchronous Model Based Optimization</h2><span id='topic+mlr_optimizers_async_mbo'></span><span id='topic+OptimizerAsyncMbo'></span>

<h3>Description</h3>

<p><code>OptimizerAsyncMbo</code> class that implements Asynchronous Model Based Optimization (AMBO).
AMBO starts multiple sequential MBO runs on different workers.
The worker communicate asynchronously through a shared archive relying on the <a href="https://CRAN.R-project.org/package=rush"><span class="pkg">rush</span></a> package.
The optimizer follows a modular layout in which the surrogate model, acquisition function, and acquisition optimizer can be changed.
The <a href="#topic+SurrogateLearner">SurrogateLearner</a> will impute missing values due to pending evaluations.
A stochastic <a href="#topic+AcqFunction">AcqFunction</a>, e.g., <a href="#topic+AcqFunctionStochasticEI">AcqFunctionStochasticEI</a> or <a href="#topic+AcqFunctionStochasticCB">AcqFunctionStochasticCB</a> is used to create varying versions of the acquisition
function on each worker, promoting different exploration-exploitation trade-offs.
The <a href="#topic+AcqOptimizer">AcqOptimizer</a> class remains consistent with the one used in synchronous MBO.
</p>
<p>In contrast to <a href="#topic+OptimizerMbo">OptimizerMbo</a>, no <a href="#topic+loop_function">loop_function</a> can be specified that determines the AMBO flavor as <code>OptimizerAsyncMbo</code> simply relies on
a surrogate update, acquisition function update and acquisition function optimization step as an internal loop.
</p>
<p>Currently, only single-objective optimization is supported and <code>OptimizerAsyncMbo</code> is considered an experimental feature and API might be subject to changes.
</p>
<p>Note that in general the <a href="#topic+SurrogateLearner">SurrogateLearner</a> is updated one final time on all available data after the optimization process has terminated.
However, in certain scenarios this is not always possible or meaningful.
It is therefore recommended to manually inspect the <a href="#topic+SurrogateLearner">SurrogateLearner</a> after optimization if it is to be used, e.g., for visualization purposes to make
sure that it has been properly updated on all available data.
If this final update of the <a href="#topic+SurrogateLearner">SurrogateLearner</a> could not be performed successfully, a warning will be logged.
</p>
<p>By specifying a <a href="#topic+ResultAssigner">ResultAssigner</a>, one can alter how the final result is determined after optimization, e.g.,
simply based on the evaluations logged in the archive <a href="#topic+ResultAssignerArchive">ResultAssignerArchive</a> or based on the <a href="#topic+Surrogate">Surrogate</a> via <a href="#topic+ResultAssignerSurrogate">ResultAssignerSurrogate</a>.
</p>


<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a> holds the following additional columns that are specific to AMBO algorithms:
</p>

<ul>
<li> <p><code>acq_function$id</code> (<code>numeric(1)</code>)<br />
The value of the acquisition function.
</p>
</li>
<li> <p><code>".already_evaluated"</code> (<code style="white-space: pre;">&#8288;logical(1))&#8288;</code><br />
Whether this point was already evaluated. Depends on the <code>skip_already_evaluated</code> parameter of the <a href="#topic+AcqOptimizer">AcqOptimizer</a>.
</p>
</li></ul>

<p>If the <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a> does not contain any evaluations prior to optimization, an initial design is needed.
If the <code>initial_design</code> parameter is specified to be a <code>data.table</code>, this data will be used.
Otherwise, if it is <code>NULL</code>, an initial design of size <code>design_size</code> will be generated based on the <code>generate_design</code> sampling function.
See also the parameters below.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>initial_design</code></dt><dd><p><code>data.table::data.table()</code><br />
Initial design of the optimization.
If <code>NULL</code>, a design of size <code>design_size</code> is generated with the specified <code>design_function</code>.
Default is <code>NULL</code>.</p>
</dd>
<dt><code>design_size</code></dt><dd><p><code>integer(1)</code><br />
Size of the initial design if it is to be generated.
Default is <code>100</code>.</p>
</dd>
<dt><code>design_function</code></dt><dd><p><code>character(1)</code><br />
Sampling function to generate the initial design.
Can be <code>random</code> <a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a>, <code>lhs</code> <a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a>, or <code>sobol</code> <a href="paradox.html#topic+generate_design_sobol">paradox::generate_design_sobol</a>.
Default is <code>sobol</code>.</p>
</dd>
<dt><code>n_workers</code></dt><dd><p><code>integer(1)</code><br />
Number of parallel workers.
If <code>NULL</code>, all rush workers specified via <code><a href="rush.html#topic+rush_plan">rush::rush_plan()</a></code> are used.
Default is <code>NULL</code>.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code><a href="bbotk.html#topic+OptimizerAsync">bbotk::OptimizerAsync</a></code> -&gt; <code>OptimizerAsyncMbo</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize.
Determined based on the <code>surrogate</code> and the <code>acq_optimizer</code>.
This corresponds to the values given by a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>'s
<code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="bbotk.html#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.
MBO in principle is very flexible and by default we assume that the optimizer has all properties.
When fully initialized, properties are determined based on the loop, e.g., the <code>loop_function</code>, and <code>surrogate</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to optimization if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.
Required packages are determined based on the <code>acq_function</code>, <code>surrogate</code> and the <code>acq_optimizer</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerAsyncMbo-new"><code>OptimizerAsyncMbo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerAsyncMbo-print"><code>OptimizerAsyncMbo$print()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerAsyncMbo-reset"><code>OptimizerAsyncMbo$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerAsyncMbo-optimize"><code>OptimizerAsyncMbo$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerAsyncMbo-clone"><code>OptimizerAsyncMbo$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerAsyncMbo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>
<p>If <code>surrogate</code> is <code>NULL</code> and the <code>acq_function$surrogate</code> field is populated, this <a href="#topic+SurrogateLearner">SurrogateLearner</a> is used.
Otherwise, <code>default_surrogate(instance)</code> is used.
If <code>acq_function</code> is <code>NULL</code> and the <code>acq_optimizer$acq_function</code> field is populated, this <a href="#topic+AcqFunction">AcqFunction</a> is used (and therefore its <code style="white-space: pre;">&#8288;$surrogate&#8288;</code> if populated; see above).
Otherwise <code>default_acqfunction(instance)</code> is used.
If <code>acq_optimizer</code> is <code>NULL</code>, <code>default_acqoptimizer(instance)</code> is used.
</p>
<p>Even if already initialized, the <code>surrogate$archive</code> field will always be overwritten by the <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a> of the current <a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> to be optimized.
</p>
<p>For more information on default values for <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code> and <code>result_assigner</code>, see <code>?mbo_defaults</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerAsyncMbo$new(
  id = "async_mbo",
  surrogate = NULL,
  acq_function = NULL,
  acq_optimizer = NULL,
  result_assigner = NULL,
  param_set = NULL,
  label = "Asynchronous Model Based Optimization",
  man = "mlr3mbo::OptimizerAsyncMbo"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of control parameters.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimizerAsyncMbo-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerAsyncMbo$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-OptimizerAsyncMbo-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the optimizer.
Sets the following fields to <code>NULL</code>:
<code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>,<code>result_assigner</code>
Resets parameter values <code>design_size</code> and <code>design_function</code> to their defaults.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerAsyncMbo$reset()</pre></div>


<hr>
<a id="method-OptimizerAsyncMbo-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the optimization on an <a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> until termination.
The single evaluations will be written into the <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a>.
The result will be written into the instance object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerAsyncMbo$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-OptimizerAsyncMbo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerAsyncMbo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rush") &amp;
    requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  if (redis_available()) {

    library(bbotk)
    library(paradox)
    library(mlr3learners)

    fun = function(xs) {
      list(y = xs$x ^ 2)
    }
    domain = ps(x = p_dbl(lower = -10, upper = 10))
    codomain = ps(y = p_dbl(tags = "minimize"))
    objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

    instance = OptimInstanceAsyncSingleCrit$new(
      objective = objective,
      terminator = trm("evals", n_evals = 10))

    rush::rush_plan(n_workers=2)

    optimizer = opt("async_mbo", design_size = 4, n_workers = 2)

    optimizer$optimize(instance)
  } else {
    message("Redis server is not available.\nPlease set up Redis prior to running the example.")
  }
}

</code></pre>

<hr>
<h2 id='mlr_optimizers_mbo'>Model Based Optimization</h2><span id='topic+mlr_optimizers_mbo'></span><span id='topic+OptimizerMbo'></span>

<h3>Description</h3>

<p><code>OptimizerMbo</code> class that implements Model Based Optimization (MBO).
The implementation follows a modular layout relying on a <a href="#topic+loop_function">loop_function</a> determining the MBO flavor to be used, e.g.,
<a href="#topic+bayesopt_ego">bayesopt_ego</a> for sequential single-objective Bayesian Optimization, a <a href="#topic+Surrogate">Surrogate</a>, an <a href="#topic+AcqFunction">AcqFunction</a>, e.g., <a href="#topic+mlr_acqfunctions_ei">mlr_acqfunctions_ei</a> for
Expected Improvement and an <a href="#topic+AcqOptimizer">AcqOptimizer</a>.
</p>
<p>MBO algorithms are iterative optimization algorithms that make use of a continuously updated surrogate model built for the objective function.
By optimizing a comparably cheap to evaluate acquisition function defined on the surrogate prediction, the next candidate is chosen for evaluation.
</p>
<p>Detailed descriptions of different MBO flavors are provided in the documentation of the respective <a href="#topic+loop_function">loop_function</a>.
</p>
<p>Termination is handled via a <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> part of the <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> to be optimized.
</p>
<p>Note that in general the <a href="#topic+Surrogate">Surrogate</a> is updated one final time on all available data after the optimization process has terminated.
However, in certain scenarios this is not always possible or meaningful, e.g., when using <code><a href="#topic+bayesopt_parego">bayesopt_parego()</a></code> for multi-objective optimization
which uses a surrogate that relies on a scalarization of the objectives.
It is therefore recommended to manually inspect the <a href="#topic+Surrogate">Surrogate</a> after optimization if it is to be used, e.g., for visualization purposes to make
sure that it has been properly updated on all available data.
If this final update of the <a href="#topic+Surrogate">Surrogate</a> could not be performed successfully, a warning will be logged.
</p>
<p>By specifying a <a href="#topic+ResultAssigner">ResultAssigner</a>, one can alter how the final result is determined after optimization, e.g.,
simply based on the evaluations logged in the archive <a href="#topic+ResultAssignerArchive">ResultAssignerArchive</a> or based on the <a href="#topic+Surrogate">Surrogate</a> via <a href="#topic+ResultAssignerSurrogate">ResultAssignerSurrogate</a>.
</p>


<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> holds the following additional columns that are specific to MBO algorithms:
</p>

<ul>
<li> <p><code>acq_function$id</code> (<code>numeric(1)</code>)<br />
The value of the acquisition function.
</p>
</li>
<li> <p><code>".already_evaluated"</code> (<code style="white-space: pre;">&#8288;logical(1))&#8288;</code><br />
Whether this point was already evaluated. Depends on the <code>skip_already_evaluated</code> parameter of the <a href="#topic+AcqOptimizer">AcqOptimizer</a>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code><a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a></code> -&gt; <code>OptimizerMbo</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loop_function</code></dt><dd><p>(<a href="#topic+loop_function">loop_function</a> | <code>NULL</code>)<br />
Loop function determining the MBO flavor.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>args</code></dt><dd><p>(named <code>list()</code>)<br />
Further arguments passed to the <code>loop_function</code>.
For example, <code>random_interleave_iter</code>.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize.
Determined based on the <code>surrogate</code> and the <code>acq_optimizer</code>.
This corresponds to the values given by a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>'s
<code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="bbotk.html#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.
MBO in principle is very flexible and by default we assume that the optimizer has all properties.
When fully initialized, properties are determined based on the loop, e.g., the <code>loop_function</code>, and <code>surrogate</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to optimization if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.
Required packages are determined based on the <code>acq_function</code>, <code>surrogate</code> and the <code>acq_optimizer</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerMbo-new"><code>OptimizerMbo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerMbo-print"><code>OptimizerMbo$print()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerMbo-reset"><code>OptimizerMbo$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerMbo-optimize"><code>OptimizerMbo$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerMbo-clone"><code>OptimizerMbo$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerMbo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>
<p>If <code>surrogate</code> is <code>NULL</code> and the <code>acq_function$surrogate</code> field is populated, this <a href="#topic+Surrogate">Surrogate</a> is used.
Otherwise, <code>default_surrogate(instance)</code> is used.
If <code>acq_function</code> is <code>NULL</code> and the <code>acq_optimizer$acq_function</code> field is populated, this <a href="#topic+AcqFunction">AcqFunction</a> is used (and therefore its <code style="white-space: pre;">&#8288;$surrogate&#8288;</code> if populated; see above).
Otherwise <code>default_acqfunction(instance)</code> is used.
If <code>acq_optimizer</code> is <code>NULL</code>, <code>default_acqoptimizer(instance)</code> is used.
</p>
<p>Even if already initialized, the <code>surrogate$archive</code> field will always be overwritten by the <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of the current <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a> to be optimized.
</p>
<p>For more information on default values for <code>loop_function</code>, <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code> and <code>result_assigner</code>, see <code>?mbo_defaults</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMbo$new(
  loop_function = NULL,
  surrogate = NULL,
  acq_function = NULL,
  acq_optimizer = NULL,
  args = NULL,
  result_assigner = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>loop_function</code></dt><dd><p>(<a href="#topic+loop_function">loop_function</a> | <code>NULL</code>)<br />
Loop function determining the MBO flavor.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>args</code></dt><dd><p>(named <code>list()</code>)<br />
Further arguments passed to the <code>loop_function</code>.
For example, <code>random_interleave_iter</code>.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimizerMbo-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMbo$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-OptimizerMbo-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the optimizer.
Sets the following fields to <code>NULL</code>:
<code>loop_function</code>, <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, <code>args</code>, <code>result_assigner</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMbo$reset()</pre></div>


<hr>
<a id="method-OptimizerMbo-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the optimization and writes optimization result into <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a>.
The optimization result is returned but the complete optimization path is stored in <a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a> of <a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMbo$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>.
</p>


<hr>
<a id="method-OptimizerMbo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMbo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(bbotk)
  library(paradox)
  library(mlr3learners)

  # single-objective EGO
  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  surrogate = default_surrogate(instance)

  acq_function = acqf("ei")

  acq_optimizer = acqo(
    optimizer = opt("random_search", batch_size = 100),
    terminator = trm("evals", n_evals = 100))

  optimizer = opt("mbo",
    loop_function = bayesopt_ego,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)

  # multi-objective ParEGO
  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  optimizer = opt("mbo",
    loop_function = bayesopt_parego,
    surrogate = surrogate,
    acq_function = acq_function,
    acq_optimizer = acq_optimizer)

  optimizer$optimize(instance)
}

</code></pre>

<hr>
<h2 id='mlr_result_assigners'>Dictionary of Result Assigners</h2><span id='topic+mlr_result_assigners'></span>

<h3>Description</h3>

<p>A simple <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <a href="#topic+ResultAssigner">ResultAssigner</a>.
Each acquisition function has an associated help page, see <code>mlr_result_assigners_[id]</code>.
</p>
<p>For a more convenient way to retrieve and construct an acquisition function, see <code><a href="#topic+ras">ras()</a></code>.
</p>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>See Also</h3>

<p>Sugar function: <code><a href="#topic+ras">ras()</a></code>
</p>
<p>Other Dictionary: 
<code><a href="#topic+mlr_acqfunctions">mlr_acqfunctions</a></code>,
<code><a href="#topic+mlr_loop_functions">mlr_loop_functions</a></code>
</p>
<p>Other Result Assigner: 
<code><a href="#topic+ResultAssigner">ResultAssigner</a></code>,
<code><a href="#topic+mlr_result_assigners_archive">mlr_result_assigners_archive</a></code>,
<code><a href="#topic+mlr_result_assigners_surrogate">mlr_result_assigners_surrogate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
as.data.table(mlr_result_assigners)
ras("archive")
</code></pre>

<hr>
<h2 id='mlr_result_assigners_archive'>Result Assigner Based on the Archive</h2><span id='topic+mlr_result_assigners_archive'></span><span id='topic+ResultAssignerArchive'></span>

<h3>Description</h3>

<p>Result assigner that chooses the final point(s) based on all evaluations in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a>.
This mimics the default behavior of any <a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ResultAssigner">mlr3mbo::ResultAssigner</a></code> -&gt; <code>ResultAssignerArchive</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResultAssignerArchive-new"><code>ResultAssignerArchive$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssignerArchive-assign_result"><code>ResultAssignerArchive$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssignerArchive-clone"><code>ResultAssignerArchive$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="ResultAssigner" data-id="format"><a href='../../mlr3mbo/html/ResultAssigner.html#method-ResultAssigner-format'><code>mlr3mbo::ResultAssigner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="ResultAssigner" data-id="print"><a href='../../mlr3mbo/html/ResultAssigner.html#method-ResultAssigner-print'><code>mlr3mbo::ResultAssigner$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResultAssignerArchive-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerArchive$new()</pre></div>


<hr>
<a id="method-ResultAssignerArchive-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>Assigns the result, i.e., the final point(s) to the instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerArchive$assign_result(instance)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instance</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> |<a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceAsyncMultiCrit">bbotk::OptimInstanceAsyncMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> the final result should be assigned to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultAssignerArchive-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerArchive$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Result Assigner: 
<code><a href="#topic+ResultAssigner">ResultAssigner</a></code>,
<code><a href="#topic+mlr_result_assigners">mlr_result_assigners</a></code>,
<code><a href="#topic+mlr_result_assigners_surrogate">mlr_result_assigners_surrogate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result_assigner = ras("archive")
</code></pre>

<hr>
<h2 id='mlr_result_assigners_surrogate'>Result Assigner Based on a Surrogate Mean Prediction</h2><span id='topic+mlr_result_assigners_surrogate'></span><span id='topic+ResultAssignerSurrogate'></span>

<h3>Description</h3>

<p>Result assigner that chooses the final point(s) based on a surrogate mean prediction of all evaluated points in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a>.
This is especially useful in the case of noisy objective functions.
</p>
<p>In the case of operating on an <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> or <a href="bbotk.html#topic+OptimInstanceAsyncMultiCrit">bbotk::OptimInstanceAsyncMultiCrit</a> the <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a> must use as many learners as there are objective functions.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ResultAssigner">mlr3mbo::ResultAssigner</a></code> -&gt; <code>ResultAssignerSurrogate</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResultAssignerSurrogate-new"><code>ResultAssignerSurrogate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssignerSurrogate-assign_result"><code>ResultAssignerSurrogate$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssignerSurrogate-clone"><code>ResultAssignerSurrogate$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="ResultAssigner" data-id="format"><a href='../../mlr3mbo/html/ResultAssigner.html#method-ResultAssigner-format'><code>mlr3mbo::ResultAssigner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="ResultAssigner" data-id="print"><a href='../../mlr3mbo/html/ResultAssigner.html#method-ResultAssigner-print'><code>mlr3mbo::ResultAssigner$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResultAssignerSurrogate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerSurrogate$new(surrogate = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate that is used to predict the mean of all evaluated points.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultAssignerSurrogate-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>Assigns the result, i.e., the final point(s) to the instance.
If <code style="white-space: pre;">&#8288;$surrogate&#8288;</code> is <code>NULL</code>, <code>default_surrogate(instance)</code> is used and also assigned to <code style="white-space: pre;">&#8288;$surrogate&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerSurrogate$assign_result(instance)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instance</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> |<a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceAsyncMultiCrit">bbotk::OptimInstanceAsyncMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> the final result should be assigned to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultAssignerSurrogate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssignerSurrogate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Result Assigner: 
<code><a href="#topic+ResultAssigner">ResultAssigner</a></code>,
<code><a href="#topic+mlr_result_assigners">mlr_result_assigners</a></code>,
<code><a href="#topic+mlr_result_assigners_archive">mlr_result_assigners_archive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result_assigner = ras("surrogate")
</code></pre>

<hr>
<h2 id='mlr_tuners_adbo'>TunerAsync using Asynchronous Decentralized Bayesian Optimization</h2><span id='topic+mlr_tuners_adbo'></span><span id='topic+TunerADBO'></span>

<h3>Description</h3>

<p><code>TunerADBO</code> class that implements Asynchronous Decentralized Bayesian Optimization (ADBO).
ADBO is a variant of Asynchronous Model Based Optimization (AMBO) that uses <a href="#topic+AcqFunctionStochasticCB">AcqFunctionStochasticCB</a> with exponential lambda decay.
This is a minimal interface internally passing on to <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>.
For additional information and documentation see <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>.
</p>
<p>Currently, only single-objective optimization is supported and <code>TunerADBO</code> is considered an experimental feature and API might be subject to changes.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>initial_design</code></dt><dd><p><code>data.table::data.table()</code><br />
Initial design of the optimization.
If <code>NULL</code>, a design of size <code>design_size</code> is generated with the specified <code>design_function</code>.
Default is <code>NULL</code>.</p>
</dd>
<dt><code>design_size</code></dt><dd><p><code>integer(1)</code><br />
Size of the initial design if it is to be generated.
Default is <code>100</code>.</p>
</dd>
<dt><code>design_function</code></dt><dd><p><code>character(1)</code><br />
Sampling function to generate the initial design.
Can be <code>random</code> <a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a>, <code>lhs</code> <a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a>, or <code>sobol</code> <a href="paradox.html#topic+generate_design_sobol">paradox::generate_design_sobol</a>.
Default is <code>sobol</code>.</p>
</dd>
<dt><code>n_workers</code></dt><dd><p><code>integer(1)</code><br />
Number of parallel workers.
If <code>NULL</code>, all rush workers specified via <code><a href="rush.html#topic+rush_plan">rush::rush_plan()</a></code> are used.
Default is <code>NULL</code>.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerAsync">mlr3tuning::TunerAsync</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerAsyncFromOptimizerAsync">mlr3tuning::TunerAsyncFromOptimizerAsync</a></code> -&gt; <code>TunerADBO</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize.
Determined based on the <code>surrogate</code> and the <code>acq_optimizer</code>.
This corresponds to the values given by a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>'s
<code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="bbotk.html#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.
MBO in principle is very flexible and by default we assume that the optimizer has all properties.
When fully initialized, properties are determined based on the loop, e.g., the <code>loop_function</code>, and <code>surrogate</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to optimization if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.
Required packages are determined based on the <code>acq_function</code>, <code>surrogate</code> and the <code>acq_optimizer</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerADBO-new"><code>TunerADBO$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerADBO-print"><code>TunerADBO$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerADBO-reset"><code>TunerADBO$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerADBO-clone"><code>TunerADBO$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerAsyncFromOptimizerAsync" data-id="optimize"><a href='../../mlr3tuning/html/TunerAsyncFromOptimizerAsync.html#method-TunerAsyncFromOptimizerAsync-optimize'><code>mlr3tuning::TunerAsyncFromOptimizerAsync$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerADBO-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerADBO$new()</pre></div>


<hr>
<a id="method-TunerADBO-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerADBO$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-TunerADBO-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the tuner.
Sets the following fields to <code>NULL</code>:
<code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, <code>result_assigner</code>
Resets parameter values <code>design_size</code> and <code>design_function</code> to their defaults.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerADBO$reset()</pre></div>


<hr>
<a id="method-TunerADBO-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerADBO$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Egelé, Romain, Guyon, Isabelle, Vishwanath, Venkatram, Balaprakash, Prasanna (2023).
&ldquo;Asynchronous Decentralized Bayesian Optimization for Large Scale Hyperparameter Optimization.&rdquo;
In <em>2023 IEEE 19th International Conference on e-Science (e-Science)</em>, 1&ndash;10.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rush") &amp;
    requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  if (redis_available()) {

    library(mlr3)
    library(mlr3tuning)

    # single-objective
    task = tsk("wine")
    learner = lrn("classif.rpart", cp = to_tune(lower = 1e-4, upper = 1, logscale = TRUE))
    resampling = rsmp("cv", folds = 3)
    measure = msr("classif.acc")

    instance = TuningInstanceAsyncSingleCrit$new(
      task = task,
      learner = learner,
      resampling = resampling,
      measure = measure,
      terminator = trm("evals", n_evals = 10))

    rush::rush_plan(n_workers=2)

    tnr("adbo", design_size = 4, n_workers = 2)$optimize(instance)
  } else {
    message("Redis server is not available.\nPlease set up Redis prior to running the example.")
  }
}

</code></pre>

<hr>
<h2 id='mlr_tuners_async_mbo'>TunerAsync using Asynchronous Model Based Optimization</h2><span id='topic+mlr_tuners_async_mbo'></span><span id='topic+TunerAsyncMbo'></span>

<h3>Description</h3>

<p><code>TunerAsyncMbo</code> class that implements Asynchronous Model Based Optimization (AMBO).
This is a minimal interface internally passing on to <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>.
For additional information and documentation see <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>.
</p>
<p>Currently, only single-objective optimization is supported and <code>TunerAsyncMbo</code> is considered an experimental feature and API might be subject to changes.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>initial_design</code></dt><dd><p><code>data.table::data.table()</code><br />
Initial design of the optimization.
If <code>NULL</code>, a design of size <code>design_size</code> is generated with the specified <code>design_function</code>.
Default is <code>NULL</code>.</p>
</dd>
<dt><code>design_size</code></dt><dd><p><code>integer(1)</code><br />
Size of the initial design if it is to be generated.
Default is <code>100</code>.</p>
</dd>
<dt><code>design_function</code></dt><dd><p><code>character(1)</code><br />
Sampling function to generate the initial design.
Can be <code>random</code> <a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a>, <code>lhs</code> <a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a>, or <code>sobol</code> <a href="paradox.html#topic+generate_design_sobol">paradox::generate_design_sobol</a>.
Default is <code>sobol</code>.</p>
</dd>
<dt><code>n_workers</code></dt><dd><p><code>integer(1)</code><br />
Number of parallel workers.
If <code>NULL</code>, all rush workers specified via <code><a href="rush.html#topic+rush_plan">rush::rush_plan()</a></code> are used.
Default is <code>NULL</code>.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerAsync">mlr3tuning::TunerAsync</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerAsyncFromOptimizerAsync">mlr3tuning::TunerAsyncFromOptimizerAsync</a></code> -&gt; <code>TunerAsyncMbo</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize.
Determined based on the <code>surrogate</code> and the <code>acq_optimizer</code>.
This corresponds to the values given by a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>'s
<code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="bbotk.html#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.
MBO in principle is very flexible and by default we assume that the optimizer has all properties.
When fully initialized, properties are determined based on the loop, e.g., the <code>loop_function</code>, and <code>surrogate</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to optimization if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.
Required packages are determined based on the <code>acq_function</code>, <code>surrogate</code> and the <code>acq_optimizer</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerAsyncMbo-new"><code>TunerAsyncMbo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerAsyncMbo-print"><code>TunerAsyncMbo$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerAsyncMbo-reset"><code>TunerAsyncMbo$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerAsyncMbo-clone"><code>TunerAsyncMbo$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerAsyncFromOptimizerAsync" data-id="optimize"><a href='../../mlr3tuning/html/TunerAsyncFromOptimizerAsync.html#method-TunerAsyncFromOptimizerAsync-optimize'><code>mlr3tuning::TunerAsyncFromOptimizerAsync$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerAsyncMbo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
For more information on default values for <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, and <code>result_assigner</code>, see <code>?mbo_defaults</code>.
</p>
<p>Note that all the parameters below are simply passed to the <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a> and
the respective fields are simply (settable) active bindings to the fields of the <a href="#topic+OptimizerAsyncMbo">OptimizerAsyncMbo</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerAsyncMbo$new(
  surrogate = NULL,
  acq_function = NULL,
  acq_optimizer = NULL,
  param_set = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of control parameters.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TunerAsyncMbo-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerAsyncMbo$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-TunerAsyncMbo-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the tuner.
Sets the following fields to <code>NULL</code>:
<code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, <code>result_assigner</code>
Resets parameter values <code>design_size</code> and <code>design_function</code> to their defaults.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerAsyncMbo$reset()</pre></div>


<hr>
<a id="method-TunerAsyncMbo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerAsyncMbo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rush") &amp;
    requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  if (redis_available()) {

    library(mlr3)
    library(mlr3tuning)

    # single-objective
    task = tsk("wine")
    learner = lrn("classif.rpart", cp = to_tune(lower = 1e-4, upper = 1, logscale = TRUE))
    resampling = rsmp("cv", folds = 3)
    measure = msr("classif.acc")

    instance = TuningInstanceAsyncSingleCrit$new(
      task = task,
      learner = learner,
      resampling = resampling,
      measure = measure,
      terminator = trm("evals", n_evals = 10))

    rush::rush_plan(n_workers=2)

    tnr("async_mbo", design_size = 4, n_workers = 2)$optimize(instance)
  } else {
    message("Redis server is not available.\nPlease set up Redis prior to running the example.")
  }
}

</code></pre>

<hr>
<h2 id='mlr_tuners_mbo'>TunerBatch using Model Based Optimization</h2><span id='topic+mlr_tuners_mbo'></span><span id='topic+TunerMbo'></span>

<h3>Description</h3>

<p><code>TunerMbo</code> class that implements Model Based Optimization (MBO).
This is a minimal interface internally passing on to <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
For additional information and documentation see <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerBatch">mlr3tuning::TunerBatch</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerBatchFromOptimizerBatch">mlr3tuning::TunerBatchFromOptimizerBatch</a></code> -&gt; <code>TunerMbo</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loop_function</code></dt><dd><p>(<a href="#topic+loop_function">loop_function</a> | <code>NULL</code>)<br />
Loop function determining the MBO flavor.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>args</code></dt><dd><p>(named <code>list()</code>)<br />
Further arguments passed to the <code>loop_function</code>.
For example, <code>random_interleave_iter</code>.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character()</code>)<br />
Supported parameter classes that the optimizer can optimize.
Determined based on the <code>surrogate</code> and the <code>acq_optimizer</code>.
This corresponds to the values given by a <a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>'s
<code style="white-space: pre;">&#8288;$class&#8288;</code> field.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the optimizer.
Must be a subset of <code><a href="bbotk.html#topic+bbotk_reflections">bbotk_reflections$optimizer_properties</a></code>.
MBO in principle is very flexible and by default we assume that the optimizer has all properties.
When fully initialized, properties are determined based on the loop, e.g., the <code>loop_function</code>, and <code>surrogate</code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled prior to optimization if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.
Required packages are determined based on the <code>acq_function</code>, <code>surrogate</code> and the <code>acq_optimizer</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerMbo-new"><code>TunerMbo$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerMbo-print"><code>TunerMbo$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerMbo-reset"><code>TunerMbo$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerMbo-clone"><code>TunerMbo$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerBatchFromOptimizerBatch" data-id="optimize"><a href='../../mlr3tuning/html/TunerBatchFromOptimizerBatch.html#method-TunerBatchFromOptimizerBatch-optimize'><code>mlr3tuning::TunerBatchFromOptimizerBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerMbo-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
For more information on default values for <code>loop_function</code>, <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, and <code>result_assigner</code>, see <code>?mbo_defaults</code>.
</p>
<p>Note that all the parameters below are simply passed to the <a href="#topic+OptimizerMbo">OptimizerMbo</a> and
the respective fields are simply (settable) active bindings to the fields of the <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMbo$new(
  loop_function = NULL,
  surrogate = NULL,
  acq_function = NULL,
  acq_optimizer = NULL,
  args = NULL,
  result_assigner = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>loop_function</code></dt><dd><p>(<a href="#topic+loop_function">loop_function</a> | <code>NULL</code>)<br />
Loop function determining the MBO flavor.</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>(<a href="#topic+Surrogate">Surrogate</a> | <code>NULL</code>)<br />
The surrogate.</p>
</dd>
<dt><code>acq_function</code></dt><dd><p>(<a href="#topic+AcqFunction">AcqFunction</a> | <code>NULL</code>)<br />
The acquisition function.</p>
</dd>
<dt><code>acq_optimizer</code></dt><dd><p>(<a href="#topic+AcqOptimizer">AcqOptimizer</a> | <code>NULL</code>)<br />
The acquisition function optimizer.</p>
</dd>
<dt><code>args</code></dt><dd><p>(named <code>list()</code>)<br />
Further arguments passed to the <code>loop_function</code>.
For example, <code>random_interleave_iter</code>.</p>
</dd>
<dt><code>result_assigner</code></dt><dd><p>(<a href="#topic+ResultAssigner">ResultAssigner</a> | <code>NULL</code>)<br />
The result assigner.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TunerMbo-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMbo$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-TunerMbo-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the tuner.
Sets the following fields to <code>NULL</code>:
<code>loop_function</code>, <code>surrogate</code>, <code>acq_function</code>, <code>acq_optimizer</code>, <code>args</code>, <code>result_assigner</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMbo$reset()</pre></div>


<hr>
<a id="method-TunerMbo-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMbo$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {

  library(mlr3)
  library(mlr3tuning)

  # single-objective
  task = tsk("wine")
  learner = lrn("classif.rpart", cp = to_tune(lower = 1e-4, upper = 1, logscale = TRUE))
  resampling = rsmp("cv", folds = 3)
  measure = msr("classif.acc")

  instance = TuningInstanceBatchSingleCrit$new(
    task = task,
    learner = learner,
    resampling = resampling,
    measure = measure,
    terminator = trm("evals", n_evals = 5))

  tnr("mbo")$optimize(instance)

  # multi-objective
  task = tsk("wine")
  learner = lrn("classif.rpart", cp = to_tune(lower = 1e-4, upper = 1, logscale = TRUE))
  resampling = rsmp("cv", folds = 3)
  measures = msrs(c("classif.acc", "selected_features"))

  instance = TuningInstanceBatchMultiCrit$new(
    task = task,
    learner = learner,
    resampling = resampling,
    measures = measures,
    terminator = trm("evals", n_evals = 5),
    store_models = TRUE) # required due to selected features

  tnr("mbo")$optimize(instance)
}

</code></pre>

<hr>
<h2 id='ras'>Syntactic Sugar Result Assigner Construction</h2><span id='topic+ras'></span>

<h3>Description</h3>

<p>This function complements <a href="#topic+mlr_result_assigners">mlr_result_assigners</a> with functions in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras(.key, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ras_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve
the object.</p>
</td></tr>
<tr><td><code id="ras_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>, or to be set as public field. See
<code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ResultAssigner">ResultAssigner</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ras("archive")
</code></pre>

<hr>
<h2 id='redis_available'>Check if Redis Server is Available</h2><span id='topic+redis_available'></span>

<h3>Description</h3>

<p>Attempts to establish a connection to a Redis server using the <a href="https://CRAN.R-project.org/package=redux"><span class="pkg">redux</span></a> package
and sends a <code>PING</code> command. Returns <code>TRUE</code> if the server is available and
responds appropriately, <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redis_available()
</code></pre>


<h3>Value</h3>

<p>(<code>logical(1)</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (redis_available()) {
  # Proceed with code that requires Redis
  message("Redis server is available.")
} else {
  message("Redis server is not available.")
}
</code></pre>

<hr>
<h2 id='ResultAssigner'>Result Assigner Base Class</h2><span id='topic+ResultAssigner'></span>

<h3>Description</h3>

<p>Abstract result assigner class.
</p>
<p>A result assigner is responsible for assigning the final optimization result to the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.
Normally, it is only used within an <a href="#topic+OptimizerMbo">OptimizerMbo</a>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResultAssigner-new"><code>ResultAssigner$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssigner-assign_result"><code>ResultAssigner$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssigner-format"><code>ResultAssigner$format()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssigner-print"><code>ResultAssigner$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultAssigner-clone"><code>ResultAssigner$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ResultAssigner-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssigner$new(label = NA_character_, man = NA_character_)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultAssigner-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>Assigns the result, i.e., the final point(s) to the instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssigner$assign_result(instance)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instance</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a> |<a href="bbotk.html#topic+OptimInstanceAsyncSingleCrit">bbotk::OptimInstanceAsyncSingleCrit</a> | <a href="bbotk.html#topic+OptimInstanceAsyncMultiCrit">bbotk::OptimInstanceAsyncMultiCrit</a>)<br />
The <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> the final result should be assigned to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultAssigner-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssigner$format()</pre></div>



<h5>Returns</h5>

<p>(<code>character(1)</code>).
</p>


<hr>
<a id="method-ResultAssigner-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssigner$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-ResultAssigner-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultAssigner$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Result Assigner: 
<code><a href="#topic+mlr_result_assigners">mlr_result_assigners</a></code>,
<code><a href="#topic+mlr_result_assigners_archive">mlr_result_assigners_archive</a></code>,
<code><a href="#topic+mlr_result_assigners_surrogate">mlr_result_assigners_surrogate</a></code>
</p>

<hr>
<h2 id='srlrn'>Syntactic Sugar Surrogate Construction</h2><span id='topic+srlrn'></span>

<h3>Description</h3>

<p>This function allows to construct a <a href="#topic+SurrogateLearner">SurrogateLearner</a> or <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a> in the spirit
of <code>mlr_sugar</code> from <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>
<p>If the <code>archive</code> references more than one target variable or <code>cols_y</code> contains more than one
target variable but only a single <code>learner</code> is specified, this learner is replicated as many
times as needed to build the <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srlrn(learner, archive = NULL, cols_x = NULL, cols_y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srlrn_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> | List of <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>)<br />
<a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> that is to be used within the <a href="#topic+SurrogateLearner">SurrogateLearner</a> or a list of <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> that are to
be used within the <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>.</p>
</td></tr>
<tr><td><code id="srlrn_+3A_archive">archive</code></td>
<td>
<p>(<code>NULL</code> | <a href="bbotk.html#topic+Archive">bbotk::Archive</a>)<br />
<a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a> used.
Can also be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="srlrn_+3A_cols_x">cols_x</code></td>
<td>
<p>(<code>NULL</code> | <code>character()</code>)<br />
Column ids in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> that should be used as features.
Can also be <code>NULL</code> in which case this is automatically inferred based on the archive.</p>
</td></tr>
<tr><td><code id="srlrn_+3A_cols_y">cols_y</code></td>
<td>
<p>(<code>NULL</code> | <code>character()</code>)<br />
Column id(s) in the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> that should be used as a target.
If a list of <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> is provided as the <code>learner</code> argument and <code>cols_y</code> is
specified as well, as many column names as learners must be provided.
Can also be <code>NULL</code> in which case this is automatically inferred based on the archive.</p>
</td></tr>
<tr><td><code id="srlrn_+3A_...">...</code></td>
<td>
<p>(named <code>list()</code>)<br />
Named arguments passed to the constructor, to be set as parameters in the
<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+SurrogateLearner">SurrogateLearner</a> | <a href="#topic+SurrogateLearnerCollection">SurrogateLearnerCollection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
srlrn(lrn("regr.featureless"), catch_errors = FALSE)
srlrn(list(lrn("regr.featureless"), lrn("regr.featureless")))
</code></pre>

<hr>
<h2 id='Surrogate'>Surrogate Model</h2><span id='topic+Surrogate'></span>

<h3>Description</h3>

<p>Abstract surrogate model class.
</p>
<p>A surrogate model is used to model the unknown objective function(s) based on all points evaluated so far.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>learner</code></dt><dd><p>(learner)<br />
Arbitrary learner object depending on the subclass.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>print_id</code></dt><dd><p>(<code>character</code>)<br />
Id used when printing.</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="bbotk.html#topic+Archive">bbotk::Archive</a> | <code>NULL</code>)<br />
<a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</dd>
<dt><code>archive_is_async</code></dt><dd><p>('bool(1)&ldquo;)<br />
Whether the <a href="bbotk.html#topic+Archive">bbotk::Archive</a> is an asynchronous one.</p>
</dd>
<dt><code>n_learner</code></dt><dd><p>(<code>integer(1)</code>)<br />
Returns the number of surrogate models.</p>
</dd>
<dt><code>cols_x</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as features.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>cols_y</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as targets.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>insample_perf</code></dt><dd><p>(<code>numeric()</code>)<br />
Surrogate model's current insample performance.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Set of hyperparameters.</p>
</dd>
<dt><code>assert_insample_perf</code></dt><dd><p>(<code>numeric()</code>)<br />
Asserts whether the current insample performance meets the performance threshold.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
<dt><code>feature_types</code></dt><dd><p>(<code>character()</code>)<br />
Stores the feature types the surrogate can handle, e.g. <code>"logical"</code>, <code>"numeric"</code>, or <code>"factor"</code>.
A complete list of candidate feature types, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$task_feature_types</a></code>.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Stores a set of properties/capabilities the surrogate has.
A complete list of candidate properties, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$learner_properties</a></code>.</p>
</dd>
<dt><code>predict_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Retrieves the currently active predict type, e.g. <code>"response"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Surrogate-new"><code>Surrogate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-update"><code>Surrogate$update()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-reset"><code>Surrogate$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-predict"><code>Surrogate$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-format"><code>Surrogate$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-print"><code>Surrogate$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Surrogate-clone"><code>Surrogate$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Surrogate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$new(learner, archive, cols_x, cols_y, param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner</code></dt><dd><p>(learner)<br />
Arbitrary learner object depending on the subclass.</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="bbotk.html#topic+Archive">bbotk::Archive</a> | <code>NULL</code>)<br />
<a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</dd>
<dt><code>cols_x</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as features.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>cols_y</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as targets.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Parameter space description depending on the subclass.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Surrogate-update"></a>



<h4>Method <code>update()</code></h4>

<p>Train learner with new data.
Subclasses must implement <code>private.update()</code> and <code>private.update_async()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$update()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code>.
</p>


<hr>
<a id="method-Surrogate-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the surrogate model.
Subclasses must implement <code>private$.reset()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$reset()</pre></div>



<h5>Returns</h5>

<p><code>NULL</code>
</p>


<hr>
<a id="method-Surrogate-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict mean response and standard error.
Must be implemented by subclasses.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$predict(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
New data. One row per observation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Arbitrary prediction object.
</p>


<hr>
<a id="method-Surrogate-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$format()</pre></div>



<h5>Returns</h5>

<p>(<code>character(1)</code>).
</p>


<hr>
<a id="method-Surrogate-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-Surrogate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Surrogate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='SurrogateLearner'>Surrogate Model Containing a Single Learner</h2><span id='topic+SurrogateLearner'></span>

<h3>Description</h3>

<p>Surrogate model containing a single <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>assert_insample_perf</code></dt><dd><p><code>logical(1)</code><br />
Should the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> be asserted after updating the surrogate?
If the assertion fails (i.e., the insample performance based on the <code>perf_measure</code> does not meet the
<code>perf_threshold</code>), an error is thrown.
Default is <code>FALSE</code>.
</p>
</dd>
<dt><code>perf_measure</code></dt><dd><p><a href="mlr3.html#topic+MeasureRegr">mlr3::MeasureRegr</a><br />
Performance measure which should be use to assert the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is <a href="mlr3.html#topic+mlr_measures_regr.rsq">mlr3::mlr_measures_regr.rsq</a>.
</p>
</dd>
<dt><code>perf_threshold</code></dt><dd><p><code>numeric(1)</code><br />
Threshold the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> should be asserted against.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is <code>0</code>.
</p>
</dd>
<dt><code>catch_errors</code></dt><dd><p><code>logical(1)</code><br />
Should errors during updating the surrogate be caught and propagated to the <code>loop_function</code> which can then handle
the failed acquisition function optimization (as a result of the failed surrogate) appropriately by, e.g., proposing a randomly sampled point for evaluation?
Default is <code>TRUE</code>.
</p>
</dd>
<dt><code>impute_method</code></dt><dd><p><code>character(1)</code><br />
Method to impute missing values in the case of updating on an asynchronous <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a> with pending evaluations.
Can be <code>"mean"</code> to use mean imputation or <code>"random"</code> to sample values uniformly at random between the empirical minimum and maximum.
Default is <code>"random"</code>.
</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Surrogate">mlr3mbo::Surrogate</a></code> -&gt; <code>SurrogateLearner</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>print_id</code></dt><dd><p>(<code>character</code>)<br />
Id used when printing.</p>
</dd>
<dt><code>n_learner</code></dt><dd><p>(<code>integer(1)</code>)<br />
Returns the number of surrogate models.</p>
</dd>
<dt><code>assert_insample_perf</code></dt><dd><p>(<code>numeric()</code>)<br />
Asserts whether the current insample performance meets the performance threshold.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
<dt><code>feature_types</code></dt><dd><p>(<code>character()</code>)<br />
Stores the feature types the surrogate can handle, e.g. <code>"logical"</code>, <code>"numeric"</code>, or <code>"factor"</code>.
A complete list of candidate feature types, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$task_feature_types</a></code>.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Stores a set of properties/capabilities the surrogate has.
A complete list of candidate properties, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$learner_properties</a></code>.</p>
</dd>
<dt><code>predict_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Retrieves the currently active predict type, e.g. <code>"response"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SurrogateLearner-new"><code>SurrogateLearner$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearner-predict"><code>SurrogateLearner$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearner-clone"><code>SurrogateLearner$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="format"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-format'><code>mlr3mbo::Surrogate$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="print"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-print'><code>mlr3mbo::Surrogate$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="reset"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-reset'><code>mlr3mbo::Surrogate$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="update"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-update'><code>mlr3mbo::Surrogate$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SurrogateLearner-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearner$new(learner, archive = NULL, cols_x = NULL, col_y = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>).</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="bbotk.html#topic+Archive">bbotk::Archive</a> | <code>NULL</code>)<br />
<a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</dd>
<dt><code>cols_x</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as features.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>col_y</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Column id of variable that should be used as a target.
By default, automatically inferred based on the archive.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SurrogateLearner-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict mean response and standard error.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearner$predict(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
New data. One row per observation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with the columns <code>mean</code> and <code>se</code>.
</p>


<hr>
<a id="method-SurrogateLearner-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearner$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y = xs$x ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchSingleCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))

  xdt = generate_design_random(instance$search_space, n = 4)$data

  instance$eval_batch(xdt)

  learner = default_gp()

  surrogate = srlrn(learner, archive = instance$archive)

  surrogate$update()

  surrogate$learner$model
}
</code></pre>

<hr>
<h2 id='SurrogateLearnerCollection'>Surrogate Model Containing Multiple Learners</h2><span id='topic+SurrogateLearnerCollection'></span>

<h3>Description</h3>

<p>Surrogate model containing multiple <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>.
The <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> are fit on the target variables as indicated via <code>cols_y</code>.
Note that redundant <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> must be deep clones.
</p>


<h3>Parameters</h3>


<dl>
<dt><code>assert_insample_perf</code></dt><dd><p><code>logical(1)</code><br />
Should the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> be asserted after updating the surrogate?
If the assertion fails (i.e., the insample performance based on the <code>perf_measure</code> does not meet the
<code>perf_threshold</code>), an error is thrown.
Default is <code>FALSE</code>.
</p>
</dd>
<dt><code>perf_measure</code></dt><dd><p>List of <a href="mlr3.html#topic+MeasureRegr">mlr3::MeasureRegr</a><br />
Performance measures which should be use to assert the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is <a href="mlr3.html#topic+mlr_measures_regr.rsq">mlr3::mlr_measures_regr.rsq</a> for each learner.
</p>
</dd>
<dt><code>perf_threshold</code></dt><dd><p>List of <code>numeric(1)</code><br />
Thresholds the insample performance of the <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a> should be asserted against.
Only relevant if <code>assert_insample_perf = TRUE</code>.
Default is <code>0</code> for each learner.
</p>
</dd>
<dt><code>catch_errors</code></dt><dd><p><code>logical(1)</code><br />
Should errors during updating the surrogate be caught and propagated to the <code>loop_function</code> which can then handle
the failed acquisition function optimization (as a result of the failed surrogate) appropriately by, e.g., proposing a randomly sampled point for evaluation?
Default is <code>TRUE</code>.
</p>
</dd>
<dt><code>impute_method</code></dt><dd><p><code>character(1)</code><br />
Method to impute missing values in the case of updating on an asynchronous <a href="bbotk.html#topic+ArchiveAsync">bbotk::ArchiveAsync</a> with pending evaluations.
Can be <code>"mean"</code> to use mean imputation or <code>"random"</code> to sample values uniformly at random between the empirical minimum and maximum.
Default is <code>"random"</code>.
</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Surrogate">mlr3mbo::Surrogate</a></code> -&gt; <code>SurrogateLearnerCollection</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>print_id</code></dt><dd><p>(<code>character</code>)<br />
Id used when printing.</p>
</dd>
<dt><code>n_learner</code></dt><dd><p>(<code>integer(1)</code>)<br />
Returns the number of surrogate models.</p>
</dd>
<dt><code>assert_insample_perf</code></dt><dd><p>(<code>numeric()</code>)<br />
Asserts whether the current insample performance meets the performance threshold.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
A warning is signaled if at least one of the packages is not installed, but loaded (not attached) later on-demand via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>.</p>
</dd>
<dt><code>feature_types</code></dt><dd><p>(<code>character()</code>)<br />
Stores the feature types the surrogate can handle, e.g. <code>"logical"</code>, <code>"numeric"</code>, or <code>"factor"</code>.
A complete list of candidate feature types, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$task_feature_types</a></code>.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Stores a set of properties/capabilities the surrogate has.
A complete list of candidate properties, grouped by task type, is stored in <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$learner_properties</a></code>.</p>
</dd>
<dt><code>predict_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Retrieves the currently active predict type, e.g. <code>"response"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SurrogateLearnerCollection-new"><code>SurrogateLearnerCollection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearnerCollection-predict"><code>SurrogateLearnerCollection$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SurrogateLearnerCollection-clone"><code>SurrogateLearnerCollection$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="format"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-format'><code>mlr3mbo::Surrogate$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="print"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-print'><code>mlr3mbo::Surrogate$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="reset"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-reset'><code>mlr3mbo::Surrogate$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3mbo" data-topic="Surrogate" data-id="update"><a href='../../mlr3mbo/html/Surrogate.html#method-Surrogate-update'><code>mlr3mbo::Surrogate$update()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SurrogateLearnerCollection-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$new(
  learners,
  archive = NULL,
  cols_x = NULL,
  cols_y = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learners</code></dt><dd><p>(list of <a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a>).</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="bbotk.html#topic+Archive">bbotk::Archive</a> | <code>NULL</code>)<br />
<a href="bbotk.html#topic+Archive">bbotk::Archive</a> of the <a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a>.</p>
</dd>
<dt><code>cols_x</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as features.
By default, automatically inferred based on the archive.</p>
</dd>
<dt><code>cols_y</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Column id's of variables that should be used as targets.
By default, automatically inferred based on the archive.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SurrogateLearnerCollection-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict mean response and standard error.
Returns a named list of data.tables.
Each contains the mean response and standard error for one <code>col_y</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$predict(xdt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
New data. One row per observation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list of <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>s with the columns <code>mean</code> and <code>se</code>.
</p>


<hr>
<a id="method-SurrogateLearnerCollection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SurrogateLearnerCollection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlr3learners") &amp;
    requireNamespace("DiceKriging") &amp;
    requireNamespace("rgenoud") &amp;
    requireNamespace("ranger")) {
  library(bbotk)
  library(paradox)
  library(mlr3learners)

  fun = function(xs) {
    list(y1 = xs$x^2, y2 = (xs$x - 2) ^ 2)
  }
  domain = ps(x = p_dbl(lower = -10, upper = 10))
  codomain = ps(y1 = p_dbl(tags = "minimize"), y2 = p_dbl(tags = "minimize"))
  objective = ObjectiveRFun$new(fun = fun, domain = domain, codomain = codomain)

  instance = OptimInstanceBatchMultiCrit$new(
    objective = objective,
    terminator = trm("evals", n_evals = 5))
  xdt = generate_design_random(instance$search_space, n = 4)$data

  instance$eval_batch(xdt)

  learner1 = default_gp()

  learner2 = default_rf()

  surrogate = srlrn(list(learner1, learner2), archive = instance$archive)

  surrogate$update()

  surrogate$learner

  surrogate$learner[["y1"]]$model

  surrogate$learner[["y2"]]$model
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
