<!DOCTYPE html><html><head><title>Help for package zonebuilder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zonebuilder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#london_area'><p>Region representing London in projected coordinate system</p></a></li>
<li><a href='#zb_100_triangular_numbers'><p>The first 100 triangular numbers</p></a></li>
<li><a href='#zb_color'><p>Generate colors for zones</p></a></li>
<li><a href='#zb_doughnut'><p>Make doughnuts</p></a></li>
<li><a href='#zb_lines'><p>Create lines radiating at equal angles from a point</p></a></li>
<li><a href='#zb_plot'><p>Plot zones</p></a></li>
<li><a href='#zb_quadrat'><p>Divide a region into quadrats</p></a></li>
<li><a href='#zb_segment'><p>Make segments</p></a></li>
<li><a href='#zb_view'><p>View zones</p></a></li>
<li><a href='#zb_zone'><p>Generate zones covering a region of interest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create and Explore Geographic Zoning Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions, documentation and example data to help divide
    geographic space into discrete polygons (zones).
    The functions are motivated by research into the merits of different zoning systems
    &lt;<a href="https://doi.org/10.1068%2Fa090169">doi:10.1068/a090169</a>&gt;. A flexible 'ClockBoard' zoning system is
    provided, which breaks-up space by concentric rings
    and radial lines emanating from a central point.
    By default, the diameter of the rings grow according the triangular number sequence
    &lt;<a href="https://doi.org/10.1080%2F26375451.2019.1598687">doi:10.1080/26375451.2019.1598687</a>&gt; with the first 4 'doughnuts'
    (or 'annuli') measuring 1, 3, 6, and 10 km wide.
    These annuli are subdivided into equal segments (12 by default), creating the
    visual impression of a dartboard. Zones are labelled according to
    distance to the centre and angular distance from North, creating a simple
    geographic zoning and labelling system useful for visualising geographic
    phenomena with a clearly demarcated central location such as cities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zonebuilders/zonebuilder/issues">https://github.com/zonebuilders/zonebuilder/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, RColorBrewer, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tmap, tmaptools, pct, dplyr, lwgeom,
leaflet, covr, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zonebuilders/zonebuilder">https://github.com/zonebuilders/zonebuilder</a>,
<a href="https://zonebuilders.github.io/zonebuilder/">https://zonebuilders.github.io/zonebuilder/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-12 08:21:17 UTC; robin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Martijn Tennekes [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Lovelace &lt;rob00x@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-12 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='london_area'>Region representing London in projected coordinate system</h2><span id='topic+london_area'></span><span id='topic+london_a'></span><span id='topic+london_cent'></span><span id='topic+london_c'></span><span id='topic+london_cent_lonlat'></span><span id='topic+london_area_lonlat'></span>

<h3>Description</h3>

<p>'london_a()' and 'london_c()' return the city boundaries and centre
point of London, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>london_a()

london_c()
</code></pre>


<h3>Note</h3>

<p>'london_a()'  returns a projected version of 'lnd' in 'spDataLarge'.
See the &lsquo;data-raw' folder in the package&rsquo;s repo to reproduce these datasets
The 'lonlat' versions of the data have coordinates in units of degrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(london_a(), reset = FALSE)
plot(london_c(), add = TRUE)
</code></pre>

<hr>
<h2 id='zb_100_triangular_numbers'>The first 100 triangular numbers</h2><span id='topic+zb_100_triangular_numbers'></span>

<h3>Description</h3>

<p>The first 100 in the sequence of [triangular numbers](https://en.wikipedia.org/wiki/Triangular_number)
</p>


<h3>Note</h3>

<p>See the &lsquo;data-raw' folder in the package&rsquo;s repo to reproduce these datasets
</p>

<hr>
<h2 id='zb_color'>Generate colors for zones</h2><span id='topic+zb_color'></span>

<h3>Description</h3>

<p>This function generates colors for zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_color(z, palette = c("rings", "hcl", "dartboard"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_color_+3A_z">z</code></td>
<td>
<p>An 'sf' object containing zones covering the region</p>
</td></tr>
<tr><td><code id="zb_color_+3A_palette">palette</code></td>
<td>
<p>Palette type, one of <code>"hcl"</code> (a palette based on the HCL color space), <code>"rings"</code> (a palette which colors the rings using the YlOrBr color brewer palette), <code>"dartboard"</code> (a palette which resembles a dartboard)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z = zb_zone(london_c(), london_a())
zb_color(z)
plot(z[, "circle_id"], col = zb_color(z))
</code></pre>

<hr>
<h2 id='zb_doughnut'>Make doughnuts</h2><span id='topic+zb_doughnut'></span>

<h3>Description</h3>

<p>Make doughnuts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_doughnut(
  x = NULL,
  area = NULL,
  n_circles = NA,
  distance = 1,
  distance_growth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_doughnut_+3A_x">x</code></td>
<td>
<p>Centre point. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one point, or a name of a city (which is looked up with OSM geocoding).</p>
</td></tr>
<tr><td><code id="zb_doughnut_+3A_area">area</code></td>
<td>
<p>(optional) Area. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one (multi) polygon</p>
</td></tr>
<tr><td><code id="zb_doughnut_+3A_n_circles">n_circles</code></td>
<td>
<p>Number of rings including the central circle. By default 5, unless <code>area</code> is specified (then it is set automatically to fill the area).</p>
</td></tr>
<tr><td><code id="zb_doughnut_+3A_distance">distance</code></td>
<td>
<p>Distance The distances between the circles. For the center circle, it is the distance between the center and the circle. If only one number is specified, <code>distance_growth</code> determines the increment at which the distances grow for the outer circles.</p>
</td></tr>
<tr><td><code id="zb_doughnut_+3A_distance_growth">distance_growth</code></td>
<td>
<p>The rate at which the distances between the circles grow. Only applicable when <code>distance</code> is one number and <code>n_circles &gt; 1</code>. See also <code>distance</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'sf' data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zb_plot(zb_doughnut(london_c(), london_a()))
</code></pre>

<hr>
<h2 id='zb_lines'>Create lines radiating at equal angles from a point</h2><span id='topic+zb_lines'></span>

<h3>Description</h3>

<p>Create lines radiating at equal angles from a point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_lines(point, n, starting_angle = 45, distance = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_lines_+3A_point">point</code></td>
<td>
<p>Center point</p>
</td></tr>
<tr><td><code id="zb_lines_+3A_n">n</code></td>
<td>
<p>Number of lines</p>
</td></tr>
<tr><td><code id="zb_lines_+3A_starting_angle">starting_angle</code></td>
<td>
<p>Starting angle</p>
</td></tr>
<tr><td><code id="zb_lines_+3A_distance">distance</code></td>
<td>
<p>Distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects of class 'sfc' containing linestring geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>point = sf::st_centroid(london_a())
n = 4
l = zb_lines(point, n)
plot(l)
</code></pre>

<hr>
<h2 id='zb_plot'>Plot zones</h2><span id='topic+zb_plot'></span>

<h3>Description</h3>

<p>This function opens a static map of the zones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_plot(
  z,
  palette = c("rings", "hcl", "dartboard"),
  title = NULL,
  text_size = c(0.3, 1),
  zone_label_thres = 0.002
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_plot_+3A_z">z</code></td>
<td>
<p>An 'sf' object containing zones covering the region</p>
</td></tr>
<tr><td><code id="zb_plot_+3A_palette">palette</code></td>
<td>
<p>Palette type, one of <code>"hcl"</code> (a palette based on the HCL color space), <code>"rings"</code> (a palette which colors the rings using the YlOrBr color brewer palette), <code>"dartboard"</code> (a palette which resembles a dartboard)</p>
</td></tr>
<tr><td><code id="zb_plot_+3A_title">title</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="zb_plot_+3A_text_size">text_size</code></td>
<td>
<p>Vector of two numeric values that determine the relative text sizes. The first determines the smallest text size and the second one the largest text size. The largest text size is used for the outermost circle, and the smallest for the central circle in case there are 9 or more circles. If there are less circles, the relative text size is larger (see source code for exact method)</p>
</td></tr>
<tr><td><code id="zb_plot_+3A_zone_label_thres">zone_label_thres</code></td>
<td>
<p>This number determines in which zones labels are printed, namely each zone for which the relative area size is larger than 'zone_label_thres'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A static plot created using R's base 'graphics' package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zb_plot(zb_zone(london_c()))
</code></pre>

<hr>
<h2 id='zb_quadrat'>Divide a region into quadrats</h2><span id='topic+zb_quadrat'></span>

<h3>Description</h3>

<p>Divide a region into quadrats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_quadrat(x, ncol, nrow = NULL, intersection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_quadrat_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="zb_quadrat_+3A_ncol">ncol</code></td>
<td>
<p>ncol</p>
</td></tr>
<tr><td><code id="zb_quadrat_+3A_nrow">nrow</code></td>
<td>
<p>nrow</p>
</td></tr>
<tr><td><code id="zb_quadrat_+3A_intersection">intersection</code></td>
<td>
<p>intersection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = london_a()
c = sf::st_centroid(london_a())
plot(zb_quadrat(x, ncol = 2), col = 2:5)
plot(c, add = TRUE, col = "white")
plot(zb_quadrat(x, ncol = 3))
plot(zb_quadrat(x, ncol = 4))
plot(zb_quadrat(x, ncol = 4, intersection = FALSE))
</code></pre>

<hr>
<h2 id='zb_segment'>Make segments</h2><span id='topic+zb_segment'></span>

<h3>Description</h3>

<p>Make segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_segment(x = NULL, area = NULL, n_segments = 12, distance = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_segment_+3A_x">x</code></td>
<td>
<p>Centre point. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one point, or a name of a city (which is looked up with OSM geocoding).</p>
</td></tr>
<tr><td><code id="zb_segment_+3A_area">area</code></td>
<td>
<p>(optional) Area. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one (multi) polygon</p>
</td></tr>
<tr><td><code id="zb_segment_+3A_n_segments">n_segments</code></td>
<td>
<p>(optional) Number of segments. The number of segments. Either one number which determines the number of segments applied to all circles, or a vector with a number for each circle (which should be a multiple of 4, see also the argument <code>labeling</code>). By default, the central circle is not segmented (see the argument <code>segment_center</code>).</p>
</td></tr>
<tr><td><code id="zb_segment_+3A_distance">distance</code></td>
<td>
<p>Distance The distances between the circles. For the center circle, it is the distance between the center and the circle. If only one number is specified, <code>distance_growth</code> determines the increment at which the distances grow for the outer circles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'sf' data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zb_plot(zb_segment(london_c(), london_a()))
</code></pre>

<hr>
<h2 id='zb_view'>View zones</h2><span id='topic+zb_view'></span>

<h3>Description</h3>

<p>This function opens an interactive map of the zones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_view(z, alpha = 0.4, palette = c("rings", "hcl", "dartboard"), title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_view_+3A_z">z</code></td>
<td>
<p>An 'sf' object containing zones covering the region</p>
</td></tr>
<tr><td><code id="zb_view_+3A_alpha">alpha</code></td>
<td>
<p>Alpha transparency, number between 0 (fully transparent) and 1 (not transparent)</p>
</td></tr>
<tr><td><code id="zb_view_+3A_palette">palette</code></td>
<td>
<p>Palette type, one of <code>"hcl"</code> (a palette based on the HCL color space), <code>"rings"</code> (a palette which colors the rings using the YlOrBr color brewer palette), <code>"dartboard"</code> (a palette which resembles a dartboard)</p>
</td></tr>
<tr><td><code id="zb_view_+3A_title">title</code></td>
<td>
<p>The title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interactive map created with 'tmap'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z = zb_zone(london_c(), london_a())
zb_view(z, palette = "rings")

</code></pre>

<hr>
<h2 id='zb_zone'>Generate zones covering a region of interest</h2><span id='topic+zb_zone'></span>

<h3>Description</h3>

<p>This function first divides geographic space into [annuli](https://en.wikipedia.org/wiki/Annulus_(mathematics)) 
(concentric 2d rings or 'doughnuts') and then subdivides each annulus
into a number of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zb_zone(
  x = NULL,
  area = NULL,
  n_circles = NA,
  n_segments = 12,
  distance = 1,
  distance_growth = 1,
  labeling = NA,
  starting_angle = NA,
  segment_center = FALSE,
  intersection = TRUE,
  city = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zb_zone_+3A_x">x</code></td>
<td>
<p>Centre point. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one point, or a name of a city (which is looked up with OSM geocoding).</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_area">area</code></td>
<td>
<p>(optional) Area. Should be an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code> object containing one (multi) polygon</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_n_circles">n_circles</code></td>
<td>
<p>Number of rings including the central circle. By default 5, unless <code>area</code> is specified (then it is set automatically to fill the area).</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_n_segments">n_segments</code></td>
<td>
<p>(optional) Number of segments. The number of segments. Either one number which determines the number of segments applied to all circles, or a vector with a number for each circle (which should be a multiple of 4, see also the argument <code>labeling</code>). By default, the central circle is not segmented (see the argument <code>segment_center</code>).</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_distance">distance</code></td>
<td>
<p>Distance The distances between the circles. For the center circle, it is the distance between the center and the circle. If only one number is specified, <code>distance_growth</code> determines the increment at which the distances grow for the outer circles.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_distance_growth">distance_growth</code></td>
<td>
<p>The rate at which the distances between the circles grow. Only applicable when <code>distance</code> is one number and <code>n_circles &gt; 1</code>. See also <code>distance</code>.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_labeling">labeling</code></td>
<td>
<p>The labeling of the zones. Either <code>"clock"</code> which uses the clock ananolgy (i.e. hours 1 to 12) or <code>"NESW"</code> which uses the cardinal directions N, E, S, W. If the number of segments is 12, the clock labeling is used, and otherwise NESW. Note that the number of segments should be a multiple of four. If, for instance the number of segments is 8, than the segments are labeled N1, N2, E1, E2, S1, S2, W1, and W2.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_starting_angle">starting_angle</code></td>
<td>
<p>The angle of the first of the radii that create the segments (degrees). By default, it is either 15 when <code>n_segments</code> is 12 (i.e. the ClockBoard setting) and -45 otherwise.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_segment_center">segment_center</code></td>
<td>
<p>Should the central circle be divided into segments? 'FALSE' by default.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_intersection">intersection</code></td>
<td>
<p>Should the zones be intersected with the area? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="zb_zone_+3A_city">city</code></td>
<td>
<p>(optional) Name of the city. If specified, it adds a column 'city' to the returned 'sf' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default 12 segments are used for each annuli, resulting in a zoning system that can 
be used to refer to segments in [clock position](https://en.wikipedia.org/wiki/Clock_position),
with 12 representing North, 3 representing East, 6 Sounth and 9 Western segments.
</p>


<h3>Value</h3>

<p>An 'sf' object containing zones covering the region
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default settings
z = zb_zone(london_c(), london_a())

zb_plot(z)
if (require(tmap)) {
  zb_view(z)
  
  z = zb_zone("Berlin")
  zb_view(z)
}

# variations
zb_plot(zb_zone(london_c(), london_a(), n_circles = 2))
zb_plot(zb_zone(london_c(), london_a(), n_circles = 4, distance = 2, distance_growth = 0))
zb_plot(zb_zone(london_c(), london_a(), n_circles = 3, n_segments = c(1,4,8)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
