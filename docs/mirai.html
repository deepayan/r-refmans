<!DOCTYPE html><html><head><title>Help for package mirai</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mirai}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mirai-package'><p>mirai: Minimalist Async Evaluation Framework for R</p></a></li>
<li><a href='#.daemon'><p>dot Daemon</p></a></li>
<li><a href='#.progress'><p>mirai Map Options</p></a></li>
<li><a href='#as.promise.mirai'><p>Make Mirai Promise</p></a></li>
<li><a href='#call_mirai'><p>mirai (Call Value)</p></a></li>
<li><a href='#collect_mirai'><p>mirai (Collect Value)</p></a></li>
<li><a href='#daemon'><p>Daemon Instance</p></a></li>
<li><a href='#daemons'><p>Daemons (Set Persistent Processes)</p></a></li>
<li><a href='#dispatcher'><p>Dispatcher</p></a></li>
<li><a href='#everywhere'><p>Evaluate Everywhere</p></a></li>
<li><a href='#host_url'><p>URL Constructors</p></a></li>
<li><a href='#is_mirai'><p>Is mirai</p></a></li>
<li><a href='#is_mirai_error'><p>Error Validators</p></a></li>
<li><a href='#launch_local'><p>Launch Daemon</p></a></li>
<li><a href='#make_cluster'><p>Make Mirai Cluster</p></a></li>
<li><a href='#mirai'><p>mirai (Evaluate Async)</p></a></li>
<li><a href='#mirai_map'><p>mirai Map</p></a></li>
<li><a href='#nextstream'><p>Next &gt;&gt; Developer Interface</p></a></li>
<li><a href='#register_cluster'><p>Register Mirai Cluster</p></a></li>
<li><a href='#remote_config'><p>Generic and SSH Remote Launch Configuration</p></a></li>
<li><a href='#saisei'><p>Saisei (Regenerate Token)</p></a></li>
<li><a href='#serialization'><p>Custom Serialization Functions</p></a></li>
<li><a href='#status'><p>Status Information</p></a></li>
<li><a href='#stop_mirai'><p>mirai (Stop)</p></a></li>
<li><a href='#unresolved'><p>Query if a mirai is Unresolved</p></a></li>
<li><a href='#with.miraiDaemons'><p>With Mirai Daemons</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Minimalist Async Evaluation Framework for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>High-performance parallel code execution and distributed computing.
    Designed for simplicity, a 'mirai' evaluates an R expression asynchronously,
    on local or network resources, resolving automatically upon completion.
    Modern networking and concurrency built on 'nanonext' and 'NNG' (Nanomsg
    Next Gen) ensures reliable and efficient scheduling, over fast inter-process
    communications or TCP/IP secured by TLS.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>,
<a href="https://github.com/shikokuchuo/mirai/">https://github.com/shikokuchuo/mirai/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nanonext (&ge; 1.1.1)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>parallel, promises</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 09:39:28 UTC; cg334</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Gao <a href="https://orcid.org/0000-0002-0750-061X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Hibiki AI Limited [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Gao &lt;charlie.gao@shikokuchuo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 10:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='mirai-package'>mirai: Minimalist Async Evaluation Framework for R</h2><span id='topic+mirai-package'></span>

<h3>Description</h3>

<p>High-performance parallel code execution and distributed computing. Designed
for simplicity, a 'mirai' evaluates an R expression asynchronously, on
local or network resources, resolving automatically upon completion.
Modern networking and concurrency built on 'nanonext' and 'NNG' (Nanomsg
Next Gen) ensures reliable and efficient scheduling, over fast
inter-process communications or TCP/IP secured by TLS.
</p>


<h3>Notes</h3>

<p>For local mirai requests, the default transport for inter-process
communications is platform-dependent: abstract Unix domain sockets on
Linux, Unix domain sockets on MacOS, Solaris and other POSIX platforms,
and named pipes on Windows.
</p>
<p>This may be overriden, if desired, by specifying 'url' in the
<code><a href="#topic+daemons">daemons</a></code> interface and launching daemons using
<code><a href="#topic+launch_local">launch_local</a></code>.
</p>


<h3>Reference Manual</h3>

<p><code>vignette("mirai", package = "mirai")</code>
</p>


<h3>Author(s)</h3>

<p>Charlie Gao <a href="mailto:charlie.gao@shikokuchuo.net">charlie.gao@shikokuchuo.net</a>
(<a href="https://orcid.org/0000-0002-0750-061X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>
</p>
</li>
<li> <p><a href="https://github.com/shikokuchuo/mirai/">https://github.com/shikokuchuo/mirai/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.daemon'>dot Daemon</h2><span id='topic+.daemon'></span>

<h3>Description</h3>

<p>Ephemeral executor for the remote process. User code must not call this.
Consider <code>daemon(maxtasks = 1L)</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.daemon(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".daemon_+3A_url">url</code></td>
<td>
<p>the character host or dispatcher URL to dial into, including the
port to connect to (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE or FALSE.
</p>

<hr>
<h2 id='.progress'>mirai Map Options</h2><span id='topic+.progress'></span><span id='topic+.stop'></span>

<h3>Description</h3>

<p>Expressions to insert into the <code>[]</code> method for &lsquo;mirai_map&rsquo;
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.progress

.stop
</code></pre>


<h3>Format</h3>

<p>An object of class <code>expression</code> of length 1.
</p>
<p>An object of class <code>expression</code> of length 1.
</p>


<h3>Results</h3>

<p><code>x[]</code> collects the results of a mirai_map <code>x</code>. This will wait
for all asynchronous operations to complete if still in progress,
blocking but user-interruptible.
</p>
<p><code>x[.progress]</code> collects the results whilst showing a text progress
indicator.
</p>
<p><code>x[.stop]</code> collects the results applying early stopping, which stops
at the first failure and aborts all remaining in-progress operations.
</p>
<p><code>x[c(.stop, .progress)]</code> combines early stopping with a progress
indicator.
</p>

<hr>
<h2 id='as.promise.mirai'>Make Mirai Promise</h2><span id='topic+as.promise.mirai'></span>

<h3>Description</h3>

<p>Creates a &lsquo;promise&rsquo; from a &lsquo;mirai&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mirai'
as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.promise.mirai_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;mirai&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>as.promise</code> for
class &lsquo;mirai&rsquo;.
</p>
<p>Requires the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.
</p>
<p>Allows a &lsquo;mirai&rsquo; to be used with the promise pipe <code>%...&gt;%</code>,
which schedules a function to run upon resolution of the &lsquo;mirai&rsquo;.
</p>


<h3>Value</h3>

<p>A &lsquo;promise&rsquo; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; requireNamespace("promises", quietly = TRUE)) {

library(promises)

p &lt;- as.promise(mirai("example"))
print(p)
is.promise(p)

p2 &lt;- mirai("completed") %...&gt;% identity()
p2$then(cat)
is.promise(p2)

}

</code></pre>

<hr>
<h2 id='call_mirai'>mirai (Call Value)</h2><span id='topic+call_mirai'></span><span id='topic+call_mirai_'></span>

<h3>Description</h3>

<p><code>call_mirai</code> waits for the &lsquo;mirai&rsquo; to resolve if still in
progress, storing the value at <code>$data</code>, and returns the
&lsquo;mirai&rsquo; object.
</p>
<p><code>call_mirai_</code> is a variant of <code>call_mirai</code> that allows user
interrupts, suitable for interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_mirai(x)

call_mirai_(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_mirai_+3A_x">x</code></td>
<td>
<p>a &lsquo;mirai&rsquo; object, or list of &lsquo;mirai&rsquo; objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions accept a list of &lsquo;mirai&rsquo; objects, such as that
returned by <code><a href="#topic+mirai_map">mirai_map</a></code> as well as individual &lsquo;mirai&rsquo;.
</p>
<p>They will wait for the asynchronous operation(s) to complete if still in
progress (blocking).
</p>
<p><code>x[]</code> may also be used to wait for and return the value of a mirai
<code>x</code>, and is the equivalent of <code>call_mirai_(x)$data</code>.
</p>


<h3>Value</h3>

<p>The passed object (invisibly). For a &lsquo;mirai&rsquo;, the retrieved
value is stored at <code>$data</code>.
</p>


<h3>Alternatively</h3>

<p>The value of a &lsquo;mirai&rsquo; may be accessed at any time at
<code>$data</code>, and if yet to resolve, an &lsquo;unresolved&rsquo; logical NA
will be returned instead.
</p>
<p>Using <code><a href="#topic+unresolved">unresolved</a></code> on a &lsquo;mirai&rsquo; returns TRUE only if
it has yet to resolve and FALSE otherwise. This is suitable for use in
control flow statements such as <code>while</code> or <code>if</code>.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class &lsquo;miraiError&rsquo; and &lsquo;errorValue&rsquo;
(the stack trace is available at <code>$stack.trace</code> on the error
object). <code><a href="#topic+is_mirai_error">is_mirai_error</a></code> may be used to test for this.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
&lsquo;errorValue&rsquo; 19 (Connection reset) is returned (when not using
dispatcher or using dispatcher with <code>retry = FALSE</code>). Otherwise,
using dispatcher with <code>retry = TRUE</code>, the mirai will remain
unresolved and is automatically re-tried on the next daemon to connect to
the particular instance. To cancel the task instead, use
<code>saisei(force = TRUE)</code> (see <code><a href="#topic+saisei">saisei</a></code>).
</p>
<p><code><a href="#topic+is_error_value">is_error_value</a></code> tests for all error conditions including
&lsquo;mirai&rsquo; errors, interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# using call_mirai()
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), df1 = df1, df2 = df2, .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

}

</code></pre>

<hr>
<h2 id='collect_mirai'>mirai (Collect Value)</h2><span id='topic+collect_mirai'></span>

<h3>Description</h3>

<p><code>collect_mirai</code> waits for the &lsquo;mirai&rsquo; to resolve if still in
progress, and returns its value directly. It is a more efifcient version
of and equivalent to <code>call_mirai(x)$data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_mirai_+3A_x">x</code></td>
<td>
<p>a &lsquo;mirai&rsquo; object, or list of &lsquo;mirai&rsquo; objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will wait for the asynchronous operation(s) to
complete if still in progress (blocking), and is not interruptible.
</p>
<p><code>x[]</code> may be used to wait for and return the value of a mirai
<code>x</code>, and is the user-interruptible counterpart to
<code>collect_mirai(x)</code>.
</p>


<h3>Value</h3>

<p>An object (the return value of the &lsquo;mirai&rsquo;), or a list of such
objects (the same length as &lsquo;x&rsquo;, preserving names).
</p>


<h3>Alternatively</h3>

<p>The value of a &lsquo;mirai&rsquo; may be accessed at any time at
<code>$data</code>, and if yet to resolve, an &lsquo;unresolved&rsquo; logical NA
will be returned instead.
</p>
<p>Using <code><a href="#topic+unresolved">unresolved</a></code> on a &lsquo;mirai&rsquo; returns TRUE only if
it has yet to resolve and FALSE otherwise. This is suitable for use in
control flow statements such as <code>while</code> or <code>if</code>.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class &lsquo;miraiError&rsquo; and &lsquo;errorValue&rsquo;
(the stack trace is available at <code>$stack.trace</code> on the error
object). <code><a href="#topic+is_mirai_error">is_mirai_error</a></code> may be used to test for this.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
&lsquo;errorValue&rsquo; 19 (Connection reset) is returned (when not using
dispatcher or using dispatcher with <code>retry = FALSE</code>). Otherwise,
using dispatcher with <code>retry = TRUE</code>, the mirai will remain
unresolved and is automatically re-tried on the next daemon to connect to
the particular instance. To cancel the task instead, use
<code>saisei(force = TRUE)</code> (see <code><a href="#topic+saisei">saisei</a></code>).
</p>
<p><code><a href="#topic+is_error_value">is_error_value</a></code> tests for all error conditions including
&lsquo;mirai&rsquo; errors, interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# using collect_mirai()
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), df1 = df1, df2 = df2, .timeout = 1000)
collect_mirai(m)

# using x[]
m[]

}

</code></pre>

<hr>
<h2 id='daemon'>Daemon Instance</h2><span id='topic+daemon'></span>

<h3>Description</h3>

<p>Starts up an execution daemon to receive <code><a href="#topic+mirai">mirai</a></code> requests. Awaits
data, evaluates an expression in an environment containing the supplied
data, and returns the value to the host caller. Daemon settings may be
controlled by <code><a href="#topic+daemons">daemons</a></code> and this function should not need to
be invoked directly, unless deploying manually on remote resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemon(
  url,
  autoexit = TRUE,
  cleanup = TRUE,
  output = FALSE,
  maxtasks = Inf,
  idletime = Inf,
  walltime = Inf,
  timerstart = 0L,
  ...,
  tls = NULL,
  rs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daemon_+3A_url">url</code></td>
<td>
<p>the character host or dispatcher URL to dial into, including the
port to connect to (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
<tr><td><code id="daemon_+3A_autoexit">autoexit</code></td>
<td>
<p>[default TRUE] logical value, whether the daemon should
exit automatically when its socket connection ends. If a signal from the
<span class="pkg">tools</span> package, e.g. <code>tools::SIGINT</code>, or an equivalent integer
value is supplied, this signal is additionally raised (see 'Persistence'
section below).</p>
</td></tr>
<tr><td><code id="daemon_+3A_cleanup">cleanup</code></td>
<td>
<p>[default TRUE] logical value, whether to perform cleanup of
the global environment and restore loaded packages and options to an
initial state after each evaluation. For more granular control, also
accepts an integer value (see &lsquo;Cleanup Options&rsquo; section below).</p>
</td></tr>
<tr><td><code id="daemon_+3A_output">output</code></td>
<td>
<p>[default FALSE] logical value, to output generated stdout /
stderr if TRUE, or else discard if FALSE. Specify as TRUE in the
&lsquo;...&rsquo; argument to <code><a href="#topic+daemons">daemons</a></code> or
<code><a href="#topic+launch_local">launch_local</a></code> to provide redirection of output to the host
process (applicable only for local daemons).</p>
</td></tr>
<tr><td><code id="daemon_+3A_maxtasks">maxtasks</code></td>
<td>
<p>[default Inf] the maximum number of tasks to execute (task
limit) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_idletime">idletime</code></td>
<td>
<p>[default Inf] maximum idle time, since completion of the last
task (in milliseconds) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_walltime">walltime</code></td>
<td>
<p>[default Inf] soft walltime, or the minimum amount of real
time taken (in milliseconds) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_timerstart">timerstart</code></td>
<td>
<p>[default 0L] number of completed tasks after which to start
the timer for &lsquo;idletime&rsquo; and &lsquo;walltime&rsquo;. 0L implies timers
are started upon launch.</p>
</td></tr>
<tr><td><code id="daemon_+3A_...">...</code></td>
<td>
<p>reserved but not currently used.</p>
</td></tr>
<tr><td><code id="daemon_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over 'tls+tcp://'
or 'wss://'. <strong>Either</strong> the character path to a file containing
X.509 certificate(s) in PEM format, comprising the certificate authority
certificate chain starting with the TLS certificate and ending with the
CA certificate, <strong>or</strong> a length 2 character vector comprising [i]
the certificate authority certificate chain and [ii] the empty string
<code>''</code>.</p>
</td></tr>
<tr><td><code id="daemon_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host
process and should not be independently supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that daemons dial into the host or
dispatcher, which listens at the &lsquo;url&rsquo; address. In this way,
network resources may be added or removed dynamically and the host or
dispatcher automatically distributes tasks to all available daemons.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Persistence</h3>

<p>The &lsquo;autoexit&rsquo; argument governs persistence settings for the
daemon. The default TRUE ensures that it will exit cleanly once its
socket connection has ended.
</p>
<p>Instead of TRUE, supplying a signal from the <span class="pkg">tools</span> package, e.g.
<code>tools::SIGINT</code>, or an equivalent integer value, sets the signal to
be raised when the socket connection ends. As an example, supplying
SIGINT allows a potentially more immediate exit by interrupting any
ongoing evaluation rather than letting it complete.
</p>
<p>Setting to FALSE allows the daemon to persist indefinitely even when
there is no longer a socket connection. This allows a host session to end
and a new session to connect at the URL where the daemon is dialled in.
Daemons must be terminated with <code>daemons(NULL)</code> in this case, which
sends explicit exit instructions to all connected daemons.
</p>
<p>Persistence also implies that dials are performed asynchronously, which
means retries are attempted (indefinitely) if not immediately successful.
This is resilient behaviour but can mask potential connection issues.
</p>


<h3>Cleanup Options</h3>

<p>The &lsquo;cleanup&rsquo; argument also accepts an integer value, which
operates an additive bitmask: perform cleanup of the global environment
(1L), reset loaded packages to an initial state (2L), restore options to
an initial state (4L), and perform garbage collection (8L).
</p>
<p>As an example, to perform cleanup of the global environment and garbage
collection, specify 9L (1L + 8L). The default argument value of TRUE
performs all actions apart from garbage collection and is equivalent to a
value of 7L.
</p>
<p>Caution: do not reset options but not loaded packages if packages set
options on load.
</p>

<hr>
<h2 id='daemons'>Daemons (Set Persistent Processes)</h2><span id='topic+daemons'></span>

<h3>Description</h3>

<p>Set &lsquo;daemons&rsquo; or persistent background processes to receive
<code><a href="#topic+mirai">mirai</a></code> requests. Specify &lsquo;n&rsquo; to create daemons on the
local machine. Specify &lsquo;url&rsquo; for receiving connections from remote
daemons (for distributed computing across the network). Specify
&lsquo;remote&rsquo; to optionally launch remote daemons via a remote
configuration. By default, dispatcher ensures optimal scheduling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemons(
  n,
  url = NULL,
  remote = NULL,
  dispatcher = TRUE,
  ...,
  seed = NULL,
  tls = NULL,
  pass = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daemons_+3A_n">n</code></td>
<td>
<p>integer number of daemons to set.</p>
</td></tr>
<tr><td><code id="daemons_+3A_url">url</code></td>
<td>
<p>[default NULL] if specified, the character URL or vector of URLs
on the host for remote daemons to dial into, including a port accepting
incoming connections (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'. Specify a URL
starting 'tls+tcp://' or 'wss://' to use secure TLS connections.
Auxiliary function <code><a href="#topic+host_url">host_url</a></code> may be used to construct a
valid host URL.</p>
</td></tr>
<tr><td><code id="daemons_+3A_remote">remote</code></td>
<td>
<p>[default NULL] required only for launching remote daemons, a
configuration generated by <code><a href="#topic+remote_config">remote_config</a></code> or
<code><a href="#topic+ssh_config">ssh_config</a></code>.</p>
</td></tr>
<tr><td><code id="daemons_+3A_dispatcher">dispatcher</code></td>
<td>
<p>[default TRUE] logical value whether to use dispatcher.
Dispatcher is a local background process that connects to daemons on
behalf of the host and ensures FIFO scheduling (see Dispatcher section
below).</p>
</td></tr>
<tr><td><code id="daemons_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to
<code><a href="#topic+dispatcher">dispatcher</a></code> if using dispatcher and/or <code><a href="#topic+daemon">daemon</a></code>
if launching daemons. These include &lsquo;retry&rsquo; and &lsquo;token&rsquo; at
dispatcher and &lsquo;autoexit&rsquo;, &lsquo;cleanup&rsquo;, &lsquo;output&rsquo;,
&lsquo;maxtasks&rsquo;, &lsquo;idletime&rsquo;, &lsquo;walltime&rsquo; and
&lsquo;timerstart&rsquo; at daemon.</p>
</td></tr>
<tr><td><code id="daemons_+3A_seed">seed</code></td>
<td>
<p>[default NULL] (optional) supply a random seed (single value,
interpreted as an integer). This is used to inititalise the L'Ecuyer-CMRG
RNG streams sent to each daemon. Note that reproducible results can be
expected only for <code>dispatcher = FALSE</code>, as the unpredictable timing
of task completions would otherwise influence the tasks sent to each
daemon. Even for <code>dispatcher = FALSE</code>, reproducibility is not
guaranteed if the order in which tasks are sent is not deterministic.</p>
</td></tr>
<tr><td><code id="daemons_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (optional for secure TLS connections) if not
supplied, zero-configuration single-use keys and certificates are
automatically generated. If supplied, <strong>either</strong> the character path
to a file containing the PEM-encoded TLS certificate and associated
private key (may contain additional certificates leading to a validation
chain, with the TLS certificate first), <strong>or</strong> a length 2 character
vector comprising [i] the TLS certificate (optionally certificate chain)
and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="daemons_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to
&lsquo;tls&rsquo; is encrypted with a password) For security, should be
provided through a function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="daemons_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>daemons(0)</code> to reset daemon connections:
</p>

<ul>
<li><p> All connected daemons and/or dispatchers exit automatically.
</p>
</li>
<li> <p><span class="pkg">mirai</span> reverts to the default behaviour of creating a new
background process for each request.
</p>
</li>
<li><p> Any unresolved &lsquo;mirai&rsquo; will return an &lsquo;errorValue&rsquo; 19
(Connection reset) after a reset.
</p>
</li>
<li><p> Calling <code>daemons</code> with revised (or even the same) settings for
the same compute profile implicitly resets daemons before applying the
new settings.
</p>
</li></ul>

<p>If the host session ends, all connected dispatcher and daemon processes
automatically exit as soon as their connections are dropped (unless
the daemons were started with <code>autoexit = FALSE</code>). If a daemon is
processing a task, it will exit as soon as the task is complete.
</p>
<p>To reset persistent daemons started with <code>autoexit = FALSE</code>, use
<code>daemons(NULL)</code> instead, which also sends exit instructions to all
connected daemons prior to resetting.
</p>
<p>For historical reasons, <code>daemons()</code> with no arguments returns the
value of <code><a href="#topic+status">status</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the arguments supplied:
</p>

<ul>
<li><p> using dispatcher: integer number of daemons set.
</p>
</li>
<li><p> or else launching local daemons: integer number of daemons launched.
</p>
</li>
<li><p> otherwise: the character host URL.
</p>
</li></ul>



<h3>Local Daemons</h3>

<p>Daemons provide a potentially more efficient solution for asynchronous
operations as new processes no longer need to be created on an <em>ad
hoc</em> basis.
</p>
<p>Supply the argument &lsquo;n&rsquo; to set the number of daemons. New
background <code><a href="#topic+daemon">daemon</a></code> processes are automatically created on
the local machine connecting back to the host process, either directly or
via dispatcher.
</p>


<h3>Dispatcher</h3>

<p>By default <code>dispatcher = TRUE</code>. This launches a background process
running <code><a href="#topic+dispatcher">dispatcher</a></code>. Dispatcher connects to daemons on
behalf of the host and ensures FIFO scheduling of tasks. Dispatcher uses
synchronisation primitives from <span class="pkg">nanonext</span>, waiting rather than
polling for tasks, which is both efficient (no resource usage) and fully
event-driven (having no latency).
</p>
<p>By specifying <code>dispatcher = FALSE</code>, daemons connect to the host
directly rather than through dispatcher. The host sends tasks to
connected daemons immediately in a round-robin fashion. Optimal
scheduling is not guaranteed as the duration of tasks cannot be known
<em>a priori</em>, hence tasks can be queued at one daemon while other
daemons remain idle. However, this provides a resource-light approach
suited to working with similar-length tasks, or where concurrent tasks
typically do not exceed available daemons.
</p>


<h3>Distributed Computing</h3>

<p>Specifying &lsquo;url&rsquo; allows tasks to be distributed across the network.
This should be a character string such as &lsquo;tcp://10.75.32.70:5555&rsquo;
at which daemon processes should connect to. Switching the URL scheme to
&lsquo;tls+tcp://&rsquo; or &lsquo;wss://&rsquo; automatically upgrades the
connection to use TLS. The auxiliary function <code><a href="#topic+host_url">host_url</a></code> may
be used to automatically construct a valid host URL based on the
computer's hostname.
</p>
<p>Specify &lsquo;remote&rsquo; with a call to <code><a href="#topic+remote_config">remote_config</a></code> or
<code><a href="#topic+ssh_config">ssh_config</a></code> to launch daemons on remote machines. Otherwise,
<code><a href="#topic+launch_remote">launch_remote</a></code> may be used to generate the shell commands to
deploy daemons manually on remote resources.
</p>
<p>IPv6 addresses are also supported and must be enclosed in square brackets
[ ] to avoid confusion with the final colon separating the port. For
example, port 5555 on the IPv6 loopback address ::1 would be specified
as &lsquo;tcp://[::1]:5555&rsquo;.
</p>
<p>Specifying the wildcard value zero for the port number e.g.
&lsquo;tcp://[::1]:0&rsquo; or &lsquo;ws://[::1]:0&rsquo; will automatically assign
a free ephemeral port. Use <code><a href="#topic+status">status</a></code> to inspect the actual
assigned port at any time.
</p>
<p><strong>With Dispatcher</strong>
</p>
<p>When using dispatcher, it is recommended to use a websocket URL rather
than TCP, as this requires only one port to connect to all daemons: a
websocket URL supports a path after the port number, which can be made
unique for each daemon.
</p>
<p>Specifying a single host URL such as &lsquo;ws://10.75.32.70:5555&rsquo; with
<code>n = 6</code> will automatically append a sequence to the path, listening
to the URLs &lsquo;ws://10.75.32.70:5555/1&rsquo; through
&lsquo;ws://110.75.32.70:5555/6&rsquo;.
</p>
<p>Alternatively, specify a vector of URLs to listen to arbitrary port
numbers / paths. In this case it is optional to supply &lsquo;n&rsquo; as this
can be inferred by the length of vector supplied.
</p>
<p>Individual daemons then dial in to each of these host URLs. At most one
daemon can be dialled into each URL at any given time.
</p>
<p>Dispatcher automatically adjusts to the number of daemons actually
connected. Hence it is possible to dynamically scale up or down the
number of daemons as required, subject to the maximum number initially
specified.
</p>
<p>Alternatively, supplying a single TCP URL will listen at a block of URLs
with ports starting from the supplied port number and incrementing by one
for &lsquo;n&rsquo; specified e.g. the host URL
&lsquo;tcp://10.75.32.70:5555&rsquo; with <code>n = 6</code> listens to the
contiguous block of ports 5555 through 5560.
</p>
<p><strong>Without Dispatcher</strong>
</p>
<p>A TCP URL may be used in this case as the host listens at only one
address, utilising a single port.
</p>
<p>The network topology is such that daemons (started with
<code><a href="#topic+daemon">daemon</a></code>) or indeed dispatchers (started with
<code><a href="#topic+dispatcher">dispatcher</a></code>) dial into the same host URL.
</p>
<p>&lsquo;n&rsquo; is not required in this case, and disregarded if supplied, as
network resources may be added or removed at any time. The host
automatically distributes tasks to all connected daemons and dispatchers
in a round-robin fashion.
</p>


<h3>Compute Profiles</h3>

<p>By default, the &lsquo;default&rsquo; compute profile is used. Providing a
character value for &lsquo;.compute&rsquo; creates a new compute profile with
the name specified. Each compute profile retains its own daemons
settings, and may be operated independently of each other. Some usage
examples follow:
</p>
<p><strong>local / remote</strong> daemons may be set with a host URL and specifying
&lsquo;.compute&rsquo; as &lsquo;remote&rsquo;, which creates a new compute
profile. Subsequent <code><a href="#topic+mirai">mirai</a></code> calls may then be sent for local
computation by not specifying the &lsquo;.compute&rsquo; argument, or for
remote computation to connected daemons by specifying the
&lsquo;.compute&rsquo; argument as &lsquo;remote&rsquo;.
</p>
<p><strong>cpu / gpu</strong> some tasks may require access to different types of
daemon, such as those with GPUs. In this case, <code>daemons()</code> may be
called twice to set up host URLs for CPU-only daemons and for those
with GPUs, specifying the &lsquo;.compute&rsquo; argument as &lsquo;cpu&rsquo; and
&lsquo;gpu&rsquo; respectively. By supplying the &lsquo;.compute&rsquo; argument to
subsequent <code><a href="#topic+mirai">mirai</a></code> calls, tasks may be sent to either
&lsquo;cpu&rsquo; or &lsquo;gpu&rsquo; daemons as appropriate.
</p>
<p>Note: further actions such as resetting daemons via <code>daemons(0)</code>
should be carried out with the desired &lsquo;.compute&rsquo; argument
specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# Create 2 local daemons (using dispatcher)
daemons(2)
status()
# Reset to zero
daemons(0)

# Create 2 local daemons (not using dispatcher)
daemons(2, dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

# 2 remote daemons via dispatcher using WebSockets
daemons(2, url = host_url(ws = TRUE))
status()
# Reset to zero
daemons(0)

# Set host URL for remote daemons to dial into
daemons(url = host_url(), dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

# Use with() to evaluate with daemons for the duration of the expression
with(
  daemons(2),
  {
    m1 &lt;- mirai(Sys.getpid())
    m2 &lt;- mirai(Sys.getpid())
    cat(call_mirai(m1)$data, call_mirai(m2)$data, "\n")
  }
)

}

## Not run: 
# Launch 2 daemons on remotes 'nodeone' and 'nodetwo' using SSH
# connecting back directly to the host URL over a TLS connection:

daemons(url = host_url(tls = TRUE),
        remote = ssh_config(c('ssh://nodeone', 'ssh://nodetwo')),
        dispatcher = FALSE)

# Launch 4 daemons on the remote machine 10.75.32.90 using SSH tunnelling
# over port 5555 ('url' hostname must be 'localhost' or '127.0.0.1'):

daemons(n = 4,
        url = 'ws://localhost:5555',
        remote = ssh_config('ssh://10.75.32.90', tunnel = TRUE))


## End(Not run)

</code></pre>

<hr>
<h2 id='dispatcher'>Dispatcher</h2><span id='topic+dispatcher'></span>

<h3>Description</h3>

<p>Dispatches tasks from a host to daemons for processing, using FIFO
scheduling, queuing tasks as required. Daemon / dispatcher settings
may be controlled by <code><a href="#topic+daemons">daemons</a></code> and this function should not
need to be invoked directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatcher(
  host,
  url = NULL,
  n = NULL,
  ...,
  asyncdial = FALSE,
  retry = FALSE,
  token = FALSE,
  tls = NULL,
  pass = NULL,
  rs = NULL,
  monitor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispatcher_+3A_host">host</code></td>
<td>
<p>the character host URL to dial (where tasks are sent from),
including the port to connect to (and optionally for websockets, a path),
e.g. 'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_url">url</code></td>
<td>
<p>(optional) the character URL or vector of URLs dispatcher should
listen at, including the port to connect to (and optionally for websockets,
a path), e.g. 'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.
Specify 'tls+tcp://' or 'wss://' to use secure TLS connections. Tasks are
sent to daemons dialled into these URLs. If not supplied, &lsquo;n&rsquo;
local inter-process URLs will be assigned automatically.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_n">n</code></td>
<td>
<p>(optional) if specified, the integer number of daemons to listen for.
Otherwise &lsquo;n&rsquo; will be inferred from the number of URLs supplied in
&lsquo;url&rsquo;. Where a single URL is supplied and &lsquo;n&rsquo; &gt; 1,
&lsquo;n&rsquo; unique URLs will be automatically assigned for daemons to dial
into.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to <code><a href="#topic+daemon">daemon</a></code>.
These include &lsquo;autoexit&rsquo;, &lsquo;cleanup&rsquo;, &lsquo;maxtasks&rsquo;,
&lsquo;idletime&rsquo;, &lsquo;walltime&rsquo; and &lsquo;timerstart&rsquo;.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_asyncdial">asyncdial</code></td>
<td>
<p>[default FALSE] whether to perform dials asynchronously. The
default FALSE will error if a connection is not immediately possible
(e.g. <code><a href="#topic+daemons">daemons</a></code> has yet to be called on the host, or the
specified port is not open etc.). Specifying TRUE continues retrying
(indefinitely) if not immediately successful, which is more resilient but
can mask potential connection issues.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_retry">retry</code></td>
<td>
<p>[default FALSE] if TRUE, a task where the daemon crashes or
terminates unexpectedly will be automatically re-tried on the next daemon
instance to connect. In such a case, the mirai will remain unresolved but
<code><a href="#topic+status">status</a></code> will show &lsquo;online&rsquo; as 0 and &lsquo;assigned&rsquo;
&gt; &lsquo;complete&rsquo;. To cancel a task in such a case, use
<code>saisei(force = TRUE)</code>. If FALSE, such tasks will be returned as
&lsquo;errorValue&rsquo; 19 (Connection reset).</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_token">token</code></td>
<td>
<p>[default FALSE] if TRUE, appends a unique 24-character token
to each URL path the dispatcher listens at (not applicable for TCP URLs
which do not accept a path).</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (required for secure TLS connections) <strong>either</strong>
the character path to a file containing the PEM-encoded TLS certificate
and associated private key (may contain additional certificates leading
to a validation chain, with the TLS certificate first), <strong>or</strong> a
length 2 character vector comprising [i] the TLS certificate (optionally
certificate chain) and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to
&lsquo;tls&rsquo; is encrypted with a password) For security, should be
provided through a function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host
process and should not be independently supplied.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_monitor">monitor</code></td>
<td>
<p>(for package internal use only) do not set this parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that a dispatcher acts as a gateway
between the host and daemons, ensuring that tasks received from the host
are dispatched on a FIFO basis for processing. Tasks are queued at the
dispatcher to ensure tasks are only sent to daemons that can begin
immediate execution of the task.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>

<hr>
<h2 id='everywhere'>Evaluate Everywhere</h2><span id='topic+everywhere'></span>

<h3>Description</h3>

<p>Evaluate an expression &lsquo;everywhere&rsquo; on all connected daemons for the
specified compute profile. Designed for performing setup operations
across daemons or exporting common data, resultant changes to the global
environment, loaded packages or options are persisted regardless of a
daemon's &lsquo;cleanup&rsquo; setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>everywhere(.expr, ..., .args = list(), .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="everywhere_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or else</strong> a pre-constructed
language object.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_...">...</code></td>
<td>
<p>(optional) <strong>either</strong> named arguments (name = value pairs)
specifying objects referenced, but not defined, in &lsquo;.expr&rsquo;,
<strong>or</strong> an environment containing such objects. See
&lsquo;evaluation&rsquo; section below.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a named list specifying objects
referenced, but not defined, in &lsquo;.expr&rsquo;, <strong>or</strong> an
environment containing such objects. These objects will remain local to
the evaluation environment as opposed to those supplied in &lsquo;...&rsquo;
above - see &lsquo;evaluation&rsquo; section below.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Evaluation</h3>

<p>The expression &lsquo;.expr&rsquo; will be evaluated in a separate R process
in a clean environment (not the global environment), consisting only of
the objects in the list or environment supplied to &lsquo;.args&rsquo;, with
the named objects passed as &lsquo;...&rsquo; (from the environment if one was
supplied) assigned to the global environment of that process.
</p>
<p>For evaluation to occur <em>as if</em> in your global environment, supply
objects to &lsquo;...&rsquo; rather than &lsquo;.args&rsquo;. For stricter scoping,
use &lsquo;.args&rsquo;, which limits, for example, where variables not
explicitly passed as arguments to functions are found.
</p>
<p>As evaluation occurs in a clean environment, all undefined objects must
be supplied though &lsquo;...&rsquo; and/or &lsquo;.args&rsquo;, including
self-defined functions. Functions from a package should use namespaced
calls such as <code>mirai::mirai()</code>, or else the package should be loaded
beforehand as part of &lsquo;.expr&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1)
# export common data by a super-assignment expression:
everywhere(y &lt;&lt;- 3)
# '...' variables are assigned to the global environment:
everywhere({}, a = 1, b = 2)
m &lt;- mirai(a + b - y == 0L)
call_mirai(m)$data
daemons(0)

daemons(1, dispatcher = FALSE)
everywhere(library(parallel))
m &lt;- mirai("package:parallel" %in% search())
call_mirai(m)$data
daemons(0)

}

</code></pre>

<hr>
<h2 id='host_url'>URL Constructors</h2><span id='topic+host_url'></span><span id='topic+local_url'></span>

<h3>Description</h3>

<p><code>host_url</code> constructs a valid host URL (at which daemons may connect)
based on the computer's hostname. This may be supplied directly to the
&lsquo;url&rsquo; argument of <code><a href="#topic+daemons">daemons</a></code>.
</p>
<p><code>local_url</code> constructs a random URL suitable for local daemons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>host_url(ws = FALSE, tls = FALSE, port = 0)

local_url()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="host_url_+3A_ws">ws</code></td>
<td>
<p>[default FALSE] logical value whether to use a WebSockets 'ws://'
or else TCP 'tcp://' scheme.</p>
</td></tr>
<tr><td><code id="host_url_+3A_tls">tls</code></td>
<td>
<p>[default FALSE] logical value whether to use TLS in which case the
scheme used will be either 'wss://' or 'tls+tcp://' accordingly.</p>
</td></tr>
<tr><td><code id="host_url_+3A_port">port</code></td>
<td>
<p>[default 0] numeric port to use. This should be open to
connections from the network addresses the daemons are connecting from.
&lsquo;0&rsquo; is a wildcard value that automatically assigns a free
ephemeral port.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>host_url</code> relies on using the host name of the computer
rather than an IP address and typically works on local networks, although
this is not always guaranteed. If unsuccessful, substitute an IPv4 or
IPv6 address in place of the hostname.
</p>
<p><code>local_url</code> generates a random URL for the platform's default
inter-process communications transport: abstract Unix domain sockets on
Linux, Unix domain sockets on MacOS, Solaris and other POSIX platforms,
and named pipes on Windows.
</p>


<h3>Value</h3>

<p>A character string comprising a valid URL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>host_url()
host_url(ws = TRUE)
host_url(tls = TRUE)
host_url(ws = TRUE, tls = TRUE, port = 5555)

local_url()

</code></pre>

<hr>
<h2 id='is_mirai'>Is mirai</h2><span id='topic+is_mirai'></span>

<h3>Description</h3>

<p>Is the object a &lsquo;mirai&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mirai_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE if &lsquo;x&rsquo; is of class &lsquo;mirai&rsquo;, FALSE
otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

df &lt;- data.frame()
m &lt;- mirai(as.matrix(df), df = df)
is_mirai(m)
is_mirai(df)

}

</code></pre>

<hr>
<h2 id='is_mirai_error'>Error Validators</h2><span id='topic+is_mirai_error'></span><span id='topic+is_mirai_interrupt'></span><span id='topic+is_error_value'></span>

<h3>Description</h3>

<p>Validator functions for error value types created by <span class="pkg">mirai</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai_error(x)

is_mirai_interrupt(x)

is_error_value(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mirai_error_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the object a &lsquo;miraiError&rsquo;. When execution in a
&lsquo;mirai&rsquo; process fails, the error message is returned as a
character string of class &lsquo;miraiError&rsquo; and &lsquo;errorValue&rsquo;.
The stack trace is available at <code>$stack.trace</code> on the error object.
</p>
<p>Is the object a &lsquo;miraiInterrupt&rsquo;. When an ongoing &lsquo;mirai&rsquo;
is sent a user interrupt, it will resolve to an empty character string
classed as &lsquo;miraiInterrupt&rsquo; and &lsquo;errorValue&rsquo;.
</p>
<p>Is the object an &lsquo;errorValue&rsquo;, such as a &lsquo;mirai&rsquo; timeout,
a &lsquo;miraiError&rsquo; or a &lsquo;miraiInterrupt&rsquo;. This is a catch-all
condition that includes all returned error values.
</p>


<h3>Value</h3>

<p>Logical value TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

m &lt;- mirai(stop())
call_mirai(m)
is_mirai_error(m$data)
is_mirai_interrupt(m$data)
is_error_value(m$data)
m$data$stack.trace

m2 &lt;- mirai(Sys.sleep(1L), .timeout = 100)
call_mirai(m2)
is_mirai_error(m2$data)
is_mirai_interrupt(m2$data)
is_error_value(m2$data)

}

</code></pre>

<hr>
<h2 id='launch_local'>Launch Daemon</h2><span id='topic+launch_local'></span><span id='topic+launch_remote'></span>

<h3>Description</h3>

<p><code>launch_local</code> spawns a new background <code>Rscript</code> process calling
<code><a href="#topic+daemon">daemon</a></code> with the specified arguments.
</p>
<p><code>launch_remote</code> returns the shell command for deploying daemons as a
character vector. If a configuration generated by
<code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code> is supplied then
this is used to launch the daemon on the remote machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_local(url, ..., tls = NULL, .compute = "default")

launch_remote(
  url,
  remote = remote_config(),
  ...,
  tls = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_local_+3A_url">url</code></td>
<td>
<p>the character host URL or vector of host URLs, including the port
to connect to (and optionally for websockets, a path), e.g.
tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'
</p>
<p><strong>or</strong> integer index value, or vector of index values, of the
dispatcher URLs, or 1L for the host URL (when not using dispatcher).
</p>
<p><strong>or</strong> for <code>launch_remote</code> only, a &lsquo;miraiCluster&rsquo; or
&lsquo;miraiNode&rsquo;.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to
<code><a href="#topic+daemon">daemon</a></code>. These include &lsquo;autoexit&rsquo;, &lsquo;cleanup&rsquo;,
&lsquo;output&rsquo;, &lsquo;maxtasks&rsquo;, &lsquo;idletime&rsquo;, &lsquo;walltime&rsquo;
and &lsquo;timerstart&rsquo;.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over tls+tcp or
wss. Zero-configuration TLS certificates generated by <code><a href="#topic+daemons">daemons</a></code>
are automatically passed to the daemon, without requiring to be specified
here. Otherwise, supply <strong>either</strong> the character path to a file
containing X.509 certificate(s) in PEM format, comprising the certificate
authority certificate chain, <strong>or</strong> a length 2 character vector
comprising [i] the certificate authority certificate chain and [ii] the
empty character &rdquo;.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="launch_local_+3A_remote">remote</code></td>
<td>
<p>required only for launching remote daemons, a configuration
generated by <code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code>. An
empty <code><a href="#topic+remote_config">remote_config</a></code> does not effect any daemon launches but
returns the shell commands for deploying manually on remote machines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions may be used to re-launch daemons that have exited
after reaching time or task limits.
</p>
<p>If daemons have been set, the generated command will automatically
contain the argument &lsquo;rs&rsquo; specifying the length 7 L'Ecuyer-CMRG
random seed supplied to the daemon. The values will be different each
time the function is called.
</p>


<h3>Value</h3>

<p>For <strong>launch_local</strong>: Invisible NULL.
</p>
<p>For <strong>launch_remote</strong>: A character vector of daemon launch
commands, classed as &lsquo;miraiLaunchCmd&rsquo;. The printed output may be
directly copy / pasted to the remote machine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(url = host_url(ws = TRUE), dispatcher = FALSE)
status()
launch_local(status()$daemons, maxtasks = 10L)
launch_remote(1L, maxtasks = 10L)
Sys.sleep(1)
status()
daemons(0)

daemons(n = 2L, url = host_url(tls = TRUE))
status()
launch_local(1:2, idletime = 60000L, timerstart = 1L)
launch_remote(1:2, idletime = 60000L, timerstart = 1L)
Sys.sleep(1)
status()
daemons(0)

}

</code></pre>

<hr>
<h2 id='make_cluster'>Make Mirai Cluster</h2><span id='topic+make_cluster'></span><span id='topic+stop_cluster'></span>

<h3>Description</h3>

<p><code>make_cluster</code> creates a cluster of type &lsquo;miraiCluster&rsquo;, which
may be used as a cluster object for any function in the <span class="pkg">parallel</span>
base package such as <code><a href="parallel.html#topic+clusterApply">clusterApply</a></code> or
<code><a href="parallel.html#topic+parLapply">parLapply</a></code>.
</p>
<p><code>stop_cluster</code> stops a cluster created by <code>make_cluster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cluster(n, url = NULL, remote = NULL, ...)

stop_cluster(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cluster_+3A_n">n</code></td>
<td>
<p>integer number of nodes (automatically launched on the local machine
unless &lsquo;url&rsquo; is supplied).</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_url">url</code></td>
<td>
<p>[default NULL] (specify for remote nodes) the character URL on the
host for remote nodes to dial into, including a port accepting incoming
connections, e.g. 'tcp://10.75.37.40:5555'. Specify a URL with the scheme
&lsquo;tls+tcp://&rsquo; to use secure TLS connections.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_remote">remote</code></td>
<td>
<p>[default NULL] (specify to launch remote nodes) a remote launch
configuration generated by <code><a href="#topic+remote_config">remote_config</a></code> or
<code><a href="#topic+ssh_config">ssh_config</a></code>. If not supplied, nodes may be deployed manually
on remote resources.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_...">...</code></td>
<td>
<p>additional arguments passed onto <code><a href="#topic+daemons">daemons</a></code>.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_cl">cl</code></td>
<td>
<p>a &lsquo;miraiCluster&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <strong>make_cluster</strong>: An object of class &lsquo;miraiCluster&rsquo;
and &lsquo;cluster&rsquo;. Each &lsquo;miraiCluster&rsquo; has an automatically
assigned ID and &lsquo;n&rsquo; nodes of class &lsquo;miraiNode&rsquo;. If
&lsquo;url&rsquo; is supplied but not &lsquo;remote&rsquo;, the shell commands for
deployment of nodes on remote resources are printed to the console.
</p>
<p>For <strong>stop_cluster</strong>: invisible NULL.
</p>


<h3>Remote Nodes</h3>

<p>Specify &lsquo;url&rsquo; and &lsquo;n&rsquo; to set up a host connection for
remote nodes to dial into. &lsquo;n&rsquo; defaults to one if not specified.
</p>
<p>Also specify &lsquo;remote&rsquo; to launch the nodes using a configuration
generated by <code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code>.
In this case, the number of nodes is inferred from the configuration
provided and &lsquo;n&rsquo; is disregarded.
</p>
<p>If &lsquo;remote&rsquo; is not supplied, the shell commands for deploying
nodes manually on remote resources are automatically printed to the
console.
</p>
<p><code><a href="#topic+launch_remote">launch_remote</a></code> may be called at any time on a
&lsquo;miraiCluster&rsquo; to return the shell commands for deployment of all
nodes, or on a &lsquo;miraiNode&rsquo; to return the command for a single node.
</p>


<h3>Status</h3>

<p>Call <code><a href="#topic+status">status</a></code> on a &lsquo;miraiCluster&rsquo; to check the number
of currently active connections as well as the host URL.
</p>


<h3>Errors</h3>

<p>Errors are thrown by the &lsquo;parallel&rsquo; mechanism if one or more nodes
failed (quit unexpectedly). The resulting &lsquo;errorValue&rsquo; returned is
19 (Connection reset). Other types of error, e.g. in evaluation, should
result in the usual &lsquo;miraiError&rsquo; being returned.
</p>


<h3>Note</h3>

<p>The default behaviour of clusters created by this function is designed
to map as closely as possible to clusters created by the <span class="pkg">parallel</span>
package. However, &lsquo;...&rsquo; arguments are passed onto
<code><a href="#topic+daemons">daemons</a></code> for additional customisation if desired, although
resultant behaviour may not always be supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

cl &lt;- make_cluster(2)
cl
cl[[1L]]

Sys.sleep(0.5)
status(cl)

stop_cluster(cl)

}

</code></pre>

<hr>
<h2 id='mirai'>mirai (Evaluate Async)</h2><span id='topic+mirai'></span>

<h3>Description</h3>

<p>Evaluate an expression asynchronously in a new background R process or
persistent daemon (local or remote). This function will return
immediately with a &lsquo;mirai&rsquo;, which will resolve to the evaluated
result once complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirai(.expr, ..., .args = list(), .timeout = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirai_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or else</strong> a pre-constructed
language object.</p>
</td></tr>
<tr><td><code id="mirai_+3A_...">...</code></td>
<td>
<p>(optional) <strong>either</strong> named arguments (name = value pairs)
specifying objects referenced, but not defined, in &lsquo;.expr&rsquo;,
<strong>or</strong> an environment containing such objects. See
&lsquo;evaluation&rsquo; section below.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a named list specifying objects
referenced, but not defined, in &lsquo;.expr&rsquo;, <strong>or</strong> an
environment containing such objects. These objects will remain local to
the evaluation environment as opposed to those supplied in &lsquo;...&rsquo;
above - see &lsquo;evaluation&rsquo; section below.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.timeout">.timeout</code></td>
<td>
<p>[default NULL] for no timeout, or an integer value in
milliseconds. A mirai will resolve to an &lsquo;errorValue&rsquo; 5 (timed
out) if evaluation exceeds this limit.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return a &lsquo;mirai&rsquo; object immediately.
</p>
<p>The value of a mirai may be accessed at any time at <code>$data</code>, and
if yet to resolve, an &lsquo;unresolved&rsquo; logical NA will be returned
instead.
</p>
<p><code><a href="#topic+unresolved">unresolved</a></code> may be used on a mirai, returning TRUE if a
&lsquo;mirai&rsquo; has yet to resolve and FALSE otherwise. This is suitable
for use in control flow statements such as <code>while</code> or <code>if</code>.
</p>
<p>Alternatively, to call (and wait for) the result, use
<code><a href="#topic+call_mirai">call_mirai</a></code> on the returned &lsquo;mirai&rsquo;. This will block
until the result is returned.
</p>
<p>Specify &lsquo;.compute&rsquo; to send the mirai using a specific compute
profile (if previously created by <code><a href="#topic+daemons">daemons</a></code>), otherwise leave
as &lsquo;default&rsquo;.
</p>


<h3>Value</h3>

<p>A &lsquo;mirai&rsquo; object.
</p>


<h3>Evaluation</h3>

<p>The expression &lsquo;.expr&rsquo; will be evaluated in a separate R process
in a clean environment (not the global environment), consisting only of
the objects in the list or environment supplied to &lsquo;.args&rsquo;, with
the named objects passed as &lsquo;...&rsquo; (from the environment if one was
supplied) assigned to the global environment of that process.
</p>
<p>For evaluation to occur <em>as if</em> in your global environment, supply
objects to &lsquo;...&rsquo; rather than &lsquo;.args&rsquo;. For stricter scoping,
use &lsquo;.args&rsquo;, which limits, for example, where variables not
explicitly passed as arguments to functions are found.
</p>
<p>As evaluation occurs in a clean environment, all undefined objects must
be supplied though &lsquo;...&rsquo; and/or &lsquo;.args&rsquo;, including
self-defined functions. Functions from a package should use namespaced
calls such as <code>mirai::mirai()</code>, or else the package should be loaded
beforehand as part of &lsquo;.expr&rsquo;.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class &lsquo;miraiError&rsquo; and &lsquo;errorValue&rsquo;
(the stack trace is available at <code>$stack.trace</code> on the error
object). <code><a href="#topic+is_mirai_error">is_mirai_error</a></code> may be used to test for this.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
&lsquo;errorValue&rsquo; 19 (Connection reset) is returned (when not using
dispatcher or using dispatcher with <code>retry = FALSE</code>). Otherwise,
using dispatcher with <code>retry = TRUE</code>, the mirai will remain
unresolved and is automatically re-tried on the next daemon to connect to
the particular instance. To cancel the task instead, use
<code>saisei(force = TRUE)</code> (see <code><a href="#topic+saisei">saisei</a></code>).
</p>
<p><code><a href="#topic+is_error_value">is_error_value</a></code> tests for all error conditions including
&lsquo;mirai&rsquo; errors, interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# specifying objects via '...'
n &lt;- 3
m &lt;- mirai(x + y + 2, x = 2, y = n)
m
m$data
Sys.sleep(0.2)
m$data

# passing the calling environment to '...'
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), environment(), .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

# evaluating scripts using source() in '.expr'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file); r}, file = file, n = n)
call_mirai(m)[["data"]]
unlink(file)

# use source(local = TRUE) when passing in local variables via '.args'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file, local = TRUE); r}, .args = list(file = file, n = n))
call_mirai(m)[["data"]]
unlink(file)

# passing a language object to '.expr' and a named list to '.args'
expr &lt;- quote(a + b + 2)
args &lt;- list(a = 2, b = 3)
m &lt;- mirai(.expr = expr, .args = args)
call_mirai(m)$data

}

</code></pre>

<hr>
<h2 id='mirai_map'>mirai Map</h2><span id='topic+mirai_map'></span>

<h3>Description</h3>

<p>Asynchronous parallel / distributed map of a function over a list or vector
using <span class="pkg">mirai</span>, with optional <span class="pkg">promises</span> integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirai_map(.x, .f, ..., .args = list(), .promise = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirai_map_+3A_.x">.x</code></td>
<td>
<p>a list or atomic vector.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.f">.f</code></td>
<td>
<p>a function to be applied to each element of <code>.x</code>.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_...">...</code></td>
<td>
<p>(optional) named arguments (name = value pairs) specifying objects
referenced, but not defined, in <code>.f</code>, or an environment containing
such objects.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.args">.args</code></td>
<td>
<p>(optional) further constant arguments to <code>.f</code>, provided as
a list.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.promise">.promise</code></td>
<td>
<p>(optional) if supplied, registers a promise against each
mirai. Either a function, supplied to the &lsquo;onFulfilled&rsquo; argument
of <code>promises::then()</code> or a list of 2 functions, supplied
respectively to &lsquo;onFulfilled&rsquo; and &lsquo;onRejected&rsquo; for
<code>promises::then()</code>. Using this argument requires the
<a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sends each application of function <code>.f</code> on an element of
<code>.x</code> for computation in a separate <code><a href="#topic+mirai">mirai</a></code> call.
</p>
<p>This simple and transparent behaviour is designed to make full use of
<span class="pkg">mirai</span> scheduling to minimise overall execution time.
</p>
<p>Facilitates recovery from partial failure by returning all
&lsquo;miraiError&rsquo; / &lsquo;errorValue&rsquo; as the case may be, thus
allowing only the failures to be re-run. If using dispatcher,
&lsquo;retry&rsquo; should be specified as FALSE to ensure crashes are
returned as errors.
</p>
<p>Note: requires daemons to have previously been set. If not, then one
local daemon is set before the function propceeds.
</p>


<h3>Value</h3>

<p>A &lsquo;mirai_map&rsquo; (list of &lsquo;mirai&rsquo; objects).
</p>


<h3>Results</h3>

<p><code>x[]</code> collects the results of a mirai_map <code>x</code>. This will wait
for all asynchronous operations to complete if still in progress,
blocking but user-interruptible.
</p>
<p><code>x[.progress]</code> collects the results whilst showing a text progress
indicator.
</p>
<p><code>x[.stop]</code> collects the results applying early stopping, which stops
at the first failure and aborts all remaining in-progress operations.
</p>
<p><code>x[c(.stop, .progress)]</code> combines early stopping with a progress
indicator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(4, dispatcher = FALSE)

res &lt;- mirai_map(1:3, rnorm, .args = list(mean = 20, sd = 2))[]
res

mp &lt;- mirai_map(
  c(a = 2, b = 3, c = 4),
  function(x) do(x, as.logical(x %% 2)),
  do = nanonext::random
)
unresolved(mp)
mp
mp[]
unresolved(mp)

# progress indicator counts up to 4 seconds
res &lt;- mirai_map(1:4, Sys.sleep)[.progress]

daemons(0)

# generates warning as daemons not set
# stops early when second element returns an error
tryCatch(
  mirai_map(list(a = 1, b = "a", c = 3), sum)[.stop],
  error = identity
)

# promises example that outputs the results, including errors, to the console
if (requireNamespace("promises", quietly = TRUE)) {
daemons(1, dispatcher = FALSE)
ml &lt;- mirai_map(
  1:30,
  function(x) {Sys.sleep(0.1); if (x == 30) stop(x) else x},
  .promise = list(
    function(x) cat(paste(x, "")),
    function(x) { cat(conditionMessage(x), "\n"); daemons(0) }
  )
)
}

}

</code></pre>

<hr>
<h2 id='nextstream'>Next &gt;&gt; Developer Interface</h2><span id='topic+nextstream'></span><span id='topic+nextget'></span>

<h3>Description</h3>

<p><code>nextstream</code> retrieves the currently stored L'Ecuyer-CMRG RNG stream
for the specified compute profile and advances it to the next stream.
</p>
<p><code>nextget</code> retrieves the specified item from the specified compute
profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextstream(.compute = "default")

nextget(x, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextstream_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="nextstream_+3A_x">x</code></td>
<td>
<p>character value of item to retrieve. One of &lsquo;pid&rsquo; (dispatcher
process ID), &lsquo;urls&rsquo; (URLs dispatcher is listening at) or
&lsquo;tls&rsquo; (the stored client TLS configuration for use by daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported for use by packages extending
<span class="pkg">mirai</span> with alternative launchers of <code><a href="#topic+daemon">daemon</a></code> processes.
</p>
<p>For <code>nextstream</code>: This function should be called for its return
value when required. The function also has the side effect of
automatically advancing the stream stored within the compute profile.
This ensures that the next recursive stream is returned when the function
is called again.
</p>


<h3>Value</h3>

<p>For <code>nextstream</code>: a length 7 integer vector, as given by
<code>.Random.seed</code> when the L'Ecuyer-CMRG RNG is in use (may be passed
directly to the &lsquo;rs&rsquo; argument of <code><a href="#topic+daemon">daemon</a></code>), or else
NULL if a stream has not yet been created.
</p>
<p>For <code>nextget</code>: the requested item, or else NULL if not present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1L)
nextstream()
nextstream()

nextget("pid")
nextget("urls")

daemons(0)

}

</code></pre>

<hr>
<h2 id='register_cluster'>Register Mirai Cluster</h2><span id='topic+register_cluster'></span>

<h3>Description</h3>

<p>Registers 'miraiCluster' with the <span class="pkg">parallel</span> package as cluster type
'MIRAI' and (optionally) makes it the default cluster type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_cluster(default = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_cluster_+3A_default">default</code></td>
<td>
<p>[default TRUE] logical value whether to also register
'miraiCluster' as the default cluster type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL
</p>


<h3>Note</h3>

<p>The underlying implementation in the <span class="pkg">parallel</span> package this
function relies on iis currently only available in R-devel (4.5).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch(mirai::register_cluster(), error = identity)

</code></pre>

<hr>
<h2 id='remote_config'>Generic and SSH Remote Launch Configuration</h2><span id='topic+remote_config'></span><span id='topic+ssh_config'></span>

<h3>Description</h3>

<p><code>remote_config</code> provides a flexible generic framework for generating
the shell commands to deploy daemons remotely.
</p>
<p><code>ssh_config</code> generates a remote configuration for launching daemons over
SSH, with the option of SSH tunnelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remote_config(
  command = NULL,
  args = c("", "."),
  rscript = "Rscript",
  quote = FALSE
)

ssh_config(
  remotes,
  tunnel = FALSE,
  timeout = 10,
  command = "ssh",
  rscript = "Rscript",
  host
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remote_config_+3A_command">command</code></td>
<td>
<p>the command used to effect the daemon launch on the remote
machine as a character string (e.g. <code>'ssh'</code>). Defaults to
&lsquo;ssh&rsquo; for <code>ssh_config</code>, although may be substituted for the
full path to a specific SSH application. The default NULL for
<code>remote_config</code> does not effect any launches, but causes
<code><a href="#topic+launch_remote">launch_remote</a></code> to return the shell commands for manual
deployment on remote machines.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_args">args</code></td>
<td>
<p>(optional) arguments passed to &lsquo;command&rsquo;, as a character
vector that must include <code>"."</code> as an element, which will be
substituted for the daemon launch command. Alternatively, a list of such
character vectors to effect multiple launches (one for each list element).</p>
</td></tr>
<tr><td><code id="remote_config_+3A_rscript">rscript</code></td>
<td>
<p>(optional) name / path of the Rscript executable on the remote
machine. The default assumes &lsquo;Rscript&rsquo; is on the executable search
path. Prepend the full path if necessary. If launching on Windows,
&lsquo;Rscript&rsquo; should be replaced with &lsquo;Rscript.exe&rsquo;.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_quote">quote</code></td>
<td>
<p>[default FALSE] logical value whether or not to quote the daemon
launch command (not required for Slurm &lsquo;srun&rsquo; for example, but
required for &lsquo;ssh&rsquo;).</p>
</td></tr>
<tr><td><code id="remote_config_+3A_remotes">remotes</code></td>
<td>
<p>the character URL or vector of URLs to SSH into, using the
'ssh://' scheme and including the port open for SSH connections (defaults
to 22 if not specified), e.g. 'ssh://10.75.32.90:22' or 'ssh://nodename'.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_tunnel">tunnel</code></td>
<td>
<p>[default FALSE] logical value whether to use SSH reverse
tunnelling. If TRUE, a tunnel is created between the same ports on the
local and remote machines. See the &lsquo;SSH Tunnelling&rsquo; section below
for how to correctly specify required settings.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_timeout">timeout</code></td>
<td>
<p>[default 10] maximum time allowed for connection setup in
seconds.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_host">host</code></td>
<td>
<p>(optional) only applicable for reverse tunnelling. Should be
specified if creating a standalone configuration object. If calling this
function directly as an argument to <code><a href="#topic+daemons">daemons</a></code>, this is not
required and can be inferred from the &lsquo;url&rsquo; supplied (see
&lsquo;SSH Tunnelling&rsquo; section below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in the required format to be supplied to the &lsquo;remote&rsquo;
argument of <code><a href="#topic+launch_remote">launch_remote</a></code>, <code><a href="#topic+daemons">daemons</a></code>, or
<code><a href="#topic+make_cluster">make_cluster</a></code>.
</p>


<h3>SSH Direct Connections</h3>

<p>The simplest use of SSH is to execute the daemon launch command on a
remote machine, for it to dial back to the host / dispatcher URL.
</p>
<p>It is assumed that SSH key-based authentication is already in place. The
relevant port on the host must also be open to inbound connections from
the remote machine.
</p>


<h3>SSH Tunnelling</h3>

<p>Use of SSH tunnelling provides a convenient way to launch remote nodes
without requiring the remote machine to be able to access the host.
Often firewall configurations or security policies may prevent opening a
port to accept outside connections.
</p>
<p>In these cases SSH tunnelling offers a solution by creating a tunnel once
the initial SSH connection is made. For simplicity, this SSH tunnelling
implementation uses the same port on both the side of the host and that
of the corresponding node. SSH key-based authentication must also already
be in place.
</p>
<p>Tunnelling requires the hostname for the &lsquo;host&rsquo; argument (or the
&lsquo;url&rsquo; argument to <code><a href="#topic+daemons">daemons</a></code> if called directly in
that context) to be either &lsquo;127.0.0.1&rsquo; or &lsquo;localhost&rsquo;.
This is as the tunnel is created between <code>127.0.0.1:port</code> or
equivalently <code>localhost:port</code> on each machine. The host listens to
<code>port</code> on its machine and the remotes each dial into <code>port</code> on
their own respective machines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for Slurm
remote_config(
  command = "srun",
  args = c("--mem 512", "-n 1", "."),
  rscript = file.path(R.home("bin"), "Rscript")
)

# commands like SSH require quoting of the daemon launch command
remote_config(
  command = "/usr/bin/ssh",
  args = c("-fTp 22 10.75.32.90", "."),
  quote = TRUE
)

ssh_config(
  remotes = c("ssh://10.75.32.90:222", "ssh://nodename"),
  timeout = 5
)

ssh_config(
  remotes = c("ssh://10.75.32.90:222", "ssh://nodename"),
  tunnel = TRUE,
  host = "tls+tcp://127.0.0.1:5555"
)

## Not run: 

# launch 2 daemons on the remote machines 10.75.32.90 and 10.75.32.91 using
# SSH, connecting back directly to the host URL over a TLS connection:

daemons(
  url = host_url(tls = TRUE),
  remote = ssh_config(
    remotes = c("ssh://10.75.32.90:222", "ssh://10.75.32.91:222"),
    timeout = 1
  )
)

# launch 2 nodes on the remote machine 10.75.32.90 using SSH tunnelling over
# port 5555 ('url' hostname must be 'localhost' or '127.0.0.1'):

cl &lt;- make_cluster(
  url = "tcp://localhost:5555",
  remote = ssh_config(
    remotes = c("ssh://10.75.32.90", "ssh://10.75.32.90"),
    tunnel = TRUE,
    timeout = 1
  )
)

## End(Not run)

</code></pre>

<hr>
<h2 id='saisei'>Saisei (Regenerate Token)</h2><span id='topic+saisei'></span>

<h3>Description</h3>

<p>When using daemons with dispatcher, regenerates the token for the URL a
dispatcher socket listens at.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saisei(i, force = FALSE, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saisei_+3A_i">i</code></td>
<td>
<p>integer index number URL to regenerate at dispatcher.</p>
</td></tr>
<tr><td><code id="saisei_+3A_force">force</code></td>
<td>
<p>[default FALSE] logical value whether to regenerate the URL even
when there is an existing active connection.</p>
</td></tr>
<tr><td><code id="saisei_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a URL is regenerated, the listener at the specified socket is
closed and replaced immediately, hence this function will only be
successful if there are no existing connections at the socket (i.e.
'online' status shows 0), unless the argument &lsquo;force&rsquo; is specified
as TRUE.
</p>
<p>If &lsquo;force&rsquo; is specified as TRUE, the socket is immediately closed
and regenerated. If this happens while a mirai task is still ongoing, it
will be returned as an &lsquo;errorValue&rsquo; 7 (Object closed). This may be
used to cancel a task that consistently hangs or crashes to prevent it
from failing repeatedly when new daemons connect.
</p>


<h3>Value</h3>

<p>The regenerated character URL upon success, or else NULL.
</p>


<h3>Timeouts</h3>

<p>Specifying the '.timeout' argument to <code><a href="#topic+mirai">mirai</a></code> ensures that
the 'mirai' always resolves. However, the task may not have completed and
still be ongoing in the daemon process. In such situations, dispatcher
ensures that queued tasks are not assigned to the busy process, however
overall performance may still be degraded if they remain in use.
</p>
<p>If a process hangs and cannot be restarted otherwise, <code>saisei</code>
specifying <code>force = TRUE</code> may be used to cancel the task and
regenerate any particular URL for a new <code><a href="#topic+daemon">daemon</a></code> to connect
to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1L)
Sys.sleep(1L)
status()
saisei(i = 1L, force = TRUE)
status()

daemons(0)

}

</code></pre>

<hr>
<h2 id='serialization'>Custom Serialization Functions</h2><span id='topic+serialization'></span>

<h3>Description</h3>

<p>Registers custom serialization and unserialization functions for sending and
receiving reference objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialization(fns, class, vec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialization_+3A_fns">fns</code></td>
<td>
<p><strong>either</strong> a list comprising 2 functions: <br /> serialization
function: must accept a reference object (or list of objects) inheriting
from &lsquo;class&rsquo; and return a raw vector.<br /> unserialization function:
must accept a raw vector and return a reference object (or list of
reference objects).<br /> <strong>or else</strong> NULL to reset.</p>
</td></tr>
<tr><td><code id="serialization_+3A_class">class</code></td>
<td>
<p>the class of reference object (as a character string) that these
functions are applied to, e.g. 'ArrowTabular' or 'torch_tensor'.</p>
</td></tr>
<tr><td><code id="serialization_+3A_vec">vec</code></td>
<td>
<p>[default FALSE] if FALSE the functions must accept and return
reference objects individually e.g. <code>arrow::write_to_raw</code> and
<code>arrow::read_ipc_stream</code>. If TRUE, the functions are vectorized and
must accept and return a list of reference objects, e.g.
<code>torch::torch_serialize</code> and <code>torch::torch_load</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Registering new functions replaces any existing registered functions.
</p>
<p>This function may be called prior to or after setting daemons, with the
registered functions applying across all compute profiles.
</p>
<p>Calling without any arguments returns a list comprising the registered
values for 'fns', class', and 'vec', or else NULL if not registered.
</p>


<h3>Value</h3>

<p>Invisibly, a list comprising 'fns', class', and 'vec', or else NULL
if supplied to 'fns'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reg &lt;- serialization(
  list(function(x) serialize(x, NULL), base::unserialize),
  class = "example_class"
)
reg

serialization(NULL)
print(serialization())

</code></pre>

<hr>
<h2 id='status'>Status Information</h2><span id='topic+status'></span>

<h3>Description</h3>

<p>Retrieve status information for the specified compute profile, comprising
current connections and daemons status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(.compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character compute profile (each compute
profile has its own set of daemons for connecting to different resources).
</p>
<p><strong>or</strong> a &lsquo;miraiCluster&rsquo; to obtain its status.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list comprising:
</p>

<ul>
<li> <p><strong>connections</strong> - integer number of active connections.
<br /> Using dispatcher: Always 1L as there is a single connection to
dispatcher, which connects to the daemons in turn.
</p>
</li>
<li> <p><strong>daemons</strong> - of variable type.
<br /> Using dispatcher: a status matrix (see Status Matrix section below),
or else an integer &lsquo;errorValue&rsquo; if communication with dispatcher
failed.
<br /> Not using dispatcher: the character host URL.
<br /> Not set: 0L.
</p>
</li></ul>



<h3>Status Matrix</h3>

<p>When using dispatcher, <code>$daemons</code> comprises an integer matrix with
the following columns:
</p>

<ul>
<li> <p><strong>i</strong> - integer index number.
</p>
</li>
<li> <p><strong>online</strong> - shows as 1 when there is an active connection,
or else 0 if a daemon has yet to connect or has disconnected.
</p>
</li>
<li> <p><strong>instance</strong> - increments by 1 every time there is a new
connection at a URL. This counter is designed to track new daemon
instances connecting after previous ones have ended (due to time-outs
etc.). The count becomes negative immediately after a URL is regenerated
by <code><a href="#topic+saisei">saisei</a></code>, but increments again once a new daemon connects.
</p>
</li>
<li> <p><strong>assigned</strong> - shows the cumulative number of tasks assigned
to the daemon.
</p>
</li>
<li> <p><strong>complete</strong> - shows the cumulative number of tasks
completed by the daemon.
</p>
</li></ul>

<p>The dispatcher URLs are stored as row names to the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

status()
daemons(n = 2L, url = "wss://[::1]:0")
status()
daemons(0)

}

</code></pre>

<hr>
<h2 id='stop_mirai'>mirai (Stop)</h2><span id='topic+stop_mirai'></span>

<h3>Description</h3>

<p>Stops a &lsquo;mirai&rsquo; if still in progress, causing it to resolve
immediately to an &lsquo;errorValue&rsquo; 20 (Operation canceled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_mirai_+3A_x">x</code></td>
<td>
<p>a &lsquo;mirai&rsquo; object, or list of &lsquo;mirai&rsquo; objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forces the &lsquo;mirai&rsquo; to resolve immediately. Has no effect if
the &lsquo;mirai&rsquo; has already resolved.
</p>
<p>If cancellation was successful, the value at <code>$data</code> will be an
&lsquo;errorValue&rsquo; 20 (Operation canceled). Note that in such a case,
the &lsquo;mirai&rsquo; has been aborted and the value not retrieved - but any
ongoing evaluation in the daemon process will continue to completion and
is not interrupted.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

m &lt;- mirai(Sys.sleep(n), n = 5)
stop_mirai(m)
m$data

}

</code></pre>

<hr>
<h2 id='unresolved'>Query if a mirai is Unresolved</h2><span id='topic+unresolved'></span>

<h3>Description</h3>

<p>Query whether a &lsquo;mirai&rsquo;, &lsquo;mirai&rsquo; value or list of &lsquo;mirai&rsquo;
remains unresolved. Unlike <code><a href="#topic+call_mirai">call_mirai</a></code>, this function does
not wait for completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unresolved(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unresolved_+3A_x">x</code></td>
<td>
<p>a &lsquo;mirai&rsquo; object or list of &lsquo;mirai&rsquo; objects, or a
&lsquo;mirai&rsquo; value stored at <code>$data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable for use in control flow statements such as <code>while</code> or
<code>if</code>.
</p>
<p>Note: querying resolution may cause a previously unresolved
&lsquo;mirai&rsquo; to resolve.
</p>


<h3>Value</h3>

<p>Logical TRUE if &lsquo;aio&rsquo; is an unresolved &lsquo;mirai&rsquo; or
&lsquo;mirai&rsquo; value or the list contains at least one unresolved
&lsquo;mirai&rsquo;, or FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

m &lt;- mirai(Sys.sleep(0.1))
unresolved(m)
Sys.sleep(0.3)
unresolved(m)

}

</code></pre>

<hr>
<h2 id='with.miraiDaemons'>With Mirai Daemons</h2><span id='topic+with.miraiDaemons'></span>

<h3>Description</h3>

<p>Evaluate an expression with daemons that last for the duration of the
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miraiDaemons'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.miraiDaemons_+3A_data">data</code></td>
<td>
<p>a call to <code><a href="#topic+daemons">daemons</a></code>.</p>
</td></tr>
<tr><td><code id="with.miraiDaemons_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate.</p>
</td></tr>
<tr><td><code id="with.miraiDaemons_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>with</code> for
class 'miraiDaemons'.
</p>


<h3>Value</h3>

<p>The return value of 'expr'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

with(
  daemons(2),
  {
    m1 &lt;- mirai(Sys.getpid())
    m2 &lt;- mirai(Sys.getpid())
    cat(call_mirai(m1)$data, call_mirai(m2)$data, "\n")
  }
)

status()

}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
