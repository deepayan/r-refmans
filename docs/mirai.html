<!DOCTYPE html><html lang="en"><head><title>Help for package mirai</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mirai}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mirai-package'><p>mirai: Minimalist Async Evaluation Framework for R</p></a></li>
<li><a href='#.flat'><p>mirai Map Options</p></a></li>
<li><a href='#as.promise.mirai'><p>Make mirai Promise</p></a></li>
<li><a href='#as.promise.mirai_map'><p>Make mirai_map Promise</p></a></li>
<li><a href='#call_mirai'><p>mirai (Call Value)</p></a></li>
<li><a href='#call_mirai_'><p>Call mirai</p></a></li>
<li><a href='#collect_mirai'><p>mirai (Collect Value)</p></a></li>
<li><a href='#daemon'><p>Daemon Instance</p></a></li>
<li><a href='#daemons'><p>Daemons (Set Persistent Processes)</p></a></li>
<li><a href='#dispatcher'><p>Dispatcher</p></a></li>
<li><a href='#everywhere'><p>Evaluate Everywhere</p></a></li>
<li><a href='#host_url'><p>URL Constructors</p></a></li>
<li><a href='#is_mirai'><p>Is mirai / mirai_map</p></a></li>
<li><a href='#is_mirai_error'><p>Error Validators</p></a></li>
<li><a href='#launch_local'><p>Launch Daemon</p></a></li>
<li><a href='#make_cluster'><p>Make Mirai Cluster</p></a></li>
<li><a href='#mirai'><p>mirai (Evaluate Async)</p></a></li>
<li><a href='#mirai_map'><p>mirai Map</p></a></li>
<li><a href='#nextstream'><p>Next &gt;&gt; Developer Interface</p></a></li>
<li><a href='#remote_config'><p>Generic and SSH Remote Launch Configuration</p></a></li>
<li><a href='#serial_config'><p>Create Serialization Configuration</p></a></li>
<li><a href='#status'><p>Status Information</p></a></li>
<li><a href='#stop_mirai'><p>mirai (Stop)</p></a></li>
<li><a href='#unresolved'><p>Query if a mirai is Unresolved</p></a></li>
<li><a href='#with.miraiDaemons'><p>With Mirai Daemons</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Minimalist Async Evaluation Framework for R</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for simplicity, a 'mirai' evaluates an R expression
    asynchronously in a parallel process, locally or distributed over the
    network. The result is automatically available upon completion. Modern
    networking and concurrency, built on 'nanonext' and 'NNG' (Nanomsg Next
    Gen), ensures reliable and efficient scheduling over fast inter-process
    communications or TCP/IP secured by TLS. Distributed computing can launch
    remote resources via SSH or cluster managers. An inherently queued
    architecture handles many more tasks than available processes, and requires
    no storage on the file system. Innovative features include support for
    otherwise non-exportable reference objects, event-driven promises, and
    asynchronous parallel map.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>,
<a href="https://github.com/shikokuchuo/mirai">https://github.com/shikokuchuo/mirai</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nanonext (&ge; 1.5.2)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>parallel, promises</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cli, litedown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>litedown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-20 14:02:03 UTC; cg334</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Gao <a href="https://orcid.org/0000-0002-0750-061X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Joe Cheng [ctb],
  Hibiki AI Limited [cph],
  Posit Software, PBC [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Gao &lt;charlie.gao@shikokuchuo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-20 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mirai-package'>mirai: Minimalist Async Evaluation Framework for R</h2><span id='topic+mirai-package'></span>

<h3>Description</h3>

<p>Designed for simplicity, a 'mirai' evaluates an R expression asynchronously
in a parallel process, locally or distributed over the network. The result is
automatically available upon completion. Modern networking and concurrency,
built on 'nanonext' and 'NNG' (Nanomsg Next Gen), ensures reliable and
efficient scheduling over fast inter-process communications or TCP/IP secured
by TLS. Distributed computing can launch remote resources via SSH or cluster
managers. An inherently queued architecture handles many more tasks than
available processes, and requires no storage on the file system. Innovative
features include support for otherwise non-exportable reference objects,
event-driven promises, and asynchronous parallel map.
</p>


<h3>Notes</h3>

<p>For local mirai requests, the default transport for inter-process
communications is platform-dependent: abstract Unix domain sockets on Linux,
Unix domain sockets on MacOS, Solaris and other POSIX platforms, and named
pipes on Windows.
</p>
<p>This may be overriden, if desired, by specifying 'url' in the
<code><a href="#topic+daemons">daemons()</a></code> interface and launching daemons using
<code><a href="#topic+launch_local">launch_local()</a></code>.
</p>


<h3>Reference Manual</h3>

<p><code>vignette("mirai", package = "mirai")</code>
</p>


<h3>Author(s)</h3>

<p>Charlie Gao <a href="mailto:charlie.gao@shikokuchuo.net">charlie.gao@shikokuchuo.net</a>
(<a href="https://orcid.org/0000-0002-0750-061X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>
</p>
</li>
<li> <p><a href="https://github.com/shikokuchuo/mirai">https://github.com/shikokuchuo/mirai</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.flat'>mirai Map Options</h2><span id='topic+.flat'></span><span id='topic+.progress'></span><span id='topic+.stop'></span>

<h3>Description</h3>

<p>Expressions to be provided to the <code style="white-space: pre;">&#8288;[]&#8288;</code> method for 'mirai_map' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.flat

.progress

.stop
</code></pre>


<h3>Format</h3>

<p>An object of class <code>bytecode</code> of length 1.
</p>
<p>An object of class <code>bytecode</code> of length 1.
</p>
<p>An object of class <code>bytecode</code> of length 1.
</p>


<h3>Collection Options</h3>

<p><code>x[]</code> collects the results of a 'mirai_map' <code>x</code> and returns a list. This will
wait for all asynchronous operations to complete if still in progress,
blocking but user-interruptible.
</p>
<p><code>x[.flat]</code> collects and flattens map results to a vector, checking that
they are of the same type to avoid coercion. Note: errors if an 'errorValue'
has been returned or results are of differing type.
</p>
<p><code>x[.progress]</code> collects map results whilst showing a progress bar from
the <a href="https://CRAN.R-project.org/package=cli"><span class="pkg">cli</span></a> package, if installed, with completion percentage and ETA,
or else a simple text progress indicator. Note: if the map operation
completes too quickly then the progress bar may not show at all.
</p>
<p><code>x[.stop]</code> collects map results applying early stopping, which stops at
the first failure and cancels remaining operations. Note: operations already
in progress continue to completion, although their results are not collected.
</p>
<p>The options above may be combined in the manner of: <br />
<code>x[.stop, .progress]</code> which applies early stopping together with a
progress indicator.
</p>

<hr>
<h2 id='as.promise.mirai'>Make mirai Promise</h2><span id='topic+as.promise.mirai'></span>

<h3>Description</h3>

<p>Creates a 'promise' from a 'mirai'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mirai'
as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.promise.mirai_+3A_x">x</code></td>
<td>
<p>an object of class 'mirai'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>as.promise()</code> for class
'mirai'.
</p>
<p>Requires the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.
</p>
<p>Allows a 'mirai' to be used with the promise pipe <code style="white-space: pre;">&#8288;%...&gt;%&#8288;</code>, which schedules a
function to run upon resolution of the 'mirai'.
</p>


<h3>Value</h3>

<p>A 'promise' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(promises)

p &lt;- as.promise(mirai("example"))
print(p)
is.promise(p)

p2 &lt;- mirai("completed") %...&gt;% identity()
p2$then(cat)
is.promise(p2)

</code></pre>

<hr>
<h2 id='as.promise.mirai_map'>Make mirai_map Promise</h2><span id='topic+as.promise.mirai_map'></span>

<h3>Description</h3>

<p>Creates a 'promise' from a 'mirai_map'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mirai_map'
as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.promise.mirai_map_+3A_x">x</code></td>
<td>
<p>an object of class 'mirai_map'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>as.promise()</code> for class
'mirai_map'.
</p>
<p>Requires the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.
</p>
<p>Allows a 'mirai_map' to be used with the promise pipe <code style="white-space: pre;">&#8288;%...&gt;%&#8288;</code>, which
schedules a function to run upon resolution of the entire 'mirai_map'.
</p>
<p>The implementation internally uses <code>promises::promise_all()</code>. If all of the
promises were successful, the returned promise will resolve to a list of the
promise values; if any promise fails, the first error to be encountered will
be used to reject the returned promise.
</p>


<h3>Value</h3>

<p>A 'promise' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(promises)

with(daemons(1), {
  mp &lt;- mirai_map(1:3, function(x) { Sys.sleep(1); x })
  p &lt;- as.promise(mp)
  print(p)
  p %...&gt;% print
  mp[.flat]
})

</code></pre>

<hr>
<h2 id='call_mirai'>mirai (Call Value)</h2><span id='topic+call_mirai'></span>

<h3>Description</h3>

<p>Waits for the 'mirai' to resolve if still in progress, stores the value at
<code style="white-space: pre;">&#8288;$data&#8288;</code>, and returns the 'mirai' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call_mirai_+3A_x">x</code></td>
<td>
<p>a 'mirai' object, or list of 'mirai' objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepts a list of 'mirai' objects, such as those returned by <code><a href="#topic+mirai_map">mirai_map()</a></code>,
as well as individual 'mirai'.
</p>
<p>Waits for the asynchronous operation(s) to complete if still in progress,
blocking but user-interruptible.
</p>
<p><code>x[]</code> may also be used to wait for and return the value of a mirai <code>x</code>, and
is the equivalent of <code>call_mirai(x)$data</code>.
</p>


<h3>Value</h3>

<p>The passed object (invisibly). For a 'mirai', the retrieved value is
stored at <code style="white-space: pre;">&#8288;$data&#8288;</code>.
</p>


<h3>Alternatively</h3>

<p>The value of a 'mirai' may be accessed at any time at <code style="white-space: pre;">&#8288;$data&#8288;</code>, and if yet to
resolve, an 'unresolved' logical NA will be returned instead.
</p>
<p>Using <code><a href="#topic+unresolved">unresolved()</a></code> on a 'mirai' returns TRUE only if it has yet to resolve
and FALSE otherwise. This is suitable for use in control flow statements such
as <code>while</code> or <code>if</code>.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class 'miraiError' and 'errorValue'. <code><a href="#topic+is_mirai_error">is_mirai_error()</a></code>
may be used to test for this. The elements of the original condition are
accessible via <code>$</code> on the error object. A stack trace comprising a list of
calls is also available at <code style="white-space: pre;">&#8288;$stack.trace&#8288;</code>.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
'errorValue' 19 (Connection reset) is returned.
</p>
<p><code><a href="#topic+is_error_value">is_error_value()</a></code> tests for all error conditions including 'mirai' errors,
interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using call_mirai()
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), df1 = df1, df2 = df2, .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

</code></pre>

<hr>
<h2 id='call_mirai_'>Call mirai</h2><span id='topic+call_mirai_'></span>

<h3>Description</h3>

<p><code>call_mirai_</code> is deprecated and exported for historical compatibility only.
It will be removed in a future package version. Use <code><a href="#topic+call_mirai">call_mirai()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_mirai_(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call_mirai__+3A_x">x</code></td>
<td>
<p>a 'mirai' object, or list of 'mirai' objects.</p>
</td></tr>
</table>

<hr>
<h2 id='collect_mirai'>mirai (Collect Value)</h2><span id='topic+collect_mirai'></span>

<h3>Description</h3>

<p>Waits for the 'mirai' to resolve if still in progress, and returns its value
directly. It is a more efficient version of and equivalent to
<code>call_mirai(x)$data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_mirai(x, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_mirai_+3A_x">x</code></td>
<td>
<p>a 'mirai' object, or list of 'mirai' objects.</p>
</td></tr>
<tr><td><code id="collect_mirai_+3A_options">options</code></td>
<td>
<p>(if <code>x</code> is a list of mirai) a character vector comprising any
combination of collection options for <code><a href="#topic+mirai_map">mirai_map()</a></code>, such as <code>".flat"</code> or
<code>c(".progress", ".stop")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will wait for the asynchronous operation(s) to complete if
still in progress, blocking but interruptible.
</p>
<p><code>x[]</code> is an equivalent way to wait for and return the value of a mirai <code>x</code>.
</p>


<h3>Value</h3>

<p>An object (the return value of the 'mirai'), or a list of such
objects (the same length as <code>x</code>, preserving names).
</p>


<h3>Alternatively</h3>

<p>The value of a 'mirai' may be accessed at any time at <code style="white-space: pre;">&#8288;$data&#8288;</code>, and if yet to
resolve, an 'unresolved' logical NA will be returned instead.
</p>
<p>Using <code><a href="#topic+unresolved">unresolved()</a></code> on a 'mirai' returns TRUE only if it has yet to resolve
and FALSE otherwise. This is suitable for use in control flow statements such
as <code>while</code> or <code>if</code>.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class 'miraiError' and 'errorValue'. <code><a href="#topic+is_mirai_error">is_mirai_error()</a></code>
may be used to test for this. The elements of the original condition are
accessible via <code>$</code> on the error object. A stack trace comprising a list of
calls is also available at <code style="white-space: pre;">&#8288;$stack.trace&#8288;</code>.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
'errorValue' 19 (Connection reset) is returned.
</p>
<p><code><a href="#topic+is_error_value">is_error_value()</a></code> tests for all error conditions including 'mirai' errors,
interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using collect_mirai()
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), df1 = df1, df2 = df2, .timeout = 1000)
collect_mirai(m)

# using x[]
m[]

# mirai_map with collection options
daemons(1, dispatcher = FALSE)
m &lt;- mirai_map(1:3, rnorm)
collect_mirai(m, c(".flat", ".progress"))
daemons(0)

</code></pre>

<hr>
<h2 id='daemon'>Daemon Instance</h2><span id='topic+daemon'></span>

<h3>Description</h3>

<p>Starts up an execution daemon to receive <code><a href="#topic+mirai">mirai()</a></code> requests. Awaits data,
evaluates an expression in an environment containing the supplied data,
and returns the value to the host caller. Daemon settings may be controlled
by <code><a href="#topic+daemons">daemons()</a></code> and this function should not need to be invoked directly,
unless deploying manually on remote resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemon(
  url,
  dispatcher = FALSE,
  ...,
  asyncdial = FALSE,
  autoexit = TRUE,
  cleanup = TRUE,
  output = FALSE,
  idletime = Inf,
  walltime = Inf,
  maxtasks = Inf,
  id = NULL,
  tls = NULL,
  rs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daemon_+3A_url">url</code></td>
<td>
<p>the character host or dispatcher URL to dial into, including the
port to connect to, e.g. 'tcp://hostname:5555' or
'tls+tcp://10.75.32.70:5555'.</p>
</td></tr>
<tr><td><code id="daemon_+3A_dispatcher">dispatcher</code></td>
<td>
<p>[default FALSE] logical value, which should be set to
TRUE if using dispatcher and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="daemon_+3A_...">...</code></td>
<td>
<p>reserved but not currently used.</p>
</td></tr>
<tr><td><code id="daemon_+3A_asyncdial">asyncdial</code></td>
<td>
<p>[default FALSE] whether to perform dials asynchronously.
The default FALSE will error if a connection is not immediately possible
(for instance if <code><a href="#topic+daemons">daemons()</a></code> has yet to be called on the host, or the
specified port is not open etc.). Specifying TRUE continues retrying
(indefinitely) if not immediately successful, which is more resilient but
can mask potential connection issues.</p>
</td></tr>
<tr><td><code id="daemon_+3A_autoexit">autoexit</code></td>
<td>
<p>[default TRUE] logical value, whether the daemon should
exit automatically when its socket connection ends. If a signal from the
<span class="pkg">tools</span> package, such as <code>tools::SIGINT</code>, or an equivalent integer
value is supplied, this signal is additionally raised on exit (see
'Persistence' section below).</p>
</td></tr>
<tr><td><code id="daemon_+3A_cleanup">cleanup</code></td>
<td>
<p>[default TRUE] logical value, whether to perform cleanup of
the global environment and restore attached packages and options to an
initial state after each evaluation.</p>
</td></tr>
<tr><td><code id="daemon_+3A_output">output</code></td>
<td>
<p>[default FALSE] logical value, to output generated stdout /
stderr if TRUE, or else discard if FALSE. Specify as TRUE in the <code>...</code>
argument to <code><a href="#topic+daemons">daemons()</a></code> or <code><a href="#topic+launch_local">launch_local()</a></code> to provide redirection of
output to the host process (applicable only for local daemons).</p>
</td></tr>
<tr><td><code id="daemon_+3A_idletime">idletime</code></td>
<td>
<p>[default Inf] integer milliseconds maximum time to wait for
a task (idle time) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_walltime">walltime</code></td>
<td>
<p>[default Inf] integer milliseconds soft walltime (time
limit) i.e. the minimum amount of real time elapsed before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_maxtasks">maxtasks</code></td>
<td>
<p>[default Inf] integer maximum number of tasks to execute
(task limit) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_id">id</code></td>
<td>
<p>[default NULL] (optional) integer daemon ID provided to
dispatcher to track connection status. Causes <code><a href="#topic+status">status()</a></code> to report this ID
under <code style="white-space: pre;">&#8288;$events&#8288;</code> when the daemon connects and disconnects.</p>
</td></tr>
<tr><td><code id="daemon_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over
'tls+tcp://'. <strong>Either</strong> the character path to a file containing X.509
certificate(s) in PEM format, comprising the certificate authority
certificate chain starting with the TLS certificate and ending with the CA
certificate, <strong>or</strong> a length 2 character vector comprising [i] the
certificate authority certificate chain and [ii] the empty string <code>""</code>.</p>
</td></tr>
<tr><td><code id="daemon_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host process
and should not be independently supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that daemons dial into the host or dispatcher,
which listens at the <code>url</code> address. In this way, network resources may be
added or removed dynamically and the host or dispatcher automatically
distributes tasks to all available daemons.
</p>


<h3>Value</h3>

<p>Invisibly, an integer exit code: 0L for normal termination, and a
positive value if a self-imposed limit was reached: 1L (idletime), 2L
(walltime), 3L (maxtasks).
</p>


<h3>Persistence</h3>

<p>The <code>autoexit</code> argument governs persistence settings for the daemon. The
default TRUE ensures that it will exit cleanly once its socket connection
has ended.
</p>
<p>Instead of TRUE, supplying a signal from the <span class="pkg">tools</span> package, such as
<code>tools::SIGINT</code>, or an equivalent integer value, sets this signal to be
raised when the socket connection ends. For instance, supplying SIGINT allows
a potentially more immediate exit by interrupting any ongoing evaluation
rather than letting it complete.
</p>
<p>Setting to FALSE allows the daemon to persist indefinitely even when there is
no longer a socket connection. This allows a host session to end and a new
session to connect at the URL where the daemon is dialled in. Daemons must be
terminated with <code>daemons(NULL)</code> in this case, which sends explicit exit
signals to all connected daemons.
</p>

<hr>
<h2 id='daemons'>Daemons (Set Persistent Processes)</h2><span id='topic+daemons'></span>

<h3>Description</h3>

<p>Set daemons, or persistent background processes, to receive <code><a href="#topic+mirai">mirai()</a></code>
requests. Specify <code>n</code> to create daemons on the local machine. Specify <code>url</code>
to receive connections from remote daemons (for distributed computing across
the network). Specify <code>remote</code> to optionally launch remote daemons via a
remote configuration. Dispatcher (enabled by default) ensures optimal
scheduling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemons(
  n,
  url = NULL,
  remote = NULL,
  dispatcher = TRUE,
  ...,
  seed = NULL,
  serial = NULL,
  tls = NULL,
  pass = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daemons_+3A_n">n</code></td>
<td>
<p>integer number of daemons to launch.</p>
</td></tr>
<tr><td><code id="daemons_+3A_url">url</code></td>
<td>
<p>[default NULL] if specified, a character string comprising a URL
at which to listen for remote daemons, including a port accepting incoming
connections, e.g. 'tcp://hostname:5555' or 'tcp://10.75.32.70:5555'.
Specify a URL with scheme 'tls+tcp://' to use secure TLS connections (for
details see Distributed Computing section below). Auxiliary function
<code><a href="#topic+host_url">host_url()</a></code> may be used to construct a valid host URL.</p>
</td></tr>
<tr><td><code id="daemons_+3A_remote">remote</code></td>
<td>
<p>[default NULL] required only for launching remote daemons, a
configuration generated by <code><a href="#topic+remote_config">remote_config()</a></code> or <code><a href="#topic+ssh_config">ssh_config()</a></code>.</p>
</td></tr>
<tr><td><code id="daemons_+3A_dispatcher">dispatcher</code></td>
<td>
<p>[default TRUE] logical value, whether to use dispatcher.
Dispatcher runs in a separate process to ensure optimal scheduling,
although this may not always be required (for details see Dispatcher
section below).</p>
</td></tr>
<tr><td><code id="daemons_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to
<code><a href="#topic+daemon">daemon()</a></code> if launching daemons. These include <code>asyncdial</code>, <code>autoexit</code>,
<code>cleanup</code>, <code>output</code>, <code>maxtasks</code>, <code>idletime</code> and <code>walltime</code>.</p>
</td></tr>
<tr><td><code id="daemons_+3A_seed">seed</code></td>
<td>
<p>[default NULL] (optional) supply a random seed (single value,
interpreted as an integer). This is used to inititalise the L'Ecuyer-CMRG
RNG streams sent to each daemon. Note that reproducible results can be
expected only for <code>dispatcher = FALSE</code>, as the unpredictable timing of task
completions would otherwise influence the tasks sent to each daemon. Even
for <code>dispatcher = FALSE</code>, reproducibility is not guaranteed if the order in
which tasks are sent is not deterministic.</p>
</td></tr>
<tr><td><code id="daemons_+3A_serial">serial</code></td>
<td>
<p>[default NULL] (optional, requires dispatcher) a
configuration created by <code><a href="#topic+serial_config">serial_config()</a></code> to register serialization and
unserialization functions for normally non-exportable reference objects,
such as Arrow Tables or torch tensors.</p>
</td></tr>
<tr><td><code id="daemons_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (optional for secure TLS connections) if not
supplied, zero-configuration single-use keys and certificates are
automatically generated. If supplied, <strong>either</strong> the character path to
a file containing the PEM-encoded TLS certificate and associated private
key (may contain additional certificates leading to a validation chain,
with the TLS certificate first), <strong>or</strong> a length 2 character vector
comprising [i] the TLS certificate (optionally certificate chain) and
[ii] the associated private key.</p>
</td></tr>
<tr><td><code id="daemons_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to
<code>tls</code> is encrypted with a password) For security, should be provided
through a function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="daemons_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>daemons(0)</code> to reset daemon connections:
</p>

<ul>
<li><p> All connected daemons and/or dispatchers exit automatically.
</p>
</li>
<li> <p><span class="pkg">mirai</span> reverts to the default behaviour of creating a new
background process for each request.
</p>
</li>
<li><p> Any unresolved 'mirai' will return an 'errorValue' 19 (Connection
reset) after a reset.
</p>
</li>
<li><p> Daemons must be reset before calling <code>daemons()</code> with revised
settings for a compute profile. Daemons may be added at any time by using
<code><a href="#topic+launch_local">launch_local()</a></code> or <code><a href="#topic+launch_remote">launch_remote()</a></code> without needing to revise daemons
settings.
</p>
</li></ul>

<p>If the host session ends, all connected dispatcher and daemon processes
automatically exit as soon as their connections are dropped (unless the
daemons were started with <code>autoexit = FALSE</code>). If a daemon is processing
a task, it will exit as soon as the task is complete.
</p>
<p>To reset persistent daemons started with <code>autoexit = FALSE</code>, use
<code>daemons(NULL)</code> instead, which also sends exit signals to all connected
daemons prior to resetting.
</p>
<p>For historical reasons, <code>daemons()</code> with no arguments (other than
optionally <code>.compute</code>) returns the value of <code><a href="#topic+status">status()</a></code>.
</p>


<h3>Value</h3>

<p>The integer number of daemons launched locally (zero if specifying
<code>url</code> or using a remote launcher).
</p>


<h3>Local Daemons</h3>

<p>Daemons provide a potentially more efficient solution for asynchronous
operations as new processes no longer need to be created on an <em>ad hoc</em>
basis.
</p>
<p>Supply the argument <code>n</code> to set the number of daemons. New background
<code><a href="#topic+daemon">daemon()</a></code> processes are automatically created on the local machine
connecting back to the host process, either directly or via dispatcher.
</p>


<h3>Dispatcher</h3>

<p>By default <code>dispatcher = TRUE</code> launches a background process running
<code><a href="#topic+dispatcher">dispatcher()</a></code>. Dispatcher connects to daemons on behalf of the host, queues
tasks, and ensures optimal scheduling.
</p>
<p>Specifying <code>dispatcher = FALSE</code>, daemons connect directly to the host and
tasks are distributed in a round-robin fashion. As tasks are queued at each
daemon, optimal scheduling is not guaranteed as the duration of each task
cannot be known <em>a priori</em>. Tasks can be queued at one daemon while others
remain idle. However, this provides the most resource-light approach, suited
to working with similar-length tasks, or where concurrent tasks typically do
not exceed available daemons.
</p>


<h3>Distributed Computing</h3>

<p>Specifying <code>url</code> as a character string allows tasks to be distributed across
the network. <code>n</code> is only required in this case if providing a launch
configuration to <code>remote</code> to launch remote daemons.
</p>
<p>Supply a URL with a 'tcp://' scheme, such as 'tcp://10.75.32.70:5555'. The
host / dispatcher listens at this address, utilising a single port.
Individual daemons (started with <code><a href="#topic+daemon">daemon()</a></code>) may then dial in to this URL.
Host / dispatcher automatically adjusts to the number of daemons actually
connected, allowing dynamic upscaling or downscaling as required.
</p>
<p>Switching the URL scheme to 'tls+tcp://' automatically upgrades the
connection to use TLS. The auxiliary function <code><a href="#topic+host_url">host_url()</a></code> may be used to
construct a valid host URL based on the computer's hostname.
</p>
<p>IPv6 addresses are also supported and must be enclosed in square brackets
<code style="white-space: pre;">&#8288;[]&#8288;</code> to avoid confusion with the final colon separating the port. For
example, port 5555 on the IPv6 loopback address ::1 would be specified as
'tcp://[::1]:5555'.
</p>
<p>Specifying the wildcard value zero for the port number e.g. 'tcp://[::1]:0'
will automatically assign a free ephemeral port. Use <code><a href="#topic+status">status()</a></code> to inspect
the actual assigned port at any time.
</p>
<p>Specify <code>remote</code> with a call to <code><a href="#topic+remote_config">remote_config()</a></code> or <code><a href="#topic+ssh_config">ssh_config()</a></code> to launch
daemons on remote machines. Otherwise, <code><a href="#topic+launch_remote">launch_remote()</a></code> may be used to
generate the shell commands to deploy daemons manually on remote resources.
</p>


<h3>Compute Profiles</h3>

<p>By default, the <code>"default"</code> compute profile is used. Providing a character
value for <code>.compute</code> creates a new compute profile with the name specified.
Each compute profile retains its own daemons settings, and may be operated
independently of each other. Some usage examples follow:
</p>
<p><strong>local / remote</strong> daemons may be set with a host URL and specifying
<code>.compute</code> as <code>"remote"</code>, which creates a new compute profile. Subsequent
<code><a href="#topic+mirai">mirai()</a></code> calls may then be sent for local computation by not specifying the
<code>.compute</code> argument, or for remote computation to connected daemons by
specifying the <code>.compute</code> argument as <code>"remote"</code>.
</p>
<p><strong>cpu / gpu</strong> some tasks may require access to different types of daemon,
such as those with GPUs. In this case, <code>daemons()</code> may be called to set up
host URLs for CPU-only daemons and for those with GPUs, specifying the
<code>.compute</code> argument as <code>"cpu"</code> and <code>"gpu"</code> respectively. By supplying the
<code>.compute</code> argument to subsequent <code><a href="#topic+mirai">mirai()</a></code> calls, tasks may be sent to
either <code>cpu</code> or <code>gpu</code> daemons as appropriate.
</p>
<p>Note: further actions such as resetting daemons via <code>daemons(0)</code> should
be carried out with the desired <code>.compute</code> argument specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 2 local daemons (using dispatcher)
daemons(2)
status()
# Reset to zero
daemons(0)

# Create 2 local daemons (not using dispatcher)
daemons(2, dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

# Set up dispatcher accepting TLS over TCP connections
daemons(url = host_url(tls = TRUE))
status()
# Reset to zero
daemons(0)

# Set host URL for remote daemons to dial into
daemons(url = host_url(), dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

# Use with() to evaluate with daemons for the duration of the expression
with(
  daemons(2),
  {
    m1 &lt;- mirai(Sys.getpid())
    m2 &lt;- mirai(Sys.getpid())
    cat(m1[], m2[], "\n")
  }
)

## Not run: 

# Launch daemons on remotes 'nodeone' and 'nodetwo' using SSH
# connecting back directly to the host URL over a TLS connection:
daemons(
  url = host_url(tls = TRUE),
  remote = ssh_config(c('ssh://nodeone', 'ssh://nodetwo'))
)

# Launch 4 daemons on the remote machine 10.75.32.90 using SSH tunnelling:
daemons(
  n = 4,
  url = local_url(tcp = TRUE),
  remote = ssh_config('ssh://10.75.32.90', tunnel = TRUE)
)


## End(Not run)

</code></pre>

<hr>
<h2 id='dispatcher'>Dispatcher</h2><span id='topic+dispatcher'></span>

<h3>Description</h3>

<p>Dispatches tasks from a host to daemons for processing, using FIFO
scheduling, queuing tasks as required. Daemon / dispatcher settings may be
controlled by <code><a href="#topic+daemons">daemons()</a></code> and this function should not need to be invoked
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatcher(host, url = NULL, n = NULL, ..., tls = NULL, pass = NULL, rs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dispatcher_+3A_host">host</code></td>
<td>
<p>the character host URL to dial (where tasks are sent from),
including the port to connect to e.g. 'tcp://hostname:5555' or
'tcp://10.75.32.70:5555'.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_url">url</code></td>
<td>
<p>(optional) the character URL dispatcher should listen at (and
daemons should dial in to), including the port to connect to e.g.
'tcp://hostname:5555' or 'tcp://10.75.32.70:5555'. Specify 'tls+tcp://' to
use secure TLS connections.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_n">n</code></td>
<td>
<p>(optional) if specified, the integer number of daemons to launch. In
this case, a local url is automatically generated.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to <code><a href="#topic+daemon">daemon()</a></code>.
These include <code>asyncdial</code>, <code>autoexit</code>, and <code>cleanup</code>.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (required for secure TLS connections) <strong>either</strong>
the character path to a file containing the PEM-encoded TLS certificate and
associated private key (may contain additional certificates leading to a
validation chain, with the TLS certificate first), <strong>or</strong> a length 2
character vector comprising [i] the TLS certificate (optionally
certificate chain) and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to
<code>tls</code> is encrypted with a password) For security, should be provided
through a function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host process
and should not be independently supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that a dispatcher acts as a gateway between the
host and daemons, ensuring that tasks received from the host are dispatched
on a FIFO basis for processing. Tasks are queued at the dispatcher to ensure
tasks are only sent to daemons that can begin immediate execution of the
task.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>

<hr>
<h2 id='everywhere'>Evaluate Everywhere</h2><span id='topic+everywhere'></span>

<h3>Description</h3>

<p>Evaluate an expression 'everywhere' on all connected daemons for the
specified compute profile - this must be set prior to calling this function.
Designed for performing setup operations across daemons by loading packages
or exporting common data. Resultant changes to the global environment, loaded
packages and options are persisted regardless of a daemon's <code>cleanup</code>
setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>everywhere(.expr, ..., .args = list(), .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="everywhere_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or else</strong> a pre-constructed language
object.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_...">...</code></td>
<td>
<p>(optional) <strong>either</strong> named arguments (name = value pairs)
specifying objects referenced, but not defined, in <code>.expr</code>, <strong>or</strong> an
environment containing such objects. See 'evaluation' section below.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a named list specifying objects
referenced, but not defined, in <code>.expr</code>, <strong>or</strong> an environment containing
such objects. These objects will remain local to the evaluation environment
as opposed to those supplied in <code>...</code> above - see 'evaluation' section
below.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be called when no other mirai operations are in
progress. If necessary, wait for all mirai operations to complete. This is as
this function does not force a synchronization point, and using concurrently
with other mirai operations does not guarantee the timing of when the
instructions will be received, or that they will be received on each daemon.
</p>


<h3>Value</h3>

<p>A list of mirai executed on each daemon. This may be waited for and
inspected using <code><a href="#topic+call_mirai">call_mirai()</a></code> or <code><a href="#topic+collect_mirai">collect_mirai()</a></code>.
</p>


<h3>Evaluation</h3>

<p>The expression <code>.expr</code> will be evaluated in a separate R process in a clean
environment (not the global environment), consisting only of the objects
supplied to <code>.args</code>, with the objects passed as <code>...</code> assigned to the global
environment of that process.
</p>
<p>As evaluation occurs in a clean environment, all undefined objects must be
supplied through <code>...</code> and/or <code>.args</code>, including self-defined functions.
Functions from a package should use namespaced calls such as
<code>mirai::mirai()</code>, or else the package should be loaded beforehand as part of
<code>.expr</code>.
</p>
<p>For evaluation to occur <em>as if</em> in your global environment, supply objects to
<code>...</code> rather than <code>.args</code>, e.g. for free variables or helper functions
defined in function bodies, as scoping rules may otherwise prevent them from
being found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daemons(1)
# export common data by a super-assignment expression:
everywhere(y &lt;&lt;- 3)
# '...' variables are assigned to the global environment
# '.expr' may be specified as an empty {} in such cases:
everywhere({}, a = 1, b = 2)
m &lt;- mirai(a + b - y == 0L)
m[]
# everywhere() returns a list of mirai which may be waited for and inspected
mlist &lt;- everywhere("just a normal operation")
collect_mirai(mlist)
mlist &lt;- everywhere(stop("error"))
collect_mirai(mlist)
daemons(0)

# loading a package on all daemons
daemons(1, dispatcher = FALSE)
everywhere(library(parallel))
m &lt;- mirai("package:parallel" %in% search())
m[]
daemons(0)

</code></pre>

<hr>
<h2 id='host_url'>URL Constructors</h2><span id='topic+host_url'></span><span id='topic+local_url'></span>

<h3>Description</h3>

<p><code>host_url</code> constructs a valid host URL (at which daemons may connect)
based on the computer's hostname. This may be supplied directly to the <code>url</code>
argument of <code><a href="#topic+daemons">daemons()</a></code>.
</p>
<p><code>local_url</code> constructs a URL suitable for local daemons, or for use with
SSH tunnelling. This may be supplied directly to the <code>url</code> argument of
<code><a href="#topic+daemons">daemons()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>host_url(tls = FALSE, port = 0)

local_url(tcp = FALSE, port = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="host_url_+3A_tls">tls</code></td>
<td>
<p>[default FALSE] logical value whether to use TLS in which case
the scheme used will be 'tls+tcp://'.</p>
</td></tr>
<tr><td><code id="host_url_+3A_port">port</code></td>
<td>
<p>[default 0] numeric port to use. <code>0</code> is a wildcard value that
automatically assigns a free ephemeral port. For <code>host_url</code>, this port
should be open to connections from the network addresses the daemons are
connecting from. For <code>local_url</code>, is only taken into account if
<code>tcp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="host_url_+3A_tcp">tcp</code></td>
<td>
<p>[default FALSE] logical value whether to use a TCP connection.
This must be used for SSH tunnelling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>host_url</code> relies on using the host name of the computer rather than an IP
address and typically works on local networks, although this is not always
guaranteed. If unsuccessful, substitute an IPv4 or IPv6 address in place of
the hostname.
</p>
<p><code>local_url</code> generates a random URL for the platform's default inter-process
communications transport: abstract Unix domain sockets on Linux, Unix domain
sockets on MacOS, Solaris and other POSIX platforms, and named pipes on
Windows.
</p>


<h3>Value</h3>

<p>A character string comprising a valid URL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>host_url()
host_url(tls = TRUE)
host_url(tls = TRUE, port = 5555)

local_url()
local_url(tcp = TRUE)
local_url(tcp = TRUE, port = 5555)

</code></pre>

<hr>
<h2 id='is_mirai'>Is mirai / mirai_map</h2><span id='topic+is_mirai'></span><span id='topic+is_mirai_map'></span>

<h3>Description</h3>

<p>Is the object a 'mirai' or 'mirai_map'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai(x)

is_mirai_map(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_mirai_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE if <code>x</code> is of class 'mirai' or 'mirai_map' respectively,
FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daemons(1, dispatcher = FALSE)
df &lt;- data.frame()
m &lt;- mirai(as.matrix(df), df = df)
is_mirai(m)
is_mirai(df)

mp &lt;- mirai_map(1:3, runif)
is_mirai_map(mp)
is_mirai_map(mp[])
daemons(0)

</code></pre>

<hr>
<h2 id='is_mirai_error'>Error Validators</h2><span id='topic+is_mirai_error'></span><span id='topic+is_mirai_interrupt'></span><span id='topic+is_error_value'></span>

<h3>Description</h3>

<p>Validator functions for error value types created by <span class="pkg">mirai</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai_error(x)

is_mirai_interrupt(x)

is_error_value(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_mirai_error_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the object a 'miraiError'. When execution in a 'mirai' process fails, the
error message is returned as a character string of class 'miraiError' and
'errorValue'. The elements of the original condition are accessible via <code>$</code>
on the error object. A stack trace is also available at <code style="white-space: pre;">&#8288;$stack.trace&#8288;</code>.
</p>
<p>Is the object a 'miraiInterrupt'. When an ongoing 'mirai' is sent a user
interrupt, it will resolve to an empty character string classed as
'miraiInterrupt' and 'errorValue'.
</p>
<p>Is the object an 'errorValue', such as a 'mirai' timeout, a 'miraiError' or a
'miraiInterrupt'. This is a catch-all condition that includes all returned
error values.
</p>


<h3>Value</h3>

<p>Logical value TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- mirai(stop())
call_mirai(m)
is_mirai_error(m$data)
is_mirai_interrupt(m$data)
is_error_value(m$data)
m$data$stack.trace

m2 &lt;- mirai(Sys.sleep(1L), .timeout = 100)
call_mirai(m2)
is_mirai_error(m2$data)
is_mirai_interrupt(m2$data)
is_error_value(m2$data)

</code></pre>

<hr>
<h2 id='launch_local'>Launch Daemon</h2><span id='topic+launch_local'></span><span id='topic+launch_remote'></span>

<h3>Description</h3>

<p><code>launch_local</code> spawns a new background <code>Rscript</code> process calling <code><a href="#topic+daemon">daemon()</a></code>
with the specified arguments.
</p>
<p><code>launch_remote</code> returns the shell command for deploying daemons as a
character vector. If a configuration generated by <code><a href="#topic+remote_config">remote_config()</a></code> or
<code><a href="#topic+ssh_config">ssh_config()</a></code> is supplied then this is used to launch the daemon on the
remote machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_local(n = 1L, ..., tls = NULL, .compute = "default")

launch_remote(
  n = 1L,
  remote = remote_config(),
  ...,
  tls = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="launch_local_+3A_n">n</code></td>
<td>
<p>integer number of daemons.
</p>
<p><strong>or</strong> for <code>launch_remote</code> only, a 'miraiCluster' or 'miraiNode'.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_...">...</code></td>
<td>
<p>(optional) arguments passed through to <code><a href="#topic+daemon">daemon()</a></code>. These include
<code>autoexit</code>, <code>cleanup</code>, <code>output</code>, <code>maxtasks</code>, <code>idletime</code> and <code>walltime</code>.
Only supply to override arguments originally provided to <code><a href="#topic+daemons">daemons()</a></code>,
otherwise those will be used instead.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over
'tls+tcp://'. Zero-configuration TLS certificates generated by <code><a href="#topic+daemons">daemons()</a></code>
are automatically passed to the daemon, without requiring to be specified
here. Otherwise, supply <strong>either</strong> the character path to a file containing
X.509 certificate(s) in PEM format, comprising the certificate authority
certificate chain, <strong>or</strong> a length 2 character vector comprising [i] the
certificate authority certificate chain and [ii] the empty string <code>""</code>.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="launch_local_+3A_remote">remote</code></td>
<td>
<p>required only for launching remote daemons, a configuration
generated by <code><a href="#topic+remote_config">remote_config()</a></code> or <code><a href="#topic+ssh_config">ssh_config()</a></code>. An empty
<code><a href="#topic+remote_config">remote_config()</a></code> does not effect any daemon launches but returns the shell
commands for deploying manually on remote machines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions may be used to re-launch daemons that have exited after
reaching time or task limits.
</p>
<p>Daemons must already be set for launchers to work.
</p>
<p>The generated command contains the argument <code>rs</code> specifying the length 7
L'Ecuyer-CMRG random seed supplied to the daemon. The values will be
different each time the function is called.
</p>


<h3>Value</h3>

<p>For <strong>launch_local</strong>: Integer number of daemons launched.
</p>
<p>For <strong>launch_remote</strong>: A character vector of daemon launch commands,
classed as 'miraiLaunchCmd'. The printed output may be copy / pasted
directly to the remote machine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daemons(url = host_url(), dispatcher = FALSE)
status()
launch_local(1L, cleanup = FALSE)
launch_remote(1L, cleanup = FALSE)
Sys.sleep(1)
status()
daemons(0)

daemons(url = host_url(tls = TRUE))
status()
launch_local(2L, output = TRUE)
Sys.sleep(1)
status()
daemons(0)

</code></pre>

<hr>
<h2 id='make_cluster'>Make Mirai Cluster</h2><span id='topic+make_cluster'></span><span id='topic+stop_cluster'></span>

<h3>Description</h3>

<p><code>make_cluster</code> creates a cluster of type 'miraiCluster', which may be used as
a cluster object for any function in the <span class="pkg">parallel</span> base package such as
<code><a href="parallel.html#topic+clusterApply">parallel::clusterApply()</a></code> or <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>
<p><code>stop_cluster</code> stops a cluster created by <code>make_cluster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cluster(n, url = NULL, remote = NULL, ...)

stop_cluster(cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_cluster_+3A_n">n</code></td>
<td>
<p>integer number of nodes (automatically launched on the local machine
unless <code>url</code> is supplied).</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_url">url</code></td>
<td>
<p>[default NULL] (specify for remote nodes) the character URL on
the host for remote nodes to dial into, including a port accepting incoming
connections, e.g. 'tcp://10.75.37.40:5555'. Specify a URL with the scheme
'tls+tcp://' to use secure TLS connections.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_remote">remote</code></td>
<td>
<p>[default NULL] (specify to launch remote nodes) a remote
launch configuration generated by <code><a href="#topic+remote_config">remote_config()</a></code> or <code><a href="#topic+ssh_config">ssh_config()</a></code>. If
not supplied, nodes may be deployed manually on remote resources.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_...">...</code></td>
<td>
<p>additional arguments passed onto <code><a href="#topic+daemons">daemons()</a></code>.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_cl">cl</code></td>
<td>
<p>a 'miraiCluster'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R version 4.5 or newer, <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> specifying
<code>type = "MIRAI"</code> is equivalent to this function.
</p>


<h3>Value</h3>

<p>For <strong>make_cluster</strong>: An object of class 'miraiCluster' and
'cluster'. Each 'miraiCluster' has an automatically assigned ID and <code>n</code>
nodes of class 'miraiNode'. If <code>url</code> is supplied but not <code>remote</code>, the
shell commands for deployment of nodes on remote resources are printed to
the console.
</p>
<p>For <strong>stop_cluster</strong>: invisible NULL.
</p>


<h3>Remote Nodes</h3>

<p>Specify <code>url</code> and <code>n</code> to set up a host connection for remote nodes to dial
into. <code>n</code> defaults to one if not specified.
</p>
<p>Also specify <code>remote</code> to launch the nodes using a configuration generated by
<code><a href="#topic+remote_config">remote_config()</a></code> or <code><a href="#topic+ssh_config">ssh_config()</a></code>. In this case, the number of nodes is
inferred from the configuration provided and <code>n</code> is disregarded.
</p>
<p>If <code>remote</code> is not supplied, the shell commands for deploying nodes manually
on remote resources are automatically printed to the console.
</p>
<p><code><a href="#topic+launch_remote">launch_remote()</a></code> may be called at any time on a 'miraiCluster' to return the
shell commands for deployment of all nodes, or on a 'miraiNode' to return the
command for a single node.
</p>


<h3>Status</h3>

<p>Call <code><a href="#topic+status">status()</a></code> on a 'miraiCluster' to check the number of currently active
connections as well as the host URL.
</p>


<h3>Errors</h3>

<p>Errors are thrown by the <span class="pkg">parallel</span> package mechanism if one or more
nodes failed (quit unexpectedly). The resulting 'errorValue' returned is 19
(Connection reset). Other types of error, e.g. in evaluation, result in the
usual 'miraiError' being returned.
</p>


<h3>Note</h3>

<p>The default behaviour of clusters created by this function is designed
to map as closely as possible to clusters created by the <span class="pkg">parallel</span>
package. However, <code>...</code> arguments are passed onto <code><a href="#topic+daemons">daemons()</a></code> for
additional customisation if desired, although resultant behaviour may not
always be supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cl &lt;- make_cluster(2)
cl
cl[[1L]]

Sys.sleep(0.5)
status(cl)

stop_cluster(cl)

</code></pre>

<hr>
<h2 id='mirai'>mirai (Evaluate Async)</h2><span id='topic+mirai'></span>

<h3>Description</h3>

<p>Evaluate an expression asynchronously in a new background R process or
persistent daemon (local or remote). This function will return immediately
with a 'mirai', which will resolve to the evaluated result once complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirai(.expr, ..., .args = list(), .timeout = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mirai_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or else</strong> a pre-constructed language
object.</p>
</td></tr>
<tr><td><code id="mirai_+3A_...">...</code></td>
<td>
<p>(optional) <strong>either</strong> named arguments (name = value pairs)
specifying objects referenced, but not defined, in <code>.expr</code>, <strong>or</strong> an
environment containing such objects. See 'evaluation' section below.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a named list specifying objects
referenced, but not defined, in <code>.expr</code>, <strong>or</strong> an environment containing
such objects. These objects will remain local to the evaluation environment
as opposed to those supplied in <code>...</code> above - see 'evaluation' section
below.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.timeout">.timeout</code></td>
<td>
<p>[default NULL] for no timeout, or an integer value in
milliseconds. A mirai will resolve to an 'errorValue' 5 (timed out) if
evaluation exceeds this limit.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return a 'mirai' object immediately.
</p>
<p>The value of a mirai may be accessed at any time at <code style="white-space: pre;">&#8288;$data&#8288;</code>, and if yet
to resolve, an 'unresolved' logical NA will be returned instead.
</p>
<p><code><a href="#topic+unresolved">unresolved()</a></code> may be used on a mirai, returning TRUE if a 'mirai' has yet to
resolve and FALSE otherwise. This is suitable for use in control flow
statements such as <code>while</code> or <code>if</code>.
</p>
<p>Alternatively, to call (and wait for) the result, use <code><a href="#topic+call_mirai">call_mirai()</a></code> on the
returned 'mirai'. This will block until the result is returned.
</p>
<p>Specify <code>.compute</code> to send the mirai using a specific compute profile (if
previously created by <code><a href="#topic+daemons">daemons()</a></code>), otherwise leave as <code>"default"</code>.
</p>


<h3>Value</h3>

<p>A 'mirai' object.
</p>


<h3>Evaluation</h3>

<p>The expression <code>.expr</code> will be evaluated in a separate R process in a clean
environment (not the global environment), consisting only of the objects
supplied to <code>.args</code>, with the objects passed as <code>...</code> assigned to the global
environment of that process.
</p>
<p>As evaluation occurs in a clean environment, all undefined objects must be
supplied through <code>...</code> and/or <code>.args</code>, including self-defined functions.
Functions from a package should use namespaced calls such as
<code>mirai::mirai()</code>, or else the package should be loaded beforehand as part of
<code>.expr</code>.
</p>
<p>For evaluation to occur <em>as if</em> in your global environment, supply objects to
<code>...</code> rather than <code>.args</code>, e.g. for free variables or helper functions
defined in function bodies, as scoping rules may otherwise prevent them from
being found.
</p>


<h3>Timeouts</h3>

<p>Specifying the <code>.timeout</code> argument ensures that the mirai always resolves.
However, the task may not have completed and still be ongoing in the daemon
process. Use <code><a href="#topic+stop_mirai">stop_mirai()</a></code> instead to explicitly stop and interrupt a task.
</p>


<h3>Errors</h3>

<p>If an error occurs in evaluation, the error message is returned as a
character string of class 'miraiError' and 'errorValue'. <code><a href="#topic+is_mirai_error">is_mirai_error()</a></code>
may be used to test for this. The elements of the original condition are
accessible via <code>$</code> on the error object. A stack trace comprising a list of
calls is also available at <code style="white-space: pre;">&#8288;$stack.trace&#8288;</code>.
</p>
<p>If a daemon crashes or terminates unexpectedly during evaluation, an
'errorValue' 19 (Connection reset) is returned.
</p>
<p><code><a href="#topic+is_error_value">is_error_value()</a></code> tests for all error conditions including 'mirai' errors,
interrupts, and timeouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# specifying objects via '...'
n &lt;- 3
m &lt;- mirai(x + y + 2, x = 2, y = n)
m
m$data
Sys.sleep(0.2)
m$data

# passing the calling environment to '...'
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), environment(), .timeout = 1000)
m[]

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

# evaluating scripts using source() in '.expr'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file); r}, file = file, n = n)
call_mirai(m)$data
unlink(file)

# use source(local = TRUE) when passing in local variables via '.args'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file, local = TRUE); r}, .args = list(file = file, n = n))
call_mirai(m)$data
unlink(file)

# passing a language object to '.expr' and a named list to '.args'
expr &lt;- quote(a + b + 2)
args &lt;- list(a = 2, b = 3)
m &lt;- mirai(.expr = expr, .args = args)
collect_mirai(m)

</code></pre>

<hr>
<h2 id='mirai_map'>mirai Map</h2><span id='topic+mirai_map'></span>

<h3>Description</h3>

<p>Asynchronous parallel map of a function over a list or vector using
<span class="pkg">mirai</span>, with optional <span class="pkg">promises</span> integration. Performs multiple map
over the rows of a dataframe or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirai_map(.x, .f, ..., .args = list(), .promise = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mirai_map_+3A_.x">.x</code></td>
<td>
<p>a list or atomic vector. Also accepts a matrix or dataframe, in
which case multiple map is performed over its rows.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.f">.f</code></td>
<td>
<p>a function to be applied to each element of <code>.x</code>, or row of <code>.x</code> as
the case may be.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_...">...</code></td>
<td>
<p>(optional) named arguments (name = value pairs) specifying objects
referenced, but not defined, in <code>.f</code>.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.args">.args</code></td>
<td>
<p>(optional) further constant arguments to <code>.f</code>, provided as a
list.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.promise">.promise</code></td>
<td>
<p>(optional) if supplied, registers a promise against each
mirai. Either a function, supplied to the <code>onFulfilled</code> argument of
<code>promises::then()</code> or a list of 2 functions, supplied respectively to
<code>onFulfilled</code> and <code>onRejected</code> of <code>promises::then()</code>. Using this argument
requires the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.</p>
</td></tr>
<tr><td><code id="mirai_map_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sends each application of function <code>.f</code> on an element of <code>.x</code> (or row of
<code>.x</code>) for computation in a separate <code><a href="#topic+mirai">mirai()</a></code> call. If <code>.x</code> is named, names
are preserved.
</p>
<p>This simple and transparent behaviour is designed to make full use of
<span class="pkg">mirai</span> scheduling to minimise overall execution time.
</p>
<p>Facilitates recovery from partial failure by returning all 'miraiError' /
'errorValue' as the case may be, thus allowing only failures to be re-run.
</p>
<p>This function requires daemons to have previously been set, and will error
otherwise.
</p>


<h3>Value</h3>

<p>A 'mirai_map' (list of 'mirai' objects).
</p>


<h3>Collection Options</h3>

<p><code>x[]</code> collects the results of a 'mirai_map' <code>x</code> and returns a list. This will
wait for all asynchronous operations to complete if still in progress,
blocking but user-interruptible.
</p>
<p><code>x[.flat]</code> collects and flattens map results to a vector, checking that
they are of the same type to avoid coercion. Note: errors if an 'errorValue'
has been returned or results are of differing type.
</p>
<p><code>x[.progress]</code> collects map results whilst showing a progress bar from
the <a href="https://CRAN.R-project.org/package=cli"><span class="pkg">cli</span></a> package, if installed, with completion percentage and ETA,
or else a simple text progress indicator. Note: if the map operation
completes too quickly then the progress bar may not show at all.
</p>
<p><code>x[.stop]</code> collects map results applying early stopping, which stops at
the first failure and cancels remaining operations. Note: operations already
in progress continue to completion, although their results are not collected.
</p>
<p>The options above may be combined in the manner of: <br />
<code>x[.stop, .progress]</code> which applies early stopping together with a
progress indicator.
</p>


<h3>Multiple Map</h3>

<p>If <code>.x</code> is a matrix or dataframe (or other object with 'dim' attributes),
<em>multiple</em> map is performed over its <strong>rows</strong>. Character row names are
preserved as names of the output.
</p>
<p>This allows map over 2 or more arguments, and <code>.f</code> should accept at least as
many arguments as there are columns. If the dataframe has names, or the
matrix column dimnames, named arguments are provided to <code>.f</code>.
</p>
<p>To map over <strong>columns</strong> instead, first wrap a dataframe in <code><a href="base.html#topic+as.list">as.list()</a></code>, or
transpose a matrix using <code><a href="base.html#topic+t">t()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daemons(4)

# perform and collect mirai map
mm &lt;- mirai_map(c(a = 1, b = 2, c = 3), rnorm)
mm
mm[]

# map with constant args specified via '.args'
mirai_map(1:3, rnorm, .args = list(n = 5, sd = 2))[]

# flatmap with helper function passed via '...'
mirai_map(
  10^(0:9),
  function(x) rnorm(1L, valid(x)),
  valid = function(x) min(max(x, 0L), 100L)
)[.flat]

# unnamed matrix multiple map: arguments passed to function by position
(mat &lt;- matrix(1:4, nrow = 2L))
mirai_map(mat, function(x = 10, y = 0, z = 0) x + y + z)[.flat]

# named matrix multiple map: arguments passed to function by name
dimnames(mat) &lt;- list(c("a", "b"), c("y", "z"))
mirai_map(mat, function(x = 10, y = 0, z = 0) x + y + z)[.flat]

# dataframe multiple map: using a function taking '...' arguments
df &lt;- data.frame(a = c("Aa", "Bb"), b = c(1L, 4L))
mirai_map(df, function(...) sprintf("%s: %d", ...))[.flat]

# indexed map over a vector (using a dataframe)
v &lt;- c("egg", "got", "ten", "nap", "pie")
mirai_map(
  data.frame(1:length(v), v),
  sprintf,
  .args = list(fmt = "%d_%s")
)[.flat]

# return a 'mirai_map' object, check for resolution, collect later
mp &lt;- mirai_map(2:4, function(x) runif(1L, x, x + 1))
unresolved(mp)
mp
mp[.flat]
unresolved(mp)

# progress indicator counts up from 0 to 4 seconds
res &lt;- mirai_map(1:4, Sys.sleep)[.progress]

# stops early when second element returns an error
tryCatch(mirai_map(list(1, "a", 3), sum)[.stop], error = identity)

daemons(0)


# promises example that outputs the results, including errors, to the console
daemons(1, dispatcher = FALSE)
ml &lt;- mirai_map(
  1:30,
  function(i) {Sys.sleep(0.1); if (i == 30) stop(i) else i},
  .promise = list(
    function(x) cat(paste(x, "")),
    function(x) { cat(conditionMessage(x), "\n"); daemons(0) }
  )
)

</code></pre>

<hr>
<h2 id='nextstream'>Next &gt;&gt; Developer Interface</h2><span id='topic+nextstream'></span><span id='topic+nextget'></span><span id='topic+nextcode'></span>

<h3>Description</h3>

<p><code>nextstream</code> retrieves the currently stored L'Ecuyer-CMRG RNG stream
for the specified compute profile and advances it to the next stream.
</p>
<p><code>nextget</code> retrieves the specified item from the specified compute profile.
</p>
<p><code>nextcode</code> translates integer exit codes returned by <code><a href="#topic+daemon">daemon()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextstream(.compute = "default")

nextget(x, .compute = "default")

nextcode(xc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nextstream_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="nextstream_+3A_x">x</code></td>
<td>
<p>character value of item to retrieve. One of <code>"n"</code> (number of
dispatcher daemons), <code>"pid"</code> (dispatcher process ID), <code>"urls"</code> (URLs
dispatcher is listening at) or <code>"tls"</code> (the stored client TLS configuration
for use by daemons).</p>
</td></tr>
<tr><td><code id="nextstream_+3A_xc">xc</code></td>
<td>
<p>integer return value of <code><a href="#topic+daemon">daemon()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported for use by packages extending <span class="pkg">mirai</span> with
alternative launchers of <code><a href="#topic+daemon">daemon()</a></code> processes.
</p>
<p>For <code>nextstream</code>: This function should be called for its return value
when required. The function also has the side effect of automatically
advancing the stream stored within the compute profile. This ensures that the
next recursive stream is returned when the function is called again.
</p>


<h3>Value</h3>

<p>For <code>nextstream</code>: a length 7 integer vector, as given by
<code>.Random.seed</code> when the L'Ecuyer-CMRG RNG is in use (may be passed directly
to the <code>rs</code> argument of <code><a href="#topic+daemon">daemon()</a></code>), or else NULL if a stream has not yet
been created.
</p>
<p>For <code>nextget</code>: the requested item, or else NULL if not present.
</p>
<p>For <code>nextcode</code>: character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daemons(1L)
nextstream()
nextstream()

nextget("pid")
nextget("urls")

daemons(0)

nextcode(0L)
nextcode(1L)

</code></pre>

<hr>
<h2 id='remote_config'>Generic and SSH Remote Launch Configuration</h2><span id='topic+remote_config'></span><span id='topic+ssh_config'></span>

<h3>Description</h3>

<p><code>remote_config</code> provides a flexible generic framework for generating the
shell commands to deploy daemons remotely.
</p>
<p><code>ssh_config</code> generates a remote configuration for launching daemons over
SSH, with the option of SSH tunnelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remote_config(
  command = NULL,
  args = c("", "."),
  rscript = "Rscript",
  quote = FALSE
)

ssh_config(
  remotes,
  tunnel = FALSE,
  timeout = 10,
  command = "ssh",
  rscript = "Rscript"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remote_config_+3A_command">command</code></td>
<td>
<p>the command used to effect the daemon launch on the remote
machine as a character string (e.g. <code>"ssh"</code>). Defaults to <code>"ssh"</code> for
<code>ssh_config</code>, although may be substituted for the full path to a specific
SSH application. The default NULL for <code>remote_config</code> does not carry out
any launches, but causes <code><a href="#topic+launch_remote">launch_remote()</a></code> to return the shell commands for
manual deployment on remote machines.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_args">args</code></td>
<td>
<p>(optional) arguments passed to <code>command</code>, as a character vector
that must include <code>"."</code> as an element, which will be substituted for the
daemon launch command. Alternatively, a list of such character vectors to
effect multiple launches (one for each list element).</p>
</td></tr>
<tr><td><code id="remote_config_+3A_rscript">rscript</code></td>
<td>
<p>(optional) name / path of the Rscript executable on the remote
machine. The default assumes <code>"Rscript"</code> is on the executable search
path. Prepend the full path if necessary. If launching on Windows,
<code>"Rscript"</code> should be replaced with <code>"Rscript.exe"</code>.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_quote">quote</code></td>
<td>
<p>[default FALSE] logical value whether or not to quote the
daemon launch command (not required for Slurm <code>"srun"</code> for example, but
required for Slurm <code>"sbatch"</code> or <code>"ssh"</code>).</p>
</td></tr>
<tr><td><code id="remote_config_+3A_remotes">remotes</code></td>
<td>
<p>the character URL or vector of URLs to SSH into, using the
'ssh://' scheme and including the port open for SSH connections (defaults
to 22 if not specified), e.g. 'ssh://10.75.32.90:22' or 'ssh://nodename'.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_tunnel">tunnel</code></td>
<td>
<p>[default FALSE] logical value, whether to use SSH tunnelling.
If TRUE, requires the <code><a href="#topic+daemons">daemons()</a></code> <code>url</code> hostname to be '127.0.0.1'. See
the 'SSH Tunnelling' section below for further details.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_timeout">timeout</code></td>
<td>
<p>[default 10] maximum time allowed for connection setup in
seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in the required format to be supplied to the <code>remote</code> argument
of <code><a href="#topic+launch_remote">launch_remote()</a></code>, <code><a href="#topic+daemons">daemons()</a></code>, or <code><a href="#topic+make_cluster">make_cluster()</a></code>.
</p>


<h3>SSH Direct Connections</h3>

<p>The simplest use of SSH is to execute the daemon launch command on a remote
machine, for it to dial back to the host / dispatcher URL.
</p>
<p>It is assumed that SSH key-based authentication is already in place. The
relevant port on the host must also be open to inbound connections from the
remote machine, and is hence suitable for use within trusted networks.
</p>


<h3>SSH Tunnelling</h3>

<p>Use of SSH tunnelling provides a convenient way to launch remote daemons
without requiring the remote machine to be able to access the host. Often
firewall configurations or security policies may prevent opening a port to
accept outside connections.
</p>
<p>In these cases SSH tunnelling offers a solution by creating a tunnel once the
initial SSH connection is made. For simplicity, this SSH tunnelling
implementation uses the same port on both host and daemon. SSH key-based
authentication must already be in place, but no other configuration is
required.
</p>
<p>To use tunnelling, set the hostname of the <code><a href="#topic+daemons">daemons()</a></code> <code>url</code> argument to be
'127.0.0.1'. Using <code><a href="#topic+local_url">local_url()</a></code> with <code>tcp = TRUE</code> also does this for you.
Specifying a specific port to use is optional, with a random ephemeral port
assigned otherwise. For example, specifying 'tcp://127.0.0.1:5555' uses the
local port '5555' to create the tunnel on each machine. The host listens
to '127.0.0.1:5555' on its machine and the remotes each dial into
'127.0.0.1:5555' on their own respective machines.
</p>
<p>This provides a means of launching daemons on any machine you are able to
access via SSH, be it on the local network or the cloud.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Slurm srun example
remote_config(
  command = "srun",
  args = c("--mem 512", "-n 1", "."),
  rscript = file.path(R.home("bin"), "Rscript")
)

# Slurm sbatch requires 'quote = TRUE'
remote_config(
  command = "sbatch",
  args = c("--mem 512", "-n 1", "--wrap", "."),
  rscript = file.path(R.home("bin"), "Rscript"),
  quote = TRUE
)

# SSH also requires 'quote = TRUE'
remote_config(
  command = "/usr/bin/ssh",
  args = c("-fTp 22 10.75.32.90", "."),
  quote = TRUE
)

# can be used to start local dameons with special configurations
remote_config(
  command = "Rscript",
  rscript = "--default-packages=NULL --vanilla"
)

# direct SSH example
ssh_config(c("ssh://10.75.32.90:222", "ssh://nodename"), timeout = 5)

# SSH tunnelling example
ssh_config(c("ssh://10.75.32.90:222", "ssh://nodename"), tunnel = TRUE)

## Not run: 

# launch 2 daemons on the remote machines 10.75.32.90 and 10.75.32.91 using
# SSH, connecting back directly to the host URL over a TLS connection:
daemons(
  url = host_url(tls = TRUE),
  remote = ssh_config(c("ssh://10.75.32.90:222", "ssh://10.75.32.91:222"))
)

# launch 2 daemons on the remote machine 10.75.32.90 using SSH tunnelling:
daemons(
  n = 2,
  url = local_url(tcp = TRUE),
  remote = ssh_config("ssh://10.75.32.90", tunnel = TRUE)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='serial_config'>Create Serialization Configuration</h2><span id='topic+serial_config'></span>

<h3>Description</h3>

<p>Returns a serialization configuration, which may be set to perform custom
serialization and unserialization of normally non-exportable reference
objects, allowing these to be used seamlessly between different R sessions.
This feature utilises the 'refhook' system of R native serialization. Once
set, the functions apply to all mirai requests for a specific compute
profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial_config(class, sfunc, ufunc, vec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serial_config_+3A_class">class</code></td>
<td>
<p>character string of the class of object custom serialization
functions are applied to, e.g. 'ArrowTabular' or 'torch_tensor'.</p>
</td></tr>
<tr><td><code id="serial_config_+3A_sfunc">sfunc</code></td>
<td>
<p>a function that accepts a reference object inheriting from
<code>class</code> (or a list of such objects) and returns a raw vector.</p>
</td></tr>
<tr><td><code id="serial_config_+3A_ufunc">ufunc</code></td>
<td>
<p>a function that accepts a raw vector and returns a reference
object (or list of such objects).</p>
</td></tr>
<tr><td><code id="serial_config_+3A_vec">vec</code></td>
<td>
<p>[default FALSE] whether or not the serialization functions are
vectorized. If FALSE, they should accept and return reference objects
individually e.g. <code>arrow::write_to_raw</code> and <code>arrow::read_ipc_stream</code>. If
TRUE, they should accept and return a list of reference objects, e.g.
<code>torch::torch_serialize</code> and <code>torch::torch_load</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising the configuration. This should be passed to the
<code>serial</code> argument of <code><a href="#topic+daemons">daemons()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cfg &lt;- serial_config("test_cls", function(x) serialize(x, NULL), unserialize)
cfg

</code></pre>

<hr>
<h2 id='status'>Status Information</h2><span id='topic+status'></span>

<h3>Description</h3>

<p>Retrieve status information for the specified compute profile, comprising
current connections and daemons status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(.compute = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="status_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character compute profile (each compute
profile has its own set of daemons for connecting to different resources).
</p>
<p><strong>or</strong> a 'miraiCluster' to obtain its status.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list comprising:
</p>

<ul>
<li> <p><strong>connections</strong> - integer number of active daemon connections.
</p>
</li>
<li> <p><strong>daemons</strong> - character URL at which host / dispatcher is
listening, or else <code>0L</code> if daemons have not yet been set.
</p>
</li>
<li> <p><strong>mirai</strong> (present only if using dispatcher) - a named integer
vector comprising: <strong>awaiting</strong> - number of tasks queued for execution at
dispatcher, <strong>executing</strong> - number of tasks sent to a daemon for
execution, and <strong>completed</strong> - number of tasks for which the result has
been received (either completed or cancelled).
</p>
</li></ul>



<h3>Events</h3>

<p>If dispatcher is used combined with daemon IDs, an additional element
<strong>events</strong> will report the positive integer ID when the daemon connects and
the negative value when it disconnects. Only the events since the previous
status query are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
status()
daemons(url = "tcp://[::1]:0")
status()
daemons(0)

</code></pre>

<hr>
<h2 id='stop_mirai'>mirai (Stop)</h2><span id='topic+stop_mirai'></span>

<h3>Description</h3>

<p>Stops a 'mirai' if still in progress, causing it to resolve immediately to an
'errorValue' 20 (Operation canceled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_mirai_+3A_x">x</code></td>
<td>
<p>a 'mirai' object, or list of 'mirai' objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using dispatcher allows cancellation of 'mirai'. In the case that the 'mirai'
is awaiting execution, it is discarded from the queue and never evaluated. In
the case it is already in execution, an interrupt will be sent.
</p>
<p>A successful cancellation request does not guarantee successful cancellation:
the task, or a portion of it, may have already completed before the interrupt
is received. Even then, compiled code is not always interruptible. This
should be noted, particularly if the code carries out side effects during
execution, such as writing to files, etc.
</p>


<h3>Value</h3>

<p>Logical TRUE if the cancellation request was successful (was awaiting
execution or in execution), or else FALSE (if already completed or
previously cancelled). Will always return FALSE if not using dispatcher.
</p>
<p><strong>Or</strong> a vector of logical values if supplying a list of 'mirai', such as
those returned by <code><a href="#topic+mirai_map">mirai_map()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- mirai(Sys.sleep(n), n = 5)
stop_mirai(m)
m$data

</code></pre>

<hr>
<h2 id='unresolved'>Query if a mirai is Unresolved</h2><span id='topic+unresolved'></span>

<h3>Description</h3>

<p>Query whether a 'mirai', 'mirai' value or list of 'mirai' remains unresolved.
Unlike <code><a href="#topic+call_mirai">call_mirai()</a></code>, this function does not wait for completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unresolved(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unresolved_+3A_x">x</code></td>
<td>
<p>a 'mirai' object or list of 'mirai' objects, or a 'mirai' value
stored at <code style="white-space: pre;">&#8288;$data&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable for use in control flow statements such as <code>while</code> or <code>if</code>.
</p>
<p>Note: querying resolution may cause a previously unresolved 'mirai' to
resolve.
</p>


<h3>Value</h3>

<p>Logical TRUE if <code>x</code> is an unresolved 'mirai' or 'mirai' value or the
list contains at least one unresolved 'mirai', or FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- mirai(Sys.sleep(0.1))
unresolved(m)
Sys.sleep(0.3)
unresolved(m)

</code></pre>

<hr>
<h2 id='with.miraiDaemons'>With Mirai Daemons</h2><span id='topic+with.miraiDaemons'></span>

<h3>Description</h3>

<p>Evaluate an expression with daemons that last for the duration of the
expression. Ensure each mirai within the statement is explicitly called (or
their values collected) so that daemons are not reset before they have all
completed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miraiDaemons'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with.miraiDaemons_+3A_data">data</code></td>
<td>
<p>a call to <code><a href="#topic+daemons">daemons()</a></code>.</p>
</td></tr>
<tr><td><code id="with.miraiDaemons_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate.</p>
</td></tr>
<tr><td><code id="with.miraiDaemons_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code><a href="base.html#topic+with">with()</a></code> for class
'miraiDaemons'.
</p>


<h3>Value</h3>

<p>The return value of <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(
  daemons(2, dispatcher = FALSE),
  {
    m1 &lt;- mirai(Sys.getpid())
    m2 &lt;- mirai(Sys.getpid())
    cat(m1[], m2[], "\n")
  }
)

status()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
