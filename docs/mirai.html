<!DOCTYPE html><html><head><title>Help for package mirai</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mirai}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mirai-package'><p>mirai: Minimalist Async Evaluation Framework for R</p></a></li>
<li><a href='#.daemon'><p>dot Daemon</p></a></li>
<li><a href='#as.promise.mirai'><p>Make Mirai Promise</p></a></li>
<li><a href='#call_mirai'><p>mirai (Call Value)</p></a></li>
<li><a href='#daemon'><p>Daemon Instance</p></a></li>
<li><a href='#daemons'><p>Daemons (Set Persistent Processes)</p></a></li>
<li><a href='#dispatcher'><p>Dispatcher</p></a></li>
<li><a href='#everywhere'><p>Evaluate Everywhere</p></a></li>
<li><a href='#host_url'><p>URL Constructors</p></a></li>
<li><a href='#is_mirai'><p>Is mirai</p></a></li>
<li><a href='#is_mirai_error'><p>Error Validators</p></a></li>
<li><a href='#launch_local'><p>Launch Daemon</p></a></li>
<li><a href='#make_cluster'><p>Make Mirai Cluster</p></a></li>
<li><a href='#mirai'><p>mirai (Evaluate Async)</p></a></li>
<li><a href='#nextstream'><p>Next &gt;&gt; Developer Interface</p></a></li>
<li><a href='#remote_config'><p>Generic and SSH Remote Launch Configuration</p></a></li>
<li><a href='#saisei'><p>Saisei (Regenerate Token)</p></a></li>
<li><a href='#serialization'><p>Custom Serialization Functions</p></a></li>
<li><a href='#status'><p>Status Information</p></a></li>
<li><a href='#stop_mirai'><p>mirai (Stop Evaluation)</p></a></li>
<li><a href='#unresolved'><p>Query if a mirai is Unresolved</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Minimalist Async Evaluation Framework for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.12.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Lightweight parallel code execution and distributed computing.
    Designed for simplicity, a 'mirai' evaluates an R expression asynchronously,
    on local or network resources, resolving automatically upon completion.
    Efficient scheduling over fast inter-process communications or secure TLS
    connections over TCP/IP, built on 'nanonext' and 'NNG' (Nanomsg Next Gen).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>,
<a href="https://github.com/shikokuchuo/mirai/">https://github.com/shikokuchuo/mirai/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nanonext (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>parallel, promises</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 08:04:02 UTC; cg334</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Gao <a href="https://orcid.org/0000-0002-0750-061X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Hibiki AI Limited [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Gao &lt;charlie.gao@shikokuchuo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mirai-package'>mirai: Minimalist Async Evaluation Framework for R</h2><span id='topic+mirai-package'></span>

<h3>Description</h3>

<p>Lightweight parallel code execution and distributed computing. Designed for
simplicity, a 'mirai' evaluates an R expression asynchronously, on local
or network resources, resolving automatically upon completion. Efficient
scheduling over fast inter-process communications or secure TLS
connections over TCP/IP, built on 'nanonext' and 'NNG' (Nanomsg Next
Gen).
</p>


<h3>Notes</h3>

<p>For local mirai requests, the default transport for inter-process
communications is platform-dependent: abstract Unix domain sockets on
Linux, Unix domain sockets on MacOS, Solaris and other POSIX platforms,
and named pipes on Windows.
</p>
<p>This may be overriden, if desired, by specifying 'url' in the
<code><a href="#topic+daemons">daemons</a></code> interface and launching daemons using
<code><a href="#topic+launch_local">launch_local</a></code>.
</p>


<h3>Reference Manual</h3>

<p><code>vignette("mirai", package = "mirai")</code>
</p>


<h3>Author(s)</h3>

<p>Charlie Gao <a href="mailto:charlie.gao@shikokuchuo.net">charlie.gao@shikokuchuo.net</a>
(<a href="https://orcid.org/0000-0002-0750-061X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shikokuchuo.net/mirai/">https://shikokuchuo.net/mirai/</a>
</p>
</li>
<li> <p><a href="https://github.com/shikokuchuo/mirai/">https://github.com/shikokuchuo/mirai/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shikokuchuo/mirai/issues">https://github.com/shikokuchuo/mirai/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.daemon'>dot Daemon</h2><span id='topic+.daemon'></span>

<h3>Description</h3>

<p>Ephemeral executor for the remote process. User code must not call this.
Consider <code>daemon(maxtasks = 1L)</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.daemon(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".daemon_+3A_url">url</code></td>
<td>
<p>the character host or dispatcher URL to dial into, including the
port to connect to (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL.
</p>

<hr>
<h2 id='as.promise.mirai'>Make Mirai Promise</h2><span id='topic+as.promise.mirai'></span>

<h3>Description</h3>

<p>Creates a 'promise' from a 'mirai'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mirai'
as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.promise.mirai_+3A_x">x</code></td>
<td>
<p>an object of class 'mirai'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>as.promise</code> for
class 'mirai'.
</p>
<p>Requires the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package.
</p>
<p>Allows a 'mirai' to be used with the promise pipe <code>%...&gt;%</code>, which
schedules a function to run upon resolution of the 'mirai'.
</p>


<h3>Value</h3>

<p>A 'promise' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; requireNamespace("promises", quietly = TRUE)) {

library(promises)

p &lt;- as.promise(mirai("example"))
print(p)
is.promise(p)

p2 &lt;- mirai("completed") %...&gt;% identity()
p2$then(cat)
is.promise(p2)

}

</code></pre>

<hr>
<h2 id='call_mirai'>mirai (Call Value)</h2><span id='topic+call_mirai'></span><span id='topic+call_mirai_'></span>

<h3>Description</h3>

<p><code>call_mirai</code> retrieves the value of a mirai, waiting for the the
asynchronous operation to resolve if it is still in progress.
</p>
<p><code>call_mirai_</code> is a variant that allows user interrupts, suitable for
interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_mirai(aio)

call_mirai_(aio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_mirai_+3A_aio">aio</code></td>
<td>
<p>a 'mirai' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will wait for the async operation to complete if still
in progress (blocking).
</p>
<p>If an error occurs in evaluation, the error message is returned as a
character string of class 'miraiError' and 'errorValue'.
<code><a href="#topic+is_mirai_error">is_mirai_error</a></code> may be used to test for this.
</p>
<p><code><a href="#topic+is_error_value">is_error_value</a></code> tests for all error conditions including
mirai errors, interrupts, and timeouts.
</p>
<p>The mirai updates itself in place, so to access the value of a mirai
<code>x</code> directly, use <code>call_mirai(x)$data</code>.
</p>


<h3>Value</h3>

<p>The passed mirai (invisibly). The retrieved value is stored at
<code>$data</code>.
</p>


<h3>Alternatively</h3>

<p>The value of a mirai may be accessed at any time at <code>$data</code>, and
if yet to resolve, an 'unresolved' logical NA will be returned instead.
</p>
<p>Using <code><a href="#topic+unresolved">unresolved</a></code> on a mirai returns TRUE only if a mirai
has yet to resolve and FALSE otherwise. This is suitable for use in
control flow statements such as <code>while</code> or <code>if</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# using call_mirai()
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), .args = list(df1, df2), .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai({
  res &lt;- rnorm(n)
  res / rev(res)
  },
  n = 1e6)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

}

</code></pre>

<hr>
<h2 id='daemon'>Daemon Instance</h2><span id='topic+daemon'></span>

<h3>Description</h3>

<p>Starts up an execution daemon to receive <code><a href="#topic+mirai">mirai</a></code> requests. Awaits
data, evaluates an expression in an environment containing the supplied
data, and returns the value to the host caller. Daemon settings may be
controlled by <code><a href="#topic+daemons">daemons</a></code> and this function should not need to
be invoked directly, unless deploying manually on remote resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemon(
  url,
  autoexit = TRUE,
  cleanup = TRUE,
  output = FALSE,
  maxtasks = Inf,
  idletime = Inf,
  walltime = Inf,
  timerstart = 0L,
  ...,
  tls = NULL,
  rs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daemon_+3A_url">url</code></td>
<td>
<p>the character host or dispatcher URL to dial into, including the
port to connect to (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
<tr><td><code id="daemon_+3A_autoexit">autoexit</code></td>
<td>
<p>[default TRUE] logical value, whether the daemon should
exit automatically when its socket connection ends. If a signal from the
<span class="pkg">tools</span> package, e.g. <code>tools::SIGINT</code>, or an equivalent integer
value is supplied, this signal is additionally raised (see 'Persistence'
section below).</p>
</td></tr>
<tr><td><code id="daemon_+3A_cleanup">cleanup</code></td>
<td>
<p>[default TRUE] logical value, whether to perform cleanup of
the global environment and restore loaded packages and options to an
initial state after each evaluation. For more granular control, also
accepts an integer value (see 'Cleanup Options' section below).</p>
</td></tr>
<tr><td><code id="daemon_+3A_output">output</code></td>
<td>
<p>[default FALSE] logical value, to output generated stdout /
stderr if TRUE, or else discard if FALSE. Specify as TRUE in the '...'
argument to <code><a href="#topic+daemons">daemons</a></code> or <code><a href="#topic+launch_local">launch_local</a></code> to provide
redirection of output to the host process (applicable only for local
daemons).</p>
</td></tr>
<tr><td><code id="daemon_+3A_maxtasks">maxtasks</code></td>
<td>
<p>[default Inf] the maximum number of tasks to execute (task
limit) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_idletime">idletime</code></td>
<td>
<p>[default Inf] maximum idle time, since completion of the last
task (in milliseconds) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_walltime">walltime</code></td>
<td>
<p>[default Inf] soft walltime, or the minimum amount of real
time taken (in milliseconds) before exiting.</p>
</td></tr>
<tr><td><code id="daemon_+3A_timerstart">timerstart</code></td>
<td>
<p>[default 0L] number of completed tasks after which to start
the timer for 'idletime' and 'walltime'. 0L implies timers are started
upon launch.</p>
</td></tr>
<tr><td><code id="daemon_+3A_...">...</code></td>
<td>
<p>reserved but not currently used.</p>
</td></tr>
<tr><td><code id="daemon_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over 'tls+tcp://'
or 'wss://'. <strong>Either</strong> the character path to a file containing
X.509 certificate(s) in PEM format, comprising the certificate authority
certificate chain starting with the TLS certificate and ending with the
CA certificate, <strong>or</strong> a length 2 character vector comprising [i]
the certificate authority certificate chain and [ii] the empty character
<code>''</code>.</p>
</td></tr>
<tr><td><code id="daemon_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host
process and should not be independently supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that daemons dial into the host or
dispatcher, which listens at the 'url' address. In this way, network
resources may be added or removed dynamically and the host or
dispatcher automatically distributes tasks to all available daemons.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Persistence</h3>

<p>The 'autoexit' argument governs persistence settings for the daemon. The
default TRUE ensures that it will exit cleanly once its socket connection
has ended.
</p>
<p>Instead of TRUE, supplying a signal from the <span class="pkg">tools</span> package, e.g.
<code>tools::SIGINT</code>, or an equivalent integer value, sets the signal to
be raised when the socket connection ends. As an example, supplying
SIGINT allows a potentially more immediate exit by interrupting any
ongoing evaluation rather than letting it complete.
</p>
<p>Setting to FALSE allows the daemon to persist indefinitely even when
there is no longer a socket connection. This allows a host session to end
and a new session to connect at the URL where the daemon is dialled in.
Daemons must be terminated with <code>daemons(NULL)</code> in this case, which
sends explicit exit instructions to all connected daemons.
</p>
<p>Persistence also implies that dials are performed asynchronously, which
means retries are attempted (indefinitely) if not immediately successful.
This is resilient behaviour but can mask potential connection issues.
</p>


<h3>Cleanup Options</h3>

<p>The 'cleanup' argument also accepts an integer value, which operates an
additive bitmask: perform cleanup of the global environment (1L), reset
loaded packages to an initial state (2L), restore options to an initial
state (4L), and perform garbage collection (8L).
</p>
<p>As an example, to perform cleanup of the global environment and garbage
collection, specify 9L (1L + 8L). The default argument value of TRUE
performs all actions apart from garbage collection and is equivalent to a
value of 7L.
</p>
<p>Caution: do not reset options but not loaded packages if packages set
options on load.
</p>

<hr>
<h2 id='daemons'>Daemons (Set Persistent Processes)</h2><span id='topic+daemons'></span>

<h3>Description</h3>

<p>Set 'daemons' or persistent background processes to receive <code><a href="#topic+mirai">mirai</a></code>
requests. Specify 'n' to create daemons on the local machine. Specify
'url' for receiving connections from remote daemons (for distributed
computing across the network). Specify 'remote' to optionally launch
remote daemons via a remote configuration. By default, dispatcher ensures
optimal scheduling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemons(
  n,
  url = NULL,
  remote = NULL,
  dispatcher = TRUE,
  ...,
  resilience = TRUE,
  seed = NULL,
  tls = NULL,
  pass = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daemons_+3A_n">n</code></td>
<td>
<p>integer number of daemons to set.</p>
</td></tr>
<tr><td><code id="daemons_+3A_url">url</code></td>
<td>
<p>[default NULL] if specified, the character URL or vector of URLs
on the host for remote daemons to dial into, including a port accepting
incoming connections (and optionally for websockets, a path), e.g.
'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'. Specify a URL
starting 'tls+tcp://' or 'wss://' to use secure TLS connections.
Auxiliary function <code><a href="#topic+host_url">host_url</a></code> may be used to construct a
valid host URL.</p>
</td></tr>
<tr><td><code id="daemons_+3A_remote">remote</code></td>
<td>
<p>[default NULL] required only for launching remote daemons, a
configuration generated by <code><a href="#topic+remote_config">remote_config</a></code> or
<code><a href="#topic+ssh_config">ssh_config</a></code>.</p>
</td></tr>
<tr><td><code id="daemons_+3A_dispatcher">dispatcher</code></td>
<td>
<p>[default TRUE] logical value whether to use dispatcher.
Dispatcher is a local background process that connects to daemons on
behalf of the host and ensures FIFO scheduling (see Dispatcher section
below).</p>
</td></tr>
<tr><td><code id="daemons_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to
<code><a href="#topic+dispatcher">dispatcher</a></code> if using dispatcher and/or <code><a href="#topic+daemon">daemon</a></code>
if launching daemons. These include 'token' at dispatcher and 'autoexit,
'cleanup', 'output', 'maxtasks', 'idletime', 'walltime' and 'timerstart'
at daemon.</p>
</td></tr>
<tr><td><code id="daemons_+3A_resilience">resilience</code></td>
<td>
<p>[default TRUE] (applicable when not using dispatcher)
logical value whether to retry failed tasks on other daemons. If FALSE,
an appropriate 'errorValue' will be returned in such cases.</p>
</td></tr>
<tr><td><code id="daemons_+3A_seed">seed</code></td>
<td>
<p>[default NULL] (optional) supply a random seed (single value,
interpreted as an integer). This is used to inititalise the L'Ecuyer-CMRG
RNG streams sent to each daemon. Note that reproducible results can be
expected only for 'dispatcher = FALSE', as the unpredictable timing of
task completions would otherwise influence the tasks sent to each daemon.
Even for 'dispatcher = FALSE', reproducibility is not guaranteed if the
order in which tasks are sent is not deterministic.</p>
</td></tr>
<tr><td><code id="daemons_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (optional for secure TLS connections) if not
supplied, zero-configuration single-use keys and certificates are
automatically generated. If supplied, <strong>either</strong> the character path
to a file containing the PEM-encoded TLS certificate and associated
private key (may contain additional certificates leading to a validation
chain, with the TLS certificate first), <strong>or</strong> a length 2 character
vector comprising [i] the TLS certificate (optionally certificate chain)
and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="daemons_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to 'tls'
is encrypted with a password) For security, should be provided through a
function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="daemons_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>daemons(0)</code> to reset daemon connections:
</p>

<ul>
<li><p> A reset is required before revising settings for the same compute
profile, otherwise changes are not registered.
</p>
</li>
<li><p> All connected daemons and/or dispatchers exit automatically.
</p>
</li>
<li> <p><span class="pkg">mirai</span> reverts to the default behaviour of creating a new
background process for each request.
</p>
</li>
<li><p> Any unresolved 'mirai' will return an 'errorValue' 7 (Object
closed) after a reset.
</p>
</li></ul>

<p>If the host session ends, all connected dispatcher and daemon processes
automatically exit as soon as their connections are dropped (unless
the daemons were started with <code>autoexit = FALSE</code>). If a daemon is
processing a task, it will exit as soon as the task is complete.
</p>
<p>To reset persistent daemons started with <code>autoexit = FALSE</code>, use
<code>daemons(NULL)</code> instead, which also sends exit instructions to all
connected daemons prior to resetting.
</p>
<p>For historical reasons, <code>daemons()</code> with no arguments returns the
value of <code><a href="#topic+status">status</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the arguments supplied:
</p>

<ul>
<li><p> using dispatcher: integer number of daemons set.
</p>
</li>
<li><p> or else launching local daemons: integer number of daemons launched.
</p>
</li>
<li><p> otherwise: the character host URL.
</p>
</li></ul>



<h3>Local Daemons</h3>

<p>Daemons provide a potentially more efficient solution for asynchronous
operations as new processes no longer need to be created on an <em>ad
hoc</em> basis.
</p>
<p>Supply the argument 'n' to set the number of daemons. New background
<code><a href="#topic+daemon">daemon</a></code> processes are automatically created on the local
machine connecting back to the host process, either directly or via
dispatcher.
</p>


<h3>Dispatcher</h3>

<p>By default <code>dispatcher = TRUE</code>. This launches a background process
running <code><a href="#topic+dispatcher">dispatcher</a></code>. Dispatcher connects to daemons on
behalf of the host and ensures FIFO scheduling of tasks. Dispatcher uses
synchronisation primitives from <span class="pkg">nanonext</span>, waiting rather than
polling for tasks, which is both efficient (no resource usage) and fully
event-driven (having no latency).
</p>
<p>By specifying <code>dispatcher = FALSE</code>, daemons connect to the host
directly rather than through dispatcher. The host sends tasks to
connected daemons immediately in an evenly-distributed fashion. However,
optimal scheduling is not guaranteed as the duration of tasks cannot be
known <em>a priori</em>, such that tasks can be queued at one daemon while
other daemons remain idle. Nevertheless, this provides a resource-light
approach suited to working with similar-length tasks, or where concurrent
tasks typically do not exceed available daemons.
</p>


<h3>Distributed Computing</h3>

<p>Specifying 'url' allows tasks to be distributed across the network. This
should be a character string such as: 'tcp://10.75.32.70:5555' at which
daemon processes should connect to. Switching the URL scheme to
'tls+tcp://' or 'wss://' automatically upgrades the connection to use TLS.
The auxiliary function <code><a href="#topic+host_url">host_url</a></code> may be used to
automatically construct a valid host URL based on the computer's hostname.
</p>
<p>Specify 'remote' with a call to <code><a href="#topic+remote_config">remote_config</a></code> or
<code><a href="#topic+ssh_config">ssh_config</a></code> to launch daemons on remote machines. Otherwise,
<code><a href="#topic+launch_remote">launch_remote</a></code> may be used to generate the shell commands to
deploy daemons manually on remote resources.
</p>
<p>IPv6 addresses are also supported and must be enclosed in square brackets
[ ] to avoid confusion with the final colon separating the port. For
example, port 5555 on the IPv6 loopback address ::1 would be specified
as 'tcp://[::1]:5555'.
</p>
<p>Specifying the wildcard value zero for the port number e.g. 'tcp://[::1]:0'
or 'ws://[::1]:0' will automatically assign a free ephemeral port. Use
<code><a href="#topic+status">status</a></code> to inspect the actual assigned port at any time.
</p>
<p><strong>With Dispatcher</strong>
</p>
<p>When using dispatcher, it is recommended to use a websocket URL rather
than TCP, as this requires only one port to connect to all daemons: a
websocket URL supports a path after the port number, which can be made
unique for each daemon.
</p>
<p>Specifying a single host URL such as 'ws://10.75.32.70:5555' with
<code>n = 6</code> will automatically append a sequence to the path, listening
to the URLs 'ws://10.75.32.70:5555/1' through 'ws://110.75.32.70:5555/6'.
</p>
<p>Alternatively, specify a vector of URLs to listen to arbitrary port
numbers / paths. In this case it is optional to supply 'n' as this can
be inferred by the length of vector supplied.
</p>
<p>Individual daemons then dial in to each of these host URLs. At most one
daemon can be dialled into each URL at any given time.
</p>
<p>Dispatcher automatically adjusts to the number of daemons actually
connected. Hence it is possible to dynamically scale up or down the
number of daemons as required, subject to the maximum number initially
specified.
</p>
<p>Alternatively, supplying a single TCP URL will listen at a block of URLs
with ports starting from the supplied port number and incrementing by one
for 'n' specified e.g. the host URL 'tcp://10.75.32.70:5555' with
<code>n = 6</code> listens to the contiguous block of ports 5555 through 5560.
</p>
<p><strong>Without Dispatcher</strong>
</p>
<p>A TCP URL may be used in this case as the host listens at only one
address, utilising a single port.
</p>
<p>The network topology is such that daemons (started with <code><a href="#topic+daemon">daemon</a></code>)
or indeed dispatchers (started with <code><a href="#topic+dispatcher">dispatcher</a></code>) dial into
the same host URL.
</p>
<p>'n' is not required in this case, and disregarded if supplied, as network
resources may be added or removed at any time. The host automatically
distributes tasks to all connected daemons and dispatchers in a
round-robin fashion.
</p>


<h3>Compute Profiles</h3>

<p>By default, the 'default' compute profile is used. Providing a character
value for '.compute' creates a new compute profile with the name
specified. Each compute profile retains its own daemons settings, and may
be operated independently of each other. Some usage examples follow:
</p>
<p><strong>local / remote</strong> daemons may be set with a host URL and specifying
'.compute' as 'remote', which creates a new compute profile. Subsequent
mirai calls may then be sent for local computation by not specifying the
'.compute' argument, or for remote computation to connected daemons by
specifying the '.compute' argument as 'remote'.
</p>
<p><strong>cpu / gpu</strong> some tasks may require access to different types of
daemon, such as those with GPUs. In this case, <code>daemons()</code> may be
called twice to set up host URLs for CPU-only daemons and for those
with GPUs, specifying the '.compute' argument as 'cpu' and 'gpu'
respectively. By supplying the '.compute' argument to subsequent mirai
calls, tasks may be sent to either 'cpu' or 'gpu' daemons as appropriate.
</p>
<p>Note: further actions such as resetting daemons via <code>daemons(0)</code>
should be carried out with the desired '.compute' argument specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# Create 2 local daemons (using dispatcher)
daemons(2)
status()
# Reset to zero
daemons(0)

# Create 2 local daemons (not using dispatcher)
daemons(2, dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

# 2 remote daemons via dispatcher using WebSockets
daemons(2, url = host_url(ws = TRUE))
status()
# Reset to zero
daemons(0)

# Set host URL for remote daemons to dial into
daemons(url = host_url(), dispatcher = FALSE)
status()
# Reset to zero
daemons(0)

}

## Not run: 
# Launch 2 daemons on remotes 'nodeone' and 'nodetwo' using SSH
# connecting back directly to the host URL over a TLS connection:

daemons(url = host_url(tls = TRUE),
        remote = ssh_config(c('ssh://nodeone', 'ssh://nodetwo')),
        dispatcher = FALSE)

# Launch 4 daemons on the remote machine 10.75.32.90 using SSH tunnelling
# over port 5555 ('url' hostname must be 'localhost' or '127.0.0.1'):

daemons(n = 4,
        url = 'ws://localhost:5555',
        remote = ssh_config('ssh://10.75.32.90', tunnel = TRUE))


## End(Not run)

</code></pre>

<hr>
<h2 id='dispatcher'>Dispatcher</h2><span id='topic+dispatcher'></span>

<h3>Description</h3>

<p>Dispatches tasks from a host to daemons for processing, using FIFO
scheduling, queuing tasks as required. Daemon / dispatcher settings
may be controlled by <code><a href="#topic+daemons">daemons</a></code> and this function should not
need to be invoked directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispatcher(
  host,
  url = NULL,
  n = NULL,
  ...,
  asyncdial = FALSE,
  token = FALSE,
  tls = NULL,
  pass = NULL,
  rs = NULL,
  monitor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispatcher_+3A_host">host</code></td>
<td>
<p>the character host URL to dial (where tasks are sent from),
including the port to connect to (and optionally for websockets, a path),
e.g. 'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_url">url</code></td>
<td>
<p>(optional) the character URL or vector of URLs dispatcher should
listen at, including the port to connect to (and optionally for websockets,
a path), e.g. 'tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'.
Specify 'tls+tcp://' or 'wss://' to use secure TLS connections. Tasks are
sent to daemons dialled into these URLs. If not supplied, 'n' local
inter-process URLs will be assigned automatically.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_n">n</code></td>
<td>
<p>(optional) if specified, the integer number of daemons to listen for.
Otherwise 'n' will be inferred from the number of URLs supplied in 'url'.
Where a single URL is supplied and 'n' &gt; 1, 'n' unique URLs will be
automatically assigned for daemons to dial into.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to <code><a href="#topic+daemon">daemon</a></code>.
These include 'autoexit', 'cleanup', 'maxtasks', 'idletime', 'walltime'
and 'timerstart'.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_asyncdial">asyncdial</code></td>
<td>
<p>[default FALSE] whether to perform dials asynchronously. The
default FALSE will error if a connection is not immediately possible
(e.g. <code><a href="#topic+daemons">daemons</a></code> has yet to be called on the host, or the
specified port is not open etc.). Specifying TRUE continues retrying
(indefinitely) if not immediately successful, which is more resilient but
can mask potential connection issues.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_token">token</code></td>
<td>
<p>[default FALSE] if TRUE, appends a unique 24-character token
to each URL path the dispatcher listens at (not applicable for TCP URLs
which do not accept a path).</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_tls">tls</code></td>
<td>
<p>[default NULL] (required for secure TLS connections) <strong>either</strong>
the character path to a file containing the PEM-encoded TLS certificate
and associated private key (may contain additional certificates leading
to a validation chain, with the TLS certificate first), <strong>or</strong> a
length 2 character vector comprising [i] the TLS certificate (optionally
certificate chain) and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_pass">pass</code></td>
<td>
<p>[default NULL] (required only if the private key supplied to 'tls'
is encrypted with a password) For security, should be provided through a
function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_rs">rs</code></td>
<td>
<p>[default NULL] the initial value of .Random.seed. This is set
automatically using L'Ecuyer-CMRG RNG streams generated by the host
process and should not be independently supplied.</p>
</td></tr>
<tr><td><code id="dispatcher_+3A_monitor">monitor</code></td>
<td>
<p>(for package internal use only) do not set this parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network topology is such that a dispatcher acts as a gateway
between the host and daemons, ensuring that tasks received from the host
are dispatched on a FIFO basis for processing. Tasks are queued at the
dispatcher to ensure tasks are only sent to daemons that can begin
immediate execution of the task.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>

<hr>
<h2 id='everywhere'>Evaluate Everywhere</h2><span id='topic+everywhere'></span>

<h3>Description</h3>

<p>Evaluate an expression 'everywhere' on all connected daemons for the
specified compute profile. Designed for performing setup operations
across daemons or exporting common data, resultant changes to the global
environment, loaded packages or options are persisted regardless of a
daemon's 'cleanup' setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>everywhere(.expr, ..., .args = list(), .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="everywhere_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or</strong> a language object passed
by <a href="base.html#topic+name">name</a>.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_...">...</code></td>
<td>
<p>(optional) named arguments (name = value pairs) specifying
objects referenced in '.expr'. Used in addition to, and taking precedence
over, any arguments specified via '.args'.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a list of objects passed by
<a href="base.html#topic+name">name</a> (found in the current scope), <strong>or else</strong> a list of
name = value pairs, as in '...'.</p>
</td></tr>
<tr><td><code id="everywhere_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1)
# export common data by super-assignment:
everywhere(y &lt;&lt;- 3)
# assign explicitly to global environment:
everywhere(list2env(x, envir = .GlobalEnv), x = list(a = 1, b = 2))
m &lt;- mirai(a + b - y == 0L)
call_mirai(m)$data
daemons(0)

daemons(1, dispatcher = FALSE)
everywhere(library(parallel))
m &lt;- mirai("package:parallel" %in% search())
call_mirai(m)$data
daemons(0)

}

</code></pre>

<hr>
<h2 id='host_url'>URL Constructors</h2><span id='topic+host_url'></span><span id='topic+local_url'></span>

<h3>Description</h3>

<p><code>host_url</code> constructs a valid host URL (at which daemons may connect)
based on the computer's hostname. This may be supplied directly to the
'url' argument of <code><a href="#topic+daemons">daemons</a></code>.
</p>
<p><code>local_url</code> constructs a random URL suitable for local daemons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>host_url(ws = FALSE, tls = FALSE, port = 0)

local_url()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="host_url_+3A_ws">ws</code></td>
<td>
<p>[default FALSE] logical value whether to use a WebSockets 'ws://'
or else TCP 'tcp://' scheme.</p>
</td></tr>
<tr><td><code id="host_url_+3A_tls">tls</code></td>
<td>
<p>[default FALSE] logical value whether to use TLS in which case the
scheme used will be either 'wss://' or 'tls+tcp://' accordingly.</p>
</td></tr>
<tr><td><code id="host_url_+3A_port">port</code></td>
<td>
<p>[default 0] numeric port to use. This should be open to
connections from the network addresses the daemons are connecting from.
'0' is a wildcard value that automatically assigns a free ephemeral port.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>host_url</code> relies on using the host name of the computer
rather than an IP address and typically works on local networks, although
this is not always guaranteed. If unsuccessful, substitute an IPv4 or
IPv6 address in place of the hostname.
</p>
<p><code>local_url</code> generates a random URL for the platform's default
inter-process communications transport: abstract Unix domain sockets on
Linux, Unix domain sockets on MacOS, Solaris and other POSIX platforms,
and named pipes on Windows.
</p>


<h3>Value</h3>

<p>A character string comprising a valid URL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>host_url()
host_url(ws = TRUE)
host_url(tls = TRUE)
host_url(ws = TRUE, tls = TRUE, port = 5555)

local_url()

</code></pre>

<hr>
<h2 id='is_mirai'>Is mirai</h2><span id='topic+is_mirai'></span>

<h3>Description</h3>

<p>Is the object a 'mirai'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mirai_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE if 'x' is of class 'mirai', FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

df &lt;- data.frame()
m &lt;- mirai(as.matrix(df), .args = list(df))
is_mirai(m)
is_mirai(df)

}

</code></pre>

<hr>
<h2 id='is_mirai_error'>Error Validators</h2><span id='topic+is_mirai_error'></span><span id='topic+is_mirai_interrupt'></span><span id='topic+is_error_value'></span>

<h3>Description</h3>

<p>Validator functions for error value types created by <span class="pkg">mirai</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mirai_error(x)

is_mirai_interrupt(x)

is_error_value(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mirai_error_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the object a 'miraiError'. When execution in a mirai process
fails, the error message is returned as a character string of class
'miraiError' and 'errorValue'.
</p>
<p>Is the object a 'miraiInterrupt'. When an ongoing mirai is sent a user
interrupt, the mirai will resolve to an empty character string classed as
'miraiInterrupt' and 'errorValue'.
</p>
<p>Is the object an 'errorValue', such as a mirai timeout, a 'miraiError' or
a 'miraiInterrupt'. This is a catch-all condition that includes all
returned error values.
</p>


<h3>Value</h3>

<p>Logical value TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

m &lt;- mirai(stop())
call_mirai(m)
is_mirai_error(m$data)
is_mirai_interrupt(m$data)
is_error_value(m$data)

m2 &lt;- mirai(Sys.sleep(1L), .timeout = 100)
call_mirai(m2)
is_mirai_error(m2$data)
is_mirai_interrupt(m2$data)
is_error_value(m2$data)

}

</code></pre>

<hr>
<h2 id='launch_local'>Launch Daemon</h2><span id='topic+launch_local'></span><span id='topic+launch_remote'></span>

<h3>Description</h3>

<p><code>launch_local</code> spawns a new background <code>Rscript</code> process calling
<code><a href="#topic+daemon">daemon</a></code> with the specified arguments.
</p>
<p><code>launch_remote</code> returns the shell command for deploying daemons as a
character vector. If a configuration generated by <code><a href="#topic+remote_config">remote_config</a></code>
or <code><a href="#topic+ssh_config">ssh_config</a></code> is supplied then this is used to launch the
daemon on the remote machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_local(url, ..., tls = NULL, .compute = "default")

launch_remote(
  url,
  remote = remote_config(),
  ...,
  tls = NULL,
  .compute = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_local_+3A_url">url</code></td>
<td>
<p>the character host URL or vector of host URLs, including the port
to connect to (and optionally for websockets, a path), e.g.
tcp://hostname:5555' or 'ws://10.75.32.70:5555/path'
</p>
<p><strong>or</strong> integer index value, or vector of index values, of the
dispatcher URLs, or 1L for the host URL (when not using dispatcher).
</p>
<p><strong>or</strong> for <code>launch_remote</code> only, a 'miraiCluster' or 'miraiNode'.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments passed through to <code><a href="#topic+daemon">daemon</a></code>.
These include 'autoexit', 'cleanup', 'output', 'maxtasks', 'idletime',
'walltime' and 'timerstart'.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_tls">tls</code></td>
<td>
<p>[default NULL] required for secure TLS connections over tls+tcp or
wss. Zero-configuration TLS certificates generated by <code><a href="#topic+daemons">daemons</a></code>
are automatically passed to the daemon, without requiring to be specified
here. Otherwise, supply <strong>either</strong> the character path to a file
containing X.509 certificate(s) in PEM format, comprising the certificate
authority certificate chain, <strong>or</strong> a length 2 character vector
comprising [i] the certificate authority certificate chain and [ii] the
empty character &rdquo;.</p>
</td></tr>
<tr><td><code id="launch_local_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="launch_local_+3A_remote">remote</code></td>
<td>
<p>required only for launching remote daemons, a configuration
generated by <code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code>. An
empty <code><a href="#topic+remote_config">remote_config</a></code> does not effect any daemon launches but
returns the shell commands for deploying manually on remote machines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions may be used to re-launch daemons that have exited
after reaching time or task limits.
</p>
<p>If daemons have been set, the generated command will automatically
contain the argument 'rs' specifying the length 7 L'Ecuyer-CMRG random
seed supplied to the daemon. The values will be different each time the
function is called.
</p>


<h3>Value</h3>

<p>For <strong>launch_local</strong>: Invisible NULL.
</p>
<p>For <strong>launch_remote</strong>: A character vector of daemon launch
commands, classed as 'miraiLaunchCmd'. The printed output may be directly
copy / pasted to the remote machine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(url = host_url(ws = TRUE), dispatcher = FALSE)
status()
launch_local(status()$daemons, maxtasks = 10L)
launch_remote(1L, maxtasks = 10L)
Sys.sleep(1)
status()
daemons(0)

daemons(n = 2L, url = host_url(tls = TRUE))
status()
launch_local(1:2, idletime = 60000L, timerstart = 1L)
launch_remote(1:2, idletime = 60000L, timerstart = 1L)
Sys.sleep(1)
status()
daemons(0)

}

</code></pre>

<hr>
<h2 id='make_cluster'>Make Mirai Cluster</h2><span id='topic+make_cluster'></span><span id='topic+stop_cluster'></span>

<h3>Description</h3>

<p><code>make_cluster</code> creates a cluster of type 'miraiCluster', which may be
used as a cluster object for any function in the <span class="pkg">parallel</span> base
package such as <code><a href="parallel.html#topic+clusterApply">clusterApply</a></code> or
<code><a href="parallel.html#topic+parLapply">parLapply</a></code>.
</p>
<p><code>stop_cluster</code> stops a cluster created by <code>make_cluster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cluster(n, url = NULL, remote = NULL, ...)

stop_cluster(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cluster_+3A_n">n</code></td>
<td>
<p>integer number of nodes (automatically launched on the local machine
unless 'url' is supplied).</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_url">url</code></td>
<td>
<p>[default NULL] (specify for remote nodes) the character URL on the
host for remote nodes to dial into, including a port accepting incoming
connections, e.g. 'tcp://10.75.37.40:5555'. Specify a URL with the scheme
'tls+tcp://' to use secure TLS connections.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_remote">remote</code></td>
<td>
<p>[default NULL] (specify to launch remote nodes) a remote launch
configuration generated by <code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code>.
If not supplied, nodes may be deployed manually on remote resources.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_...">...</code></td>
<td>
<p>additional arguments passed onto <code><a href="#topic+daemons">daemons</a></code>.</p>
</td></tr>
<tr><td><code id="make_cluster_+3A_cl">cl</code></td>
<td>
<p>a 'miraiCluster'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <strong>make_cluster</strong>: An object of class 'miraiCluster' and
'cluster'. Each 'miraiCluster' has an automatically assigned ID and 'n'
nodes of class 'miraiNode'. If 'url' is supplied but not 'remote', the
shell commands for deployment of nodes on remote resources are printed to
the console.
</p>
<p>For <strong>stop_cluster</strong>: invisible NULL.
</p>


<h3>Remote Nodes</h3>

<p>Specify 'url' and 'n' to set up a host connection for remote nodes to
dial into. 'n' defaults to one if not specified.
</p>
<p>Also specify 'remote' to launch the nodes using a configuration generated
by <code><a href="#topic+remote_config">remote_config</a></code> or <code><a href="#topic+ssh_config">ssh_config</a></code>. In this case,
the number of nodes is inferred from the configuration provided and 'n'
is disregarded.
</p>
<p>If 'remote' is not supplied, the shell commands for deploying nodes
manually on remote resources are automatically printed to the console.
</p>
<p><code><a href="#topic+launch_remote">launch_remote</a></code> may be called at any time on a 'miraiCluster'
to return the shell commands for deployment of all nodes, or on a
'miraiNode' to return the command for a single node.
</p>


<h3>Status</h3>

<p>Call <code><a href="#topic+status">status</a></code> on a 'miraiCluster' to check the number of
currently active connections as well as the host URL.
</p>


<h3>Errors</h3>

<p>Errors are thrown by the 'parallel' mechanism if one or more nodes failed
(quit unexpectedly). The resulting 'errorValue' returned is 19
(Connection reset). Other types of error, e.g. in evaluation, should
result in the usual 'miraiError' being returned.
</p>


<h3>Note</h3>

<p>The default behaviour of clusters created by this function is designed
to map as closely as possible to clusters created by the <span class="pkg">parallel</span>
package. However, '...' arguments are passed onto <code><a href="#topic+daemons">daemons</a></code>
for additional customisation if desired, although resultant behaviour may
not be supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

cl &lt;- make_cluster(2)
cl
cl[[1L]]

Sys.sleep(0.5)
status(cl)

stop_cluster(cl)

}

</code></pre>

<hr>
<h2 id='mirai'>mirai (Evaluate Async)</h2><span id='topic+mirai'></span>

<h3>Description</h3>

<p>Evaluate an expression asynchronously in a new background R process or
persistent daemon (local or remote). This function will return
immediately with a 'mirai', which will resolve to the evaluated result
once complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirai(.expr, ..., .args = list(), .timeout = NULL, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirai_+3A_.expr">.expr</code></td>
<td>
<p>an expression to evaluate asynchronously (of arbitrary length,
wrapped in { } where necessary), <strong>or</strong> a language object passed
by <a href="base.html#topic+name">name</a>.</p>
</td></tr>
<tr><td><code id="mirai_+3A_...">...</code></td>
<td>
<p>(optional) named arguments (name = value pairs) specifying
objects referenced in '.expr'. Used in addition to, and taking precedence
over, any arguments specified via '.args'.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.args">.args</code></td>
<td>
<p>(optional) <strong>either</strong> a list of objects passed by
<a href="base.html#topic+name">name</a> (found in the current scope), <strong>or else</strong> a list of
name = value pairs, as in '...'.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.timeout">.timeout</code></td>
<td>
<p>[default NULL] for no timeout, or an integer value in
milliseconds. A mirai will resolve to an 'errorValue' 5 (timed out) if
evaluation exceeds this limit.</p>
</td></tr>
<tr><td><code id="mirai_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return a 'mirai' object immediately.
</p>
<p>The value of a mirai may be accessed at any time at <code>$data</code>, and
if yet to resolve, an 'unresolved' logical NA will be returned instead.
</p>
<p><code><a href="#topic+unresolved">unresolved</a></code> may be used on a mirai, returning TRUE if a
'mirai' has yet to resolve and FALSE otherwise. This is suitable for use
in control flow statements such as <code>while</code> or <code>if</code>.
</p>
<p>Alternatively, to call (and wait for) the result, use <code><a href="#topic+call_mirai">call_mirai</a></code>
on the returned mirai. This will block until the result is returned.
</p>
<p>The expression '.expr' will be evaluated in a separate R process in a
clean environment, which is not the global environment, consisting only
of the named objects passed as '...' and/or the list supplied to '.args'.
</p>
<p>If an error occurs in evaluation, the error message is returned as a
character string of class 'miraiError' and 'errorValue'.
<code><a href="#topic+is_mirai_error">is_mirai_error</a></code> may be used to test for this.
</p>
<p><code><a href="#topic+is_error_value">is_error_value</a></code> tests for all error conditions including
'mirai' errors, interrupts, and timeouts.
</p>
<p>Specify '.compute' to send the mirai using a specific compute profile (if
previously created by <code><a href="#topic+daemons">daemons</a></code>), otherwise leave as 'default'.
</p>


<h3>Value</h3>

<p>A 'mirai' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

# specifying objects via '...'
n &lt;- 3
m &lt;- mirai(x + y + 2, x = 2, y = n)
m
m$data
Sys.sleep(0.2)
m$data

# passing existing objects by name via '.args'
df1 &lt;- data.frame(a = 1, b = 2)
df2 &lt;- data.frame(a = 3, b = 1)
m &lt;- mirai(as.matrix(rbind(df1, df2)), .args = list(df1, df2), .timeout = 1000)
call_mirai(m)$data

# using unresolved()
m &lt;- mirai(
  {
    res &lt;- rnorm(n)
    res / rev(res)
  },
  n = 1e6
)
while (unresolved(m)) {
  cat("unresolved\n")
  Sys.sleep(0.1)
}
str(m$data)

# evaluating scripts using source(local = TRUE) in '.expr'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
m &lt;- mirai({source(file, local = TRUE); r}, .args = list(file, n))
call_mirai(m)[["data"]]
unlink(file)

# specifying global variables using list2env(envir = .GlobalEnv) in '.expr'
n &lt;- 10L
file &lt;- tempfile()
cat("r &lt;- rnorm(n)", file = file)
globals &lt;- list(file = file, n = n)
m &lt;- mirai(
  {
    list2env(globals, envir = .GlobalEnv)
    source(file)
    r
  },
  globals = globals
)
call_mirai(m)[["data"]]
unlink(file)

# passing a language object to '.expr' and a named list to '.args'
expr &lt;- quote(a + b + 2)
args &lt;- list(a = 2, b = 3)
m &lt;- mirai(.expr = expr, .args = args)
call_mirai(m)$data

}

</code></pre>

<hr>
<h2 id='nextstream'>Next &gt;&gt; Developer Interface</h2><span id='topic+nextstream'></span><span id='topic+nextget'></span>

<h3>Description</h3>

<p><code>nextstream</code> retrieves the currently stored L'Ecuyer-CMRG RNG stream
for the specified compute profile and advances it to the next stream.
</p>
<p><code>nextget</code> retrieves the specified item from the specified compute
profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextstream(.compute = "default")

nextget(x, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextstream_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
<tr><td><code id="nextstream_+3A_x">x</code></td>
<td>
<p>character value of item to retrieve. One of 'pid' (dispatcher
process ID), 'urls' (URLs dispatcher is listening at) or 'tls' (the
stored client TLS configuration for use by daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported for use by packages extending
<a href="https://CRAN.R-project.org/package=mirai"><span class="pkg">mirai</span></a> with alternative launchers of <code><a href="#topic+daemon">daemon</a></code>
processes.
</p>
<p>For <code>nextstream</code>: This function should be called for its return
value when required. The function also has the side effect of
automatically advancing the stream stored within the compute profile.
This ensures that the next recursive stream is returned when the function
is called again.
</p>


<h3>Value</h3>

<p>For <code>nextstream</code>: a length 7 integer vector, as given by
<code>.Random.seed</code> when the L'Ecuyer-CMRG RNG is in use (may be passed
directly to the 'rs' argument of <code><a href="#topic+daemon">daemon</a></code>), or else NULL if a
stream has not yet been created.
</p>
<p>For <code>nextget</code>: the requested item, or else NULL if not present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1L)
nextstream()
nextstream()

nextget("pid")
nextget("urls")

daemons(0)

}

</code></pre>

<hr>
<h2 id='remote_config'>Generic and SSH Remote Launch Configuration</h2><span id='topic+remote_config'></span><span id='topic+ssh_config'></span>

<h3>Description</h3>

<p><code>remote_config</code> provides a flexible generic framework for generating
the shell commands to deploy daemons remotely.
</p>
<p><code>ssh_config</code> generates a remote configuration for launching daemons over
SSH, with the option of SSH tunnelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remote_config(command = NULL, args = c("", "."), rscript = "Rscript")

ssh_config(
  remotes,
  timeout = 10,
  tunnel = FALSE,
  command = "ssh",
  rscript = "Rscript"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remote_config_+3A_command">command</code></td>
<td>
<p>the command used to effect the daemon launch on the remote
machine as a character string (e.g. <code>'ssh'</code>). Defaults to 'ssh' for
<code>ssh_config</code>, although may be substituted for the full path to a
specific SSH application. The default NULL for <code>remote_config</code> does
not effect any launches, but causes <code><a href="#topic+launch_remote">launch_remote</a></code> to return
the shell commands for manual deployment on remote machines.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_args">args</code></td>
<td>
<p>(optional) arguments passed to 'command', as a character vector
that must include <code>"."</code> as an element, which will be substituted
for the daemon launch command. Alternatively, a list of such character
vectors to effect multiple launches (one for each list element).</p>
</td></tr>
<tr><td><code id="remote_config_+3A_rscript">rscript</code></td>
<td>
<p>(optional) name / path of the Rscript executable on the remote
machine. The default assumes 'Rscript' is on the executable search path.
Prepend the full path if necessary. If launching on Windows, 'Rscript'
should be replaced with 'Rscript.exe'.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_remotes">remotes</code></td>
<td>
<p>the character URL or vector of URLs to SSH into, using the
'ssh://' scheme and including the port open for SSH connections (defaults
to 22 if not specified), e.g. 'ssh://10.75.32.90:22' or 'ssh://nodename'.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_timeout">timeout</code></td>
<td>
<p>[default 10] maximum time allowed for connection setup in
seconds.</p>
</td></tr>
<tr><td><code id="remote_config_+3A_tunnel">tunnel</code></td>
<td>
<p>[default FALSE] logical value whether to use SSH reverse
tunnelling. If TRUE, a tunnel is created between the same ports (as
specified in 'url') on the local and remote machines. Setting to TRUE
requires access to 'url' in the evaluation context and will error if not
called from a relevant function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in the required format to be supplied to the 'remote' argument
of <code><a href="#topic+launch_remote">launch_remote</a></code>, <code><a href="#topic+daemons">daemons</a></code>, or <code><a href="#topic+make_cluster">make_cluster</a></code>.
</p>


<h3>SSH Direct Connections</h3>

<p>The simplest use of SSH is to execute the daemon launch command on a
remote machine, for it to dial back to the host / dispatcher URL.
</p>
<p>It is assumed that SSH key-based authentication is already in place. The
relevant port on the host must also be open to inbound connections from
the remote machine.
</p>


<h3>SSH Tunnelling</h3>

<p>Use of SSH tunnelling provides a convenient way to launch remote nodes
without requiring the remote machine to be able to access the host.
Often firewall configurations or security policies may prevent opening a
port to accept outside connections.
</p>
<p>In these cases SSH tunnelling offers a solution by creating a tunnel once
the initial SSH connection is made. For simplicity, this SSH tunnelling
implementation uses the same port on both the side of the host and that
of the corresponding node. SSH key-based authentication must also already
be in place.
</p>
<p>Tunnelling requires the hostname for 'url' specified when setting up
<code><a href="#topic+daemons">daemons</a></code> to be either '127.0.0.1' or 'localhost'. This is as
the tunnel is created between <code>127.0.0.1:port</code> or equivalently
<code>localhost:port</code> on each machine. The host listens to <code>port</code> on
its machine and the remotes each dial into <code>port</code> on their own
respective machines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>remote_config(command = "ssh", args = c("-fTp 22 10.75.32.90", "."))

ssh_config(remotes = c("ssh://10.75.32.90:222", "ssh://nodename"), timeout = 5)

## Not run: 

# launch 2 daemons on the remote machines 10.75.32.90 and 10.75.32.91 using
# SSH, connecting back directly to the host URL over a TLS connection:

daemons(
  url = host_url(tls = TRUE),
  remote = ssh_config(
    remotes = c("ssh://10.75.32.90:222", "ssh://10.75.32.91:222"),
    timeout = 1
  )
)

# launch 2 nodes on the remote machine 10.75.32.90 using SSH tunnelling over
# port 5555 ('url' hostname must be 'localhost' or '127.0.0.1'):

cl &lt;- make_cluster(
  url = "tcp://localhost:5555",
  remote = ssh_config(
    remotes = c("ssh://10.75.32.90", "ssh://10.75.32.90"),
    timeout = 1,
    tunnel = TRUE
  )
)

## End(Not run)

</code></pre>

<hr>
<h2 id='saisei'>Saisei (Regenerate Token)</h2><span id='topic+saisei'></span>

<h3>Description</h3>

<p>When using daemons with dispatcher, regenerates the token for the URL a
dispatcher socket listens at.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saisei(i, force = FALSE, .compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saisei_+3A_i">i</code></td>
<td>
<p>integer index number URL to regenerate at dispatcher.</p>
</td></tr>
<tr><td><code id="saisei_+3A_force">force</code></td>
<td>
<p>[default FALSE] logical value whether to regenerate the URL even
when there is an existing active connection.</p>
</td></tr>
<tr><td><code id="saisei_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character value for the compute profile
to use (each compute profile has its own independent set of daemons).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a URL is regenerated, the listener at the specified socket is
closed and replaced immediately, hence this function will only be
successful if there are no existing connections at the socket (i.e.
'online' status shows 0), unless the argument 'force' is specified as TRUE.
</p>
<p>If 'force' is specified as TRUE, the socket is immediately closed and
regenerated. If this happens while a mirai is still ongoing, it will be
returned as an errorValue 7 'Object closed'. This may be used to cancel a
task that consistently hangs or crashes to prevent it from failing
repeatedly when new daemons connect.
</p>


<h3>Value</h3>

<p>The regenerated character URL upon success, or else NULL.
</p>


<h3>Timeouts</h3>

<p>Specifying the '.timeout' argument to <code><a href="#topic+mirai">mirai</a></code> ensures that
the 'mirai' always resolves. However, the task may not have completed and
still be ongoing in the daemon process. In such situations, dispatcher
ensures that queued tasks are not assigned to the busy process, however
overall performance may still be degraded if they remain in use.
</p>
<p>If a process hangs and cannot be restarted otherwise, <code>saisei</code>
specifying <code>force = TRUE</code> may be used to cancel the task and
regenerate any particular URL for a new <code><a href="#topic+daemon">daemon</a></code> to connect
to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

daemons(1L)
Sys.sleep(1L)
status()
saisei(i = 1L, force = TRUE)
status()

daemons(0)

}

</code></pre>

<hr>
<h2 id='serialization'>Custom Serialization Functions</h2><span id='topic+serialization'></span>

<h3>Description</h3>

<p>Registers custom serialization and unserialization functions for sending and
receiving external pointer reference objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialization(refhook = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialization_+3A_refhook">refhook</code></td>
<td>
<p><strong>either</strong> a list or pairlist of two functions: the
signature for the first must accept a list of external pointer type
objects and return a raw vector, e.g. <code>torch::torch_serialize</code>, and
the second must accept a raw vector and return a list of external pointer
type objects, e.g. <code>torch::torch_load</code>,<br /> <strong>or else</strong> NULL to
reset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling without any arguments returns the pairlist of
currently-registered 'refhook' functions.
</p>
<p>This function may be called prior to or after setting daemons, with the
registered functions applying across all compute profiles.
</p>


<h3>Value</h3>

<p>Invisibly, the pairlist of currently-registered 'refhook' functions.
A message is printed to the console when functions are successfully
registered or reset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- serialization(list(function(x) serialize(x, NULL), unserialize))
print(serialization())
serialization(r)

serialization(NULL)
print(serialization())

</code></pre>

<hr>
<h2 id='status'>Status Information</h2><span id='topic+status'></span>

<h3>Description</h3>

<p>Retrieve status information for the specified compute profile, comprising
current connections and daemons status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(.compute = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_.compute">.compute</code></td>
<td>
<p>[default 'default'] character compute profile (each compute
profile has its own set of daemons for connecting to different resources).
</p>
<p><strong>or</strong> a 'miraiCluster' to obtain its status.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list comprising:
</p>

<ul>
<li> <p><strong>connections</strong> - integer number of active connections.
<br /> Using dispatcher: Always 1L as there is a single connection to
dispatcher, which connects to the daemons in turn.
</p>
</li>
<li> <p><strong>daemons</strong> - of variable type.
<br /> Using dispatcher: a status matrix (see Status Matrix section below),
or else an integer 'errorValue' if communication with dispatcher failed.
<br /> Not using dispatcher: the character host URL.
<br /> Not set: 0L.
</p>
</li></ul>



<h3>Status Matrix</h3>

<p>When using dispatcher, <code>$daemons</code> comprises an integer matrix with
the following columns:
</p>

<ul>
<li> <p><strong>i</strong> - integer index number.
</p>
</li>
<li> <p><strong>online</strong> - shows as 1 when there is an active connection,
or else 0 if a daemon has yet to connect or has disconnected.
</p>
</li>
<li> <p><strong>instance</strong> - increments by 1 every time there is a new
connection at a URL. This counter is designed to track new daemon
instances connecting after previous ones have ended (due to time-outs
etc.). The count becomes negative immediately after a URL is regenerated
by <code><a href="#topic+saisei">saisei</a></code>, but increments again once a new daemon connects.
</p>
</li>
<li> <p><strong>assigned</strong> - shows the cumulative number of tasks assigned
to the daemon.
</p>
</li>
<li> <p><strong>complete</strong> - shows the cumulative number of tasks
completed by the daemon.
</p>
</li></ul>

<p>The dispatcher URLs are stored as row names to the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

status()
daemons(n = 2L, url = "wss://[::1]:0")
status()
daemons(0)

}

</code></pre>

<hr>
<h2 id='stop_mirai'>mirai (Stop Evaluation)</h2><span id='topic+stop_mirai'></span>

<h3>Description</h3>

<p>Stop evaluation of a mirai that is in progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_mirai(aio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_mirai_+3A_aio">aio</code></td>
<td>
<p>a 'mirai' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stops the asynchronous operation associated with the mirai by
aborting, and then waits for it to complete or to be completely aborted.
The mirai is then deallocated and attempting to access the value at
<code>$data</code> will result in an error.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

s &lt;- mirai(Sys.sleep(n), n = 5)
stop_mirai(s)

}

</code></pre>

<hr>
<h2 id='unresolved'>Query if a mirai is Unresolved</h2><span id='topic+unresolved'></span>

<h3>Description</h3>

<p>Query whether a mirai or mirai value remains unresolved. Unlike
<code><a href="#topic+call_mirai">call_mirai</a></code>, this function does not wait for completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unresolved(aio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unresolved_+3A_aio">aio</code></td>
<td>
<p>a 'mirai' object or 'mirai' value stored at <code>$data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable for use in control flow statements such as <code>while</code> or
<code>if</code>.
</p>
<p>Note: querying resolution may cause a previously unresolved 'mirai' to
resolve.
</p>


<h3>Value</h3>

<p>Logical TRUE if 'aio' is an unresolved mirai or mirai value, or
FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# Only run examples in interactive R sessions

m &lt;- mirai(Sys.sleep(0.1))
unresolved(m)
Sys.sleep(0.3)
unresolved(m)

}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
