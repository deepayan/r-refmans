<!DOCTYPE html><html><head><title>Help for package batchtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {batchtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addAlgorithm'><p>Define Algorithms for Experiments</p></a></li>
<li><a href='#addExperiments'><p>Add Experiments to the Registry</p></a></li>
<li><a href='#addProblem'><p>Define Problems for Experiments</p></a></li>
<li><a href='#assertRegistry'><p>assertRegistry</p></a></li>
<li><a href='#batchExport'><p>Export Objects to the Slaves</p></a></li>
<li><a href='#batchMap'><p>Map Operation for Batch Systems</p></a></li>
<li><a href='#batchMapResults'><p>Map Over Results to Create New Jobs</p></a></li>
<li><a href='#batchReduce'><p>Reduce Operation for Batch Systems</p></a></li>
<li><a href='#batchtools-package'><p>batchtools: Tools for Computation on Batch Systems</p></a></li>
<li><a href='#btlapply'><p>Synchronous Apply Functions</p></a></li>
<li><a href='#cfBrewTemplate'><p>Cluster Functions Helper to Write Job Description Files</p></a></li>
<li><a href='#cfHandleUnknownSubmitError'><p>Cluster Functions Helper to Handle Unknown Errors</p></a></li>
<li><a href='#cfKillJob'><p>Cluster Functions Helper to Kill Batch Jobs</p></a></li>
<li><a href='#cfReadBrewTemplate'><p>Cluster Functions Helper to Parse a Brew Template</p></a></li>
<li><a href='#chunk'><p>Chunk Jobs for Sequential Execution</p></a></li>
<li><a href='#clearRegistry'><p>Remove All Jobs</p></a></li>
<li><a href='#doJobCollection'><p>Execute Jobs of a JobCollection</p></a></li>
<li><a href='#estimateRuntimes'><p>Estimate Remaining Runtimes</p></a></li>
<li><a href='#execJob'><p>Execute a Single Jobs</p></a></li>
<li><a href='#findConfFile'><p>Find a batchtools Configuration File</p></a></li>
<li><a href='#findJobs'><p>Find and Filter Jobs</p></a></li>
<li><a href='#findTemplateFile'><p>Find a batchtools Template File</p></a></li>
<li><a href='#getDefaultRegistry'><p>Get and Set the Default Registry</p></a></li>
<li><a href='#getErrorMessages'><p>Retrieve Error Messages</p></a></li>
<li><a href='#getJobTable'><p>Query Job Information</p></a></li>
<li><a href='#getStatus'><p>Summarize the Computational Status</p></a></li>
<li><a href='#grepLogs'><p>Grep Log Files for a Pattern</p></a></li>
<li><a href='#JobNames'><p>Set and Retrieve Job Names</p></a></li>
<li><a href='#JoinTables'><p>Inner, Left, Right, Outer, Semi and Anti Join for Data Tables</p></a></li>
<li><a href='#killJobs'><p>Kill Jobs</p></a></li>
<li><a href='#loadRegistry'><p>Load a Registry from the File System</p></a></li>
<li><a href='#loadResult'><p>Load the Result of a Single Job</p></a></li>
<li><a href='#makeClusterFunctions'><p>ClusterFunctions Constructor</p></a></li>
<li><a href='#makeClusterFunctionsDocker'><p>ClusterFunctions for Docker</p></a></li>
<li><a href='#makeClusterFunctionsInteractive'><p>ClusterFunctions for Sequential Execution in the Running R Session</p></a></li>
<li><a href='#makeClusterFunctionsLSF'><p>ClusterFunctions for LSF Systems</p></a></li>
<li><a href='#makeClusterFunctionsMulticore'><p>ClusterFunctions for Parallel Multicore Execution</p></a></li>
<li><a href='#makeClusterFunctionsOpenLava'><p>ClusterFunctions for OpenLava</p></a></li>
<li><a href='#makeClusterFunctionsSGE'><p>ClusterFunctions for SGE Systems</p></a></li>
<li><a href='#makeClusterFunctionsSlurm'><p>ClusterFunctions for Slurm Systems</p></a></li>
<li><a href='#makeClusterFunctionsSocket'><p>ClusterFunctions for Parallel Socket Execution</p></a></li>
<li><a href='#makeClusterFunctionsSSH'><p>ClusterFunctions for Remote SSH Execution</p></a></li>
<li><a href='#makeClusterFunctionsTORQUE'><p>ClusterFunctions for OpenPBS/TORQUE Systems</p></a></li>
<li><a href='#makeExperimentRegistry'><p>ExperimentRegistry Constructor</p></a></li>
<li><a href='#makeJob'><p>Jobs and Experiments</p></a></li>
<li><a href='#makeJobCollection'><p>JobCollection Constructor</p></a></li>
<li><a href='#makeRegistry'><p>Registry Constructor</p></a></li>
<li><a href='#makeSubmitJobResult'><p>Create a SubmitJobResult</p></a></li>
<li><a href='#reduceResults'><p>Reduce Results</p></a></li>
<li><a href='#reduceResultsList'><p>Apply Functions on Results</p></a></li>
<li><a href='#removeExperiments'><p>Remove Experiments</p></a></li>
<li><a href='#removeRegistry'><p>Remove a Registry from the File System</p></a></li>
<li><a href='#resetJobs'><p>Reset the Computational State of Jobs</p></a></li>
<li><a href='#runHook'><p>Trigger Evaluation of Custom Function</p></a></li>
<li><a href='#runOSCommand'><p>Run OS Commands on Local or Remote Machines</p></a></li>
<li><a href='#saveRegistry'><p>Store the Registy to the File System</p></a></li>
<li><a href='#showLog'><p>Inspect Log Files</p></a></li>
<li><a href='#submitJobs'><p>Submit Jobs to the Batch Systems</p></a></li>
<li><a href='#summarizeExperiments'><p>Quick Summary over Experiments</p></a></li>
<li><a href='#sweepRegistry'><p>Check Consistency and Remove Obsolete Information</p></a></li>
<li><a href='#syncRegistry'><p>Synchronize the Registry</p></a></li>
<li><a href='#Tags'><p>Add or Remove Job Tags</p></a></li>
<li><a href='#testJob'><p>Run Jobs Interactively</p></a></li>
<li><a href='#unwrap'><p>Unwrap Nested Data Frames</p></a></li>
<li><a href='#waitForJobs'><p>Wait for Termination of Jobs</p></a></li>
<li><a href='#Worker'><p>Create a Linux-Worker</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Computation on Batch Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.17</td>
</tr>
<tr>
<td>Description:</td>
<td>As a successor of the packages 'BatchJobs' and 'BatchExperiments',
    this package provides a parallel implementation of the Map function for high
    performance computing systems managed by schedulers 'IBM Spectrum LSF'
    (<a href="https://www.ibm.com/products/hpc-workload-management">https://www.ibm.com/products/hpc-workload-management</a>),
    'OpenLava' (<a href="https://www.openlava.org/">https://www.openlava.org/</a>), 'Univa Grid Engine'/'Oracle Grid
    Engine' (<a href="https://www.univa.com/">https://www.univa.com/</a>), 'Slurm' (<a href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</a>),
    'TORQUE/PBS'
    (<a href="https://adaptivecomputing.com/cherry-services/torque-resource-manager/">https://adaptivecomputing.com/cherry-services/torque-resource-manager/</a>),
    or 'Docker Swarm' (<a href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a>).
    A multicore and socket mode allow the parallelization on a local machines,
    and multiple machines can be hooked up via SSH to create a makeshift
    cluster. Moreover, the package provides an abstraction mechanism to define
    large-scale computer experiments in a well-organized and reproducible way.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mllg/batchtools">https://github.com/mllg/batchtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mllg/batchtools/issues">https://github.com/mllg/batchtools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports (&ge; 1.1.2), base64url (&ge; 1.1), brew, checkmate (&ge;
1.8.5), data.table (&ge; 1.11.2), digest (&ge; 0.6.9), fs (&ge;
1.2.0), parallel, progress (&ge; 1.1.1), R6, rappdirs, stats,
stringi, utils, withr (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>debugme, doParallel, doMPI, e1071, foreach, future,
future.batchtools, knitr, parallelMap, ranger, rmarkdown,
rpart, snow, testthat, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-20 11:51:42 UTC; michel</td>
</tr>
<tr>
<td>Author:</td>
<td>Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Bernd Bischl [aut],
  Dirk Surmann <a href="https://orcid.org/0000-0003-0873-137X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michel Lang &lt;michellang@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-20 14:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='addAlgorithm'>Define Algorithms for Experiments</h2><span id='topic+addAlgorithm'></span><span id='topic+Algorithm'></span><span id='topic+removeAlgorithms'></span>

<h3>Description</h3>

<p>Algorithms are functions which get the codedata part as well as the problem instance (the return value of the
function defined in <code><a href="#topic+Problem">Problem</a></code>) and return an arbitrary R object.
</p>
<p>This function serializes all components to the file system and registers the algorithm in the <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.
</p>
<p><code>removeAlgorithm</code> removes all jobs from the registry which depend on the specific algorithm.
<code>reg$algorithms</code> holds the IDs of already defined algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAlgorithm(name, fun = NULL, reg = getDefaultRegistry())

removeAlgorithms(name, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAlgorithm_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Unique identifier for the algorithm.</p>
</td></tr>
<tr><td><code id="addAlgorithm_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
The algorithm function. The static problem part is passed as &ldquo;data&rdquo;, the generated
problem instance is passed as &ldquo;instance&rdquo; and the <code><a href="#topic+Job">Job</a></code>/<code><a href="#topic+Experiment">Experiment</a></code> as &ldquo;job&rdquo;.
Therefore, your function must have the formal arguments &ldquo;job&rdquo;, &ldquo;data&rdquo; and &ldquo;instance&rdquo; (or dots <code>...</code>).
</p>
<p>If you do not provide a function, it defaults to a function which just returns the instance.</p>
</td></tr>
<tr><td><code id="addAlgorithm_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>]<br />
Registry. If not explicitly passed, uses the last created registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>Algorithm</code>]. Object of class &ldquo;Algorithm&rdquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Problem">Problem</a></code>, <code><a href="#topic+addExperiments">addExperiments</a></code>
</p>

<hr>
<h2 id='addExperiments'>Add Experiments to the Registry</h2><span id='topic+addExperiments'></span>

<h3>Description</h3>

<p>Adds experiments (parametrized combinations of problems with algorithms) to the registry and thereby defines batch jobs.
</p>
<p>If multiple problem designs or algorithm designs are provided, they are combined via the Cartesian product.
E.g., if you have two problems <code>p1</code> and <code>p2</code> and three algorithms <code>a1</code>, <code>a2</code> and <code>a3</code>,
<code>addExperiments</code> creates experiments for all parameters for the combinations <code>(p1, a1)</code>, <code>(p1, a2)</code>,
<code>(p1, a3)</code>, <code>(p2, a1)</code>, <code>(p2, a2)</code> and <code>(p2, a3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addExperiments(
  prob.designs = NULL,
  algo.designs = NULL,
  repls = 1L,
  combine = "crossprod",
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addExperiments_+3A_prob.designs">prob.designs</code></td>
<td>
<p>[named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>]<br />
Named list of data frames (or <code><a href="data.table.html#topic+data.table">data.table</a></code>).
The name must match the problem name while the column names correspond to parameters of the problem.
If <code>NULL</code>, experiments for all defined problems without any parameters are added.</p>
</td></tr>
<tr><td><code id="addExperiments_+3A_algo.designs">algo.designs</code></td>
<td>
<p>[named list of <code><a href="data.table.html#topic+data.table">data.table</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>]<br />
Named list of data frames (or <code><a href="data.table.html#topic+data.table">data.table</a></code>).
The name must match the algorithm name while the column names correspond to parameters of the algorithm.
If <code>NULL</code>, experiments for all defined algorithms without any parameters are added.</p>
</td></tr>
<tr><td><code id="addExperiments_+3A_repls">repls</code></td>
<td>
<p>[<code>integer()</code>]<br />
Number of replications for each problem design in 'prob.designs' (automatically replicated to
the correct length).</p>
</td></tr>
<tr><td><code id="addExperiments_+3A_combine">combine</code></td>
<td>
<p>[<code>character(1)</code>]<br />
How to combine the rows of a single problem design with the rows of a single algorithm design?
Default is &ldquo;crossprod&rdquo; which combines each row of the problem design which each row of the algorithm design
in a cross-product fashion. Set to &ldquo;bind&rdquo; to just <code><a href="base.html#topic+cbind">cbind</a></code> the tables of
problem and algorithm designs where the shorter table is repeated if necessary.</p>
</td></tr>
<tr><td><code id="addExperiments_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>]<br />
Registry. If not explicitly passed, uses the last created registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with ids of added jobs stored in column &ldquo;job.id&rdquo;.
</p>


<h3>Note</h3>

<p>R's <code>data.frame</code> converts character vectors to factors by default in R versions prior to 4.0.0 which frequently resulted in problems using <code>addExperiments</code>.
Therefore, this function will warn about factor variables if the following conditions hold:
</p>

<ol>
<li><p> R version is &lt; 4.0.0
</p>
</li>
<li><p> The design is passed as a <code>data.frame</code>, not a <code><a href="data.table.html#topic+data.table">data.table</a></code> or <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>
</li>
<li><p> The option &ldquo;stringsAsFactors&rdquo; is not set or set to <code>TRUE</code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Experiment: 
<code><a href="#topic+removeExperiments">removeExperiments</a>()</code>,
<code><a href="#topic+summarizeExperiments">summarizeExperiments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE)

# add first problem
fun = function(job, data, n, mean, sd, ...) rnorm(n, mean = mean, sd = sd)
addProblem("rnorm", fun = fun, reg = tmp)

# add second problem
fun = function(job, data, n, lambda, ...) rexp(n, rate = lambda)
addProblem("rexp", fun = fun, reg = tmp)

# add first algorithm
fun = function(instance, method, ...) if (method == "mean") mean(instance) else median(instance)
addAlgorithm("average", fun = fun, reg = tmp)

# add second algorithm
fun = function(instance, ...) sd(instance)
addAlgorithm("deviation", fun = fun, reg = tmp)

# define problem and algorithm designs
library(data.table)
prob.designs = algo.designs = list()
prob.designs$rnorm = CJ(n = 100, mean = -1:1, sd = 1:5)
prob.designs$rexp = data.table(n = 100, lambda = 1:5)
algo.designs$average = data.table(method = c("mean", "median"))
algo.designs$deviation = data.table()

# add experiments and submit
addExperiments(prob.designs, algo.designs, reg = tmp)

# check what has been created
summarizeExperiments(reg = tmp)
unwrap(getJobPars(reg = tmp))
</code></pre>

<hr>
<h2 id='addProblem'>Define Problems for Experiments</h2><span id='topic+addProblem'></span><span id='topic+Problem'></span><span id='topic+removeProblems'></span>

<h3>Description</h3>

<p>Problems may consist of up to two parts: A static, immutable part (<code>data</code> in <code>addProblem</code>)
and a dynamic, stochastic part (<code>fun</code> in <code>addProblem</code>).
For example, for statistical learning problems a data frame would be the static problem part while
a resampling function would be the stochastic part which creates problem instance.
This instance is then typically passed to a learning algorithm like a wrapper around a statistical model
(<code>fun</code> in <code><a href="#topic+addAlgorithm">addAlgorithm</a></code>).
</p>
<p>This function serialize all components to the file system and registers the problem in the <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.
</p>
<p><code>removeProblem</code> removes all jobs from the registry which depend on the specific problem.
<code>reg$problems</code> holds the IDs of already defined problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addProblem(
  name,
  data = NULL,
  fun = NULL,
  seed = NULL,
  cache = FALSE,
  reg = getDefaultRegistry()
)

removeProblems(name, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addProblem_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Unique identifier for the problem.</p>
</td></tr>
<tr><td><code id="addProblem_+3A_data">data</code></td>
<td>
<p>[<code>ANY</code>]<br />
Static problem part. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="addProblem_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
The function defining the stochastic problem part.
The static part is passed to this function with name &ldquo;data&rdquo; and the <code><a href="#topic+Job">Job</a></code>/<code><a href="#topic+Experiment">Experiment</a></code>
is passed as &ldquo;job&rdquo;.
Therefore, your function must have the formal arguments &ldquo;job&rdquo; and &ldquo;data&rdquo; (or dots <code>...</code>).
If you do not provide a function, it defaults to a function which just returns the data part.</p>
</td></tr>
<tr><td><code id="addProblem_+3A_seed">seed</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Start seed for this problem. This allows the &ldquo;synchronization&rdquo; of a stochastic
problem across algorithms, so that different algorithms are evaluated on the same stochastic instance.
If the problem seed is defined, the seeding mechanism works as follows:
(1) Before the dynamic part of a problem is instantiated,
the seed of the problem + [replication number] - 1 is set, i.e. the first
replication uses the problem seed. (2) The stochastic part of the problem is
instantiated. (3) From now on the usual experiment seed of the registry is used,
see <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.
If <code>seed</code> is set to <code>NULL</code> (default), the job seed is used to instantiate the problem and
different algorithms see different stochastic instances of the same problem.</p>
</td></tr>
<tr><td><code id="addProblem_+3A_cache">cache</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code> and <code>seed</code> is set, problem instances will be cached on the file system.
This assumes that each problem instance is deterministic for each combination of hyperparameter setting
and each replication number.
This feature is experimental.</p>
</td></tr>
<tr><td><code id="addProblem_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>]<br />
Registry. If not explicitly passed, uses the last created registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>Problem</code>]. Object of class &ldquo;Problem&rdquo; (invisibly).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Algorithm">Algorithm</a></code>, <code><a href="#topic+addExperiments">addExperiments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE)
addProblem("p1", fun = function(job, data) data, reg = tmp)
addProblem("p2", fun = function(job, data) job, reg = tmp)
addAlgorithm("a1", fun = function(job, data, instance) instance, reg = tmp)
addExperiments(repls = 2, reg = tmp)

# List problems, algorithms and job parameters:
tmp$problems
tmp$algorithms
getJobPars(reg = tmp)

# Remove one problem
removeProblems("p1", reg = tmp)

# List problems and algorithms:
tmp$problems
tmp$algorithms
getJobPars(reg = tmp)
</code></pre>

<hr>
<h2 id='assertRegistry'>assertRegistry</h2><span id='topic+assertRegistry'></span>

<h3>Description</h3>

<p>Assert that a given object is a <code>batchtools</code> registry.
Additionally can sync the registry, check if it is writeable, or check if jobs are running.
If any check fails, throws an error indicting the reason for the failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertRegistry(
  reg,
  class = NULL,
  writeable = FALSE,
  sync = FALSE,
  running.ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assertRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
The object asserted to be a <code>Registry</code>.</p>
</td></tr>
<tr><td><code id="assertRegistry_+3A_class">class</code></td>
<td>
<p>[<code>character(1)</code>]<br />
If <code>NULL</code> (default), <code>reg</code> must only inherit from class &ldquo;Registry&rdquo;.
Otherwise check that <code>reg</code> is of class <code>class</code>.
E.g., if set to &ldquo;Registry&rdquo;, a <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code> would not pass.</p>
</td></tr>
<tr><td><code id="assertRegistry_+3A_writeable">writeable</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Check if the registry is writeable.</p>
</td></tr>
<tr><td><code id="assertRegistry_+3A_sync">sync</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Try to synchronize the registry by including pending results from the file system.
See <code><a href="#topic+syncRegistry">syncRegistry</a></code>.</p>
</td></tr>
<tr><td><code id="assertRegistry_+3A_running.ok">running.ok</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>FALSE</code> throw an error if jobs associated with the registry are currently running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> invisibly.
</p>

<hr>
<h2 id='batchExport'>Export Objects to the Slaves</h2><span id='topic+batchExport'></span>

<h3>Description</h3>

<p>Objects are saved in subdirectory &ldquo;exports&rdquo; of the
&ldquo;file.dir&rdquo; of <code>reg</code>.
They are automatically loaded and placed in the global environment
each time the registry is loaded or a job collection is executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchExport(
  export = list(),
  unexport = character(0L),
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchExport_+3A_export">export</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of objects to export.</p>
</td></tr>
<tr><td><code id="batchExport_+3A_unexport">unexport</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of object names to unexport.</p>
</td></tr>
<tr><td><code id="batchExport_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>data.table</code>] with name and uri to the exported objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)

# list exports
exports = batchExport(reg = tmp)
print(exports)

# add a job and required exports
batchMap(function(x) x^2 + y + z, x = 1:3, reg = tmp)
exports = batchExport(export = list(y = 99, z = 1), reg = tmp)
print(exports)

submitJobs(reg = tmp)
waitForJobs(reg = tmp)
stopifnot(loadResult(1, reg = tmp) == 101)

# Un-export z
exports = batchExport(unexport = "z", reg = tmp)
print(exports)
</code></pre>

<hr>
<h2 id='batchMap'>Map Operation for Batch Systems</h2><span id='topic+batchMap'></span>

<h3>Description</h3>

<p>A parallel and asynchronous <code><a href="base.html#topic+Map">Map</a></code>/<code><a href="base.html#topic+mapply">mapply</a></code> for batch systems.
Note that this function only defines the computational jobs.
The actual computation is started with <code><a href="#topic+submitJobs">submitJobs</a></code>.
Results and partial results can be collected with <code><a href="#topic+reduceResultsList">reduceResultsList</a></code>, <code><a href="#topic+reduceResults">reduceResults</a></code> or
<code><a href="#topic+loadResult">loadResult</a></code>.
</p>
<p>For a synchronous <code><a href="base.html#topic+Map">Map</a></code>-like execution, see <code><a href="#topic+btmapply">btmapply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMap(
  fun,
  ...,
  args = list(),
  more.args = list(),
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMap_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function to map over arguments provided via <code>...</code>.
Parameters given via <code>args</code> or <code>...</code> are passed as-is, in the respective order and possibly named.
If the function has the named formal argument &ldquo;.job&rdquo;, the <code><a href="#topic+Job">Job</a></code> is passed to the function
on the slave.</p>
</td></tr>
<tr><td><code id="batchMap_+3A_...">...</code></td>
<td>
<p>[ANY]<br />
Arguments to vectorize over (list or vector).
Shorter vectors will be recycled (possibly with a warning any length is not a multiple of the longest length).
Mutually exclusive with <code>args</code>.
Note that although it is possible to iterate over large objects (e.g., lists of data frames or matrices), this usually
hurts the overall performance and thus is discouraged.</p>
</td></tr>
<tr><td><code id="batchMap_+3A_args">args</code></td>
<td>
<p>[<code>list</code> | <code>data.frame</code>]<br />
Arguments to vectorize over as (named) list or data frame.
Shorter vectors will be recycled (possibly with a warning any length is not a multiple of the longest length).
Mutually exclusive with <code>...</code>.</p>
</td></tr>
<tr><td><code id="batchMap_+3A_more.args">more.args</code></td>
<td>
<p>[<code>list</code>]<br />
A list of further arguments passed to <code>fun</code>.
Default is an empty list.</p>
</td></tr>
<tr><td><code id="batchMap_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with ids of added jobs stored in column &ldquo;job.id&rdquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+batchReduce">batchReduce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example using "..." and more.args
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
f = function(x, y) x^2 + y
ids = batchMap(f, x = 1:10, more.args = list(y = 100), reg = tmp)
getJobPars(reg = tmp)
testJob(6, reg = tmp) # 100 + 6^2 = 136

# vector recycling
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
f = function(...) list(...)
ids = batchMap(f, x = 1:3, y = 1:6, reg = tmp)
getJobPars(reg = tmp)

# example for an expand.grid()-like operation on parameters
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
ids = batchMap(paste, args = data.table::CJ(x = letters[1:3], y = 1:3), reg = tmp)
getJobPars(reg = tmp)
testJob(6, reg = tmp)
</code></pre>

<hr>
<h2 id='batchMapResults'>Map Over Results to Create New Jobs</h2><span id='topic+batchMapResults'></span>

<h3>Description</h3>

<p>This function allows you to create new computational jobs (just like <code><a href="#topic+batchMap">batchMap</a></code> based on the results of
a <code><a href="#topic+Registry">Registry</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMapResults(
  fun,
  ids = NULL,
  ...,
  more.args = list(),
  target,
  source = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMapResults_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function which takes the result as first (unnamed) argument.</p>
</td></tr>
<tr><td><code id="batchMapResults_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findDone">findDone</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="batchMapResults_+3A_...">...</code></td>
<td>
<p>[ANY]<br />
Arguments to vectorize over (list or vector). Passed to <code><a href="#topic+batchMap">batchMap</a></code>.</p>
</td></tr>
<tr><td><code id="batchMapResults_+3A_more.args">more.args</code></td>
<td>
<p>[<code>list</code>]<br />
A list of further arguments passed to <code>fun</code>.
Default is an empty list.</p>
</td></tr>
<tr><td><code id="batchMapResults_+3A_target">target</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Empty Registry where new jobs are created for.</p>
</td></tr>
<tr><td><code id="batchMapResults_+3A_source">source</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with ids of jobs added to <code>target</code>.
</p>


<h3>Note</h3>

<p>The URI to the result files in registry <code>source</code> is hard coded as parameter in the <code>target</code> registry.
This means that <code>target</code> is currently not portable between systems for computation.
</p>


<h3>See Also</h3>

<p>Other Results: 
<code><a href="#topic+loadResult">loadResult</a>()</code>,
<code><a href="#topic+reduceResultsList">reduceResultsList</a>()</code>,
<code><a href="#topic+reduceResults">reduceResults</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Source registry: calculate square of some numbers
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(x) list(square = x^2), x = 1:10, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)

# Target registry: calculate the square root on results of first registry
target = makeRegistry(file.dir = NA, make.default = FALSE)
batchMapResults(fun = function(x, y) list(sqrt = sqrt(x$square)), ids = 4:8,
  target = target, source = tmp)
submitJobs(reg = target)
waitForJobs(reg = target)

# Map old to new ids. First, get a table with results and parameters
results = unwrap(rjoin(getJobPars(reg = target), reduceResultsDataTable(reg = target)))
print(results)

# Parameter '.id' points to job.id in 'source'. Use a inner join to combine:
ijoin(results, unwrap(reduceResultsDataTable(reg = tmp)), by = c(".id" = "job.id"))
</code></pre>

<hr>
<h2 id='batchReduce'>Reduce Operation for Batch Systems</h2><span id='topic+batchReduce'></span>

<h3>Description</h3>

<p>A parallel and asynchronous <code><a href="base.html#topic+Reduce">Reduce</a></code> for batch systems.
Note that this function only defines the computational jobs.
Each job reduces a certain number of elements on one slave.
The actual computation is started with <code><a href="#topic+submitJobs">submitJobs</a></code>.
Results and partial results can be collected with <code><a href="#topic+reduceResultsList">reduceResultsList</a></code>, <code><a href="#topic+reduceResults">reduceResults</a></code> or
<code><a href="#topic+loadResult">loadResult</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchReduce(
  fun,
  xs,
  init = NULL,
  chunks = seq_along(xs),
  more.args = list(),
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchReduce_+3A_fun">fun</code></td>
<td>
<p>[<code>function(aggr, x, ...)</code>]<br />
Function to reduce <code>xs</code> with.</p>
</td></tr>
<tr><td><code id="batchReduce_+3A_xs">xs</code></td>
<td>
<p>[<code>vector</code>]<br />
Vector to reduce.</p>
</td></tr>
<tr><td><code id="batchReduce_+3A_init">init</code></td>
<td>
<p>[ANY]<br />
Initial object for reducing. See <code><a href="base.html#topic+Reduce">Reduce</a></code>.</p>
</td></tr>
<tr><td><code id="batchReduce_+3A_chunks">chunks</code></td>
<td>
<p>[<code>integer(length(xs))</code>]<br />
Group for each element of <code>xs</code>. Can be generated with <code><a href="#topic+chunk">chunk</a></code>.</p>
</td></tr>
<tr><td><code id="batchReduce_+3A_more.args">more.args</code></td>
<td>
<p>[<code>list</code>]<br />
A list of additional arguments passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="batchReduce_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with ids of added jobs stored in column &ldquo;job.id&rdquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+batchMap">batchMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define function to reduce on slave, we want to sum a vector
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
xs = 1:100
f = function(aggr, x) aggr + x

# sum 20 numbers on each slave process, i.e. 5 jobs
chunks = chunk(xs, chunk.size = 5)
batchReduce(fun = f, 1:100, init = 0, chunks = chunks, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)

# now reduce one final time on master
reduceResults(fun = function(aggr, job, res) f(aggr, res), reg = tmp)
</code></pre>

<hr>
<h2 id='batchtools-package'>batchtools: Tools for Computation on Batch Systems</h2><span id='topic+batchtools'></span><span id='topic+batchtools-package'></span>

<h3>Description</h3>

<p>For bug reports and feature requests please use the tracker:
<a href="https://github.com/mllg/batchtools">https://github.com/mllg/batchtools</a>.
</p>


<h3>Package options</h3>


<dl>
<dt><code>batchtools.verbose</code></dt><dd>
<p>Verbosity. Set to <code>FALSE</code> to suppress info messages and progress bars.
</p>
</dd>
<dt><code>batchtools.progress</code></dt><dd>
<p>Progress bars. Set to <code>FALSE</code> to disable them.
</p>
</dd>
<dt><code>batchtools.timestamps</code></dt><dd>
<p>Add time stamps to log output. Set to <code>FALSE</code> to disable them.
</p>
</dd>
</dl>

<p>Furthermore, you may enable a debug mode using the <span class="pkg">debugme</span> package by
setting the environment variable &ldquo;DEBUGME&rdquo; to &ldquo;batchtools&rdquo; before
loading <span class="pkg">batchtools</span>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Dirk Surmann <a href="mailto:surmann@statistik.tu-dortmund.de">surmann@statistik.tu-dortmund.de</a> (<a href="https://orcid.org/0000-0003-0873-137X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mllg/batchtools">https://github.com/mllg/batchtools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mllg/batchtools/issues">https://github.com/mllg/batchtools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='btlapply'>Synchronous Apply Functions</h2><span id='topic+btlapply'></span><span id='topic+btmapply'></span>

<h3>Description</h3>

<p>This is a set of functions acting as counterparts to the sequential popular apply functions in base R:
<code>btlapply</code> for <code><a href="base.html#topic+lapply">lapply</a></code> and <code>btmapply</code> for <code><a href="base.html#topic+mapply">mapply</a></code>.
</p>
<p>Internally, jobs are created using <code><a href="#topic+batchMap">batchMap</a></code> on the provided registry.
If no registry is provided, a temporary registry (see argument <code>file.dir</code> of <code><a href="#topic+makeRegistry">makeRegistry</a></code>) and <code><a href="#topic+batchMap">batchMap</a></code>
will be used.
After all jobs are terminated (see <code><a href="#topic+waitForJobs">waitForJobs</a></code>), the results are collected and returned as a list.
</p>
<p>Note that these functions are only suitable for short and fail-safe operations
on batch system. If some jobs fail, you have to retrieve partial results from the
registry directory yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btlapply(
  X,
  fun,
  ...,
  resources = list(),
  n.chunks = NULL,
  chunk.size = NULL,
  reg = makeRegistry(file.dir = NA)
)

btmapply(
  fun,
  ...,
  more.args = list(),
  simplify = FALSE,
  use.names = TRUE,
  resources = list(),
  n.chunks = NULL,
  chunk.size = NULL,
  reg = makeRegistry(file.dir = NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btlapply_+3A_x">X</code></td>
<td>
<p>[<code><a href="base.html#topic+vector">vector</a></code>]<br />
Vector to apply over.</p>
</td></tr>
<tr><td><code id="btlapply_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function to apply.</p>
</td></tr>
<tr><td><code id="btlapply_+3A_...">...</code></td>
<td>
<p>[<code>ANY</code>]<br />
Additional arguments passed to <code>fun</code> (<code>btlapply</code>) or vectors to map over (<code>btmapply</code>).</p>
</td></tr>
<tr><td><code id="btlapply_+3A_resources">resources</code></td>
<td>
<p>[<code>named list</code>]<br />
Computational  resources for the jobs to submit. The actual elements of this list
(e.g. something like &ldquo;walltime&rdquo; or &ldquo;nodes&rdquo;) depend on your template file, exceptions are outlined in the section 'Resources'.
Default settings for a system can be set in the configuration file by defining the named list <code>default.resources</code>.
Note that these settings are merged by name, e.g. merging <code>list(walltime = 300)</code> into <code>list(walltime = 400, memory = 512)</code>
will result in <code>list(walltime = 300, memory = 512)</code>.
Same holds for individual job resources passed as additional column of <code>ids</code> (c.f. section 'Resources').</p>
</td></tr>
<tr><td><code id="btlapply_+3A_n.chunks">n.chunks</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Passed to <code><a href="#topic+chunk">chunk</a></code> before <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="btlapply_+3A_chunk.size">chunk.size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Passed to <code><a href="#topic+chunk">chunk</a></code> before <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="btlapply_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
<tr><td><code id="btlapply_+3A_more.args">more.args</code></td>
<td>
<p>[<code>list</code>]<br />
Additional arguments passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="btlapply_+3A_simplify">simplify</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Simplify the results using <code><a href="base.html#topic+simplify2array">simplify2array</a></code>?</p>
</td></tr>
<tr><td><code id="btlapply_+3A_use.names">use.names</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Use names of the input to name the output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with the results of the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
btlapply(1:3, function(x) x^2)
btmapply(function(x, y, z) x + y + z, x = 1:3, y = 1:3, more.args = list(z = 1), simplify = TRUE)
</code></pre>

<hr>
<h2 id='cfBrewTemplate'>Cluster Functions Helper to Write Job Description Files</h2><span id='topic+cfBrewTemplate'></span>

<h3>Description</h3>

<p>This function is only intended for use in your own cluster functions implementation.
</p>
<p>Calls brew silently on your template, any error will lead to an exception.
The file is stored at the same place as the corresponding job file in the &ldquo;jobs&rdquo;-subdir
of your files directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfBrewTemplate(reg, text, jc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfBrewTemplate_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
<tr><td><code id="cfBrewTemplate_+3A_text">text</code></td>
<td>
<p>[<code>character(1)</code>]<br />
String ready to be brewed. See <code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a></code> to read a template from the file system.</p>
</td></tr>
<tr><td><code id="cfBrewTemplate_+3A_jc">jc</code></td>
<td>
<p>[<code><a href="#topic+JobCollection">JobCollection</a>)</code>]<br />
Will be used as environment to brew the template file in. See <code><a href="#topic+JobCollection">JobCollection</a></code> for a list of all
available variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]. File path to brewed template file.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='cfHandleUnknownSubmitError'>Cluster Functions Helper to Handle Unknown Errors</h2><span id='topic+cfHandleUnknownSubmitError'></span>

<h3>Description</h3>

<p>This function is only intended for use in your own cluster functions implementation.
</p>
<p>Simply constructs a <code><a href="#topic+SubmitJobResult">SubmitJobResult</a></code> object with status code 101, NA as batch id and
an informative error message containing the output of the OS command in <code>output</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfHandleUnknownSubmitError(cmd, exit.code, output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfHandleUnknownSubmitError_+3A_cmd">cmd</code></td>
<td>
<p>[<code>character(1)</code>]<br />
OS command used to submit the job, e.g. qsub.</p>
</td></tr>
<tr><td><code id="cfHandleUnknownSubmitError_+3A_exit.code">exit.code</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Exit code of the OS command, should not be 0.</p>
</td></tr>
<tr><td><code id="cfHandleUnknownSubmitError_+3A_output">output</code></td>
<td>
<p>[<code>character</code>]<br />
Output of the OS command, hopefully an informative error message.
If these are multiple lines in a vector, they are automatically joined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+SubmitJobResult">SubmitJobResult</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='cfKillJob'>Cluster Functions Helper to Kill Batch Jobs</h2><span id='topic+cfKillJob'></span>

<h3>Description</h3>

<p>This function is only intended for use in your own cluster functions implementation.
</p>
<p>Calls the OS command to kill a job via <code><a href="base.html#topic+system">system</a></code> like this: &ldquo;cmd batch.job.id&rdquo;. If the
command returns an exit code &gt; 0, the command is repeated after a 1 second sleep
<code>max.tries-1</code> times. If the command failed in all tries, an error is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfKillJob(
  reg,
  cmd,
  args = character(0L),
  max.tries = 3L,
  nodename = "localhost"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfKillJob_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
<tr><td><code id="cfKillJob_+3A_cmd">cmd</code></td>
<td>
<p>[<code>character(1)</code>]<br />
OS command, e.g. &ldquo;qdel&rdquo;.</p>
</td></tr>
<tr><td><code id="cfKillJob_+3A_args">args</code></td>
<td>
<p>[<code>character</code>]<br />
Arguments to <code>cmd</code>, including the batch id.</p>
</td></tr>
<tr><td><code id="cfKillJob_+3A_max.tries">max.tries</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of total times to try execute the OS command in cases of failures.
Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="cfKillJob_+3A_nodename">nodename</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the SSH node to run the command on. If set to &ldquo;localhost&rdquo; (default), the command
is not piped through SSH.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> on success. An exception is raised otherwise.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='cfReadBrewTemplate'>Cluster Functions Helper to Parse a Brew Template</h2><span id='topic+cfReadBrewTemplate'></span>

<h3>Description</h3>

<p>This function is only intended for use in your own cluster functions implementation.
</p>
<p>This function is only intended for use in your own cluster functions implementation.
Simply reads your template file and returns it as a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfReadBrewTemplate(template, comment.string = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfReadBrewTemplate_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to template file which is then passed to <code><a href="brew.html#topic+brew">brew</a></code>.</p>
</td></tr>
<tr><td><code id="cfReadBrewTemplate_+3A_comment.string">comment.string</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Ignore lines starting with this string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character</code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='chunk'>Chunk Jobs for Sequential Execution</h2><span id='topic+chunk'></span><span id='topic+lpt'></span><span id='topic+binpack'></span>

<h3>Description</h3>

<p>Jobs can be partitioned into &ldquo;chunks&rdquo; to be executed sequentially on the computational nodes.
Chunks are defined by providing a data frame with columns &ldquo;job.id&rdquo; and &ldquo;chunk&rdquo; (integer)
to <code><a href="#topic+submitJobs">submitJobs</a></code>.
All jobs with the same chunk number will be grouped together on one node to form a single
computational job.
</p>
<p>The function <code>chunk</code> simply splits <code>x</code> into either a fixed number of groups, or
into a variable number of groups with a fixed number of maximum elements.
</p>
<p>The function <code>lpt</code> also groups <code>x</code> into a fixed number of chunks,
but uses the actual values of <code>x</code> in a greedy &ldquo;Longest Processing Time&rdquo; algorithm.
As a result, the maximum sum of elements in minimized.
</p>
<p><code>binpack</code> splits <code>x</code> into a variable number of groups whose sum of elements do
not exceed the upper limit provided by <code>chunk.size</code>.
</p>
<p>See examples of <code><a href="#topic+estimateRuntimes">estimateRuntimes</a></code> for an application of <code>binpack</code> and <code>lpt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk(x, n.chunks = NULL, chunk.size = NULL, shuffle = TRUE)

lpt(x, n.chunks = 1L)

binpack(x, chunk.size = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code>]<br />
For <code>chunk</code> an atomic vector (usually the <code>job.id</code>).
For <code>binpack</code> and <code>lpt</code>, the weights to group.</p>
</td></tr>
<tr><td><code id="chunk_+3A_n.chunks">n.chunks</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Requested number of chunks.
The function <code>chunk</code> distributes the number of elements in <code>x</code> evenly while
<code>lpt</code> tries to even out the sum of elements in each chunk.
If more chunks than necessary are requested, empty chunks are ignored.
Mutually exclusive with <code>chunks.size</code>.</p>
</td></tr>
<tr><td><code id="chunk_+3A_chunk.size">chunk.size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Requested chunk size for each single chunk.
For <code>chunk</code> this is the number of elements in <code>x</code>, for <code>binpack</code> the size
is determined by the sum of values in <code>x</code>.
Mutually exclusive with <code>n.chunks</code>.</p>
</td></tr>
<tr><td><code id="chunk_+3A_shuffle">shuffle</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shuffles the groups. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] giving the chunk number for each element of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateRuntimes">estimateRuntimes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ch = chunk(1:10, n.chunks = 2)
table(ch)

ch = chunk(rep(1, 10), chunk.size = 2)
table(ch)

set.seed(1)
x = runif(10)
ch = lpt(x, n.chunks = 2)
sapply(split(x, ch), sum)

set.seed(1)
x = runif(10)
ch = binpack(x, 1)
sapply(split(x, ch), sum)

# Job chunking
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
ids = batchMap(identity, 1:25, reg = tmp)

### Group into chunks with 10 jobs each
library(data.table)
ids[, chunk := chunk(job.id, chunk.size = 10)]
print(ids[, .N, by = chunk])

### Group into 4 chunks
ids[, chunk := chunk(job.id, n.chunks = 4)]
print(ids[, .N, by = chunk])

### Submit to batch system
submitJobs(ids = ids, reg = tmp)

# Grouped chunking
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE)
prob = addProblem(reg = tmp, "prob1", data = iris, fun = function(job, data) nrow(data))
prob = addProblem(reg = tmp, "prob2", data = Titanic, fun = function(job, data) nrow(data))
algo = addAlgorithm(reg = tmp, "algo", fun = function(job, data, instance, i, ...) problem)
prob.designs = list(prob1 = data.table(), prob2 = data.table(x = 1:2))
algo.designs = list(algo = data.table(i = 1:3))
addExperiments(prob.designs, algo.designs, repls = 3, reg = tmp)

### Group into chunks of 5 jobs, but do not put multiple problems into the same chunk
# -&gt; only one problem has to be loaded per chunk, and only once because it is cached
ids = getJobTable(reg = tmp)[, .(job.id, problem, algorithm)]
ids[, chunk := chunk(job.id, chunk.size = 5), by = "problem"]
ids[, chunk := .GRP, by = c("problem", "chunk")]
dcast(ids, chunk ~ problem)
</code></pre>

<hr>
<h2 id='clearRegistry'>Remove All Jobs</h2><span id='topic+clearRegistry'></span>

<h3>Description</h3>

<p>Removes all jobs from a registry and calls <code><a href="#topic+sweepRegistry">sweepRegistry</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearRegistry(reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>

<hr>
<h2 id='doJobCollection'>Execute Jobs of a JobCollection</h2><span id='topic+doJobCollection'></span>

<h3>Description</h3>

<p>Executes every job in a <code><a href="#topic+JobCollection">JobCollection</a></code>.
This function is intended to be called on the slave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doJobCollection(jc, output = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doJobCollection_+3A_jc">jc</code></td>
<td>
<p>[<code><a href="#topic+JobCollection">JobCollection</a></code>]<br />
Either an object of class &ldquo;JobCollection&rdquo; as returned by
<code><a href="#topic+makeJobCollection">makeJobCollection</a></code> or a string with the path to file
containing a &ldquo;JobCollection&rdquo; as RDS file (as stored by <code><a href="#topic+submitJobs">submitJobs</a></code>).</p>
</td></tr>
<tr><td><code id="doJobCollection_+3A_output">output</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to a file to write the output to. Defaults to <code>NULL</code> which means
that output is written to the active <code><a href="base.html#topic+sink">sink</a></code>.
Do not set this if your scheduler redirects output to a log file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]: Hash of the <code><a href="#topic+JobCollection">JobCollection</a></code> executed.
</p>


<h3>See Also</h3>

<p>Other JobCollection: 
<code><a href="#topic+makeJobCollection">makeJobCollection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(identity, 1:2, reg = tmp)
jc = makeJobCollection(1:2, reg = tmp)
doJobCollection(jc)
</code></pre>

<hr>
<h2 id='estimateRuntimes'>Estimate Remaining Runtimes</h2><span id='topic+estimateRuntimes'></span><span id='topic+print.RuntimeEstimate'></span>

<h3>Description</h3>

<p>Estimates the runtimes of jobs using the random forest implemented in <span class="pkg">ranger</span>.
Observed runtimes are retrieved from the <code><a href="#topic+Registry">Registry</a></code> and runtimes are
predicted for unfinished jobs.
</p>
<p>The estimated remaining time is calculated in the <code>print</code> method.
You may also pass <code>n</code> here to determine the number of parallel jobs which is then used
in a simple Longest Processing Time (LPT) algorithm to give an estimate for the parallel runtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateRuntimes(tab, ..., reg = getDefaultRegistry())

## S3 method for class 'RuntimeEstimate'
print(x, n = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateRuntimes_+3A_tab">tab</code></td>
<td>
<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>]<br />
Table with column &ldquo;job.id&rdquo; and additional columns to predict the runtime.
Observed runtimes will be looked up in the registry and serve as dependent variable.
All columns in <code>tab</code> except &ldquo;job.id&rdquo; will be passed to <code><a href="ranger.html#topic+ranger">ranger</a></code> as
independent variables to fit the model.</p>
</td></tr>
<tr><td><code id="estimateRuntimes_+3A_...">...</code></td>
<td>
<p>[ANY]<br />
Additional parameters passed to <code><a href="ranger.html#topic+ranger">ranger</a></code>. Ignored for the <code>print</code> method.</p>
</td></tr>
<tr><td><code id="estimateRuntimes_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
<tr><td><code id="estimateRuntimes_+3A_x">x</code></td>
<td>
<p>[<code>RuntimeEstimate</code>]<br />
Object to print.</p>
</td></tr>
<tr><td><code id="estimateRuntimes_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of parallel jobs to assume for runtime estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>RuntimeEstimate</code>] which is a <code>list</code> with two named elements:
&ldquo;runtimes&rdquo; is a <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns &ldquo;job.id&rdquo;,
&ldquo;runtime&rdquo; (in seconds) and &ldquo;type&rdquo; (&ldquo;estimated&rdquo; if runtime is estimated,
&ldquo;observed&rdquo; if runtime was observed).
The other element of the list named &ldquo;model&rdquo;] contains the fitted random forest object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binpack">binpack</a></code> and <code><a href="#topic+lpt">lpt</a></code> to chunk jobs according to their estimated runtimes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a simple toy registry
set.seed(1)
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE, seed = 1)
addProblem(name = "iris", data = iris, fun = function(data, ...) nrow(data), reg = tmp)
addAlgorithm(name = "nrow", function(instance, ...) nrow(instance), reg = tmp)
addAlgorithm(name = "ncol", function(instance, ...) ncol(instance), reg = tmp)
addExperiments(algo.designs = list(nrow = data.table::CJ(x = 1:50, y = letters[1:5])), reg = tmp)
addExperiments(algo.designs = list(ncol = data.table::CJ(x = 1:50, y = letters[1:5])), reg = tmp)

# We use the job parameters to predict runtimes
tab = unwrap(getJobPars(reg = tmp))

# First we need to submit some jobs so that the forest can train on some data.
# Thus, we just sample some jobs from the registry while grouping by factor variables.
library(data.table)
ids = tab[, .SD[sample(nrow(.SD), 5)], by = c("problem", "algorithm", "y")]
setkeyv(ids, "job.id")
submitJobs(ids, reg = tmp)
waitForJobs(reg = tmp)

# We "simulate" some more realistic runtimes here to demonstrate the functionality:
# - Algorithm "ncol" is 5 times more expensive than "nrow"
# - x has no effect on the runtime
# - If y is "a" or "b", the runtimes are really high
runtime = function(algorithm, x, y) {
  ifelse(algorithm == "nrow", 100L, 500L) + 1000L * (y %in% letters[1:2])
}
tmp$status[ids, done := done + tab[ids, runtime(algorithm, x, y)]]
rjoin(sjoin(tab, ids), getJobStatus(ids, reg = tmp)[, c("job.id", "time.running")])

# Estimate runtimes:
est = estimateRuntimes(tab, reg = tmp)
print(est)
rjoin(tab, est$runtimes)
print(est, n = 10)

# Submit jobs with longest runtime first:
ids = est$runtimes[type == "estimated"][order(runtime, decreasing = TRUE)]
print(ids)
## Not run: 
submitJobs(ids, reg = tmp)

## End(Not run)

# Group jobs into chunks with runtime &lt; 1h
ids = est$runtimes[type == "estimated"]
ids[, chunk := binpack(runtime, 3600)]
print(ids)
print(ids[, list(runtime = sum(runtime)), by = chunk])
## Not run: 
submitJobs(ids, reg = tmp)

## End(Not run)

# Group jobs into 10 chunks with similar runtime
ids = est$runtimes[type == "estimated"]
ids[, chunk := lpt(runtime, 10)]
print(ids[, list(runtime = sum(runtime)), by = chunk])
</code></pre>

<hr>
<h2 id='execJob'>Execute a Single Jobs</h2><span id='topic+execJob'></span>

<h3>Description</h3>

<p>Executes a single job (as created by <code><a href="#topic+makeJob">makeJob</a></code>) and returns
its result. Also works for Experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execJob(job)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execJob_+3A_job">job</code></td>
<td>
<p>[<code><a href="#topic+Job">Job</a></code> | <code><a href="#topic+Experiment">Experiment</a></code>]<br />
Job/Experiment to execute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the job.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(identity, 1:2, reg = tmp)
job = makeJob(1, reg = tmp)
execJob(job)
</code></pre>

<hr>
<h2 id='findConfFile'>Find a batchtools Configuration File</h2><span id='topic+findConfFile'></span>

<h3>Description</h3>

<p>This functions returns the path to the first configuration file found in the following locations:
</p>

<ol>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the current working directory.
</p>
</li>
<li><p>File &ldquo;config.R&rdquo; in the user configuration directory as reported by <code>rappdirs::user_config_dir("batchtools", expand = FALSE)</code> (depending on OS, e.g., on linux this usually resolves to &ldquo;~/.config/batchtools/config.R&rdquo;).
</p>
</li>
<li><p>&ldquo;.batchtools.conf.R&rdquo; in the home directory (&ldquo;~&rdquo;).
</p>
</li>
<li><p>&ldquo;config.R&rdquo; in the site config directory as reported by <code>rappdirs::site_config_dir("batchtools")</code> (depending on OS). This file can be used for admins to set sane defaults for a computation site.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>findConfFile()
</code></pre>


<h3>Value</h3>

<p>[<code>character(1)</code>] Path to the configuration file or <code>NA</code> if no configuration file was found.
</p>

<hr>
<h2 id='findJobs'>Find and Filter Jobs</h2><span id='topic+findJobs'></span><span id='topic+findExperiments'></span><span id='topic+findSubmitted'></span><span id='topic+findNotSubmitted'></span><span id='topic+findStarted'></span><span id='topic+findNotStarted'></span><span id='topic+findDone'></span><span id='topic+findNotDone'></span><span id='topic+findErrors'></span><span id='topic+findOnSystem'></span><span id='topic+findRunning'></span><span id='topic+findQueued'></span><span id='topic+findExpired'></span><span id='topic+findTagged'></span>

<h3>Description</h3>

<p>These functions are used to find and filter jobs, depending on either their parameters (<code>findJobs</code> and
<code>findExperiments</code>), their tags (<code>findTagged</code>), or their computational status (all other functions,
see <code><a href="#topic+getStatus">getStatus</a></code> for an overview).
</p>
<p>Note that <code>findQueued</code>, <code>findRunning</code>, <code>findOnSystem</code> and <code>findExpired</code> are somewhat heuristic
and may report misleading results, depending on the state of the system and the <code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code> implementation.
</p>
<p>See <code><a href="#topic+JoinTables">JoinTables</a></code> for convenient set operations (unions, intersects, differences) on tables with job ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findJobs(expr, ids = NULL, reg = getDefaultRegistry())

findExperiments(
  ids = NULL,
  prob.name = NA_character_,
  prob.pattern = NA_character_,
  algo.name = NA_character_,
  algo.pattern = NA_character_,
  prob.pars,
  algo.pars,
  repls = NULL,
  reg = getDefaultRegistry()
)

findSubmitted(ids = NULL, reg = getDefaultRegistry())

findNotSubmitted(ids = NULL, reg = getDefaultRegistry())

findStarted(ids = NULL, reg = getDefaultRegistry())

findNotStarted(ids = NULL, reg = getDefaultRegistry())

findDone(ids = NULL, reg = getDefaultRegistry())

findNotDone(ids = NULL, reg = getDefaultRegistry())

findErrors(ids = NULL, reg = getDefaultRegistry())

findOnSystem(ids = NULL, reg = getDefaultRegistry())

findRunning(ids = NULL, reg = getDefaultRegistry())

findQueued(ids = NULL, reg = getDefaultRegistry())

findExpired(ids = NULL, reg = getDefaultRegistry())

findTagged(tags = character(0L), ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findJobs_+3A_expr">expr</code></td>
<td>
<p>[<code>expression</code>]<br />
Predicate expression evaluated in the job parameters.
Jobs for which <code>expr</code> evaluates to <code>TRUE</code> are returned.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
<tr><td><code id="findJobs_+3A_prob.name">prob.name</code></td>
<td>
<p>[<code>character</code>]<br />
Exact name of the problem (no substring matching).
If not provided, all problems are matched.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_prob.pattern">prob.pattern</code></td>
<td>
<p>[<code>character</code>]<br />
Regular expression pattern to match problem names.
If not provided, all problems are matched.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_algo.name">algo.name</code></td>
<td>
<p>[<code>character</code>]<br />
Exact name of the problem (no substring matching).
If not provided, all algorithms are matched.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_algo.pattern">algo.pattern</code></td>
<td>
<p>[<code>character</code>]<br />
Regular expression pattern to match algorithm names.
If not provided, all algorithms are matched.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_prob.pars">prob.pars</code></td>
<td>
<p>[<code>expression</code>]<br />
Predicate expression evaluated in the problem parameters.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_algo.pars">algo.pars</code></td>
<td>
<p>[<code>expression</code>]<br />
Predicate expression evaluated in the algorithm parameters.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_repls">repls</code></td>
<td>
<p>[<code>integer</code>]<br />
Whitelist of replication numbers. If not provided, all replications are matched.</p>
</td></tr>
<tr><td><code id="findJobs_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Return jobs which are tagged with any of the tags provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with column &ldquo;job.id&rdquo; containing matched jobs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getStatus">getStatus</a></code> <code><a href="#topic+JoinTables">JoinTables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(identity, i = 1:3, reg = tmp)
ids = findNotSubmitted(reg = tmp)

# get all jobs:
findJobs(reg = tmp)

# filter for jobs with parameter i &gt;= 2
findJobs(i &gt;= 2, reg = tmp)

# filter on the computational status
findSubmitted(reg = tmp)
findNotDone(reg = tmp)

# filter on tags
addJobTags(2:3, "my_tag", reg = tmp)
findTagged(tags = "my_tag", reg = tmp)

# combine filter functions using joins
# -&gt; jobs which are not done and not tagged (using an anti-join):
ajoin(findNotDone(reg = tmp), findTagged("my_tag", reg = tmp))
</code></pre>

<hr>
<h2 id='findTemplateFile'>Find a batchtools Template File</h2><span id='topic+findTemplateFile'></span>

<h3>Description</h3>

<p>This functions returns the path to a template file on the file system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findTemplateFile(template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findTemplateFile_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character</code>] Path to the file or <code>NA</code> if no template template file was found.
</p>

<hr>
<h2 id='getDefaultRegistry'>Get and Set the Default Registry</h2><span id='topic+getDefaultRegistry'></span><span id='topic+setDefaultRegistry'></span>

<h3>Description</h3>

<p><code>getDefaultRegistry</code> returns the registry currently set as default (or
stops with an exception if none is set). <code>setDefaultRegistry</code> sets
a registry as default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDefaultRegistry()

setDefaultRegistry(reg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDefaultRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>

<hr>
<h2 id='getErrorMessages'>Retrieve Error Messages</h2><span id='topic+getErrorMessages'></span>

<h3>Description</h3>

<p>Extracts error messages from the internal data base and returns them in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getErrorMessages(
  ids = NULL,
  missing.as.error = FALSE,
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getErrorMessages_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findErrors">findErrors</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="getErrorMessages_+3A_missing.as.error">missing.as.error</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Treat missing results as errors? If <code>TRUE</code>, the error message &ldquo;[not terminated]&rdquo; is imputed
for jobs which have not terminated. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getErrorMessages_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with columns &ldquo;job.id&rdquo;, &ldquo;terminated&rdquo; (logical),
&ldquo;error&rdquo; (logical) and &ldquo;message&rdquo; (string).
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
fun = function(i) if (i == 3) stop(i) else i
ids = batchMap(fun, i = 1:5, reg = tmp)
submitJobs(1:4, reg = tmp)
waitForJobs(1:4, reg = tmp)
getErrorMessages(ids, reg = tmp)
getErrorMessages(ids, missing.as.error = TRUE, reg = tmp)
</code></pre>

<hr>
<h2 id='getJobTable'>Query Job Information</h2><span id='topic+getJobTable'></span><span id='topic+getJobStatus'></span><span id='topic+getJobResources'></span><span id='topic+getJobPars'></span><span id='topic+getJobTags'></span>

<h3>Description</h3>

<p><code>getJobStatus</code> returns the internal table which stores information about the computational
status of jobs, <code>getJobPars</code> a table with the job parameters, <code>getJobResources</code> a table
with the resources which were set to submit the jobs, and <code>getJobTags</code> the tags of the jobs
(see <a href="#topic+Tags">Tags</a>).
</p>
<p><code>getJobTable</code> returns all these tables joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getJobTable(ids = NULL, reg = getDefaultRegistry())

getJobStatus(ids = NULL, reg = getDefaultRegistry())

getJobResources(ids = NULL, reg = getDefaultRegistry())

getJobPars(ids = NULL, reg = getDefaultRegistry())

getJobTags(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getJobTable_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="getJobTable_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with the following columns (not necessarily in this order):
</p>

<dl>
<dt>job.id</dt><dd><p>Unique Job ID as integer.</p>
</dd>
<dt>submitted</dt><dd><p>Time the job was submitted to the batch system as <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</dd>
<dt>started</dt><dd><p>Time the job was started on the batch system as <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</dd>
<dt>done</dt><dd><p>Time the job terminated (successfully or with an error) as <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</dd>
<dt>error</dt><dd><p>Either <code>NA</code> if the job terminated successfully or the error message.</p>
</dd>
<dt>mem.used</dt><dd><p>Estimate of the memory usage.</p>
</dd>
<dt>batch.id</dt><dd><p>Batch ID as reported by the scheduler.</p>
</dd>
<dt>log.file</dt><dd><p>Log file. If missing, defaults to <code>[job.hash].log</code>.</p>
</dd>
<dt>job.hash</dt><dd><p>Unique string identifying the job or chunk.</p>
</dd>
<dt>time.queued</dt><dd><p>Time in seconds (as <code><a href="base.html#topic+difftime">difftime</a></code>) the job was queued.</p>
</dd>
<dt>time.running</dt><dd><p>Time in seconds (as <code><a href="base.html#topic+difftime">difftime</a></code>) the job was running.</p>
</dd>
<dt>pars</dt><dd><p>List of parameters/arguments for this job.</p>
</dd>
<dt>resources</dt><dd><p>List of computational resources set for this job.</p>
</dd>
<dt>tags</dt><dd><p>Tags as joined string, delimited by &ldquo;,&rdquo;.</p>
</dd>
<dt>problem</dt><dd><p>Only for <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>: the problem identifier.</p>
</dd>
<dt>algorithm</dt><dd><p>Only for <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>: the algorithm identifier.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
f = function(x) if (x &lt; 0) stop("x must be &gt; 0") else sqrt(x)
batchMap(f, x = c(-1, 0, 1), reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)
addJobTags(1:2, "tag1", reg = tmp)
addJobTags(2, "tag2", reg = tmp)

# Complete table:
getJobTable(reg = tmp)

# Job parameters:
getJobPars(reg = tmp)

# Set and retrieve tags:
getJobTags(reg = tmp)

# Job parameters with tags right-joined:
rjoin(getJobPars(reg = tmp), getJobTags(reg = tmp))
</code></pre>

<hr>
<h2 id='getStatus'>Summarize the Computational Status</h2><span id='topic+getStatus'></span>

<h3>Description</h3>

<p>This function gives an encompassing overview over the computational status on your system.
The status can be one or many of the following:
</p>

<ul>
<li> <p>&ldquo;defined&rdquo;: Jobs which are defined via <code><a href="#topic+batchMap">batchMap</a></code> or <code><a href="#topic+addExperiments">addExperiments</a></code>, but are not yet submitted.
</p>
</li>
<li> <p>&ldquo;submitted&rdquo;: Jobs which are submitted to the batch system via <code><a href="#topic+submitJobs">submitJobs</a></code>, scheduled for execution.
</p>
</li>
<li> <p>&ldquo;started&rdquo;: Jobs which have been started.
</p>
</li>
<li> <p>&ldquo;done&rdquo;: Jobs which terminated successfully.
</p>
</li>
<li> <p>&ldquo;error&rdquo;: Jobs which terminated with an exception.
</p>
</li>
<li> <p>&ldquo;running&rdquo;: Jobs which are listed by the cluster functions to be running on the live system. Not supported for all cluster functions.
</p>
</li>
<li> <p>&ldquo;queued&rdquo;: Jobs which are listed by the cluster functions to be queued on the live system. Not supported for all cluster functions.
</p>
</li>
<li> <p>&ldquo;system&rdquo;: Jobs which are listed by the cluster functions to be queued or running. Not supported for all cluster functions.
</p>
</li>
<li> <p>&ldquo;expired&rdquo;: Jobs which have been submitted, but vanished from the live system. Note that this is determined heuristically and may include some false positives.
</p>
</li></ul>

<p>Here, a job which terminated successfully counts towards the jobs which are submitted, started and done.
To retrieve the corresponding job ids, see <code><a href="#topic+findJobs">findJobs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStatus(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStatus_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="getStatus_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] (with class &ldquo;Status&rdquo; for printing).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findJobs">findJobs</a></code>
</p>
<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
fun = function(i) if (i == 3) stop(i) else i
ids = batchMap(fun, i = 1:5, reg = tmp)
submitJobs(ids = 1:4, reg = tmp)
waitForJobs(reg = tmp)

tab = getStatus(reg = tmp)
print(tab)
str(tab)
</code></pre>

<hr>
<h2 id='grepLogs'>Grep Log Files for a Pattern</h2><span id='topic+grepLogs'></span>

<h3>Description</h3>

<p>Crawls through log files and reports jobs with lines matching the <code>pattern</code>.
See <code><a href="#topic+showLog">showLog</a></code> for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepLogs(
  ids = NULL,
  pattern,
  ignore.case = FALSE,
  fixed = FALSE,
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grepLogs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findStarted">findStarted</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="grepLogs_+3A_pattern">pattern</code></td>
<td>
<p>[<code>character(1L)</code>]<br />
Regular expression or string (see <code>fixed</code>).</p>
</td></tr>
<tr><td><code id="grepLogs_+3A_ignore.case">ignore.case</code></td>
<td>
<p>[<code>logical(1L)</code>]<br />
If <code>TRUE</code> the match will be performed case insensitively.</p>
</td></tr>
<tr><td><code id="grepLogs_+3A_fixed">fixed</code></td>
<td>
<p>[<code>logical(1L)</code>]<br />
If <code>FALSE</code> (default), <code>pattern</code> is a regular expression and a fixed string otherwise.</p>
</td></tr>
<tr><td><code id="grepLogs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with columns &ldquo;job.id&rdquo; and &ldquo;message&rdquo;.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>

<hr>
<h2 id='JobNames'>Set and Retrieve Job Names</h2><span id='topic+JobNames'></span><span id='topic+setJobNames'></span><span id='topic+getJobNames'></span>

<h3>Description</h3>

<p>Set custom names for jobs. These are passed to the template as &lsquo;job.name&rsquo;.
If no custom name is set (or any of the job names of the chunk is missing),
the job hash is used as job name.
Individual job names can be accessed via <code>jobs$job.name</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setJobNames(ids = NULL, names, reg = getDefaultRegistry())

getJobNames(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JobNames_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="JobNames_+3A_names">names</code></td>
<td>
<p>[<code>character</code>]<br />
Character vector of the same length as provided ids.</p>
</td></tr>
<tr><td><code id="JobNames_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setJobNames</code> returns <code>NULL</code> invisibly, <code>getJobTable</code>
returns a <code>data.table</code> with columns <code>job.id</code> and <code>job.name</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
ids = batchMap(identity, 1:10, reg = tmp)
setJobNames(ids, letters[1:nrow(ids)], reg = tmp)
getJobNames(reg = tmp)
</code></pre>

<hr>
<h2 id='JoinTables'>Inner, Left, Right, Outer, Semi and Anti Join for Data Tables</h2><span id='topic+JoinTables'></span><span id='topic+ijoin'></span><span id='topic+ljoin'></span><span id='topic+rjoin'></span><span id='topic+ojoin'></span><span id='topic+sjoin'></span><span id='topic+ajoin'></span><span id='topic+ujoin'></span>

<h3>Description</h3>

<p>These helper functions perform join operations on data tables.
Most of them are basically one-liners.
See <a href="https://rpubs.com/ronasta/join_data_tables">https://rpubs.com/ronasta/join_data_tables</a> for a overview of join operations in
data table or alternatively <span class="pkg">dplyr</span>'s vignette on two table verbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijoin(x, y, by = NULL)

ljoin(x, y, by = NULL)

rjoin(x, y, by = NULL)

ojoin(x, y, by = NULL)

sjoin(x, y, by = NULL)

ajoin(x, y, by = NULL)

ujoin(x, y, all.y = FALSE, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JoinTables_+3A_x">x</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code>]<br />
First data.frame to join.</p>
</td></tr>
<tr><td><code id="JoinTables_+3A_y">y</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code>]<br />
Second data.frame to join.</p>
</td></tr>
<tr><td><code id="JoinTables_+3A_by">by</code></td>
<td>
<p>[<code>character</code>]<br />
Column name(s) of variables used to match rows in <code>x</code> and <code>y</code>.
If not provided, a heuristic similar to the one described in the <span class="pkg">dplyr</span> vignette is used:
</p>

<ol>
<li><p> If <code>x</code> is keyed, the existing key will be used if <code>y</code> has the same column(s).
</p>
</li>
<li><p> If <code>x</code> is not keyed, the intersect of common columns names is used if not empty.
</p>
</li>
<li><p> Raise an exception.
</p>
</li></ol>

<p>You may pass a named character vector to merge on columns with different names in <code>x</code> and
<code>y</code>: <code>by = c("x.id" = "y.id")</code> will match <code>x</code>'s &ldquo;x.id&rdquo; column with <code>y</code>\'s
&ldquo;y.id&rdquo; column.</p>
</td></tr>
<tr><td><code id="JoinTables_+3A_all.y">all.y</code></td>
<td>
<p>[logical(1)]<br />
Keep columns of <code>y</code> which are not in <code>x</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with key identical to <code>by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create two tables for demonstration
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(identity, x = 1:6, reg = tmp)
x = getJobPars(reg = tmp)
y = findJobs(x &gt;= 2 &amp; x &lt;= 5, reg = tmp)
y$extra.col = head(letters, nrow(y))

# Inner join: similar to intersect(): keep all columns of x and y with common matches
ijoin(x, y)

# Left join: use all ids from x, keep all columns of x and y
ljoin(x, y)

# Right join: use all ids from y, keep all columns of x and y
rjoin(x, y)

# Outer join: similar to union(): keep all columns of x and y with matches in x or y
ojoin(x, y)

# Semi join: filter x with matches in y
sjoin(x, y)

# Anti join: filter x with matches not in y
ajoin(x, y)

# Updating join: Replace values in x with values in y
ujoin(x, y)
</code></pre>

<hr>
<h2 id='killJobs'>Kill Jobs</h2><span id='topic+killJobs'></span>

<h3>Description</h3>

<p>Kill jobs which are currently running on the batch system.
</p>
<p>In case of an error when killing, the function tries - after a short sleep - to kill the remaining
batch jobs again. If this fails three times for some jobs, the function gives up. Jobs that could be
successfully killed are reset in the <a href="#topic+Registry">Registry</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>killJobs(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="killJobs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findOnSystem">findOnSystem</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="killJobs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with columns &ldquo;job.id&rdquo;, the corresponding &ldquo;batch.id&rdquo; and
the logical flag &ldquo;killed&rdquo; indicating success.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>

<hr>
<h2 id='loadRegistry'>Load a Registry from the File System</h2><span id='topic+loadRegistry'></span>

<h3>Description</h3>

<p>Loads a registry from its <code>file.dir</code>.
</p>
<p>Multiple R sessions accessing the same registry simultaneously can lead to database inconsistencies.
This is especially dangerous if the same <code>file.dir</code> is accessed from multiple machines, e.g. via a mount.
</p>
<p>If you just need to check on the status or peek into some preliminary results while another process is still submitting or waiting
for pending results, you can load the registry in a read-only mode.
All operations that need to change the registry will raise an exception in this mode.
Files communicated back by the computational nodes are parsed to update the registry in memory while the registry on the file system remains unchanged.
</p>
<p>A heuristic tries to detect if the registry has been altered in the background by an other process and in this case automatically restricts the current registry to read-only mode.
However, you should rely on this heuristic to work flawlessly.
Thus, set to <code>writeable</code> to <code>TRUE</code> if and only if you are absolutely sure that other state-changing processes are terminated.
</p>
<p>If you need write access, load the registry with <code>writeable</code> set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadRegistry(
  file.dir,
  work.dir = NULL,
  conf.file = findConfFile(),
  make.default = TRUE,
  writeable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadRegistry_+3A_file.dir">file.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path where all files of the registry are saved.
Default is directory &ldquo;registry&rdquo; in the current working directory.
The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.
</p>
<p>If you pass <code>NA</code>, a temporary directory will be used.
This way, you can create disposable registries for <code><a href="#topic+btlapply">btlapply</a></code> or examples.
By default, the temporary directory <code><a href="base.html#topic+tempdir">tempdir</a>()</code> will be used.
If you want to use another directory, e.g. a directory which is shared between nodes,
you can set it in your configuration file by setting the variable <code>temp.dir</code>.</p>
</td></tr>
<tr><td><code id="loadRegistry_+3A_work.dir">work.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Working directory for R process for running jobs.
Defaults to the working directory currently set during Registry construction (see <code><a href="base.html#topic+getwd">getwd</a></code>).
<code>loadRegistry</code> uses the stored <code>work.dir</code>, but you may also explicitly overwrite it,
e.g., after switching to another system.
</p>
<p>The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.</p>
</td></tr>
<tr><td><code id="loadRegistry_+3A_conf.file">conf.file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to a configuration file which is sourced while the registry is created.
In the configuration file you can define how <span class="pkg">batchtools</span> interacts with the system via <code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>.
Separating the configuration of the underlying host system from the R code allows to easily move computation to another site.
</p>
<p>The file lookup is implemented in the internal (but exported) function <code>findConfFile</code> which returns the first file found of the following candidates:
</p>

<ol>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the current working directory.
</p>
</li>
<li><p>File &ldquo;config.R&rdquo; in the user configuration directory as reported by <code>rappdirs::user_config_dir("batchtools", expand = FALSE)</code> (depending on OS, e.g., on linux this usually resolves to &ldquo;~/.config/batchtools/config.R&rdquo;).
</p>
</li>
<li><p>&ldquo;.batchtools.conf.R&rdquo; in the home directory (&ldquo;~&rdquo;).
</p>
</li>
<li><p>&ldquo;config.R&rdquo; in the site config directory as reported by <code>rappdirs::site_config_dir("batchtools")</code> (depending on OS). This file can be used for admins to set sane defaults for a computation site.
</p>
</li></ol>

<p>Set to <code>NA</code> if you want to suppress reading any configuration file.
If a configuration file is found, it gets sourced inside the environment of the registry after the defaults for all variables are set.
Therefore you can set and overwrite slots, e.g. <code>default.resources = list(walltime = 3600)</code> to set default resources or &ldquo;max.concurrent.jobs&rdquo; to
limit the number of jobs allowed to run simultaneously on the system.</p>
</td></tr>
<tr><td><code id="loadRegistry_+3A_make.default">make.default</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, the created registry is saved inside the package
namespace and acts as default registry. You might want to switch this
off if you work with multiple registries simultaneously.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="loadRegistry_+3A_writeable">writeable</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Loads the registry in read-write mode. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+Registry">Registry</a></code>].
</p>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>

<hr>
<h2 id='loadResult'>Load the Result of a Single Job</h2><span id='topic+loadResult'></span>

<h3>Description</h3>

<p>Loads the result of a single job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadResult(id, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadResult_+3A_id">id</code></td>
<td>
<p>[<code>integer(1)</code> or <code>data.table</code>]<br />
Single integer to specify the job or a <code>data.table</code> with column <code>job.id</code>
and exactly one row.</p>
</td></tr>
<tr><td><code id="loadResult_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ANY</code>]. The stored result.
</p>


<h3>See Also</h3>

<p>Other Results: 
<code><a href="#topic+batchMapResults">batchMapResults</a>()</code>,
<code><a href="#topic+reduceResultsList">reduceResultsList</a>()</code>,
<code><a href="#topic+reduceResults">reduceResults</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctions'>ClusterFunctions Constructor</h2><span id='topic+makeClusterFunctions'></span><span id='topic+ClusterFunctions'></span>

<h3>Description</h3>

<p>This is the constructor used to create <em>custom</em> cluster functions.
Note that some standard implementations for TORQUE, Slurm, LSF, SGE, etc. ship
with the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctions(
  name,
  submitJob,
  killJob = NULL,
  listJobsQueued = NULL,
  listJobsRunning = NULL,
  array.var = NA_character_,
  store.job.collection = FALSE,
  store.job.files = FALSE,
  scheduler.latency = 0,
  fs.latency = 0,
  hooks = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctions_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of cluster functions.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_submitjob">submitJob</code></td>
<td>
<p>[<code>function(reg, jc, ...)</code>]<br />
Function to submit new jobs. Must return a <code><a href="#topic+SubmitJobResult">SubmitJobResult</a></code> object.
The arguments are <code>reg</code> (<code><a href="#topic+Registry">Registry</a></code>) and <code>jobs</code> (<code><a href="#topic+JobCollection">JobCollection</a></code>).</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_killjob">killJob</code></td>
<td>
<p>[<code>function(reg, batch.id)</code>]<br />
Function to kill a job on the batch system. Make sure that you definitely kill the job! Return
value is currently ignored. Must have the arguments <code>reg</code> (<code><a href="#topic+Registry">Registry</a></code>) and
<code>batch.id</code> (<code>character(1)</code> as returned by <code>submitJob</code>).
Note that there is a helper function <code><a href="#topic+cfKillJob">cfKillJob</a></code> to repeatedly try to kill jobs.
Set <code>killJob</code> to <code>NULL</code> if killing jobs cannot be supported.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_listjobsqueued">listJobsQueued</code></td>
<td>
<p>[<code>function(reg)</code>]<br />
List all queued jobs on the batch system for the current user.
Must return an character vector of batch ids, same format as they
are returned by <code>submitJob</code>.
Set <code>listJobsQueued</code> to <code>NULL</code> if listing of queued jobs is not supported.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_listjobsrunning">listJobsRunning</code></td>
<td>
<p>[<code>function(reg)</code>]<br />
List all running jobs on the batch system for the current user.
Must return an character vector of batch ids, same format as they
are returned by <code>submitJob</code>. It does not matter if you return a few job ids too many (e.g.
all for the current user instead of all for the current registry), but you have to include all
relevant ones. Must have the argument are <code>reg</code> (<code><a href="#topic+Registry">Registry</a></code>).
Set <code>listJobsRunning</code> to <code>NULL</code> if listing of running jobs is not supported.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_array.var">array.var</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the environment variable set by the scheduler to identify IDs of job arrays.
Default is <code>NA</code> for no array support.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_store.job.collection">store.job.collection</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Flag to indicate that the cluster function implementation of <code>submitJob</code> can not directly handle <code><a href="#topic+JobCollection">JobCollection</a></code> objects.
If set to <code>FALSE</code>, the <code><a href="#topic+JobCollection">JobCollection</a></code> is serialized to the file system before submitting the job.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_store.job.files">store.job.files</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Flag to indicate that job files need to be stored in the file directory.
If set to <code>FALSE</code> (default), the job file is created in a temporary directory, otherwise (or if the debug mode is enabled) in
the subdirectory <code>jobs</code> of the <code>file.dir</code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
<tr><td><code id="makeClusterFunctions_+3A_hooks">hooks</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of functions which will we called on certain events like &ldquo;pre.submit&rdquo; or &ldquo;post.sync&rdquo;.
See <a href="#topic+Hooks">Hooks</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>
</p>
<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsDocker'>ClusterFunctions for Docker</h2><span id='topic+makeClusterFunctionsDocker'></span>

<h3>Description</h3>

<p>Cluster functions for Docker/Docker Swarm (<a href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a>).
</p>
<p>The <code>submitJob</code> function executes
<code>docker [docker.args] run --detach=true [image.args] [resources] [image] [cmd]</code>.
Arguments <code>docker.args</code>, <code>image.args</code> and <code>image</code> can be set on construction.
The <code>resources</code> part takes the named resources <code>ncpus</code> and <code>memory</code>
from <code><a href="#topic+submitJobs">submitJobs</a></code> and maps them to the arguments <code>--cpu-shares</code> and <code>--memory</code>
(in Megabytes). The resource <code>threads</code> is mapped to the environment variables &ldquo;OMP_NUM_THREADS&rdquo;
and &ldquo;OPENBLAS_NUM_THREADS&rdquo;.
To reliably identify jobs in the swarm, jobs are labeled with &ldquo;batchtools=[job.hash]&rdquo; and named
using the current login name (label &ldquo;user&rdquo;) and the job hash (label &ldquo;batchtools&rdquo;).
</p>
<p><code>listJobsRunning</code> uses <code>docker [docker.args] ps --format={{.ID}}</code> to filter for running jobs.
</p>
<p><code>killJobs</code> uses <code>docker [docker.args] kill [batch.id]</code> to filter for running jobs.
</p>
<p>These cluster functions use a <a href="#topic+Hook">Hook</a> to remove finished jobs before a new submit and every time the <a href="#topic+Registry">Registry</a>
is synchronized (using <code><a href="#topic+syncRegistry">syncRegistry</a></code>).
This is currently required because docker does not remove terminated containers automatically.
Use <code>docker ps -a --filter 'label=batchtools' --filter 'status=exited'</code> to identify and remove terminated
containers manually (or usa a cron job).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsDocker(
  image,
  docker.args = character(0L),
  image.args = character(0L),
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsDocker_+3A_image">image</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the docker image to run.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsDocker_+3A_docker.args">docker.args</code></td>
<td>
<p>[<code>character</code>]<br />
Additional arguments passed to &ldquo;docker&rdquo; *before* the command (&ldquo;run&rdquo;, &ldquo;ps&rdquo; or &ldquo;kill&rdquo;) to execute (e.g., the docker host).</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsDocker_+3A_image.args">image.args</code></td>
<td>
<p>[<code>character</code>]<br />
Additional arguments passed to &ldquo;docker run&rdquo; (e.g., to define mounts or environment variables).</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsDocker_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsDocker_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsInteractive'>ClusterFunctions for Sequential Execution in the Running R Session</h2><span id='topic+makeClusterFunctionsInteractive'></span>

<h3>Description</h3>

<p>All jobs are executed sequentially using the current R process in which <code><a href="#topic+submitJobs">submitJobs</a></code> is called.
Thus, <code>submitJob</code> blocks the session until the job has finished.
The main use of this <code>ClusterFunctions</code> implementation is to test and debug programs on a local computer.
</p>
<p>Listing jobs returns an empty vector (as no jobs can be running when you call this)
and <code>killJob</code> is not implemented for the same reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsInteractive(
  external = FALSE,
  write.logs = TRUE,
  fs.latency = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsInteractive_+3A_external">external</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, jobs are started in a fresh R session instead of currently active but still
waits for its termination.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsInteractive_+3A_write.logs">write.logs</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Sink the output to log files. Turning logging off can increase the speed of
calculations but makes it very difficult to debug.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsInteractive_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsLSF'>ClusterFunctions for LSF Systems</h2><span id='topic+makeClusterFunctionsLSF'></span>

<h3>Description</h3>

<p>Cluster functions for LSF (<a href="https://www.ibm.com/products/hpc-workload-management">https://www.ibm.com/products/hpc-workload-management</a>).
</p>
<p>Job files are created based on the brew template <code>template.file</code>. This
file is processed with brew and then submitted to the queue using the
<code>bsub</code> command. Jobs are killed using the <code>bkill</code> command and the
list of running jobs is retrieved using <code>bjobs -u $USER -w</code>. The user
must have the appropriate privileges to submit, delete and list jobs on the
cluster (this is usually the case).
</p>
<p>The template file can access all resources passed to <code><a href="#topic+submitJobs">submitJobs</a></code>
as well as all variables stored in the <code><a href="#topic+JobCollection">JobCollection</a></code>.
It is the template file's job to choose a queue for the job and handle the desired resource
allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsLSF(
  template = "lsf",
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsLSF_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsLSF_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsLSF_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>Note</h3>

<p>Array jobs are currently not supported.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsMulticore'>ClusterFunctions for Parallel Multicore Execution</h2><span id='topic+makeClusterFunctionsMulticore'></span>

<h3>Description</h3>

<p>Jobs are spawned asynchronously using the functions <code>mcparallel</code> and <code>mccollect</code> (both in <span class="pkg">parallel</span>).
Does not work on Windows, use <code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsMulticore(ncpus = NA_integer_, fs.latency = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsMulticore_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of CPUs.
Default is to use all logical cores. The total number of cores &quot;available&quot; can be set via the option <code>mc.cores</code>
and defaults to the heuristic implemented in <code><a href="parallel.html#topic+detectCores">detectCores</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsMulticore_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsOpenLava'>ClusterFunctions for OpenLava</h2><span id='topic+makeClusterFunctionsOpenLava'></span>

<h3>Description</h3>

<p>Cluster functions for OpenLava.
</p>
<p>Job files are created based on the brew template <code>template</code>. This
file is processed with brew and then submitted to the queue using the
<code>bsub</code> command. Jobs are killed using the <code>bkill</code> command and the
list of running jobs is retrieved using <code>bjobs -u $USER -w</code>. The user
must have the appropriate privileges to submit, delete and list jobs on the
cluster (this is usually the case).
</p>
<p>The template file can access all resources passed to <code><a href="#topic+submitJobs">submitJobs</a></code>
as well as all variables stored in the <code><a href="#topic+JobCollection">JobCollection</a></code>.
It is the template file's job to choose a queue for the job and handle the desired resource
allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsOpenLava(
  template = "openlava",
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsOpenLava_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsOpenLava_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsOpenLava_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>Note</h3>

<p>Array jobs are currently not supported.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsSGE'>ClusterFunctions for SGE Systems</h2><span id='topic+makeClusterFunctionsSGE'></span>

<h3>Description</h3>

<p>Cluster functions for Univa Grid Engine / Oracle Grid Engine /
Sun Grid Engine (<a href="https://www.univa.com/">https://www.univa.com/</a>).
</p>
<p>Job files are created based on the brew template <code>template</code>. This
file is processed with brew and then submitted to the queue using the
<code>qsub</code> command. Jobs are killed using the <code>qdel</code> command and the
list of running jobs is retrieved using <code>qselect</code>. The user must have
the appropriate privileges to submit, delete and list jobs on the cluster
(this is usually the case).
</p>
<p>The template file can access all resources passed to <code><a href="#topic+submitJobs">submitJobs</a></code>
as well as all variables stored in the <code><a href="#topic+JobCollection">JobCollection</a></code>.
It is the template file's job to choose a queue for the job and handle the desired resource
allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsSGE(
  template = "sge",
  nodename = "localhost",
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsSGE_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsSGE_+3A_nodename">nodename</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Nodename of the master host. All commands are send via SSH to this host. Only works iff
</p>

<ol>
<li><p>Passwordless authentication (e.g., via SSH public key authentication) is set up.
</p>
</li>
<li><p>The file directory is shared across machines, e.g. mounted via SSHFS.
</p>
</li>
<li><p>Either the absolute path to the <code>file.dir</code> is identical on the machines, or paths are provided relative to the home directory. Symbolic links should work.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsSGE_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsSGE_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>Note</h3>

<p>Array jobs are currently not supported.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsSlurm'>ClusterFunctions for Slurm Systems</h2><span id='topic+makeClusterFunctionsSlurm'></span>

<h3>Description</h3>

<p>Cluster functions for Slurm (<a href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</a>).
</p>
<p>Job files are created based on the brew template <code>template.file</code>. This
file is processed with brew and then submitted to the queue using the
<code>sbatch</code> command. Jobs are killed using the <code>scancel</code> command and
the list of running jobs is retrieved using <code>squeue</code>. The user must
have the appropriate privileges to submit, delete and list jobs on the
cluster (this is usually the case).
</p>
<p>The template file can access all resources passed to <code><a href="#topic+submitJobs">submitJobs</a></code>
as well as all variables stored in the <code><a href="#topic+JobCollection">JobCollection</a></code>.
It is the template file's job to choose a queue for the job and handle the desired resource
allocations.
</p>
<p>Note that you might have to specify the cluster name here if you do not want to use the default,
otherwise the commands for listing and killing jobs will not work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsSlurm(
  template = "slurm",
  array.jobs = TRUE,
  nodename = "localhost",
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsSlurm_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsSlurm_+3A_array.jobs">array.jobs</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If array jobs are disabled on the computing site, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsSlurm_+3A_nodename">nodename</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Nodename of the master host. All commands are send via SSH to this host. Only works iff
</p>

<ol>
<li><p>Passwordless authentication (e.g., via SSH public key authentication) is set up.
</p>
</li>
<li><p>The file directory is shared across machines, e.g. mounted via SSHFS.
</p>
</li>
<li><p>Either the absolute path to the <code>file.dir</code> is identical on the machines, or paths are provided relative to the home directory. Symbolic links should work.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsSlurm_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsSlurm_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsSocket'>ClusterFunctions for Parallel Socket Execution</h2><span id='topic+makeClusterFunctionsSocket'></span>

<h3>Description</h3>

<p>Jobs are spawned asynchronously using the package <span class="pkg">snow</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsSocket(ncpus = NA_integer_, fs.latency = 65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsSocket_+3A_ncpus">ncpus</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of CPUs.
Default is to use all logical cores. The total number of cores &quot;available&quot; can be set via the option <code>mc.cores</code>
and defaults to the heuristic implemented in <code><a href="parallel.html#topic+detectCores">detectCores</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsSocket_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeClusterFunctionsSSH'>ClusterFunctions for Remote SSH Execution</h2><span id='topic+makeClusterFunctionsSSH'></span>

<h3>Description</h3>

<p>Jobs are spawned by starting multiple R sessions via <code>Rscript</code> over SSH.
If the hostname of the <code><a href="#topic+Worker">Worker</a></code> equals &ldquo;localhost&rdquo;,
<code>Rscript</code> is called directly so that you do not need to have an SSH client installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsSSH(workers, fs.latency = 65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsSSH_+3A_workers">workers</code></td>
<td>
<p>[<code>list</code> of <code><a href="#topic+Worker">Worker</a></code>]<br />
List of Workers as constructed with <code><a href="#topic+Worker">Worker</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsSSH_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>Note</h3>

<p>If you use a custom &ldquo;.ssh/config&rdquo; file, make sure your
ProxyCommand passes &lsquo;-q&rsquo; to ssh, otherwise each output will
end with the message &ldquo;Killed by signal 1&rdquo; and this will break
the communication with the nodes.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctionsTORQUE">makeClusterFunctionsTORQUE</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# cluster functions for multicore execution on the local machine
makeClusterFunctionsSSH(list(Worker$new("localhost", ncpus = 2)))

## End(Not run)
</code></pre>

<hr>
<h2 id='makeClusterFunctionsTORQUE'>ClusterFunctions for OpenPBS/TORQUE Systems</h2><span id='topic+makeClusterFunctionsTORQUE'></span>

<h3>Description</h3>

<p>Cluster functions for TORQUE/PBS (<a href="https://adaptivecomputing.com/cherry-services/torque-resource-manager/">https://adaptivecomputing.com/cherry-services/torque-resource-manager/</a>).
</p>
<p>Job files are created based on the brew template <code>template.file</code>. This file is processed
with brew and then submitted to the queue using the <code>qsub</code> command. Jobs are killed using
the <code>qdel</code> command and the list of running jobs is retrieved using <code>qselect</code>. The user
must have the appropriate privileges to submit, delete and list jobs on the cluster (this is
usually the case).
</p>
<p>The template file can access all resources passed to <code><a href="#topic+submitJobs">submitJobs</a></code>
as well as all variables stored in the <code><a href="#topic+JobCollection">JobCollection</a></code>.
It is the template file's job to choose a queue for the job and handle the desired resource
allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClusterFunctionsTORQUE(
  template = "torque",
  scheduler.latency = 1,
  fs.latency = 65
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClusterFunctionsTORQUE_+3A_template">template</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either a path to a <span class="pkg">brew</span> template file (with extension &ldquo;tmpl&rdquo;), or a short descriptive name enabling the following heuristic for the file lookup:
</p>

<ol>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li> <p>&ldquo;batchtools.[template].tmpl&rdquo; in the current working directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the user config directory (see <code><a href="rappdirs.html#topic+user_config_dir">user_config_dir</a></code>); on linux this is usually &ldquo;~/.config/batchtools/[template].tmpl&rdquo;.
</p>
</li>
<li> <p>&ldquo;.batchtools.[template].tmpl&rdquo; in the home directory.
</p>
</li>
<li> <p>&ldquo;[template].tmpl&rdquo; in the package installation directory in the subfolder &ldquo;templates&rdquo;.
</p>
</li></ol>
</td></tr>
<tr><td><code id="makeClusterFunctionsTORQUE_+3A_scheduler.latency">scheduler.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</td></tr>
<tr><td><code id="makeClusterFunctionsTORQUE_+3A_fs.latency">fs.latency</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to <code>0</code> to disable the heuristic, e.g. if you are working on a local file system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>].
</p>


<h3>See Also</h3>

<p>Other ClusterFunctions: 
<code><a href="#topic+makeClusterFunctionsDocker">makeClusterFunctionsDocker</a>()</code>,
<code><a href="#topic+makeClusterFunctionsInteractive">makeClusterFunctionsInteractive</a>()</code>,
<code><a href="#topic+makeClusterFunctionsLSF">makeClusterFunctionsLSF</a>()</code>,
<code><a href="#topic+makeClusterFunctionsMulticore">makeClusterFunctionsMulticore</a>()</code>,
<code><a href="#topic+makeClusterFunctionsOpenLava">makeClusterFunctionsOpenLava</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSGE">makeClusterFunctionsSGE</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSSH">makeClusterFunctionsSSH</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a>()</code>,
<code><a href="#topic+makeClusterFunctionsSocket">makeClusterFunctionsSocket</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>
</p>

<hr>
<h2 id='makeExperimentRegistry'>ExperimentRegistry Constructor</h2><span id='topic+makeExperimentRegistry'></span><span id='topic+ExperimentRegistry'></span>

<h3>Description</h3>

<p><code>makeExperimentRegistry</code> constructs a special <code><a href="#topic+Registry">Registry</a></code> which
is suitable for the definition of large scale computer experiments.
</p>
<p>Each experiments consists of a <code><a href="#topic+Problem">Problem</a></code> and an <code><a href="#topic+Algorithm">Algorithm</a></code>.
These can be parametrized with <code><a href="#topic+addExperiments">addExperiments</a></code> to actually define computational
jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeExperimentRegistry(
  file.dir = "registry",
  work.dir = getwd(),
  conf.file = findConfFile(),
  packages = character(0L),
  namespaces = character(0L),
  source = character(0L),
  load = character(0L),
  seed = NULL,
  make.default = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeExperimentRegistry_+3A_file.dir">file.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path where all files of the registry are saved.
Default is directory &ldquo;registry&rdquo; in the current working directory.
The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.
</p>
<p>If you pass <code>NA</code>, a temporary directory will be used.
This way, you can create disposable registries for <code><a href="#topic+btlapply">btlapply</a></code> or examples.
By default, the temporary directory <code><a href="base.html#topic+tempdir">tempdir</a>()</code> will be used.
If you want to use another directory, e.g. a directory which is shared between nodes,
you can set it in your configuration file by setting the variable <code>temp.dir</code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_work.dir">work.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Working directory for R process for running jobs.
Defaults to the working directory currently set during Registry construction (see <code><a href="base.html#topic+getwd">getwd</a></code>).
<code>loadRegistry</code> uses the stored <code>work.dir</code>, but you may also explicitly overwrite it,
e.g., after switching to another system.
</p>
<p>The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_conf.file">conf.file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to a configuration file which is sourced while the registry is created.
In the configuration file you can define how <span class="pkg">batchtools</span> interacts with the system via <code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>.
Separating the configuration of the underlying host system from the R code allows to easily move computation to another site.
</p>
<p>The file lookup is implemented in the internal (but exported) function <code>findConfFile</code> which returns the first file found of the following candidates:
</p>

<ol>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the current working directory.
</p>
</li>
<li><p>File &ldquo;config.R&rdquo; in the user configuration directory as reported by <code>rappdirs::user_config_dir("batchtools", expand = FALSE)</code> (depending on OS, e.g., on linux this usually resolves to &ldquo;~/.config/batchtools/config.R&rdquo;).
</p>
</li>
<li><p>&ldquo;.batchtools.conf.R&rdquo; in the home directory (&ldquo;~&rdquo;).
</p>
</li>
<li><p>&ldquo;config.R&rdquo; in the site config directory as reported by <code>rappdirs::site_config_dir("batchtools")</code> (depending on OS). This file can be used for admins to set sane defaults for a computation site.
</p>
</li></ol>

<p>Set to <code>NA</code> if you want to suppress reading any configuration file.
If a configuration file is found, it gets sourced inside the environment of the registry after the defaults for all variables are set.
Therefore you can set and overwrite slots, e.g. <code>default.resources = list(walltime = 3600)</code> to set default resources or &ldquo;max.concurrent.jobs&rdquo; to
limit the number of jobs allowed to run simultaneously on the system.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_packages">packages</code></td>
<td>
<p>[<code>character</code>]<br />
Packages that will always be loaded on each node.
Uses <code><a href="base.html#topic+require">require</a></code> internally.
Default is <code>character(0)</code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_namespaces">namespaces</code></td>
<td>
<p>[<code>character</code>]<br />
Same as <code>packages</code>, but the packages will not be attached.
Uses <code><a href="base.html#topic+requireNamespace">requireNamespace</a></code> internally.
Default is <code>character(0)</code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_source">source</code></td>
<td>
<p>[<code>character</code>]<br />
Files which should be sourced on the slaves prior to executing a job.
Calls <code><a href="base.html#topic+sys.source">sys.source</a></code> using the <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_load">load</code></td>
<td>
<p>[<code>character</code>]<br />
Files which should be loaded on the slaves prior to executing a job.
Calls <code><a href="base.html#topic+load">load</a></code> using the <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_seed">seed</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Start seed for jobs. Each job uses the (<code>seed</code> + <code>job.id</code>) as seed.
Default is a random integer between 1 and 32768.
Note that there is an additional seeding mechanism to synchronize instantiation of
<code><a href="#topic+Problem">Problem</a></code>s in a <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.</p>
</td></tr>
<tr><td><code id="makeExperimentRegistry_+3A_make.default">make.default</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, the created registry is saved inside the package
namespace and acts as default registry. You might want to switch this
off if you work with multiple registries simultaneously.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>ExperimentRegistry</code>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE)

# Definde one problem, two algorithms and add them with some parameters:
addProblem(reg = tmp, "p1",
  fun = function(job, data, n, mean, sd, ...) rnorm(n, mean = mean, sd = sd))
addAlgorithm(reg = tmp, "a1", fun = function(job, data, instance, ...) mean(instance))
addAlgorithm(reg = tmp, "a2", fun = function(job, data, instance, ...) median(instance))
ids = addExperiments(reg = tmp, list(p1 = data.table::CJ(n = c(50, 100), mean = -2:2, sd = 1:4)))

# Overview over defined experiments:
tmp$problems
tmp$algorithms
summarizeExperiments(reg = tmp)
summarizeExperiments(reg = tmp, by = c("problem", "algorithm", "n"))
ids = findExperiments(prob.pars = (n == 50), reg = tmp)
print(unwrap(getJobPars(ids, reg = tmp)))

# Submit jobs
submitJobs(reg = tmp)
waitForJobs(reg = tmp)

# Reduce the results of algorithm a1
ids.mean = findExperiments(algo.name = "a1", reg = tmp)
reduceResults(ids.mean, fun = function(aggr, res, ...) c(aggr, res), reg = tmp)

# Join info table with all results and calculate mean of results
# grouped by n and algorithm
ids = findDone(reg = tmp)
pars = unwrap(getJobPars(ids, reg = tmp))
results = unwrap(reduceResultsDataTable(ids, fun = function(res) list(res = res), reg = tmp))
tab = ljoin(pars, results)
tab[, list(mres = mean(res)), by = c("n", "algorithm")]
</code></pre>

<hr>
<h2 id='makeJob'>Jobs and Experiments</h2><span id='topic+makeJob'></span><span id='topic+Job'></span><span id='topic+Experiment'></span>

<h3>Description</h3>

<p>Jobs and Experiments are abstract objects which hold all information necessary to execute a single computational
job for a <code><a href="#topic+Registry">Registry</a></code> or <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>, respectively.
</p>
<p>They can be created using the constructor <code>makeJob</code> which takes a single job id.
Jobs and Experiments are passed to reduce functions like <code><a href="#topic+reduceResults">reduceResults</a></code>.
Furthermore, Experiments can be used in the functions of the <code><a href="#topic+Problem">Problem</a></code> and <code><a href="#topic+Algorithm">Algorithm</a></code>.
Jobs and Experiments hold these information:
</p>

<dl>
<dt><code>job.id</code></dt><dd><p>Job ID as integer.</p>
</dd>
<dt><code>pars</code></dt><dd>
<p>Job parameters as named list.
For <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>, the parameters are divided into the sublists &ldquo;prob.pars&rdquo; and &ldquo;algo.pars&rdquo;.
</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed which is set via <code><a href="#topic+doJobCollection">doJobCollection</a></code> as scalar integer.</p>
</dd>
<dt><code>resources</code></dt><dd><p>Computational resources which were set for this job as named list.</p>
</dd>
<dt><code>external.dir</code></dt><dd>
<p>Path to a directory which is created exclusively for this job. You can store external files here.
Directory is persistent between multiple restarts of the job and can be cleaned by calling <code><a href="#topic+resetJobs">resetJobs</a></code>.
</p>
</dd>
<dt><code>fun</code></dt><dd><p>Job only: User function passed to <code><a href="#topic+batchMap">batchMap</a></code>.</p>
</dd>
<dt><code>prob.name</code></dt><dd><p>Experiments only: Problem id.</p>
</dd>
<dt><code>algo.name</code></dt><dd><p>Experiments only: Algorithm id.</p>
</dd>
<dt><code>problem</code></dt><dd><p>Experiments only: <code><a href="#topic+Problem">Problem</a></code>.</p>
</dd>
<dt><code>instance</code></dt><dd><p>Experiments only: Problem instance.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>Experiments only: <code><a href="#topic+Algorithm">Algorithm</a></code>.</p>
</dd>
<dt><code>repl</code></dt><dd><p>Experiments only: Replication number.</p>
</dd>
</dl>

<p>Note that the slots &ldquo;pars&rdquo;, &ldquo;fun&rdquo;, &ldquo;algorithm&rdquo; and &ldquo;problem&rdquo;
lazy-load required files from the file system and construct the object on the first access.
The realizations are cached for all slots except &ldquo;instance&rdquo; (which might be stochastic).
</p>
<p>Jobs and Experiments can be executed manually with <code><a href="#topic+execJob">execJob</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeJob(id, reader = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeJob_+3A_id">id</code></td>
<td>
<p>[<code>integer(1)</code> or <code>data.table</code>]<br />
Single integer to specify the job or a <code>data.table</code> with column <code>job.id</code>
and exactly one row.</p>
</td></tr>
<tr><td><code id="makeJob_+3A_reader">reader</code></td>
<td>
<p>[<code>RDSReader</code> | <code>NULL</code>]<br />
Reader object to retrieve files. Used internally to cache reading from the file system.
The default (<code>NULL</code>) does not make use of caching.</p>
</td></tr>
<tr><td><code id="makeJob_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>Job</code> | <code>Experiment</code>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(x, y) x + y, x = 1:2, more.args = list(y = 99), reg = tmp)
submitJobs(resources = list(foo = "bar"), reg = tmp)
job = makeJob(1, reg = tmp)
print(job)

# Get the parameters:
job$pars

# Get the job resources:
job$resources

# Execute the job locally:
execJob(job)
</code></pre>

<hr>
<h2 id='makeJobCollection'>JobCollection Constructor</h2><span id='topic+makeJobCollection'></span><span id='topic+JobCollection'></span>

<h3>Description</h3>

<p><code>makeJobCollection</code> takes multiple job ids and creates an object of class &ldquo;JobCollection&rdquo; which holds all
necessary information for the calculation with <code><a href="#topic+doJobCollection">doJobCollection</a></code>. It is implemented as an environment
with the following variables:
</p>

<dl>
<dt>file.dir</dt><dd><p><code>file.dir</code> of the <a href="#topic+Registry">Registry</a>.</p>
</dd>
<dt>work.dir:</dt><dd><p><code>work.dir</code> of the <a href="#topic+Registry">Registry</a>.</p>
</dd>
<dt>job.hash</dt><dd><p>Unique identifier of the job. Used to create names on the file system.</p>
</dd>
<dt>jobs</dt><dd><p><code><a href="data.table.html#topic+data.table">data.table</a></code> holding individual job information. See examples.</p>
</dd>
<dt>log.file</dt><dd><p>Location of the designated log file for this job.</p>
</dd>
<dt>resources:</dt><dd><p>Named list of of specified computational resources.</p>
</dd>
<dt>uri</dt><dd><p>Location of the job description file (saved with <code>link[base]{saveRDS}</code> on the file system.</p>
</dd>
<dt>seed</dt><dd><p><code>integer(1)</code> Seed of the <a href="#topic+Registry">Registry</a>.</p>
</dd>
<dt>packages</dt><dd><p><code>character</code> with required packages to load via <code><a href="base.html#topic+require">require</a></code>.</p>
</dd>
<dt>namespaces</dt><dd><p>codecharacter with required packages to load via <code><a href="base.html#topic+requireNamespace">requireNamespace</a></code>.</p>
</dd>
<dt>source</dt><dd><p><code>character</code> with list of files to source before execution.</p>
</dd>
<dt>load</dt><dd><p><code>character</code> with list of files to load before execution.</p>
</dd>
<dt>array.var</dt><dd><p><code>character(1)</code> of the array environment variable specified by the cluster functions.</p>
</dd>
<dt>array.jobs</dt><dd><p><code>logical(1)</code> signaling if jobs were submitted using <code>chunks.as.arrayjobs</code>.</p>
</dd>
</dl>

<p>If your <a href="#topic+ClusterFunctions">ClusterFunctions</a> uses a template, <code><a href="brew.html#topic+brew">brew</a></code> will be executed in the environment of such
a collection. Thus all variables available inside the job can be used in the template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeJobCollection(ids = NULL, resources = list(), reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeJobCollection_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="makeJobCollection_+3A_resources">resources</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of resources. Default is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="makeJobCollection_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>JobCollection</code>].
</p>


<h3>See Also</h3>

<p>Other JobCollection: 
<code><a href="#topic+doJobCollection">doJobCollection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE, packages = "methods")
batchMap(identity, 1:5, reg = tmp)

# resources are usually set in submitJobs()
jc = makeJobCollection(1:3, resources = list(foo = "bar"), reg = tmp)
ls(jc)
jc$resources
</code></pre>

<hr>
<h2 id='makeRegistry'>Registry Constructor</h2><span id='topic+makeRegistry'></span><span id='topic+Registry'></span>

<h3>Description</h3>

<p><code>makeRegistry</code> constructs the inter-communication object for all functions in <code>batchtools</code>.
All communication transactions are processed via the file system:
All information required to run a job is stored as <code><a href="#topic+JobCollection">JobCollection</a></code> in a file in the
a subdirectory of the <code>file.dir</code> directory.
Each jobs stores its results as well as computational status information (start time, end time, error message, ...)
also on the file system which is regular merged parsed by the master using <code><a href="#topic+syncRegistry">syncRegistry</a></code>.
After integrating the new information into the Registry, the Registry is serialized to the file system via <code><a href="#topic+saveRegistry">saveRegistry</a></code>.
Both <code><a href="#topic+syncRegistry">syncRegistry</a></code> and <code><a href="#topic+saveRegistry">saveRegistry</a></code> are called whenever required internally.
Therefore it should be safe to quit the R session at any time.
Work can later be resumed by calling <code><a href="#topic+loadRegistry">loadRegistry</a></code> which de-serializes the registry from
the file system.
</p>
<p>The registry created last is saved in the package namespace (unless <code>make.default</code> is set to
<code>FALSE</code>) and can be retrieved via <code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a></code>.
</p>
<p>Canceled jobs and jobs submitted multiple times may leave stray files behind.
These can be swept using <code><a href="#topic+sweepRegistry">sweepRegistry</a></code>.
<code><a href="#topic+clearRegistry">clearRegistry</a></code> completely erases all jobs from a registry, including log files and results,
and thus allows you to start over.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRegistry(
  file.dir = "registry",
  work.dir = getwd(),
  conf.file = findConfFile(),
  packages = character(0L),
  namespaces = character(0L),
  source = character(0L),
  load = character(0L),
  seed = NULL,
  make.default = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRegistry_+3A_file.dir">file.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path where all files of the registry are saved.
Default is directory &ldquo;registry&rdquo; in the current working directory.
The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.
</p>
<p>If you pass <code>NA</code>, a temporary directory will be used.
This way, you can create disposable registries for <code><a href="#topic+btlapply">btlapply</a></code> or examples.
By default, the temporary directory <code><a href="base.html#topic+tempdir">tempdir</a>()</code> will be used.
If you want to use another directory, e.g. a directory which is shared between nodes,
you can set it in your configuration file by setting the variable <code>temp.dir</code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_work.dir">work.dir</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Working directory for R process for running jobs.
Defaults to the working directory currently set during Registry construction (see <code><a href="base.html#topic+getwd">getwd</a></code>).
<code>loadRegistry</code> uses the stored <code>work.dir</code>, but you may also explicitly overwrite it,
e.g., after switching to another system.
</p>
<p>The provided path will get normalized unless it is given relative to the home directory
(i.e., starting with &ldquo;~&rdquo;). Note that some templates do not handle relative paths well.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_conf.file">conf.file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Path to a configuration file which is sourced while the registry is created.
In the configuration file you can define how <span class="pkg">batchtools</span> interacts with the system via <code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code>.
Separating the configuration of the underlying host system from the R code allows to easily move computation to another site.
</p>
<p>The file lookup is implemented in the internal (but exported) function <code>findConfFile</code> which returns the first file found of the following candidates:
</p>

<ol>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the path specified by the environment variable &ldquo;R_BATCHTOOLS_SEARCH_PATH&rdquo;.
</p>
</li>
<li><p>File &ldquo;batchtools.conf.R&rdquo; in the current working directory.
</p>
</li>
<li><p>File &ldquo;config.R&rdquo; in the user configuration directory as reported by <code>rappdirs::user_config_dir("batchtools", expand = FALSE)</code> (depending on OS, e.g., on linux this usually resolves to &ldquo;~/.config/batchtools/config.R&rdquo;).
</p>
</li>
<li><p>&ldquo;.batchtools.conf.R&rdquo; in the home directory (&ldquo;~&rdquo;).
</p>
</li>
<li><p>&ldquo;config.R&rdquo; in the site config directory as reported by <code>rappdirs::site_config_dir("batchtools")</code> (depending on OS). This file can be used for admins to set sane defaults for a computation site.
</p>
</li></ol>

<p>Set to <code>NA</code> if you want to suppress reading any configuration file.
If a configuration file is found, it gets sourced inside the environment of the registry after the defaults for all variables are set.
Therefore you can set and overwrite slots, e.g. <code>default.resources = list(walltime = 3600)</code> to set default resources or &ldquo;max.concurrent.jobs&rdquo; to
limit the number of jobs allowed to run simultaneously on the system.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_packages">packages</code></td>
<td>
<p>[<code>character</code>]<br />
Packages that will always be loaded on each node.
Uses <code><a href="base.html#topic+require">require</a></code> internally.
Default is <code>character(0)</code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_namespaces">namespaces</code></td>
<td>
<p>[<code>character</code>]<br />
Same as <code>packages</code>, but the packages will not be attached.
Uses <code><a href="base.html#topic+requireNamespace">requireNamespace</a></code> internally.
Default is <code>character(0)</code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_source">source</code></td>
<td>
<p>[<code>character</code>]<br />
Files which should be sourced on the slaves prior to executing a job.
Calls <code><a href="base.html#topic+sys.source">sys.source</a></code> using the <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_load">load</code></td>
<td>
<p>[<code>character</code>]<br />
Files which should be loaded on the slaves prior to executing a job.
Calls <code><a href="base.html#topic+load">load</a></code> using the <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_seed">seed</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Start seed for jobs. Each job uses the (<code>seed</code> + <code>job.id</code>) as seed.
Default is a random integer between 1 and 32768.
Note that there is an additional seeding mechanism to synchronize instantiation of
<code><a href="#topic+Problem">Problem</a></code>s in a <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.</p>
</td></tr>
<tr><td><code id="makeRegistry_+3A_make.default">make.default</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, the created registry is saved inside the package
namespace and acts as default registry. You might want to switch this
off if you work with multiple registries simultaneously.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently <span class="pkg">batchtools</span> understands the following options set via the configuration file:
</p>

<dl>
<dt><code>cluster.functions</code>:</dt><dd><p>As returned by a constructor, e.g. <code><a href="#topic+makeClusterFunctionsSlurm">makeClusterFunctionsSlurm</a></code>.</p>
</dd>
<dt><code>default.resources</code>:</dt><dd><p>List of resources to use. Will be overruled by resources specified via <code><a href="#topic+submitJobs">submitJobs</a></code>.</p>
</dd>
<dt><code>temp.dir</code>:</dt><dd><p>Path to directory to use for temporary registries.</p>
</dd>
<dt><code>sleep</code>:</dt><dd><p>Custom sleep function. See <code><a href="#topic+waitForJobs">waitForJobs</a></code>.</p>
</dd>
<dt><code>expire.after</code>:</dt><dd><p>Number of iterations before treating jobs as expired in <code><a href="#topic+waitForJobs">waitForJobs</a></code>.</p>
</dd>
<dt><code>compress</code>:</dt><dd><p>Compression algorithm to use via <code><a href="base.html#topic+saveRDS">saveRDS</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>[<code>environment</code>] of class &ldquo;Registry&rdquo; with the following slots:
</p>

<dl>
<dt><code>file.dir</code> [path]:</dt><dd><p>File directory.</p>
</dd>
<dt><code>work.dir</code> [path]:</dt><dd><p>Working directory.</p>
</dd>
<dt><code>temp.dir</code> [path]:</dt><dd><p>Temporary directory. Used if <code>file.dir</code> is <code>NA</code> to create temporary registries.</p>
</dd>
<dt><code>packages</code> [character()]:</dt><dd><p>Packages to load on the slaves.</p>
</dd>
<dt><code>namespaces</code> [character()]:</dt><dd><p>Namespaces to load on the slaves.</p>
</dd>
<dt><code>seed</code> [integer(1)]:</dt><dd><p>Registry seed. Before each job is executed, the seed <code>seed + job.id</code> is set.</p>
</dd>
<dt><code>cluster.functions</code> [cluster.functions]:</dt><dd><p>Usually set in your <code>conf.file</code>. Set via a call to <code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a></code>. See example.</p>
</dd>
<dt><code>default.resources</code> [named list()]:</dt><dd><p>Usually set in your <code>conf.file</code>. Named list of default resources.</p>
</dd>
<dt><code>max.concurrent.jobs</code> [integer(1)]:</dt><dd><p>Usually set in your <code>conf.file</code>. Maximum number of concurrent jobs for a single user and current registry on the system.
<code><a href="#topic+submitJobs">submitJobs</a></code> will try to respect this setting. The resource &ldquo;max.concurrent.jobs&rdquo; has higher precedence.</p>
</dd>
<dt><code>defs</code> [data.table]:</dt><dd><p>Table with job definitions (i.e. parameters).</p>
</dd>
<dt><code>status</code> [data.table]:</dt><dd><p>Table holding information about the computational status. Also see <code><a href="#topic+getJobStatus">getJobStatus</a></code>.</p>
</dd>
<dt><code>resources</code> [data.table]:</dt><dd><p>Table holding information about the computational resources used for the job. Also see <code><a href="#topic+getJobResources">getJobResources</a></code>.</p>
</dd>
<dt><code>tags</code> [data.table]:</dt><dd><p>Table holding information about tags. See <a href="#topic+Tags">Tags</a>.</p>
</dd>
<dt><code>hash</code> [character(1)]:</dt><dd><p>Unique hash which changes each time the registry gets saved to the file system. Can be utilized to invalidate the cache of <span class="pkg">knitr</span>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
print(tmp)

# Set cluster functions to interactive mode and start jobs in external R sessions
tmp$cluster.functions = makeClusterFunctionsInteractive(external = TRUE)

# Change packages to load
tmp$packages = c("MASS")
saveRegistry(reg = tmp)
</code></pre>

<hr>
<h2 id='makeSubmitJobResult'>Create a SubmitJobResult</h2><span id='topic+makeSubmitJobResult'></span><span id='topic+SubmitJobResult'></span>

<h3>Description</h3>

<p>This function is only intended for use in your own cluster functions implementation.
</p>
<p>Use this function in your implementation of <code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a></code> to create a return
value for the <code>submitJob</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSubmitJobResult(
  status,
  batch.id,
  log.file = NA_character_,
  msg = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSubmitJobResult_+3A_status">status</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Launch status of job. 0 means success, codes between 1 and 100 are temporary errors and any
error greater than 100 is a permanent failure.</p>
</td></tr>
<tr><td><code id="makeSubmitJobResult_+3A_batch.id">batch.id</code></td>
<td>
<p>[<code>character()</code>]<br />
Unique id of this job on batch system, as given by the batch system.
Must be globally unique so that the job can be terminated using just this information.
For array jobs, this may be a vector of length equal to the number of jobs in the array.</p>
</td></tr>
<tr><td><code id="makeSubmitJobResult_+3A_log.file">log.file</code></td>
<td>
<p>[<code>character()</code>]<br />
Log file. If <code>NA</code>, defaults to <code>[job.hash].log</code>.
Some cluster functions set this for array jobs.</p>
</td></tr>
<tr><td><code id="makeSubmitJobResult_+3A_msg">msg</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Optional error message in case <code>status</code> is not equal to 0. Default is &ldquo;OK&rdquo;,
&ldquo;TEMPERROR&rdquo;, &ldquo;ERROR&rdquo;, depending on <code>status</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+SubmitJobResult">SubmitJobResult</a></code>]. A list, containing
<code>status</code>, <code>batch.id</code> and <code>msg</code>.
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+runOSCommand">runOSCommand</a>()</code>
</p>

<hr>
<h2 id='reduceResults'>Reduce Results</h2><span id='topic+reduceResults'></span>

<h3>Description</h3>

<p>A version of <code><a href="base.html#topic+Reduce">Reduce</a></code> for <code><a href="#topic+Registry">Registry</a></code> objects
which iterates over finished jobs and aggregates them.
All jobs must have terminated, an error is raised otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceResults(fun, ids = NULL, init, ..., reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceResults_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
A function to reduce the results. The result of previous iterations (or
the <code>init</code>) will be passed as first argument, the result of of the
i-th iteration as second. See <code><a href="base.html#topic+Reduce">Reduce</a></code> for some
examples.
If the function has the formal argument &ldquo;job&rdquo;, the <code><a href="#topic+Job">Job</a></code>/<code><a href="#topic+Experiment">Experiment</a></code>
is also passed to the function (named).</p>
</td></tr>
<tr><td><code id="reduceResults_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findDone">findDone</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="reduceResults_+3A_init">init</code></td>
<td>
<p>[<code>ANY</code>]<br />
Initial element, as used in <code><a href="base.html#topic+Reduce">Reduce</a></code>.
If missing, the reduction uses the result of the first job as <code>init</code> and the reduction starts
with the second job.</p>
</td></tr>
<tr><td><code id="reduceResults_+3A_...">...</code></td>
<td>
<p>[<code>ANY</code>]<br />
Additional arguments passed to function <code>fun</code>.</p>
</td></tr>
<tr><td><code id="reduceResults_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated results in the same order as provided ids.
Return type depends on the user function. If <code>ids</code>
is empty, <code>reduceResults</code> returns <code>init</code> (if available) or <code>NULL</code> otherwise.
</p>


<h3>Note</h3>

<p>If you have thousands of jobs, disabling the progress bar (<code>options(batchtools.progress = FALSE)</code>)
can significantly increase the performance.
</p>


<h3>See Also</h3>

<p>Other Results: 
<code><a href="#topic+batchMapResults">batchMapResults</a>()</code>,
<code><a href="#topic+loadResult">loadResult</a>()</code>,
<code><a href="#topic+reduceResultsList">reduceResultsList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(a, b) list(sum = a+b, prod = a*b), a = 1:3, b = 1:3, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)

# Extract element sum from each result
reduceResults(function(aggr, res) c(aggr, res$sum), init = list(), reg = tmp)

# Aggregate element sum via '+'
reduceResults(function(aggr, res) aggr + res$sum, init = 0, reg = tmp)

# Aggregate element prod via '*' where parameter b &lt; 3
reduce = function(aggr, res, job) {
  if (job$pars$b &gt;= 3)
    return(aggr)
  aggr * res$prod
}
reduceResults(reduce, init = 1, reg = tmp)

# Reduce to data.frame() (inefficient, use reduceResultsDataTable() instead)
reduceResults(rbind, init = data.frame(), reg = tmp)

# Reduce to data.frame by collecting results first, then utilize vectorization of rbind:
res = reduceResultsList(fun = as.data.frame, reg = tmp)
do.call(rbind, res)

# Reduce with custom combine function:
comb = function(x, y) list(sum = x$sum + y$sum, prod = x$prod * y$prod)
reduceResults(comb, reg = tmp)

# The same with neutral element NULL
comb = function(x, y) if (is.null(x)) y else list(sum = x$sum + y$sum, prod = x$prod * y$prod)
reduceResults(comb, init = NULL, reg = tmp)

# Alternative: Reduce in list, reduce manually in a 2nd step
res = reduceResultsList(reg = tmp)
Reduce(comb, res)
</code></pre>

<hr>
<h2 id='reduceResultsList'>Apply Functions on Results</h2><span id='topic+reduceResultsList'></span><span id='topic+reduceResultsDataTable'></span>

<h3>Description</h3>

<p>Applies a function on the results of your finished jobs and thereby collects
them in a <code><a href="base.html#topic+list">list</a></code> or <code><a href="data.table.html#topic+data.table">data.table</a></code>.
The later requires the provided function to return a list (or <code>data.frame</code>) of scalar values.
See <code><a href="data.table.html#topic+rbindlist">rbindlist</a></code> for features and limitations of the aggregation.
</p>
<p>If not all jobs are terminated, the respective result will be <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceResultsList(
  ids = NULL,
  fun = NULL,
  ...,
  missing.val,
  reg = getDefaultRegistry()
)

reduceResultsDataTable(
  ids = NULL,
  fun = NULL,
  ...,
  missing.val,
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceResultsList_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findDone">findDone</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="reduceResultsList_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
Function to apply to each result. The result is passed unnamed as first argument. If <code>NULL</code>, the identity is used.
If the function has the formal argument &ldquo;job&rdquo;, the <code><a href="#topic+Job">Job</a></code>/<code><a href="#topic+Experiment">Experiment</a></code> is also passed to the function.</p>
</td></tr>
<tr><td><code id="reduceResultsList_+3A_...">...</code></td>
<td>
<p>[<code>ANY</code>]<br />
Additional arguments passed to to function <code>fun</code>.</p>
</td></tr>
<tr><td><code id="reduceResultsList_+3A_missing.val">missing.val</code></td>
<td>
<p>[<code>ANY</code>]<br />
Value to impute as result for a job which is not finished.
If not provided and a result is missing, an exception is raised.</p>
</td></tr>
<tr><td><code id="reduceResultsList_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>reduceResultsList</code> returns a list of the results in the same order as the provided ids.
<code>reduceResultsDataTable</code> returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns &ldquo;job.id&rdquo; and additional result columns
created via <code><a href="data.table.html#topic+rbindlist">rbindlist</a></code>, sorted by &ldquo;job.id&rdquo;.
</p>


<h3>Note</h3>

<p>If you have thousands of jobs, disabling the progress bar (<code>options(batchtools.progress = FALSE)</code>)
can significantly increase the performance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduceResults">reduceResults</a></code>
</p>
<p>Other Results: 
<code><a href="#topic+batchMapResults">batchMapResults</a>()</code>,
<code><a href="#topic+loadResult">loadResult</a>()</code>,
<code><a href="#topic+reduceResults">reduceResults</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1 - reduceResultsList
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(x) x^2, x = 1:10, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)
reduceResultsList(fun = sqrt, reg = tmp)

### Example 2 - reduceResultsDataTable
tmp = makeExperimentRegistry(file.dir = NA, make.default = FALSE)

# add first problem
fun = function(job, data, n, mean, sd, ...) rnorm(n, mean = mean, sd = sd)
addProblem("rnorm", fun = fun, reg = tmp)

# add second problem
fun = function(job, data, n, lambda, ...) rexp(n, rate = lambda)
addProblem("rexp", fun = fun, reg = tmp)

# add first algorithm
fun = function(instance, method, ...) if (method == "mean") mean(instance) else median(instance)
addAlgorithm("average", fun = fun, reg = tmp)

# add second algorithm
fun = function(instance, ...) sd(instance)
addAlgorithm("deviation", fun = fun, reg = tmp)

# define problem and algorithm designs
library(data.table)
prob.designs = algo.designs = list()
prob.designs$rnorm = CJ(n = 100, mean = -1:1, sd = 1:5)
prob.designs$rexp = data.table(n = 100, lambda = 1:5)
algo.designs$average = data.table(method = c("mean", "median"))
algo.designs$deviation = data.table()

# add experiments and submit
addExperiments(prob.designs, algo.designs, reg = tmp)
submitJobs(reg = tmp)

# collect results and join them with problem and algorithm paramters
res = ijoin(
  getJobPars(reg = tmp),
  reduceResultsDataTable(reg = tmp, fun = function(x) list(res = x))
)
unwrap(res, sep = ".")
</code></pre>

<hr>
<h2 id='removeExperiments'>Remove Experiments</h2><span id='topic+removeExperiments'></span>

<h3>Description</h3>

<p>Remove Experiments from an <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>.
This function automatically checks if any of the jobs to reset is either pending or running.
However, if the implemented heuristic fails, this can lead to inconsistencies in the data base.
Use with care while jobs are running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeExperiments(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeExperiments_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to no job.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="removeExperiments_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>]<br />
Registry. If not explicitly passed, uses the last created registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] of removed job ids, invisibly.
</p>


<h3>See Also</h3>

<p>Other Experiment: 
<code><a href="#topic+addExperiments">addExperiments</a>()</code>,
<code><a href="#topic+summarizeExperiments">summarizeExperiments</a>()</code>
</p>

<hr>
<h2 id='removeRegistry'>Remove a Registry from the File System</h2><span id='topic+removeRegistry'></span>

<h3>Description</h3>

<p>All files will be erased from the file system, including all results.
If you wish to remove only intermediate files, use <code><a href="#topic+sweepRegistry">sweepRegistry</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeRegistry(wait = 5, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeRegistry_+3A_wait">wait</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Seconds to wait before proceeding. This is a safety measure to not
accidentally remove your precious files. Set to 0 in
non-interactive scripts to disable this precaution.</p>
</td></tr>
<tr><td><code id="removeRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]: Path of the deleted file directory.
</p>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
removeRegistry(0, tmp)
</code></pre>

<hr>
<h2 id='resetJobs'>Reset the Computational State of Jobs</h2><span id='topic+resetJobs'></span>

<h3>Description</h3>

<p>Resets the computational state of jobs in the <code><a href="#topic+Registry">Registry</a></code>.
This function automatically checks if any of the jobs to reset is either pending or running.
However, if the implemented heuristic fails, this can lead to inconsistencies in the data base.
Use with care while jobs are running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetJobs(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetJobs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to no job.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="resetJobs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] of job ids which have been reset.
See <code><a href="#topic+JoinTables">JoinTables</a></code> for examples on working with job tables.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>

<hr>
<h2 id='runHook'>Trigger Evaluation of Custom Function</h2><span id='topic+runHook'></span><span id='topic+Hooks'></span><span id='topic+Hook'></span>

<h3>Description</h3>

<p>Hooks allow to trigger functions calls on specific events.
They can be specified via the <code><a href="#topic+ClusterFunctions">ClusterFunctions</a></code> and are triggered on the following events:
</p>

<dl>
<dt><code>pre.sync</code></dt><dd><p><code>function(reg, fns, ...)</code>: Run before synchronizing the registry on the master. <code>fn</code> is the character vector of paths to the update files.</p>
</dd>
<dt><code>post.sync</code></dt><dd><p><code>function(reg, updates, ...)</code>: Run after synchronizing the registry on the master. <code>updates</code> is the data.table of processed updates.</p>
</dd>
<dt><code>pre.submit.job</code></dt><dd><p><code>function(reg, ...)</code>: Run before a job is successfully submitted to the scheduler on the master.</p>
</dd>
<dt><code>post.submit.job</code></dt><dd><p><code>function(reg, ...)</code>: Run after a job is successfully submitted to the scheduler on the master.</p>
</dd>
<dt><code>pre.submit</code></dt><dd><p><code>function(reg, ...)</code>: Run before any job is submitted to the scheduler.</p>
</dd>
<dt><code>post.submit</code></dt><dd><p><code>function(reg, ...)</code>: Run after a jobs are submitted to the schedule.</p>
</dd>
<dt><code>pre.do.collection</code></dt><dd><p><code>function(reg, reader, ...)</code>: Run before starting the job collection on the slave.
<code>reader</code> is an internal cache object.</p>
</dd>
<dt><code>post.do.collection</code></dt><dd><p><code>function(reg, updates, reader, ...)</code>: Run after all jobs in the chunk are terminated on the slave.
<code>updates</code> is a <code><a href="data.table.html#topic+data.table">data.table</a></code> of updates which will be merged with the <code><a href="#topic+Registry">Registry</a></code> by the master.
<code>reader</code> is an internal cache object.</p>
</dd>
<dt><code>pre.kill</code></dt><dd><p><code>function(reg, ids, ...)</code>: Run before any job is killed.</p>
</dd>
<dt><code>post.kill</code></dt><dd><p><code>function(reg, ids, ...)</code>: Run after jobs are killed. <code>ids</code> is the return value of <code><a href="#topic+killJobs">killJobs</a></code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>runHook(obj, hook, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runHook_+3A_obj">obj</code></td>
<td>
<p>[<a href="#topic+Registry">Registry</a> | <a href="#topic+JobCollection">JobCollection</a>]<br />
Registry which contains the <a href="#topic+ClusterFunctions">ClusterFunctions</a> with element &ldquo;hooks&rdquo;
or a <a href="#topic+JobCollection">JobCollection</a> which holds the subset of functions which are executed
remotely.</p>
</td></tr>
<tr><td><code id="runHook_+3A_hook">hook</code></td>
<td>
<p>[<code>character(1)</code>]<br />
ID of the hook as string.</p>
</td></tr>
<tr><td><code id="runHook_+3A_...">...</code></td>
<td>
<p>[ANY]<br />
Additional arguments passed to the function referenced by <code>hook</code>.
See description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return value of the called function, or <code>NULL</code> if there is no hook
with the specified ID.
</p>

<hr>
<h2 id='runOSCommand'>Run OS Commands on Local or Remote Machines</h2><span id='topic+runOSCommand'></span>

<h3>Description</h3>

<p>This is a helper function to run arbitrary OS commands on local or remote machines.
The interface is similar to <code><a href="base.html#topic+system2">system2</a></code>, but it always returns the exit status
<em>and</em> the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOSCommand(
  sys.cmd,
  sys.args = character(0L),
  stdin = "",
  nodename = "localhost"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOSCommand_+3A_sys.cmd">sys.cmd</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Command to run.</p>
</td></tr>
<tr><td><code id="runOSCommand_+3A_sys.args">sys.args</code></td>
<td>
<p>[<code>character</code>]<br />
Arguments for <code>sys.cmd</code>.</p>
</td></tr>
<tr><td><code id="runOSCommand_+3A_stdin">stdin</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Argument passed to <code><a href="base.html#topic+system2">system2</a></code>.</p>
</td></tr>
<tr><td><code id="runOSCommand_+3A_nodename">nodename</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the SSH node to run the command on. If set to &ldquo;localhost&rdquo; (default), the command
is not piped through SSH.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>named list</code>] with &ldquo;sys.cmd&rdquo;, &ldquo;sys.args&rdquo;, &ldquo;exit.code&rdquo; (integer), &ldquo;output&rdquo; (character).
</p>


<h3>See Also</h3>

<p>Other ClusterFunctionsHelper: 
<code><a href="#topic+cfBrewTemplate">cfBrewTemplate</a>()</code>,
<code><a href="#topic+cfHandleUnknownSubmitError">cfHandleUnknownSubmitError</a>()</code>,
<code><a href="#topic+cfKillJob">cfKillJob</a>()</code>,
<code><a href="#topic+cfReadBrewTemplate">cfReadBrewTemplate</a>()</code>,
<code><a href="#topic+makeClusterFunctions">makeClusterFunctions</a>()</code>,
<code><a href="#topic+makeSubmitJobResult">makeSubmitJobResult</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runOSCommand("ls")
runOSCommand("ls", "-al")
runOSCommand("notfound")

## End(Not run)
</code></pre>

<hr>
<h2 id='saveRegistry'>Store the Registy to the File System</h2><span id='topic+saveRegistry'></span>

<h3>Description</h3>

<p>Stores the registry on the file system in its &ldquo;file.dir&rdquo; (specified
for construction in <code><a href="#topic+makeRegistry">makeRegistry</a></code>, can be accessed via
<code>reg$file.dir</code>).
This function is usually called internally whenever needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRegistry(reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]: <code>TRUE</code> if the registry was saved,
<code>FALSE</code> otherwise (if the registry is read-only).
</p>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>

<hr>
<h2 id='showLog'>Inspect Log Files</h2><span id='topic+showLog'></span><span id='topic+getLog'></span>

<h3>Description</h3>

<p><code>showLog</code> opens the log in the pager. For customization, see <code><a href="base.html#topic+file.show">file.show</a></code>.
<code>getLog</code> returns the log as character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showLog(id, reg = getDefaultRegistry())

getLog(id, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showLog_+3A_id">id</code></td>
<td>
<p>[<code>integer(1)</code> or <code>data.table</code>]<br />
Single integer to specify the job or a <code>data.table</code> with column <code>job.id</code>
and exactly one row.</p>
</td></tr>
<tr><td><code id="showLog_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+testJob">testJob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)

# Create some dummy jobs
fun = function(i) {
  if (i == 3) stop(i)
  if (i %% 2 == 1) warning("That's odd.")
}
ids = batchMap(fun, i = 1:5, reg = tmp)
submitJobs(reg = tmp)
waitForJobs(reg = tmp)
getStatus(reg = tmp)

writeLines(getLog(ids[1], reg = tmp))
## Not run: 
showLog(ids[1], reg = tmp)

## End(Not run)

grepLogs(pattern = "warning", ignore.case = TRUE, reg = tmp)
</code></pre>

<hr>
<h2 id='submitJobs'>Submit Jobs to the Batch Systems</h2><span id='topic+submitJobs'></span>

<h3>Description</h3>

<p>Submits defined jobs to the batch system.
</p>
<p>After submitting the jobs, you can use <code><a href="#topic+waitForJobs">waitForJobs</a></code> to wait for the
termination of jobs or call <code><a href="#topic+reduceResultsList">reduceResultsList</a></code>/<code><a href="#topic+reduceResults">reduceResults</a></code>
to collect partial results.
The progress can be monitored with <code><a href="#topic+getStatus">getStatus</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submitJobs(
  ids = NULL,
  resources = list(),
  sleep = NULL,
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submitJobs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findNotSubmitted">findNotSubmitted</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="submitJobs_+3A_resources">resources</code></td>
<td>
<p>[<code>named list</code>]<br />
Computational  resources for the jobs to submit. The actual elements of this list
(e.g. something like &ldquo;walltime&rdquo; or &ldquo;nodes&rdquo;) depend on your template file, exceptions are outlined in the section 'Resources'.
Default settings for a system can be set in the configuration file by defining the named list <code>default.resources</code>.
Note that these settings are merged by name, e.g. merging <code>list(walltime = 300)</code> into <code>list(walltime = 400, memory = 512)</code>
will result in <code>list(walltime = 300, memory = 512)</code>.
Same holds for individual job resources passed as additional column of <code>ids</code> (c.f. section 'Resources').</p>
</td></tr>
<tr><td><code id="submitJobs_+3A_sleep">sleep</code></td>
<td>
<p>[<code>function(i)</code> | <code>numeric(1)</code>]<br />
Parameter to control the duration to sleep between temporary errors.
You can pass an absolute numeric value in seconds or a <code>function(i)</code> which returns the number of seconds to sleep in the <code>i</code>-th
iteration between temporary errors.
If not provided (<code>NULL</code>), tries to read the value (number/function) from the configuration file (stored in <code>reg$sleep</code>) or defaults to
a function with exponential backoff between 5 and 120 seconds.</p>
</td></tr>
<tr><td><code id="submitJobs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with columns &ldquo;job.id&rdquo; and &ldquo;chunk&rdquo;.
</p>


<h3>Resources</h3>

<p>You can pass arbitrary resources to <code>submitJobs()</code> which then are available in the cluster function template.
Some resources' names are standardized and it is good practice to stick to the following nomenclature to avoid confusion:
</p>

<dl>
<dt>walltime:</dt><dd><p>Upper time limit in seconds for jobs before they get killed by the scheduler. Can be passed as additional column as part of <code>ids</code> to set per-job resources.</p>
</dd>
<dt>memory:</dt><dd><p>Memory limit in Mb. If jobs exceed this limit, they are usually killed by the scheduler. Can be passed as additional column as part of <code>ids</code> to set per-job resources.</p>
</dd>
<dt>ncpus:</dt><dd><p>Number of (physical) CPUs to use on the slave. Can be passed as additional column as part of <code>ids</code> to set per-job resources.</p>
</dd>
<dt>omp.threads:</dt><dd><p>Number of threads to use via OpenMP. Used to set environment variable &ldquo;OMP_NUM_THREADS&rdquo;. Can be passed as additional column as part of <code>ids</code> to set per-job resources.</p>
</dd>
<dt>pp.size:</dt><dd><p>Maximum size of the pointer protection stack, see <code><a href="base.html#topic+Memory">Memory</a></code>.</p>
</dd>
<dt>blas.threads:</dt><dd><p>Number of threads to use for the BLAS backend. Used to set environment variables &ldquo;MKL_NUM_THREADS&rdquo; and &ldquo;OPENBLAS_NUM_THREADS&rdquo;. Can be passed as additional column as part of <code>ids</code> to set per-job resources.</p>
</dd>
<dt>measure.memory:</dt><dd><p>Enable memory measurement for jobs. Comes with a small runtime overhead.</p>
</dd>
<dt>chunks.as.arrayjobs:</dt><dd><p>Execute chunks as array jobs.</p>
</dd>
<dt>pm.backend:</dt><dd><p>Start a <span class="pkg">parallelMap</span> backend on the slave.</p>
</dd>
<dt>foreach.backend:</dt><dd><p>Start a <span class="pkg">foreach</span> backend on the slave.</p>
</dd>
<dt>clusters:</dt><dd><p>Resource used for Slurm to select the set of clusters to run <code>sbatch</code>/<code>squeue</code>/<code>scancel</code> on.</p>
</dd>
</dl>



<h3>Chunking of Jobs</h3>

<p>Multiple jobs can be grouped (chunked) together to be executed sequentially on the batch system as a single batch job.
This is especially useful to avoid overburding the scheduler by submitting thousands of jobs simultaneously.
To chunk jobs together, job ids must be provided as <code>data.frame</code> with columns &ldquo;job.id&rdquo; and &ldquo;chunk&rdquo; (integer).
All jobs with the same chunk number will be executed sequentially inside the same batch job.
The utility functions <code><a href="#topic+chunk">chunk</a></code>, <code><a href="#topic+binpack">binpack</a></code> and <code><a href="#topic+lpt">lpt</a></code>
can assist in grouping jobs.
</p>


<h3>Array Jobs</h3>

<p>If your cluster supports array jobs, you can set the resource <code>chunks.as.arrayjobs</code> to <code>TRUE</code> in order
to execute chunks as job arrays on the cluster.
For each chunk of size <code>n</code>, <span class="pkg">batchtools</span> creates a <code><a href="#topic+JobCollection">JobCollection</a></code> of (possibly heterogeneous) jobs which is
submitted to the scheduler as a single array job with <code>n</code> repetitions.
For each repetition, the <code>JobCollection</code> is first read from the file system, then subsetted to the <code>i</code>-th job using
the environment variable <code>reg$cluster.functions$array.var</code> (depending on the cluster backend, defined automatically) and finally
executed.
</p>


<h3>Order of Submission</h3>

<p>Jobs are submitted in the order of chunks, i.e. jobs which have chunk number
<code>sort(unique(ids$chunk))[1]</code> first, then jobs with chunk number <code>sort(unique(ids$chunk))[2]</code>
and so on. If no chunks are provided, jobs are submitted in the order of <code>ids$job.id</code>.
</p>


<h3>Limiting the Number of Jobs</h3>

<p>If requested, <code>submitJobs</code> tries to limit the number of concurrent jobs of the user by waiting until jobs terminate
before submitting new ones.
This can be controlled by setting &ldquo;max.concurrent.jobs&rdquo; in the configuration file (see <code><a href="#topic+Registry">Registry</a></code>)
or by setting the resource &ldquo;max.concurrent.jobs&rdquo; to the maximum number of jobs to run simultaneously.
If both are set, the setting via the resource takes precedence over the setting in the configuration.
</p>


<h3>Measuring Memory</h3>

<p>Setting the resource <code>measure.memory</code> to <code>TRUE</code> turns on memory measurement:
<code><a href="base.html#topic+gc">gc</a></code> is called  directly before and after the job and the difference is
stored in the internal database. Note that this is just a rough estimate and does
neither work reliably for external code like C/C++ nor in combination with threading.
</p>


<h3>Inner Parallelization</h3>

<p>Inner parallelization is typically done via threading, sockets or MPI.
Two backends are supported to assist in setting up inner parallelization.
</p>
<p>The first package is <span class="pkg">parallelMap</span>.
If you set the resource &ldquo;pm.backend&rdquo; to &ldquo;multicore&rdquo;, &ldquo;socket&rdquo; or &ldquo;mpi&rdquo;,
<code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> is called on the slave before the first job in the chunk is started
and <code><a href="parallelMap.html#topic+parallelStop">parallelStop</a></code> is called after the last job terminated.
This way, the resources for inner parallelization can be set and get automatically stored just like other computational resources.
The function provided by the user just has to call <code><a href="parallelMap.html#topic+parallelMap">parallelMap</a></code> to start parallelization using the preconfigured backend.
</p>
<p>To control the number of CPUs, you have to set the resource <code>ncpus</code>.
Otherwise <code>ncpus</code> defaults to the number of available CPUs (as reported by (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>))
on the executing machine for multicore and socket mode and defaults to the return value of <code><a href="Rmpi.html#topic+mpi.universe.size">mpi.universe.size</a>-1</code> for MPI.
Your template must be set up to handle the parallelization, e.g. request the right number of CPUs or start R with <code>mpirun</code>.
You may pass further options like <code>level</code> to <code><a href="parallelMap.html#topic+parallelStart">parallelStart</a></code> via the named list &ldquo;pm.opts&rdquo;.
</p>
<p>The second supported parallelization backend is <span class="pkg">foreach</span>.
If you set the resource &ldquo;foreach.backend&rdquo; to &ldquo;seq&rdquo; (sequential mode), &ldquo;parallel&rdquo; (<span class="pkg">doParallel</span>) or
&ldquo;mpi&rdquo; (<span class="pkg">doMPI</span>), the requested <span class="pkg">foreach</span> backend is automatically registered on the slave.
Again, the resource <code>ncpus</code> is used to determine the number of CPUs.
</p>
<p>Neither the namespace of <span class="pkg">parallelMap</span> nor the namespace <span class="pkg">foreach</span> are attached.
You have to do this manually via <code><a href="base.html#topic+library">library</a></code> or let the registry load the packages for you.
</p>


<h3>Note</h3>

<p>If you a large number of jobs, disabling the progress bar (<code>options(batchtools.progress = FALSE)</code>)
can significantly increase the performance of <code>submitJobs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: Submit subsets of jobs
tmp = makeRegistry(file.dir = NA, make.default = FALSE)

# toy function which fails if x is even and an input file does not exists
fun = function(x, fn) if (x %% 2 == 0 &amp;&amp; !file.exists(fn)) stop("file not found") else x

# define jobs via batchMap
fn = tempfile()
ids = batchMap(fun, 1:20, reg = tmp, fn = fn)

# submit some jobs
ids = 1:10
submitJobs(ids, reg = tmp)
waitForJobs(ids, reg = tmp)
getStatus(reg = tmp)

# create the required file and re-submit failed jobs
file.create(fn)
submitJobs(findErrors(ids, reg = tmp), reg = tmp)
getStatus(reg = tmp)

# submit remaining jobs which have not yet been submitted
ids = findNotSubmitted(reg = tmp)
submitJobs(ids, reg = tmp)
getStatus(reg = tmp)

# collect results
reduceResultsList(reg = tmp)

### Example 2: Using memory measurement
tmp = makeRegistry(file.dir = NA, make.default = FALSE)

# Toy function which creates a large matrix and returns the column sums
fun = function(n, p) colMeans(matrix(runif(n*p), n, p))

# Arguments to fun:
args = data.table::CJ(n = c(1e4, 1e5), p = c(10, 50)) # like expand.grid()
print(args)

# Map function to create jobs
ids = batchMap(fun, args = args, reg = tmp)

# Set resources: enable memory measurement
res = list(measure.memory = TRUE)

# Submit jobs using the currently configured cluster functions
submitJobs(ids, resources = res, reg = tmp)

# Retrive information about memory, combine with parameters
info = ijoin(getJobStatus(reg = tmp)[, .(job.id, mem.used)], getJobPars(reg = tmp))
print(unwrap(info))

# Combine job info with results -&gt; each job is aggregated using mean()
unwrap(ijoin(info, reduceResultsDataTable(fun = function(res) list(res = mean(res)), reg = tmp)))

### Example 3: Multicore execution on the slave
tmp = makeRegistry(file.dir = NA, make.default = FALSE)

# Function which sleeps 10 seconds, i-times
f = function(i) {
  parallelMap::parallelMap(Sys.sleep, rep(10, i))
}

# Create one job with parameter i=4
ids = batchMap(f, i = 4, reg = tmp)

# Set resources: Use parallelMap in multicore mode with 4 CPUs
# batchtools internally loads the namespace of parallelMap and then
# calls parallelStart() before the job and parallelStop() right
# after the job last job in the chunk terminated.
res = list(pm.backend = "multicore", ncpus = 4)

## Not run: 
# Submit both jobs and wait for them
submitJobs(resources = res, reg = tmp)
waitForJobs(reg = tmp)

# If successfull, the running time should be ~10s
getJobTable(reg = tmp)[, .(job.id, time.running)]

# There should also be a note in the log:
grepLogs(pattern = "parallelMap", reg = tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarizeExperiments'>Quick Summary over Experiments</h2><span id='topic+summarizeExperiments'></span>

<h3>Description</h3>

<p>Returns a frequency table of defined experiments.
See <code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code> for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeExperiments(
  ids = NULL,
  by = c("problem", "algorithm"),
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeExperiments_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="summarizeExperiments_+3A_by">by</code></td>
<td>
<p>[<code>character</code>]<br />
Split the resulting table by columns of <code><a href="#topic+getJobPars">getJobPars</a></code>.</p>
</td></tr>
<tr><td><code id="summarizeExperiments_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+ExperimentRegistry">ExperimentRegistry</a></code>]<br />
Registry. If not explicitly passed, uses the last created registry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] of frequencies.
</p>


<h3>See Also</h3>

<p>Other Experiment: 
<code><a href="#topic+addExperiments">addExperiments</a>()</code>,
<code><a href="#topic+removeExperiments">removeExperiments</a>()</code>
</p>

<hr>
<h2 id='sweepRegistry'>Check Consistency and Remove Obsolete Information</h2><span id='topic+sweepRegistry'></span>

<h3>Description</h3>

<p>Canceled jobs and jobs submitted multiple times may leave stray files behind.
This function checks the registry for consistency and removes obsolete files
and redundant data base entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sweepRegistry(reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sweepRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+syncRegistry">syncRegistry</a>()</code>
</p>

<hr>
<h2 id='syncRegistry'>Synchronize the Registry</h2><span id='topic+syncRegistry'></span>

<h3>Description</h3>

<p>Parses update files written by the slaves to the file system and updates the
internal data base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncRegistry(reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syncRegistry_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]: <code>TRUE</code> if the state has changed, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p>Other Registry: 
<code><a href="#topic+clearRegistry">clearRegistry</a>()</code>,
<code><a href="#topic+getDefaultRegistry">getDefaultRegistry</a>()</code>,
<code><a href="#topic+loadRegistry">loadRegistry</a>()</code>,
<code><a href="#topic+makeRegistry">makeRegistry</a>()</code>,
<code><a href="#topic+removeRegistry">removeRegistry</a>()</code>,
<code><a href="#topic+saveRegistry">saveRegistry</a>()</code>,
<code><a href="#topic+sweepRegistry">sweepRegistry</a>()</code>
</p>

<hr>
<h2 id='Tags'>Add or Remove Job Tags</h2><span id='topic+Tags'></span><span id='topic+addJobTags'></span><span id='topic+removeJobTags'></span><span id='topic+getUsedJobTags'></span>

<h3>Description</h3>

<p>Add and remove arbitrary tags to jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addJobTags(ids = NULL, tags, reg = getDefaultRegistry())

removeJobTags(ids = NULL, tags, reg = getDefaultRegistry())

getUsedJobTags(ids = NULL, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tags_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to all jobs.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="Tags_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Tags to add or remove as strings. Each tag may consist of letters, numbers, underscore and dots (pattern &ldquo;^[[:alnum:]_.]+&rdquo;).</p>
</td></tr>
<tr><td><code id="Tags_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>] with job ids affected (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
ids = batchMap(sqrt, x = -3:3, reg = tmp)

# Add new tag to all ids
addJobTags(ids, "needs.computation", reg = tmp)
getJobTags(reg = tmp)

# Add more tags
addJobTags(findJobs(x &lt; 0, reg = tmp), "x.neg", reg = tmp)
addJobTags(findJobs(x &gt; 0, reg = tmp), "x.pos", reg = tmp)
getJobTags(reg = tmp)

# Submit first 5 jobs and remove tag if successful
ids = submitJobs(1:5, reg = tmp)
if (waitForJobs(reg = tmp))
  removeJobTags(ids, "needs.computation", reg = tmp)
getJobTags(reg = tmp)

# Grep for warning message and add a tag
addJobTags(grepLogs(pattern = "NaNs produced", reg = tmp), "div.zero", reg = tmp)
getJobTags(reg = tmp)

# All tags where tag x.neg is set:
ids = findTagged("x.neg", reg = tmp)
getUsedJobTags(ids, reg = tmp)
</code></pre>

<hr>
<h2 id='testJob'>Run Jobs Interactively</h2><span id='topic+testJob'></span>

<h3>Description</h3>

<p>Starts a single job on the local machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testJob(id, external = FALSE, reg = getDefaultRegistry())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testJob_+3A_id">id</code></td>
<td>
<p>[<code>integer(1)</code> or <code>data.table</code>]<br />
Single integer to specify the job or a <code>data.table</code> with column <code>job.id</code>
and exactly one row.</p>
</td></tr>
<tr><td><code id="testJob_+3A_external">external</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Run the job in an external R session? If <code>TRUE</code>, starts a fresh R
session on the local machine to execute the with <code><a href="#topic+execJob">execJob</a></code>.
You will not be able to use debug tools like <code><a href="base.html#topic+traceback">traceback</a></code>
or <code><a href="base.html#topic+browser">browser</a></code>.
</p>
<p>If <code>external</code> is set to <code>FALSE</code> (default) on the other hand,
<code>testJob</code> will execute the job in the current R session and the usual
debugging tools work. However, spotting missing variable declarations (as they
are possibly resolved in the global environment) is impossible.
Same holds for missing package dependency declarations.</p>
</td></tr>
<tr><td><code id="testJob_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the result of the job if successful.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+getErrorMessages">getErrorMessages</a>()</code>,
<code><a href="#topic+getStatus">getStatus</a>()</code>,
<code><a href="#topic+grepLogs">grepLogs</a>()</code>,
<code><a href="#topic+killJobs">killJobs</a>()</code>,
<code><a href="#topic+resetJobs">resetJobs</a>()</code>,
<code><a href="#topic+showLog">showLog</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp = makeRegistry(file.dir = NA, make.default = FALSE)
batchMap(function(x) if (x == 2) xxx else x, 1:2, reg = tmp)
testJob(1, reg = tmp)
## Not run: 
testJob(2, reg = tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='unwrap'>Unwrap Nested Data Frames</h2><span id='topic+unwrap'></span><span id='topic+flatten'></span>

<h3>Description</h3>

<p>Some functions (e.g., <code><a href="#topic+getJobPars">getJobPars</a></code>, <code><a href="#topic+getJobResources">getJobResources</a></code> or <code><a href="#topic+reduceResultsDataTable">reduceResultsDataTable</a></code>
return a <code>data.table</code> with columns of type <code>list</code>.
These columns can be unnested/unwrapped with this function.
The contents of these columns  will be transformed to a <code>data.table</code> and <code><a href="base.html#topic+cbind">cbind</a></code>-ed
to the input data.frame <code>x</code>, replacing the original nested column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(x, cols = NULL, sep = NULL)

flatten(x, cols = NULL, sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_x">x</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> | <code><a href="data.table.html#topic+data.table">data.table</a></code>]<br />
Data frame to flatten.</p>
</td></tr>
<tr><td><code id="unwrap_+3A_cols">cols</code></td>
<td>
<p>[<code>character</code>]<br />
Columns to consider for this operation. If set to <code>NULL</code> (default),
will operate on all columns of type &ldquo;list&rdquo;.</p>
</td></tr>
<tr><td><code id="unwrap_+3A_sep">sep</code></td>
<td>
<p>[<code>character(1)</code>]<br />
If <code>NULL</code> (default), the column names of the additional columns will re-use the names
of the nested <code>list</code>/<code>data.frame</code>.
This may lead to name clashes.
If you provide <code>sep</code>, the variable column name will be constructed as
&ldquo;[column name of x][sep][inner name]&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="data.table.html#topic+data.table">data.table</a></code>].
</p>


<h3>Note</h3>

<p>There is a name clash with function <code>flatten</code> in package <span class="pkg">purrr</span>.
The function <code>flatten</code> is discouraged to use for this reason in favor of <code>unwrap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = data.table::data.table(
  id = 1:3,
  values = list(list(a = 1, b = 3), list(a = 2, b = 2), list(a = 3))
)
unwrap(x)
unwrap(x, sep = ".")
</code></pre>

<hr>
<h2 id='waitForJobs'>Wait for Termination of Jobs</h2><span id='topic+waitForJobs'></span>

<h3>Description</h3>

<p>This function simply waits until all jobs are terminated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waitForJobs(
  ids = NULL,
  sleep = NULL,
  timeout = 604800,
  expire.after = NULL,
  stop.on.error = FALSE,
  stop.on.expire = FALSE,
  reg = getDefaultRegistry()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waitForJobs_+3A_ids">ids</code></td>
<td>
<p>[<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>integer</code>]<br />
A <code><a href="base.html#topic+data.frame">data.frame</a></code> (or <code><a href="data.table.html#topic+data.table">data.table</a></code>)
with a column named &ldquo;job.id&rdquo;.
Alternatively, you may also pass a vector of integerish job ids.
If not set, defaults to the return value of <code><a href="#topic+findSubmitted">findSubmitted</a></code>.
Invalid ids are ignored.</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_sleep">sleep</code></td>
<td>
<p>[<code>function(i)</code> | <code>numeric(1)</code>]<br />
Parameter to control the duration to sleep between queries.
You can pass an absolute numeric value in seconds or a <code>function(i)</code> which returns
the number of seconds to sleep in the <code>i</code>-th iteration.
If not provided (<code>NULL</code>), tries to read the value (number/function) from the configuration file
(stored in <code>reg$sleep</code>) or defaults to a function with exponential backoff between
5 and 120 seconds.</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_timeout">timeout</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
After waiting <code>timeout</code> seconds, show a message and return
<code>FALSE</code>. This argument may be required on some systems where, e.g.,
expired jobs or jobs on hold are problematic to detect. If you don't want
a timeout, set this to <code>Inf</code>. Default is <code>604800</code> (one week).</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_expire.after">expire.after</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Jobs count as &ldquo;expired&rdquo; if they are not found on the system but have not communicated back
their results (or error message). This frequently happens on managed system if the scheduler kills
a job because the job has hit the walltime or request more memory than reserved.
On the other hand, network file systems often require several seconds for new files to be found,
which can lead to false positives in the detection heuristic.
<code>waitForJobs</code> treats such jobs as expired after they have not been detected on the system
for <code>expire.after</code> iterations.
If not provided (<code>NULL</code>), tries to read the value from the configuration file (stored in <code>reg$expire.after</code>),
and finally defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Immediately cancel if a job terminates with an error? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_stop.on.expire">stop.on.expire</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Immediately cancel if jobs are detected to be expired? Default is <code>FALSE</code>.
Expired jobs will then be ignored for the remainder of <code>waitForJobs()</code>.</p>
</td></tr>
<tr><td><code id="waitForJobs_+3A_reg">reg</code></td>
<td>
<p>[<code><a href="#topic+Registry">Registry</a></code>]<br />
Registry. If not explicitly passed, uses the default registry (see <code><a href="#topic+setDefaultRegistry">setDefaultRegistry</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]. Returns <code>TRUE</code> if all jobs terminated
successfully and <code>FALSE</code> if either the timeout is reached or at least
one job terminated with an exception or expired.
</p>

<hr>
<h2 id='Worker'>Create a Linux-Worker</h2><span id='topic+Worker'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> to create local and remote linux workers.
</p>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object
</p>


<h3>Value</h3>

<p>[<code><a href="#topic+Worker">Worker</a></code>].
</p>


<h3>Fields</h3>


<dl>
<dt><code>nodename</code></dt><dd><p>Host name. Set via constructor.</p>
</dd>
<dt><code>ncpus</code></dt><dd><p>Number of CPUs. Set via constructor and defaults to a heuristic which tries to detect the number of CPUs of the machine.</p>
</dd>
<dt><code>max.load</code></dt><dd><p>Maximum load average (of the last 5 min). Set via constructor and defaults to the number of CPUs of the machine.</p>
</dd>
<dt><code>status</code></dt><dd><p>Status of the worker; one of &ldquo;unknown&rdquo;, &ldquo;available&rdquo;, &ldquo;max.cpus&rdquo; and &ldquo;max.load&rdquo;.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>new(nodename, ncpus, max.load)</code></dt><dd><p>Constructor.</p>
</dd>
<dt><code>update(reg)</code></dt><dd><p>Update the worker status.</p>
</dd>
<dt><code>list(reg)</code></dt><dd><p>List running jobs.</p>
</dd>
<dt><code>start(reg, fn, outfile)</code></dt><dd><p>Start job collection in file &ldquo;fn&rdquo; and output to &ldquo;outfile&rdquo;.</p>
</dd>
<dt><code>kill(reg, batch.id)</code></dt><dd><p>Kill job matching the &ldquo;batch.id&rdquo;.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create a worker for the local machine and use 4 CPUs.
Worker$new("localhost", ncpus = 4)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
