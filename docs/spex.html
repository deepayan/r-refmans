<!DOCTYPE html><html lang="en"><head><title>Help for package spex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spex-package'><p>spex</p></a></li>
<li><a href='#as_double'><p>Atomic vector extent</p></a></li>
<li><a href='#buffer_extent'><p>Whole grain buffers</p></a></li>
<li><a href='#extent'><p>Extent of simple features</p></a></li>
<li><a href='#ice'><p>A raster data set with southern ocean sea ice concentration</p></a></li>
<li><a href='#latitudecircle'><p>Latitude circle</p></a></li>
<li><a href='#latmask'><p>Latitude mask for polar raster</p></a></li>
<li><a href='#lux'><p>The 'lux' Spatial Polygons from the 'raster' package.</p></a></li>
<li><a href='#polygonize'><p>Create a polygon layer from a raster.</p></a></li>
<li><a href='#psf'><p>A polygon data set with <code>sf</code> class.</p></a></li>
<li><a href='#spex'><p>Polygon extent</p></a></li>
<li><a href='#xlim'><p>Axis ranges from extent</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Extent Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to produce a fully fledged 'geo-spatial' object extent as a
    'SpatialPolygonsDataFrame'. Also included are functions to generate polygons
    from raster data using 'quadmesh' techniques, a round number buffered extent, and
    general spatial-extent and 'raster-like' extent helpers missing from the originating
    packages. Some latitude-based tools for polar maps are included. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, quadmesh, raster, reproj, sp, stats, crsmeta</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0.9000</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mdsumner.github.io/spex/">https://mdsumner.github.io/spex/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mdsumner/spex/issues">https://github.com/mdsumner/spex/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-20 09:18:16 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-20 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spex-package'>spex</h2><span id='topic+spex-package'></span>

<h3>Description</h3>

<p>Tools for spatial extents that are agnostic regarding format (i.e. <code>sp</code>,
<code>sf</code>, or <code>raster</code>). These functions fill some of the gaps within and between
these packages for dealing with object extents in flexible ways. Generally,
spex considers extents of raster cells, and extents of objects as first-class
objects (with projection metadata). and provides helpers for  latitudinal
boundaries within projected data.
</p>


<h3>Spatial Extent</h3>


<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+buffer_extent">buffer_extent</a></code> </td><td style="text-align: left;"> Buffer an extent to a given whole number. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+latitudecircle">latitudecircle</a></code> </td><td style="text-align: left;"> Create a latitude circle in a chosen projection. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+latmask">latmask</a></code> </td><td style="text-align: left;"> Mask a raster based on a minimum (or maximum) latitude. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+polygonize">polygonize</a></code> </td><td style="text-align: left;"> Convert raster cells to polygons. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+qm_rasterToPolygons">qm_rasterToPolygons</a></code> </td><td style="text-align: left;"> The <code>sf</code> version of <code>polygonize</code>.  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+qm_rasterToPolygons_sp">qm_rasterToPolygons_sp</a></code> </td><td style="text-align: left;"> The <code>sp</code> version of <code>polygonize</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+spex">spex</a></code> </td><td style="text-align: left;"> A function to produce a fully fledged Spatial object extent. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+xlim">xlim</a>, <a href="#topic+ylim">ylim</a></code> </td><td style="text-align: left;"> Helper functions for extents. </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>


<hr>
<h2 id='as_double'>Atomic vector extent</h2><span id='topic+as_double'></span><span id='topic+as_double.Extent'></span><span id='topic+as_integer'></span><span id='topic+as_integer.Extent'></span>

<h3>Description</h3>

<p>Coerce a <code><a href="raster.html#topic+extent">extent</a></code> to an atomic vector of <code>c(xmin(x), xmax(x), ymin(x), ymax(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_double(x, ...)

## S3 method for class 'Extent'
as_double(x, ...)

as_integer(x, ...)

## S3 method for class 'Extent'
as_integer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_double_+3A_x">x</code></td>
<td>
<p>a <code><a href="raster.html#topic+extent">extent</a></code></p>
</td></tr>
<tr><td><code id="as_double_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>as_integer</code> results in truncation, see rasterOps for positive buffering.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>base::as.double
</p>

<hr>
<h2 id='buffer_extent'>Whole grain buffers</h2><span id='topic+buffer_extent'></span>

<h3>Description</h3>

<p>Ensure a raster extent aligns to a clean divisor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer_extent(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buffer_extent_+3A_e1">e1</code></td>
<td>
<p>input <code><a href="raster.html#topic+extent">extent</a></code></p>
</td></tr>
<tr><td><code id="buffer_extent_+3A_e2">e2</code></td>
<td>
<p>grain size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to generate extents that have tidy boundaries,
i.e. extents that align to a clean whole number like &quot;10000&quot;.
</p>
<p>(We can't use the S4 group generic because raster has set that specifically for use with '+' and '-'.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
buffer_extent(extent(0.1, 2.2, 0, 3), 2)

p &lt;- par(xpd = NA) 
plot(lux)
plot(extent(lux), lty = 2, add = TRUE, col = "grey")
plot(buffer_extent(lux, 0.1), add = TRUE)
abline(v = c(5.7, 6.6), h = c(49.4, 50.2))
title("boundaries on clean alignment to 0.1")
par(p)
</code></pre>

<hr>
<h2 id='extent'>Extent of simple features</h2><span id='topic+extent'></span><span id='topic+extent_sf'></span><span id='topic+Extent'></span>

<h3>Description</h3>

<p>This is the simplest of the missing &quot;raster support&quot; for the sf package,
here using the xmin, xmax, ymin, ymax convention used by raster rather than
the transpose version favoured in sp and sf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent_sf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p>object with an extent</p>
</td></tr>
<tr><td><code id="extent_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='ice'>A raster data set with southern ocean sea ice concentration</h2><span id='topic+ice'></span>

<h3>Description</h3>

<p>When first created this data set was from 2018-04-28.
</p>

<hr>
<h2 id='latitudecircle'>Latitude circle</h2><span id='topic+latitudecircle'></span>

<h3>Description</h3>

<p>Create a circular polygon using a latitude value in a map projection. The
longitude range can be modified from global to give a portion of a circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latitudecircle(
  latitude = 0,
  crs = "+proj=stere +lon_0=0 +lat_0=-90 +lat_ts=-71 +ellps=WGS84",
  lonlim = c(-180, 180),
  nverts = 1800
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latitudecircle_+3A_latitude">latitude</code></td>
<td>
<p>latitude value for the boundary, defaults to 0</p>
</td></tr>
<tr><td><code id="latitudecircle_+3A_crs">crs</code></td>
<td>
<p>map projection to use, defaults to southern Polar Stereographic true scale at -71S</p>
</td></tr>
<tr><td><code id="latitudecircle_+3A_lonlim">lonlim</code></td>
<td>
<p>the range of longitude to use, defaults to entire globe</p>
</td></tr>
<tr><td><code id="latitudecircle_+3A_nverts">nverts</code></td>
<td>
<p>total number of vertices to use, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>nverts</code> controls the total number of vertices of the circle
within a linearly within the <code>lonlim</code> range of longitudes at <code>latitude</code>
</p>
<p>This is for use on classic polar projections centred on the north or the
south pole, particularly Polar Stereographic and Lambert Azimuthal Equal Area
but will also work with some caveats on other families and situations. We
have not explored this more general use. Feel free to contact the maintainer
if you have interest in less typical usage or find problems.
</p>


<h3>Value</h3>

<p>SpatialPolygonsDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>latitudecircle(seq(0, -65, by = -5))
library(raster)
plot(ice)
circ &lt;- latitudecircle(-71, crs = projection(ice))
plot(circ, add = TRUE)
</code></pre>

<hr>
<h2 id='latmask'>Latitude mask for polar raster</h2><span id='topic+latmask'></span>

<h3>Description</h3>

<p>Mask out values based on latitude for a raster. This works by finding all cells at
latitudes less than <code>latitude</code> and setting them to missing. If <code>southern = FALSE</code>
the inequality is reversed, and all cells at latitudes greater than <code>latitude</code> are
masked out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latmask(x, latitude = 0, southern = TRUE, trim = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latmask_+3A_x">x</code></td>
<td>
<p>a raster layer</p>
</td></tr>
<tr><td><code id="latmask_+3A_latitude">latitude</code></td>
<td>
<p>maximum latitude  (effectively a minimum latitude if <code>southern = FALSe</code>)</p>
</td></tr>
<tr><td><code id="latmask_+3A_southern">southern</code></td>
<td>
<p>flag for whether south-polar context is used, default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="latmask_+3A_trim">trim</code></td>
<td>
<p>if <code>TRUE</code> runs <code>raster::trim</code> on the result, to remove <code>NA</code> margin</p>
</td></tr>
<tr><td><code id="latmask_+3A_...">...</code></td>
<td>
<p>ignored currently</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>trim</code> option allows for the result to be reduced to the common bounding box
within which any row or column has a non-missing value.
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>See Also</h3>

<p><a href="raster.html#topic+trim">raster::trim</a>, <a href="#topic+latitudecircle">latitudecircle</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(raster)
plot(latmask(ice, -60))
plot(latmask(ice, -60, trim = TRUE))
ice[!ice &gt; 0] &lt;- NA
plot(ice)
plot(latmask(ice, -55, trim = TRUE))
</code></pre>

<hr>
<h2 id='lux'>The 'lux' Spatial Polygons from the 'raster' package.</h2><span id='topic+lux'></span>

<h3>Description</h3>

<p>The 'lux' Spatial Polygons from the 'raster' package.
</p>


<h3>Format</h3>

<p><code><a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a></code> with columns:
</p>

<ul>
<li><p> ID_1
</p>
</li>
<li><p> NAME_1
</p>
</li>
<li><p> ID_2
</p>
</li>
<li><p> NAME_2
</p>
</li>
<li><p> AREA
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
plot(lux)
</code></pre>

<hr>
<h2 id='polygonize'>Create a polygon layer from a raster.</h2><span id='topic+polygonize'></span><span id='topic+polygonize.RasterLayer'></span><span id='topic+qm_rasterToPolygons'></span><span id='topic+qm_rasterToPolygons_sp'></span><span id='topic+polygonize.RasterStack'></span><span id='topic+polygonize.RasterBrick'></span>

<h3>Description</h3>

<p>This method uses the quadmesh to generate the coordinates, and creates a simple features layer.
It's faster by turning off the checking done in the simple features package, but it's also faster
than raster because it uses a dense mesh to generate the coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RasterLayer'
polygonize(x, na.rm = TRUE, ...)

polygonize(x, ...)

qm_rasterToPolygons(x, na.rm = TRUE, ...)

## S3 method for class 'RasterStack'
polygonize(x, na.rm = TRUE, ...)

## S3 method for class 'RasterBrick'
polygonize(x, na.rm = TRUE, ...)

qm_rasterToPolygons_sp(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygonize_+3A_x">x</code></td>
<td>
<p>raster, brick or stack</p>
</td></tr>
<tr><td><code id="polygonize_+3A_na.rm">na.rm</code></td>
<td>
<p>defaults to <code>TRUE</code> and will polygonize all the cells that are non-NA in any layer,
set to <code>FALSE</code> to not remove any cells</p>
</td></tr>
<tr><td><code id="polygonize_+3A_...">...</code></td>
<td>
<p>arguments passed to methods, currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>na.rm</code> is <code>TRUE</code> (the default) only cells that are not-NA across all
layers are created. An exception to this is the empty raster <code>raster::hasValues(x)</code> is <code>FALSE</code>
and all the cells will be turned into polygons - since this is what the whole
scene is really for, easily creating polygons from a grid.
</p>


<h3>Value</h3>

<p>simple features POLYGON layer, or SpatialPolygonsDataFrame
</p>


<h3>Warning</h3>

<p>Please don't try this on large rasters (&gt; ~1e5 cells), use quadmesh itself for efficient vector based use of a raster's
coordinates. It will work reasonably on largish grids, but you won't want to try plotting them or perform
operations on them, simple features is incredibly wasteful for objects like this.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(raadtools)
library(raster)
r &lt;- raster(volcano)
r[sample(ncell(r), 3000)] &lt;- NA
b &lt;- brick(r, r*1.5)
psf &lt;- qm_rasterToPolygons(r, na.rm = TRUE)
#psp &lt;- qm_rasterToPolygons_sp(r)
#pspr &lt;- rasterToPolygons(r)
#library(rbenchmark)
#benchmark(qm_rasterToPolygons(r), qm_rasterToPolygons_sp(r), rasterToPolygons(r), replications = 2)
#                        test replications elapsed relative user.self sys.self user.child sys.child
# 1    qm_rasterToPolygons(r)            2   0.476    1.000     0.476    0.000          0         0
# 2 qm_rasterToPolygons_sp(r)            2   4.012    8.429     3.964    0.048          0         0
# 3       rasterToPolygons(r)            2   2.274    4.777     2.268    0.008          0         0
</code></pre>

<hr>
<h2 id='psf'>A polygon data set with <code>sf</code> class.</h2><span id='topic+psf'></span>

<h3>Description</h3>

<p>A polygon data set with <code>sf</code> class.
</p>

<hr>
<h2 id='spex'>Polygon extent</h2><span id='topic+spex'></span><span id='topic+spex.default'></span><span id='topic+spex.sf'></span><span id='topic+spex.sfc'></span>

<h3>Description</h3>

<p>Create Spatial Polygons with projection metadata from a 'Spatial Extent'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spex(x, crs, byid = FALSE, .id, ..., clipboard = FALSE)

## Default S3 method:
spex(x, crs = NULL, byid = FALSE, .id, ..., clipboard = FALSE)

## S3 method for class 'sf'
spex(x, crs, byid = FALSE, .id, ..., clipboard = FALSE)

## S3 method for class 'sfc'
spex(x, crs, byid = FALSE, .id, ..., clipboard = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spex_+3A_x">x</code></td>
<td>
<p>any object with a <code><a href="raster.html#topic+Extent-class">Extent-class</a></code></p>
</td></tr>
<tr><td><code id="spex_+3A_crs">crs</code></td>
<td>
<p>a projection string</p>
</td></tr>
<tr><td><code id="spex_+3A_byid">byid</code></td>
<td>
<p>return a separate object for every input sub-object (not yet implemented)</p>
</td></tr>
<tr><td><code id="spex_+3A_.id">.id</code></td>
<td>
<p>optional name for output attribute name</p>
</td></tr>
<tr><td><code id="spex_+3A_...">...</code></td>
<td>
<p>arguments for methods</p>
</td></tr>
<tr><td><code id="spex_+3A_clipboard">clipboard</code></td>
<td>
<p>WIP this special-case allows x to be the result of the leafem clipboard copy process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called with no arguments will return the extent of the current 'par(&quot;usr&quot;)' setting.
</p>
<p>Called with a matrix, list, or data frame it will create an extent from a two columned thing.
</p>
<p>Called with <code>clipboard = TRUE</code> and <code>x</code> will be treated as the JSON-ic output of the clipboard copy from
leafem (WIP). If x is missing, it will be attempted to be read from the clipboard. Clipboard read cannot
work on RStudio Server, so we allow the text value to be passed in.
I.e. <code>spex(clipboard = TRUE)</code> will
read from the clipboard, <code>spex(tx, clipboard = TRUE)</code> will read from tx with value like
<code>'{"_southWest":{"lat":-1.307259612275665,"lng":23.411865234375},"_north...}"'</code>.
</p>
<p>This function is to replace a common pattern in spatial packages which is
</p>

<ul>
<li><p> create an <code><a href="raster.html#topic+Extent-class">Extent-class</a></code>, a bounding box in xmin,xmax,ymin,ymax but without projection metadata
</p>
</li>
<li><p> coerce the Extent to <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>
</p>
</li>
<li><p> restore the 'CRS', the &quot;coordinate reference system&quot;, i.e. projection metadata
</p>
</li>
<li><p> elevate the object to be a <code><a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame-class</a></code>.
</p>
</li></ul>

<p>In short, this pattern exists because there is no projection metadata stored
with either sp's <code><a href="sp.html#topic+bbox">bbox</a></code> or raster's <code><a href="raster.html#topic+Extent-class">Extent-class</a></code>.
</p>


<h3>Value</h3>

<p>'SpatialPolygonsDataFrame'
</p>


<h3>Warning</h3>

<p>Please note that an extent converted to polygons consists
of only four unique coordinates, and so this is not necessarily suited for
projection transformations.
</p>


<h3>See Also</h3>

<p>This pattern is displayed in the example code for <code><a href="raster.html#topic+cover">cover</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
data(lux)
exlux &lt;- spex(lux)

plot(lux)
plot(exlux, add = TRUE)

## put an extent and a CRS together
spex(extent(0, 1, 0, 1), crs = "+proj=laea +ellps=WGS84")
</code></pre>

<hr>
<h2 id='xlim'>Axis ranges from extent</h2><span id='topic+xlim'></span><span id='topic+xlim.default'></span><span id='topic+ylim'></span><span id='topic+ylim.default'></span>

<h3>Description</h3>

<p>Functions <code>xlim</code> and <code>ylim</code> return the two-value counterparts of an extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlim(x, ...)

## Default S3 method:
xlim(x, ...)

ylim(x, ...)

## Default S3 method:
ylim(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xlim_+3A_x">x</code></td>
<td>
<p>any object with an extent understood by <code>spex</code></p>
</td></tr>
<tr><td><code id="xlim_+3A_...">...</code></td>
<td>
<p>reserved for future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any projection metadata is dropped since this is a one-dimensional entity.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
