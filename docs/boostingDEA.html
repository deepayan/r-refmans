<!DOCTYPE html><html><head><title>Help for package boostingDEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {boostingDEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddBF'><p>Add a new pair of Basis Functions</p></a></li>
<li><a href='#banks'><p>Taiwanese banks (in 2010)</p></a></li>
<li><a href='#BBC_in'><p>Linear programming model for radial input measure</p></a></li>
<li><a href='#BBC_out'><p>Linear programming model for radial output measure</p></a></li>
<li><a href='#bestEATBoost'><p>Tuning an EATBoost model</p></a></li>
<li><a href='#bestMARSBoost'><p>Tuning an MARSBoost model</p></a></li>
<li><a href='#CobbDouglas'><p>Single Output Data Generation</p></a></li>
<li><a href='#comparePareto'><p>Pareto-dominance relationships</p></a></li>
<li><a href='#CreateBF'><p>Generate a new pair of Basis Functions</p></a></li>
<li><a href='#CreateCubicBF'><p>Generate a new pair of Cubic Basis Functions</p></a></li>
<li><a href='#DDF'><p>Linear programming model for Directional Distance Function measure</p></a></li>
<li><a href='#DEA'><p>Data Envelope Analysis model</p></a></li>
<li><a href='#deepEAT'><p>Deep Efficiency Analysis Trees</p></a></li>
<li><a href='#EAT'><p>Efficiency Analysis Trees</p></a></li>
<li><a href='#EAT_object'><p>Create a EAT object</p></a></li>
<li><a href='#EATBoost'><p>Gradient Tree Boosting</p></a></li>
<li><a href='#efficiency'><p>Calculate efficiency scores</p></a></li>
<li><a href='#ERG'><p>Enhanced Russell Graph measure</p></a></li>
<li><a href='#EstimCoeffsForward'><p>Estimate Coefficients in Multivariate Adaptive Frontier Splines during</p>
Forward Procedure.</a></li>
<li><a href='#estimEAT'><p>Estimation of child nodes</p></a></li>
<li><a href='#FDH'><p>Free Disposal Hull model</p></a></li>
<li><a href='#get.a.EATBoost'><p>Get <code>EATBoost</code> leaves supports</p></a></li>
<li><a href='#get.a.trees'><p>Get the inferior corner of the leave support from all trees</p>
of <code>EATBoost</code></a></li>
<li><a href='#get.b.trees'><p>Get the superior corner of the leave support from all trees</p>
of <code>EATBoost</code></a></li>
<li><a href='#get.intersection.a'><p>Get intersection between two leaves supports</p></a></li>
<li><a href='#isFinalNode'><p>Is Final Node</p></a></li>
<li><a href='#MARSAdapted'><p>Adapted Multivariate Adaptive Frontier Splines</p></a></li>
<li><a href='#MARSAdapted_object'><p>Create an MARSAdapted object</p></a></li>
<li><a href='#MARSAdaptedSmooth'><p>Smoothing (Forward) Multivariate Adaptive Frontier Splines</p></a></li>
<li><a href='#MARSBoost'><p>LS-Boosting with adapted Multivariate Adaptive Frontier Splines (MARS)</p></a></li>
<li><a href='#mse'><p>Mean Squared Error</p></a></li>
<li><a href='#mse_tree'><p>Mean Squared Error</p></a></li>
<li><a href='#posIdNode'><p>Position of the node</p></a></li>
<li><a href='#predict.DEA'><p>Model Prediction for DEA</p></a></li>
<li><a href='#predict.EAT'><p>Model Prediction for Efficiency Analysis Trees.</p></a></li>
<li><a href='#predict.EATBoost'><p>Model prediction for EATBoost algorithm</p></a></li>
<li><a href='#predict.FDH'><p>Model Prediction for FDH</p></a></li>
<li><a href='#predict.MARSAdapted'><p>Model Prediction for Adapted Multivariate Adaptive Frontier Splines.</p></a></li>
<li><a href='#predict.MARSBoost'><p>Model Prediction for Boosted Multivariate Adaptive Frontier Splines</p></a></li>
<li><a href='#predictor'><p>Efficiency Analysis Trees Predictor</p></a></li>
<li><a href='#preProcess'><p>Data Pre-processing for Multivariate Adaptive Frontier Splines.</p></a></li>
<li><a href='#Russell_in'><p>Linear programming model for Russell input measure</p></a></li>
<li><a href='#Russell_out'><p>Linear programming model for Russell output measure</p></a></li>
<li><a href='#split'><p>Split node</p></a></li>
<li><a href='#WAM'><p>Linear programming model for Weighted Additive Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Boosting Approach to Data Envelopment Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maria D. Guillen &lt;maria.guilleng@umh.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes functions to estimate production frontiers 
    and make ideal output predictions in the Data Envelopment Analysis (DEA) 
    context using both standard models from DEA and Free Disposal Hull (FDH)
    and boosting techniques. In particular, EATBoosting (Guillen et al., 2023 
    &lt;<a href="https://doi.org/10.1016%2Fj.eswa.2022.119134">doi:10.1016/j.eswa.2022.119134</a>&gt;) and MARSBoosting. Moreover, the package 
    includes code for estimating several technical efficiency measures using 
    different models such as the input and output-oriented radial measures, the
    input and output-oriented Russell measures, the Directional Distance 
    Function (DDF), the Weighted Additive Measure (WAM) and the Slacks-Based 
    Measure (SBM).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rglpk, dplyr, lpSolveAPI, stats, MLmetrics, methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/itsmeryguillen/boostingDEA">https://github.com/itsmeryguillen/boostingDEA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/itsmeryguillen/boostingDEA/issues">https://github.com/itsmeryguillen/boostingDEA/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-15 07:58:20 UTC; Master</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria D. Guillen <a href="https://orcid.org/0000-0002-2445-5654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Juan Aparicio <a href="https://orcid.org/0000-0002-0867-0004"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Víctor España <a href="https://orcid.org/0000-0002-1807-6180"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-15 09:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddBF'>Add a new pair of Basis Functions</h2><span id='topic+AddBF'></span>

<h3>Description</h3>

<p>This function adds the best pair of basis functions to the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddBF(data, x, y, ForwardModel, knots_list, Kp, minspan, Le, linpreds, err_min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddBF_+3A_data">data</code></td>
<td>
<p>data <code>data.frame</code> or <code>matrix</code> containing the variables
in the model.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_forwardmodel">ForwardModel</code></td>
<td>
<p><code>list</code> containing the set of basis functions and the
B matrix.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_knots_list">knots_list</code></td>
<td>
<p><code>list</code> containing the set of selected knots.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_kp">Kp</code></td>
<td>
<p>Maximum degree of interaction allowed.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_minspan">minspan</code></td>
<td>
<p><code>integer</code>. Minimum number of observations between knots.
When <code>minspan = 0</code>, it is calculated as in Friedman's MARS paper section
3.8 with alpha = 0.05.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_le">Le</code></td>
<td>
<p><code>integer</code> Minimum number of observations before the first and
after the final knot.</p>
</td></tr>
<tr><td><code id="AddBF_+3A_linpreds">linpreds</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, predictors can enter linearly</p>
</td></tr>
<tr><td><code id="AddBF_+3A_err_min">err_min</code></td>
<td>
<p>Minimum error in the split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the matrix of basis functions (<code>B</code>), a
<code>list</code> of basis functions (<code>BF</code>), a <code>list</code> of selected knots
(<code>knots_list</code>) and the minimum error (<code>err_min</code>).
</p>

<hr>
<h2 id='banks'>Taiwanese banks (in 2010)</h2><span id='topic+banks'></span>

<h3>Description</h3>

<p>The dataset consists of 31 banks operating in Taiwan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(banks)
</code></pre>


<h3>Format</h3>

<p><code>banks</code> is a dataframe with 31 banks (rows) and 6 variables
(outputs) named <code>Financial.funds</code> (deposits and borrowed funds in
millions of TWD), <code>Labor</code> (number of employees),
<code>Physical.capital</code> (net amount of fixed assets in millions of TWD),
<code>Finalcial.investments</code> (financial assets, securities, and equity
investments in millions of TWD), <code>Loans</code> (loans and discounts in millions
of TWD) and <code>Revenue</code> (interests from financial investments and loans).
</p>


<h3>Source</h3>

<p>The dataset has been extracted from the “Condition and
Performance of Domestic Banks” published by the Central Bank of China
(Taiwan) and the Taiwan Economic Journal (TEJ) for the year 2010.
The “Condition and Performance of Domestic Banks” was downloaded from
http://www.cbc.gov.tw/ct.asp?xItem=1062&amp;ctNode=535&amp;mp=2
</p>


<h3>References</h3>

<p>Juo, J. C., Fu, T. T., Yu, M. M., &amp; Lin, Y. H. (2015).
Profit-oriented productivity change. Omega, 57, 176-187.
</p>

<hr>
<h2 id='BBC_in'>Linear programming model for radial input measure</h2><span id='topic+BBC_in'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBC_in(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BBC_in_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="BBC_in_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='BBC_out'>Linear programming model for radial output measure</h2><span id='topic+BBC_out'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBC_out(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BBC_out_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="BBC_out_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='bestEATBoost'>Tuning an EATBoost model</h2><span id='topic+bestEATBoost'></span>

<h3>Description</h3>

<p>This function computes the root mean squared error (RMSE) for a
set of EATBoost models built with a grid of given hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestEATBoost(
  training,
  test,
  x,
  y,
  num.iterations,
  learning.rate,
  num.leaves,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestEATBoost_+3A_training">training</code></td>
<td>
<p>Training <code>data.frame</code> or <code>matrix</code> containing the
variables for model construction.</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_test">test</code></td>
<td>
<p>Test <code>data.frame</code> or <code>matrix</code> containing the variables
for model assessment.</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_num.iterations">num.iterations</code></td>
<td>
<p>Maximum number of iterations the algorithm will perform</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_learning.rate">learning.rate</code></td>
<td>
<p>Learning rate that control overfitting of the algorithm.
Value must be in (0,1]</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_num.leaves">num.leaves</code></td>
<td>
<p>Maximum number of terminal leaves in each tree at each
iteration</p>
</td></tr>
<tr><td><code id="bestEATBoost_+3A_verbose">verbose</code></td>
<td>
<p>Controls the verbosity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sets of hyperparameters and the root
mean squared error (RMSE) and mean square error (MSE) associated for each
model.
</p>

<hr>
<h2 id='bestMARSBoost'>Tuning an MARSBoost model</h2><span id='topic+bestMARSBoost'></span>

<h3>Description</h3>

<p>This funcion computes the root mean squared error (RMSE) for a
set of MARSBoost models built with a grid of given hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestMARSBoost(
  training,
  test,
  x,
  y,
  num.iterations,
  learning.rate,
  num.terms,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestMARSBoost_+3A_training">training</code></td>
<td>
<p>Training <code>data.frame</code> or <code>matrix</code> containing the
variables for model construction.</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_test">test</code></td>
<td>
<p>Test <code>data.frame</code> or <code>matrix</code> containing the variables
for model assessment.</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>training</code>.</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_num.iterations">num.iterations</code></td>
<td>
<p>Maximum number of iterations the algorithm will perform</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_learning.rate">learning.rate</code></td>
<td>
<p>Learning rate that control overfitting of the algorithm.
Value must be in (0,1]</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_num.terms">num.terms</code></td>
<td>
<p>Maximum number of reflected pairs created by the forward
algorithm of MARS.</p>
</td></tr>
<tr><td><code id="bestMARSBoost_+3A_verbose">verbose</code></td>
<td>
<p>Controls the verbosity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the sets of hyperparameters and the root
mean squared error (RMSE) associated for each model.
</p>

<hr>
<h2 id='CobbDouglas'>Single Output Data Generation</h2><span id='topic+CobbDouglas'></span>

<h3>Description</h3>

<p>This function is used to simulate the data in a single output
scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CobbDouglas(N, nX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CobbDouglas_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="CobbDouglas_+3A_nx">nX</code></td>
<td>
<p>Number of inputs. Possible values: <code>1</code>, <code>2</code>, <code>3</code>,
<code>4</code>, <code>5</code>,<code>6</code>, <code>9</code>, <code>12</code> and <code>15</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the simulated data.
</p>

<hr>
<h2 id='comparePareto'>Pareto-dominance relationships</h2><span id='topic+comparePareto'></span>

<h3>Description</h3>

<p>This function denotes if a node dominates another one or if there is no Pareto-dominance relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePareto(t1, t2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePareto_+3A_t1">t1</code></td>
<td>
<p>A first node.</p>
</td></tr>
<tr><td><code id="comparePareto_+3A_t2">t2</code></td>
<td>
<p>A second node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-1 if t1 dominates t2, 1 if t2 dominates t1 and 0 if there are no Pareto-dominance relationships.
</p>

<hr>
<h2 id='CreateBF'>Generate a new pair of Basis Functions</h2><span id='topic+CreateBF'></span>

<h3>Description</h3>

<p>This function generates two new basis functions from a variable
and a knot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateBF(data, xi, knt, B, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateBF_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_xi">xi</code></td>
<td>
<p><code>integer</code>. Variable index of the new basis function(s).</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_knt">knt</code></td>
<td>
<p>Knot for creating the new basis function(s).</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_b">B</code></td>
<td>
<p><code>matrix</code> of basis functions on which the new pair of functions
is added.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_p">p</code></td>
<td>
<p><code>integer</code>. Parent basis function index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of basis function (<code>B</code>) updated with the new basis
functions.
</p>

<hr>
<h2 id='CreateCubicBF'>Generate a new pair of Cubic Basis Functions</h2><span id='topic+CreateCubicBF'></span>

<h3>Description</h3>

<p>This function generates two new cubic basis functions from a
variable and a knot previously created during MARS algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateCubicBF(data, xi, knt, B, side)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateCubicBF_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="CreateCubicBF_+3A_xi">xi</code></td>
<td>
<p>Variable index of the new basis function(s).</p>
</td></tr>
<tr><td><code id="CreateCubicBF_+3A_knt">knt</code></td>
<td>
<p>Knots for creating the new basis function(s).</p>
</td></tr>
<tr><td><code id="CreateCubicBF_+3A_b">B</code></td>
<td>
<p>Matrix of basis functions.</p>
</td></tr>
<tr><td><code id="CreateCubicBF_+3A_side">side</code></td>
<td>
<p>Side of the basis function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of basis functions updated with the new basis functions.
</p>

<hr>
<h2 id='DDF'>Linear programming model for Directional Distance Function measure</h2><span id='topic+DDF'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DDF(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE,
  direction.vector
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DDF_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="DDF_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="DDF_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="DDF_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="DDF_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="DDF_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="DDF_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
<tr><td><code id="DDF_+3A_direction.vector">direction.vector</code></td>
<td>
<p>Direction vector. Valid values are: <code>dmu</code> (x_0, y_0),
<code>unit</code> (unit vector), <code>mean</code> (mean values of each variable) and
a user specific vector of the same length as the number of input and output
variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='DEA'>Data Envelope Analysis model</h2><span id='topic+DEA'></span><span id='topic+DEA_object'></span>

<h3>Description</h3>

<p>This function estimates a production frontier satisfying Data
Envelope Analysis axioms using the radial output measure.
</p>
<p>This function saves information about the DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEA(data, x, y)

DEA_object(data, x, y, pred, score)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEA_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="DEA_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="DEA_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="DEA_+3A_pred">pred</code></td>
<td>
<p>Output predictions using the BBC radial output measure</p>
</td></tr>
<tr><td><code id="DEA_+3A_score">score</code></td>
<td>
<p>Efficiency score using the BBC radial output measure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DEA</code> object.
</p>
<p>A <code>DEA</code> object.
</p>

<hr>
<h2 id='deepEAT'>Deep Efficiency Analysis Trees</h2><span id='topic+deepEAT'></span>

<h3>Description</h3>

<p>This function creates a deep Efficiency Analysis Tree and a set of possible prunings by the weakest-link pruning procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepEAT(data, x, y, numStop = 5, max.leaves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepEAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="deepEAT_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing each possible pruning for the deep tree and its associated alpha value.
</p>

<hr>
<h2 id='EAT'>Efficiency Analysis Trees</h2><span id='topic+EAT'></span>

<h3>Description</h3>

<p>This function estimates a stepped production frontier through regression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT(data, x, y, numStop = 5, max.leaves, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="EAT_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="EAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="EAT_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="EAT_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Maximum number of leaf nodes.</p>
</td></tr>
<tr><td><code id="EAT_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EAT function generates a regression tree model based on CART under a new approach that guarantees obtaining a stepped production frontier that fulfills the property of free disposability. This frontier shares the aforementioned aspects with the FDH frontier but enhances some of its disadvantages such as the overfitting problem or the underestimation of technical inefficiency.
</p>


<h3>Value</h3>

<p>An <code>EAT</code> object containing:
</p>

<ul>
<li><p><code>data</code> </p>

<ul>
<li><p><code>df</code>: data frame containing the variables in the model.
</p>
</li>
<li><p><code>x</code>: input indexes in data.
</p>
</li>
<li><p><code>y</code>: output indexes in data.
</p>
</li>
<li><p><code>input_names</code>: input variable names.
</p>
</li>
<li><p><code>output_names</code>: output variable names.
</p>
</li>
<li><p><code>row_names</code>: rownames in data.</p>
</li></ul>


</li>
<li><p><code>control</code> </p>

<ul>
<li><p><code>fold</code>: fold hyperparameter value.
</p>
</li>
<li><p><code>numStop</code>: numStop hyperparameter value.
</p>
</li>
<li><p><code>max.leaves</code>: max.leaves hyperparameter value.
</p>
</li>
<li><p><code>max.depth</code>: max.depth hyperparameter value.
</p>
</li>
<li><p><code>na.rm</code>: na.rm hyperparameter value.</p>
</li></ul>


</li>
<li><p><code>tree</code>: list structure containing the EAT nodes.
</p>
</li>
<li><p><code>nodes_df</code>: data frame containing the following information for each node. </p>

<ul>
<li><p><code>id</code>: node index.
</p>
</li>
<li><p><code>SL</code>: left child node index.
</p>
</li>
<li><p><code>N</code>: number of observations at the node.
</p>
</li>
<li><p><code>Proportion</code>: proportion of observations at the node.
</p>
</li>
<li><p>the output predictions.
</p>
</li>
<li><p><code>R</code>: the error at the node.
</p>
</li>
<li><p><code>index</code>: observation indexes at the node.</p>
</li></ul>


</li>
<li><p><code>model</code> </p>

<ul>
<li><p><code>nodes</code>: total number of nodes at the tree.
</p>
</li>
<li><p><code>leaf_nodes</code>: number of leaf nodes at the tree.
</p>
</li>
<li><p><code>a</code>: lower bound of the nodes.
</p>
</li>
<li><p><code>y</code>: output predictions.</p>
</li></ul>


</li></ul>


<hr>
<h2 id='EAT_object'>Create a EAT object</h2><span id='topic+EAT_object'></span>

<h3>Description</h3>

<p>This function saves information about the Efficiency Analysis Trees model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EAT_object(data, x, y, rownames, numStop, max.leaves, na.rm, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EAT_object_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in the model.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_rownames">rownames</code></td>
<td>
<p><code>string</code>. Data rownames.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node for a split to be attempted.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_max.leaves">max.leaves</code></td>
<td>
<p>Depth of the tree.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted. If <code>FALSE</code>, an error occurs in case of <code>NA</code> rows.</p>
</td></tr>
<tr><td><code id="EAT_object_+3A_tree">tree</code></td>
<td>
<p><code>list</code> containing the nodes of the Efficiency Analysis Trees pruned model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>EAT</code> object.
</p>

<hr>
<h2 id='EATBoost'>Gradient Tree Boosting</h2><span id='topic+EATBoost'></span><span id='topic+EATBoost_object'></span>

<h3>Description</h3>

<p>This function estimates a production frontier satisfying some
classical production theory axioms, such as monotonicity and
determinictiness, which is based upon the adaptation of the machine learning
technique known as Gradient Tree Boosting
</p>
<p>This function saves information about the EATBoost model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EATBoost(data, x, y, num.iterations, num.leaves, learning.rate)

EATBoost_object(
  data,
  x,
  y,
  num.iterations,
  num.leaves,
  learning.rate,
  EAT.models,
  f0,
  prediction
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EATBoost_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables
in the model.</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_num.iterations">num.iterations</code></td>
<td>
<p>Maximum number of iterations the algorithm will perform</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_num.leaves">num.leaves</code></td>
<td>
<p>Maximum number of terminal leaves in each tree at each
iteration.</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_learning.rate">learning.rate</code></td>
<td>
<p>Learning rate that control overfitting of the algorithm.
Value must be in (0,1]</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_eat.models">EAT.models</code></td>
<td>
<p>List of the EAT models created in each iterations</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_f0">f0</code></td>
<td>
<p>Initial predictions of the model (they correspond to maximum value
of each output variable)</p>
</td></tr>
<tr><td><code id="EATBoost_+3A_prediction">prediction</code></td>
<td>
<p>Final predictions of the original data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>EATBoost</code> object.
</p>
<p>A <code>EATBoost</code> object.
</p>

<hr>
<h2 id='efficiency'>Calculate efficiency scores</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>Calculates the efficiency score corresponding to the given model
using the given measure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(
  model,
  measure = "rad.out",
  data,
  x,
  y,
  heuristic = TRUE,
  direction.vector = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency_+3A_model">model</code></td>
<td>
<p>Model object for which efficiency score is computed. Valid classes
are: <code>DEA</code>, <code>FDH</code>, <code>EATBoost</code> and <code>MARSBoost</code>.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_measure">measure</code></td>
<td>
<p>Efficiency measure used. Valid measures are: <code>rad.out</code>,
<code>rad.in</code></p>
</td></tr>
<tr><td><code id="efficiency_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_heuristic">heuristic</code></td>
<td>
<p>Only used if <code>model</code> is <code>EATBoost</code>. This indicates
whether the heuristic or the exact approach is used.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_direction.vector">direction.vector</code></td>
<td>
<p>Only used when <code>measure</code> is <code>DDF</code>.Direction vector.
Valid values are: <code>dmu</code> (x_0, y_0), <code>unit</code> (unit vector),
<code>mean</code> (mean values of each variable) and a user specific vector of
the same length as the number of input and output variables</p>
</td></tr>
<tr><td><code id="efficiency_+3A_weights">weights</code></td>
<td>
<p>Only used when <code>measure</code> is <code>WAM</code>. Weights.
Valid values are: <code>MIP</code> (Measure of Inefficiency
Proportions), <code>RAM</code> (Range Adjusted Measure), <code>BAM</code> (Bounded
Adjusted Measure), <code>normalized</code> (normalized weighted additive model)
and a user specific vector of the same length as the number of input and
output variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='ERG'>Enhanced Russell Graph measure</h2><span id='topic+ERG'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ERG(data, x, y, dataOriginal = data, xOriginal = x, yOriginal = y, FDH = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ERG_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="ERG_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="ERG_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="ERG_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="ERG_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="ERG_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="ERG_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='EstimCoeffsForward'>Estimate Coefficients in Multivariate Adaptive Frontier Splines during
Forward Procedure.</h2><span id='topic+EstimCoeffsForward'></span>

<h3>Description</h3>

<p>This function solves a Quadratic Programming Problem to obtain a
set of coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimCoeffsForward(B, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimCoeffsForward_+3A_b">B</code></td>
<td>
<p><code>matrix</code> of basis functions.</p>
</td></tr>
<tr><td><code id="EstimCoeffsForward_+3A_y">y</code></td>
<td>
<p>Output <code>vector</code> in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vector</code> with the coefficients estimated.
</p>

<hr>
<h2 id='estimEAT'>Estimation of child nodes</h2><span id='topic+estimEAT'></span>

<h3>Description</h3>

<p>This function gets the estimation of the response variable and updates Pareto-coordinates and the observation index for both new nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimEAT(data, leaves, t, xi, s, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimEAT_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_leaves">leaves</code></td>
<td>
<p>List structure with leaf nodes or pending expansion nodes.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_xi">xi</code></td>
<td>
<p>Variable index that produces the split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_s">s</code></td>
<td>
<p>Value of xi variable that produces the split.</p>
</td></tr>
<tr><td><code id="estimEAT_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Left and right children nodes.
</p>

<hr>
<h2 id='FDH'>Free Disposal Hull model</h2><span id='topic+FDH'></span><span id='topic+FDH_object'></span>

<h3>Description</h3>

<p>This function estimates a production frontier satisfying Free
Disposal HUll axioms using the radial output measure.
</p>
<p>This function saves information about the FDH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDH(data, x, y)

FDH_object(data, x, y, pred, score)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDH_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="FDH_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="FDH_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="FDH_+3A_pred">pred</code></td>
<td>
<p>Output predictions using the BBC radial output measure</p>
</td></tr>
<tr><td><code id="FDH_+3A_score">score</code></td>
<td>
<p>Efficiency score using the BBC radial output measure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>FDH</code> object.
</p>
<p>A <code>FDH</code> object.
</p>

<hr>
<h2 id='get.a.EATBoost'>Get <code>EATBoost</code> leaves supports</h2><span id='topic+get.a.EATBoost'></span>

<h3>Description</h3>

<p>Calculates the inferior corner of the leaves supports of a
<code>EATBoost</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.a.EATBoost(EATBoost_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.a.EATBoost_+3A_eatboost_model">EATBoost_model</code></td>
<td>
<p>Model from class <code>EATBoost</code> from which the data
are obtained</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the leave supports
</p>

<hr>
<h2 id='get.a.trees'>Get the inferior corner of the leave support from all trees
of <code>EATBoost</code></h2><span id='topic+get.a.trees'></span>

<h3>Description</h3>

<p>Calculates the inferior corner of the support of all leave nodes
of every tree created in the <code>EATBoost</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.a.trees(EATBoost_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.a.trees_+3A_eatboost_model">EATBoost_model</code></td>
<td>
<p>Model from class <code>EATBoost</code> from which the data
are obtained</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of <code>matrix</code>. The length of the list is equal to
the <code>num.iterations</code> of the <code>EATBoost_model</code>. Each <code>matrix</code>
corresponds to a tree,  where the number of columns is the number of input
variables and the number of rows to the number of leaves
</p>

<hr>
<h2 id='get.b.trees'>Get the superior corner of the leave support from all trees
of <code>EATBoost</code></h2><span id='topic+get.b.trees'></span>

<h3>Description</h3>

<p>Calculates the superior corner of the support of all leave nodes
of every tree created in the <code>EATBoost</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.b.trees(EATBoost_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.b.trees_+3A_eatboost_model">EATBoost_model</code></td>
<td>
<p>Model from class <code>EATBoost</code> from which the data
are obtained</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of <code>matrix</code>. The length of the list is equal to
the <code>num.iterations</code> of the <code>EATBoost_model</code>. Each <code>matrix</code>
corresponds to a tree,  where the number of columns is the number of input
variables and the number of rows to the number of leaves
</p>

<hr>
<h2 id='get.intersection.a'>Get intersection between two leaves supports</h2><span id='topic+get.intersection.a'></span>

<h3>Description</h3>

<p>Calculates the intersection between two leave nodes from
different trees of a <code>EATBoost</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.intersection.a(comb_a_actual, comb_b_actual)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.intersection.a_+3A_comb_a_actual">comb_a_actual</code></td>
<td>
<p>Inferior corner of first leave support</p>
</td></tr>
<tr><td><code id="get.intersection.a_+3A_comb_b_actual">comb_b_actual</code></td>
<td>
<p>Superior corner of first leave support</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vector</code> with the intersection. <code>NULL</code> if intersection
is not valid.
</p>

<hr>
<h2 id='isFinalNode'>Is Final Node</h2><span id='topic+isFinalNode'></span>

<h3>Description</h3>

<p>This function evaluates a node and checks if it fulfills the conditions to be a final node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFinalNode(obs, data, numStop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFinalNode_+3A_obs">obs</code></td>
<td>
<p>Observation in the evaluated node.</p>
</td></tr>
<tr><td><code id="isFinalNode_+3A_data">data</code></td>
<td>
<p>Data with predictive variable.</p>
</td></tr>
<tr><td><code id="isFinalNode_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if the node is a final node and false in any other case.
</p>

<hr>
<h2 id='MARSAdapted'>Adapted Multivariate Adaptive Frontier Splines</h2><span id='topic+MARSAdapted'></span>

<h3>Description</h3>

<p>Create an adapted version of Multivariate Adaptive Regression
Splines (MARS) model to estimate a production frontier satisfying some
classical production theory axioms, such as monotonicity and concavity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSAdapted(
  data,
  x,
  y,
  nterms,
  Kp = 1,
  d = 2,
  err_red = 0.01,
  minspan = 0,
  endspan = 0,
  linpreds = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSAdapted_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_nterms">nterms</code></td>
<td>
<p>Maximum number of reflected pairs created by the forward
algorithm of MARS.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_kp">Kp</code></td>
<td>
<p>Maximum degree of interaction allowed. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_d">d</code></td>
<td>
<p>Generalized Cross Validation (GCV) penalty per knot. Default is
<code>2</code>. If it is set to <code>-1</code>, <code>GCV = RSS / n</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_err_red">err_red</code></td>
<td>
<p>Minimum reduced error rate for the addition of two new basis
functions. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_minspan">minspan</code></td>
<td>
<p>Minimum number of observations between knots. When
<code>minspan = 0</code> (default), it is calculated as in Friedman's MARS paper
section 3.8 with alpha = 0.05.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_endspan">endspan</code></td>
<td>
<p>Minimum number of observations before the first and after the
final knot. When <code>endspan = 0</code> (default), it is calculated as in
Friedman's MARS paper section 3.8 with alpha = 0.05.</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_linpreds">linpreds</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, predictors can enter linearly</p>
</td></tr>
<tr><td><code id="MARSAdapted_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>AdaptedMARS</code> object.
</p>

<hr>
<h2 id='MARSAdapted_object'>Create an MARSAdapted object</h2><span id='topic+MARSAdapted_object'></span>

<h3>Description</h3>

<p>This function saves information about the adapted Multivariate
Adaptive Frontier Splines model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSAdapted_object(
  data,
  x,
  y,
  rownames,
  nterms,
  Kp,
  d,
  err_red,
  minspan,
  endspan,
  na.rm,
  MARS.Forward,
  MARS.Forward.Smooth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSAdapted_object_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_rownames">rownames</code></td>
<td>
<p><code>string</code>. Data rownames.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_nterms">nterms</code></td>
<td>
<p>Maximum number of terms created by the forward algorithm .</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_kp">Kp</code></td>
<td>
<p>Maximum degree of interaction allowed. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_d">d</code></td>
<td>
<p>Generalized Cross Validation (GCV) penalty per knot. Default is
<code>2</code>. If set to <code>-1</code>, <code>GCV = RSS / n</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_err_red">err_red</code></td>
<td>
<p>Minimum reduced error rate for the addition of two new basis
functions. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_minspan">minspan</code></td>
<td>
<p>Minimum number of observations between knots. When
<code>minspan = 0</code> (default), it is calculated as in Friedman's MARS paper
section 3.8 with alpha = 0.05.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_endspan">endspan</code></td>
<td>
<p>Minimum number of observations before the first and after the
final knot. When <code>endspan = 0</code> (default), it is calculated as in
Friedman's MARS paper section 3.8 with alpha = 0.05.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_mars.forward">MARS.Forward</code></td>
<td>
<p>The Multivariate Adaptive Frontier Splines model after
applying the forward algorithm without the smoothing procedures</p>
</td></tr>
<tr><td><code id="MARSAdapted_object_+3A_mars.forward.smooth">MARS.Forward.Smooth</code></td>
<td>
<p>The Multivariate Adaptive Frontier Splines model
after applying the forward algorithm after applying the smoothing procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MARSAdapted</code> object.
</p>

<hr>
<h2 id='MARSAdaptedSmooth'>Smoothing (Forward) Multivariate Adaptive Frontier Splines</h2><span id='topic+MARSAdaptedSmooth'></span>

<h3>Description</h3>

<p>This function smoothes the Forward MARS predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSAdaptedSmooth(data, nX, knots, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSAdaptedSmooth_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables in
the model.</p>
</td></tr>
<tr><td><code id="MARSAdaptedSmooth_+3A_nx">nX</code></td>
<td>
<p>number of inputs in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSAdaptedSmooth_+3A_knots">knots</code></td>
<td>
<p><code>data.frame</code> containing knots from Forward MARS.</p>
</td></tr>
<tr><td><code id="MARSAdaptedSmooth_+3A_y">y</code></td>
<td>
<p>output indexes in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the set of knots from backward (<code>knots</code>),
the new cubic knots (<code>cubic_knots</code>) and the set of coefficients
(<code>alpha</code>).
</p>

<hr>
<h2 id='MARSBoost'>LS-Boosting with adapted Multivariate Adaptive Frontier Splines (MARS)</h2><span id='topic+MARSBoost'></span><span id='topic+MARSBoost_object'></span>

<h3>Description</h3>

<p>This function estimates a production frontier satisfying some
classical production theory axioms, such as monotonicity and concavity,
which is based upon the adaptation of the machine learning technique known
as LS-boosting using adapted Multivariate Adaptive Regression Splines (MARS)
as base learners.
</p>
<p>This function saves information about the LS-Boosted
Multivariate Adaptive Frontier Splines model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MARSBoost(data, x, y, num.iterations, num.terms, learning.rate)

MARSBoost_object(
  data,
  x,
  y,
  num.iterations,
  learning.rate,
  num.terms,
  MARS.models,
  f0,
  prediction,
  prediction.smooth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MARSBoost_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables
in the model.</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_num.iterations">num.iterations</code></td>
<td>
<p>Maximum number of iterations the algorithm will perform</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_num.terms">num.terms</code></td>
<td>
<p>Maximum number of reflected pairs created by the forward
algorithm of MARS.</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_learning.rate">learning.rate</code></td>
<td>
<p>Learning rate that control overfitting of the algorithm.
Value must be in (0,1]</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_mars.models">MARS.models</code></td>
<td>
<p>List of the adapted forward MARS models created in each
iterations</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_f0">f0</code></td>
<td>
<p>Initial predictions of the model (they correspond to maximum value
of each output variable)</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_prediction">prediction</code></td>
<td>
<p>Final predictions of the original data without applying
the smoothing procedure</p>
</td></tr>
<tr><td><code id="MARSBoost_+3A_prediction.smooth">prediction.smooth</code></td>
<td>
<p>Final predictions of the original data after
applying the smoothing procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MARSBoost</code> object.
</p>
<p>A <code>MARSBoost</code> object.
</p>

<hr>
<h2 id='mse'>Mean Squared Error</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>This function computes the mean squared error between two
numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(y, yPred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_y">y</code></td>
<td>
<p>Vector of actual data.</p>
</td></tr>
<tr><td><code id="mse_+3A_ypred">yPred</code></td>
<td>
<p>Vector of predicted values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean Squared Error.
</p>

<hr>
<h2 id='mse_tree'>Mean Squared Error</h2><span id='topic+mse_tree'></span>

<h3>Description</h3>

<p>This function calculates the Mean Square Error between the predicted value and the observations in a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse_tree(data, t, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_tree_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="mse_tree_+3A_t">t</code></td>
<td>
<p>A given node.</p>
</td></tr>
<tr><td><code id="mse_tree_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean Square Error at a node.
</p>

<hr>
<h2 id='posIdNode'>Position of the node</h2><span id='topic+posIdNode'></span>

<h3>Description</h3>

<p>This function finds the node where a register is located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posIdNode(tree, idNode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posIdNode_+3A_tree">tree</code></td>
<td>
<p>A list containing EAT nodes.</p>
</td></tr>
<tr><td><code id="posIdNode_+3A_idnode">idNode</code></td>
<td>
<p>Id of a specific node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Position of the node or -1 if it is not found.
</p>

<hr>
<h2 id='predict.DEA'>Model Prediction for DEA</h2><span id='topic+predict.DEA'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>DEA</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DEA'
predict(object, newdata, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DEA_+3A_object">object</code></td>
<td>
<p>A <code>DEA</code> object.</p>
</td></tr>
<tr><td><code id="predict.DEA_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.DEA_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.DEA_+3A_y">y</code></td>
<td>
<p>Outputs index.</p>
</td></tr>
<tr><td><code id="predict.DEA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values. Valid measures are:
<code>rad.out</code>.
</p>

<hr>
<h2 id='predict.EAT'>Model Prediction for Efficiency Analysis Trees.</h2><span id='topic+predict.EAT'></span>

<h3>Description</h3>

<p>This function predicts the expected output by an <code>EAT</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EAT'
predict(object, newdata, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.EAT_+3A_object">object</code></td>
<td>
<p>An <code>EAT</code> object.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.EAT_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values.
</p>

<hr>
<h2 id='predict.EATBoost'>Model prediction for EATBoost algorithm</h2><span id='topic+predict.EATBoost'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>EATBoost</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EATBoost'
predict(object, newdata, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.EATBoost_+3A_object">object</code></td>
<td>
<p>A <code>EATBoost</code> object.</p>
</td></tr>
<tr><td><code id="predict.EATBoost_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.EATBoost_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.EATBoost_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values.
</p>

<hr>
<h2 id='predict.FDH'>Model Prediction for FDH</h2><span id='topic+predict.FDH'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>FDH</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDH'
predict(object, newdata, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.FDH_+3A_object">object</code></td>
<td>
<p>A <code>FDH</code> object.</p>
</td></tr>
<tr><td><code id="predict.FDH_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.FDH_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.FDH_+3A_y">y</code></td>
<td>
<p>Outputs index.</p>
</td></tr>
<tr><td><code id="predict.FDH_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values. Valid measures are:
<code>rad.out</code>.
</p>

<hr>
<h2 id='predict.MARSAdapted'>Model Prediction for Adapted Multivariate Adaptive Frontier Splines.</h2><span id='topic+predict.MARSAdapted'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>MARS</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MARSAdapted'
predict(object, newdata, x, class = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MARSAdapted_+3A_object">object</code></td>
<td>
<p>A <code>MARSAdapted</code> object.</p>
</td></tr>
<tr><td><code id="predict.MARSAdapted_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.MARSAdapted_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.MARSAdapted_+3A_class">class</code></td>
<td>
<p>Model for prediction. <code>1</code> MARS Boost without smoothing
procedure.<code>2</code> MARS Boost with smoothing procedure..</p>
</td></tr>
<tr><td><code id="predict.MARSAdapted_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values.
</p>

<hr>
<h2 id='predict.MARSBoost'>Model Prediction for Boosted Multivariate Adaptive Frontier Splines</h2><span id='topic+predict.MARSBoost'></span>

<h3>Description</h3>

<p>This function predicts the expected output by a <code>MARSBoost</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MARSBoost'
predict(object, newdata, x, class = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MARSBoost_+3A_object">object</code></td>
<td>
<p>A <code>MARSBoost</code> object.</p>
</td></tr>
<tr><td><code id="predict.MARSBoost_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code>. Set of input variables to predict on.</p>
</td></tr>
<tr><td><code id="predict.MARSBoost_+3A_x">x</code></td>
<td>
<p>Inputs index.</p>
</td></tr>
<tr><td><code id="predict.MARSBoost_+3A_class">class</code></td>
<td>
<p>Model for prediction. <code>1</code> MARS Boost without smoothing.
<code>2</code> MARS Boost with smoothing.</p>
</td></tr>
<tr><td><code id="predict.MARSBoost_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the predicted values.
</p>

<hr>
<h2 id='predictor'>Efficiency Analysis Trees Predictor</h2><span id='topic+predictor'></span>

<h3>Description</h3>

<p>This function predicts the expected value based on a set of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictor(tree, register)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictor_+3A_tree">tree</code></td>
<td>
<p><code>list</code> with the tree nodes.</p>
</td></tr>
<tr><td><code id="predictor_+3A_register">register</code></td>
<td>
<p>Set of independent values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of the dependent variable based on the given register.
</p>

<hr>
<h2 id='preProcess'>Data Pre-processing for Multivariate Adaptive Frontier Splines.</h2><span id='topic+preProcess'></span>

<h3>Description</h3>

<p>This function arranges the data in the required format and
displays error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess(data, x, y, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcess_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the variables
in the model.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_x">x</code></td>
<td>
<p>Column input indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_y">y</code></td>
<td>
<p>Column output indexes in <code>data</code>.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, <code>NA</code> rows are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>data.frame</code> in the required format.
</p>

<hr>
<h2 id='Russell_in'>Linear programming model for Russell input measure</h2><span id='topic+Russell_in'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Russell_in(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Russell_in_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="Russell_in_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='Russell_out'>Linear programming model for Russell output measure</h2><span id='topic+Russell_out'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Russell_out(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Russell_out_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="Russell_out_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

<hr>
<h2 id='split'>Split node</h2><span id='topic+split'></span>

<h3>Description</h3>

<p>This function gets the variable and split value to be used in estimEAT, selects the best split and updates VarInfo, node indexes and leaves list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split(data, tree, leaves, t, x, y, numStop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="split_+3A_tree">tree</code></td>
<td>
<p>List structure with the tree nodes.</p>
</td></tr>
<tr><td><code id="split_+3A_leaves">leaves</code></td>
<td>
<p>List with leaf nodes or pending expansion nodes.</p>
</td></tr>
<tr><td><code id="split_+3A_t">t</code></td>
<td>
<p>Node which is being split.</p>
</td></tr>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>Column input indexes in data.</p>
</td></tr>
<tr><td><code id="split_+3A_y">y</code></td>
<td>
<p>Column output indexes in data.</p>
</td></tr>
<tr><td><code id="split_+3A_numstop">numStop</code></td>
<td>
<p>Minimum number of observations in a node to be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Leaves and tree lists updated with the new child nodes.
</p>

<hr>
<h2 id='WAM'>Linear programming model for Weighted Additive Model</h2><span id='topic+WAM'></span>

<h3>Description</h3>

<p>This function predicts the expected output through a DEA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAM(
  data,
  x,
  y,
  dataOriginal = data,
  xOriginal = x,
  yOriginal = y,
  FDH = FALSE,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WAM_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the new variables
in the model.</p>
</td></tr>
<tr><td><code id="WAM_+3A_x">x</code></td>
<td>
<p>Vector. Column input indexes in data.</p>
</td></tr>
<tr><td><code id="WAM_+3A_y">y</code></td>
<td>
<p>Vector. Column output indexes in data.</p>
</td></tr>
<tr><td><code id="WAM_+3A_dataoriginal">dataOriginal</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> containing the
original
variables used to create the model.</p>
</td></tr>
<tr><td><code id="WAM_+3A_xoriginal">xOriginal</code></td>
<td>
<p>Vector. Column input indexes in original data.</p>
</td></tr>
<tr><td><code id="WAM_+3A_yoriginal">yOriginal</code></td>
<td>
<p>Vector. Column output indexes in original data.</p>
</td></tr>
<tr><td><code id="WAM_+3A_fdh">FDH</code></td>
<td>
<p>Binary decision variables</p>
</td></tr>
<tr><td><code id="WAM_+3A_weights">weights</code></td>
<td>
<p>Weights. Valid values are: <code>MIP</code> (Measure of Inefficiency
Proportions), <code>RAM</code> (Range Adjusted Measure), <code>BAM</code> (Bounded
Adjusted Measure), <code>normalized</code> (normalized weighted additive model)
and a user specific vector of the same length as the number of input and
output variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> with the the predicted score
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
