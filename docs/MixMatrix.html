<!DOCTYPE html><html><head><title>Help for package MixMatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MixMatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARgenerate'><p>Generate a unit AR(1) covariance matrix</p></a></li>
<li><a href='#CSgenerate'><p>Generate a compound symmetric correlation matrix</p></a></li>
<li><a href='#init_matrixmixture'><p>Initializing settings for Matrix Mixture Models</p></a></li>
<li><a href='#matrixlda'><p>LDA for matrix variate distributions</p></a></li>
<li><a href='#matrixmixture'><p>Fit a matrix variate mixture model</p></a></li>
<li><a href='#matrixqda'><p>Quadratic Discriminant Analysis for Matrix Variate Observations</p></a></li>
<li><a href='#MixMatrix'><p>Classification with Matrix Variate Normal and t Distributions</p></a></li>
<li><a href='#MLmatrixnorm'><p>Maximum likelihood estimation for matrix normal distributions</p></a></li>
<li><a href='#MLmatrixt'><p>Maximum likelihood estimation for matrix variate t distributions</p></a></li>
<li><a href='#predict.matrixlda'><p>Classify Matrix Variate Observations by Linear Discrimination</p></a></li>
<li><a href='#predict.matrixqda'><p>Classify Matrix Variate Observations by Quadratic Discrimination</p></a></li>
<li><a href='#rmatrixinvt'><p>Distribution functions for matrix variate inverted t distributions</p></a></li>
<li><a href='#rmatrixnorm'><p>Matrix variate Normal distribution functions</p></a></li>
<li><a href='#rmatrixt'><p>Distribution functions for the matrix variate t distribution.</p></a></li>
<li><a href='#vardet'><p>Determinant selector for chosen covariance matrix.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classification with Matrix Variate Normal and t Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides sampling and density functions for matrix
    variate normal, t, and inverted t distributions;  ML estimation for matrix
    variate normal and t distributions using the EM algorithm,
    including some restrictions on the parameters; and classification by linear and
    quadratic discriminant analysis for matrix variate normal and t
    distributions described in Thompson et al. (2019) &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1696208">doi:10.1080/10618600.2019.1696208</a>&gt;.
    Performs clustering with matrix variate normal and t mixture models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, CholWishart, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr, ggplot2, dplyr, magrittr,
spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gzt/MixMatrix/">https://github.com/gzt/MixMatrix/</a>,
<a href="https://gzt.github.io/MixMatrix/">https://gzt.github.io/MixMatrix/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gzt/MixMatrix/issues">https://github.com/gzt/MixMatrix/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-us</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-15 13:24:40 UTC; gzt</td>
</tr>
<tr>
<td>Author:</td>
<td>Geoffrey Thompson <a href="https://orcid.org/0000-0003-2436-8822"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  B. D. Ripley author of original lda and qda functions [ctb, cph],
  W. N. Venables author of original lda and qda functions [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Geoffrey Thompson &lt;gzthompson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-16 08:10:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARgenerate'>Generate a unit AR(1) covariance matrix</h2><span id='topic+ARgenerate'></span>

<h3>Description</h3>

<p>generate AR(1) correlation matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARgenerate(n, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARgenerate_+3A_n">n</code></td>
<td>
<p>number of columns/rows</p>
</td></tr>
<tr><td><code id="ARgenerate_+3A_rho">rho</code></td>
<td>
<p>correlation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Toeplitz <code class="reqn">n \times n</code> matrix with 1 on the diagonal
and <code class="reqn">rho^k</code> on the other diagonals, where <code class="reqn">k</code> is distance from the
main diagonal.
Used internally but it is useful for generating your own random matrices.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+toeplitz">stats::toeplitz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARgenerate(6, .9)
</code></pre>

<hr>
<h2 id='CSgenerate'>Generate a compound symmetric correlation matrix</h2><span id='topic+CSgenerate'></span>

<h3>Description</h3>

<p>Generate a compound symmetric correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSgenerate(n, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSgenerate_+3A_n">n</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="CSgenerate_+3A_rho">rho</code></td>
<td>
<p>off-diagonal element - a correlation between -1 and 1.
Will warn if less than 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an <code class="reqn">n \times n</code> matrix with 1 on the diagonal and
<code>rho</code> on the off-diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generates a covariance matrix with 1 on the main diagonal
# and 0.5 on the off-diagonal elements.
CSgenerate(3, .5)
</code></pre>

<hr>
<h2 id='init_matrixmixture'>Initializing settings for Matrix Mixture Models</h2><span id='topic+init_matrixmixture'></span>

<h3>Description</h3>

<p>Providing this will generate a list suitable for use as the <code>init</code>
argument in the <code>matrixmixture</code> function. Either provide data
and it will select centers and variance matrices to initialize or
provide initial values and it will format them as expected for the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_matrixmixture(
  data,
  prior = NULL,
  K = length(prior),
  centers = NULL,
  U = NULL,
  V = NULL,
  centermethod = "kmeans",
  varmethod = "identity",
  model = "normal",
  init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_matrixmixture_+3A_data">data</code></td>
<td>
<p>data, <code class="reqn">p \times q \times n</code> array</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_prior">prior</code></td>
<td>
<p>prior probability. One of <code>prior</code> and <code>K</code>
must be  provided. They must be consistent if both provided.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_k">K</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_centers">centers</code></td>
<td>
<p>(optional) either a matrix or an array of
<code class="reqn">p \times p</code>
matrices for use as the <code>centers</code> argument.
If fewer than <code>K</code> are provided, the
remainder are chosen by <code>centermethod</code>.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_u">U</code></td>
<td>
<p>(optional) either a matrix or an array of
<code class="reqn">p \times p</code> matrices for use as the <code>U</code>
argument. If a matrix is provided, it is duplicated to provide an
array. If an array is provided, it should have <code>K</code> slices.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_v">V</code></td>
<td>
<p>(optional) either a matrix or an array of matrices
for use as the <code>V</code> argument. If a matrix is provided,
it is duplicated to provide an array.
If an array is provided, it should have <code>K</code> slices.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_centermethod">centermethod</code></td>
<td>
<p>what method to use to generate initial centers.
Currently support random start (<code>random</code>) or performing k-means
(<code>kmeans</code>) on the vectorized version for a small number of
iterations and then converting back.
By default, if <code>K</code> centers are provided, nothing will be done.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_varmethod">varmethod</code></td>
<td>
<p>what method to use to choose initial variance matrices.
Currently only identity matrices are created.
By default, if <code>U</code> and <code>V</code> matrices are provided, nothing
will be done.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_model">model</code></td>
<td>
<p>whether to use a normal distribution or a t-distribution, not
relevant for more initialization methods.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_init">init</code></td>
<td>
<p>(optional) a (possibly partially-formed) list
with some of the components
<code>centers</code>, <code>U</code>, and <code>V</code>. The function will complete the
list and fill out missing entries.</p>
</td></tr>
<tr><td><code id="init_matrixmixture_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>kmeans()</code> if that is
<code>centermethod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list suitable to use as the <code>init</code> argument in
<code>matrixmixture</code>:
</p>

<dl>
<dt><code>centers</code></dt><dd><p>the group means,
a <code class="reqn">p \times q \times K</code> array.</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrices, a
<code class="reqn">p \times p \times K</code>  array</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrix, a
<code class="reqn">q \times q \times K</code> array</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrixmixture">matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(20180221)
A &lt;- rmatrixt(30,mean=matrix(0,nrow=3,ncol=4), df = 10)
# 3x4 matrices with mean 0
B &lt;- rmatrixt(30,mean=matrix(2,nrow=3,ncol=4), df = 10)
# 3x4 matrices with mean 2
C &lt;- array(c(A,B), dim=c(3,4,60)) # combine into one array
prior &lt;- c(.5,.5) # equal probability prior
init = init_matrixmixture(C, prior = prior)
# will find two centers using the "kmeans" method on the vectorized matrices
</code></pre>

<hr>
<h2 id='matrixlda'>LDA for matrix variate distributions</h2><span id='topic+matrixlda'></span>

<h3>Description</h3>

<p>Performs linear discriminant analysis on matrix variate data.
This works slightly differently from the LDA function in MASS:
it does not sphere the data or otherwise normalize it. It presumes
equal variance matrices and probabilities are given as if
the data are from a matrix variate normal distribution.
The estimated variance matrices are weighted by the prior. However,
if there are not enough members of a class to estimate a variance,
this may be a problem.
The function does not take the formula interface. If <code>method = 't'</code>
is selected, this performs discrimination using the matrix variate t
distribution, presuming equal covariances between classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixlda(
  x,
  grouping,
  prior,
  tol = 1e-04,
  method = "normal",
  nu = 10,
  ...,
  subset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixlda_+3A_x">x</code></td>
<td>
<p>3-D array of matrix data indexed by the third dimension</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_grouping">grouping</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_prior">prior</code></td>
<td>
<p>a vector of prior probabilities of the same length
as the number of classes</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_tol">tol</code></td>
<td>
<p>by default, <code>1e-4</code>. Tolerance parameter checks
for 0 variance.</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_method">method</code></td>
<td>
<p>whether to use the normal distribution (<code>normal</code>) or the
t distribution (<code>t</code>). By default, normal.</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_nu">nu</code></td>
<td>
<p>If using the t-distribution, the degrees of freedom parameter. By
default, 10.</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods, such
as additional parameters to pass to <code>MLmatrixnorm</code> (e.g.,
<code>row.mean</code>)</p>
</td></tr>
<tr><td><code id="matrixlda_+3A_subset">subset</code></td>
<td>
<p>An index vector specifying the cases to be used in the
training sample.  (NOTE: If given, this argument must be
named.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>matrixlda</code> containing
the following components:
</p>

<dl>
<dt><code>prior</code></dt><dd><p>the prior probabilities used.</p>
</dd>
<dt><code>counts</code></dt><dd><p>the counts of group membership</p>
</dd>
<dt><code>means</code></dt><dd><p>the group means.</p>
</dd>
<dt><code>scaling</code></dt><dd><p>the scalar variance parameter</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrix</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrix</p>
</dd>
<dt><code>lev</code></dt><dd><p>levels of the grouping factor</p>
</dd>
<dt><code>N</code></dt><dd><p>The number of observations used.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used.</p>
</dd>
<dt><code>nu</code></dt><dd><p>The degrees of freedom parameter if the t distribution
was used.</p>
</dd>
<dt><code>call</code></dt><dd><p>The (matched) function call.</p>
</dd>
</dl>



<h3>References</h3>

<pre>G Z Thompson, R Maitra, W Q Meeker, A Bastawros (2019),
"Classification with the matrix-variate-t distribution", arXiv
e-prints arXiv:1907.09565 &lt;https://arxiv.org/abs/1907.09565&gt;

Ming Li, Baozong Yuan, "2D-LDA: A statistical linear discriminant
  analysis for image matrix", Pattern Recognition Letters, Volume 26,
  Issue 5, 2005, Pages 527-532, ISSN 0167-8655.
</pre>
<p>Aaron Molstad &amp; Adam J. Rothman (2019), &quot;A Penalized Likelihood
Method for Classification With Matrix-Valued Predictors&quot;, Journal of
Computational and Graphical Statistics, 28:1, 11-22,
doi: <a href="https://doi.org/10.1080/10618600.2018.1476249">10.1080/10618600.2018.1476249</a>  <a href="https://CRAN.R-project.org/package=MatrixLDA"><span class="pkg">MatrixLDA</span></a>
</p>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with
S. Fourth Edition. Springer, New York. ISBN 0-387-95457-0 <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.matrixlda">predict.matrixlda()</a></code>, <code><a href="MASS.html#topic+lda">MASS::lda()</a></code>,
<code><a href="#topic+MLmatrixnorm">MLmatrixnorm()</a></code> and <code><a href="#topic+MLmatrixt">MLmatrixt()</a></code>
<code><a href="#topic+matrixqda">matrixqda()</a></code>, and <code><a href="#topic+matrixmixture">matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180221)
# construct two populations of 3x4 random matrices with different means
A &lt;- rmatrixnorm(30, mean = matrix(0, nrow = 3, ncol = 4))
B &lt;- rmatrixnorm(30, mean = matrix(1, nrow = 3, ncol = 4))
C &lt;- array(c(A, B), dim = c(3, 4, 60)) # combine together
groups &lt;- c(rep(1, 30), rep(2, 30)) # define groups
prior &lt;- c(.5, .5) # set prior
D &lt;- matrixlda(C, groups, prior) # fit model
logLik(D)
print(D)
</code></pre>

<hr>
<h2 id='matrixmixture'>Fit a matrix variate mixture model</h2><span id='topic+matrixmixture'></span>

<h3>Description</h3>

<p>Clustering by fitting a mixture model using EM with <code>K</code> groups
and unconstrained covariance matrices for a matrix variate normal or
matrix variate t distribution (with specified degrees of freedom <code>nu</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixmixture(
  x,
  init = NULL,
  prior = NULL,
  K = length(prior),
  iter = 1000,
  model = "normal",
  method = NULL,
  row.mean = FALSE,
  col.mean = FALSE,
  tolerance = 0.1,
  nu = NULL,
  ...,
  verbose = 0,
  miniter = 5,
  convergence = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixmixture_+3A_x">x</code></td>
<td>
<p>data, <code class="reqn">p \times q \times n</code> array</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_init">init</code></td>
<td>
<p>a list containing an array of <code>K</code> of
<code class="reqn">p \times q</code> means labeled <code>centers</code>,
and optionally <code class="reqn">p \times p</code> and <code class="reqn">q \times q</code>
positive definite variance matrices labeled <code>U</code> and <code>V</code>.
By default, those are presumed to be identity if not provided.
If <code>init</code> is missing, it will be provided using the <code>prior</code>
or <code>K</code> by <code>init_matrixmix</code>.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_prior">prior</code></td>
<td>
<p>prior for the <code>K</code> classes, a vector that adds to unity</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_k">K</code></td>
<td>
<p>number of classes - provide either this or the prior. If this is
provided, the prior will be of uniform distribution among the classes.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_model">model</code></td>
<td>
<p>whether to use the <code>normal</code> or <code>t</code> distribution.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_method">method</code></td>
<td>
<p>what method to use to fit the distribution.
Currently no options.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_row.mean">row.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>col.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_col.mean">col.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>row.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_tolerance">tolerance</code></td>
<td>
<p>convergence criterion, using Aitken acceleration of the
log-likelihood by default.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom parameter. Can be a vector of length <code>K</code>.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_...">...</code></td>
<td>
<p>pass additional arguments to <code>MLmatrixnorm</code> or
<code>MLmatrixt</code></p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_verbose">verbose</code></td>
<td>
<p>whether to print diagnostic output, by default <code>0</code>.
Higher  numbers output more results.</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_miniter">miniter</code></td>
<td>
<p>minimum number of iterations</p>
</td></tr>
<tr><td><code id="matrixmixture_+3A_convergence">convergence</code></td>
<td>
<p>By default, <code>TRUE</code>, using Aitken acceleration
to determine convergence. If false, it instead checks if the change in
log-likelihood is less than <code>tolerance</code>. Aitken acceleration may
prematurely end in the first few steps, so you may wish to set
<code>miniter</code> or select <code>FALSE</code> if this is an issue.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>MixMatrixModel</code> containing the following
components:
</p>

<dl>
<dt><code>prior</code></dt><dd><p>the prior probabilities used.</p>
</dd>
<dt><code>init</code></dt><dd><p>the initialization used.</p>
</dd>
<dt><code>K</code></dt><dd><p>the number of groups</p>
</dd>
<dt><code>N</code></dt><dd><p>the number of observations</p>
</dd>
<dt><code>centers</code></dt><dd><p>the group means.</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrices</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrix</p>
</dd>
<dt><code>posterior</code></dt><dd><p>the posterior probabilities for each
observation</p>
</dd>
<dt><code>pi</code></dt><dd><p> the final proportions</p>
</dd>
<dt><code>nu</code></dt><dd><p>The degrees of freedom parameter if the t distribution
was used.</p>
</dd>
<dt><code>convergence </code></dt><dd><p>whether the model converged</p>
</dd>
<dt><code>logLik</code></dt><dd><p>a vector of the log-likelihoods
of each iteration ending in
the final log-likelihood of the model</p>
</dd>
<dt><code>model</code></dt><dd><p>the model used</p>
</dd>
<dt><code>method</code></dt><dd><p>the method used</p>
</dd>
<dt><code>call</code></dt><dd><p>The (matched) function call.</p>
</dd>
</dl>



<h3>References</h3>

<pre>Andrews, Jeffrey L., Paul D. McNicholas, and Sanjeena Subedi. 2011.
  "Model-Based Classification via Mixtures of Multivariate
  T-Distributions." Computational Statistics &amp; Data Analysis 55 (1):
  520–29. \doi{10.1016/j.csda.2010.05.019}.

Fraley, Chris, and Adrian E Raftery. 2002. "Model-Based Clustering,
   Discriminant Analysis, and Density Estimation." Journal of the
   American Statistical Association 97 (458). Taylor &amp; Francis: 611–31.
   \doi{10.1198/016214502760047131}.

McLachlan, Geoffrey J, Sharon X Lee, and Suren I Rathnayake. 2019.
      "Finite Mixture Models." Annual Review of Statistics and Its
      Application 6. Annual Reviews: 355–78.
      \doi{10.1146/annurev-statistics-031017-100325}.

Viroli, Cinzia. 2011. "Finite Mixtures of Matrix Normal Distributions
      for Classifying Three-Way Data." Statistics and Computing 21 (4):
      511–22. \doi{10.1007/s11222-010-9188-x}.
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+init_matrixmixture">init_matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180221)
A &lt;- rmatrixt(20,mean=matrix(0,nrow=3,ncol=4), df = 5)
# 3x4 matrices with mean 0
B &lt;- rmatrixt(20,mean=matrix(1,nrow=3,ncol=4), df = 5)
# 3x4 matrices with mean 1
C &lt;- array(c(A,B), dim=c(3,4,40)) # combine into one array
prior &lt;- c(.5,.5) # equal probability prior
# create an intialization object, starts at the true parameters
init = list(centers = array(c(rep(0,12),rep(1,12)), dim = c(3,4,2)),
              U = array(c(diag(3), diag(3)), dim = c(3,3,2))*20,
              V = array(c(diag(4), diag(4)), dim = c(4,4,2))
 )
# fit model
 res&lt;-matrixmixture(C, init = init, prior = prior, nu = 5,
                    model = "t", tolerance = 1e-3, convergence = FALSE)
print(res$centers) # the final centers
print(res$pi) # the final mixing proportion
plot(res) # the log likelihood by iteration
logLik(res) # log likelihood of final result
BIC(res) # BIC of final result
predict(res, newdata = C[,,c(1,21)]) # predicted class membership
</code></pre>

<hr>
<h2 id='matrixqda'>Quadratic Discriminant Analysis for Matrix Variate Observations</h2><span id='topic+matrixqda'></span>

<h3>Description</h3>

<p>See <code>matrixlda</code>: quadratic discriminant analysis for matrix
variate observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixqda(
  x,
  grouping,
  prior,
  tol = 1e-04,
  method = "normal",
  nu = 10,
  ...,
  subset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixqda_+3A_x">x</code></td>
<td>
<p>3-D array of matrix data indexed by the third dimension</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_grouping">grouping</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_prior">prior</code></td>
<td>
<p>a vector of prior probabilities of the same length
as the number of classes</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_tol">tol</code></td>
<td>
<p>by default, <code>1e-4</code>. Tolerance parameter checks
for 0 variance.</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_method">method</code></td>
<td>
<p>whether to use the normal distribution (<code>normal</code>) or the
t distribution (<code>t</code>). By default, normal.</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_nu">nu</code></td>
<td>
<p>If using the t-distribution, the degrees of freedom parameter. By
default, 10.</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods, such
as additional parameters to pass to <code>MLmatrixnorm</code> (e.g.,
<code>row.mean</code>)</p>
</td></tr>
<tr><td><code id="matrixqda_+3A_subset">subset</code></td>
<td>
<p>An index vector specifying the cases to be used in the
training sample.  (NOTE: If given, this argument must be
named.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses <code>MLmatrixnorm</code> or <code>MLmatrixt</code> to find the means and
variances for the case when different groups have different variances.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>matrixqda</code> containing
the following components:
</p>

<dl>
<dt><code>prior</code></dt><dd><p>the prior probabilities used.</p>
</dd>
<dt><code>counts</code></dt><dd><p>the counts of group membership</p>
</dd>
<dt><code>means</code></dt><dd><p>the group means.</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrices</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrices</p>
</dd>
<dt><code>lev</code></dt><dd><p>levels of the grouping factor</p>
</dd>
<dt><code>N</code></dt><dd><p>The number of observations used.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used.</p>
</dd>
<dt><code>nu</code></dt><dd><p>The degrees of freedom parameter
if the t-distribution was used.</p>
</dd>
<dt><code>call</code></dt><dd><p>The (matched) function call.</p>
</dd>
</dl>



<h3>References</h3>

<pre>G Z Thompson, R Maitra, W Q Meeker, A Bastawros (2019),
"Classification with the matrix-variate-t distribution", arXiv
e-prints arXiv:1907.09565 &lt;https://arxiv.org/abs/1907.09565&gt;
</pre>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with
S. Fourth Edition. Springer, New York. ISBN 0-387-95457-0</p>
<pre>Pierre Dutilleul.  The MLE algorithm for the matrix normal distribution.
Journal of Statistical Computation and Simulation, (64):105–123, 1999.
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+predict.matrixqda">predict.matrixqda()</a></code>, <code><a href="MASS.html#topic+qda">MASS::qda()</a></code>,
<code><a href="#topic+MLmatrixnorm">MLmatrixnorm()</a></code>, <code><a href="#topic+MLmatrixt">MLmatrixt()</a></code>,
<code><a href="#topic+matrixlda">matrixlda()</a></code>, and <code><a href="#topic+matrixmixture">matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180221)
# construct two populations of 3x4 random matrices with different means
A &lt;- rmatrixnorm(30, mean = matrix(0, nrow = 3, ncol = 4))
B &lt;- rmatrixnorm(30, mean = matrix(1, nrow = 3, ncol = 4))
C &lt;- array(c(A, B), dim = c(3, 4, 60)) # combine together
groups &lt;- c(rep(1, 30), rep(2, 30)) # define groups
prior &lt;- c(.5, .5) # set prior
D &lt;- matrixqda(C, groups, prior)
logLik(D)
print(D)
</code></pre>

<hr>
<h2 id='MixMatrix'>Classification with Matrix Variate Normal and t Distributions</h2><span id='topic+MixMatrix'></span>

<h3>Description</h3>

<p>Provides sampling and density functions for matrix
variate normal, <code class="reqn">t</code>, and inverted <code class="reqn">t</code> distributions;
ML estimation for matrix variate normal and <code class="reqn">t</code> distributions
using the EM algorithm, including some restrictions on the parameters;
and classification by linear and quadratic discriminant
analysis for matrix variate normal and t distributions described
in <a href="https://arxiv.org/abs/1907.09565">Thompson et al. (2019)</a>.
Performs clustering with matrix variate normal and t mixture models.
</p>

<hr>
<h2 id='MLmatrixnorm'>Maximum likelihood estimation for matrix normal distributions</h2><span id='topic+MLmatrixnorm'></span>

<h3>Description</h3>

<p>Maximum likelihood estimates exist for <code class="reqn">N &gt; max(p/q,q/p)+1</code> and are
unique for <code class="reqn">N &gt; max(p,q)</code>. This finds the estimate for the mean and then
alternates between estimates for the <code class="reqn">U</code> and <code class="reqn">V</code> matrices until
convergence. An AR(1), compound symmetry, correlation matrix, or independence
restriction can be proposed for either or both variance matrices. However, if
they are inappropriate for the data, they may fail with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLmatrixnorm(
  data,
  row.mean = FALSE,
  col.mean = FALSE,
  row.variance = "none",
  col.variance = "none",
  tol = 10 * .Machine$double.eps^0.5,
  max.iter = 100,
  U,
  V,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLmatrixnorm_+3A_data">data</code></td>
<td>
<p>Either a list of matrices or a 3-D array with matrices in
dimensions 1 and 2, indexed by dimension 3.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_row.mean">row.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>col.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_col.mean">col.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>row.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_row.variance">row.variance</code></td>
<td>
<p>Imposes a variance structure on the rows. Either
'none', 'AR(1)', 'CS' for 'compound symmetry', 'Correlation' for a
correlation matrix, or 'Independence' for
independent and identical variance across the rows.
Only positive correlations are allowed for AR(1) and CS covariances.
Note that while maximum likelihood estimators are available (and used) for
the unconstrained variance matrices, <code>optim</code> is used for any
constraints so it may be considerably slower.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_col.variance">col.variance</code></td>
<td>
<p>Imposes a variance structure on the columns.
Either 'none', 'AR(1)', 'CS', 'Correlation', or 'Independence'.
Only positive correlations are allowed for
AR(1) and CS.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion. Measured against square deviation
between iterations of the two variance-covariance matrices.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum possible iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_u">U</code></td>
<td>
<p>(optional) Can provide a starting point for the <code>U</code> matrix.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_v">V</code></td>
<td>
<p>(optional) Can provide a starting point for the <code>V</code> matrix.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixnorm_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments can be passed to <code>optim</code>
if using restrictions on the variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with a the following elements:
</p>

<dl>
<dt><code>mean</code></dt><dd><p>the mean matrix</p>
</dd>
<dt><code>scaling</code></dt><dd><p>the scalar variance parameter
(the first entry of the covariances are restricted to unity)</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrix</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrix</p>
</dd>
<dt><code>iter</code></dt><dd><p>the number of iterations</p>
</dd>
<dt><code>tol</code></dt><dd><p>the squared difference between iterations of
the variance matrices at the time of stopping</p>
</dd>
<dt><code>logLik</code></dt><dd><p>vector of log likelihoods at each iteration.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>a convergence flag, <code>TRUE</code> if converged.</p>
</dd>
<dt><code>call</code></dt><dd><p>The (matched) function call.</p>
</dd>
</dl>



<h3>References</h3>

<p>Pierre Dutilleul.  The MLE algorithm for the matrix normal
distribution.
Journal of Statistical Computation and Simulation, (64):105–123, 1999.</p>
<pre>Gupta, Arjun K, and Daya K Nagar. 1999. Matrix Variate Distributions.
Vol. 104. CRC Press. ISBN:978-1584880462
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixnorm">rmatrixnorm()</a></code> and <code><a href="#topic+MLmatrixt">MLmatrixt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180202)
# simulating from a given density
A &lt;- rmatrixnorm(
  n = 100, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = TRUE
)
# finding the parameters by ML estimation
results &lt;- MLmatrixnorm(A, tol = 1e-5)
print(results)
</code></pre>

<hr>
<h2 id='MLmatrixt'>Maximum likelihood estimation for matrix variate t distributions</h2><span id='topic+MLmatrixt'></span>

<h3>Description</h3>

<p>For the matrix variate normal distribution, maximum likelihood estimates
exist for <code class="reqn">N &gt; max(p/q,q/p)+1</code> and are unique for <code class="reqn">N &gt; max(p,q)</code>.
The number necessary for the matrix variate t has not been worked out but
this is a lower bound. This implements an ECME algorithm to estimate the
mean, covariance, and degrees of freedom parameters. An AR(1), compound
symmetry, or independence restriction can be proposed for either or both
variance matrices. However, if they are inappropriate for the data, they may
fail with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLmatrixt(
  data,
  row.mean = FALSE,
  col.mean = FALSE,
  row.variance = "none",
  col.variance = "none",
  df = 10,
  fixed = TRUE,
  tol = .Machine$double.eps^0.5,
  max.iter = 5000,
  U,
  V,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLmatrixt_+3A_data">data</code></td>
<td>
<p>Either a list of matrices or a 3-D array with matrices in
dimensions 1 and 2, indexed by dimension 3.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_row.mean">row.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>col.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_col.mean">col.mean</code></td>
<td>
<p>By default, <code>FALSE</code>. If <code>TRUE</code>, will fit a
common mean within each row. If both this and <code>row.mean</code> are
<code>TRUE</code>, there will be a common mean for the entire matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_row.variance">row.variance</code></td>
<td>
<p>Imposes a variance structure on the rows. Either
'none', 'AR(1)', 'CS' for 'compound symmetry', 'Correlation' for a
correlation matrix, or 'Independence' for
independent and identical variance across the rows.
Only positive correlations are allowed for AR(1) and CS and these
restrictions may not be guaranteed to converge.
Note that while maximum likelihood estimators are available (and used)
for the unconstrained variance matrices, <code>optim</code> is used for any
constraints so it may be considerably slower.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_col.variance">col.variance</code></td>
<td>
<p>Imposes a variance structure on the columns.
Either 'none', 'AR(1)', 'CS', 'Correlation', or 'Independence'.
Only positive correlations are allowed for
AR(1) and CS.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_df">df</code></td>
<td>
<p>Starting value for the degrees of freedom. If <code>fixed = TRUE</code>,
then this is required and not updated. By default, set to 10.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_fixed">fixed</code></td>
<td>
<p>Whether <code>df</code> is estimated or fixed.
By default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion. Measured against square deviation
between iterations of the two variance-covariance matrices.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum possible iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_u">U</code></td>
<td>
<p>(optional) Can provide a starting point for the U matrix.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_v">V</code></td>
<td>
<p>(optional) Can provide a starting point for the V matrix.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="MLmatrixt_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments can be passed to <code>optim</code>
if using restrictions on the variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt><code>mean</code></dt><dd><p>the mean matrix</p>
</dd>
<dt><code>U</code></dt><dd><p>the between-row covariance matrix</p>
</dd>
<dt><code>V</code></dt><dd><p>the between-column covariance matrix</p>
</dd>
<dt><code>var</code></dt><dd><p>the scalar variance parameter
(the first entry of the covariances are restricted to unity)</p>
</dd>
<dt><code>nu</code></dt><dd><p>the degrees of freedom parameter</p>
</dd>
<dt><code>iter</code></dt><dd><p>the number of iterations</p>
</dd>
<dt><code>tol</code></dt><dd><p>the squared difference between iterations of
the variance matrices at the time of stopping</p>
</dd>
<dt><code>logLik</code></dt><dd><p>log likelihood of result.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>a convergence flag,
<code>TRUE</code> if converged.</p>
</dd>
<dt><code>call</code></dt><dd><p>The (matched) function call.</p>
</dd>
</dl>



<h3>References</h3>

<pre>Thompson, G Z.  R Maitra, W Q Meeker, A Bastawros (2019),
"Classification with the matrix-variate-t distribution", arXiv
e-prints arXiv:1907.09565 &lt;https://arxiv.org/abs/1907.09565&gt;

Dickey, James M. 1967. “Matricvariate Generalizations of the
Multivariate t Distribution and the Inverted Multivariate t
Distribution.” Ann. Math. Statist. 38 (2): 511–18.
\doi{10.1214/aoms/1177698967}

Liu, Chuanhai, and Donald B. Rubin. 1994. “The ECME Algorithm:
A Simple Extension of EM and ECM with Faster Monotone Convergence.”
Biometrika 81 (4): 633–48.
      \doi{10.2307/2337067}
</pre>
<p>Meng, Xiao-Li, and Donald B. Rubin. 1993. “Maximum Likelihood Estimation
via the ECM Algorithm: A General Framework.” Biometrika 80 (2): 267–78.
doi: <a href="https://doi.org/10.1093/biomet/80.2.267">10.1093/biomet/80.2.267</a></p>
<pre>Rubin, D.B. 1983. “Encyclopedia of Statistical Sciences.” In, 4th ed.,
  272–5. John Wiley.
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixnorm">rmatrixnorm()</a></code>, <code><a href="#topic+rmatrixt">rmatrixt()</a></code>,
<code><a href="#topic+MLmatrixnorm">MLmatrixnorm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180202)
# drawing from a distribution with specified mean and covariance
A &lt;- rmatrixt(
  n = 100, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = TRUE, df = 5
)
# fitting maximum likelihood estimates
results &lt;- MLmatrixt(A, tol = 1e-5, df = 5)
print(results)
</code></pre>

<hr>
<h2 id='predict.matrixlda'>Classify Matrix Variate Observations by Linear Discrimination</h2><span id='topic+predict.matrixlda'></span>

<h3>Description</h3>

<p>Classify matrix variate observations in conjunction with <code>matrixlda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrixlda'
predict(object, newdata, prior = object$prior, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.matrixlda_+3A_object">object</code></td>
<td>
<p>object of class <code>matrixlda</code></p>
</td></tr>
<tr><td><code id="predict.matrixlda_+3A_newdata">newdata</code></td>
<td>
<p>array or list of new observations to be classified.
If newdata is missing, an attempt will be made to retrieve the
data used to fit the <code>matrixlda</code> object.</p>
</td></tr>
<tr><td><code id="predict.matrixlda_+3A_prior">prior</code></td>
<td>
<p>The prior probabilities of the classes, by default the
proportions in the training set or what was set in the call to
<code>matrixlda</code>.</p>
</td></tr>
<tr><td><code id="predict.matrixlda_+3A_...">...</code></td>
<td>
<p>arguments based from or to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code>predict()</code> for
class &quot;<code>matrixlda</code>&quot;. It can be invoked by calling <code>predict(x)</code> for
an object <code>x</code> of the appropriate class.
</p>


<h3>Value</h3>

<p>Returns a list containing
the following components:
</p>

<dl>
<dt><code>class</code></dt><dd><p>The MAP classification (a factor)</p>
</dd>
<dt><code>posterior</code></dt><dd><p>posterior probabilities for the classes</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrixlda">matrixlda()</a></code>, <code><a href="#topic+matrixqda">matrixqda()</a></code>,
and <code><a href="#topic+matrixmixture">matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180221)
# construct two populations of 3x4 random matrices with different means
A &lt;- rmatrixnorm(30, mean = matrix(0, nrow = 3, ncol = 4))
B &lt;- rmatrixnorm(30, mean = matrix(1, nrow = 3, ncol = 4))
C &lt;- array(c(A, B), dim = c(3, 4, 60)) # combine together
groups &lt;- c(rep(1, 30), rep(2, 30)) # define groups
prior &lt;- c(.5, .5) # set prior
D &lt;- matrixlda(C, groups, prior)
predict(D)$posterior[1:10, ]

## S3 method for class 'matrixlda'
</code></pre>

<hr>
<h2 id='predict.matrixqda'>Classify Matrix Variate Observations by Quadratic Discrimination</h2><span id='topic+predict.matrixqda'></span>

<h3>Description</h3>

<p>Classify matrix variate observations in conjunction with <code>matrixqda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrixqda'
predict(object, newdata, prior = object$prior, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.matrixqda_+3A_object">object</code></td>
<td>
<p>object of class <code>matrixqda</code></p>
</td></tr>
<tr><td><code id="predict.matrixqda_+3A_newdata">newdata</code></td>
<td>
<p>array or list of new observations to be classified.
If newdata is missing, an attempt will be made to retrieve the
data used to fit the <code>matrixqda</code> object.</p>
</td></tr>
<tr><td><code id="predict.matrixqda_+3A_prior">prior</code></td>
<td>
<p>The prior probabilities of the classes, by default the
proportions in the training set or what was set in the call to
<code>matrixqda</code>.</p>
</td></tr>
<tr><td><code id="predict.matrixqda_+3A_...">...</code></td>
<td>
<p>arguments based from or to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code>predict()</code> for
class &quot;<code>matrixqda</code>&quot;. It can be invoked by calling <code>predict(x)</code> for
an object <code>x</code> of the appropriate class.
</p>


<h3>Value</h3>

<p>Returns a list containing
the following components:
</p>

<dl>
<dt><code>class</code></dt><dd><p>The MAP classification (a factor)</p>
</dd>
<dt><code>posterior</code></dt><dd><p>posterior probabilities for the classes</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+matrixlda">matrixlda()</a></code>, <code><a href="#topic+matrixqda">matrixqda()</a></code>,
and <code><a href="#topic+matrixmixture">matrixmixture()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(20180221)
# construct two populations of 3x4 random matrices with different means
A &lt;- rmatrixnorm(30, mean = matrix(0, nrow = 3, ncol = 4))
B &lt;- rmatrixnorm(30, mean = matrix(1, nrow = 3, ncol = 4))
C &lt;- array(c(A, B), dim = c(3, 4, 60)) # combine together
groups &lt;- c(rep(1, 30), rep(2, 30)) # define groups
prior &lt;- c(.5, .5) # set prior
D &lt;- matrixqda(C, groups, prior) # fit model
predict(D)$posterior[1:10, ] # predict, show results of first 10
## S3 method for class "matrixqda"
</code></pre>

<hr>
<h2 id='rmatrixinvt'>Distribution functions for matrix variate inverted t distributions</h2><span id='topic+rmatrixinvt'></span><span id='topic+dmatrixinvt'></span>

<h3>Description</h3>

<p>Generate random samples from the inverted matrix
variate t distribution or compute densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixinvt(
  n,
  df,
  mean,
  L = diag(dim(as.matrix(mean))[1]),
  R = diag(dim(as.matrix(mean))[2]),
  U = L %*% t(L),
  V = t(R) %*% R,
  list = FALSE,
  array = NULL
)

dmatrixinvt(
  x,
  df,
  mean = matrix(0, p, n),
  L = diag(p),
  R = diag(n),
  U = L %*% t(L),
  V = t(R) %*% R,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixinvt_+3A_n">n</code></td>
<td>
<p>number of observations for generation</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt;0</code>, may be non-integer),
<code style="white-space: pre;">&#8288;df = 0, Inf&#8288;</code> is allowed and will return a normal distribution.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_mean">mean</code></td>
<td>
<p><code class="reqn">p \times q</code> This is really a 'shift' rather than a
mean, though the expected value will be equal to this if
<code class="reqn">df &gt; 2</code></p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_l">L</code></td>
<td>
<p><code class="reqn">p \times p</code>  matrix specifying relations among the rows.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_r">R</code></td>
<td>
<p><code class="reqn">q \times q</code>  matrix specifying relations among the
columns. By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_u">U</code></td>
<td>
<p><code class="reqn">LL^T</code>  - <code class="reqn">p \times p</code>   positive definite matrix for
rows, computed from <code class="reqn">L</code> if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_v">V</code></td>
<td>
<p><code class="reqn">R^T R</code>  - <code class="reqn">q \times q</code>  positive definite matrix for
columns, computed from <code class="reqn">R</code>  if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_list">list</code></td>
<td>
<p>Defaults to <code>FALSE</code> . If this is <code>TRUE</code> , then the
output will be a list of matrices.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_array">array</code></td>
<td>
<p>If <code class="reqn">n = 1</code>  and this is not specified and <code>list</code>  is
<code>FALSE</code> , the function will return a matrix containing the one
observation. If <code class="reqn">n &gt; 1</code> , should be the opposite of <code>list</code> .
If <code>list</code>  is <code>TRUE</code> , this will be ignored.</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_x">x</code></td>
<td>
<p>quantile for density</p>
</td></tr>
<tr><td><code id="rmatrixinvt_+3A_log">log</code></td>
<td>
<p>logical; in <code>dmatrixt</code>, if <code>TRUE</code>, probabilities
<code>p</code> are given as <code>log(p)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rmatrixinvt</code> returns either a list of <code class="reqn">n</code>
<code class="reqn">p \times q</code>  matrices or
a <code class="reqn">p \times q \times n</code>  array.
</p>
<p><code>dmatrixinvt</code> returns the density at  <code>x</code>.
</p>


<h3>References</h3>

<p>Gupta, Arjun K, and Daya K Nagar. 1999.
Matrix Variate Distributions.
Vol. 104. CRC Press. ISBN:978-1584880462
</p>
<p>Dickey, James M. 1967. “Matricvariate Generalizations of the Multivariate t
Distribution and the Inverted Multivariate t
Distribution.” Ann. Math. Statist. 38 (2): 511–18.
doi: <a href="https://doi.org/10.1214/aoms/1177698967">10.1214/aoms/1177698967</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixnorm">rmatrixnorm()</a></code>, <code><a href="#topic+rmatrixt">rmatrixt()</a></code>,
and <code><a href="stats.html#topic+Distributions">stats::Distributions()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an example of drawing from the distribution and computing the density.
A &lt;- rmatrixinvt(n = 2, df = 10, diag(4))
dmatrixinvt(A[, , 1], df = 10, mean = diag(4))
</code></pre>

<hr>
<h2 id='rmatrixnorm'>Matrix variate Normal distribution functions</h2><span id='topic+rmatrixnorm'></span><span id='topic+dmatrixnorm'></span>

<h3>Description</h3>

<p>Density and random generation for the matrix variate
normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixnorm(
  n,
  mean,
  L = diag(dim(as.matrix(mean))[1]),
  R = diag(dim(as.matrix(mean))[2]),
  U = L %*% t(L),
  V = t(R) %*% R,
  list = FALSE,
  array = NULL,
  force = FALSE
)

dmatrixnorm(
  x,
  mean = matrix(0, p, n),
  L = diag(p),
  R = diag(n),
  U = L %*% t(L),
  V = t(R) %*% R,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixnorm_+3A_n">n</code></td>
<td>
<p>number of observations to generate - must be a positive integer.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_mean">mean</code></td>
<td>
<p><code class="reqn">p \times q</code>  matrix of means</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_l">L</code></td>
<td>
<p><code class="reqn">p \times p</code>  matrix specifying relations
among the rows.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_r">R</code></td>
<td>
<p><code class="reqn">q \times q</code>  matrix specifying relations among the
columns.  By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_u">U</code></td>
<td>
<p><code class="reqn">LL^T</code>  - <code class="reqn">p \times p</code>
positive definite variance-covariance
matrix for rows, computed from <code class="reqn">L</code> if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_v">V</code></td>
<td>
<p><code class="reqn">R^T R</code>  - <code class="reqn">q \times q</code>
positive definite variance-covariance
matrix for columns, computed from <code class="reqn">R</code>  if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_list">list</code></td>
<td>
<p>Defaults to <code>FALSE</code> . If this is <code>TRUE</code> , then the
output will be a list of matrices.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_array">array</code></td>
<td>
<p>If <code class="reqn">n = 1</code>  and this is not specified and <code>list</code>  is
<code>FALSE</code> , the function will return a matrix containing the one
observation. If <code class="reqn">n &gt; 1</code> , should be the opposite of <code>list</code> .
If <code>list</code>  is <code>TRUE</code> , this will be ignored.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_force">force</code></td>
<td>
<p>If TRUE, will take the input of <code>L</code> and/or <code>R</code>
directly - otherwise computes <code>U</code> and <code>V</code> and uses Cholesky
decompositions. Useful for generating degenerate normal distributions.
Will also override concerns about potentially singular matrices
unless they are not, in fact, invertible.</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_x">x</code></td>
<td>
<p>quantile for density</p>
</td></tr>
<tr><td><code id="rmatrixnorm_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rmatrixnorm</code> returns either a list of
<code class="reqn">n</code>  <code class="reqn">p \times q</code>  matrices or
a <code class="reqn">p \times q \times n</code>  array.
</p>
<p><code>dmatrixnorm</code> returns the density at <code>x</code>.
</p>


<h3>References</h3>

<p>Gupta, Arjun K, and Daya K Nagar. 1999.
Matrix Variate Distributions.
Vol. 104. CRC Press. ISBN:978-1584880462
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixt">rmatrixt()</a></code>, <code><a href="#topic+rmatrixinvt">rmatrixinvt()</a></code>,
<code><a href="stats.html#topic+rnorm">rnorm()</a></code> and <code><a href="stats.html#topic+Distributions">stats::Distributions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180202)
# a draw from a matrix variate normal with a certain mean
# and row-wise covariance
rmatrixnorm(
  n = 1, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = FALSE
)
set.seed(20180202)
# another way of specifying this - note the output is equivalent
A &lt;- rmatrixnorm(
  n = 10, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = TRUE
)
A[[1]]
# demonstrating the dmatrixnorm function
dmatrixnorm(A[[1]],
  mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), log = TRUE
)
</code></pre>

<hr>
<h2 id='rmatrixt'>Distribution functions for the matrix variate t distribution.</h2><span id='topic+rmatrixt'></span><span id='topic+dmatrixt'></span>

<h3>Description</h3>

<p>Density and random generation for the matrix variate t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmatrixt(
  n,
  df,
  mean,
  L = diag(dim(as.matrix(mean))[1]),
  R = diag(dim(as.matrix(mean))[2]),
  U = L %*% t(L),
  V = t(R) %*% R,
  list = FALSE,
  array = NULL,
  force = FALSE
)

dmatrixt(
  x,
  df,
  mean = matrix(0, p, n),
  L = diag(p),
  R = diag(n),
  U = L %*% t(L),
  V = t(R) %*% R,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatrixt_+3A_n">n</code></td>
<td>
<p>number of observations for generation</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt;0</code>, may be non-integer),
<code style="white-space: pre;">&#8288;df = 0, Inf&#8288;</code> is allowed and will return a normal distribution.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_mean">mean</code></td>
<td>
<p><code class="reqn">p \times q</code> This is really a 'shift' rather than a
mean, though the expected value will be equal to this if
<code class="reqn">df &gt; 2</code></p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_l">L</code></td>
<td>
<p><code class="reqn">p \times p</code>  matrix specifying relations among the rows.
By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_r">R</code></td>
<td>
<p><code class="reqn">q \times q</code>  matrix specifying relations among the
columns. By default, an identity matrix.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_u">U</code></td>
<td>
<p><code class="reqn">LL^T</code>  - <code class="reqn">p \times p</code>   positive definite matrix for
rows, computed from <code class="reqn">L</code> if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_v">V</code></td>
<td>
<p><code class="reqn">R^T R</code>  - <code class="reqn">q \times q</code>  positive definite matrix for
columns, computed from <code class="reqn">R</code>  if not specified.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_list">list</code></td>
<td>
<p>Defaults to <code>FALSE</code> . If this is <code>TRUE</code> , then the
output will be a list of matrices.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_array">array</code></td>
<td>
<p>If <code class="reqn">n = 1</code>  and this is not specified and <code>list</code>  is
<code>FALSE</code> , the function will return a matrix containing the one
observation. If <code class="reqn">n &gt; 1</code> , should be the opposite of <code>list</code> .
If <code>list</code>  is <code>TRUE</code> , this will be ignored.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_force">force</code></td>
<td>
<p>In <code>rmatrix</code>: if <code>TRUE</code>, will take the input of
<code>R</code> directly - otherwise uses <code>V</code> and uses Cholesky
decompositions. Useful for generating degenerate t-distributions.
Will also override concerns about potentially singular matrices
unless they are not, in fact, invertible.</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_x">x</code></td>
<td>
<p>quantile for density</p>
</td></tr>
<tr><td><code id="rmatrixt_+3A_log">log</code></td>
<td>
<p>logical; in <code>dmatrixt</code>, if <code>TRUE</code>, probabilities
<code>p</code> are given as <code>log(p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code class="reqn">t</code>-distribution is parameterized slightly
differently from the univariate and multivariate <code class="reqn">t</code>-distributions
</p>

<ul>
<li><p> the variance is scaled by a factor of <code>1/df</code>.
In this parameterization, the variance for a <code class="reqn">1 \times 1</code> matrix
variate <code class="reqn">t</code>-distributed random variable with identity variance matrices
is <code class="reqn">1/(df-2)</code> instead of <code class="reqn">df/(df-2)</code>. A Central Limit Theorem
for the matrix variate <code class="reqn">T</code> is then that as <code>df</code> goes to
infinity, <code class="reqn">MVT(0, df, I_p, df*I_q)</code> converges to
<code class="reqn">MVN(0,I_p,I_q)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>rmatrixt</code> returns either a list of <code class="reqn">n</code>
<code class="reqn">p \times q</code>  matrices or a
<code class="reqn">p \times q \times n</code>
array.
</p>
<p><code>dmatrixt</code> returns the density at <code>x</code>.
</p>


<h3>References</h3>

<p>Gupta, Arjun K, and Daya K Nagar. 1999.
Matrix Variate Distributions.
Vol. 104. CRC Press. ISBN:978-1584880462
</p>
<p>Dickey, James M. 1967. “Matricvariate Generalizations of the Multivariate t
Distribution and the Inverted Multivariate t
Distribution.” Ann. Math. Statist. 38 (2): 511–18.
doi: <a href="https://doi.org/10.1214/aoms/1177698967">10.1214/aoms/1177698967</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmatrixnorm">rmatrixnorm()</a></code>,
<code><a href="#topic+rmatrixinvt">rmatrixinvt()</a></code>,<code><a href="stats.html#topic+rt">rt()</a></code> and
<code><a href="stats.html#topic+Distributions">stats::Distributions()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20180202)
# random matrix with df = 10 and the given mean and L matrix
rmatrixt(
  n = 1, df = 10, mean = matrix(c(100, 0, -100, 0, 25, -1000), nrow = 2),
  L = matrix(c(2, 1, 0, .1), nrow = 2), list = FALSE
)
# comparing 1-D distribution of t to matrix
summary(rt(n = 100, df = 10))
summary(rmatrixt(n = 100, df = 10, matrix(0)))
# demonstrating equivalence of 1x1 matrix t to usual t
set.seed(20180204)
x &lt;- rmatrixt(n = 1, mean = matrix(0), df = 1)
dt(x, 1)
dmatrixt(x, df = 1)
</code></pre>

<hr>
<h2 id='vardet'>Determinant selector for chosen covariance matrix.</h2><span id='topic+vardet'></span>

<h3>Description</h3>

<p>Determinant selector for chosen covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vardet(n, rho, deriv, variance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vardet_+3A_n">n</code></td>
<td>
<p>dimensions</p>
</td></tr>
<tr><td><code id="vardet_+3A_rho">rho</code></td>
<td>
<p>off-diagonal parameter</p>
</td></tr>
<tr><td><code id="vardet_+3A_deriv">deriv</code></td>
<td>
<p>logical whether to return the determinant or the derivative of
the log of the determinant</p>
</td></tr>
<tr><td><code id="vardet_+3A_variance">variance</code></td>
<td>
<p>variance structure - AR(1) or CS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Determinant or derivative of log-inverse for the
specified matrix structure.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
