<!DOCTYPE html><html><head><title>Help for package xegaSelectGene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaSelectGene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ContinuousScaleFitness'><p>Dispersion Ratio Based Fitness Scaling.</p></a></li>
<li><a href='#Counted'><p>Transformation into a counted function</p></a></li>
<li><a href='#DeJongF4Factory'><p>Factory for function F4 (30-dimensional quartic with noise)</p></a></li>
<li><a href='#DelayedPFactory'><p>Factory for a 2-dimensional quadratic parabola with delayed execution.</p></a></li>
<li><a href='#DispersionMeasureFactory'><p>Configure dispersion measure.</p></a></li>
<li><a href='#DispersionRatio'><p>Dispersion Ratio</p></a></li>
<li><a href='#envXOR'><p>The problem environment <code>envXOR</code> for programming the XOR function</p>
either by grammar-based genetic programming or grammatical evolution.</a></li>
<li><a href='#EvalGene'><p>Evaluate a gene</p></a></li>
<li><a href='#EvalGeneDet'><p>Evaluates a gene in a deterministic problem environment.</p></a></li>
<li><a href='#EvalGeneFactory'><p>Configure the evaluation function of a genetic algorithm.</p></a></li>
<li><a href='#EvalGeneR'><p>Evaluates a repaired gene in a problem environment.</p></a></li>
<li><a href='#EvalGeneStoch'><p>Evaluates a gene in a stochastic problem environment.</p></a></li>
<li><a href='#EvalGeneU'><p>Evaluates a gene in a problem environment</p></a></li>
<li><a href='#lau15'><p>The problem environment <code>lau15</code> for a traveling salesman problem.</p></a></li>
<li><a href='#newCounter'><p>Counter</p></a></li>
<li><a href='#newEnvXOR'><p>Generates a problem environment for the XOR problem.</p></a></li>
<li><a href='#NewlFevalGenes'><p>Generate local functions and objects</p></a></li>
<li><a href='#NewlFselectGenes'><p>Generate local functions and objects.</p></a></li>
<li><a href='#newTimer'><p>Timer for R code chunks.</p></a></li>
<li><a href='#newTSP'><p>Generate a TSP problem environment</p></a></li>
<li><a href='#Parabola2DEarlyFactory'><p>Factory for a 2-dimensional quadratic parabola with early termination check.</p></a></li>
<li><a href='#Parabola2DErrFactory'><p>Factory for a randomly failing 2-dimensional quadratic parabola.</p></a></li>
<li><a href='#Parabola2DFactory'><p>Factory for a 2-dimensional quadratic parabola.</p></a></li>
<li><a href='#parm'><p>Factory for constants</p></a></li>
<li><a href='#predictSelectTime'><p>Predict the time use of a selection method for a popsize.</p></a></li>
<li><a href='#runOneBenchmark'><p>Script for testing a single selection functions</p></a></li>
<li><a href='#runSelectBenchmarks'><p>Script for testing all selection functions</p></a></li>
<li><a href='#ScaleFitness'><p>Scaling Fitness</p></a></li>
<li><a href='#ScalingFactory'><p>Scaling Factory</p></a></li>
<li><a href='#ScalingFitness'><p>Abstract interface for ScaleFitness.</p></a></li>
<li><a href='#selectBenchmark'><p>Benchmark and stress test of selection functions.</p></a></li>
<li><a href='#SelectDuel'><p>Deterministic duel.</p></a></li>
<li><a href='#SelectGeneFactory'><p>Configure the selection function of a genetic algorithm.</p></a></li>
<li><a href='#SelectLinearRankTSR'><p>Linear rank selection.</p></a></li>
<li><a href='#SelectLRSelective'><p>Linear rank selection with selective pressure.</p></a></li>
<li><a href='#SelectPropFit'><p>Selection proportional to fitness <code class="reqn">O(n^2)</code>.</p></a></li>
<li><a href='#SelectPropFitDiff'><p>Selection proportional to fitness differences.</p></a></li>
<li><a href='#SelectPropFitDiffM'><p>Selection proportional to fitness differences.</p></a></li>
<li><a href='#SelectPropFitDiffOnln'><p>Selection proportional to fitness differences O(n ln(n)).</p></a></li>
<li><a href='#SelectPropFitM'><p>Selection proportional to fitness (vector/matrix).</p></a></li>
<li><a href='#SelectPropFitOnln'><p>Selection proportional to fitness O(n ln(n)).</p></a></li>
<li><a href='#SelectSTournament'><p>Stochastic tournament selection.</p></a></li>
<li><a href='#SelectSUS'><p>Stochastic universal sampling.</p></a></li>
<li><a href='#SelectTournament'><p>Tournament selection.</p></a></li>
<li><a href='#SelectUniform'><p>Selection with uniform probability.</p></a></li>
<li><a href='#SelectUniformP'><p>Selection with uniform probability without replacement.</p></a></li>
<li><a href='#STournament'><p>Stochastic tournament of size <code>k</code>.</p></a></li>
<li><a href='#testEvalGeneStoch'><p>Test of incremental mean, variance, and standard deviation.</p></a></li>
<li><a href='#testSelectGene'><p>Test a gene selection function</p></a></li>
<li><a href='#ThresholdScaleFitness'><p>Dispersion Ratio Based Fitness Scaling.</p></a></li>
<li><a href='#Timed'><p>Transformation into a timed function</p></a></li>
<li><a href='#Tournament'><p>Deterministic tournament of size <code>k</code>.</p></a></li>
<li><a href='#TransformSelect'><p>Convert a selection function into a continuation.</p></a></li>
<li><a href='#xegaSelectGene'><p>Package xegaSelectGene.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Selection of Genes and Gene Representation Independent Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>This collection of gene representation-independent 
             mechanisms for evolutionary and genetic algorithms contains
             four groups of functions:
             First, functions for selecting a gene 
             in a population of genes according to its fitness value
             and for adaptive scaling of the fitness values as well as for 
             performance optimization and measurement offer several 
             variants for implementing the survival of the fittest.
             Second, evaluation functions for 
             deterministic functions avoid recomputation.
             Evaluation of stochastic functions incrementally improve 
             the estimation of the mean and variance of fitness values 
             at almost no additional cost. Evaluation functions
             for gene repair handle error-correcting decoders.
             Third, timing and counting functions for profiling the
             algorithm pipeline are provided to assess bottlenecks in 
             the algorithms.
             Fourth, a small collection of problem environments
             for function optimization, combinatorial optimization, and
             grammar-based genetic programming and grammatical evolution
             is provided for tutorial examples.
             The methods in the package are described by the following
             references:
             Baker, James E. (1987, ISBN:978-08058-0158-8), 
             De Jong, Kenneth A. (1975) 
             <a href="https://deepblue.lib.umich.edu/handle/2027.42/4507">https://deepblue.lib.umich.edu/handle/2027.42/4507</a>,
             Geyer-Schulz, Andreas (1997, ISBN:978-3-7908-0830-X),
             Grefenstette, John J. (1987, ISBN:978-08058-0158-8),
             Grefenstette, John J. and Baker, James E. 
             (1989, ISBN:1-55860-066-3),
             Holland, John (1975, ISBN:0-472-08460-7),
             Lau, H. T. (1986) &lt;<a href="https://doi.org/10.1007%2F978-3-642-61649-5">doi:10.1007/978-3-642-61649-5</a>&gt;,
             Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005) 
             &lt;<a href="https://doi.org/10.1007%2F3-540-31306-0">doi:10.1007/3-540-31306-0</a>&gt;,  
             Reynolds, J. C. (1993) &lt;<a href="https://doi.org/10.1007%2FBF01019459">doi:10.1007/BF01019459</a>&gt;,
             Schaffer, J. David (1989, ISBN:1-55860-066-3),
             Wenstop, Fred (1980) &lt;<a href="https://doi.org/10.1016%2F0165-0114%2880%2990031-7">doi:10.1016/0165-0114(80)90031-7</a>&gt;,
             Whitley, Darrell (1989, ISBN:1-55860-066-3),
             Wickham, Hadley (2019, ISBN:978-815384571).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaSelectGene&amp;gt;">https://github.com/ageyerschulz/xegaSelectGene&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'evalGene.R' 'scaling.R' 'selectGene.R'
'selectGeneBenchmark.R' 'timer.R' 'DeJongF4.R' 'Parabola2D.R'
'newXOR.R' 'newTSP.R' 'xegaSelectGene-package.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 10:49:39 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ContinuousScaleFitness'>Dispersion Ratio Based Fitness Scaling.</h2><span id='topic+ContinuousScaleFitness'></span>

<h3>Description</h3>

<p>Dispersion Ratio Based Fitness Scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContinuousScaleFitness(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContinuousScaleFitness_+3A_fit">fit</code></td>
<td>
<p>A fitness vector.</p>
</td></tr>
<tr><td><code id="ContinuousScaleFitness_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled fitness vector.
</p>


<h3>See Also</h3>

<p>Other Scaling: 
<code><a href="#topic+DispersionRatio">DispersionRatio</a>()</code>,
<code><a href="#topic+ScaleFitness">ScaleFitness</a>()</code>,
<code><a href="#topic+ScalingFitness">ScalingFitness</a>()</code>,
<code><a href="#topic+ThresholdScaleFitness">ThresholdScaleFitness</a>()</code>
</p>
<p>Other Adaptive Parameter: 
<code><a href="#topic+ThresholdScaleFitness">ThresholdScaleFitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lF&lt;-list()
lF$Offset&lt;-parm(0.0001)
lF$RDMWeight&lt;-parm(2)
lF$RDM&lt;-parm(1.2)
fit&lt;-sample(10, 20, replace=TRUE)
fit
ContinuousScaleFitness(fit, lF)
</code></pre>

<hr>
<h2 id='Counted'>Transformation into a counted function</h2><span id='topic+Counted'></span>

<h3>Description</h3>

<p><code>Counted</code> takes two functions as arguments: 
The function whose call frequency 
should be measured and a counter object created by <code>newCounter()</code>.
It returns a counted function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Counted(FUN, counter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Counted_+3A_fun">FUN</code></td>
<td>
<p>A function whose run time should be measured.</p>
</td></tr>
<tr><td><code id="Counted_+3A_counter">counter</code></td>
<td>
<p>A counter generated by <code>newCounter()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A counted function.
</p>


<h3>See Also</h3>

<p>Other Performance Measurement: 
<code><a href="#topic+Timed">Timed</a>()</code>,
<code><a href="#topic+newCounter">newCounter</a>()</code>,
<code><a href="#topic+newTimer">newTimer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    test&lt;-function(v) {sum(v)} 
    testCounter&lt;-newCounter()
    testCounted&lt;-Counted(test, testCounter)
    testCounter("Show")
    testCounted(sample(10,10)); testCounted(sample(10,10))
    testCounter("Show")
</code></pre>

<hr>
<h2 id='DeJongF4Factory'>Factory for function F4 (30-dimensional quartic with noise)</h2><span id='topic+DeJongF4Factory'></span>

<h3>Description</h3>

<p>This function factory sets up the problem environment
for De Jong's function F4.
F4 is a 30-dimensional quartic function with Gaussian noise.
It is a continuous, convex, unimodal, high-dimensional quartic function
with Gaussian noise. For validation,  <code class="reqn">\epsilon = 3*\sigma</code> 
will work most of the time.
Note: There exist <code class="reqn">2^{30}</code> maxima (without noise)!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeJongF4Factory()
</code></pre>


<h3>Value</h3>

<p>A problem environment represented as a list of functions:
</p>

<ul>
<li> <p><code>$name()</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the number of bits of 
each parameter of the function.
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of the gene.
</p>
</li>
<li> <p><code>$lb()</code>: The vector of lower bounds of the parameters.
</p>
</li>
<li> <p><code>$ub()</code>: The vector of upper bounds of the parameters.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>): The fitness function. 
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li> <p><code>$describe()</code>: Print a description of the problem environment to the console.
</p>
</li>
<li> <p><code>$solution()</code>: The solution structure. A named list with <code>minimum</code>, <code>maximum</code> and
2 lists of equivalent solutions: <code>minpoints</code>, <code>maxpoints</code>. 
</p>
</li></ul>



<h3>References</h3>

<p>De Jong, Kenneth A. (1975):
<em>An Analysis of the Behavior of a Class of Genetic Adaptive Systems.</em>
PhD thesis, Michigan, Ann Arbor, pp. 203-206.
&lt;https://deepblue.lib.umich.edu/handle/2027.42/4507&gt;
</p>


<h3>See Also</h3>

<p>Other Problem Environments: 
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DeJongF4&lt;-DeJongF4Factory()
DeJongF4$name()
DeJongF4$bitlength()
DeJongF4$genelength()
DeJongF4$lb()
DeJongF4$ub()
DeJongF4$f(c(2.01, -1.05, 4.95, -4.3, -3.0))
DeJongF4$f(c(2.01, -1.05, 4.95, -4.3, -3.0))
DeJongF4$describe()
DeJongF4$solution()
</code></pre>

<hr>
<h2 id='DelayedPFactory'>Factory for a 2-dimensional quadratic parabola with delayed execution.</h2><span id='topic+DelayedPFactory'></span>

<h3>Description</h3>

<p>This list of functions sets up the problem environment
for a 2-dimensional
quadratic parabola with a delayed execution of 0.1s.
This function aims to test strategies
of distributed/parallel execution of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DelayedPFactory()
</code></pre>


<h3>Details</h3>

<p>The factory contains examples of all functions 
which form the interface of a problem environment to
the simple genetic algorithm with binary-coded genes
of package <code>xega</code>.
</p>


<h3>Value</h3>

<p>A problem environment represented as a list of functions:
</p>

<ul>
<li> <p><code>$name()</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the number of bits of 
each parameter of the function.
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of the gene.
</p>
</li>
<li> <p><code>$lb()</code>: The vector of lower bounds of the parameters.
</p>
</li>
<li> <p><code>$ub()</code>: The vector of upper bounds of the parameters.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>): The fitness function. 
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li> <p><code>$describe()</code>: Print a description of the problem environment to the console.
</p>
</li>
<li> <p><code>$solution()</code>: The solution structure. A named list with <code>minimum</code>, <code>maximum</code> and
2 lists of equivalent solutions: <code>minpoints</code>, <code>maxpoints</code>. 
</p>
</li></ul>



<h3>See Also</h3>

<p>Parabola2D
</p>
<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DelayedP&lt;-DelayedPFactory()
DelayedP$f(c(2.2, 1.0))
</code></pre>

<hr>
<h2 id='DispersionMeasureFactory'>Configure dispersion measure.</h2><span id='topic+DispersionMeasureFactory'></span>

<h3>Description</h3>

<p><code>DispersionMeasureFactory</code> returns a function 
for the dispersion measure as specified by a label.
If an invalid label is 
specified, the configuration fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispersionMeasureFactory(method = "var")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispersionMeasureFactory_+3A_method">method</code></td>
<td>
<p>A dispersion measure.
</p>

<ul>
<li><p>  &quot;var&quot;: Variance (Default).
</p>
</li>
<li><p> &quot;std&quot;: Standard deviation.
</p>
</li>
<li><p> &quot;mad&quot;: Median absolute deviation (<code>mad(vec, constant=1)</code>).
</p>
</li>
<li><p> &quot;cv&quot;: Coefficient of variation&quot;. 
</p>
</li>
<li><p> &quot;range&quot;: Range.
</p>
</li>
<li><p> &quot;iqr&quot;: Inter quartile range 
(approximated by the lower and upper hinge of <code>fivenum</code>). 
</p>
</li></ul>

<p>If an invalid label is 
specified, the configuration fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which computes the dispersion measure from the vector of 
population statistics produced by <code>xegaObservePopulation</code>
of package <code>xegaPopulation</code>.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+EvalGeneFactory">EvalGeneFactory</a>()</code>,
<code><a href="#topic+ScalingFactory">ScalingFactory</a>()</code>,
<code><a href="#topic+SelectGeneFactory">SelectGeneFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
fit&lt;-sample(30, 20, replace=TRUE)
populationStats&lt;-c(mean(fit), fivenum(fit), var(fit), mad(fit, constant=1))
dm&lt;-DispersionMeasureFactory("var")
dm(populationStats)
dm&lt;-DispersionMeasureFactory("range")
dm(populationStats)
</code></pre>

<hr>
<h2 id='DispersionRatio'>Dispersion Ratio</h2><span id='topic+DispersionRatio'></span>

<h3>Description</h3>

<p>The dispersion ratio is computed as 
the ratio <code>DM(t)/DM(k)</code>
where <code>DM(t)</code> is the dispersion measure of period t and 
<code>DM(k)</code> the dispersion measure of period <code>max(1, (t-k))</code>.
<code>k</code> is specified by <code>lF$ScalingDelay</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispersionRatio(popStat, DM, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispersionRatio_+3A_popstat">popStat</code></td>
<td>
<p>Population statistics.</p>
</td></tr>
<tr><td><code id="DispersionRatio_+3A_dm">DM</code></td>
<td>
<p>Dispersion function.</p>
</td></tr>
<tr><td><code id="DispersionRatio_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dispersion ratio may take unreasonably high and low values
leading to numerical underflow or overflow 
of fitness values. Therefore,
we use hard thresholding to force 
the dispersion ratio into the interval 
<code>[lF$DRmin(), lF$DRmax()]</code>.
The default interval is <code>[0.5, 2.0]</code>.
</p>


<h3>Value</h3>

<p>Dispersion ratio.
</p>


<h3>See Also</h3>

<p>Other Scaling: 
<code><a href="#topic+ContinuousScaleFitness">ContinuousScaleFitness</a>()</code>,
<code><a href="#topic+ScaleFitness">ScaleFitness</a>()</code>,
<code><a href="#topic+ScalingFitness">ScalingFitness</a>()</code>,
<code><a href="#topic+ThresholdScaleFitness">ThresholdScaleFitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-matrix(0, nrow=3, ncol=8)
p[1,]&lt;-c(14.1,  0.283,  5.53, 14.0, 19.4, 38.1, 90.2, 6.54)
p[2,]&lt;-c(20.7,  0.794, 14.63, 19.0, 26.5, 38.8, 71.4, 5.27)
p[3,]&lt;-c(24.0,  6.007, 16.89, 24.1, 29.2, 38.8, 73.4, 6.50)
F&lt;-list()
F$ScalingDelay&lt;-function() {1}
F$DRmax&lt;-function() {2.0}
F$DRmin&lt;-function() {0.5}
dm&lt;-DispersionMeasureFactory("var")
DispersionRatio(p, dm, F)
F$ScalingDelay&lt;-function() {2}
DispersionRatio(p, dm, F)
</code></pre>

<hr>
<h2 id='envXOR'>The problem environment <code>envXOR</code> for programming the XOR function
either by grammar-based genetic programming or grammatical evolution.</h2><span id='topic+envXOR'></span>

<h3>Description</h3>

<p>The problem environment <code>envXOR</code> is a list with the following elements:
</p>

<ul>
<li> <p><code>envXOR$name</code>: 
<code>"envXOR"</code>, the name of the problem environment.
</p>
</li>
<li> <p><code>envXOR$buildtest(expr)</code>: 
The function which builds the environment 
for evaluating the expression with 
a binding of the variables to the parameters.
</p>
</li>
<li> <p><code>envXOR$TestCases</code>: The truth table of the XOR function.
</p>
</li>
<li> <p><code>envXOR$f(expr, gene=NULL, lF=NULL)</code>: The fitness function.
<code>expr</code> is the string with the 
logical expression to be evaluated. 
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>envXOR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>See Also</h3>

<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>

<hr>
<h2 id='EvalGene'>Evaluate a gene</h2><span id='topic+EvalGene'></span>

<h3>Description</h3>

<p><code>EvalGene</code> is the abstract function which evaluates 
a gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGene_+3A_gene">gene</code></td>
<td>
<p>A gene (representation independent).</p>
</td></tr>
<tr><td><code id="EvalGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration (a function factory provided by 
the <code>xegaX</code> package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For minimization problems, the fitness value 
must be multiplied by -1. The constant function 
<code>lF$Max()</code> returns 1 for a maximization and 
-1 for a minimization problem.
</p>


<h3>Value</h3>

<p>A gene.
</p>


<h3>See Also</h3>

<p>Other Evaluation Functions: 
<code><a href="#topic+EvalGeneDet">EvalGeneDet</a>()</code>,
<code><a href="#topic+EvalGeneR">EvalGeneR</a>()</code>,
<code><a href="#topic+EvalGeneStoch">EvalGeneStoch</a>()</code>,
<code><a href="#topic+EvalGeneU">EvalGeneU</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DeJongF4&lt;-DeJongF4Factory()
lF&lt;-NewlFevalGenes(DeJongF4)
EvalGene&lt;-EvalGeneFactory()
g1&lt;-list(evaluated=FALSE, fit=0, gene1=c(1.0, -1.5))
g1
g2&lt;-EvalGene(g1, lF)
g2
</code></pre>

<hr>
<h2 id='EvalGeneDet'>Evaluates a gene in a deterministic problem environment.</h2><span id='topic+EvalGeneDet'></span>

<h3>Description</h3>

<p><code>EvalGeneDet</code> evaluates a gene in
a problem environment if it has not been evaluated yet.
The repeated evaluations of a gene are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGeneDet(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGeneDet_+3A_gene">gene</code></td>
<td>
<p>A gene.</p>
</td></tr>
<tr><td><code id="EvalGeneDet_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the evaluation of the fitness function of the 
problem environment fails, we catch the error and 
return <code>NA</code>.
</p>


<h3>Value</h3>

<p>A gene (with <code>$evaluated==TRUE</code>).
</p>


<h3>See Also</h3>

<p>Other Evaluation Functions: 
<code><a href="#topic+EvalGeneR">EvalGeneR</a>()</code>,
<code><a href="#topic+EvalGeneStoch">EvalGeneStoch</a>()</code>,
<code><a href="#topic+EvalGeneU">EvalGeneU</a>()</code>,
<code><a href="#topic+EvalGene">EvalGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DFactory()
lF&lt;-NewlFevalGenes(Parabola2D)
g1&lt;-list(evaluated=FALSE, fit=0, gene1=c(1.0, -1.5))
g2&lt;-list(evaluated=FALSE, fit=0, gene1=c(0.0, 0.0))
g1a&lt;-EvalGeneDet(g1, lF)
EvalGeneDet(g1a, lF)
g2a&lt;-EvalGeneDet(g2, lF)
EvalGeneDet(g2a, lF)
</code></pre>

<hr>
<h2 id='EvalGeneFactory'>Configure the evaluation function of a genetic algorithm.</h2><span id='topic+EvalGeneFactory'></span>

<h3>Description</h3>

<p><code>EvalGeneFactory</code> implements the selection 
of one of the evaluation functions for a gene 
in this package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGeneFactory(method = "EvalGeneU")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGeneFactory_+3A_method">method</code></td>
<td>
<p>Available methods are: 
</p>

<ul>
<li><p> &quot;EvalGeneU&quot;: Evaluate gene (Default).
Function <code>EvalGeneU</code>.
</p>
</li>
<li><p> &quot;EvalGeneR&quot;: If the gene has been repaired by a decoder, 
the gene is replaced by the repaired gene.
Function <code>EvalGeneR</code>.
</p>
</li>
<li><p> &quot;Deterministic&quot;: A gene which has been evaluated is 
not reevaluated. 
Function <code>EvalGeneDet</code>.
</p>
</li>
<li><p> &quot;Stochastic&quot;: The fitness mean and 
the fitness variance
are incrementally updated.
Genes remaining in the population over several
generations, the fitness mean converges to the 
expected mean.
Function <code>EvalGeneStoch</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An evaluation function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+DispersionMeasureFactory">DispersionMeasureFactory</a>()</code>,
<code><a href="#topic+ScalingFactory">ScalingFactory</a>()</code>,
<code><a href="#topic+SelectGeneFactory">SelectGeneFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
DeJongF4&lt;-DeJongF4Factory()
lF&lt;-NewlFevalGenes(DeJongF4)
EvalGene&lt;-EvalGeneFactory("EvalGeneU")
g1&lt;-list(evaluated=FALSE, evalFail=FALSE, fit=0, gene1=c(1.0, -1.5))
g1
g2&lt;-EvalGene(g1, lF)
g2
EvalGene&lt;-EvalGeneFactory("Deterministic")
g3&lt;-EvalGene(g2, lF)
g3
set.seed(5)
EvalGene&lt;-EvalGeneFactory("Stochastic")
g1&lt;-list(evaluated=FALSE, evalFail=FALSE, fit=0, gene1=c(1.0, -1.5))
g1
g2&lt;-EvalGene(g1, lF)
g2
g3&lt;-EvalGene(g2, lF)
g3
</code></pre>

<hr>
<h2 id='EvalGeneR'>Evaluates a repaired gene in a problem environment.</h2><span id='topic+EvalGeneR'></span>

<h3>Description</h3>

<p><code>EvalGeneR</code> evaluates a repaired gene in
a problem environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGeneR(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGeneR_+3A_gene">gene</code></td>
<td>
<p>A gene.</p>
</td></tr>
<tr><td><code id="EvalGeneR_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the decoder repairs a gene, the repaired gene 
must replace the original gene.
</p>


<h3>Value</h3>

<p>A gene (with <code>$evaluated==TRUE</code>).
</p>


<h3>See Also</h3>

<p>EvalGeneU
</p>
<p>Other Evaluation Functions: 
<code><a href="#topic+EvalGeneDet">EvalGeneDet</a>()</code>,
<code><a href="#topic+EvalGeneStoch">EvalGeneStoch</a>()</code>,
<code><a href="#topic+EvalGeneU">EvalGeneU</a>()</code>,
<code><a href="#topic+EvalGene">EvalGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DFactory()
lF&lt;-NewlFevalGenes(Parabola2D)
g1&lt;-list(evaluated=FALSE, fit=0, gene1=c(1.0, -1.5, 3.37))
g2&lt;-list(evaluated=FALSE, fit=0, gene1=c(0.0, 0.0, 0.0))
EvalGeneR(g1, lF)
EvalGeneR(g2, lF)
</code></pre>

<hr>
<h2 id='EvalGeneStoch'>Evaluates a gene in a stochastic problem environment.</h2><span id='topic+EvalGeneStoch'></span>

<h3>Description</h3>

<p><code>EvalGeneStoch</code> evaluates a gene in
a stochastic problem environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGeneStoch(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGeneStoch_+3A_gene">gene</code></td>
<td>
<p>A gene.</p>
</td></tr>
<tr><td><code id="EvalGeneStoch_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a stochastic problem environment, the expected fitness
is maximized. The computation of the expectation is 
done by incrementally updating the mean.
For this, need the number of evaluations of the gene 
(<code>$obs</code> of the gene).
In addition, we compute the incremental variance 
of the expected fitness 
stored in <code>$var</code>.  
The standard deviation is then <code>gene$var/gene$obs</code>.
</p>
<p>If the evaluation of the fitness function of the 
problem environment fails, we catch the error and 
return <code>NA</code> for the first evaluation of the gene.
If the gene has been evaluated, we return the old gene.
</p>


<h3>Value</h3>

<p>A gene with the elements
</p>

<ul>
<li>  <p><code>$evaluated</code>: Boolean.
</p>
</li>
<li>  <p><code>$evalFail</code>:  Boolean. 
</p>
</li>
<li>  <p><code>$fit</code>:       Mean fitness of gene. 
</p>
</li>
<li>  <p><code>$gene1</code>:     Gene.  
</p>
</li>
<li>  <p><code>$obs</code>:       Number of evaluations of gene.
</p>
</li>
<li>  <p><code>$var</code>:       Variance of fitness.  
</p>
</li>
<li>  <p><code>$sigma</code>:     Standard deviation of fitness.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Evaluation Functions: 
<code><a href="#topic+EvalGeneDet">EvalGeneDet</a>()</code>,
<code><a href="#topic+EvalGeneR">EvalGeneR</a>()</code>,
<code><a href="#topic+EvalGeneU">EvalGeneU</a>()</code>,
<code><a href="#topic+EvalGene">EvalGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DeJongF4&lt;-DeJongF4Factory()
lF&lt;-NewlFevalGenes(DeJongF4)
g1&lt;-list(evaluated=FALSE, evalFail=FALSE, fit=0, gene1=c(1.0, -1.5))
g1
g2&lt;-EvalGeneStoch(g1, lF)
g2
g3&lt;-EvalGeneStoch(g2, lF)
g3
g4&lt;-EvalGeneStoch(g3, lF)
g4
g5&lt;-EvalGeneStoch(g4, lF)
g5
</code></pre>

<hr>
<h2 id='EvalGeneU'>Evaluates a gene in a problem environment</h2><span id='topic+EvalGeneU'></span>

<h3>Description</h3>

<p><code>EvalGeneU</code> evaluates a gene in
a problem environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalGeneU(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvalGeneU_+3A_gene">gene</code></td>
<td>
<p>A gene.</p>
</td></tr>
<tr><td><code id="EvalGeneU_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the evaluation of the fitness function of the 
problem environment fails, the following 
strategy is used: 
We catch the error
and print it, ignore it: 
</p>
<p>The error handler returns <code>NA</code>.
</p>
<p>We check for the error and update the gene:
</p>

<ul>
<li> <p><code>$evaluated</code>  TRUE.
</p>
</li>
<li> <p><code>$evalFail</code>   TRUE.
</p>
</li>
<li> <p><code>$fit</code> is set to the minimum fitness in the 
population.
</p>
</li></ul>

<p>The boolean function <code>lF$ReportEvalErrors</code> controls
the output of error messages for evaluation failures. 
Rationale: In grammatical evolution, the standard approach 
ignores attempts the evaluate incomplete programs.
</p>


<h3>Value</h3>

<p>A gene (with <code>$evaluated==TRUE</code>).
</p>


<h3>Future improvement</h3>

<p>Provide configurable error handlers.
Rationale: Make debugging for new problem environments easier.
Catch communication problems in distributed/parallel 
environments.
</p>


<h3>See Also</h3>

<p>Other Evaluation Functions: 
<code><a href="#topic+EvalGeneDet">EvalGeneDet</a>()</code>,
<code><a href="#topic+EvalGeneR">EvalGeneR</a>()</code>,
<code><a href="#topic+EvalGeneStoch">EvalGeneStoch</a>()</code>,
<code><a href="#topic+EvalGene">EvalGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DFactory()
lF&lt;-NewlFevalGenes(Parabola2D)
g1&lt;-list(evaluated=FALSE, fit=0, gene1=c(1.0, -1.5, 3.37))
g2&lt;-list(evaluated=FALSE, fit=0, gene1=c(0.0, 0.0, 0.0))
EvalGeneU(g1, lF)
EvalGeneU(g2, lF)
</code></pre>

<hr>
<h2 id='lau15'>The problem environment <code>lau15</code> for a traveling salesman problem.</h2><span id='topic+lau15'></span>

<h3>Description</h3>

<p>15 abstract cities for which a traveling salesman solution is sought.
Solution: A path with a length of 291.
</p>
<p>The problem environment <code>lau15</code> is a list with the following functions: 
</p>

<ol>
<li> <p><code>lau15$name()</code>:  <code>"lau15"</code>, the name of the TSP  
problem environment.
</p>
</li>
<li> <p><code>lau15$genelength()</code>: 15, the number of cities on the round trip.
</p>
</li>
<li> <p><code>lau15$dist()</code>: The distance matrix of the problem.
</p>
</li>
<li> <p><code>lau15$cities()</code>: A list of city names or the vector 
<code>1:lau15$genelength()</code>.
</p>
</li>
<li> <p><code>lau15$f (permutation, gene = 0, lF = 0, tour = TRUE)</code>: 
The fitness function. Computes the roundtrip 
for permutation of cities.
</p>
</li>
<li> <p><code>lau15$solution()</code>: 291, the known optimal solution of lau15.
</p>
</li>
<li> <p><code>lau15$path()</code>: The permutation for the optimal roundtrip.
</p>
</li>
<li> <p><code>lau15$show(p)</code>: Prints the roundtrip <code>p</code>.
</p>
</li>
<li> <p><code>lau15$greedy(startposition, k)</code>: Computes a path of length
<code>k</code> starting at <code>startposition</code> 
by choosing the nearest city.
</p>
</li>
<li> <p><code>lau15$kBestGreedy(k, tour=TRUE)</code>:
Computes the best greedy path/tour with 
k cities. 
</p>
</li>
<li> <p><code>lau15$rnd2Opt(permutation, maxtries=5)</code>:
Tries to find a better permutation by 
at most 5 random 2-opt heuristics.
</p>
</li>
<li> <p><code>lau15$LinKernighan(permutation, maxtries=5)</code>:
A randomized Lin-Kernigan heuristic implemented 
as a sequence of randomized 2-opt moves.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>lau15
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>References</h3>

<p>Lau, H. T. (1986):
<em>Combinatorial Heuristic Algorithms in FORTRAN</em>.
Springer, 1986. p. 61. &lt;doi:10.1007/978-3-642-61649-5&gt;
</p>


<h3>See Also</h3>

<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>

<hr>
<h2 id='newCounter'>Counter</h2><span id='topic+newCounter'></span>

<h3>Description</h3>

<p><code>newCounter</code> sets up a counter object with one 
internal state variable, namely <code>count</code> 
to count the number of counter calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newCounter()
</code></pre>


<h3>Details</h3>

<p>Generate a counter: 
<code>a&lt;-newCounter()</code> sets up the counter <code>a</code>.
The counter <code>a</code> supports three methods:
</p>

<ol>
<li> <p><code>a()</code> or 
<code>a("Measure")</code> or 
<code>a(method="Measure")</code> 
<strong>starts</strong> the timer when called 1st, 3rd, 5th, ... time
and <strong>stops</strong> the timer 
when called the 2nd, 4th, 6th, ... time.
The calls can be manually inserted 
before and after a block of R-code for profiling.
</p>
</li>
<li> <p><code>a("Count")</code> or
<code>a(method="Count")</code> returns the number of times 
the function/block or R-code has been executed.
</p>
</li></ol>



<h3>Value</h3>

<p><code>newCounter()</code> returns a counter function.
</p>
<p><code>a_counter_function()</code> returns the 
number of times it has been called
(invisible).
</p>
<p><code>a_counter_function("Show")</code> returns the number of executions
of the <code>a_counter_function</code>.
</p>


<h3>See Also</h3>

<p>Other Performance Measurement: 
<code><a href="#topic+Counted">Counted</a>()</code>,
<code><a href="#topic+Timed">Timed</a>()</code>,
<code><a href="#topic+newTimer">newTimer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   a&lt;-newCounter() 
   a(); a()
   a("Show")
</code></pre>

<hr>
<h2 id='newEnvXOR'>Generates a problem environment for the XOR problem.</h2><span id='topic+newEnvXOR'></span>

<h3>Description</h3>

<p>Generates a problem environment for the XOR problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newEnvXOR()
</code></pre>


<h3>Value</h3>

<p>The problem environment for the XOR problem with 
</p>

<ul>
<li> <p><code>$name</code>: 
<code>"envXOR"</code>, the name of the problem environment.
</p>
</li>
<li> <p><code>$buildtest(expr)</code>: 
The function which builds the environment 
for evaluating the expression 
by binding the variables to the parameters.
</p>
</li>
<li> <p><code>$TestCases</code>: The truthtable of the XOR function.
</p>
</li>
<li> <p><code>$f(expr, gene=NULL, lF=NULL)</code>: The fitness function.
<code>expr</code> is the string with the 
logical expression to be evaluated. 
</p>
</li></ul>

<p>The problem environment.
</p>


<h3>See Also</h3>

<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>envXOR&lt;-newEnvXOR()
envXOR$name()
a2&lt;-"OR(OR(D1, D2), (AND(NOT(D1), NOT(D2))))"
a3&lt;-"OR(OR(D1, D2), AND(D1, D2))"
a4&lt;-"AND(OR(D1,D2),NOT(AND(D1,D2)))"
gp4&lt;-"(AND(AND(OR(D2,D1),NOT(AND(D1,D2))),(OR(D2,D1))))"
envXOR$f(a2)
envXOR$f(a3)
envXOR$f(a4)
envXOR$f(gp4)

</code></pre>

<hr>
<h2 id='NewlFevalGenes'>Generate local functions and objects</h2><span id='topic+NewlFevalGenes'></span>

<h3>Description</h3>

<p><code>NewlFevalGenes</code> returns 
the list of functions containing
a definition of all local objects required for the use
of evaluation functions. We reference this object 
as local configuration. When adding additional 
evaluation functions, this must be extended
by the constant (functions) needed to configure them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewlFevalGenes(penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NewlFevalGenes_+3A_penv">penv</code></td>
<td>
<p>A problem environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The local configuration. A list of functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DFactory()
lF&lt;-NewlFevalGenes(Parabola2D)
lF$Max()
</code></pre>

<hr>
<h2 id='NewlFselectGenes'>Generate local functions and objects.</h2><span id='topic+NewlFselectGenes'></span>

<h3>Description</h3>

<p><code>NewlFselectGenes</code> returns 
the list of functions which contains 
a definition of all local objects required for the use
of selection functions. We reference this object 
as local configuration. When adding additional 
selection functions, this must be extended
by the constant (functions) needed to configure them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewlFselectGenes()
</code></pre>


<h3>Value</h3>

<p>Local configuration <code>lF</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lF&lt;-NewlFselectGenes()
lF$Max()
</code></pre>

<hr>
<h2 id='newTimer'>Timer for R code chunks.</h2><span id='topic+newTimer'></span>

<h3>Description</h3>

<p><code>newTimer</code> sets up a timer object with two 
internal state variables, namely <code>count</code> 
to count the number of timer calls and
<code>tUsed</code> to calculate the total time spent in a code block
between two timer calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newTimer()
</code></pre>


<h3>Details</h3>


<ul>
<li> 
<p>Generate a timer: 
<code>a&lt;-newTimer()</code> sets up the timer <code>a</code>.
The timer <code>a</code> supports three methods:
</p>

<ol>
<li> <p><code>a()</code> or 
<code>a("Measure")</code> or 
<code>a(method="Measure")</code> 
<strong>starts</strong> the timer when called 1st, 3rd, 5th, ... time
and <strong>stops</strong> the timer 
when called the 2nd, 4th, 6th, ... time.
The calls can be manually inserted 
before and after a block of R-code for profiling.
</p>
</li>
<li> <p><code>a("TimeUsed")</code> or
<code>a(method="TimeUsed")</code> returns the time used in seconds.
</p>
</li>
<li> <p><code>a("Count")</code> or
<code>a(method="Count")</code> returns the number of times 
the function/block or R-code has been executed.
</p>
</li></ol>

</li>
<li> 
<p>The second way of usage is with the <code>Timed</code> function:  
</p>

<ol>
<li><p> Generate a timer: 
<code>a&lt;-newTimer()</code> sets up the timer <code>a</code>.
</p>
</li>
<li><p> You convert a function <code>b</code> into a timed function
<code>bTimed</code> by 
<code>bTimed&lt;-Timed(a, b)</code>. 
</p>
</li>
<li><p> You use <code>bTimed</code> instead of <code>b</code>.
</p>
</li>
<li><p> At the end, you can query the aggregated time and 
the aggregated number of executions by 
<code>a("TimeUsed")</code> and 
<code>a("Count")</code>, respectively. 
</p>
</li></ol>

</li></ul>



<h3>Value</h3>

<p><code>newTimer()</code> returns a timer function.
</p>
<p><code>a_timer_function()</code> returns the used time in seconds
(invisible).
</p>
<p><code>a_timer_function("TimeUsed")</code> returns the used time in seconds.
</p>
<p><code>a_timer_function("Count")</code> returns the number of executions
of a timed function and/or a timed block of R-Code in seconds.
</p>


<h3>See Also</h3>

<p>Other Performance Measurement: 
<code><a href="#topic+Counted">Counted</a>()</code>,
<code><a href="#topic+Timed">Timed</a>()</code>,
<code><a href="#topic+newCounter">newCounter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   a&lt;-newTimer() 
   a(); Sys.sleep(2); a()
   a("TimeUsed")
   a("Count")
</code></pre>

<hr>
<h2 id='newTSP'>Generate a TSP problem environment</h2><span id='topic+newTSP'></span>

<h3>Description</h3>

<p><code>newTSP</code> generates the problem environment 
for a traveling salesman problem (TSP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newTSP(D, Name, Cities = NA, Solution = NA, Path = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newTSP_+3A_d">D</code></td>
<td>
<p>A <code>n</code> x <code>n</code> distance matrix.</p>
</td></tr>
<tr><td><code id="newTSP_+3A_name">Name</code></td>
<td>
<p>The name of the problem environment.</p>
</td></tr>
<tr><td><code id="newTSP_+3A_cities">Cities</code></td>
<td>
<p>The names of the cities.</p>
</td></tr>
<tr><td><code id="newTSP_+3A_solution">Solution</code></td>
<td>
<p>Solution of problem (if known). 
Default: <code>NA</code></p>
</td></tr>
<tr><td><code id="newTSP_+3A_path">Path</code></td>
<td>
<p>Optimal permutation of cities (if known). As integer vector.
Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>newTSP</code> provides several local permutation 
improvement heuristics: 
a greedy path of length k starting
from city i, 
the best greedy path of length k, 
a random 2-Opt-move,
and a sequence of random 2-Opt moves.
They help to find bounds for the TSP 
or to implement special purpose mutation operators.
</p>


<h3>Value</h3>

<p>A problem environment for the TSP.
</p>

<ol>
<li> 
<p><code>$name()</code>             a string with the name of the environment
</p>
</li>
<li> 
<p><code>$cities()</code> a vector length <code>n</code> of city names.           
</p>
</li>
<li> 
<p><code>$dist()</code>  the <code>n</code> x <code>n</code> distance matrix 
between <code>n</code> cities.
</p>
</li>
<li> 
<p><code>$genelength()</code> the size of the permutation <code>n</code>.
E.g. for a TSP: the number of cities. 
</p>
</li>
<li> 
<p><code>$f(permutation, gene, lF, tour=TRUE)</code> 
the fitness function of the TSP. If <code>tour==FALSE</code>,
the path length is computed 
(without the cost from city n to city 1).
</p>
<p>With a permutation of size <code>n</code> as argument. 
</p>
</li>
<li> 
<p><code>$show(p)</code>    shows tour through the cities in 
path <code>p</code> with its cost. 
</p>
</li>
<li> 
<p><code>$greedy(startPosition, k)</code> 
computes a <code>k</code>-step greedy minimal cost path 
beginning at the city <code>start</code>.
For  <code>k+1=n</code> the greedy solution gives
an upper bound for the TSP.
</p>
</li>
<li> 
<p><code>$kBestGreedy(k, tour=TRUE)</code> computes the best greedy 
subtour with <code>k+1</code> cities.
For <code>tour=FALSE</code>, the best greedy
subpath with <code>k+1</code> cities is 
computed.
</p>
</li>
<li> 
<p><code>$rnd2Opt(permutation, maxTries=5)</code> returns a permutation 
improved by a single random 2-Opt-move  
after at most <code>maxTries=5</code> attempts.
</p>
</li>
<li> 
<p><code>$LinKernighan(permutation, maxTries=5, show=FALSE)</code> returns 
the best permutation found after
several random 2-Opt-moves
with at most <code>maxTries=5</code> attempts.
The loop stops after the first 2-Opt-move
which does not improve the solution.
</p>
</li>
<li> 
<p><code>$solution()</code>         known optimal solution
</p>
</li>
<li> 
<p><code>$path()</code>             known optimal round trip 
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-matrix(0, nrow=15, ncol=15)
a[1,]&lt;- c(0, 29, 82, 46, 68, 52, 72, 42, 51,  55,  29,  74,  23,  72,  46)
a[2,]&lt;- c(29,  0, 55, 46, 42, 43, 43, 23, 23,  31,  41,  51,  11,  52,  21)
a[3,]&lt;- c(82, 55,  0, 68, 46, 55, 23, 43, 41,  29,  79,  21,  64,  31,  51)
a[4,]&lt;-c(46, 46, 68,  0, 82, 15, 72, 31, 62,  42,  21,  51,  51,  43,  64)
a[5,]&lt;-c(68, 42, 46, 82,  0, 74, 23, 52, 21,  46,  82,  58,  46,  65,  23)
a[6,]&lt;-c(52, 43, 55, 15, 74,  0, 61, 23, 55,  31,  33,  37,  51,  29,  59)
a[7,]&lt;-c(72, 43, 23, 72, 23, 61,  0, 42, 23,  31,  77,  37,  51,  46,  33)
a[8,]&lt;-c(42, 23, 43, 31, 52, 23, 42,  0, 33,  15,  37,  33,  33,  31,  37)
a[9,]&lt;-c(51, 23, 41, 62, 21, 55, 23, 33,  0,  29,  62,  46,  29,  51,  11)
a[10,]&lt;-c(55, 31, 29, 42, 46, 31, 31, 15, 29,  0,  51,  21,  41,  23,  37)
a[11,]&lt;-c(29, 41, 79, 21, 82, 33, 77, 37, 62,  51,   0,  65,  42,  59,  61)
a[12,]&lt;-c(74, 51, 21, 51, 58, 37, 37, 33, 46,  21,  65,   0,  61,  11,  55)
a[13,]&lt;-c(23, 11, 64, 51, 46, 51, 51, 33, 29,  41,  42,  61,   0,  62,  23)
a[14,]&lt;-c(72, 52, 31, 43, 65, 29, 46, 31, 51,  23,  59,  11,  62,   0,  59)
a[15,]&lt;-c(46, 21, 51, 64, 23, 59, 33, 37, 11,  37,  61,  55,  23,  59,   0)
lau15&lt;-newTSP(a, Name="lau15")
lau15$name()
lau15$genelength()
b&lt;-sample(1:15, 15, FALSE)
lau15$f(b)
lau15$f(b, tour=TRUE)
lau15$show(b)
lau15$greedy(1, 14)
lau15$greedy(1, 1)

</code></pre>

<hr>
<h2 id='Parabola2DEarlyFactory'>Factory for a 2-dimensional quadratic parabola with early termination check.</h2><span id='topic+Parabola2DEarlyFactory'></span>

<h3>Description</h3>

<p>This list of functions sets up the problem environment
for a 2-dimensional
quadratic parabola.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parabola2DEarlyFactory()
</code></pre>


<h3>Details</h3>

<p>The factory contains examples of all functions 
which form the interface of a problem environment to
the simple genetic algorithm with binary-coded genes
of package <code>xega</code>.
This factory provides examples of a termination condition,
a description function, and a solution function:
</p>

<ul>
<li> <p><code>terminate(solution)</code>
checks for an early termination condition.
</p>
</li>
<li> <p><code>describe()</code>
shows a description of the function.
</p>
</li>
<li> <p><code>solution()</code>
returns a list with the 
<code>minimum</code> and the
<code>maximum</code> values as well as the lists
<code>minpoints</code> and <code>maxpoints</code> of 
the minimal and the maximal points.
</p>
</li></ul>



<h3>Value</h3>

<p>A problem environment represented as a list of functions:
</p>

<ul>
<li> <p><code>$name()</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the number of bits of 
each parameter of the function.
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of the gene.
</p>
</li>
<li> <p><code>$lb()</code>: The vector of lower bounds of the parameters.
</p>
</li>
<li> <p><code>$ub()</code>: The vector of upper bounds of the parameters.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>): The fitness function. 
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li> <p><code>$describe()</code>: Print a description of the problem environment to the console.
</p>
</li>
<li> <p><code>$solution()</code>: The solution structure. A named list with <code>minimum</code>, <code>maximum</code> and
2 lists of equivalent solutions: <code>minpoints</code>, <code>maxpoints</code>. 
</p>
</li></ul>



<h3>See Also</h3>

<p>DelayedP, Parabola2DErr
</p>
<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DEarlyFactory()
Parabola2D$f(c(2.2, 1.0))
</code></pre>

<hr>
<h2 id='Parabola2DErrFactory'>Factory for a randomly failing 2-dimensional quadratic parabola.</h2><span id='topic+Parabola2DErrFactory'></span>

<h3>Description</h3>

<p>This list of functions sets up the problem environment
for a 2-dimensional
quadratic parabola which produces an error 
with a probability of 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parabola2DErrFactory()
</code></pre>


<h3>Details</h3>

<p>The factory contains examples of all functions 
which form the interface of a problem environment to
the simple genetic algorithm with binary-coded genes
of package <code>xega</code>.
</p>


<h3>Value</h3>

<p>A problem environment represented as a list of functions:
</p>

<ul>
<li> <p><code>$name()</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the number of bits of 
each parameter of the function.
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of the gene.
</p>
</li>
<li> <p><code>$lb()</code>: The vector of lower bounds of the parameters.
</p>
</li>
<li> <p><code>$ub()</code>: The vector of upper bounds of the parameters.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>): The fitness function. 
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li> <p><code>$describe()</code>: Print a description of the problem environment to the console.
</p>
</li>
<li> <p><code>$solution()</code>: The solution structure. A named list with <code>minimum</code>, <code>maximum</code> and
2 lists of equivalent solutions: <code>minpoints</code>, <code>maxpoints</code>. 
</p>
</li></ul>



<h3>See Also</h3>

<p>DelayedP
</p>
<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DFactory">Parabola2DFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2DErr&lt;-Parabola2DErrFactory()
</code></pre>

<hr>
<h2 id='Parabola2DFactory'>Factory for a 2-dimensional quadratic parabola.</h2><span id='topic+Parabola2DFactory'></span>

<h3>Description</h3>

<p>This list of functions sets up the problem environment
for a 2-dimensional
quadratic parabola.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parabola2DFactory()
</code></pre>


<h3>Details</h3>

<p>The factory contains examples of all functions 
which form the interface of a problem environment to
the simple genetic algorithm with binary-coded genes
of package <code>xega</code>.
</p>


<h3>Value</h3>

<p>A problem environment represented as a list of functions:
</p>

<ul>
<li> <p><code>$name()</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the number of bits of 
each parameter of the function.
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of the gene.
</p>
</li>
<li> <p><code>$lb()</code>: The vector of lower bounds of the parameters.
</p>
</li>
<li> <p><code>$ub()</code>: The vector of upper bounds of the parameters.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>): The fitness function. 
</p>
</li></ul>

<p>Additional elements:
</p>

<ul>
<li> <p><code>$describe()</code>: Print a description of the problem environment to the console.
</p>
</li>
<li> <p><code>$solution()</code>: The solution structure. A named list with <code>minimum</code>, <code>maximum</code> and
2 lists of equivalent solutions: <code>minpoints</code>, <code>maxpoints</code>. 
</p>
</li></ul>



<h3>See Also</h3>

<p>DelayedP, Parabola2DErr
</p>
<p>Other Problem Environments: 
<code><a href="#topic+DeJongF4Factory">DeJongF4Factory</a>()</code>,
<code><a href="#topic+DelayedPFactory">DelayedPFactory</a>()</code>,
<code><a href="#topic+Parabola2DEarlyFactory">Parabola2DEarlyFactory</a>()</code>,
<code><a href="#topic+Parabola2DErrFactory">Parabola2DErrFactory</a>()</code>,
<code><a href="#topic+envXOR">envXOR</a></code>,
<code><a href="#topic+lau15">lau15</a></code>,
<code><a href="#topic+newEnvXOR">newEnvXOR</a>()</code>,
<code><a href="#topic+newTSP">newTSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Parabola2D&lt;-Parabola2DFactory()
Parabola2D$f(c(2.2, 1.0))
</code></pre>

<hr>
<h2 id='parm'>Factory for constants</h2><span id='topic+parm'></span>

<h3>Description</h3>

<p><code>parm</code> builds a constant function for <code>x</code>. 
See Wickham (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parm_+3A_x">x</code></td>
<td>
<p>A constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The constant function.
</p>


<h3>References</h3>

<p>Wickham, Hadley (2019): Advanced R, CRC Press, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TournamentSize&lt;-parm(2)
TournamentSize()
Eps&lt;-parm(0.01)
Eps()
</code></pre>

<hr>
<h2 id='predictSelectTime'>Predict the time use of a selection method for a popsize.</h2><span id='topic+predictSelectTime'></span>

<h3>Description</h3>

<p>Predict the time use of a selection method for a popsize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictSelectTime(df, method = "Uniform", popsize = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSelectTime_+3A_df">df</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="predictSelectTime_+3A_method">method</code></td>
<td>
<p>Selection method.</p>
</td></tr>
<tr><td><code id="predictSelectTime_+3A_popsize">popsize</code></td>
<td>
<p>Population size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with
</p>

<ul>
<li>
<p><code>$model</code>:  The result of <code>stats::lm</code>.
</p>
</li>
<li>
<p><code>$predict</code>:  The result of <code>stats::predict</code>.
</p>
</li></ul>



<h3>Warning</h3>

<p>Uses a quadratic regression model.
But the complexities of the functions are of orders
O(1), O(n), O(n.ln(n)) and O(n^2).
</p>


<h3>See Also</h3>

<p>Other Benchmark Selection Functions: 
<code><a href="#topic+runOneBenchmark">runOneBenchmark</a>()</code>,
<code><a href="#topic+runSelectBenchmarks">runSelectBenchmarks</a>()</code>,
<code><a href="#topic+selectBenchmark">selectBenchmark</a>()</code>,
<code><a href="#topic+testSelectGene">testSelectGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>popsizes&lt;-as.integer(seq(from=100, to=200, length.out=5))
a&lt;-runSelectBenchmarks(popsizes, both=TRUE)
b&lt;-predictSelectTime(a, method="SUS", 155)
summary(b$model)
b$predicted
c&lt;- predictSelectTime(a, method="SUS  C", c(155, 500))
summary(c$model)
c$predicted
</code></pre>

<hr>
<h2 id='runOneBenchmark'>Script for testing a single selection functions</h2><span id='topic+runOneBenchmark'></span>

<h3>Description</h3>

<p>Script for testing a single selection functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOneBenchmark(name, limit = c(10, 100, 1000), both = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOneBenchmark_+3A_name">name</code></td>
<td>
<p>Name is one of the following strings.
</p>

<ol>
<li><p> &quot;Uniform&quot; benchmarks <code>SelectUniform</code>.
</p>
</li>
<li><p> &quot;ProportionalOnln&quot; benchmarks <code>SelectPropFitOnln</code>.
</p>
</li>
<li><p> &quot;Proportional&quot; benchmarks <code>SelectPropFit</code>.
</p>
</li>
<li><p> &quot;ProportionalM&quot; benchmarks <code>SelectPropFitM</code>.
</p>
</li>
<li><p> &quot;PropFitDiffOnln&quot; benchmarks <code>SelectPropFitDiffOnln</code>.
</p>
</li>
<li><p> &quot;PropFitDiff&quot; benchmarks <code>SelectPropFitDiff</code>.
</p>
</li>
<li><p> &quot;PropFitDiffM&quot; benchmarks <code>SelectPropFitDiffM</code>.
</p>
</li>
<li><p> &quot;Tournament&quot; benchmarks <code>SelectTournament</code>.
</p>
</li>
<li><p> &quot;Duel&quot; benchmarks <code>SelectDuel</code>.
</p>
</li>
<li><p> &quot;LinearRank&quot; benchmarks <code>SelectLinearRank</code>.
</p>
</li>
<li><p> &quot;SUS&quot; benchmarks <code>SelectSUS</code>.
</p>
</li></ol>
</td></tr>
<tr><td><code id="runOneBenchmark_+3A_limit">limit</code></td>
<td>
<p>Vector of population sizes.</p>
</td></tr>
<tr><td><code id="runOneBenchmark_+3A_both">both</code></td>
<td>
<p>For <code>both=TRUE</code> the selection function 
is benchmarked with and without transformation. 
For <code>both=FALSE</code>, only the transformed selection functions
are benchmarked.</p>
</td></tr>
<tr><td><code id="runOneBenchmark_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default: <code>FALSE</code>. 
If <code>TRUE</code>, the function benchmarked and the population size 
are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame sorted in ascending order of time of last column.
</p>


<h3>Warning</h3>

<p>The time to run the function for <code>lim&gt;6</code> explodes 
for all benchmark functions with higher than linear complexity.
(e.g. <code>PropFit</code>, <code>PropFitdiff</code>, and <code>Tournament</code>).
</p>


<h3>See Also</h3>

<p>Other Benchmark Selection Functions: 
<code><a href="#topic+predictSelectTime">predictSelectTime</a>()</code>,
<code><a href="#topic+runSelectBenchmarks">runSelectBenchmarks</a>()</code>,
<code><a href="#topic+selectBenchmark">selectBenchmark</a>()</code>,
<code><a href="#topic+testSelectGene">testSelectGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runOneBenchmark("Duel", 5, both=FALSE)
runOneBenchmark("PropFitDiffOnln")
</code></pre>

<hr>
<h2 id='runSelectBenchmarks'>Script for testing all selection functions</h2><span id='topic+runSelectBenchmarks'></span>

<h3>Description</h3>

<p>Script for testing all selection functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSelectBenchmarks(lim = c(10, 100), both = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runSelectBenchmarks_+3A_lim">lim</code></td>
<td>
<p>Vector of population sizes.</p>
</td></tr>
<tr><td><code id="runSelectBenchmarks_+3A_both">both</code></td>
<td>
<p>For <code>both=TRUE</code> the selection function 
is benchmarked with and without transformation. 
For <code>both=FALSE</code>, only the transformed selection functions
are benchmarked.</p>
</td></tr>
<tr><td><code id="runSelectBenchmarks_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default: <code>FALSE</code>. 
If <code>TRUE</code>, the function benchmarked and the population size 
are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame sorted in ascending order of the time of
the last column. 
The fastest selection methods come first.
The first row contains the population sizes with which 
the benchmark has been performed.
The data frame has <code>1+length(lim)</code> columns:
</p>

<ul>
<li><p> &quot;Benchmark&quot;: The name of the benchmarked selection 
function. A &quot;C&quot; after the name indicates
that the selection function has been 
transformed into a lookup function.
</p>
</li>
<li> <p><code>length(lim)</code> columns with the execution times in seconds.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Benchmark Selection Functions: 
<code><a href="#topic+predictSelectTime">predictSelectTime</a>()</code>,
<code><a href="#topic+runOneBenchmark">runOneBenchmark</a>()</code>,
<code><a href="#topic+selectBenchmark">selectBenchmark</a>()</code>,
<code><a href="#topic+testSelectGene">testSelectGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runSelectBenchmarks(lim=c(10, 100), both=TRUE, verbose=TRUE)
runSelectBenchmarks(lim=c(10, 100), both=FALSE)
</code></pre>

<hr>
<h2 id='ScaleFitness'>Scaling Fitness</h2><span id='topic+ScaleFitness'></span>

<h3>Description</h3>

<p>Fitness is transformed by a power function 
<code>fit^k</code>.
If <code>k</code> is 
</p>

<ul>
<li><p> less than 1: Selection pressure is decreased.
</p>
</li>
<li><p> 1:  Selection pressure remains constant.
</p>
</li>
<li><p> larger than 1: Selection pressure is increased.
</p>
</li>
<li><p> 0:  Fitness is constant. Random selection.
</p>
</li>
<li><p> smaller than 0: Fitness is 
<code>1/k</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ScaleFitness(fit, k, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScaleFitness_+3A_fit">fit</code></td>
<td>
<p>A fitness vector.</p>
</td></tr>
<tr><td><code id="ScaleFitness_+3A_k">k</code></td>
<td>
<p>Scaling exponent.</p>
</td></tr>
<tr><td><code id="ScaleFitness_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Power functions are used for contrast sharpening or softening
in image analysis. 
For fuzzy sets representing the value of a linguistic variable,
the power function has been used as concentration or dilation
transformations for modeling adverbs.
</p>


<h3>Value</h3>

<p>A scaled fitness vector.
</p>


<h3>References</h3>

<p>Wenstop, Fred (1980) 
Quantitative Analysis with Linguistic Variables.
Fuzzy Sets and Systems, 4(2), pp. 99-115.
&lt;doi:10.1016/0165-0114(80)90031-7&gt;
</p>


<h3>See Also</h3>

<p>Other Scaling: 
<code><a href="#topic+ContinuousScaleFitness">ContinuousScaleFitness</a>()</code>,
<code><a href="#topic+DispersionRatio">DispersionRatio</a>()</code>,
<code><a href="#topic+ScalingFitness">ScalingFitness</a>()</code>,
<code><a href="#topic+ThresholdScaleFitness">ThresholdScaleFitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lF&lt;-list()
lF$Offset&lt;-parm(0.0001)
fit&lt;-sample(10, 20, replace=TRUE)
fit
ScaleFitness(fit, 0.5, lF)
</code></pre>

<hr>
<h2 id='ScalingFactory'>Scaling Factory</h2><span id='topic+ScalingFactory'></span>

<h3>Description</h3>

<p>Scaling Factory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScalingFactory(method = "NoScaling")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalingFactory_+3A_method">method</code></td>
<td>
<p>A scaling method. Available methods are:
</p>
 
<ul>
<li><p> &quot;NoScaling&quot;: Identity (Default).       
</p>
</li>
<li><p> &quot;ConstantScaling&quot;: <code>fit^k</code> with constant exponent.
Function <code>ConstantScaling</code>.
</p>
</li>
<li><p> &quot;ThresholdScaling&quot;: 
If the dispersion ratio is larger than <code>1+threshold</code>, 
use a constant scaling exponent with a value below 1 
(decrease of selection pressure).
Function <code>ThresholdScaling</code>.
</p>
</li>
<li><p> If the dispersion ratio is lower than <code>1-threshold</code>, 
use a constant scaling exponent with a value above 1
(increase of selection pressure).
</p>
</li>
<li><p> &quot;ContinuousScaling&quot;: Use weighted dispersion ratio 
as scaling exponent.
Function <code>ContinuousScaling</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaling function.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+DispersionMeasureFactory">DispersionMeasureFactory</a>()</code>,
<code><a href="#topic+EvalGeneFactory">EvalGeneFactory</a>()</code>,
<code><a href="#topic+SelectGeneFactory">SelectGeneFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 20, replace=TRUE)
lF&lt;-list()
lF$ScalingExp&lt;-parm(2)
Scale&lt;-ScalingFactory()
fit
Scale(fit, lF)
Scale&lt;-ScalingFactory("ConstantScaling")
Scale(fit, lF)
</code></pre>

<hr>
<h2 id='ScalingFitness'>Abstract interface for ScaleFitness.</h2><span id='topic+ScalingFitness'></span>

<h3>Description</h3>

<p>The scaling constant <code>k</code> is  
set by the function <code>lF$ScalingExp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScalingFitness(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalingFitness_+3A_fit">fit</code></td>
<td>
<p>A fitness vector.</p>
</td></tr>
<tr><td><code id="ScalingFitness_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled fitness vector
</p>


<h3>See Also</h3>

<p>Other Scaling: 
<code><a href="#topic+ContinuousScaleFitness">ContinuousScaleFitness</a>()</code>,
<code><a href="#topic+DispersionRatio">DispersionRatio</a>()</code>,
<code><a href="#topic+ScaleFitness">ScaleFitness</a>()</code>,
<code><a href="#topic+ThresholdScaleFitness">ThresholdScaleFitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lF&lt;-list()
lF$Offset&lt;-parm(0.0001)
lF$ScalingExp&lt;-parm(2)
fit&lt;-sample(10, 20, replace=TRUE)
fit
ScalingFitness(fit, lF)
</code></pre>

<hr>
<h2 id='selectBenchmark'>Benchmark and stress test of selection functions.</h2><span id='topic+selectBenchmark'></span>

<h3>Description</h3>

<p>Times a selection function 
for populations of size 10 to <code class="reqn">10^{limit}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectBenchmark(
  method = "Uniform",
  continuation = TRUE,
  limit = c(10, 100, 1000),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectBenchmark_+3A_method">method</code></td>
<td>
<p>Selection function. Default: Uniform.</p>
</td></tr>
<tr><td><code id="selectBenchmark_+3A_continuation">continuation</code></td>
<td>
<p>Convert to index function? Default: TRUE.</p>
</td></tr>
<tr><td><code id="selectBenchmark_+3A_limit">limit</code></td>
<td>
<p>Vector of population sizes.</p>
</td></tr>
<tr><td><code id="selectBenchmark_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default: <code>FALSE</code>. 
If <code>TRUE</code>, the function benchmarked and the population size 
are printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of execution times in seconds.
</p>


<h3>See Also</h3>

<p>Other Benchmark Selection Functions: 
<code><a href="#topic+predictSelectTime">predictSelectTime</a>()</code>,
<code><a href="#topic+runOneBenchmark">runOneBenchmark</a>()</code>,
<code><a href="#topic+runSelectBenchmarks">runSelectBenchmarks</a>()</code>,
<code><a href="#topic+testSelectGene">testSelectGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>selectBenchmark(method="Uniform", continuation=TRUE, limit=c(10, 100, 1000))
selectBenchmark(method="SUS", continuation=TRUE, limit=c(5000, 10000, 15000))
selectBenchmark(method="SUS", continuation=FALSE, limit=seq(from=100, to=1000, length.out=5))
</code></pre>

<hr>
<h2 id='SelectDuel'>Deterministic duel.</h2><span id='topic+SelectDuel'></span>

<h3>Description</h3>

<p><code>SelectDuel</code> implements selection
by a tournament between 2
randomly selected genes. The best gene always wins.
This is the version of tournament selection 
with the least selection pressure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectDuel(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectDuel_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectDuel_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectDuel_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an O(n) implementation of tournament selection with 
a tournament size of 2.
</p>
<p>A special case of tournament selection.
</p>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectDuel(fit, NewlFselectGenes()) 
SelectDuel(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectGeneFactory'>Configure the selection function of a genetic algorithm.</h2><span id='topic+SelectGeneFactory'></span>

<h3>Description</h3>

<p><code>SelectGeneFactory</code> implements selection
of one of the gene selection functions in this 
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.             
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Uniform&quot; returns <code>SelectUniform</code>.
</p>
</li>
<li><p> &quot;UniformP&quot; returns <code>SelectUniformP</code>.
</p>
</li>
<li><p> &quot;ProportionalOnln&quot; returns <code>SelectPropFitOnln</code>.
</p>
</li>
<li><p> &quot;Proportional&quot; returns <code>SelectPropFit</code>.
</p>
</li>
<li><p> &quot;ProportionalM&quot; returns <code>SelectPropFitM</code>.
</p>
</li>
<li><p> &quot;PropFitDiffOnln&quot; returns <code>SelectPropFitDiffOnln</code>.
</p>
</li>
<li><p> &quot;PropFitDiff&quot; returns <code>SelectPropFitDiff</code>.
</p>
</li>
<li><p> &quot;PropFitDiffM&quot; returns <code>SelectPropFitDiffM</code>.
</p>
</li>
<li><p> &quot;Tournament&quot; returns <code>SelectTournament</code>.
</p>
</li>
<li><p> &quot;STournament&quot; returns <code>SelectSTournament</code>.
</p>
</li>
<li><p> &quot;Duel&quot; returns <code>SelectDuel</code>.
</p>
</li>
<li><p> &quot;LRSelective&quot; returns <code>SelectLRSelective</code>.
</p>
</li>
<li><p> &quot;LRTSR&quot; returns <code>SelectLinearRankTSR</code>.
</p>
</li>
<li><p> &quot;SUS&quot; returns a function factory for <code>SelectSUS</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>SelectGeneFactory(method = "PropFitDiffOnln")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectGeneFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the selection function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>SelectionContinuation()==TRUE</code> then:
</p>

<ol>
<li><p> In package xegaPopulation function <code>NextPopulation</code>,
first the functions 
<code>SelectGene</code> and <code>SelectMate</code> 
are transformed by <code>TransformSelect</code> to
a continuation function with
embedded index vector and counter.
</p>
</li>
<li><p> For each call in <code>ReplicateGene</code>,
<code>SelectGene</code> and <code>SelectMate</code> 
return the index of the selected gene.
</p>
</li></ol>



<h3>Value</h3>

<p>A selection function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+DispersionMeasureFactory">DispersionMeasureFactory</a>()</code>,
<code><a href="#topic+EvalGeneFactory">EvalGeneFactory</a>()</code>,
<code><a href="#topic+ScalingFactory">ScalingFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SelectGene&lt;-SelectGeneFactory("Uniform")
fit&lt;-sample(10, 15, replace=TRUE)
SelectGene(fit, lFselectGenes) 
sel&lt;-"Proportional"
SelectGene&lt;-SelectGeneFactory(method=sel)
fit&lt;-sample(10, 15, replace=TRUE)
SelectGene(fit, lFselectGenes) 
</code></pre>

<hr>
<h2 id='SelectLinearRankTSR'>Linear rank selection.</h2><span id='topic+SelectLinearRankTSR'></span>

<h3>Description</h3>

<p><code>SelectLinearRankTSR</code> implements selection
with interpolated target sampling rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectLinearRankTSR(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectLinearRankTSR_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectLinearRankTSR_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectLinearRankTSR_+3A_size">size</code></td>
<td>
<p>Size of return vector (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The target sampling rate is a linear interpolation 
between <code>lF$MaxTSR</code> and <code>Min&lt;-2-lF$MaxTSR</code>,
because the sum of the target sampling rates is $n$. 
The target sampling rates are computed and used as a fitness
vector for stochastic universal sampling algorithm
implemented by <code>SelectSUS</code>.
<code>lF$MaxTSR</code> should be in [1.0, 2.0].
</p>
<p>TODO: More efficient implementation. We use two sorts!
</p>


<h3>Value</h3>

<p>The index vector of selected genes.
</p>


<h3>References</h3>

<p>Grefenstette, John J. and Baker, James E. (1989):
How Genetic Algorithms Work: A Critical Look at Implicit Parallelism
In Schaffer, J. David (Ed.) 
<em>Proceedings of the Third International 
Conference on Genetic Algorithms on Genetic Algorithms</em>, pp. 20-27.
(ISBN:1-55860-066-3)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectLinearRankTSR(fit, NewlFselectGenes()) 
SelectLinearRankTSR(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectLRSelective'>Linear rank selection with selective pressure.</h2><span id='topic+SelectLRSelective'></span>

<h3>Description</h3>

<p><code>SelectLRSelective</code> implements selection
by Whitley's linear rank selection with selective pressure 
for the GENITOR algorithm. 
See Whitley, Darrell (1989), p. 121.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectLRSelective(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectLRSelective_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectLRSelective_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectLRSelective_+3A_size">size</code></td>
<td>
<p>Size of return vector (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection pressure is configured by the constant function 
<code>lF$SelectionBias()</code>. Its values should be strictly larger 
than 1 and preferably below 2. The default is set to 1.5.
A value of 1.0 means uniform random selection.
</p>


<h3>Value</h3>

<p>The index vector of selected genes.
</p>


<h3>References</h3>

<p>Whitley, Darrell (1989):
The GENITOR Algorithm and Selection Pressure.
Why Rank-Based Allocation of Reproductive Trials is Best.
In Schaffer, J. David (Ed.) 
<em>Proceedings of the Third International 
Conference on Genetic Algorithms on Genetic Algorithms</em>, pp. 116-121.
(ISBN:1-55860-066-3)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectLRSelective(fit, NewlFselectGenes()) 
SelectLRSelective(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFit'>Selection proportional to fitness <code class="reqn">O(n^2)</code>.</h2><span id='topic+SelectPropFit'></span>

<h3>Description</h3>

<p><code>SelectPropFit</code> implements selection
proportional to fitness. Negative fitness
vectors are shifted to <code class="reqn">R^+</code>.
The default of the function <code>lf$Offset</code> is <code>1</code>. 
Holland's schema theorem uses this selection function.
See John Holland (1975) for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFit(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFit_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFit_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFit_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Warning</h3>

<p>There is a potential slow for-loop in the code.
</p>


<h3>References</h3>

<p>Holland, John (1975): 
<em>Adaptation in Natural and Artificial Systems</em>,  
The University of Michigan Press, Ann Arbor.
(ISBN:0-472-08460-7)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFit(fit, NewlFselectGenes()) 
SelectPropFit(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFitDiff'>Selection proportional to fitness differences.</h2><span id='topic+SelectPropFitDiff'></span>

<h3>Description</h3>

<p><code>SelectPropFitDiff</code> implements selection
proportional to fitness differences.
It selects a gene out of the population
with a probability proportional to the fitness
difference to the gene with minimal fitness.
The fitness of survival of the gene with 
minimal fitness is set by <code>lF$Eps()</code> 
to <code>0.01</code> per default.
See equation (7.45) Andreas Geyer-Schulz (1997), p. 205.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFitDiff(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFitDiff_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiff_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiff_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Note</h3>

<p><code>SelectPopFitDiff</code> is a dynamic scaling function.
Complexity: <code class="reqn">O(n^2)</code>.
</p>


<h3>References</h3>

<p>Geyer-Schulz, Andreas (1997):
<em>Fuzzy Rule-Based Expert Systems and Genetic Machine Learning</em>,
Physica, Heidelberg.
(ISBN:978-3-7908-0830-X)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFitDiff(fit, NewlFselectGenes()) 
SelectPropFitDiff(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFitDiffM'>Selection proportional to fitness differences.</h2><span id='topic+SelectPropFitDiffM'></span>

<h3>Description</h3>

<p><code>SelectPropFitDiffM</code> implements selection
proportional to fitness differences.
It selects a gene from the population
with a probability proportional to the fitness
difference to the gene with minimal fitness.
The fitness of survival of the gene with 
minimal fitness is set by <code>lF$Eps()</code> 
to <code>0.01</code> per default.
See equation (7.45) Andreas Geyer-Schulz (1997), p. 205.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFitDiffM(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFitDiffM_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiffM_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiffM_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Warning</h3>

<p><code>outer</code> uses <code class="reqn">O(n^2)</code> memory cells.
</p>


<h3>Note</h3>

<p><code>SelectPopFitDiff</code> is a dynamic scaling function.
</p>


<h3>References</h3>

<p>Andreas Geyer-Schulz (1997):
<em>Fuzzy Rule-Based Expert Systems and Genetic Machine Learning</em>,
Physica, Heidelberg.
&lt;978-3-7908-0830-X&gt;
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFitDiffM(fit, NewlFselectGenes()) 
SelectPropFitDiffM(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFitDiffOnln'>Selection proportional to fitness differences O(n ln(n)).</h2><span id='topic+SelectPropFitDiffOnln'></span>

<h3>Description</h3>

<p><code>SelectPropFitDiffOnln</code> implements selection
proportional to fitness differences. Negative fitness
vectors are shifted to <code class="reqn">R^+</code>.
The default of the function <code>lf$Offset</code> is <code>1</code>. 
Holland's schema theorem uses this selection function.
See John Holland (1975) for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFitDiffOnln(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFitDiffOnln_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiffOnln_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFitDiffOnln_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a fast implementation which gives exactly the same 
results as the functions <code>SelectPropFitDiff</code> 
and <code>SelectPropDiffFitM</code>.
Its runtime is <code class="reqn">O(n . ln(n))</code>.
</p>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Credits</h3>

<p>The code of this function has been adapted by 
Fabian Aisenbrey.
</p>


<h3>Warning</h3>

<p>There is a potential slow for-loop in the code.
</p>


<h3>References</h3>

<p>Holland, John (1975): 
<em>Adaptation in Natural and Artificial Systems</em>,  
The University of Michigan Press, Ann Arbor.
(ISBN:0-472-08460-7)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFitDiffOnln(fit, NewlFselectGenes()) 
SelectPropFitOnln(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFitM'>Selection proportional to fitness (vector/matrix).</h2><span id='topic+SelectPropFitM'></span>

<h3>Description</h3>

<p><code>SelectPropFitM</code> implements selection
proportional to fitness. Negative fitness
vectors are shifted to <code class="reqn">R^+</code>.
The default of the function <code>lf$Offset</code> is <code>1</code>. 
Holland's schema theorem uses this selection function.
See John Holland (1975) for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFitM(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFitM_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFitM_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFitM_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Warning</h3>

<p>The code is completely written in vector/matrix 
operations. 
<code>outer</code> uses <code class="reqn">O(n^2)</code> memory cells.
</p>


<h3>References</h3>

<p>Holland, John (1975): 
<em>Adaptation in Natural and Artificial Systems</em>,  
The University of Michigan Press, Ann Arbor.
(ISBN:0-472-08460-7)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFitM(fit, NewlFselectGenes()) 
SelectPropFitM(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectPropFitOnln'>Selection proportional to fitness O(n ln(n)).</h2><span id='topic+SelectPropFitOnln'></span>

<h3>Description</h3>

<p><code>SelectPropFitOnln</code> implements selection
proportional to fitness. Negative fitness
vectors are shifted to <code class="reqn">R^+</code>.
The default of the function <code>lf$Offset</code> is <code>1</code>. 
Holland's schema theorem uses this selection function.
See John Holland (1975) for further information.
</p>
<p>@details This is a fast implementation with equivalent results 
to the functions <code>SelectPropFit</code> and <code>SelectPropFitM</code>.
Its runtime is <code class="reqn">O(n . ln(n))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectPropFitOnln(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectPropFitOnln_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectPropFitOnln_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectPropFitOnln_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>Credits</h3>

<p>The code of this function has been written by 
Fabian Aisenbrey.
</p>


<h3>References</h3>

<p>Holland, John (1975): 
<em>Adaptation in Natural and Artificial Systems</em>,  
The University of Michigan Press, Ann Arbor.
(ISBN:0-472-08460-7)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectPropFitOnln(fit, NewlFselectGenes()) 
SelectPropFitOnln(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectSTournament'>Stochastic tournament selection.</h2><span id='topic+SelectSTournament'></span>

<h3>Description</h3>

<p><code>SelectSTournament</code> implements selection
through a stochastic tournament between 
<code>lF$TournamentSize()</code> 
randomly selected genes. A gene wins a tournament 
with a probability proportional to its fitness.
The default of <code>lF$TournamentSize()</code> is <code>2</code>. 
A tournament
with 2 participants has the least selection pressure.
</p>
<p><code>lF$TournamentSize</code> must be less than the population size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectSTournament(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectSTournament_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectSTournament_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectSTournament_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectSTournament(fit, NewlFselectGenes()) 
SelectSTournament(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectSUS'>Stochastic universal sampling.</h2><span id='topic+SelectSUS'></span>

<h3>Description</h3>

<p><code>SelectSUS</code> implements selection
by Baker's stochastic universal sampling method. 
SUS is a strictly sequential algorithm 
which has zero bias and minimal spread.
SUS uses a single random number for each generation.
See Baker, James E. (1987), p. 16.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectSUS(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectSUS_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectSUS_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectSUS_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>References</h3>

<p>Baker, James E. (1987):
Reducing Bias and Inefficiency in the Selection Algorithm.
In Grefenstette, John J.(Ed.) 
<em>Proceedings of the Second International 
Conference on Genetic Algorithms on Genetic Algorithms</em>, pp. 14-21.
(ISBN:978-08058-0158-8)
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectSUS(fit, NewlFselectGenes()) 
SelectSUS(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectTournament'>Tournament selection.</h2><span id='topic+SelectTournament'></span>

<h3>Description</h3>

<p><code>SelectTournament</code> implements selection
by doing a tournament between <code>lF$TournamentSize()</code> 
randomly selected genes. The best gene always wins.
The default of <code>lF$TournamentSize()</code> is <code>2</code>. This 
is the version with the least selection pressure.
</p>
<p><code>lF$TournamentSize</code> must be less than the population size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectTournament(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectTournament_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectTournament_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectTournament_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectTournament(fit, NewlFselectGenes()) 
SelectTournament(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectUniform'>Selection with uniform probability.</h2><span id='topic+SelectUniform'></span>

<h3>Description</h3>

<p><code>SelectUniform</code> implements selection
by choosing a gene with equal probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectUniform(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectUniform_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectUniform_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectUniform_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This selection function is useful:
</p>

<ol>
<li>
<p>To specify mating behavior in crossover operators.
</p>
</li>
<li>
<p>For computer experiments without selection pressure.
</p>
</li>
<li> 
<p>For computing random search solutions as a benchmark.
</p>
</li></ol>



<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniformP">SelectUniformP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectUniform(fit, NewlFselectGenes()) 
SelectUniform(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='SelectUniformP'>Selection with uniform probability without replacement.</h2><span id='topic+SelectUniformP'></span>

<h3>Description</h3>

<p><code>SelectUniformP</code> implements selection
by choosing a gene with equal probability without 
replacement.
Usage:
</p>

<ol>
<li>
<p>To specify mating behavior in crossover operators.
</p>
</li>
<li>
<p>For computer experiments without selection pressure.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>SelectUniformP(fit, lF, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectUniformP_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="SelectUniformP_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="SelectUniformP_+3A_size">size</code></td>
<td>
<p>Number of selected genes. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection without replacement guarantees that 
vectors of different indices are selected.
A vector of the size of the population is a permutation 
of indices. This property is needed for the classic 
variant of differential evolution.
</p>


<h3>Value</h3>

<p>The index vector of the selected genes.
</p>


<h3>References</h3>

<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134. 
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>


<h3>See Also</h3>

<p>Other Selection Functions: 
<code><a href="#topic+SelectDuel">SelectDuel</a>()</code>,
<code><a href="#topic+SelectLRSelective">SelectLRSelective</a>()</code>,
<code><a href="#topic+SelectLinearRankTSR">SelectLinearRankTSR</a>()</code>,
<code><a href="#topic+SelectPropFitDiffM">SelectPropFitDiffM</a>()</code>,
<code><a href="#topic+SelectPropFitDiffOnln">SelectPropFitDiffOnln</a>()</code>,
<code><a href="#topic+SelectPropFitDiff">SelectPropFitDiff</a>()</code>,
<code><a href="#topic+SelectPropFitM">SelectPropFitM</a>()</code>,
<code><a href="#topic+SelectPropFitOnln">SelectPropFitOnln</a>()</code>,
<code><a href="#topic+SelectPropFit">SelectPropFit</a>()</code>,
<code><a href="#topic+SelectSTournament">SelectSTournament</a>()</code>,
<code><a href="#topic+SelectSUS">SelectSUS</a>()</code>,
<code><a href="#topic+SelectTournament">SelectTournament</a>()</code>,
<code><a href="#topic+SelectUniform">SelectUniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
SelectUniformP(fit, NewlFselectGenes()) 
SelectUniformP(fit, NewlFselectGenes(), length(fit)) 
</code></pre>

<hr>
<h2 id='STournament'>Stochastic tournament of size <code>k</code>.</h2><span id='topic+STournament'></span>

<h3>Description</h3>

<p><code>STournament</code> is implemented in two steps:
</p>

<ol>
<li>
<p>A subset of size k of the population is selected with uniform probability.
</p>
</li>
<li>
<p>A gene is selected with probability proportional to fitness.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>STournament(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STournament_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="STournament_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of candidate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
STournament(fit, NewlFselectGenes()) 
</code></pre>

<hr>
<h2 id='testEvalGeneStoch'>Test of incremental mean, variance, and standard deviation.</h2><span id='topic+testEvalGeneStoch'></span>

<h3>Description</h3>

<p>Test of incremental mean, variance, and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testEvalGeneStoch(gene, lF, rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testEvalGeneStoch_+3A_gene">gene</code></td>
<td>
<p>A gene.</p>
</td></tr>
<tr><td><code id="testEvalGeneStoch_+3A_lf">lF</code></td>
<td>
<p>A local function list with a problem environment.</p>
</td></tr>
<tr><td><code id="testEvalGeneStoch_+3A_rep">rep</code></td>
<td>
<p>Number of repeated evaluations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DeJongF4&lt;-DeJongF4Factory()
lF&lt;-NewlFevalGenes(DeJongF4)
g1&lt;-list(evaluated=FALSE, evalFail=FALSE, fit=0, gene1=c(1.0, -1.5))
g10&lt;-testEvalGeneStoch(g1, lF, rep=10)
g10
</code></pre>

<hr>
<h2 id='testSelectGene'>Test a gene selection function</h2><span id='topic+testSelectGene'></span>

<h3>Description</h3>

<p><code>testSelectGene</code> implements 
testing a selection function.
It collects the results of the repeated execution 
of the selection function
given a fitness function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSelectGene(
  fit,
  method = "Uniform",
  howOften = 100,
  lF = NewlFselectGenes(),
  continuation = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testSelectGene_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="testSelectGene_+3A_method">method</code></td>
<td>
<p>String specifying the selection function. 
See <code>SelectGeneFactory</code>.</p>
</td></tr>
<tr><td><code id="testSelectGene_+3A_howoften">howOften</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="testSelectGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="testSelectGene_+3A_continuation">continuation</code></td>
<td>
<p>Convert to index function?</p>
</td></tr>
<tr><td><code id="testSelectGene_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default: <code>FALSE</code>. 
If <code>TRUE</code>, the exection time of the transformation of the selection function
into a quasi-continuation function is printed on the console.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>$fit</code> fitness vector.
</p>
</li>
<li> <p><code>$newPop</code> indices of survivors in fitness vector.
</p>
</li>
<li> <p><code>$time</code> time in seconds. 
</p>
</li>
<li> <p><code>$size</code> population size.
</p>
</li>
<li> <p><code>$method</code> selection method used.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Benchmark Selection Functions: 
<code><a href="#topic+predictSelectTime">predictSelectTime</a>()</code>,
<code><a href="#topic+runOneBenchmark">runOneBenchmark</a>()</code>,
<code><a href="#topic+runSelectBenchmarks">runSelectBenchmarks</a>()</code>,
<code><a href="#topic+selectBenchmark">selectBenchmark</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit1&lt;-rep(10,10)
fit2&lt;-fit1+runif(rep(10,1))
fit3&lt;-sample(100, 10, replace=TRUE)
testSelectGene(fit2, method="Tournament", howOften=100) 
testSelectGene(fit3, method="Tournament", howOften=10) 
</code></pre>

<hr>
<h2 id='ThresholdScaleFitness'>Dispersion Ratio Based Fitness Scaling.</h2><span id='topic+ThresholdScaleFitness'></span>

<h3>Description</h3>

<p>Fitness is transformed by a power function 
<code>fit^lF$ScalingExp</code>.
If <code>lF$ScalingExp</code> is 
</p>

<ul>
<li><p> less than 1: Selection pressure is decreased.
</p>
</li>
<li><p> 1:  Selection pressure remains constant.
</p>
</li>
<li><p> larger than 1: Selection pressure is increased.
</p>
</li>
<li><p> 0:  Fitness is constant. Random selection.
</p>
</li>
<li><p> smaller than 1: Fitness is 
<code>1/fit^lF$ScalingExp</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ThresholdScaleFitness(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThresholdScaleFitness_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="ThresholdScaleFitness_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled fitness vector.
</p>


<h3>See Also</h3>

<p>Other Scaling: 
<code><a href="#topic+ContinuousScaleFitness">ContinuousScaleFitness</a>()</code>,
<code><a href="#topic+DispersionRatio">DispersionRatio</a>()</code>,
<code><a href="#topic+ScaleFitness">ScaleFitness</a>()</code>,
<code><a href="#topic+ScalingFitness">ScalingFitness</a>()</code>
</p>
<p>Other Adaptive Parameter: 
<code><a href="#topic+ContinuousScaleFitness">ContinuousScaleFitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lF&lt;-list()
lF$Offset&lt;-parm(0.0001)
lF$ScalingThreshold&lt;-parm(0.05)
lF$RDM&lt;-parm(1.0)
lF$ScalingExp&lt;-parm(0.5)
lF$ScalingExp2&lt;-parm(2)
fit&lt;-sample(10, 20, replace=TRUE)
fit
ThresholdScaleFitness(fit, lF)
lF$RDM&lt;-parm(1.2)
ThresholdScaleFitness(fit, lF)
lF$RDM&lt;-parm(0.8)
ThresholdScaleFitness(fit, lF)
</code></pre>

<hr>
<h2 id='Timed'>Transformation into a timed function</h2><span id='topic+Timed'></span>

<h3>Description</h3>

<p><code>Timed</code> takes two functions as arguments, 
namely the function whose time and call frequency 
should be measured and a timer object created by <code>newTimer()</code>.
It returns a timed function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Timed(FUN, timer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Timed_+3A_fun">FUN</code></td>
<td>
<p>A function whose run time should be measured.</p>
</td></tr>
<tr><td><code id="Timed_+3A_timer">timer</code></td>
<td>
<p>A timer generated by <code>newTimer()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A timed function.
</p>


<h3>See Also</h3>

<p>Other Performance Measurement: 
<code><a href="#topic+Counted">Counted</a>()</code>,
<code><a href="#topic+newCounter">newCounter</a>()</code>,
<code><a href="#topic+newTimer">newTimer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    test&lt;-function(seconds) {Sys.sleep(seconds)} 
    testTimer&lt;-newTimer()
    testTimed&lt;-Timed(test, testTimer)
    testTimer("Count"); testTimer("TimeUsed")
    testTimed(1); testTimed(2)
    testTimer("Count") 
    testTimer("TimeUsed")
</code></pre>

<hr>
<h2 id='Tournament'>Deterministic tournament of size <code>k</code>.</h2><span id='topic+Tournament'></span>

<h3>Description</h3>

<p><code>Tournament</code> is implemented in two steps:
</p>

<ol>
<li>
<p>A subset of size k of the population is selected with uniform probability.
</p>
</li>
<li>
<p>A gene is selected with probability proportional to fitness.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>Tournament(fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tournament_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="Tournament_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each generation, the worst gene in a population dies.
</p>


<h3>Value</h3>

<p>Index of the best candidate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
Tournament(fit, NewlFselectGenes()) 
</code></pre>

<hr>
<h2 id='TransformSelect'>Convert a selection function into a continuation.</h2><span id='topic+TransformSelect'></span>

<h3>Description</h3>

<p><code>TransformSelect</code> precomputes 
the indices of genes to be selected and
converts the selection function into an access function to the 
next index. 
The access function provides a periodic random 
index stream with a period length of the population size.
In a genetic algorithm with a fixed size population,
this avoids recomputation of the selection functions 
for each gene 
and its mate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransformSelect(fit, lF, SelectFUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformSelect_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="TransformSelect_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
<tr><td><code id="TransformSelect_+3A_selectfun">SelectFUN</code></td>
<td>
<p>Selection function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The motivation for this transformation is: 
</p>

<ol>
<li><p> We avoid the recomputation of potentially 
expensive selection functions.
E.g. In population-based genetic algorithms, 
the selection function
is computed twice per generation instead of 
more than generation times the population size. 
</p>
</li>
<li><p> No additional control flow is needed.
</p>
</li>
<li><p> Dynamic reconfiguration is possible.
</p>
</li>
<li><p> All selection functions have a 
common abstract interface and, 
therefore, can be overloaded by 
specialized concrete implementations.
(Polymorphism).
</p>
</li></ol>
 
<p>The implementation idea is adapted from the
continuation passing style 
in functional programming. See Reynolds, J. C. (1993).
</p>


<h3>Value</h3>

<p>A function with a  state which consists of 
the precomputed gene index 
vector, its <code>length</code>, and a <code>counter</code>. 
The function increments the counter in the state 
of its environment and
returns the precomputed gene index at position 
<code>modulo((counter+1),length)</code> in   
the precomputed index vector in its environment.
The function supports the same interface as a selection function.
</p>


<h3>Parallelization/Distribution</h3>

         
<ol>
<li><p> We use this tranformation if only the evaluation of genes 
should be parallelized/distributed.
</p>
</li>
<li><p> If the complete replication of genes is parallelized, 
this transformation cannot be used in its current form.
The current implementations of the selection functions
can not easily be parallelized.
</p>
</li></ol>



<h3>References</h3>

<p>Reynolds, J. C. (1993):
The discoveries of continuations.
<em>LISP and Symbolic Computation</em> 6, 233-247. 
&lt;doi:10.1007/BF01019459&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit&lt;-sample(10, 15, replace=TRUE)
newselect&lt;-TransformSelect(fit, NewlFselectGenes(), SelectSUS) 
newselect(fit, NewlFselectGenes())
newselect(fit, NewlFselectGenes(), 5)
newselect(fit, NewlFselectGenes(), 10)
newselect(fit, NewlFselectGenes(), 10)
</code></pre>

<hr>
<h2 id='xegaSelectGene'>Package xegaSelectGene.</h2><span id='topic+xegaSelectGene'></span>

<h3>Description</h3>

<p>Selection functions for genetic algorithms.
</p>


<h3>Details</h3>

<p>The <code>selectGene</code> package provides selection and scaling functions
for genetic algorithms. 
All functions of this package are independent of the gene 
representation. 
</p>

<ul>
<li><p> Scaling functions and dispersion measures are in scaling.R
</p>
</li>
<li><p> Selection functions are in selectGene.R.
For selection functions, a transformation to index access 
functions is provided (a limited form of function continuation).
</p>
</li>
<li><p> Benchmark functions for selection functions are in 
selectGeneBenchmark.R.
Except for uniform selection, the continuation form of
selection functions should be used.
</p>
</li>
<li><p> Evaluation functions are in evalGene.R.
</p>
</li>
<li><p> Counting and timing of function executions  
are provided by transformation functions in timer.R
</p>
</li>
<li><p> Problem environments for examples and unit tests for
</p>

<ul>
<li><p> function optimization:
DeJongF4.R (stochastic functions) and Parabola2D.R 
(delayed execution for benchmarking of parallelism,
deterministic function,
deterministic function with early termination check, 
function with random failures)
</p>
</li>
<li><p> combinatorial optimization: 
newTSP.R (for the traveling salesman problem).
</p>
</li>
<li><p> boolean function learning:
newXOR.R (for the XOR problem).
</p>
</li></ul>

</li></ul>



<h3>Interface Scaling Functions</h3>

<p>All scaling functions must implement
the following abstract interface:
</p>
<p><code>function name</code>(<code>fit</code>, <code>lF</code>)
</p>
<p><strong>Parameters</strong>
</p>

<ul>
<li> <p><code>fit</code>  A fitness vector. 
</p>
</li>
<li> <p><code>lF</code>   Local configuration.
</p>
</li></ul>

<p><strong>Return Value</strong>
</p>
<p>Scaled fitness vector.
</p>


<h3>Interface Dispersion Measures</h3>

<p>All dispersion measure functions must implement
the following abstract interface:
</p>
<p><code>function name</code>(<code>popstatvec</code>)
</p>
<p><strong>Parameters</strong>
</p>

<ul>
<li> <p><code>popstatvec</code>  Vector of population statistics. 
</p>
<p>The internal state of the genetic algorithm is described 
by a matrix of the history of population statistics.
Each row consists of 8 population statistics
(mean, min, Q1, median, Q3, max, var, mad). 
A row is a vector of population statistics.  
</p>
</li></ul>

<p><strong>Return Value</strong>
</p>
<p>Dispersion measure (real).
</p>


<h3>Interface Selection Functions</h3>

<p>All selection functions must implement
the following abstract interface:
</p>
<p><code>function name</code>(<code>fit</code>, <code>lF</code>, <code>size</code>)
</p>
<p><strong>Parameters</strong>
</p>

<ul>
<li> <p><code>fit</code>  a vector of fitness values.
</p>
</li>
<li> <p><code>lF</code>   a local function list.
</p>
</li>
<li> <p><code>size</code> the number of indices returned.
</p>
</li></ul>

<p><strong>Return Value</strong>
</p>
<p>A vector of indices of length <code>size</code>.
</p>
<p>All selection functions are implemented
WITHOUT a default assignment to <code>lF</code>.
</p>
<p>A missing configuration should raise an error!
</p>
<p>The default value of <code>size</code> is <code>1</code>.
</p>


<h3>Constants</h3>

<p>Some scaling and selection functions use constants which should 
be configured. 
We handle these constants by 
constant functions created by <code>parm(constant)</code>.
We store all of these functions in the list of 
local functions <code>lF</code>.
The rationale is to reduce the number of parameters
of selection functions and to provide a uniform 
interface for selection functions.
</p>


<h3>Table of Scaling Constants</h3>


<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong>   </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Offset           </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> ScaleFitness </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$ScalingExp       </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> ScalingFitness,  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> ThresholdScaleFitness  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$ScalingExp2      </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> ThresholdScaleFitness  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$ScalingThreshold </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> ThresholdScaleFitness  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$RDMWeight        </td><td style="text-align: center;"> 1.0              </td><td style="text-align: left;"> ContinuousScaleFitness  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$DRMin            </td><td style="text-align: center;"> 0.5              </td><td style="text-align: left;"> DispersionRatio  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$DRMax            </td><td style="text-align: center;"> 2.0              </td><td style="text-align: left;"> DispersionRatio  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$ScalingDelay     </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> DispersionRatio  </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;"> 
<strong>State Variable</strong> </td><td style="text-align: center;"> <strong>Start Value</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$RDM           </td><td style="text-align: center;"> 1.0                </td><td style="text-align: left;"> ThresholdScaleFitness </td>
</tr>
<tr>
 <td style="text-align: right;">
                 </td><td style="text-align: center;">                    </td><td style="text-align: left;"> ContinuousScaleFitness </td>
</tr>
<tr>
 <td style="text-align: right;">
                 </td><td style="text-align: center;">                    </td><td style="text-align: left;"> xega::RunGA </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Table of Selection Constants</h3>


<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$SelectionContinuation </td><td style="text-align: center;"> TRUE </td><td style="text-align: left;"> xegaPopulation::xegaNextPopulation </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$Offset           </td><td style="text-align: center;"> 1                </td><td style="text-align: left;"> SelectPropFitOnLn </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectPropFit </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectPropFitM </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectPropFitDiffOnLn </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectPropFitDiff </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SUS </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectLinearRankTSR </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$eps              </td><td style="text-align: center;"> 0.01             </td><td style="text-align: left;"> SelectPropFitDiffM </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$TournamentSize   </td><td style="text-align: center;"> 2                </td><td style="text-align: left;"> Tournament </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectTournament </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> STournament </td>
</tr>
<tr>
 <td style="text-align: right;">
                    </td><td style="text-align: center;">                  </td><td style="text-align: left;"> SelectSTournament </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$SelectionBias    </td><td style="text-align: center;"> 1.5              </td><td style="text-align: left;"> SelectLRSelective </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$MaxTSR           </td><td style="text-align: center;"> 1.5              </td><td style="text-align: left;"> SelectLinearRankTSR 
</td>
</tr>

</table>



<h3>Parallel/Distributed Execution</h3>

<p>All selection functions in this package return
</p>

<ol>
<li><p> the index of a selected gene.
The configured selection function is executed each time
a gene must be selected in the gene replication process.
This allows a parallelization/distribution of the
complete gene replication process and the fitness evaluation.
However, the price to pay is a recomputation of the selection
algorithms for each gene and each mate (which may be costly).
The execution time of Baker's SUS function explodes
when used in this way.
</p>
</li>
<li><p> a vector of indices of the selected genes.
We compute
a vector of indices for genes and their mates,
and we replace the selection function with a
quasi-continuation function
with precomputed indices
which when called, returns the next index.
The selection computation is executed once for each generation
without costly recomputation.
The cost of selecting a gene and its mate is the cost of indexing 
an integer in a vector.
This version is faster for almost all selection functions
(Sequential computation).
</p>
<p>The parallelization of quasi-continuation function is not yet implemented. 
</p>
</li></ol>



<h3>Constant Functions for Configuration</h3>

<p>The following constant functions are expected to be in the local function list lF.
</p>

<ul>
<li> <p><code>Offset()</code> in <code>SelectPropFit</code>:
Since all fitness values must be larger than 0,
in case of negative fitness values, <code>Offset()</code> 
is the value of the minimum fitness value (default: 1).
</p>
</li>
<li> <p><code>Eps()</code> in <code>SelectPropFitDiff</code>:
<code>Eps()</code> is a very small value to eliminate 
differences of 0.
</p>
</li>
<li> <p><code>TournamentSize()</code> in <code>SelectTournament</code>:
Specifies the size of the tournament. Per default: 2.
</p>
</li>
<li> <p><code>SelectionBias()</code> in <code>SelectLinearRank</code>.
This constant must be larger than 1.0 and usually
should be set at most to 2.0.
Increasing <code>SelectionBias()</code>
increases selection pressure.
Beyond 2.0, there is the danger of premature convergence.
</p>
</li></ul>



<h3>Performance Measurement</h3>

<p>The file <code>Timer.R</code>:  Functions for timing and counting.
</p>
<p>The file <code>selectGeneBenchmark.R</code>: A benchmark of selection functions.
</p>


<h3>Interface Function Evaluation and Methods</h3>

<p>All evaluation functions must implement
the following abstract interface:
</p>
<p><code>function name</code>(<code>gene</code>, <code>lF</code>)
</p>
<p><strong>Parameters</strong>
</p>

<ul>
<li> <p><code>gene</code>  a gene. 
</p>
</li>
<li> <p><code>lF</code>   a local function list.
</p>
</li></ul>

<p><strong>Return Value</strong>
</p>
<p>A gene.
</p>
<p>The file <code>evalGene.R</code> contains different function evaluation methods.
</p>

<ol>
<li> <p><code>EvalGeneU</code> evaluates a gene unconditionally. (Default.)
</p>
</li>
<li> <p><code>EvalGeneR</code> evaluates a gene unconditionally
and allows the repair of the gene by the decoder.
</p>
</li>
<li> <p><code>EvalGeneDet</code> memoizes the evaluation of a gene in the 
in the gene. Genes are evaluated only once.
This leads to a performance improvement for
deterministic functions.
</p>
</li>
<li> <p><code>EvalGeneStoch</code> computes an incremental average of 
the value of a gene.
The average converges to the true value as the number 
of repeated evaluations of a gene increases.
</p>
</li></ol>



<h3>Gene Representation</h3>

<p>A gene is a named list:
</p>

<ul>
<li><p> $gene1      the gene.
</p>
</li>
<li><p> $fit        the fitness value of the gene
(for EvalGeneDet and EvalGeneU) or
the mean fitness (for stochastic functions
evaluated with EvalGeneStoch).
</p>
</li>
<li><p> $evaluated  has the gene been evaluated?
</p>
</li>
<li><p> $evalFail   has the evaluation of the gene failed?
</p>
</li>
<li><p> $var        the cumulative variance of the fitness 
of all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $sigma      the standard deviation of the fitness of 
all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $obs        the number of evaluations of a gene.
(For stochastic functions)
</p>
</li></ul>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation-free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population-related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split into a representation-independent and 
a representation-dependent part:
</p>

<ol>
<li> 
<p>The representation-indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, and profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation-dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation-free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler, and 
<code>xegaDerivationTrees</code> is an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>&lt;https://github.com/ageyerschulz/xegaSelectGene&gt;
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaSelectGene')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
