<!DOCTYPE html><html><head><title>Help for package conformalInference.multi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conformalInference.multi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bikeMi'><p>Log of all bike rentals in Milan in 2016 form January to March</p></a></li>
<li><a href='#computing_s_regression'><p>Computing modulation function for residuals.</p></a></li>
<li><a href='#conformal.multidim.full'><p>Full Conformal Prediction Regions, Multivariate Response</p></a></li>
<li><a href='#conformal.multidim.jackplus'><p>Multivariate Response Jackknife + Prediction Regions</p></a></li>
<li><a href='#conformal.multidim.msplit'><p>Multi Split Conformal Prediction Regions with Multivariate Response</p></a></li>
<li><a href='#conformal.multidim.split'><p>Split conformal prediction intervals with Multivariate Response</p></a></li>
<li><a href='#conformalInference.multi-package'><p>Conformal Inference Tools for Regression with Multivariate Response</p></a></li>
<li><a href='#elastic.funs'><p>Elastic Net, Lasso, Ridge Regression Training and Prediction Functions</p></a></li>
<li><a href='#lm_multi'><p>Linear Modeling of Multivariate Response</p></a></li>
<li><a href='#mean_multi'><p>Mean of Multivariate Response</p></a></li>
<li><a href='#plot_multidim'><p>Plot Confidence Regions obtained with Split Conformal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conformal Inference Tools for Regression with Multivariate
Response</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>It computes full conformal, split conformal and multi split
    conformal prediction regions when the response variable is
    multivariate (i.e. dimension is greater than one). Moreover, the
    package also contain plot functions to visualize the output of the
    full and split conformal functions. 
    To guarantee consistency, the package structure mimics the univariate 'conformalInference'
    package of professor Ryan Tibshirani.
    The main references for the code are: 
    Lei et al. (2016) &lt;<a href="https://arxiv.org/abs/1604.04173">arXiv:1604.04173</a>&gt;,
    Diquigiovanni, Fontana, and Vantini (2021) &lt;<a href="https://arxiv.org/abs/2102.06746">arXiv:2102.06746</a>&gt;, 
    Diquigiovanni, Fontana, and Vantini (2021) &lt;<a href="https://arxiv.org/abs/2106.01792">arXiv:2106.01792</a>&gt;,
    Solari, and Djordjilovic (2021) &lt;<a href="https://arxiv.org/abs/2103.00627">arXiv:2103.00627</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ryantibs/conformal">https://github.com/ryantibs/conformal</a>,
<a href="https://github.com/paolo-vergo/conformalInference.multi">https://github.com/paolo-vergo/conformalInference.multi</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>future (&ge; 1.23.0), future.apply (&ge; 1.8.1), ggplot2 (&ge;
3.3.5), glmnet, gridExtra (&ge; 2.3), hrbrthemes, stats,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, pbapply</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-16 16:16:11 UTC; paolo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacopo Diquigiovanni [aut, ths],
  Matteo Fontana [aut, ths],
  Aldo Solari [aut, ths],
  Simone Vantini [aut, ths],
  Paolo Vergottini [aut, cre],
  Ryan Tibshirani [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Vergottini &lt;paolo.vergottini@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-16 16:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bikeMi'>Log of all bike rentals in Milan in 2016 form January to March</h2><span id='topic+bikeMi'></span>

<h3>Description</h3>

<p>A dataset containing the log of all the bike trips in Milan (using the BikeMi
service), in the period from 25th of January to the 6th of March from Duomo to Duomo,
as well as meteorological data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bikeMi
</code></pre>


<h3>Format</h3>

<p>A data frame with 41 rows and 6 variables:
</p>

<dl>
<dt>start</dt><dd><p>number of trips started in Duomo a given day</p>
</dd>
<dt>end</dt><dd><p>number of trips ended in Duomo a given day</p>
</dd>
<dt>we</dt><dd><p>is weekend?If true, than we is 1</p>
</dd>
<dt>rain</dt><dd><p>mean amount of rain during the day</p>
</dd>
<dt>dtemp</dt><dd><p>difference between average temperature of the day and of the period</p>
</dd>
<dt>we_rain</dt><dd><p>interaction between weekend and rain</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.mate.polimi.it/biblioteca/add/qmox/19-2019.pdf">https://www.mate.polimi.it/biblioteca/add/qmox/19-2019.pdf</a>
</p>

<hr>
<h2 id='computing_s_regression'>Computing modulation function for residuals.</h2><span id='topic+computing_s_regression'></span>

<h3>Description</h3>

<p>It computes values for local scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computing_s_regression(mat_residual, type, alpha, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computing_s_regression_+3A_mat_residual">mat_residual</code></td>
<td>
<p>A vector of the residuals obtained via multivariate modeling.</p>
</td></tr>
<tr><td><code id="computing_s_regression_+3A_type">type</code></td>
<td>
<p>A string indicating the type of modulation function chosen.
The alternatives are &quot;identity&quot;,&quot;st-dev&quot;,&quot;alpha-max&quot;.</p>
</td></tr>
<tr><td><code id="computing_s_regression_+3A_alpha">alpha</code></td>
<td>
<p>The value of the confidence interval.</p>
</td></tr>
<tr><td><code id="computing_s_regression_+3A_tau">tau</code></td>
<td>
<p>A number between 0 and 1 used for the randomized version of the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an helper function for <code><a href="#topic+conformal.multidim.split">conformal.multidim.split</a></code>  and
<code><a href="#topic+conformal.multidim.msplit">conformal.multidim.msplit</a></code>
</p>


<h3>Value</h3>

<p>It returns local scoring values for the residuals.
</p>


<h3>References</h3>

<p>&quot;Conformal Prediction Bands for Multivariate Functional Data&quot;
by Diquigiovanni, Fontana, Vantini (2021) &lt;arXiv:2106.01792&gt;.
</p>

<hr>
<h2 id='conformal.multidim.full'>Full Conformal Prediction Regions, Multivariate Response</h2><span id='topic+conformal.multidim.full'></span>

<h3>Description</h3>

<p>Compute prediction intervals using full conformal inference with multivariate
response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conformal.multidim.full(
  x,
  y,
  x0,
  train.fun,
  predict.fun,
  alpha = 0.1,
  mad.train.fun = NULL,
  mad.predict.fun = NULL,
  score = "l2",
  s.type = "st-dev",
  num.grid.pts.dim = 100,
  grid.factor = 1.25,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformal.multidim.full_+3A_x">x</code></td>
<td>
<p>Matrix of features, of dimension (say) n x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_y">y</code></td>
<td>
<p>Matrix of responses, of length (say) n X q.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_x0">x0</code></td>
<td>
<p>Matrix of features, each row being a point at which we want to
form a prediction interval, of dimension (say) n0 x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_train.fun">train.fun</code></td>
<td>
<p>A function to perform model training, i.e., to produce an
estimator of E(Y|X), the conditional expectation of the response variable
Y given features X. Its input arguments should be x: matrix of features,
y: vector of responses, and out: the output produced by a previous call
to train.fun, at the <em>same</em> features x. The function train.fun may
(optionally) leverage this returned output for efficiency purposes. See
details below.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_predict.fun">predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
responses at new feature values. Its input arguments should be out: output
produced by train.fun, and newx: feature values at which we want to make
predictions.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_alpha">alpha</code></td>
<td>
<p>Miscoverage level for the prediction intervals, i.e., intervals
with coverage 1-alpha are formed. Default for alpha is 0.1.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_mad.train.fun">mad.train.fun</code></td>
<td>
<p>A function to perform training on the absolute residuals
i.e., to produce an estimator of E(R|X) where R is the absolute residual
R = |Y - m(X)|, and m denotes the estimator produced by train.fun.
This is used to scale the conformal score, to produce a prediction interval
with varying local width. The input arguments to mad.train.fun should be
x: matrix of features, y: vector of absolute residuals, and out: the output
produced by a previous call to mad.train.fun, at the <em>same</em> features
x. The function mad.train.fun may (optionally) leverage this returned
output for efficiency purposes. See details below. The default for
mad.train.fun is NULL, which means that no training is done on the absolute
residuals, and the usual (unscaled) conformal score is used. Note that if
mad.train.fun is non-NULL, then so must be mad.predict.fun (next).</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_mad.predict.fun">mad.predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
absolute residuals at new feature values. Its input arguments should be
out: output produced by mad.train.fun, and newx: feature values at which we
want to make predictions. The default for mad.predict.fun is NULL, which
means that no local scaling is done for the conformal score, i.e., the
usual (unscaled) conformal score is used.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_score">score</code></td>
<td>
<p>Method to compute nonconformity measure in the multivariate regime.
The user can choose between squared l^2 norm of the residual,
mahalanobis depth of the residual, the max norm of the residual.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_s.type">s.type</code></td>
<td>
<p>The type of modulation function.
Currently we have 3 options: &quot;identity&quot;,&quot;st-dev&quot;. Default is &quot;st-dev&quot;</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_num.grid.pts.dim">num.grid.pts.dim</code></td>
<td>
<p>Number of grid points per dimension used when forming the conformal
intervals (each num.grid.pts.dim^q points is a trial point). Default is
100.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_grid.factor">grid.factor</code></td>
<td>
<p>Expansion factor used to define the grid for the conformal
intervals, i.e., the grid points are taken to be equally spaced in between
-grid.factor x max(abs(y)) and grid.factor x max(abs(y)). Default is 1.25. In
this case (and with exchangeable data, thus unity weights) the restriction
of the trial values to this range costs at most 1/(n+1) in coverage. See
details below.</p>
</td></tr>
<tr><td><code id="conformal.multidim.full_+3A_verbose">verbose</code></td>
<td>
<p>Should intermediate progress be printed out? Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to eventual computational overload the function is restricted to a bivariate y.
</p>
<p>This function is based on the package <code><a href="future.apply.html#topic+future.apply">future.apply</a></code> to
perform parallelisation.
</p>
<p>If the data (training and test) are assumed to be exchangeable, the basic
assumption underlying conformal prediction, then the probability that a new
response value will lie outside of (-max(abs(y)), max(abs(y))), where y is
the vector of training responses, is 1/(n+1).  Thus the restriction of the
trials values to (-grid.factor x max(abs(y)), grid.factor x max(abs(y))), for
all choices grid.factor &gt;= 1, will lead to a loss in coverage of at most
1/(n+1). This was also noted in &quot;Trimmed Conformal Prediction for
High-Dimensional Models&quot; by Chen, Wang, Ha, Barber (2016) &lt;arXiv:1611.09933&gt;
(who use this basic fact as motivation for proposing more refined trimming methods).
</p>


<h3>Value</h3>

<p>A list with the following components: pred, valid_points. The first
is a matrix of dimension n0 x q, while the second is a list of length n0, containing in each
position a matrix of varying number of rows (depending on which points where accepted by
the method) and with a number of columns equal to q + 1. Indeed, valid_points contains the
selected points on the y-grid as well as the p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conformal.multidim.split">conformal.multidim.split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=25
p=4
q=2


mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]

n0&lt;-nrow(y0)
q&lt;-ncol(y)


fun=mean_multi()

#################################### FULL CONFORMAL

final.full=conformal.multidim.full(x, y, x0, fun$train.fun,
                                fun$predict.fun, score="l2",
                                num.grid.pts.dim=5, grid.factor=1.25,
                                verbose=FALSE)

ppp&lt;-plot_multidim(final.full)

</code></pre>

<hr>
<h2 id='conformal.multidim.jackplus'>Multivariate Response Jackknife + Prediction Regions</h2><span id='topic+conformal.multidim.jackplus'></span>

<h3>Description</h3>

<p>Compute prediction regions using multivariate Jackknife + inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conformal.multidim.jackplus(x, y, x0, train.fun, predict.fun, alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformal.multidim.jackplus_+3A_x">x</code></td>
<td>
<p>The feature variables, a matrix n x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.jackplus_+3A_y">y</code></td>
<td>
<p>The matrix of multivariate responses (dimension n x q)</p>
</td></tr>
<tr><td><code id="conformal.multidim.jackplus_+3A_x0">x0</code></td>
<td>
<p>The new points to evaluate, a matrix of dimension n0 x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.jackplus_+3A_train.fun">train.fun</code></td>
<td>
<p>A function to perform model training, i.e., to produce an
estimator of E(Y|X), the conditional expectation of the response variable
Y given features X. Its input arguments should be x: matrix of features,
and y: matrix of responses.</p>
</td></tr>
<tr><td><code id="conformal.multidim.jackplus_+3A_predict.fun">predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
responses at new feature values. Its input arguments should be out: output
produced by train.fun, and newx: feature values at which we want to make
predictions.</p>
</td></tr>
<tr><td><code id="conformal.multidim.jackplus_+3A_alpha">alpha</code></td>
<td>
<p>Miscoverage level for the prediction intervals, i.e., intervals
with coverage 1-alpha are formed. Default for alpha is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is an extension of the univariate approach to jackknife +
inference to a multivariate context, exploiting the concept of depth measures.
</p>
<p>This function is based on the package future.apply to
perform parallelisation. If this package is not installed, then the function
will abort.
</p>


<h3>Value</h3>

<p>A list with length n0, giving the lower and upper bounds for each observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One instance

n=50
p=3
q=2
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=matrix(x[n,],nrow=1)
y0=matrix(y[n,],nrow=1)
n0&lt;-nrow(y0)
funs=lm_multi()

sol&lt;-conformal.multidim.jackplus(x,y,x,train.fun = funs$train.fun,
                                      predict.fun = funs$predict.fun,alpha=0.05)

sol



</code></pre>

<hr>
<h2 id='conformal.multidim.msplit'>Multi Split Conformal Prediction Regions with Multivariate Response</h2><span id='topic+conformal.multidim.msplit'></span>

<h3>Description</h3>

<p>Compute prediction intervals using Multi Split conformal inference with
multivariate response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conformal.multidim.msplit(
  x,
  y,
  x0,
  train.fun,
  predict.fun,
  alpha = 0.1,
  split = NULL,
  seed = FALSE,
  randomized = FALSE,
  seed.rand = FALSE,
  verbose = FALSE,
  rho = NULL,
  score = "max",
  s.type = "st-dev",
  B = 100,
  lambda = 0,
  tau = 0.1,
  mad.train.fun = NULL,
  mad.predict.fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformal.multidim.msplit_+3A_x">x</code></td>
<td>
<p>The feature variables, a matrix nxp.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_y">y</code></td>
<td>
<p>The matrix of multivariate responses (dimension nxq)</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_x0">x0</code></td>
<td>
<p>The new points to evaluate, a matrix of dimension n0xp.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_train.fun">train.fun</code></td>
<td>
<p>A function to perform model training, i.e., to produce an
estimator of E(Y|X), the conditional expectation of the response variable
Y given features X. Its input arguments should be x: matrix of features,
and y: matrix of responses.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_predict.fun">predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
responses at new feature values. Its input arguments should be out: output
produced by train.fun, and newx: feature values at which we want to make
predictions.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_alpha">alpha</code></td>
<td>
<p>Miscoverage level for the prediction intervals, i.e., intervals
with coverage 1-alpha are formed. Default for alpha is 0.1.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_split">split</code></td>
<td>
<p>Indices that define the data-split to be used (i.e., the indices
define the first half of the data-split, on which the model is trained).
Default is NULL, in which case the split is chosen randomly.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_seed">seed</code></td>
<td>
<p>Integer to be passed to set.seed before defining the random
data-split to be used. Default is FALSE, which effectively sets no seed.
If both split and seed are passed, the former takes priority and the latter
is ignored.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_randomized">randomized</code></td>
<td>
<p>Should the randomized approach be used? Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_seed.rand">seed.rand</code></td>
<td>
<p>The seed for the randomized version. Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_verbose">verbose</code></td>
<td>
<p>Should intermediate progress be printed out? Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_rho">rho</code></td>
<td>
<p>Split proportion between training and calibration set.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_score">score</code></td>
<td>
<p>The chosen score for the split conformal function.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_s.type">s.type</code></td>
<td>
<p>The type of modulation function.
Currently we have 3 options: &quot;identity&quot;,&quot;st-dev&quot;,&quot;alpha-max&quot;. Default is &quot;std-dev&quot;</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_b">B</code></td>
<td>
<p>Number of repetitions. Default is 100.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter. Default is 0.</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_tau">tau</code></td>
<td>
<p>It is a smoothing parameter:
tau=1-1/B  Bonferroni intersection method
tau=0 unadjusted intersection
Default is 1-(B+1)/(2*B).</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_mad.train.fun">mad.train.fun</code></td>
<td>
<p>A function to perform training on the absolute residuals
i.e., to produce an estimator of E(R|X) where R is the absolute residual
R = |Y - m(X)|, and m denotes the estimator produced by train.fun.
This is used to scale the conformal score, to produce a prediction interval
with varying local width. The input arguments to mad.train.fun should be
x: matrix of features, y: vector of absolute residuals, and out: the output
produced by a previous call to mad.train.fun, at the <em>same</em> features
x. The function mad.train.fun may (optionally) leverage this returned
output for efficiency purposes. See details below. The default for
mad.train.fun is NULL, which means that no training is done on the absolute
residuals, and the usual (unscaled) conformal score is used. Note that if
mad.train.fun is non-NULL, then so must be mad.predict.fun (next).</p>
</td></tr>
<tr><td><code id="conformal.multidim.msplit_+3A_mad.predict.fun">mad.predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
absolute residuals at new feature values. Its input arguments should be
out: output produced by mad.train.fun, and newx: feature values at which we
want to make predictions. The default for mad.predict.fun is NULL, which
means that no local scaling is done for the conformal score, i.e., the
usual (unscaled) conformal score is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is an extension of the univariate approach to Multi Split
conformal inference to a multivariate context, exploiting the concept of depth measure.
</p>
<p>This function is based on the package <code><a href="future.apply.html#topic+future.apply">future.apply</a></code> to
perform parallelization.
</p>


<h3>Value</h3>

<p>A list with length n0, giving the lower and upper bounds for each observation.
</p>


<h3>References</h3>

<p>&quot;Multi Split Conformal Prediction&quot; by Solari, Djordjilovic (2021) &lt;arXiv:2103
.00627&gt; is the baseline for the univariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(12345)

  n=200
  p=4
  q=2
  mu=rep(0,p)
  x = mvtnorm::rmvnorm(n, mu)
  beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
  y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
  x0=matrix(x[n,],nrow=1)
  y0=matrix(y[n,],nrow=1)
  n0&lt;-nrow(y0)
  q&lt;-ncol(y)
  B=100
  funs=lm_multi()


  sol&lt;-conformal.multidim.msplit(x,y, x0, train.fun = funs$train.fun,
                                            predict.fun = funs$predict.fun, alpha=0.05,
                                            split=NULL, seed=FALSE, randomized=FALSE,
                                 seed.rand=FALSE,
                                            verbose=FALSE, rho=NULL,score = "max",
                                            s.type = "st-dev",B=B,lambda=0,
                                            tau = 0.1,mad.train.fun = NULL,
                                            mad.predict.fun = NULL)

sol
</code></pre>

<hr>
<h2 id='conformal.multidim.split'>Split conformal prediction intervals with Multivariate Response</h2><span id='topic+conformal.multidim.split'></span>

<h3>Description</h3>

<p>Compute prediction intervals using split conformal inference with multivariate
response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conformal.multidim.split(
  x,
  y,
  x0,
  train.fun,
  predict.fun,
  alpha = 0.1,
  split = NULL,
  seed = FALSE,
  randomized = FALSE,
  seed.rand = FALSE,
  verbose = FALSE,
  rho = 0.5,
  score = "l2",
  s.type = "st-dev",
  mad.train.fun = NULL,
  mad.predict.fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformal.multidim.split_+3A_x">x</code></td>
<td>
<p>The feature variables, a matrix n x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_y">y</code></td>
<td>
<p>The matrix of multivariate responses (dimension n x q)</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_x0">x0</code></td>
<td>
<p>The new points to evaluate, a matrix of dimension n0 x p.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_train.fun">train.fun</code></td>
<td>
<p>A function to perform model training, i.e., to produce an
estimator of E(Y|X), the conditional expectation of the response variable
Y given features X. Its input arguments should be x: matrix of features,
and y: matrix of responses.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_predict.fun">predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
responses at new feature values. Its input arguments should be out: output
produced by train.fun, and newx: feature values at which we want to make
predictions.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_alpha">alpha</code></td>
<td>
<p>Miscoverage level for the prediction intervals, i.e., intervals
with coverage 1-alpha are formed. Default for alpha is 0.1.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_split">split</code></td>
<td>
<p>Indices that define the data-split to be used (i.e., the indices
define the first half of the data-split, on which the model is trained).
Default is NULL, in which case the split is chosen randomly.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_seed">seed</code></td>
<td>
<p>Integer to be passed to set.seed before defining the random
data-split to be used. Default is FALSE, which effectively sets no seed.
If both split and seed are passed, the former takes priority and the latter
is ignored.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_randomized">randomized</code></td>
<td>
<p>Should the randomized approach be used? Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_seed.rand">seed.rand</code></td>
<td>
<p>The seed for the randomized version. Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_verbose">verbose</code></td>
<td>
<p>Should intermediate progress be printed out? Default is FALSE.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_rho">rho</code></td>
<td>
<p>Split proportion between training and calibration set.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_score">score</code></td>
<td>
<p>The non-conformity measure. It can either be &quot;max&quot;, &quot;l2&quot;, &quot;mahalanobis&quot;.
The default is &quot;l2&quot;.</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_s.type">s.type</code></td>
<td>
<p>The type of modulation function.
Currently we have 3 options: &quot;identity&quot;,&quot;st-dev&quot;,&quot;alpha-max&quot;. Default is &quot;st-dev&quot;</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_mad.train.fun">mad.train.fun</code></td>
<td>
<p>A function to perform training on the absolute residuals
i.e., to produce an estimator of E(R|X) where R is the absolute residual
R = |Y - m(X)|, and m denotes the estimator produced by train.fun.
This is used to scale the conformal score, to produce a prediction interval
with varying local width. The input arguments to mad.train.fun should be
x: matrix of features, y: vector of absolute residuals, and out: the output
produced by a previous call to mad.train.fun, at the <em>same</em> features
x. The function mad.train.fun may (optionally) leverage this returned
output for efficiency purposes. See details below. The default for
mad.train.fun is NULL, which means that no training is done on the absolute
residuals, and the usual (unscaled) conformal score is used. Note that if
mad.train.fun is non-NULL, then so must be mad.predict.fun (next).</p>
</td></tr>
<tr><td><code id="conformal.multidim.split_+3A_mad.predict.fun">mad.predict.fun</code></td>
<td>
<p>A function to perform prediction for the (mean of the)
absolute residuals at new feature values. Its input arguments should be
out: output produced by mad.train.fun, and newx: feature values at which we
want to make predictions. The default for mad.predict.fun is NULL, which
means that no local scaling is done for the conformal score, i.e., the
usual (unscaled) conformal score is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the two mad functions are provided they take precedence over the
s.type parameter,
and they force a local scoring via the mad function predicted values.
</p>


<h3>Value</h3>

<p>A list with the following components: x0,pred,k_s,s.type,s,alpha,randomized,tau,
average_width,lo,up. In particular pred, lo, up are the matrices of
dimension n0 x q, k_s is a scalar, s.type is a string, s is a vector of length q,
alpha is a scalar between 0 and 1, randomized is a logical value,
tau is a scalar between 0 and 1,and average_width is a positive scalar.
</p>


<h3>References</h3>

<p>The s_regression and the &quot;max&quot; score are taken from
&quot;Conformal Prediction Bands
for Multivariate Functional Data&quot; by Diquigiovanni, Fontana, Vantini (2021).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conformal.multidim.full">conformal.multidim.full</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=50
p=4
q=2

mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]

n0&lt;-nrow(y0)
q&lt;-ncol(y)

fun=mean_multi()

final.point = conformal.multidim.split(x,y,x0, fun$train.fun, fun$predict.fun,
                             alpha=0.1,
                                split=NULL, seed=FALSE, randomized=FALSE,seed.rand=FALSE,
                                verbose=FALSE, rho=0.5,score ="l2",s.type="st-dev")

ppp2&lt;-plot_multidim(final.point)

</code></pre>

<hr>
<h2 id='conformalInference.multi-package'>Conformal Inference Tools for Regression with Multivariate Response</h2><span id='topic+conformalInference.multi'></span><span id='topic+conformalInference.multi-package'></span>

<h3>Description</h3>

<p>It computes full conformal, split conformal and multi split conformal prediction
regions when the response variable is multivariate (i.e. dimension is greater than one).
Moreover, the package also contain plot functions to visualize the output of the full and
split conformal functions.
</p>


<h3>Details</h3>

<p>Conformal inference is a framework for converting any pre-chosen
estimator of
the regression function into prediction regions with finite-sample
validity, under essentially no assumptions on the data-generating process
(aside from the the assumption of i.i.d. observations). The main functions
in this package for computing such prediction regions are
<code><a href="#topic+conformal.multidim.split">conformal.multidim.split</a></code> , i.e. a single split, and
<code><a href="#topic+conformal.multidim.msplit">conformal.multidim.msplit</a></code> , i.e. joining B splits.
To guarantee consistency, the package structure mimics the univariate
'conformalInference' package of professor Ryan Tibshirani.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paolo Vergottini <a href="mailto:paolo.vergottini@gmail.com">paolo.vergottini@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jacopo Diquigiovanni [thesis advisor]
</p>
</li>
<li><p> Matteo Fontana <a href="mailto:matteo.fontana@ec.europa.eu">matteo.fontana@ec.europa.eu</a> [thesis advisor]
</p>
</li>
<li><p> Aldo Solari [thesis advisor]
</p>
</li>
<li><p> Simone Vantini [thesis advisor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Ryan Tibshirani [contributor]
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>&quot;Distribution-Free Predictive Inference For Regression&quot; by Lei et al. (2016) &lt;arXiv:1604.04173&gt;
</p>
</li>
<li><p>&quot;Conformal Prediction Bands
for Multivariate Functional Data&quot; by Diquigiovanni, Fontana, and Vantini (2021)
&lt;arXiv:2106.01792&gt;
</p>
</li>
<li><p>&quot;The Importance of Being a Band: Finite-Sample Exact Distribution-Free
Prediction Sets for Functional Data&quot; by Diquigiovanni, Fontana, and Vantini (2021) &lt;arXiv:2102.06746&gt;
</p>
</li>
<li><p>&quot;Multi Split Conformal Prediction&quot; by Solari, and Djordjilovic (2021) &lt;arXiv:2103.00627&gt;
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ryantibs/conformal">https://github.com/ryantibs/conformal</a>
</p>
</li>
<li> <p><a href="https://github.com/paolo-vergo/conformalInference.multi">https://github.com/paolo-vergo/conformalInference.multi</a>
</p>
</li></ul>


<hr>
<h2 id='elastic.funs'>Elastic Net, Lasso, Ridge Regression Training and Prediction Functions</h2><span id='topic+elastic.funs'></span><span id='topic+lasso.funs'></span><span id='topic+ridge.funs'></span>

<h3>Description</h3>

<p>Construct training and prediction functions for the elastic net, the lasso,
or ridge regression, based on the <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> package, over a
sequence of (given or internally computed) lambda values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.funs(
  gamma = 0.5,
  standardize = TRUE,
  intercept = TRUE,
  lambda = NULL,
  nlambda = 50,
  lambda.min.ratio = 1e-04,
  cv.rule = c("min", "1se")
)

lasso.funs(
  standardize = TRUE,
  intercept = TRUE,
  lambda = NULL,
  nlambda = 50,
  lambda.min.ratio = 1e-04,
  cv.rule = c("min", "1se")
)

ridge.funs(
  standardize = TRUE,
  intercept = TRUE,
  lambda = NULL,
  nlambda = 50,
  lambda.min.ratio = 1e-04,
  cv.rule = c("min", "1se")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.funs_+3A_gamma">gamma</code></td>
<td>
<p>Mixing parameter (between 0 and 1) for the elastic net, where
0 corresponds to ridge regression, and 1 to the lasso. Default is 0.5.</p>
</td></tr>
<tr><td><code id="elastic.funs_+3A_standardize">standardize</code>, <code id="elastic.funs_+3A_intercept">intercept</code></td>
<td>
<p>Should the data be standardized, and should an
intercept be included? Default for both is TRUE.</p>
</td></tr>
<tr><td><code id="elastic.funs_+3A_lambda">lambda</code></td>
<td>
<p>Sequence of lambda values over which training is performed.
This must be in decreasing order, and &mdash; this argument should be used with
caution! When used, it is usually best to grab the sequence constructed by
one initial call to glmnet (see examples). Default is NULL, which means that
the nlambda, lambda.min.ratio arguments will define the lambda sequence
(see next).</p>
</td></tr>
<tr><td><code id="elastic.funs_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values over which training is performed. In
particular, the lambda sequence is defined by nlambda log-spaced values
between lambda.max and lambda.min.ratio * lambda.max, where lambda.max is
the smallest value of lambda at which the solution has all zero components,
and lambda.min.ratio is a small fraction (see next). Default is 50.</p>
</td></tr>
<tr><td><code id="elastic.funs_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Small fraction that gets used in conjunction with
nlambda to specify a lambda sequence (see above). Default is 1e-4.</p>
</td></tr>
<tr><td><code id="elastic.funs_+3A_cv.rule">cv.rule</code></td>
<td>
<p>If the cv argument is TRUE, then cv.rule determines which rule
should be used for the predict function, either &quot;min&quot; (the usual rule) or
&quot;1se&quot; (the one-standard-error rule). See the glmnet help files for details.
Default is &quot;min&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the packages <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.
Notice that Cross Validation to select the best lambda value is compulsory!
The functions lasso.funs and ridge.funs are convenience
functions, they simply call elastic.funs with gamma = 1 and gamma = 0,
respectively.
</p>


<h3>Value</h3>

<p>A list with three components: train.fun, predict.fun, active.fun.
The third function is designed to take the output of train.fun, and
reports which features are active for each fitted model contained in
this output.
</p>

<hr>
<h2 id='lm_multi'>Linear Modeling of Multivariate Response</h2><span id='topic+lm_multi'></span>

<h3>Description</h3>

<p>This model is fed to <code><a href="#topic+conformal.multidim.full">conformal.multidim.full</a></code>,
<code><a href="#topic+conformal.multidim.split">conformal.multidim.split</a></code>, and <code><a href="#topic+conformal.multidim.msplit">conformal.multidim.msplit</a></code>.
It outputs a training function and a prediction function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_multi()
</code></pre>


<h3>Details</h3>

<p>The training function takes as input:
</p>
<p>x The feature matrix  (dim n x p)
y The response matrix (dim n x q)
</p>
<p>The predict function, instead, takes as input:
</p>
<p>out The output of a previous call to train.fun
newx The new features to evaluate (i.e. an n0 x p matrix)
Here I defined an lm model for every dimension of the responses (q).
</p>


<h3>Value</h3>

<p>A list with the training function and the prediction function.
</p>

<hr>
<h2 id='mean_multi'>Mean of Multivariate Response</h2><span id='topic+mean_multi'></span>

<h3>Description</h3>

<p>This model is fed to <code><a href="#topic+conformal.multidim.full">conformal.multidim.full</a></code>,
<code><a href="#topic+conformal.multidim.split">conformal.multidim.split</a></code>, and <code><a href="#topic+conformal.multidim.msplit">conformal.multidim.msplit</a></code>.
It outputs a training function and a prediction function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_multi()
</code></pre>


<h3>Details</h3>

<p>The training function takes as input:
</p>
<p>x The feature matrix  (dim n x p)
y The response matrix (dim n x q)
</p>
<p>The predict function, instead, takes as input:
</p>
<p>out The output of a previous call to train.fun
newx The new features to evaluate (i.e. an n0 x p matrix)
</p>


<h3>Value</h3>

<p>A list with the training function and the prediction function.
</p>

<hr>
<h2 id='plot_multidim'>Plot Confidence Regions obtained with Split Conformal</h2><span id='topic+plot_multidim'></span>

<h3>Description</h3>

<p>Plot Confidence Regions obtained with Split Conformal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_multidim(out, same.scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_multidim_+3A_out">out</code></td>
<td>
<p>The output of a prediction function.</p>
</td></tr>
<tr><td><code id="plot_multidim_+3A_same.scale">same.scale</code></td>
<td>
<p>Should I force the same scale for all the y-axis ? Default
is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It exploits the package <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>, <code><a href="gridExtra.html#topic+gridExtra">gridExtra</a></code>
and <code><a href="hrbrthemes.html#topic+hrbrthemes">hrbrthemes</a></code> to better visualize the results.
</p>


<h3>Value</h3>

<p>g_list A list of ggplots (output[[i]] is the i-th observation confidence region).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=50
p=4
q=2

mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]

n0&lt;-nrow(y0)
q&lt;-ncol(y)

fun=mean_multi()

final.point = conformal.multidim.split(x,y,x0, fun$train.fun, fun$predict.fun,
                             alpha=0.1,
                                split=NULL, seed=FALSE, randomized=FALSE,seed.rand=FALSE,
                                verbose=FALSE, rho=0.5,score ="l2",s.type="st-dev")

ppp2&lt;-plot_multidim(final.point)

n=25
p=4
q=2


mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta&lt;-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]

n0&lt;-nrow(y0)
q&lt;-ncol(y)


fun=mean_multi()

#################################### FULL CONFORMAL

final.full=conformal.multidim.full(x, y, x0, fun$train.fun,
                                fun$predict.fun, score="l2",
                                num.grid.pts.dim=5, grid.factor=1.25,
                                verbose=FALSE)

ppp&lt;-plot_multidim(final.full)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
