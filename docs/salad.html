<!DOCTYPE html><html><head><title>Help for package salad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {salad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply+2Cdual-method'><p>Apply functions over array margins of dual objects</p></a></li>
<li><a href='#Arithmetic'><p>Arithmetic Operators</p></a></li>
<li><a href='#bind'><p>Binding methods for dual objects</p></a></li>
<li><a href='#c'><p>Concatenation methods</p></a></li>
<li><a href='#colSums'><p>Row and column sums and means</p></a></li>
<li><a href='#Comparison'><p>Comparison Operators</p></a></li>
<li><a href='#d'><p>get list of derivatives</p></a></li>
<li><a href='#diag'><p>Matrix diagonals</p></a></li>
<li><a href='#dnorm'><p>Normal distribution</p></a></li>
<li><a href='#dual'><p>Dual objects</p></a></li>
<li><a href='#dual-class'><p>dual class</p></a></li>
<li><a href='#dualFun1'><p>Defining in-house derivatives</p></a></li>
<li><a href='#Extract'><p>Extract or replace parts of an object</p></a></li>
<li><a href='#ifelse'><p>Conditionnal Element Selection</p></a></li>
<li><a href='#inversion'><p>Determinant and matrix inversion for dual matrices</p></a></li>
<li><a href='#MathFun'><p>Mathematical functions</p></a></li>
<li><a href='#matmult'><p>Matrix Arithmetic</p></a></li>
<li><a href='#matrix'><p>Methods for 'matrix', 'array', 'as.matrix' and 'as.vector'</p></a></li>
<li><a href='#outer'><p>Outer product for dual objects</p></a></li>
<li><a href='#rep'><p>Replicate elements of a dual vector</p></a></li>
<li><a href='#salad'><p>Salad options</p></a></li>
<li><a href='#shape'><p>Dual objects length, dim, names and dimnames</p></a></li>
<li><a href='#Summary'><p>Summary methods for objects of class dual</p></a></li>
<li><a href='#t'><p>Transposition of matrices and arrays</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Automatic Differentiation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hervé Perdry &lt;herve.perdry@universite-paris-saclay.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Handles both vector and matrices, using a flexible S4 class for automatic differentiation.
  The method used is forward automatic differentiation. Many functions and methods have been defined, 
  so that in most cases, functions written without automatic differentiation in mind can be 
  used without change. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 14:35:48 UTC; rv</td>
</tr>
<tr>
<td>Author:</td>
<td>Hervé Perdry [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-24 12:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply+2Cdual-method'>Apply functions over array margins of dual objects</h2><span id='topic+apply+2Cdual-method'></span>

<h3>Description</h3>

<p>This method generalizes 'base::apply' to dual objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dual'
apply(X, MARGIN, FUN, ..., simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply+2B2Cdual-method_+3A_x">X</code></td>
<td>
<p>a dual object (with array or matrix shape)</p>
</td></tr>
<tr><td><code id="apply+2B2Cdual-method_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscript which the function will be applied over</p>
</td></tr>
<tr><td><code id="apply+2B2Cdual-method_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="apply+2B2Cdual-method_+3A_...">...</code></td>
<td>
<p>extra arguments for 'FUN'</p>
</td></tr>
<tr><td><code id="apply+2B2Cdual-method_+3A_simplify">simplify</code></td>
<td>
<p>a logical indicating whether the results should be simplified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value depends on the values returned by 'FUN', similarly to 'base::apply'
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c(1,2,3,4), 2, 2)
x &lt;- dual(A)
cs &lt;- apply(x, 2, sum)
cs
d(cs)
# prefered method for summing over the columns
colSums(x) 
</code></pre>

<hr>
<h2 id='Arithmetic'>Arithmetic Operators</h2><span id='topic+Arithmetic'></span><span id='topic++2B+2Cdual+2Cdual-method'></span><span id='topic++2B+2Cdual+2CnumericOrArray-method'></span><span id='topic++2B+2CnumericOrArray+2Cdual-method'></span><span id='topic++2B+2Cdual+2Cmissing-method'></span><span id='topic+-+2Cdual+2Cdual-method'></span><span id='topic+-+2Cdual+2Cmissing-method'></span><span id='topic+-+2Cdual+2CnumericOrArray-method'></span><span id='topic+-+2CnumericOrArray+2Cdual-method'></span><span id='topic++2A+2Cdual+2Cdual-method'></span><span id='topic++2A+2Cdual+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2Cdual-method'></span><span id='topic++2F+2Cdual+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2Cdual-method'></span><span id='topic++2F+2Cdual+2Cdual-method'></span><span id='topic++5E+2Cdual+2Cnumeric-method'></span><span id='topic++5E+2Cnumeric+2Cdual-method'></span><span id='topic++5E+2Cdual+2Cdual-method'></span>

<h3>Description</h3>

<p>Arithmetic operators for objects of class 'dual'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dual,dual'
e1 + e2

## S4 method for signature 'dual,numericOrArray'
e1 + e2

## S4 method for signature 'numericOrArray,dual'
e1 + e2

## S4 method for signature 'dual,missing'
e1 + e2

## S4 method for signature 'dual,dual'
e1 - e2

## S4 method for signature 'dual,missing'
e1 - e2

## S4 method for signature 'dual,numericOrArray'
e1 - e2

## S4 method for signature 'numericOrArray,dual'
e1 - e2

## S4 method for signature 'dual,dual'
e1 * e2

## S4 method for signature 'dual,numeric'
e1 * e2

## S4 method for signature 'numeric,dual'
e1 * e2

## S4 method for signature 'dual,numeric'
e1 / e2

## S4 method for signature 'numeric,dual'
e1 / e2

## S4 method for signature 'dual,dual'
e1 / e2

## S4 method for signature 'dual,numeric'
e1 ^ e2

## S4 method for signature 'numeric,dual'
e1 ^ e2

## S4 method for signature 'dual,dual'
e1 ^ e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arithmetic_+3A_e1">e1</code></td>
<td>
<p>object of class 'dual' or 'numeric'</p>
</td></tr>
<tr><td><code id="Arithmetic_+3A_e2">e2</code></td>
<td>
<p>object of class 'dual' or 'numeric'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual operations are performed, with appropriate propagation of the derivatives
</p>


<h3>Value</h3>

<p>An object of class 'dual'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( c(1,2) )
a &lt;- 2 * x + 3
a
d(a)
b &lt;- x[1] + 3*x[2]
b
d(b)
</code></pre>

<hr>
<h2 id='bind'>Binding methods for dual objects</h2><span id='topic+bind'></span><span id='topic+rbind2_dd'></span><span id='topic+rbind2+2Cdual+2Cdual-method'></span><span id='topic+rbind2+2CnumericOrArray+2Cdual-method'></span><span id='topic+rbind2+2Cdual+2CnumericOrArray-method'></span><span id='topic+rbind2+2Cdual+2Cmissing-method'></span><span id='topic+cbind2+2Cdual+2Cdual-method'></span><span id='topic+cbind2+2CnumericOrArray+2Cdual-method'></span><span id='topic+cbind2+2Cdual+2CnumericOrArray-method'></span><span id='topic+cbind2+2Cdual+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods allowing to use 'cbind' and 'rbind' with dual objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dual,dual'
rbind2(x,y,...)

## S4 method for signature 'dual,numericOrArray'
rbind2(x,y,...)

## S4 method for signature 'numericOrArray,dual'
rbind2(x,y,...)

## S4 method for signature 'dual,missing'
rbind2(x,y,...)

## S4 method for signature 'dual,dual'
cbind2(x,y,...)

## S4 method for signature 'dual,numericOrArray'
cbind2(x,y,...)

## S4 method for signature 'numericOrArray,dual'
cbind2(x,y,...)

## S4 method for signature 'dual,missing'
cbind2(x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_x">x</code>, <code id="bind_+3A_y">y</code></td>
<td>
<p>dual or numeric objects</p>
</td></tr>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>extra parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dual matrix combining the arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( c(1, 3) )
y &lt;- cbind(x, 2*x+1, 3*x+2, c(0,1))
y
d(y, "x1")


</code></pre>

<hr>
<h2 id='c'>Concatenation methods</h2><span id='topic+c'></span><span id='topic+concat0'></span><span id='topic+c+2CnumericOrArray-method'></span><span id='topic+c-dual'></span>

<h3>Description</h3>

<p>Methods have been defined in order to allow the concatenation 
of 'dual' objects together and with constant objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numericOrArray'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>first object to concatenate</p>
</td></tr>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>other objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class dual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( 1 )
# concatenation with a constant
x &lt;- c(x, 2)
x
d(x)
# concatenation of dual objects
x1 &lt;- sum(x)
x2 &lt;- sum(x**2)
y &lt;- c(a = x1, b = x2)  # you can use named arguments
y
d(y)
</code></pre>

<hr>
<h2 id='colSums'>Row and column sums and means</h2><span id='topic+colSums'></span><span id='topic+rowSums.dual'></span><span id='topic+rowSums'></span><span id='topic+colMeans'></span><span id='topic+rowMeans'></span><span id='topic+rowSums+2Cdual-method'></span><span id='topic+colSums.dual'></span><span id='topic+colSums+2Cdual-method'></span><span id='topic+rowMeans.dual'></span><span id='topic+rowMeans+2Cdual-method'></span><span id='topic+colMeans.dual'></span><span id='topic+colMeans+2Cdual-method'></span>

<h3>Description</h3>

<p>Method extending to dual matrices the corresponding methods for dual matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSums.dual(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'dual'
rowSums(x, na.rm = FALSE, dims = 1, ...)

colSums.dual(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'dual'
colSums(x, na.rm = FALSE, dims = 1, ...)

rowMeans.dual(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'dual'
rowMeans(x, na.rm = FALSE, dims = 1, ...)

colMeans.dual(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'dual'
colMeans(x, na.rm = FALSE, dims = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSums_+3A_x">x</code></td>
<td>
<p>a dual matrix or array</p>
</td></tr>
<tr><td><code id="colSums_+3A_na.rm">na.rm</code></td>
<td>
<p>if 'TRUE', missing values are removed</p>
</td></tr>
<tr><td><code id="colSums_+3A_dims">dims</code></td>
<td>
<p>which dimensions are regarded as rows and cols</p>
</td></tr>
<tr><td><code id="colSums_+3A_...">...</code></td>
<td>
<p>extra parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dual object (usually a dual vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( c(1,2) )
x &lt;- cbind(x, 2*x+1)
rowSums(x)
d(rowSums(x), "x1")

</code></pre>

<hr>
<h2 id='Comparison'>Comparison Operators</h2><span id='topic+Comparison'></span><span id='topic+Compare+2Cdual+2CANY-method'></span>

<h3>Description</h3>

<p>Comparison operators for objects of class 'dual'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dual,ANY'
Compare(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Comparison_+3A_e1">e1</code></td>
<td>
<p>object of class 'dual' or 'numeric'</p>
</td></tr>
<tr><td><code id="Comparison_+3A_e2">e2</code></td>
<td>
<p>object of class 'dual' or 'numeric'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>usual comparison operators, ignoring derivatives valuesa
</p>


<h3>Value</h3>

<p>a logical vector
</p>

<hr>
<h2 id='d'>get list of derivatives</h2><span id='topic+d'></span><span id='topic+d.dual'></span><span id='topic+d.numeric'></span><span id='topic+value'></span><span id='topic+value.dual'></span><span id='topic+value.numeric'></span><span id='topic+varnames'></span><span id='topic+varnames.dual'></span><span id='topic+varnames.numeric'></span>

<h3>Description</h3>

<p>Get value, differential of a dual object, and the names of associated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d(x, varnames)

value(x)

## S3 method for class 'dual'
value(x)

## S3 method for class 'numeric'
value(x)

varnames(x)

## S3 method for class 'dual'
varnames(x)

## S3 method for class 'numeric'
varnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_+3A_x">x</code></td>
<td>
<p>a dual (or numeric) oject</p>
</td></tr>
<tr><td><code id="d_+3A_varnames">varnames</code></td>
<td>
<p>(optional) a vector or varnames to take derivatives along</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'varnames' is provided to the function 'd', a list of derivatives along the given variables will be sent back. 
In general, it sends back the derivatives along all associated variables.
</p>
<p>The 'varnames' function sends back the names of all variables
for which a derivative is defined.
</p>


<h3>Value</h3>

<p>A named list of derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(c(3,2))
varnames(x^2)
x**2
value(x**2)
d(x**2)
d(x**2, "x1")
# you can use these methods with a numerical constant
value(1)
varnames(1)
d(1, "x1")

</code></pre>

<hr>
<h2 id='diag'>Matrix diagonals</h2><span id='topic+diag'></span><span id='topic+diag.dual'></span><span id='topic+diag+2Cdual-method'></span><span id='topic+diag+3C-+2Cdual+2Cdual-method'></span><span id='topic+diag+3C-+2Cdual+2CnumericOrArray-method'></span>

<h3>Description</h3>

<p>Methods extending to dual objects the corresponding methods for numeric objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.dual(x, nrow, ncol, names = TRUE)

## S4 method for signature 'dual'
diag(x = 1, nrow, ncol, names = TRUE)

## S4 replacement method for signature 'dual,dual'
diag(x) &lt;- value

## S4 replacement method for signature 'dual,numericOrArray'
diag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_+3A_x">x</code></td>
<td>
<p>a dual object</p>
</td></tr>
<tr><td><code id="diag_+3A_nrow">nrow</code>, <code id="diag_+3A_ncol">ncol</code></td>
<td>
<p>(optional) dimensions of result</p>
</td></tr>
<tr><td><code id="diag_+3A_names">names</code></td>
<td>
<p>if 'TRUE', pass names along</p>
</td></tr>
<tr><td><code id="diag_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dual object, similarly to 'base::diag'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( c(1,2) )
diag(x)
d(diag(x), "x1")
y &lt;- matrix(x, 2, 2)
diag(y) &lt;- 2*diag(y)
y
d(y)
diag(y)
</code></pre>

<hr>
<h2 id='dnorm'>Normal distribution</h2><span id='topic+dnorm'></span><span id='topic+dnorm.dual'></span>

<h3>Description</h3>

<p>Density for the normal distribution, accepting
objects of class 'dual'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorm(x, mean = 0, sd = 1, log = FALSE)

dnorm.dual(x, mean = 0, sd = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnorm_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="dnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="dnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations</p>
</td></tr>
<tr><td><code id="dnorm_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, log of densities are returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'dnorm.dual' will make straightfoward a computation (in R), that 
works both with numeric or dual objects. 'dnorm' will call 'dnorm.dual'
if any of the objects is of class dual, or 'stats::dnorm' is all objects
are of class numeric. As 'stats::dnorm' is in written in C it is factor.
</p>
<p>If you care for performance, use 'stats::dnorm' directly for non dual numbers,
and 'dnorm.dual' for dual numbers.
</p>


<h3>Value</h3>

<p>a dual object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(0)
dnx &lt;- dnorm(x)
dnx
d(dnx)

</code></pre>

<hr>
<h2 id='dual'>Dual objects</h2><span id='topic+dual'></span>

<h3>Description</h3>

<p>Create a dual object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual(x, varnames, dx, constant = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual_+3A_x">x</code></td>
<td>
<p>a numeric object (vector, matrix, or array)</p>
</td></tr>
<tr><td><code id="dual_+3A_varnames">varnames</code></td>
<td>
<p>(optional) the name of the variables in x</p>
</td></tr>
<tr><td><code id="dual_+3A_dx">dx</code></td>
<td>
<p>(optional) a list of derivatives for the elements of x</p>
</td></tr>
<tr><td><code id="dual_+3A_constant">constant</code></td>
<td>
<p>if 'TRUE', then a constant is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic usage is <code>dual(x)</code> which will create an object of
class 'dual' with unit derivatives in each of its components. The variable
names will be derived from the names of <code>x</code>, or generated in the form 
<code>x1</code>, <code>x2</code>, etc.
</p>
<p>Another possible usage is <code>dual(x, varnames = c('x1', 'x2'), constant = TRUE)</code>
which returns an object with null derivatives in <code>x1</code> and <code>x2</code>.
</p>
<p>Finally, a list of derivatives can be defined using option <code>dx</code>.
</p>


<h3>Value</h3>

<p>an object of class 'dual'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple usage
x &lt;- dual( c(1,2) )
x
d(x)
x &lt;- dual(matrix(c(1,2,3,4), 2, 2))
x
d(x, "x1.1")

# using an object with names
x &lt;- dual( c(a = 1, b = 2) )
x
d(x)

# generate a constant 
x &lt;- dual(1, varnames = c("x1", "x2"), constant = TRUE)

# specify dx
x &lt;- dual(c(1,2), dx = list(x1 = c(1,1)))
x
d(x)
# this is equivalent to :
x &lt;- dual(1)
x &lt;- c(x, x + 1)
x
d(x)
</code></pre>

<hr>
<h2 id='dual-class'>dual class</h2><span id='topic+dual-class'></span>

<h3>Description</h3>

<p>An S4 class for forward differentiation of vector and matrix computations.
</p>


<h3>Details</h3>

<p>A dual object can be either a vector or a matrix. It can contain derivatives
with respect to several variables. The derivatives will have the same shape
as the value.
</p>
<p>The shape of an object can be changed using 'dim&lt;-'. Note that by default
'as.matrix' and 'as.vector' will send back a regular vector/matrix object,
dropping the derivatives. See 'salad' to change this behaviour if needed
(this is not the recommended solution).
</p>
<p>Many methods and functions have been redefined in the package, in order to
allow to apply existing code to 'dual' objects, with no or little change.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>the value of the object. Use the function 'value' to access this slot.</p>
</dd>
<dt><code>d</code></dt><dd><p>a (named) list of derivatives. Use the function 'd' to access this slot.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+value">value</a></code>, <code><a href="#topic+d">d</a></code>, <code><a href="#topic+dual">dual</a></code>, <code><a href="#topic+salad">salad</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating a vector of length 4
x &lt;- dual( c(1,2,1,0) )
x
d(x)
# turning x into a matrix
dim(x) &lt;- c(2,2)
x
d(x)
# and back into a vector
dim(x) &lt;- NULL
x
# weighted sum of the elements of x
S &lt;- sum(1:4 * x)
S
d(S)

</code></pre>

<hr>
<h2 id='dualFun1'>Defining in-house derivatives</h2><span id='topic+dualFun1'></span>

<h3>Description</h3>

<p>Defining the differential of a univariate function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dualFun1(f, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dualFun1_+3A_f">f</code></td>
<td>
<p>a function with a unique argument</p>
</td></tr>
<tr><td><code id="dualFun1_+3A_df">df</code></td>
<td>
<p>the differential of f</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a new function that can be applied to 
a dual object. This allows to extend the package by defining functions it is currenlty
unable to derive. It can also gain some time for intensively used functions
(see examples below).
</p>


<h3>Value</h3>

<p>Returns a function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using salad do compute the differential of a quadratic function
f &lt;- function(x) x**2 + x + 1
x &lt;- dual(4)
f(x)
d(f(x))

# using `dualFun1` to define the differential of f saves time
f1 &lt;- dualFun1(f, \(x) 2*x + 1)
f1(x)
d(f1(x))
system.time( for(i in 1:500) f(x) )
system.time( for(i in 1:500) f1(x) )


</code></pre>

<hr>
<h2 id='Extract'>Extract or replace parts of an object</h2><span id='topic+Extract'></span><span id='topic++5B+3C-+2Cdual+2Cindex+2Cindex+2Cdual-method'></span><span id='topic++5B+3C-+2Cdual+2Cmissing+2Cindex+2Cdual-method'></span><span id='topic++5B+3C-+2Cdual+2Cindex+2Cmissing+2Cdual-method'></span><span id='topic++5B+3C-+2Cdual+2Cmissing+2Cmissing+2Cdual-method'></span><span id='topic++5B+3C-+2Cdual+2Cindex+2Cindex+2ClogicalOrNumericOrArray-method'></span><span id='topic++5B+3C-+2Cdual+2Cmissing+2Cindex+2ClogicalOrNumericOrArray-method'></span><span id='topic++5B+3C-+2Cdual+2Cindex+2Cmissing+2ClogicalOrNumericOrArray-method'></span><span id='topic++5B+3C-+2Cdual+2Cmissing+2Cmissing+2ClogicalOrNumericOrArray-method'></span><span id='topic++5B+2Cdual+2Cindex+2Cindex-method'></span><span id='topic++5B+2Cdual+2Cmissing+2Cindex-method'></span><span id='topic++5B+2Cdual+2Cindex+2Cmissing-method'></span><span id='topic++5B+2Cdual+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for extraction or replacements of parts of dual objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'dual,index,index,dual'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,missing,index,dual'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,index,missing,dual'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,missing,missing,dual'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,index,index,logicalOrNumericOrArray'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,missing,index,logicalOrNumericOrArray'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,index,missing,logicalOrNumericOrArray'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dual,missing,missing,logicalOrNumericOrArray'
x[i, j, ...] &lt;- value

## S4 method for signature 'dual,index,index'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'dual,missing,index'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'dual,index,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'dual,missing,missing'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>dual object</p>
</td></tr>
<tr><td><code id="Extract_+3A_i">i</code>, <code id="Extract_+3A_j">j</code></td>
<td>
<p>indices of elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract_+3A_...">...</code></td>
<td>
<p>supplementary indices (for arrays)</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="Extract_+3A_drop">drop</code></td>
<td>
<p>for dual matrices or array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dual object (the semantic is the same as base extraction and replacement methods).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3)
x[2] &lt;- dual(4)
x
d(x)
</code></pre>

<hr>
<h2 id='ifelse'>Conditionnal Element Selection</h2><span id='topic+ifelse'></span><span id='topic+ifelse+2CANY+2Cdual+2CnumericOrArrayOrDual-method'></span><span id='topic+ifelse+2CANY+2CnumericOrArray+2Cdual-method'></span>

<h3>Description</h3>

<p>&lsquo;ifelse' methods extend 'base::ifelse' to allow using dual objects for &rsquo;yes' or 'no' arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifelse(test, yes, no)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifelse_+3A_test">test</code></td>
<td>
<p>an object which can be coerced to logical mode.</p>
</td></tr>
<tr><td><code id="ifelse_+3A_yes">yes</code></td>
<td>
<p>return values for true elements of 'test'.</p>
</td></tr>
<tr><td><code id="ifelse_+3A_no">no</code></td>
<td>
<p>return values for false elements of 'test'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dual object (dual vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(c(1,2,4,6))
y &lt;- ifelse(x &gt; 2, x, x/2)
y
d(y)
</code></pre>

<hr>
<h2 id='inversion'>Determinant and matrix inversion for dual matrices</h2><span id='topic+inversion'></span><span id='topic+det.dual'></span><span id='topic+det'></span><span id='topic+determinant'></span><span id='topic+solve'></span><span id='topic+det+2Cdual-method'></span><span id='topic+determinant.dual'></span><span id='topic+solve+2Cdual+2Cdual-method'></span><span id='topic+solve+2Cdual+2Cmissing-method'></span><span id='topic+solve+2CnumericOrArray+2Cdual-method'></span><span id='topic+solve+2Cdual+2CnumericOrArray-method'></span>

<h3>Description</h3>

<p>Methods extending to dual matrices the corresponding methods for numeric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det.dual(x, ...)

## S4 method for signature 'dual'
det(x, ...)

## S3 method for class 'dual'
determinant(x, logarithm = TRUE, ...)

## S4 method for signature 'dual,dual'
solve(a, b, ...)

## S4 method for signature 'dual,missing'
solve(a, b, ...)

## S4 method for signature 'numericOrArray,dual'
solve(a, b, ...)

## S4 method for signature 'dual,numericOrArray'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversion_+3A_x">x</code></td>
<td>
<p>a dual matrix</p>
</td></tr>
<tr><td><code id="inversion_+3A_...">...</code></td>
<td>
<p>extra parameters (ignored)</p>
</td></tr>
<tr><td><code id="inversion_+3A_logarithm">logarithm</code></td>
<td>
<p>if 'TRUE', get logarithm of modulus of determinant</p>
</td></tr>
<tr><td><code id="inversion_+3A_a">a</code>, <code id="inversion_+3A_b">b</code></td>
<td>
<p>dual or numerical arguments for 'solve'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'det' returns a dual scalar, 'determinant' a list with components 'modulus' (which is a dual object)
and 'sign', and 'solve' returns a dual object (vector or matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( matrix(c(1,2,1,3), 2, 2) )
det(x)
d(det(x), "x1.1")
solve(x)
d(solve(x), "x1.1")

</code></pre>

<hr>
<h2 id='MathFun'>Mathematical functions</h2><span id='topic+MathFun'></span><span id='topic+exp.dual'></span><span id='topic+expm1.dual'></span><span id='topic+logNeper'></span><span id='topic+log.dual'></span><span id='topic+log10.dual'></span><span id='topic+log2.dual'></span><span id='topic+log1p.dual'></span><span id='topic+sqrt.dual'></span><span id='topic+cos.dual'></span><span id='topic+sin.dual'></span><span id='topic+tan.dual'></span><span id='topic+cospi.dual'></span><span id='topic+sinpi.dual'></span><span id='topic+tanpi.dual'></span><span id='topic+acos.dual'></span><span id='topic+asin.dual'></span><span id='topic+atan.dual'></span><span id='topic+atan2+2Cdual+2Cdual-method'></span><span id='topic+atan2+2Cdual+2CnumericOrArray-method'></span><span id='topic+atan2+2CnumericOrArray+2Cdual-method'></span><span id='topic+cosh.dual'></span><span id='topic+sinh.dual'></span><span id='topic+tanh.dual'></span><span id='topic+acosh.dual'></span><span id='topic+asinh.dual'></span><span id='topic+atanh.dual'></span><span id='topic+abs.dual'></span><span id='topic+sign.dual'></span><span id='topic+ceiling.dual'></span><span id='topic+floor.dual'></span><span id='topic+trunc.dual'></span><span id='topic+gamma.dual'></span><span id='topic+lgamma.dual'></span><span id='topic+digamma.dual'></span><span id='topic+trigamma.dual'></span><span id='topic+psigamma.dual'></span><span id='topic+psigamma+2Cdual-method'></span><span id='topic+beta+2Cdual+2Cdual-method'></span><span id='topic+beta+2Cdual+2CnumericOrArray-method'></span><span id='topic+beta+2CnumericOrArray+2Cdual-method'></span><span id='topic+lbeta+2Cdual+2Cdual-method'></span><span id='topic+lbeta+2Cdual+2CnumericOrArray-method'></span><span id='topic+lbeta+2CnumericOrArray+2Cdual-method'></span><span id='topic+factorial.dual'></span><span id='topic+lfactorial.dual'></span><span id='topic+choose+2Cdual+2Cnumeric-method'></span><span id='topic+lchoose+2Cdual+2Cnumeric-method'></span>

<h3>Description</h3>

<p>various mathematical functions and methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
exp(x)

## S3 method for class 'dual'
expm1(x)

logNeper(x)

## S3 method for class 'dual'
log(x, base = exp(1))

## S3 method for class 'dual'
log10(x)

## S3 method for class 'dual'
log2(x)

## S3 method for class 'dual'
log1p(x)

## S3 method for class 'dual'
sqrt(x)

## S3 method for class 'dual'
cos(x)

## S3 method for class 'dual'
sin(x)

## S3 method for class 'dual'
tan(x)

## S3 method for class 'dual'
cospi(x)

## S3 method for class 'dual'
sinpi(x)

## S3 method for class 'dual'
tanpi(x)

## S3 method for class 'dual'
acos(x)

## S3 method for class 'dual'
asin(x)

## S3 method for class 'dual'
atan(x)

## S4 method for signature 'dual,dual'
atan2(y, x)

## S4 method for signature 'dual,numericOrArray'
atan2(y, x)

## S4 method for signature 'numericOrArray,dual'
atan2(y, x)

## S3 method for class 'dual'
cosh(x)

## S3 method for class 'dual'
sinh(x)

## S3 method for class 'dual'
tanh(x)

## S3 method for class 'dual'
acosh(x)

## S3 method for class 'dual'
asinh(x)

## S3 method for class 'dual'
atanh(x)

## S3 method for class 'dual'
abs(x)

## S3 method for class 'dual'
sign(x)

## S3 method for class 'dual'
ceiling(x)

## S3 method for class 'dual'
floor(x)

## S3 method for class 'dual'
trunc(x, ...)

## S3 method for class 'dual'
gamma(x)

## S3 method for class 'dual'
lgamma(x)

## S3 method for class 'dual'
digamma(x)

## S3 method for class 'dual'
trigamma(x)

psigamma.dual(x, deriv = 0)

## S4 method for signature 'dual'
psigamma(x, deriv = 0)

## S4 method for signature 'dual,dual'
beta(a, b)

## S4 method for signature 'dual,numericOrArray'
beta(a, b)

## S4 method for signature 'numericOrArray,dual'
beta(a, b)

## S4 method for signature 'dual,dual'
lbeta(a, b)

## S4 method for signature 'dual,numericOrArray'
lbeta(a, b)

## S4 method for signature 'numericOrArray,dual'
lbeta(a, b)

factorial.dual(x)

lfactorial.dual(x)

## S4 method for signature 'dual,numeric'
choose(n, k)

## S4 method for signature 'dual,numeric'
lchoose(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MathFun_+3A_x">x</code></td>
<td>
<p>function argument (dual or numeric object)</p>
</td></tr>
<tr><td><code id="MathFun_+3A_base">base</code></td>
<td>
<p>base to which log is computed</p>
</td></tr>
<tr><td><code id="MathFun_+3A_y">y</code></td>
<td>
<p>first argument of atan2 function (dual or numeric)</p>
</td></tr>
<tr><td><code id="MathFun_+3A_...">...</code></td>
<td>
<p>extra arguments to trunc (unused)</p>
</td></tr>
<tr><td><code id="MathFun_+3A_deriv">deriv</code></td>
<td>
<p>integer argument to psigamma</p>
</td></tr>
<tr><td><code id="MathFun_+3A_a">a</code>, <code id="MathFun_+3A_b">b</code></td>
<td>
<p>arguments of beta and lbeta (dual or nueumeric)</p>
</td></tr>
<tr><td><code id="MathFun_+3A_n">n</code></td>
<td>
<p>first argument of choose and lchoose (dual)</p>
</td></tr>
<tr><td><code id="MathFun_+3A_k">k</code></td>
<td>
<p>second argument of choose and lchoose (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The derivative of 'abs' is set to be the function 'sign', so its
derivative in 0 is considered as null. You may want to redefine 'abs' using 'dualFun1'
to get an undefined derivative.
</p>


<h3>Value</h3>

<p>All functions return dual objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(1)
y &lt;- log(x)
y
d(y)
</code></pre>

<hr>
<h2 id='matmult'>Matrix Arithmetic</h2><span id='topic+matmult'></span><span id='topic+matrixprod_dn'></span><span id='topic+matrixprod_nd'></span><span id='topic+matrixprod_dd'></span><span id='topic++25+2A+25+2Cdual+2CnumericOrArray-method'></span><span id='topic++25+2A+25+2CnumericOrArray+2Cdual-method'></span><span id='topic++25+2A+25+2Cdual+2Cdual-method'></span><span id='topic+crossprod+2Cdual+2Cdual-method'></span><span id='topic+crossprod+2Cdual+2CnumericOrArray-method'></span><span id='topic+crossprod+2CnumericOrArray+2Cdual-method'></span><span id='topic+crossprod+2Cdual+2Cmissing-method'></span><span id='topic+tcrossprod+2Cdual+2Cdual-method'></span><span id='topic+tcrossprod+2Cdual+2CnumericOrArray-method'></span><span id='topic+tcrossprod+2CnumericOrArray+2Cdual-method'></span><span id='topic+tcrossprod+2Cdual+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods and functions for dual matrix arithmetic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixprod_dn(x, y)

matrixprod_nd(x, y)

matrixprod_dd(x, y)

## S4 method for signature 'dual,numericOrArray'
x %*% y

## S4 method for signature 'numericOrArray,dual'
x %*% y

## S4 method for signature 'dual,dual'
x %*% y

## S4 method for signature 'dual,dual'
crossprod(x, y)

## S4 method for signature 'dual,numericOrArray'
crossprod(x, y)

## S4 method for signature 'numericOrArray,dual'
crossprod(x, y)

## S4 method for signature 'dual,missing'
crossprod(x, y)

## S4 method for signature 'dual,dual'
tcrossprod(x, y)

## S4 method for signature 'dual,numericOrArray'
tcrossprod(x, y)

## S4 method for signature 'numericOrArray,dual'
tcrossprod(x, y)

## S4 method for signature 'dual,missing'
tcrossprod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult_+3A_x">x</code>, <code id="matmult_+3A_y">y</code></td>
<td>
<p>Dual or numeric matrices or vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All methods are the analog of the corresponding methods for matrices.
The functions 'matrixprod_dd', 'matrixprod_nd' and 'matrixprod_dn' are for multiplication
of two dual objects, of a numeric and a dual object, or of a dual and a numeric object,
respectively. You may use these functions to save the method dispatching time.
</p>


<h3>Value</h3>

<p>A dual object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( matrix(c(0,1,3,1), 2, 2) )
y &lt;- x %*% c(2,-2)
d(y, "x1.1")
</code></pre>

<hr>
<h2 id='matrix'>Methods for 'matrix', 'array', 'as.matrix' and 'as.vector'</h2><span id='topic+matrix'></span><span id='topic+matrix+2Cdual-method'></span><span id='topic+array+2Cdual-method'></span><span id='topic+as.matrix.dual'></span><span id='topic+as'></span><span id='topic+as.matrix+2Cdual-method'></span><span id='topic+as.vector.dual'></span><span id='topic+as.vector+2Cdual-method'></span>

<h3>Description</h3>

<p>Methods for 'matrix', 'array', 'as.matrix' and 'as.vector'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dual'
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)

## S4 method for signature 'dual'
array(data = NA, dim = length(data), dimnames = NULL)

## S3 method for class 'dual'
as.matrix(x, ...)

## S4 method for signature 'dual'
as.matrix(x, ...)

## S3 method for class 'dual'
as.vector(x, mode = "any")

## S4 method for signature 'dual'
as.vector(x, mode = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_+3A_data">data</code>, <code id="matrix_+3A_x">x</code></td>
<td>
<p>A dual object</p>
</td></tr>
<tr><td><code id="matrix_+3A_nrow">nrow</code></td>
<td>
<p>the desired number of rows</p>
</td></tr>
<tr><td><code id="matrix_+3A_ncol">ncol</code></td>
<td>
<p>the desired number of cols</p>
</td></tr>
<tr><td><code id="matrix_+3A_byrow">byrow</code></td>
<td>
<p>if 'TRUE' the matrix is filled by rows</p>
</td></tr>
<tr><td><code id="matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>A 'dimnames' attributes for a matrix or an array</p>
</td></tr>
<tr><td><code id="matrix_+3A_dim">dim</code></td>
<td>
<p>A 'dim' attributes for an array</p>
</td></tr>
<tr><td><code id="matrix_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored)</p>
</td></tr>
<tr><td><code id="matrix_+3A_mode">mode</code></td>
<td>
<p>The mode of the vector to create</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour for 'as.matrix' dans 'as.vector' is to drop the derivatives.
This can be modified using 'salad' (to use with care). The prefered method to change the
shape is to use 'dim&lt;-'.
</p>


<h3>Value</h3>

<p>A dual object for 'matrix' and 'array', a base object for 'as.matrix' and 'as.vector'.
</p>


<h3>See Also</h3>

<p><a href="#topic+shape">shape</a>, <code><a href="#topic+salad">salad</a></code>, <a href="#topic+dual-class">dual-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(c(1,2,0,4))
y &lt;- matrix(x, 2, 2)
y
as.matrix(y)
dim(x) &lt;- c(2,2)
x
</code></pre>

<hr>
<h2 id='outer'>Outer product for dual objects</h2><span id='topic+outer'></span><span id='topic+outer.dual'></span><span id='topic+outer+2Cdual+2Cdual-method'></span><span id='topic+outer+2CnumericOrArray+2Cdual-method'></span><span id='topic+outer+2Cdual+2CnumericOrArray-method'></span><span id='topic++25o+25+2Cdual+2Cdual-method'></span><span id='topic++25o+25+2CnumericOrArray+2Cdual-method'></span><span id='topic++25o+25+2Cdual+2CnumericOrArray-method'></span>

<h3>Description</h3>

<p>Method extending to dual object the usual method method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer.dual(X, Y, FUN = "*", ...)

## S4 method for signature 'dual,dual'
outer(X, Y, FUN = "*", ...)

## S4 method for signature 'numericOrArray,dual'
outer(X, Y, FUN = "*", ...)

## S4 method for signature 'dual,numericOrArray'
outer(X, Y, FUN = "*", ...)

## S4 method for signature 'dual,dual'
X %o% Y

## S4 method for signature 'numericOrArray,dual'
X %o% Y

## S4 method for signature 'dual,numericOrArray'
X %o% Y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outer_+3A_x">X</code>, <code id="outer_+3A_y">Y</code></td>
<td>
<p>arguments of 'FUN'</p>
</td></tr>
<tr><td><code id="outer_+3A_fun">FUN</code></td>
<td>
<p>function to use in the outer product</p>
</td></tr>
<tr><td><code id="outer_+3A_...">...</code></td>
<td>
<p>extra arguments passed to 'FUN'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods extending 'outer' and '
</p>


<h3>Value</h3>

<p>A dual matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual(1:3)
outer(x, x)
d(outer(x,x), "x2")

</code></pre>

<hr>
<h2 id='rep'>Replicate elements of a dual vector</h2><span id='topic+rep'></span><span id='topic+rep.dual'></span>

<h3>Description</h3>

<p>A method extending 'rep' to dual objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_+3A_x">x</code></td>
<td>
<p>a dual vector</p>
</td></tr>
<tr><td><code id="rep_+3A_...">...</code></td>
<td>
<p>extra parameters (typically, 'times', 'length.out' or 'each')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dual object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep( dual(1:2), each = 4 )
x
d(x)

</code></pre>

<hr>
<h2 id='salad'>Salad options</h2><span id='topic+salad'></span>

<h3>Description</h3>

<p>Set or get options values for package 'salad'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salad(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salad_+3A_...">...</code></td>
<td>
<p>options to be defined, using 'name = value', or name(s) of 
option(s) to get.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only one option can be defined, <code>drop.derivatives</code>, 
which modifies the bevahiour of S3 methods <code>as.vector</code> and <code>as.matrix</code>
and corresponding S4 methods. 
The default value is set to 'TRUE', which means that
<code>as.vector</code> and <code>as.matrix</code> will return a 'base' objects, without
derivatives. Setting <code>drop.derivatives = FALSE</code> will make these functions
return an object of class dual. This might be useful to re-use exiting code, 
but may cause some functions to break, and should be use with care.
</p>
<p>Use <code>salad()</code> to get the current value of all options, or
<code>salad(name)</code> to get the current value of a given option.
</p>


<h3>Value</h3>

<p>A list with the defined options, or a single element when <code>salad(name)</code>
is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>salad("drop.derivatives")
x &lt;- dual(matrix(c(1,2,3,4), 2, 2))
salad(drop.derivatives = FALSE)
as.vector(x)
salad(drop.derivatives = TRUE)
as.vector(x)
</code></pre>

<hr>
<h2 id='shape'>Dual objects length, dim, names and dimnames</h2><span id='topic+shape'></span><span id='topic+length.dual'></span><span id='topic+dim.dual'></span><span id='topic+names.dual'></span><span id='topic+dimnames.dual'></span><span id='topic+dim+3C-.dual'></span><span id='topic+dimnames+3C-.dual'></span><span id='topic+names+3C-.dual'></span>

<h3>Description</h3>

<p>S3 methods for length, dim, names and dimnames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
length(x)

## S3 method for class 'dual'
dim(x)

## S3 replacement method for class 'dual'
dim(x) &lt;- value

## S3 method for class 'dual'
dimnames(x)

## S3 replacement method for class 'dual'
dimnames(x) &lt;- value

## S3 method for class 'dual'
names(x)

## S3 replacement method for class 'dual'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_+3A_x">x</code></td>
<td>
<p>a dual object</p>
</td></tr>
<tr><td><code id="shape_+3A_value">value</code></td>
<td>
<p>for replacement methods, the new value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the methods 'dimnames' and 'dimnanes&lt;-.dual' have been defined,
you can use 'rownames' and 'colnames' as with numeric matrices (see examples).
</p>


<h3>Value</h3>

<p>Return values are similar to the base methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( matrix(c(1,0,2,3,2,4), 2, 3) )
dim(x)
length(x)
rownames(x) &lt;- c("L1", "L2")
x
d(x, "x1.1")

# modifying dim is the recommended way to change dual object shape
dim(x) &lt;- NULL
x

# back to matrix shape
dim(x) &lt;- c(2, 3)
x
</code></pre>

<hr>
<h2 id='Summary'>Summary methods for objects of class dual</h2><span id='topic+Summary'></span><span id='topic+sum.dual'></span><span id='topic+sum'></span><span id='topic+prod'></span><span id='topic+min'></span><span id='topic+max'></span><span id='topic+range'></span><span id='topic+which.min'></span><span id='topic+which.max'></span><span id='topic+sum+2CnumericOrArray-method'></span><span id='topic+prod.dual'></span><span id='topic+prod+2CnumericOrArray-method'></span><span id='topic+max.dual'></span><span id='topic+max+2CnumericOrArray-method'></span><span id='topic+min.dual'></span><span id='topic+min+2CnumericOrArray-method'></span><span id='topic+range.dual'></span><span id='topic+range+2CnumericOrArray-method'></span><span id='topic+which.min+2Cdual-method'></span><span id='topic+which.max+2Cdual-method'></span>

<h3>Description</h3>

<p>Methods extending to dual objects the corresponding methods for numeric objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
sum(x, ..., na.rm = FALSE)

## S4 method for signature 'numericOrArray'
sum(x, ..., na.rm = FALSE)

## S3 method for class 'dual'
prod(x, ..., na.rm = FALSE)

## S4 method for signature 'numericOrArray'
prod(x, ..., na.rm = FALSE)

## S3 method for class 'dual'
max(x, ..., na.rm = TRUE)

## S4 method for signature 'numericOrArray'
max(x, ..., na.rm = TRUE)

## S3 method for class 'dual'
min(x, ..., na.rm = TRUE)

## S4 method for signature 'numericOrArray'
min(x, ..., na.rm = TRUE)

## S3 method for class 'dual'
range(x, ..., na.rm = TRUE)

## S4 method for signature 'numericOrArray'
range(x, ..., na.rm = TRUE)

## S4 method for signature 'dual'
which.min(x)

## S4 method for signature 'dual'
which.max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary_+3A_x">x</code></td>
<td>
<p>a dual object</p>
</td></tr>
<tr><td><code id="Summary_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
<tr><td><code id="Summary_+3A_na.rm">na.rm</code></td>
<td>
<p>if 'TRUE', NA values are removed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 'max' and 'min', the derivative is equal to the derivative of maximum element
as identified by 'which.max' and 'which.min'. This is unfortunately problematic in presence
of ties. If this is an issue, you may redefine this function (at the expense of speed).
</p>


<h3>Value</h3>

<p>'which.min' and 'which.max' return an integer, the other methods return a dual object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( c(1,2,4) )
sum(x)
d(sum(x), "x1")

</code></pre>

<hr>
<h2 id='t'>Transposition of matrices and arrays</h2><span id='topic+t'></span><span id='topic+t.dual'></span><span id='topic+aperm'></span><span id='topic+aperm.dual'></span>

<h3>Description</h3>

<p>Transposition of matrices and arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
t(x)

## S3 method for class 'dual'
aperm(a, perm = NULL, resize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_+3A_x">x</code>, <code id="t_+3A_a">a</code></td>
<td>
<p>a dual matrix or array</p>
</td></tr>
<tr><td><code id="t_+3A_perm">perm</code></td>
<td>
<p>subscript permutation vector</p>
</td></tr>
<tr><td><code id="t_+3A_resize">resize</code></td>
<td>
<p>if 'TRUE' (default) the array is reshaped</p>
</td></tr>
<tr><td><code id="t_+3A_...">...</code></td>
<td>
<p>extra arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dual matrix or array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dual( matrix(c(1,2,0,3), 2, 2) )
t(x)

# creation of an array using dim&lt;-
y &lt;- dual( c(1,-1) ) + 1:12
dim(y) &lt;- c(2,3,2)
z &lt;- aperm(y, c(2,3,1))
z
d(z, "x1")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
