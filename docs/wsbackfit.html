<!DOCTYPE html><html lang="en"><head><title>Help for package wsbackfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wsbackfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wsbackfit-package'>
<p>Weighted Smooth Backfitting for Structured Models</p></a></li>
<li><a href='#infect'>
<p>Postoperative Infection Data.</p></a></li>
<li><a href='#plot.sback'>
<p>Default sback plotting</p></a></li>
<li><a href='#predict.sback'>
<p>Predict method for sback fits</p></a></li>
<li><a href='#print.sback'>
<p>Print a <code>sback</code> object.</p></a></li>
<li><a href='#residuals.sback'>
<p>sback residuals</p></a></li>
<li><a href='#sb'>
<p>Specify a nonparametric and/or a varying coefficient term in a wsbackfit formula</p></a></li>
<li><a href='#sback'>
<p>Generalized additive and partially linear models</p></a></li>
<li><a href='#summary.sback'>
<p>Summary for a <code>sback</code> fitted object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Smooth Backfitting for Structured Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-30</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Non- and semiparametric regression for generalized additive, partial linear, and varying coefficient models as well as their combinations via smoothed backfitting. Based on Roca-Pardinas J and Sperlich S (2010) &lt;<a href="https://doi.org/10.1007%2Fs11222-009-9130-2">doi:10.1007/s11222-009-9130-2</a>&gt;; Mammen E, Linton O and Nielsen J (1999) &lt;<a href="https://doi.org/10.1214%2Faos%2F1017939138">doi:10.1214/aos/1017939138</a>&gt;; Lee YK, Mammen E, Park BU (2012) &lt;<a href="https://doi.org/10.1214%2F12-AOS1026">doi:10.1214/12-AOS1026</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-04 09:13:36 UTC; mrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier Roca-Pardinas [aut, cre],
  Maria Xose Rodriguez-Alvarez [aut],
  Stefan Sperlich [aut],
  Alan Miller (FORTRAN code lsq.f90: weighted least-squares module) [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier Roca-Pardinas &lt;roca@uvigo.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-04 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wsbackfit-package'>
Weighted Smooth Backfitting for Structured Models
</h2><span id='topic+wsbackfit-package'></span><span id='topic+wsbackfit'></span>

<h3>Description</h3>

<p>Non- and semiparametric regression for generalized additive, partial linear, and varying coefficient models as well as their combinations. Specifically, the package provides estimation procedures for a large class of regression models common in applied statistics. The regression models belong to the class of the so-called generalized structured models, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">E[Y|X,Z] = G(g_0 + \sum_j g_j (X_j) Z_j  + Z_k^{'}\beta).</code>
</p>

<p>Note that, up to identification restrictions specified e.g. in Park and Mammen (2006), several of the <code class="reqn">X_j</code> and <code class="reqn">Z_j</code> can refer to the same variable. For example, all <code class="reqn">X_j</code> may be the same but all <code class="reqn">Z_j</code> different.
</p>
<p>The estimation procedure is based on smoothed backfitting which to our knowledge is the statistically most efficient existing procedure for this model class. Additional weights allow sampling weights, trimming, or efficient estimation under heteroscedasticity. This package also allows to either set the bandwidths or automatically select them using k-fold cross-validation. The option 'offset' facilitates the application of smooth backfitting on aggregated data.   
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> wsbackfit</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-04-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez, Stefan Sperlich
</p>
<p>Maintainer: Javier Roca-Pardinas &lt;roca@uvigo.es&gt;
</p>


<h3>References</h3>

<p>Han, K. and Park B.U. (2018). Smooth backfitting for errors-in-variables additive models. Annals of Statistics, 46, 2216-2250.
</p>
<p>Lee, Y.K., Mammen, E. and Park, B.U. (2012). Flexible generalized varying coefficient regression models. The Annals of Statistics, 40(3), 1906-1933.
</p>
<p>Mammen, E. and Nielsen, J. (2003). Generalised structured models. Biometrika, 90, 551-566.
</p>
<p>Mammen, E. Linton, O. and Nielsen, J. (1999). The existence and asymptotic properties of a backfitting projection algorithm under weak conditions. Annals of Statistics, 27 (5), 1443-1490.
</p>
<p>Mammen, E. and Park, B.U. (2006). A simple smooth backfitting method for additive models. Annals of Statistics, 34 (5), 2252-2271.
</p>
<p>Nielsen. J. and Sperlich, S. (2005). Smooth backfitting in practice. Journal of the Royal Statistical Society, B, 67, 43-61.
</p>
<p>Roca-Pardinas, J. and Sperlich, S. (2010). Feasible Estimation in Generalized Structured Models. Statistics and Computing, 20, 367-379.
</p>

<hr>
<h2 id='infect'>
Postoperative Infection Data.
</h2><span id='topic+infect'></span>

<h3>Description</h3>

<p>Data from a prospective study conducted at the University Hospital of Santiago de Compostela (Spain). A total of 2318 patients who underwent surgery at this center between January 1996 and March 1997 were characterized post-operatively, in respect of whether they suffered or not post-operative infection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(infect)</code></pre>


<h3>Format</h3>

<p>A data frame with 2318 observations on the following 6 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>patient's age.</p>
</dd>
<dt><code>sex</code></dt><dd><p>patient's sex. Coded as  1 = <code>Man</code> and 2 = <code>Woman</code>.</p>
</dd>
<dt><code>linf</code></dt><dd><p>lymphocytes (expressed as relative counts (in %) of the white blood cell count)</p>
</dd>
<dt><code>gluc</code></dt><dd><p>plasma glucose concentration (measured in mg/dl)</p>
</dd>
<dt><code>diab</code></dt><dd><p>diabetes. Coded as 1 = presence and 2 = absence.</p>
</dd>
<dt><code>inf</code></dt><dd><p>variable indicating whether the patient suffered (inf = 1) or not (inf = 0) a post-operative infection.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(infect)
summary(infect)
</code></pre>

<hr>
<h2 id='plot.sback'>
Default sback plotting
</h2><span id='topic+plot.sback'></span>

<h3>Description</h3>

<p>Takes a fitted object produced by <code>sback()</code> and plots the estimates of the nonparametric functions on the scale of their respective covariates, no matter whether a particular nonparametric function is an additive component or a varying coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sback'
plot(x, composed = TRUE, ask = TRUE, select = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sback_+3A_x">x</code></td>
<td>
<p>an object of class <code>sback</code> as produced by <code>sback()</code>.</p>
</td></tr>
<tr><td><code id="plot.sback_+3A_composed">composed</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the default, the function plots the estimates of the composed (linear plus nonlinear) nonparametric functions (see Details).</p>
</td></tr>
<tr><td><code id="plot.sback_+3A_ask">ask</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the default, the user is asked for confirmation, before a new figure is drawn.</p>
</td></tr>
<tr><td><code id="plot.sback_+3A_select">select</code></td>
<td>
<p>Allows the plot for a single model term to be selected for printing. e.g. if you just want the plot for the second smooth term set select = 2.</p>
</td></tr>
<tr><td><code id="plot.sback_+3A_...">...</code></td>
<td>
<p>other graphics parameters to pass on to plotting commands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For identifiability purposes, the estimating algorithm implemented in the <code>wsbackfit</code> package decomposes each nonparametric function in two components: a linear (parametric) component and a nonlinear (nonparametric) component. For plotting, the user can choose to plot these components either separately in one graph (<code>composed = FALSE</code>), or to only plot the resulting composed function (<code>composed = TRUE</code>). Also, for the varying coefficient terms, the plots show the estimated surface spanned by <code class="reqn">(g_j , X_j , Z_j)</code>.</p>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
################################################
# Gaussian Simulated Sample
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000
x1 &lt;- runif(n)*4-2
x2 &lt;- runif(n)*4-2
x3 &lt;- runif(n)*4-2
x4 &lt;- runif(n)*4-2
x5 &lt;- as.numeric(runif(n)&gt;0.6)

f1 &lt;- 2*sin(2*x1)
f2 &lt;- x2^2
f3 &lt;- 0
f4 &lt;- x4
f5 &lt;- 1.5*x5

mu &lt;- f1 + f2 + f3 + f4 + f5
err &lt;- (0.5 + 0.5*x5)*rnorm(n)
y &lt;- mu + err

df &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = as.factor(x5), y = y)

# Fit the model with a fixed bandwidth for each covariate
m0 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.13) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), kbin = 30, data = df)

plot(m0)

</code></pre>

<hr>
<h2 id='predict.sback'>
Predict method for sback fits
</h2><span id='topic+predict.sback'></span>

<h3>Description</h3>

<p>Predicted smooth functions and values based on an sback object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sback'
predict(object, newdata, newoffset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sback_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+sback">sback</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sback_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the values of the covariates at which predictions are wanted. If not provided then the predictions correspond to the original data.</p>
</td></tr>
<tr><td><code id="predict.sback_+3A_newoffset">newoffset</code></td>
<td>
<p>an optional numerical vector containing an a priori known component to be included in the linear predictor for the predictions (offset associated with the newdata).</p>
</td></tr>
<tr><td><code id="predict.sback_+3A_...">...</code></td>
<td>
<p>not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>pdata</code></td>
<td>
<p>the original supplied <code>newdata</code> argument.</p>
</td></tr>
<tr><td><code>poffset</code></td>
<td>
<p>the original supplied <code>newoffset</code> argument.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>a numeric vector with the estimated coefficients. This vector includes both the parametric effects as well as the coefficients associated with the linear component of the nonparametric functions.</p>
</td></tr>
<tr><td><code>peffects</code></td>
<td>
<p>matrix with the estimated nonparametric functions (only the nonlinear component) for each covariate value in the original supplied newdata.</p>
</td></tr>
<tr><td><code>pfitted.values</code></td>
<td>
<p>a numeric vector with the fitted values for the supplied newdata.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
data(infect)

# Generalized varying coefficient model with binary response
m3 &lt;- sback(formula = inf ~ sb(gluc, h = 10) + sb(gluc, by = linf, h = 10), 
  data = infect, family = "binomial", kbin = 15)

summary(m3)

# Plot both linear and non linear 
# components of nonparametric functions: composed = FALSE
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,3))
plot(m3, composed = FALSE)

# Personalized plots
# First obtain predictions in new data
# Create newdata for prediction
ngrid &lt;- 30
gluc0 &lt;- seq(50, 190, length = ngrid)
linf0 &lt;- seq(0, 45, length = ngrid)
df  &lt;- expand.grid(gluc = gluc0, linf = linf0)

m3p &lt;- predict(m3, newdata = df)

par(mfrow = c(1,2))
ii &lt;- order(df[,"gluc"])

## Parametric coefficients
names(m3p$coeff)

# Nonlinear components
colnames(m3p$peffects) 

# Include the linear component
plot(df[ii,"gluc"], m3p$coeff[["gluc"]]*df[ii,"gluc"] + 
  m3p$peffects[ii,"sb(gluc, h = 10)"], 
  type = 'l', xlab = "Glucose (mg/dl)", ylab = "f_1(gluc)", 
  main = "Nonparametric effect of Glucose")

# Include the linear component
plot(df[ii,"gluc"], m3p$coeff[["gluc:linf"]]*df[ii,"gluc"] + 
  m3p$peffects[ii,"sb(gluc, h = 10, by = linf)"], 
  type= 'l', xlab = "Glucose (mg/dl)", ylab = "f_2(gluc)",
  main = "Varying coefficients as a function of Glucose")

# Countour plot of the probability of post-opererational infection
n &lt;- sqrt(nrow(df))
Z &lt;- matrix(m3p$pfitted.values, n, n)
filled.contour(z = Z, x = gluc0, y = linf0, 
  xlab = "Glucose (mg/dl)", ylab = "Lymphocytes (%)",
  main = "Probability of post-opererational infection")

par(op)

</code></pre>

<hr>
<h2 id='print.sback'>
Print a <code>sback</code> object.
</h2><span id='topic+print.sback'></span>

<h3>Description</h3>

<p>The default print method for a <code>sback</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sback'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sback_+3A_x">x</code></td>
<td>
<p>an object of class <code>sback</code> as produced by <code><a href="#topic+sback">sback</a></code>.</p>
</td></tr>
<tr><td><code id="print.sback_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>, <code><a href="#topic+plot.sback">plot.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
###############################################
# Gaussian Simulated Sample
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000
x1 &lt;- runif(n)*4-2
x2 &lt;- runif(n)*4-2
x3 &lt;- runif(n)*4-2
x4 &lt;- runif(n)*4-2
x5 &lt;- as.numeric(runif(n)&gt;0.6)

f1 &lt;- 2*sin(2*x1)
f2 &lt;- x2^2
f3 &lt;- 0
f4 &lt;- x4
f5 &lt;- 1.5*x5

mu &lt;- f1 + f2 + f3 + f4 + f5
err &lt;- (0.5 + 0.5*x5)*rnorm(n)
y &lt;- mu + err

df &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = as.factor(x5), y = y)

# Fit the model with a fixed bandwidth for each covariate
m0 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.1) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), kbin = 30, data = df)
  
m0
</code></pre>

<hr>
<h2 id='residuals.sback'>
sback residuals
</h2><span id='topic+residuals.sback'></span>

<h3>Description</h3>

<p>Returns residuals for a fitted <code>sback</code> object. Deviance, pearson, working and response residuals are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sback'
residuals(object, type = c("deviance", "pearson", "working", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.sback_+3A_object">object</code></td>
<td>
<p>an object of class <code>sback</code> as produced by <code><a href="#topic+sback">sback</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.sback_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned: &quot;deviance&quot; (default), &quot;pearson&quot;, &quot;working&quot; and &quot;response&quot;.</p>
</td></tr>
<tr><td><code id="residuals.sback_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>.
</p>


<h3>Value</h3>

<p>Numeric vector with the residuals.</p>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>, <code><a href="#topic+plot.sback">plot.sback</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
data(infect)

# Generalized varying coefficient model with binary response
m3 &lt;- sback(formula = inf ~ sb(gluc, h = 10) + sb(gluc, by = linf, h = 10), 
  data = infect, family = "binomial", kbin = 15)

summary(m3)

# Deviance
summary(residuals(m3))

# Pearson
summary(residuals(m3, type = "pearson"))
</code></pre>

<hr>
<h2 id='sb'>
Specify a nonparametric and/or a varying coefficient term in a wsbackfit formula
</h2><span id='topic+sb'></span>

<h3>Description</h3>

<p>Function used to indicate nonparametric terms and varying coefficient terms in a <code><a href="#topic+sback">sback</a></code> formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sb(x1 = NULL, by = NULL, h = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sb_+3A_x1">x1</code></td>
<td>
<p>the univariate predictor</p>
</td></tr>
<tr><td><code id="sb_+3A_by">by</code></td>
<td>
<p>numeric predictor of the same dimension as <code>x1</code>. If present, the coefficients of this predictor depend, nonparametrically, on <code>x1</code>, i.e., a varying coefficient term.</p>
</td></tr>
<tr><td><code id="sb_+3A_h">h</code></td>
<td>
<p>bandwidth (on the scale of the predictor) for this term. If <code>h = -1</code>, the bandwidth is automatically selected using k-fold cross-validation (see <code><a href="#topic+sback">sback</a></code>). A value of 0 would indicate a linear fit. By default -1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p>character vector with the name(s) of the involved predictor(s).</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>numeric value with the specified smoothing parameter.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>, <code><a href="#topic+plot.sback">plot.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
set.seed(123)
###############################################
# Gaussian Simulated Sample
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000
x1 &lt;- runif(n)*4-2
x2 &lt;- runif(n)*4-2
x3 &lt;- runif(n)*4-2
x4 &lt;- runif(n)*4-2
x5 &lt;- as.numeric(runif(n)&gt;0.6)

f1 &lt;- 2*sin(2*x1)
f2 &lt;- x2^2
f3 &lt;- 0
f4 &lt;- x4
f5 &lt;- 1.5*x5

mu &lt;- f1 + f2 + f3 + f4 + f5
err &lt;- (0.5 + 0.5*x5)*rnorm(n)
y &lt;- mu + err

df &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = as.factor(x5), y = y)

# Fit the model with a fixed bandwidth for each covariate
m0 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.1) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), kbin = 30, data = df)

summary(m0)

op &lt;- par(no.readonly = TRUE)

par(mfrow = c(2,2))
plot(m0)


# Fit the model with the bandwidths selected by k-fold cross-validation.
m1 &lt;- sback(formula = y ~ x5 + sb(x1, h = -1) + sb(x2, h = -1) 
  + sb(x3, h = -1) + sb(x4, h = -1), kbin = 30, bw.grid = seq(0.01, 0.99, length = 30),
  data = df)

summary(m1)

par(mfrow = c(2,2))
plot(m1)


par(op)
</code></pre>

<hr>
<h2 id='sback'>
Generalized additive and partially linear models
</h2><span id='topic+sback'></span>

<h3>Description</h3>

<p>Main function for fitting generalized structured models by using smooth backfitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sback(formula, data, offset = NULL, weights = NULL, 
  kernel = c("Gaussian", "Epanechnikov"), 
  bw.grid = seq(0.01, 0.99, length = 30), c.bw.factor = FALSE,
  KfoldCV = 5, kbin = 30, 
  family = c("gaussian", "binomial", "poisson"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sback_+3A_formula">formula</code></td>
<td>

<p>a <code><a href="stats.html#topic+formula">formula</a></code> object specifying the model to be fitted (see Details). 
</p>
</td></tr>
<tr><td><code id="sback_+3A_data">data</code></td>
<td>

<p>data frame representing the data and containing all needed variables
</p>
</td></tr>
<tr><td><code id="sback_+3A_offset">offset</code></td>
<td>

<p>an optional numerical vector containing priori known components to be included in the linear predictor during fitting. Default is zero.
</p>
</td></tr>
<tr><td><code id="sback_+3A_weights">weights</code></td>
<td>

<p>an optional numeric vector of &lsquo;prior weights&rsquo; to be used in the fitting process. By default, the weights are set to one.
</p>
</td></tr>
<tr><td><code id="sback_+3A_kernel">kernel</code></td>
<td>

<p>a character specifying the kernel function. Implemented are: Gaussian and Epanechnikov. By default &lsquo;Gaussian&rsquo;.
</p>
</td></tr>
<tr><td><code id="sback_+3A_bw.grid">bw.grid</code></td>
<td>

<p>numeric vector; a grid for for searching the bandwidth factor <code class="reqn">h_c</code> when using cross-validation. The bandwidth for dimension (covariate) <code class="reqn">j</code> is <code class="reqn">h_c \sigma_j</code>, with <code class="reqn">\sigma_j</code> being the standard deviation of <code class="reqn">X_j</code> (see Details). Default is a sequence of length 30 between 0.01 and 0.99.  
</p>
</td></tr>
<tr><td><code id="sback_+3A_c.bw.factor">c.bw.factor</code></td>
<td>

<p>logical; indicates whether the common factor scheme for bandwidth selection proposed by Han and Park (2018) is performed. If TRUE, and provided the user has specified the (marginal) bandwidths for all nonparametric functions, say <code class="reqn">h_j</code>, the functions searches for the common factor <code class="reqn">c_h</code> that minimizes the deviance via (k-fold) cross-validation when the bandwidth used for dimension (covariate) <code class="reqn">j</code> is <code class="reqn">c_h h_j</code>. The search is done in an equispaced grid of length 15 between 0.5 and 1.5. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="sback_+3A_kfoldcv">KfoldCV</code></td>
<td>

<p>number of cross-validation folds to be used for either (1) automatically selecting the optimal bandwidth (in the sequence given in argument <code>bw.grid</code>) for each nonparametric function; or (2) automatically selecting the optimal common bandwidth factor (see argument <code>c.bw.factor</code>). Default is 5.
</p>
</td></tr>
<tr><td><code id="sback_+3A_kbin">kbin</code></td>
<td>

<p>an integer value specifying the number of binning knots. Default is 30.
</p>
</td></tr>
<tr><td><code id="sback_+3A_family">family</code></td>
<td>

<p>a character specifying the distribution family. Implemented are: Gaussian, Binomial and Poisson. In all cases, the link function is the canonical one (logit for binomial, identity for Gaussian and logarithm for Poisson). By default &lsquo;gaussian&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>formula</code> corresponds to the model for the conditional mean function, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">E[Y|X,Z] = G(g_0 + \sum_j g_j (X_j) Z_j  + Z_k^{'}\beta).</code>
</p>

<p>This formula is similar to that used for the <code><a href="stats.html#topic+glm">glm</a></code> function, except that nonparametric functions can be added to the additive predictor by means of function <code><a href="#topic+sb">sb</a></code>. For instance, specification <code>y ~ x1 + sb(x2, h = -1)</code> assumes a parametric effect of <code>x1</code> (with <code>x1</code> either numerical or categorical), and a nonparametric effect of <code>x2</code>. <code>h = -1</code> indicates that the bandwidth should be selected using k-fold cross-validation. Varying coefficient terms get incorporated similarly. For example, <code>y ~ sb(x1, by = x2)</code> indicates that the coefficients of <code>x2</code> depend, nonparametrically, on <code>x1</code>. In this case both, <code>x1</code> and <code>x2</code>, should be numerical predictors. 
</p>
<p>With respect to the bandwidths associated with each nonparametric function specified using function <code><a href="#topic+sb">sb</a></code>, the user has two options: a) to specify in the formula the desired bandwidth - on the scale of the predictor - through argument <code>h</code> of function <code><a href="#topic+sb">sb</a></code> (followed or not by the common bandwidth factor scheme proposed by Han and Park (2018); see argument <code>c.bw.factor</code>); or, b) to allow the bandwidths to be automatically and data adaptively selected via cross-validation. In the latter case, the estimation procedure tests each of the bandwidth factors supplied in argument <code>bw.grid</code>, and selects the one that minimizes the deviance via (k-fold) cross-validation. The number k of cross-validation folds is specified through argument <code>KfoldCV</code>, with 5 by default. We note that when using cross-validation, to ensure that the bandwidths associated with the nonparametric functions are on the scale of the predictors, the finally used bandwidth is <code class="reqn">h_j =  h \sigma_j</code> with <code class="reqn">\sigma_j</code> being the standard deviation of <code class="reqn">X_j</code>. That is, before fitting the model, each bandwidth factor <code class="reqn">h</code> provided in <code>bw.grid</code> is multiplied by the standard deviation of the corresponding predictor. Note that the user has also the possibility to specify the bandwidths for some nonparametric function (through argument <code>h</code>), while letting for the remaining nonparametric functions the procedure select the bandwidths by cross-validation. For these functions, argument <code>h</code> should be set to -1. In this case, the common bandwidth factor scheme proposed by Han and Park (2018) cannot be used as it requires that all bandwidths are specified. 
</p>
<p>Finally, it is worth noting that for identifiability purposes, the estimating algorithm implemented in the <code>wsbackfit</code> package decomposes each nonparametric function in two components: a linear (parametric) component and a nonlinear (nonparametric) component. Note that it implies that for a varying coefficient term <code>~ sb(x1, by = x2)</code>, the parametric part includes the linear component associated with <code>x1</code>, as well as the linear interaction between <code>x1</code> and <code>x2</code>.     
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original supplied <code>formula</code> argument.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the original supplied <code>data</code> argument.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the original supplied <code>offset</code> argument.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the original supplied <code>weights</code> argument.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>the original supplied <code>kernel</code> argument.</p>
</td></tr>
<tr><td><code>kbin</code></td>
<td>
<p>the original supplied <code>kbin</code> argument.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the original supplied <code>family</code> argument.</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>matrix with the estimated nonparametric functions (only the nonlinear component) for each covariate value in the original supplied data.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a numeric vector with the fitted values for the supplied data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a numeric vector with the deviance residuals for the supplied data.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>a numeric vector of the same length as the number of nonparametric functions, with the bandwidths actually used in the estimation (scaled. See Details).</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>a numeric vector with the estimated coefficients. This vector includes both the parametric effects as well as the coefficients associated with the linear component of the nonparametric functions. </p>
</td></tr>
<tr><td><code>err.CV</code></td>
<td>
<p>matrix with the cross-validated error (deviance) associated with the sequence of tested (unscaled) bandwidths. Each line corresponds to a particular bandwidth (unscaled. See Details).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez and Stefan Sperlich</p>


<h3>References</h3>

<p>Han, K. and Park B.U. (2018). Smooth backfitting for errors-in-variables additive models. Annals of Statistics, 46, 2216-2250.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sb">sb</a></code>, <code><a href="#topic+print.sback">print.sback</a></code>, <code><a href="#topic+summary.sback">summary.sback</a></code>, <code><a href="#topic+plot.sback">plot.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
###############################################
# Gaussian Simulated Sample
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000
x1 &lt;- runif(n)*4-2
x2 &lt;- runif(n)*4-2
x3 &lt;- runif(n)*4-2
x4 &lt;- runif(n)*4-2
x5 &lt;- as.numeric(runif(n)&gt;0.6)

f1 &lt;- 2*sin(2*x1)
f2 &lt;- x2^2
f3 &lt;- 0
f4 &lt;- x4
f5 &lt;- 1.5*x5

mu &lt;- f1 + f2 + f3 + f4 + f5
err &lt;- (0.5 + 0.5*x5)*rnorm(n)
y &lt;- mu + err

df &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = as.factor(x5), y = y)

# Fit the model with a fixed bandwidth for each covariate
m0 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.1) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), kbin = 30, data = df)

summary(m0)

op &lt;- par(no.readonly = TRUE)

par(mfrow = c(2,2))
plot(m0)

# Fit the model with bandwidths selectec using K-fold cross-validation
## Not run: 
m0cv &lt;- sback(formula = y ~ x5 + sb(x1) + sb(x2) 
  + sb(x3) + sb(x4), kbin = 30, bw.grid = seq(0.01, 0.99, length = 30), KfoldCV = 5, 
  data = df)

summary(m0cv)

par(mfrow = c(2,2))
plot(m0cv)

## End(Not run)

# Estimate Variance as a function of x5 (which is binary)
resid &lt;- y - m0$fitted.values
sig0 &lt;- var(resid[x5 == 0])
sig1 &lt;- var(resid[x5 == 1])
w &lt;- x5/sig1 + (1-x5)/sig0
m1 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.1) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), weights = w, kbin = 30, data = df)

summary(m1)

par(mfrow = c(2,2))
plot(m1)

###############################################
# Poisson Simulated Data
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000

x1 &lt;- runif(n,-1,1)
x2 &lt;- runif(n,-1,1)

eta &lt;- 2 + 3*x1^2 + 5*x2^3

exposure &lt;- round(runif(n, 50, 500))
y &lt;- rpois(n, exposure*exp(eta))
df &lt;- data.frame(y = y, x1 = x1, x2 = x2)

# Fit the model
m2 &lt;- sback(formula = y ~ sb(x1, h = 0.1) + sb(x2, h = 0.1), 
  data = df, offset = log(exposure), 
  kbin = 30, family = "poisson")

summary(m2)

par(mfrow = c(1,2))
plot(m2)

# Dataframe and offset for prediction
n.p &lt;- 100
newoffset &lt;- rep(0, n.p)
df.pred &lt;- data.frame(x1 = seq(-1, 1,l = n.p), x2 = seq(-1, 1,l = n.p))

m2p &lt;- predict(m2, newdata = df.pred, newoffset = newoffset)

###############################################
# Postoperative Infection Data
###############################################
data(infect)

# Generalized varying coefficient model with binary response
m3 &lt;- sback(formula = inf ~ sb(gluc, h = 10) + sb(gluc, by = linf, h = 10), 
  data = infect, family = "binomial", kbin = 15)

summary(m3)

# Plot both linear and non linear 
# components of nonparametric functions: composed = FALSE
par(mfrow = c(1,3))
plot(m3, composed = FALSE)

# Personalized plots
# First obtain predictions in new data
# Create newdata for prediction
ngrid &lt;- 30
gluc0 &lt;- seq(50, 190, length = ngrid)
linf0 &lt;- seq(0, 45, length = ngrid)
df  &lt;- expand.grid(gluc = gluc0, linf = linf0)

m3p &lt;- predict(m3, newdata = df)

par(mfrow = c(1,2))
ii &lt;- order(df[,"gluc"])

## Parametric coefficients
names(m3p$coeff)

# Nonlinear components
colnames(m3p$peffects) 

# Include the linear component
plot(df[ii,"gluc"], m3p$coeff[["gluc"]]*df[ii,"gluc"] + 
  m3p$peffects[ii,"sb(gluc, h = 10)"], 
  type = 'l', xlab = "Glucose (mg/dl)", ylab = "f_1(gluc)", 
  main = "Nonparametric effect of Glucose")

# Include the linear component
plot(df[ii,"gluc"], m3p$coeff[["gluc:linf"]]*df[ii,"gluc"] + 
  m3p$peffects[ii,"sb(gluc, h = 10, by = linf)"], 
  type= 'l', xlab = "Glucose (mg/dl)", ylab = "f_2(gluc)",
  main = "Varying coefficients as a function of Glucose")

# Countour plot of the probability of post-opererational infection
n &lt;- sqrt(nrow(df))
Z &lt;- matrix(m3p$pfitted.values, n, n)
filled.contour(z = Z, x = gluc0, y = linf0, 
  xlab = "Glucose (mg/dl)", ylab = "Lymphocytes (%)",
  main = "Probability of post-opererational infection")

par(op)
</code></pre>

<hr>
<h2 id='summary.sback'>
Summary for a <code>sback</code> fitted object
</h2><span id='topic+summary.sback'></span>

<h3>Description</h3>

<p>Takes a fitted object produced by <code>sback()</code> and produces various useful summaries from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sback'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sback_+3A_object">object</code></td>
<td>
<p>an object of class <code>sback</code> as produced by <code>sback()</code>.</p>
</td></tr>
<tr><td><code id="summary.sback_+3A_...">...</code></td>
<td>
<p>other arguments (not implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.sback</code> with the information needed to print the results.</p>


<h3>Author(s)</h3>

<p>Javier Roca-Pardinas, Maria Xose Rodriguez-Alvarez, Stefan Sperlich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sback">sback</a></code>, <code><a href="#topic+plot.sback">plot.sback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(wsbackfit)
set.seed(123)
###############################################
# Gaussian Simulated Sample
###############################################
set.seed(123)
# Define the data generating process
n &lt;- 1000
x1 &lt;- runif(n)*4-2
x2 &lt;- runif(n)*4-2
x3 &lt;- runif(n)*4-2
x4 &lt;- runif(n)*4-2
x5 &lt;- as.numeric(runif(n)&gt;0.6)

f1 &lt;- 2*sin(2*x1)
f2 &lt;- x2^2
f3 &lt;- 0
f4 &lt;- x4
f5 &lt;- 1.5*x5

mu &lt;- f1 + f2 + f3 + f4 + f5
err &lt;- (0.5 + 0.5*x5)*rnorm(n)
y &lt;- mu + err

df &lt;- data.frame(x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = as.factor(x5), y = y)

# Fit the model with a fixed bandwidth for each covariate
m0 &lt;- sback(formula = y ~ x5 + sb(x1, h = 0.1) + sb(x2, h = 0.13) 
  + sb(x3, h = 0.1) + sb(x4, h = 0.1), kbin = 30, data = df)

summary(m0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
