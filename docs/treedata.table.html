<!DOCTYPE html><html><head><title>Help for package treedata.table</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treedata.table}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.treedata.table'><p>Function for performing data.table operations on an object of class</p>
<code>treedata.table</code></a></li>
<li><a href='#[[.treedata.table'><p>Function for extract a named vector from an object of class <code>treedata.table</code></p></a></li>
<li><a href='#anolis'><p>Anole data</p></a></li>
<li><a href='#as.treedata.table'><p>Combine tree (or set of trees) and data.frame into a single treedata.table</p>
object</a></li>
<li><a href='#detectAllCharacters'><p>Apply detectCharacterType over an entire matrix</p></a></li>
<li><a href='#detectCharacterType'><p>Function to detect whether a character is continuous or discrete</p></a></li>
<li><a href='#droptreedata.table'><p>Function dropping taxa from an object of class <code>treedata.table</code></p></a></li>
<li><a href='#extractVector'><p>Returning a named vector from a treedata.table object</p></a></li>
<li><a href='#filterMatrix'><p>Filter a character matrix, returning either all continuous or all discrete characters</p></a></li>
<li><a href='#forceNames'><p>Force names for rows, columns, or both</p></a></li>
<li><a href='#hasNames'><p>Row and column name check</p></a></li>
<li><a href='#head.treedata.table'><p>Return the first part of an treedata.table object</p></a></li>
<li><a href='#print.treedata.table'><p>Print method treedata.table objects</p></a></li>
<li><a href='#pulltreedata.table'><p>Returns the character matrix or phylogeny from a treedata.table object</p></a></li>
<li><a href='#summary.treedata.table'><p>Summarizing treedata.table objects</p></a></li>
<li><a href='#tail.treedata.table'><p>Return the last part of an treedata.table object</p></a></li>
<li><a href='#tdt'><p>Run a function on a <code>treedata.table</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Manipulation of Matched Phylogenies and Data using 'data.table'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/treedata.table/">https://docs.ropensci.org/treedata.table/</a> (website)
<a href="https://github.com/ropensci/treedata.table/">https://github.com/ropensci/treedata.table/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/treedata.table/issues">https://github.com/ropensci/treedata.table/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation that combines trait data and a phylogenetic tree (or trees) into a 
    single object of class treedata.table. The resulting object can be easily 
    manipulated to simultaneously change the trait- and tree-level sampling.
    Currently implemented functions allow users to use a 'data.table' syntax when
    performing operations on the trait dataset within the treedata.table object.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lazyeval, ape, geiger, utils, data.table</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-27 13:09:41 UTC; cristianroman</td>
</tr>
<tr>
<td>Author:</td>
<td>Josef Uyeda <a href="https://orcid.org/0000-0003-4624-9680"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Cristian Roman-Palacios
    <a href="https://orcid.org/0000-0003-4692-3225"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre],
  April Wright <a href="https://orcid.org/0000-0003-4692-3225"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Luke Harmon [ctb],
  Hugo Gruson [rev],
  Kari Norman [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cristian Roman-Palacios &lt;cromanpa94@email.arizona.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-30 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.treedata.table'>Function for performing data.table operations on an object of class
<code>treedata.table</code></h2><span id='topic++5B.treedata.table'></span>

<h3>Description</h3>

<p>This function can be used to subset rows, select and compute on columns
<a href="data.table.html#topic+data.table">data.table</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
x[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.treedata.table_+3A_x">x</code></td>
<td>
<p>An object of class <code>treedata.table</code></p>
</td></tr>
<tr><td><code id="+2B5B.treedata.table_+3A_...">...</code></td>
<td>
<p>Arguments in the structure of <code>data.table</code> used to perform changes
on the <code>treedata.table</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new object of class <code>treedata.table</code> with <code style="white-space: pre;">&#8288;$dat&#8288;</code> and <code style="white-space: pre;">&#8288;$phy&#8288;</code>
corresponding with the changes set to <code style="white-space: pre;">&#8288;$dat&#8288;</code> using
<a href="data.table.html#topic+data.table">data.table</a>'s structure.
</p>


<h3>See Also</h3>

<p><a href="data.table.html#topic+data.table">data.table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anolis)
anolis2 &lt;- anolis$phy
anolis2$tip.label[1] &lt;- "NAA"
anolis1 &lt;- anolis$phy
anolis1$tip.label[1] &lt;- "NAA"
trees &lt;- list(anolis1, anolis2)
class(trees) &lt;- "multiPhylo"
treesFM &lt;- list(anolis$phy, anolis$phy)
class(treesFM) &lt;- "multiPhylo"

# A phylo object that fully matches the data
td &lt;- as.treedata.table(tree = anolis$phy, data = anolis$dat)
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
td[, SVL]
td[island == "Cuba" &amp; ecomorph == "TG", .(ecomorph, island, SVL)]
td[, utils::head(.SD, 1), by = .(ecomorph, island)]

# A multiphylo object that fully matches the data
td &lt;- as.treedata.table(tree = treesFM, data = anolis$dat)
td &lt;- as.treedata.table(treesFM, anolis$dat)
td[, SVL]
td[island == "Cuba" &amp; ecomorph == "TG", .(ecomorph, island, SVL)]
td[, utils::head(.SD, 1), by = .(ecomorph, island)]

# A phylo object that partially matches the data
td &lt;- as.treedata.table(tree = anolis1, data = anolis$dat)
td &lt;- as.treedata.table(anolis1, anolis$dat)
td[, SVL]
td[island == "Cuba" &amp; ecomorph == "TG", .(ecomorph, island, SVL)]
td[, utils::head(.SD, 1), by = .(ecomorph, island)]

# A multiphylo object that partially matches the data
td &lt;- as.treedata.table(tree = trees, data = anolis$dat)
td &lt;- as.treedata.table(trees, anolis$dat)
td[, SVL]
td[island == "Cuba" &amp; ecomorph == "TG", .(ecomorph, island, SVL)]
td[, utils::head(.SD, 1), by = .(ecomorph, island)]
</code></pre>

<hr>
<h2 id='+5B+5B.treedata.table'>Function for extract a named vector from an object of class <code>treedata.table</code></h2><span id='topic++5B+5B.treedata.table'></span>

<h3>Description</h3>

<p>This function extracts a named vector for any  trait from an object of class
<code>treedata.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
x[[..., exact = TRUE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.treedata.table_+3A_x">x</code></td>
<td>
<p>An object of class <code>treedata.table</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.treedata.table_+3A_...">...</code></td>
<td>
<p>Column name in class <code>character</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.treedata.table_+3A_exact">exact</code></td>
<td>
<p>whether exact search should be conducted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new object of class <code>vector</code> with names set to labels corresponding
to tip labels in the provided <code>treedata.table</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+data.table">data.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
# With a phylo object
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
td[["SVL"]]

# With a multiPhylo object
treesFM &lt;- list(anolis$phy, anolis$phy)
class(treesFM) &lt;- "multiPhylo"
td &lt;- as.treedata.table(treesFM, anolis$dat)
td[["SVL"]]
</code></pre>

<hr>
<h2 id='anolis'>Anole data</h2><span id='topic+anolis'></span>

<h3>Description</h3>

<p>Anole data for treedata.table functions. Many
of the traits (e.g. awesomeness, hostility) in this dataset
retrieved from treeplyr are based on random numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anolis)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Author(s)</h3>

<p>Luke Harmon
</p>

<hr>
<h2 id='as.treedata.table'>Combine tree (or set of trees) and data.frame into a single treedata.table
object</h2><span id='topic+as.treedata.table'></span>

<h3>Description</h3>

<p>This function takes as input a tree of class <code>phylo</code> or <code>multiPhylo</code> and a
<code>data.frame</code> and combines them into a treedata.table. If a <code>multiPhylo</code> is
provided, all trees must have the same tip.labels. <code>treedata.table</code> object is
sorted such that the rows in the data.table are matched to the tip.labels
of the phylogeny. Tip.labels on the tree must match a column of tip
names in the input data.frame. The output of this function will be a
treedata.table, which can be manipulated as a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.treedata.table(tree, data, name_column = "detect")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.treedata.table_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code>phylo</code> or multiple trees of class <code>multiPhylo</code></p>
</td></tr>
<tr><td><code id="as.treedata.table_+3A_data">data</code></td>
<td>
<p>A dataset in format <code>data.frame</code></p>
</td></tr>
<tr><td><code id="as.treedata.table_+3A_name_column">name_column</code></td>
<td>
<p>A character indicating the name of taxa in <code>data.frame</code>.
If set to <code>detect</code> (default) <code style="white-space: pre;">&#8288;as treedata.table&#8288;</code> will auto-detect this
column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>treedata.table</code> containing the tree and data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anolis)
anolis2 &lt;- anolis$phy
anolis2$tip.label[1] &lt;- "NAA"
anolis1 &lt;- anolis$phy
anolis1$tip.label[1] &lt;- "NAA"
trees &lt;- list(anolis1, anolis2)
class(trees) &lt;- "multiPhylo"
treesFM &lt;- list(anolis$phy, anolis$phy)
class(treesFM) &lt;- "multiPhylo"

# A phylo object that fully matches the data
td &lt;- as.treedata.table(tree = anolis$phy, data = anolis$dat)
# A multiphylo object that fully matches the data
td &lt;- as.treedata.table(tree = treesFM, data = anolis$dat)
# A phylo object that partially matches the data
td &lt;- as.treedata.table(tree = anolis1, data = anolis$dat)
# A multiphylo object that partially matches the data
td &lt;- as.treedata.table(tree = trees, data = anolis$dat)
</code></pre>

<hr>
<h2 id='detectAllCharacters'>Apply detectCharacterType over an entire matrix</h2><span id='topic+detectAllCharacters'></span>

<h3>Description</h3>

<p>This function detects whether each column in a matrix is a continuous
(e.g., with values 2.45, 9.35, and so on) or a discrete character
(e.g., with values blue, red, yellow).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectAllCharacters(mat, cutoff = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectAllCharacters_+3A_mat">mat</code></td>
<td>
<p>A matrix of data</p>
</td></tr>
<tr><td><code id="detectAllCharacters_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff value for deciding if numeric data might actually be
discrete: if nlev is the number of levels and n the length of dat, then
nlev / n should exceed cutoff, or the data will be classified as discrete</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of either &quot;discrete&quot; or &quot;continuous&quot; for each variable in
matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
detectAllCharacters(anolis$dat)
</code></pre>

<hr>
<h2 id='detectCharacterType'>Function to detect whether a character is continuous or discrete</h2><span id='topic+detectCharacterType'></span>

<h3>Description</h3>

<p>This function detects whether a given vector is a continuous
(e.g., with values 2.45, 9.35, and so on) or a discrete
(e.g., with values blue, red, yellow) character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectCharacterType(dat, cutoff = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectCharacterType_+3A_dat">dat</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="detectCharacterType_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff value for deciding if numeric data might actually be
discrete: if nlev is the number of levels and n the length of dat, then
nlev / n should exceed cutoff, or the data will be classified as discrete</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either &quot;discrete&quot; or &quot;continuous&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
detectCharacterType(anolis$dat[, 1])
</code></pre>

<hr>
<h2 id='droptreedata.table'>Function dropping taxa from an object of class <code>treedata.table</code></h2><span id='topic+droptreedata.table'></span>

<h3>Description</h3>

<p>This function can be used to remove species from an object of class
<code>treedata.table</code>. The resulting <code>treedata.table</code> will include fully matching
<code style="white-space: pre;">&#8288;$dat&#8288;</code> and <code style="white-space: pre;">&#8288;$phy&#8288;</code> elements. The user should confirm the changes before they
are processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>droptreedata.table(tdObject, taxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="droptreedata.table_+3A_tdobject">tdObject</code></td>
<td>
<p>An object of class <code>treedata.table</code></p>
</td></tr>
<tr><td><code id="droptreedata.table_+3A_taxa">taxa</code></td>
<td>
<p>A vector class <code>character</code> containing all taxa that needs to be
dropped from the original <code>treedata.table</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>treedata.table</code> with matching <code style="white-space: pre;">&#8288;$dat&#8288;</code> and <code style="white-space: pre;">&#8288;$phy&#8288;</code>
elements based on whether <code>taxa</code> were dropped or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
# With a multiphylo object in the treedata.table object
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
droptreedata.table(
  tdObject = td, taxa =
    c("chamaeleonides", "eugenegrahami")
)

# With a multiphylo object in the treedata.table object
treesFM &lt;- list(anolis$phy, anolis$phy)
class(treesFM) &lt;- "multiPhylo"
td &lt;- as.treedata.table(treesFM, anolis$dat)
droptreedata.table(
  tdObject = td, taxa =
    c("chamaeleonides", "eugenegrahami")
)
</code></pre>

<hr>
<h2 id='extractVector'>Returning a named vector from a treedata.table object</h2><span id='topic+extractVector'></span>

<h3>Description</h3>

<p>Returning a named vector from a treedata.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractVector(tdObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractVector_+3A_tdobject">tdObject</code></td>
<td>
<p>A treedata.table object</p>
</td></tr>
<tr><td><code id="extractVector_+3A_...">...</code></td>
<td>
<p>The name of the column or columns to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector or a list of named vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anolis)
td &lt;- as.treedata.table(tree = anolis$phy, data = anolis$dat)
# extracts the named vector for SVL from the td object
extractVector(td, "SVL")
# extracts the named vector for SVL and ecomorph from the td object
extractVector(td, "SVL", "ecomorph")
</code></pre>

<hr>
<h2 id='filterMatrix'>Filter a character matrix, returning either all continuous or all discrete characters</h2><span id='topic+filterMatrix'></span>

<h3>Description</h3>

<p>This function filters a character matrix based on continuous
(e.g., with values 2.45, 9.35, and so on) or discrete characters
(e.g., with values blue, red, yellow).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterMatrix(mat, returnType = "discrete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterMatrix_+3A_mat">mat</code></td>
<td>
<p>A character matrix of class data.frame</p>
</td></tr>
<tr><td><code id="filterMatrix_+3A_returntype">returnType</code></td>
<td>
<p>Either discrete or continuous</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with only discrete (default) or continuous characters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
filterMatrix(anolis$dat, "discrete")
</code></pre>

<hr>
<h2 id='forceNames'>Force names for rows, columns, or both</h2><span id='topic+forceNames'></span>

<h3>Description</h3>

<p>This function creates column names (<code>colnames</code>), row.names (<code>row.names</code>),
or both in an unnamed <code>data.frame</code> or <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forceNames(dat, nameType = "row")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forceNames_+3A_dat">dat</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="forceNames_+3A_nametype">nameType</code></td>
<td>
<p>either:
</p>

<dl>
<dt>&quot;row&quot;</dt><dd><p>Rows (default)</p>
</dd>
<dt>&quot;col&quot;</dt><dd><p>Columns</p>
</dd>
<dt>&quot;rowcol&quot;</dt><dd><p>Both rows and columns</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type 'data.frame with labeled columns, rows, or both.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
forceNames(anolis$dat, "row")
</code></pre>

<hr>
<h2 id='hasNames'>Row and column name check</h2><span id='topic+hasNames'></span>

<h3>Description</h3>

<p>This function checks whether a given <code>data.frame</code> or <code>matrix</code> has
column names (<code>colnames</code>), row.names (<code>row.names</code>), or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasNames(dat, nameType = "row")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNames_+3A_dat">dat</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="hasNames_+3A_nametype">nameType</code></td>
<td>
<p>either:
</p>

<dl>
<dt>&quot;row&quot;</dt><dd><p>Rows (default)</p>
</dd>
<dt>&quot;col&quot;</dt><dd><p>Columns</p>
</dd>
<dt>&quot;rowcol&quot;</dt><dd><p>Both rows and columns</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> indicating if the object has names (<code>columns</code>,
<code>rows</code>, or
<code>both</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
hasNames(anolis$dat, "row")
</code></pre>

<hr>
<h2 id='head.treedata.table'>Return the first part of an treedata.table object</h2><span id='topic+head.treedata.table'></span>

<h3>Description</h3>

<p>Return the first part of an treedata.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
head(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.treedata.table_+3A_x">x</code></td>
<td>
<p>a treedata.table object</p>
</td></tr>
<tr><td><code id="head.treedata.table_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to head.data.table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
head(td)
</code></pre>

<hr>
<h2 id='print.treedata.table'>Print method treedata.table objects</h2><span id='topic+print.treedata.table'></span>

<h3>Description</h3>

<p>Print method treedata.table objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.treedata.table_+3A_x">x</code></td>
<td>
<p>an object of class &quot;treedata.table&quot;</p>
</td></tr>
<tr><td><code id="print.treedata.table_+3A_...">...</code></td>
<td>
<p>additional arguments passed to &quot;head.treedata.table&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function uses prints the tree and the first lines of the
data.table object.
</p>

<hr>
<h2 id='pulltreedata.table'>Returns the character matrix or phylogeny from a treedata.table object</h2><span id='topic+pulltreedata.table'></span>

<h3>Description</h3>

<p>Returns the character matrix or phylogeny from a treedata.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulltreedata.table(tdObject, type = c("dat", "phy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pulltreedata.table_+3A_tdobject">tdObject</code></td>
<td>
<p>A treedata.table object</p>
</td></tr>
<tr><td><code id="pulltreedata.table_+3A_type">type</code></td>
<td>
<p>Whether the output of the function is a tree ('type=&quot;phylo&quot;')
or a data.table ('type=&quot;dat&quot;')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>phylo</code> object from the original <code>treedata.table</code>
object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
pulltreedata.table(td, type = "phy")
pulltreedata.table(td, type = "dat")
</code></pre>

<hr>
<h2 id='summary.treedata.table'>Summarizing treedata.table objects</h2><span id='topic+summary.treedata.table'></span>

<h3>Description</h3>

<p>Summarizing treedata.table objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.treedata.table_+3A_object">object</code></td>
<td>
<p>an object of class &quot;treedata.table&quot;</p>
</td></tr>
<tr><td><code id="summary.treedata.table_+3A_...">...</code></td>
<td>
<p>additional arguments passed to &quot;head.treedata.table&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function tries to be smart about summarizing the data
and detecting continuous vs. discrete data, as well as whether
any data have missing data. Also returns the taxa that are
dropped from either the original tree or the original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
summary(td)
</code></pre>

<hr>
<h2 id='tail.treedata.table'>Return the last part of an treedata.table object</h2><span id='topic+tail.treedata.table'></span>

<h3>Description</h3>

<p>Return the last part of an treedata.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedata.table'
tail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tail.treedata.table_+3A_x">x</code></td>
<td>
<p>a treedata.table object</p>
</td></tr>
<tr><td><code id="tail.treedata.table_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to head.data.table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
tail(td)
</code></pre>

<hr>
<h2 id='tdt'>Run a function on a <code>treedata.table</code> object</h2><span id='topic+tdt'></span>

<h3>Description</h3>

<p>Run a function on a <code>treedata.table</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdt(tdObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdt_+3A_tdobject">tdObject</code></td>
<td>
<p>A treedata.table object</p>
</td></tr>
<tr><td><code id="tdt_+3A_...">...</code></td>
<td>
<p>A function call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows R functions that use trees and data to be run
on<code>treedata.table</code> objects.
</p>


<h3>Value</h3>

<p>Function output for a single tree (phylo) or a list of function
outputs (one per each tree in the MultiPhylo object)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anolis)


# A treedata.table object with a phylo $phy
td &lt;- as.treedata.table(anolis$phy, anolis$dat)
tdt(td, geiger::fitContinuous(phy, extractVector(td, "SVL"),
  model = "BM", ncores = 1
))


# A treedata.table object with a multiPhylo $phy
treesFM &lt;- list(anolis$phy, anolis$phy)
class(treesFM) &lt;- "multiPhylo"
td &lt;- as.treedata.table(treesFM, anolis$dat)
tdt(td, geiger::fitContinuous(phy, extractVector(td, "SVL"),
  model = "BM",
  ncores = 1
))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
