<!DOCTYPE html><html><head><title>Help for package od</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {od}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coords_to_od'><p>Convert coordinates into a data frame of origins and destinations</p></a></li>
<li><a href='#od_aggregate'><p>Aggregate od pairs based on aggregating zones</p></a></li>
<li><a href='#od_coordinates'><p>Create matrices representing origin-destination coordinates</p></a></li>
<li><a href='#od_coordinates_ids'><p>Interleave origin and destination coordinates</p></a></li>
<li><a href='#od_data_buildings'><p>Simple buildings dataset</p></a></li>
<li><a href='#od_data_centroids'><p>Datasets reporesenting zone centroids</p></a></li>
<li><a href='#od_data_centroids2'><p>Output area centroids</p></a></li>
<li><a href='#od_data_destinations'><p>Workplace zone (destination) centroids</p></a></li>
<li><a href='#od_data_df'><p>Origin-destination datasets</p></a></li>
<li><a href='#od_data_df2'><p>Origin-destination data with destinations in a different layer than origins</p></a></li>
<li><a href='#od_data_network'><p>Route network data for Leeds</p></a></li>
<li><a href='#od_data_zones'><p>Example OD data</p></a></li>
<li><a href='#od_data_zones_small'><p>Small zones dataset</p></a></li>
<li><a href='#od_disaggregate'><p>Split-up each OD pair into multiple OD pairs based on subpoints/subzones</p></a></li>
<li><a href='#od_filter'><p>Filter OD datasets</p></a></li>
<li><a href='#od_id'><p>Combine two ID values to create a single ID number</p></a></li>
<li><a href='#od_id_order'><p>Generate ordered ids of OD pairs so lowest is always first</p>
This function is slow on large datasets, see szudzik_pairing for faster alternative</a></li>
<li><a href='#od_interzone'><p>Return only interzonal (io intrazonal) OD pairs</p></a></li>
<li><a href='#od_jitter'><p>Move desire line end points within zone to avoid all trips going to a single centroid</p></a></li>
<li><a href='#od_oneway'><p>Aggregate OD pairs they become non-directional</p></a></li>
<li><a href='#od_road_network'><p>Simple road network dataset</p></a></li>
<li><a href='#od_sample_vertices'><p>Create a subsample of points from a route network for jittering</p></a></li>
<li><a href='#od_to_network'><p>Convert OD data into lines with start and end points sampled on a network</p></a></li>
<li><a href='#od_to_odmatrix'><p>Convert origin-destination data from long to wide format</p></a></li>
<li><a href='#od_to_sf'><p>Convert OD data into geographic 'desire line' objects</p></a></li>
<li><a href='#odc_to_sf'><p>Convert origin-destination coordinates into geographic desire lines</p></a></li>
<li><a href='#odc_to_sfc'><p>Convert origin-destination coordinates into geographic desire lines</p></a></li>
<li><a href='#odmatrix_to_od'><p>Convert origin-destination data from wide to long format</p></a></li>
<li><a href='#points_to_od'><p>Convert a series of points into a dataframe of origins and destinations</p></a></li>
<li><a href='#sfc_point_to_matrix'><p>Extract coordinates from sfc objects with point geometry</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Manipulate and Map Origin-Destination Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Description:</td>
<td>The aim of 'od' is to provide tools and example datasets for working with
  origin-destination ('OD') datasets of the type used to describe aggregate
  urban mobility patterns (Carey et al. 1981) &lt;<a href="https://doi.org/10.1287%2Ftrsc.15.1.32">doi:10.1287/trsc.15.1.32</a>&gt;.
  The package builds on functions for working with 'OD' data in the package 'stplanr',
  (Lovelace and Ellison 2018) &lt;<a href="https://doi.org/10.32614%2FRJ-2018-053">doi:10.32614/RJ-2018-053</a>&gt; with a focus on computational
  efficiency and support for  the 'sf' class system (Pebesma 2018) &lt;<a href="https://doi.org/10.32614%2FRJ-2018-009">doi:10.32614/RJ-2018-009</a>&gt;.
  With few dependencies and a simple class system based on data frames,
  the package is intended to facilitate efficient analysis of 'OD' datasets
  and to provide a place for developing new functions.
  The package enables the creation and analysis of geographic entities
  representing large scale mobility patterns,
  from daily travel between zones in cities to migration between countries.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/itsleeds/od">https://github.com/itsleeds/od</a>, <a href="https://itsleeds.github.io/od/">https://itsleeds.github.io/od/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/itsleeds/od/issues">https://github.com/itsleeds/od/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sfheaders, methods, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf, knitr, rmarkdown, tinytest, covr, lwgeom</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-10 14:51:04 UTC; robin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Cooley [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Lovelace &lt;rob00x@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-10 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coords_to_od'>Convert coordinates into a data frame of origins and destinations</h2><span id='topic+coords_to_od'></span>

<h3>Description</h3>

<p>Takes geographic coordinates and converts them into a data frame
representing the potential flows, or 'spatial interaction', between every combination
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords_to_od(p, interzone_only = FALSE, ids_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_to_od_+3A_p">p</code></td>
<td>
<p>A spatial points object or a matrix of coordinates representing points</p>
</td></tr>
<tr><td><code id="coords_to_od_+3A_interzone_only">interzone_only</code></td>
<td>
<p>Should the result only include interzonal OD pairs, in which
the ID of the origin is different from the ID of the destination zone?
<code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="coords_to_od_+3A_ids_only">ids_only</code></td>
<td>
<p>Should a data frame with only 2 columns (origin and destination IDs)
be returned? The default is <code>FALSE</code>, meaning the result should also contain the
coordinates of the start and end points of each OD pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame object with O and D codes and origin and destination coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sf::st_coordinates(od_data_centroids[1:3, ])
od = points_to_od(p)
(od = coords_to_od(p, interzone_only = TRUE))
l = odc_to_sf(od[3:6], d = od[1:2])
l$v = 1
(l_oneway = od_oneway(l))
plot(l_oneway)
</code></pre>

<hr>
<h2 id='od_aggregate'>Aggregate od pairs based on aggregating zones</h2><span id='topic+od_aggregate'></span><span id='topic+od_group'></span>

<h3>Description</h3>

<p>This function is for aggregating OD pairs.
It generally decreases the number of rows in an OD dataset, while aiming
to keep the amount of travel represented in the data the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_aggregate(od, aggzones = NULL, FUN = sum)

od_group(od, aggzones = NULL, FUN = sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_aggregate_+3A_od">od</code></td>
<td>
<p>An origin-destination data frame</p>
</td></tr>
<tr><td><code id="od_aggregate_+3A_aggzones">aggzones</code></td>
<td>
<p>Points within the zones defining the OD data</p>
</td></tr>
<tr><td><code id="od_aggregate_+3A_fun">FUN</code></td>
<td>
<p>The aggregating function to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alias for the function is <code>od_group()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_aggregated = od_data_df[1:2, c(1, 2, 9)]
aggzones = od::od_data_zones_min
subzones = od_data_zones_small
plot(aggzones$geometry)
plot(subzones$geometry, add = TRUE)
od = od_disaggregate(od_aggregated, aggzones, subzones)
od_agg = od_aggregate(od, aggzones)
names(od_agg)[1:(ncol(od_agg) - 1)] = names(od_aggregated)
attr(od_aggregated, "spec") = NULL
identical(sf::st_drop_geometry(od_agg), od_aggregated)
</code></pre>

<hr>
<h2 id='od_coordinates'>Create matrices representing origin-destination coordinates</h2><span id='topic+od_coordinates'></span>

<h3>Description</h3>

<p>This function takes a wide range of input data types (spatial lines, points or text strings)
and returns a data frame of coordinates representing origin (ox, oy) and destination (dx, dy) points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_coordinates(x, p = NULL, pd = NULL, silent = TRUE, sfnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_coordinates_+3A_x">x</code></td>
<td>
<p>A data frame in which the first two columns are codes
representing points/zones of origin and destination</p>
</td></tr>
<tr><td><code id="od_coordinates_+3A_p">p</code></td>
<td>
<p>Points representing origins and destinations</p>
</td></tr>
<tr><td><code id="od_coordinates_+3A_pd">pd</code></td>
<td>
<p>Points representing destinations, if different from origin points</p>
</td></tr>
<tr><td><code id="od_coordinates_+3A_silent">silent</code></td>
<td>
<p>Hide messages? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="od_coordinates_+3A_sfnames">sfnames</code></td>
<td>
<p>Should output column names be compatible with the sf package?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with origin and destination coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df
p = od_data_centroids
res = od_coordinates(x, p)[1:2, ]
class(res)
res
od_coordinates(x, p, sfnames = TRUE)[1:2, ]
od_coordinates(x, p, silent = FALSE)[1:2, ]
od_coordinates(x, p)
x = od_data_df2[1:3, ]
p = od_data_centroids2
pd = od_data_destinations
od_coordinates(x, p, pd)
</code></pre>

<hr>
<h2 id='od_coordinates_ids'>Interleave origin and destination coordinates</h2><span id='topic+od_coordinates_ids'></span>

<h3>Description</h3>

<p>This function takes a matrix with 4 columns representing origin and destination coordinates
and returns a data frame with 3 columns with the ID of each linestring, plus
the coordinates representing origin and destination coordinates.
Essentially the function is a pivot, converting from wide to long format, to feed
into other functions for creating geographic desire lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_coordinates_ids(odc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_coordinates_ids_+3A_odc">odc</code></td>
<td>
<p>A matrix containing coordinates representing line start and end points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>od_coordinates_ids(od_coordinates(od_data_df, p = od_data_zones, sfnames = TRUE))
</code></pre>

<hr>
<h2 id='od_data_buildings'>Simple buildings dataset</h2><span id='topic+od_data_buildings'></span>

<h3>Description</h3>

<p>Building data from OSM for testing od_disaggregate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrow(od_data_buildings)
head(od_data_buildings)
plot(od_data_buildings$geometry)
plot(od_data_zones_min$geometry, lwd = 3, col = NULL, add = TRUE)
</code></pre>

<hr>
<h2 id='od_data_centroids'>Datasets reporesenting zone centroids</h2><span id='topic+od_data_centroids'></span><span id='topic+od_data_coordinates'></span>

<h3>Description</h3>

<p>These are provided as a geographic (sf) object and a simple
data frame with longitude (<code>X</code>) and latitude (<code>Y</code>) columns.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(od_data_coordinates)
</code></pre>

<hr>
<h2 id='od_data_centroids2'>Output area centroids</h2><span id='topic+od_data_centroids2'></span>

<h3>Description</h3>

<p>This dataset represents geographic centroids of Output Areas in Leeds, UK.
</p>
<p>This dataset represents geographic centroids of Output Areas in Leeds, UK.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>
<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(od_data_centroids2)
head(od_data_centroids2)
</code></pre>

<hr>
<h2 id='od_data_destinations'>Workplace zone (destination) centroids</h2><span id='topic+od_data_destinations'></span>

<h3>Description</h3>

<p>This dataset represents geographic centroids of Output Areas in Leeds, UK.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrow(od_data_destinations)
head(od_data_destinations)
</code></pre>

<hr>
<h2 id='od_data_df'>Origin-destination datasets</h2><span id='topic+od_data_df'></span><span id='topic+od_data_df_medium'></span>

<h3>Description</h3>

<p>Datasets representing top commuter desire lines
in Leeds based on the 2011 Census.
The first two variables of the data frame are the zone code of origin and destination, respectively.
The other columns record the number of people who travel by different modes, including
<code>all</code>, <code>train</code>, <code>bus</code>, <code>bicycle</code> and by <code>foot</code>.
</p>


<h3>Details</h3>

<p><code>od_data_df_medium</code> is a larger dataset with the same variables, with around 10k rows.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_data_df
</code></pre>

<hr>
<h2 id='od_data_df2'>Origin-destination data with destinations in a different layer than origins</h2><span id='topic+od_data_df2'></span>

<h3>Description</h3>

<p>This dataset represents commuter flows between Output Areas
and Workplace Zones, the most detailed open OD data in the UK.
See https://wicid.ukdataservice.ac.uk/ and the script
<code>data-raw/od_wpz.R</code> in the <code>od</code> package's GitHub repo.
</p>


<h3>Details</h3>

<p>The dataset reports (in the 3rd column) the number of people travelling
between origins and destinations.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(od_data_df2)
</code></pre>

<hr>
<h2 id='od_data_network'>Route network data for Leeds</h2><span id='topic+od_data_network'></span>

<h3>Description</h3>

<p>Route network data for Leeds
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(od_data_network)
</code></pre>

<hr>
<h2 id='od_data_zones'>Example OD data</h2><span id='topic+od_data_zones'></span><span id='topic+od_data_csa_zones'></span><span id='topic+od_data_zones_min'></span>

<h3>Description</h3>

<p>Zone datasets for packages examples
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>

<hr>
<h2 id='od_data_zones_small'>Small zones dataset</h2><span id='topic+od_data_zones_small'></span>

<h3>Description</h3>

<p>This dataset represents geographic zones of Lower Super Output Areas in Leeds, UK.
They fit completely within the <code>od_data_zones_min</code> dataset.
</p>


<h3>Note</h3>

<p>The schema data can be (re-)generated using code in the
<code>data-raw</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrow(od_data_zones_small)
head(od_data_zones_small)
plot(od_data_zones_small$geometry)
plot(od_data_zones_min$geometry, lwd = 3, col = NULL, add = TRUE)
</code></pre>

<hr>
<h2 id='od_disaggregate'>Split-up each OD pair into multiple OD pairs based on subpoints/subzones</h2><span id='topic+od_disaggregate'></span><span id='topic+od_split'></span>

<h3>Description</h3>

<p>This function is for splitting-up OD pairs.
It increases the number of rows in an OD dataset, while aiming
to keep the amount of travel represented in the data the same.
To take an analogy from another package, it's roughly equivalent
to <a href="https://tidyr.tidyverse.org/reference/pivot_longer.html"><code>tidyr::pivot_longer()</code></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_disaggregate(
  od,
  z,
  subpoints = NULL,
  code_append = "_ag",
  population_column = 3,
  max_per_od = 5,
  keep_ids = TRUE,
  integer_outputs = FALSE
)

od_split(
  od,
  z,
  subpoints = NULL,
  code_append = "_ag",
  population_column = 3,
  max_per_od = 5,
  keep_ids = TRUE,
  integer_outputs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_disaggregate_+3A_od">od</code></td>
<td>
<p>An origin-destination data frame</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_z">z</code></td>
<td>
<p>Zones representing origins and destinations</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_subpoints">subpoints</code></td>
<td>
<p>Points, lines or polygons within the zones.
These define the OD data start/end points.</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_code_append">code_append</code></td>
<td>
<p>The name of the column containing aggregate zone names</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_population_column">population_column</code></td>
<td>
<p>The column containing the total population (if it exists)</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_max_per_od">max_per_od</code></td>
<td>
<p>Maximum flow in the population_column to assign per OD pair.
This only comes into effect if there are enough subpoints to choose from.</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_keep_ids">keep_ids</code></td>
<td>
<p>Should the origin and destination ids be kept?
<code>TRUE</code> by default, meaning 2 extra columns are appended, with the
names <code>o_agg</code> and <code>d_agg</code> containing IDs from the original OD data.</p>
</td></tr>
<tr><td><code id="od_disaggregate_+3A_integer_outputs">integer_outputs</code></td>
<td>
<p>Should integer outputs be returned? <code>FALSE</code> by default.
Note: there is a known issue when integer results are generated. See
https://github.com/ITSLeeds/od/issues/31 for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alias for the function is <code>od_split()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od = od_data_df[1:2, c(1, 2, 9)]
od
zones = od::od_data_zones_min
od_sf = od_to_sf(od, zones)
set.seed(2021) # for reproducibility
od_disag = od_disaggregate(od, zones)
od_disag2 = od_disaggregate(od, zones, max_per_od = 11)
plot(zones$geometry)
plot(od_sf$geometry, lwd = 9, add = TRUE)
plot(od_disag$geometry, col = "grey", lwd = 1, add = TRUE)
plot(od_disag2$geometry, col = "green", lwd = 1, add = TRUE)
table(od_disag$o_agg, od_disag$d_agg)
# integer results
od_disaggregate(od, zones, integer_outputs = TRUE)

# with more trips per disaggregated OD pair:
disag = od_disaggregate(od_data_df[1:2, ], z = zones, max_per_od = 50)
plot(disag[0])

# with subpoints
subpoints = sf::st_sample(zones, 100)
od_disag_subpoints = od_disaggregate(od, zones, subpoints = subpoints)
plot(subpoints)
plot(od_disag_subpoints$geometry, add = TRUE)

# with buildings data
od_disag_buildings = od_disaggregate(od, zones, od_data_buildings)
summary(od_disag_buildings)
plot(od_data_buildings$geometry)
plot(od_disag_buildings[3], add = TRUE)
# mapview::mapview(od_disag_buildings)

od = od_data_df[1:2, 1:4]
subzones = od_data_zones_small
try(od_disaggregate(od, zones, subzones))
od_disag = od_disaggregate(od, zones, subzones, max_per_od = 500)
ncol(od_disag) -3 == ncol(od) # same number of columns, the same...
# Except disag data gained geometry and new agg ids:
sum(od_disag[[3]]) == sum(od[[3]])
sum(od_disag[[4]]) == sum(od[[4]])
plot(od_disag)
# test with road network dataset (don't run as time consuming):
## Not run: 
od_disag_net = od_disaggregate(od, zones, od_road_network, max_per_od = 500)
plot(zones$geometry)
plot(od_road_network$geometry, add = TRUE, col = "green")
plot(od_disag_net$geometry, add = TRUE)
mapview::mapview(zones) + od_disag_net + od_road_network

## End(Not run)
</code></pre>

<hr>
<h2 id='od_filter'>Filter OD datasets</h2><span id='topic+od_filter'></span>

<h3>Description</h3>

<p>This function takes and OD dataset and a character vector of codes
and returns an OD dataset with rows matching origin and destinations
zones present in the codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_filter(x, codes, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_filter_+3A_x">x</code></td>
<td>
<p>A data frame in which the first two columns are codes
representing points/zones of origin and destination</p>
</td></tr>
<tr><td><code id="od_filter_+3A_codes">codes</code></td>
<td>
<p>The zone codes that must be in origins and destination</p>
</td></tr>
<tr><td><code id="od_filter_+3A_silent">silent</code></td>
<td>
<p>Hide messages? <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df
z = od_data_zones
codes = z[[1]]
z_in_x_o = codes %in% x[[1]]
z_in_x_d = codes %in% x[[2]]
sum(z_in_x_d)
sum(z_in_x_o)
z = z[which(z_in_x_o | z_in_x_d)[-1], ]
z[[1]]
unique(c(x[[1]], x[[2]]))
try(od_to_sf(x, z)) # fails
nrow(x)
x = od_filter(x, z[[1]])
nrow(x)
od_to_sf(x, z)
</code></pre>

<hr>
<h2 id='od_id'>Combine two ID values to create a single ID number</h2><span id='topic+od_id'></span><span id='topic+od_id_szudzik'></span><span id='topic+od_id_max_min'></span><span id='topic+od_id_character'></span>

<h3>Description</h3>

<p>Combine two ID values to create a single ID number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_id_szudzik(x, y, ordermatters = FALSE)

od_id_max_min(x, y)

od_id_character(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_id_+3A_x">x</code></td>
<td>
<p>a vector of numeric, character, or factor values</p>
</td></tr>
<tr><td><code id="od_id_+3A_y">y</code></td>
<td>
<p>a vector of numeric, character, or factor values</p>
</td></tr>
<tr><td><code id="od_id_+3A_ordermatters">ordermatters</code></td>
<td>
<p>logical, does the order of values matter to pairing, default = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In OD data it is common to have many 'oneway' flows from &quot;A to B&quot; and &quot;B to A&quot;.
It can be useful to group these an have a single ID that represents pairs of IDs
with or without directionality, so they contain 'twoway' or bi-directional values.
</p>
<p><code style="white-space: pre;">&#8288;od_id*&#8288;</code> functions take two vectors of equal length and return a vector of IDs,
which are unique for each combination but the same for twoway flows.
</p>

<ul>
<li><p> the Szudzik pairing function, on two vectors of equal
length. It returns a vector of ID numbers.
</p>
</li></ul>

<p>This function superseeds od_id_order as it is faster on large datasets
</p>


<h3>See Also</h3>

<p>od_oneway
</p>
<p>Other od: 
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(d = od_data_df[2:9, 1:2])
(id = od_id_character(d[[1]], d[[2]]))
duplicated(id)
od_id_szudzik(d[[1]], d[[2]])
od_id_max_min(d[[1]], d[[2]])
</code></pre>

<hr>
<h2 id='od_id_order'>Generate ordered ids of OD pairs so lowest is always first
This function is slow on large datasets, see szudzik_pairing for faster alternative</h2><span id='topic+od_id_order'></span>

<h3>Description</h3>

<p>Generate ordered ids of OD pairs so lowest is always first
This function is slow on large datasets, see szudzik_pairing for faster alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_id_order(x, id1 = names(x)[1], id2 = names(x)[2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_id_order_+3A_x">x</code></td>
<td>
<p>A data frame representing OD pairs</p>
</td></tr>
<tr><td><code id="od_id_order_+3A_id1">id1</code></td>
<td>
<p>Optional (it is assumed to be the first column)
text string referring to the name of the variable containing
the unique id of the origin</p>
</td></tr>
<tr><td><code id="od_id_order_+3A_id2">id2</code></td>
<td>
<p>Optional (it is assumed to be the second column)
text string referring to the name of the variable containing
the unique id of the destination</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = data.frame(id1 = c(1, 1, 2, 2, 3), id2 = c(1, 2, 3, 1, 4))
od_id_order(x) # 4th line switches id1 and id2 so oneway_key is in order
</code></pre>

<hr>
<h2 id='od_interzone'>Return only interzonal (io intrazonal) OD pairs</h2><span id='topic+od_interzone'></span><span id='topic+od_intrazone'></span>

<h3>Description</h3>

<p>This function takes an OD dataset and returns only the rows
corresponding to movements in which the origin is different than
the destination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_interzone(x)

od_intrazone(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_interzone_+3A_x">x</code></td>
<td>
<p>A data frame in which the first two columns are codes
representing points/zones of origin and destination</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
od_data = points_to_od(od_data_centroids)
nrow(od_data)
nrow(od_interzone(od_data))
nrow(od_intrazone(od_data))
</code></pre>

<hr>
<h2 id='od_jitter'>Move desire line end points within zone to avoid all trips going to a single centroid</h2><span id='topic+od_jitter'></span>

<h3>Description</h3>

<p>These functions tackle the problem associated with OD data representing movement to and from large zones.
Typically the associated desire lines start and end in one point per zone.
This function produces desire lines that can start and end anywhere (or at predefined points) within each zone.
See <a href="https://github.com/ITSLeeds/od/issues/11">issue #11</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_jitter(
  od,
  z,
  subpoints = NULL,
  code_append = "_ag",
  population_column = 3,
  max_per_od = 1e+05,
  keep_ids = TRUE,
  integer_outputs = FALSE,
  zd = NULL,
  subpoints_o = NULL,
  subpoints_d = NULL,
  disag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_jitter_+3A_od">od</code></td>
<td>
<p>An origin-destination data frame</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_z">z</code></td>
<td>
<p>Zones representing origins and destinations</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_subpoints">subpoints</code></td>
<td>
<p>Points, lines or polygons within the zones.
These define the OD data start/end points.</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_code_append">code_append</code></td>
<td>
<p>The name of the column containing aggregate zone names</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_population_column">population_column</code></td>
<td>
<p>The column containing the total population (if it exists)</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_max_per_od">max_per_od</code></td>
<td>
<p>Maximum flow in the population_column to assign per OD pair.
This only comes into effect if there are enough subpoints to choose from.</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_keep_ids">keep_ids</code></td>
<td>
<p>Should the origin and destination ids be kept?
<code>TRUE</code> by default, meaning 2 extra columns are appended, with the
names <code>o_agg</code> and <code>d_agg</code> containing IDs from the original OD data.</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_integer_outputs">integer_outputs</code></td>
<td>
<p>Should integer outputs be returned? <code>FALSE</code> by default.
Note: there is a known issue when integer results are generated. See
https://github.com/ITSLeeds/od/issues/31 for details.</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_zd">zd</code></td>
<td>
<p>Zones with ids matching the destination codes in input OD data</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_subpoints_o">subpoints_o</code></td>
<td>
<p>Points within origin zones representing possible destinations</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_subpoints_d">subpoints_d</code></td>
<td>
<p>Points within destination zones representing possible destinations</p>
</td></tr>
<tr><td><code id="od_jitter_+3A_disag">disag</code></td>
<td>
<p>Should the od_disaggregate function be used as a 'back end' where possible?
FALSE by default. See https://github.com/ITSLeeds/od/issues/39.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic example
od = od_data_df
z = od_data_zones_min
dlr = od_jitter(od, z) # desire_lines_random
desire_lines = od_to_sf(od, z)
plot(z$geometry)
plot(dlr["all"], add = TRUE, lwd = 3)
dlr$all
desire_lines$all
plot(desire_lines["all"], add = TRUE, lwd = 5)

# Example showing use of subpoints
subpoints_o = sf::st_sample(z, 200)
subpoints_d = sf::st_sample(z, 100)
dlr_d = od_jitter(od, z, subpoints_o = subpoints_o, subpoints_d = subpoints_d)
plot(z$geometry)
plot(dlr_d$geometry, add = TRUE)
plot(subpoints_o, add = TRUE)
plot(subpoints_d, col = "red", add = TRUE)
plot(desire_lines, add = TRUE, lwd = 5)
# mapview::mapview(desire_lines) + dlr + z # interactive map
sp = sf::st_sample(z, 100)
dlr2 = od_jitter(desire_lines, z, subpoints_o = sp, subpoints_d = sp)
plot(z$geometry)
plot(sp, add = TRUE)
plot(dlr2, add = TRUE, lwd = 3)
plot(desire_lines, add = TRUE, lwd = 5)

# Example showing jittering with origin and destination zones
od = od_data_df2
z = sf::st_buffer(od_data_centroids2, dist = 1000)
zd = sf::st_buffer(od_data_destinations, dist = 300)
zd = zd[zd[[1]] %in% od[[2]], ]
desire_lines = od_to_sf(od, od_data_centroids2, zd = od_data_destinations)
dlr = od_jitter(od, z, zd = zd)
plot(z$geometry)
plot(od_data_centroids2$geometry, add = TRUE)
plot(od_data_destinations$geometry, add = TRUE)
plot(zd$geometry, add = TRUE)
plot(dlr, add = TRUE, lwd = 3)
plot(desire_lines, add = TRUE, lwd = 5)

# Larger example with only subset of matching zones
# od = od_data_df_medium
# od_sf = od_to_sf(od, od_data_zones)
# dlr3 = od_jitter(od_sf, od_data_zones)
# plot(od_sf[od$all &gt; 200, 1])
# plot(dlr3[od$all &gt; 200, 1])
# mapview::mapview(od_sf$geometry[od$all &gt; 200])
</code></pre>

<hr>
<h2 id='od_oneway'>Aggregate OD pairs they become non-directional</h2><span id='topic+od_oneway'></span>

<h3>Description</h3>

<p>For example, sum total travel in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_oneway(
  x,
  attrib = names(x[-c(1:2)])[vapply(x[-c(1:2)], is.numeric, TRUE)],
  FUN = sum,
  ...,
  id1 = names(x)[1],
  id2 = names(x)[2],
  oneway_key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_oneway_+3A_x">x</code></td>
<td>
<p>A data frame or SpatialLinesDataFrame, representing an OD matrix</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_attrib">attrib</code></td>
<td>
<p>A vector of column numbers or names, representing variables to be aggregated.
By default, all numeric variables are selected.</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_fun">FUN</code></td>
<td>
<p>The aggregating function such as <code>sum</code> (the default) and <code>mean</code></p>
</td></tr>
<tr><td><code id="od_oneway_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_id1">id1</code></td>
<td>
<p>Optional (it is assumed to be the first column)
text string referring to the name of the variable containing
the unique id of the origin</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_id2">id2</code></td>
<td>
<p>Optional (it is assumed to be the second column)
text string referring to the name of the variable containing
the unique id of the destination</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_oneway_key">oneway_key</code></td>
<td>
<p>Optional key of unique OD pairs regardless of the order,
e.g., as generated by <code><a href="#topic+od_id_max_min">od_id_max_min()</a></code> or <code><a href="#topic+od_id_szudzik">od_id_szudzik()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Flow data often contains movement in two directions: from point A to point B
and then from B to A. This can be problematic for transport planning, because
the magnitude of flow along a route can be masked by flows the other direction.
If only the largest flow in either direction is captured in an analysis, for
example, the true extent of travel will by heavily under-estimated for
OD pairs which have similar amounts of travel in both directions.
Flows in both direction are often represented by overlapping lines with
identical geometries which can be confusing
for users and are difficult to plot.
</p>


<h3>Value</h3>

<p><code>oneway</code> outputs a data frame (or <code>sf</code> data frame) with rows containing
results for the user-selected attribute values that have been aggregated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(od_min = od_data_df[c(1, 2, 1), 1:4])
od_min[3, 1:2] = rev(od_min[3, 1:2])
od_min[3, 3:4] = od_min[3, 3:4] - 5
(od_oneway = od_oneway(od_min))
nrow(od_oneway) &lt; nrow(od_min) # result has fewer rows
sum(od_min$all) == sum(od_oneway$all) # but the same total flow
(od_oneway = od_oneway(od_min, FUN = mean))
od_oneway(od_min, attrib = "all")
od_min$all[3] = NA
(od_oneway = od_oneway(od_min, FUN = mean, na.rm = TRUE))
</code></pre>

<hr>
<h2 id='od_road_network'>Simple road network dataset</h2><span id='topic+od_road_network'></span>

<h3>Description</h3>

<p>Road network data from OSM for testing od_disaggregate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nrow(od_road_network)
head(od_road_network)
plot(od_road_network$geometry)
plot(od_data_zones_min$geometry, lwd = 3, col = NULL, add = TRUE)
</code></pre>

<hr>
<h2 id='od_sample_vertices'>Create a subsample of points from a route network for jittering</h2><span id='topic+od_sample_vertices'></span>

<h3>Description</h3>

<p>Todo: export this at some point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_sample_vertices(x, fraction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_sample_vertices_+3A_x">x</code></td>
<td>
<p>An sf object representing a road network</p>
</td></tr>
<tr><td><code id="od_sample_vertices_+3A_fraction">fraction</code></td>
<td>
<p>What percent of the network to sample?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
u = "https://github.com/ITSLeeds/od/releases/download/v0.3.1/road_network_min.Rds"
f = basename(u)
if(!file.exists(f)) download.file(u, f)
road_network_min = readRDS(f)
od_sample_vertices(road_network_min)

## End(Not run)
</code></pre>

<hr>
<h2 id='od_to_network'>Convert OD data into lines with start and end points sampled on a network</h2><span id='topic+od_to_network'></span>

<h3>Description</h3>

<p>Convert OD data into lines with start and end points sampled on a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_to_network(
  x,
  z,
  zd = NULL,
  silent = TRUE,
  package = "sf",
  crs = 4326,
  network = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_to_network_+3A_x">x</code></td>
<td>
<p>A data frame in which the first two columns are codes
representing points/zones of origin and destination</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_z">z</code></td>
<td>
<p>Zones representing origins and destinations</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_zd">zd</code></td>
<td>
<p>Zones representing destinations</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_silent">silent</code></td>
<td>
<p>Hide messages? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_package">package</code></td>
<td>
<p>Which package to use to create the sf object? <code>sfheaders</code> is the default.</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system of the output, if not known in <code>z</code>.
4326 by default.</p>
</td></tr>
<tr><td><code id="od_to_network_+3A_network">network</code></td>
<td>
<p>An sf object representing a transport network</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df
z = od_data_zones_min
network = od_data_network
(lines_to_points_on_network = od_to_network(x, z, network = network))
(lines_to_points = od_to_sf(x, z))
</code></pre>

<hr>
<h2 id='od_to_odmatrix'>Convert origin-destination data from long to wide format</h2><span id='topic+od_to_odmatrix'></span>

<h3>Description</h3>

<p>This function takes a data frame representing travel between origins
(with origin codes in <code>name_orig</code>, typically the 1st column)
and destinations
(with destination codes in <code>name_dest</code>, typically the second column) and returns a matrix
with cell values (from <code>attrib</code>, the third column by default) representing travel between
origins and destinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_to_odmatrix(x, attrib = 3, name_orig = 1, name_dest = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_to_odmatrix_+3A_x">x</code></td>
<td>
<p>A data frame representing flows between origin and destinations</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_attrib">attrib</code></td>
<td>
<p>A number or character string representing the column containing the attribute data
of interest from the <code>flow</code> data frame</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_name_orig">name_orig</code></td>
<td>
<p>A number or character string representing the zone of origin</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_name_dest">name_dest</code></td>
<td>
<p>A number or character string representing the zone of destination</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df[1:4, ]
x_matrix = od_to_odmatrix(x)
class(x_matrix)
od_to_odmatrix(x, attrib = "bicycle")
</code></pre>

<hr>
<h2 id='od_to_sf'>Convert OD data into geographic 'desire line' objects</h2><span id='topic+od_to_sf'></span><span id='topic+od_to_sfc'></span>

<h3>Description</h3>

<p>Convert OD data into geographic 'desire line' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_to_sf(
  x,
  z,
  zd = NULL,
  odc = NULL,
  silent = FALSE,
  filter = TRUE,
  package = "sfheaders",
  crs = 4326
)

od_to_sfc(
  x,
  z,
  zd = NULL,
  silent = TRUE,
  package = "sfheaders",
  crs = 4326,
  filter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_to_sf_+3A_x">x</code></td>
<td>
<p>A data frame in which the first two columns are codes
representing points/zones of origin and destination</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_z">z</code></td>
<td>
<p>Zones representing origins and destinations</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_zd">zd</code></td>
<td>
<p>Zones representing destinations</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_odc">odc</code></td>
<td>
<p>A matrix containing coordinates representing line start and end points</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_silent">silent</code></td>
<td>
<p>Hide messages? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_filter">filter</code></td>
<td>
<p>Remove rows with no matches in <code>z</code>? <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_package">package</code></td>
<td>
<p>Which package to use to create the sf object? <code>sfheaders</code> is the default.</p>
</td></tr>
<tr><td><code id="od_to_sf_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system of the output, if not known in <code>z</code>.
4326 by default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df
z = od_data_zones
desire_lines = od_to_sf(x, z)
desire_lines[1:3]
plot(desire_lines)
desire_lines_d = od_to_sf(od_data_df2, od_data_centroids2, od_data_destinations)
o1 = od_data_centroids2[od_data_centroids2[[1]] == od_data_df2[[1]][1], ]
d1 = od_data_destinations[od_data_destinations[[1]] == od_data_df2[[2]][1], ]
plot(desire_lines_d$geometry)
plot(od_data_centroids2$geometry, add = TRUE, col = "green")
plot(od_data_destinations$geometry, add = TRUE)
plot(o1, add = TRUE)
plot(d1, add = TRUE)
plot(desire_lines_d$geometry[1], lwd = 3, add = TRUE)
n = 7
on = od_data_centroids2[od_data_centroids2[[1]] == od_data_df2[[1]][n], ]
dn = od_data_destinations[od_data_destinations[[1]] == od_data_df2[[2]][n], ]
plot(desire_lines_d$geometry)
plot(on, add = TRUE)
plot(dn, add = TRUE)
plot(desire_lines_d$geometry[n], lwd = 3, add = TRUE)
</code></pre>

<hr>
<h2 id='odc_to_sf'>Convert origin-destination coordinates into geographic desire lines</h2><span id='topic+odc_to_sf'></span>

<h3>Description</h3>

<p>Convert origin-destination coordinates into geographic desire lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odc_to_sf(odc, d = NULL, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odc_to_sf_+3A_odc">odc</code></td>
<td>
<p>A matrix containing coordinates representing line start and end points</p>
</td></tr>
<tr><td><code id="odc_to_sf_+3A_d">d</code></td>
<td>
<p>An optional data frame to add to the geometry column</p>
</td></tr>
<tr><td><code id="odc_to_sf_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system of the output, if not known in <code>z</code>.
4326 by default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>(odc = od_coordinates(od_data_df, p = od_data_zones, sfnames = TRUE))
(l = odc_to_sf(odc))
plot(l)
lsfc = odc_to_sfc(odc)
</code></pre>

<hr>
<h2 id='odc_to_sfc'>Convert origin-destination coordinates into geographic desire lines</h2><span id='topic+odc_to_sfc'></span>

<h3>Description</h3>

<p>Convert origin-destination coordinates into geographic desire lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odc_to_sfc(odc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odc_to_sfc_+3A_odc">odc</code></td>
<td>
<p>A matrix containing coordinates representing line start and end points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>(odc = od_coordinates(od_data_df, p = od::od_data_zones, sfnames = TRUE))
(l = odc_to_sfc(odc))
plot(l)
</code></pre>

<hr>
<h2 id='odmatrix_to_od'>Convert origin-destination data from wide to long format</h2><span id='topic+odmatrix_to_od'></span>

<h3>Description</h3>

<p>This function takes a matrix representing travel between origins
(with origin codes in the <code>rownames</code> of the matrix)
and destinations
(with destination codes in the <code>colnames</code> of the matrix)
and returns a data frame representing origin-destination pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odmatrix_to_od(odmatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odmatrix_to_od_+3A_odmatrix">odmatrix</code></td>
<td>
<p>A matrix with row and columns representing origin and destination zone codes
and cells representing the flow between these zones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a data frame with rows ordered by origin and then destination
zone code values and with names <code>orig</code>, <code>dest</code> and <code>flow</code>.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = od_data_df
x[1:3]
odmatrix = od_to_odmatrix(od_data_df)
odmatrix
odmatrix_to_od(odmatrix)
</code></pre>

<hr>
<h2 id='points_to_od'>Convert a series of points into a dataframe of origins and destinations</h2><span id='topic+points_to_od'></span><span id='topic+points_to_odl'></span>

<h3>Description</h3>

<p>Takes a series of geographical points and converts them into a data.frame
representing the potential flows, or 'spatial interaction', between every combination
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_to_od(p, pd = NULL, interzone_only = FALSE, ids_only = FALSE)

points_to_odl(
  p,
  pd = NULL,
  interzone_only = FALSE,
  ids_only = FALSE,
  crs = 4326
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_to_od_+3A_p">p</code></td>
<td>
<p>A spatial points object or a matrix of coordinates representing points</p>
</td></tr>
<tr><td><code id="points_to_od_+3A_pd">pd</code></td>
<td>
<p>Optional spatial points object or matrix objects representing destinations</p>
</td></tr>
<tr><td><code id="points_to_od_+3A_interzone_only">interzone_only</code></td>
<td>
<p>Should the result only include interzonal OD pairs, in which
the ID of the origin is different from the ID of the destination zone?
<code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="points_to_od_+3A_ids_only">ids_only</code></td>
<td>
<p>Should a data frame with only 2 columns (origin and destination IDs)
be returned? The default is <code>FALSE</code>, meaning the result should also contain the
coordinates of the start and end points of each OD pair.</p>
</td></tr>
<tr><td><code id="points_to_od_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system of the output, if not known in <code>z</code>.
4326 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>points_to_odl()</code> generates the same output but returns
a geographic object representing desire lines in the class <code>sf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
p = od_data_centroids[1:3, ]
points_to_od(p)
points_to_od(p, ids_only = TRUE)
(l = points_to_odl(p, interzone_only = TRUE))
plot(l)
library(sf) # for subsetting sf objects:
points_to_od(od_data_centroids[1:2, ], od_data_centroids[3, ])
l = points_to_odl(od_data_centroids[1:2, ], od_data_centroids[3, ])
plot(l)
(od = points_to_od(p, interzone_only = TRUE))
l2 = od_to_sf(od, od_data_centroids)
l2$v = 1
(l2_oneway = od_oneway(l2))
plot(l2)
</code></pre>

<hr>
<h2 id='sfc_point_to_matrix'>Extract coordinates from sfc objects with point geometry</h2><span id='topic+sfc_point_to_matrix'></span>

<h3>Description</h3>

<p>This functions takes point geometries with class <code>sfc</code> from the <code>sf</code> package
and returns a matrix representing x and y (typically lon/lat) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_point_to_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_point_to_matrix_+3A_x">x</code></td>
<td>
<p>An <code>sfc</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://github.com/dcooley/sfheaders/issues/52 for details
</p>


<h3>Author(s)</h3>

<p>Dave Cooley
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_point_to_matrix(od_data_centroids$geometry[1:6])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
