<!DOCTYPE html><html lang="en"><head><title>Help for package bridgesampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bridgesampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bf'><p>Bayes Factor(s) from Marginal Likelihoods</p></a></li>
<li><a href='#bridge_sampler'><p>Log Marginal Likelihood via Bridge Sampling</p></a></li>
<li><a href='#bridge-methods'><p>Methods for bridge and bridge_list objects</p></a></li>
<li><a href='#error_measures'><p>Error Measures for Estimated Marginal Likelihood</p></a></li>
<li><a href='#ier'><p>Standardized International Exchange Rate Changes from 1975 to 1986</p></a></li>
<li><a href='#logml'><p>Log Marginal Likelihoods from Bridge Objects</p></a></li>
<li><a href='#post_prob'><p>Posterior Model Probabilities from Marginal Likelihoods</p></a></li>
<li><a href='#turtles'><p>Turtles Data from Janzen, Tucker, and Paukstis (2000)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bridge Sampling for Marginal Likelihoods and Bayes Factors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, Matrix, Brobdingnag, stringr, coda, parallel, scales,
utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, Rcpp, RcppEigen, R2jags, rjags, runjags, knitr,
rmarkdown, R.rsp, BayesFactor, rstan, rstanarm, nimble,
MCMCpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for estimating marginal likelihoods, Bayes
    factors, posterior model probabilities, and normalizing constants in general,
    via different versions of bridge sampling (Meng &amp; Wong, 1996, 
    <a href="http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm">http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm</a>).
    Gronau, Singmann, &amp; Wagenmakers (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v092.i10">doi:10.18637/jss.v092.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/quentingronau/bridgesampling">https://github.com/quentingronau/bridgesampling</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-15 18:55:13 UTC; singm</td>
</tr>
<tr>
<td>Author:</td>
<td>Quentin F. Gronau <a href="https://orcid.org/0000-0001-5510-6943"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jonathan J. Forster [ctb],
  Eric-Jan Wagenmakers [ths],
  The JASP Team [ctb],
  Jiqiang Guo [ctb],
  Jonah Gabry [ctb],
  Ben Goodrich [ctb],
  Kees Mulder [ctb],
  Perry de Valpine [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin F. Gronau &lt;Quentin.F.Gronau@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-16 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bf'>Bayes Factor(s) from Marginal Likelihoods</h2><span id='topic+bf'></span><span id='topic+bayes_factor'></span><span id='topic+bayes_factor.default'></span><span id='topic+bf.bridge'></span><span id='topic+bf.bridge_list'></span><span id='topic+bf.default'></span>

<h3>Description</h3>

<p>Generic function that computes Bayes factor(s) from marginal likelihoods. <code>bayes_factor()</code> is simply an (S3 generic) alias for <code>bf()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf(x1, x2, log = FALSE, ...)

bayes_factor(x1, x2, log = FALSE, ...)

## Default S3 method:
bayes_factor(x1, x2, log = FALSE, ...)

## S3 method for class 'bridge'
bf(x1, x2, log = FALSE, ...)

## S3 method for class 'bridge_list'
bf(x1, x2, log = FALSE, ...)

## Default S3 method:
bf(x1, x2, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bf_+3A_x1">x1</code></td>
<td>
<p>Object of class <code>"bridge"</code> or <code>"bridge_list"</code> as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>. Additionally, the default method assumes that <code>x1</code> is a single numeric log marginal likelihood (e.g., from <code><a href="#topic+logml">logml</a></code>) and will throw an error otherwise.</p>
</td></tr>
<tr><td><code id="bf_+3A_x2">x2</code></td>
<td>
<p>Object of class <code>"bridge"</code> or <code>"bridge_list"</code> as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>. Additionally, the default method assumes that <code>x2</code> is a single numeric log marginal likelihood (e.g., from <code><a href="#topic+logml">logml</a></code>) and will throw an error otherwise.</p>
</td></tr>
<tr><td><code id="bf_+3A_log">log</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the function returns the log of the Bayes factor. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bf_+3A_...">...</code></td>
<td>
<p>currently not used here, but can be used by other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Bayes factor (Kass &amp; Raftery, 1995) in favor of the model associated with <code>x1</code> over the model associated with <code>x2</code>.
</p>


<h3>Value</h3>

<p>For the default method returns a list of class <code>"bf_default"</code> with components:
</p>

<ul>
<li> <p><code>bf</code>: (scalar) value of the Bayes factor in favor of the model associated with <code>x1</code> over the model associated with <code>x2</code>.
</p>
</li>
<li> <p><code>log</code>: Boolean which indicates whether <code>bf</code> corresponds to the log Bayes factor.
</p>
</li></ul>

<p>For the method for <code>"bridge"</code> objects returns a list of class <code>"bf_bridge"</code> with components:
</p>

<ul>
<li> <p><code>bf</code>:  (scalar) value of the Bayes factor in favor of the model associated with <code>x1</code> over the model associated with <code>x2</code>.
</p>
</li>
<li> <p><code>log</code>: Boolean which indicates whether <code>bf</code> corresponds to the log Bayes factor.
</p>
</li></ul>

<p>For the method for <code>"bridge_list"</code> objects returns a list of class <code>"bf_bridge_list"</code> with components:
</p>

<ul>
<li> <p><code>bf</code>:  a numeric vector consisting of Bayes factors where each element gives the Bayes factor for one set of logmls in favor of the model associated with <code>x1</code> over the model associated with <code>x2</code>. The length of this vector is given by the <code>"bridge_list"</code> element with the most <code>repetitions</code>. Elements with fewer repetitions will be recycled (with warning).
</p>
</li>
<li> <p><code>bf_median_based</code>: (scalar) value of the Bayes factor in favor of the model associated with <code>x1</code> over the model associated with <code>x2</code> that is based on the median values of the logml estimates.
</p>
</li>
<li> <p><code>log</code>: Boolean which indicates whether <code>bf</code> corresponds to the log Bayes factor.
</p>
</li></ul>



<h3>Note</h3>

<p>For examples, see <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> and the accompanying vignettes: <br /> <code>vignette("bridgesampling_example_jags")</code> <br /> <code>vignette("bridgesampling_example_stan")</code>
</p>


<h3>Author(s)</h3>

<p>Quentin F. Gronau
</p>


<h3>References</h3>

<p>Kass, R. E., &amp; Raftery, A. E. (1995). Bayes factors. <em>Journal of the American Statistical Association, 90(430)</em>, 773-795. doi: <a href="https://doi.org/10.1080/01621459.1995.10476572">10.1080/01621459.1995.10476572</a>
</p>

<hr>
<h2 id='bridge_sampler'>Log Marginal Likelihood via Bridge Sampling</h2><span id='topic+bridge_sampler'></span><span id='topic+bridge_sampler.stanfit'></span><span id='topic+bridge_sampler.mcmc.list'></span><span id='topic+bridge_sampler.mcmc'></span><span id='topic+bridge_sampler.matrix'></span><span id='topic+bridge_sampler.stanreg'></span><span id='topic+bridge_sampler.rjags'></span><span id='topic+bridge_sampler.runjags'></span><span id='topic+bridge_sampler.MCMC_refClass'></span>

<h3>Description</h3>

<p>Computes log marginal likelihood via bridge sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridge_sampler(samples, ...)

## S3 method for class 'stanfit'
bridge_sampler(
  samples = NULL,
  stanfit_model = samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'mcmc.list'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  param_types = rep("real", ncol(samples[[1]])),
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'mcmc'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  param_types = rep("real", ncol(samples)),
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'matrix'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  param_types = rep("real", ncol(samples)),
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'stanreg'
bridge_sampler(
  samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'rjags'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'runjags'
bridge_sampler(
  samples = NULL,
  log_posterior = NULL,
  ...,
  data = NULL,
  lb = NULL,
  ub = NULL,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  packages = NULL,
  varlist = NULL,
  envir = .GlobalEnv,
  rcppFile = NULL,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE
)

## S3 method for class 'MCMC_refClass'
bridge_sampler(
  samples,
  repetitions = 1,
  method = "normal",
  cores = 1,
  use_neff = TRUE,
  maxiter = 1000,
  silent = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bridge_sampler_+3A_samples">samples</code></td>
<td>
<p>an <code>mcmc.list</code> object, a fitted <code>stanfit</code> object, a
<code>stanreg</code> object, an <code>rjags</code> object, a <code>runjags</code> object, or a
<code>matrix</code> with posterior samples (<code>colnames</code> need to correspond to
parameter names in <code>lb</code> and <code>ub</code>)  with posterior samples.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>log_posterior</code>. Ignored for
the <code>stanfit</code> and <code>stanreg</code> methods.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_stanfit_model">stanfit_model</code></td>
<td>
<p>for the <code>stanfit</code> method, an additional object of
class <code>"stanfit"</code> with the same model as <code>samples</code>, which will be
used for evaluating the <code>log_posterior</code> (i.e., it does not need to
contain any samples). The default is to use <code>samples</code>. In case
<code>samples</code> was compiled in a different R session or on another computer
with a different OS or setup, the <code>samples</code> model usually cannot be
used for evaluation. In this case, one can compile the model on the current
computer with <code>iter = 0</code> and pass it here (this usually needs to be
done before <code>samples</code> is loaded).</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_repetitions">repetitions</code></td>
<td>
<p>number of repetitions.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_method">method</code></td>
<td>
<p>either <code>"normal"</code> or <code>"warp3"</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_cores">cores</code></td>
<td>
<p>number of cores used for evaluating <code>log_posterior</code>. On
unix-like systems (where <code>.Platform$OS.type == "unix"</code> evaluates to
<code>TRUE</code>; e.g., Linux and Mac OS) forking via <code><a href="parallel.html#topic+mclapply">mclapply</a></code> is
used. Hence elements needed for evaluation should be in the
<code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>. For other systems (e.g., Windows)
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> is used and further arguments specified below will
be used.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_use_neff">use_neff</code></td>
<td>
<p>Boolean which determines whether the effective sample size is
used in the optimal bridge function. Default is TRUE. If FALSE, the number
of samples is used instead. If <code>samples</code> is a <code>matrix</code>, it is
assumed that the <code>matrix</code> contains the samples of one chain in order.
If <code>samples</code> come from more than one chain, we recommend to use an
<code>mcmc.list</code> object for optimal performance.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for the iterative updating scheme.
Default is 1,000 to avoid infinite loops.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_silent">silent</code></td>
<td>
<p>Boolean which determines whether to print the number of
iterations of the updating scheme to the console. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Should internal debug information be printed to
console? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_log_posterior">log_posterior</code></td>
<td>
<p>function or name of function that takes a parameter
vector and the <code>data</code> as input and returns the log of the unnormalized
posterior density (i.e., a scalar value). If the function name is passed,
the function should exist in the <code>.GlobalEnv</code>. For special behavior if
<code>cores &gt; 1</code> see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_data">data</code></td>
<td>
<p>data object which is used in <code>log_posterior</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_lb">lb</code></td>
<td>
<p>named vector with lower bounds for parameters.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_ub">ub</code></td>
<td>
<p>named vector with upper bounds for parameters.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_param_types">param_types</code></td>
<td>
<p>character vector of length <code>ncol(samples)</code> with
<code>"real"</code>, <code>"simplex"</code> or <code>"circular"</code>. For all regular
bounded or unbounded continuous parameters, this should just be
<code>"real"</code>. However, if there are parameters which lie on a simplex or on
the circle, this should be noted here. Simplex parameters are parameters
which are bounded below by zero and collectively sum to one, such as weights
in a mixture model. For these, the stick-breaking transformation is
performed as described in the Stan reference manual. The circular variables
are given a numerical representation to which the normal distribution is
most likely a good fit. Only possible to use with
<code>bridge_sampler.matrix</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_packages">packages</code></td>
<td>
<p>character vector with names of packages needed for evaluating
<code>log_posterior</code> in parallel (only relevant if <code>cores &gt; 1</code> and
<code>.Platform$OS.type != "unix"</code>).</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_varlist">varlist</code></td>
<td>
<p>character vector with names of variables needed for evaluating
<code>log_posterior</code> (only needed if <code>cores &gt; 1</code>  and
<code>.Platform$OS.type != "unix"</code> as these objects will be exported to the
nodes). These objects need to exist in <code>envir</code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_envir">envir</code></td>
<td>
<p>specifies the environment for <code>varlist</code> (only needed if
<code>cores &gt; 1</code>  and <code>.Platform$OS.type != "unix"</code> as these objects
will be exported to the nodes). Default is <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.</p>
</td></tr>
<tr><td><code id="bridge_sampler_+3A_rcppfile">rcppFile</code></td>
<td>
<p>in case <code>cores &gt; 1</code> and <code>log_posterior</code> is an
<code>Rcpp</code> function, <code>rcppFile</code> specifies the path to the cpp file
(will be compiled on all cores).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bridge sampling is implemented as described in Meng and Wong (1996,
see equation 4.1) using the &quot;optimal&quot; bridge function. When <code>method =
 "normal"</code>, the proposal distribution is a multivariate normal distribution
with mean vector equal to the sample mean vector of <code>samples</code> and
covariance matrix equal to the sample covariance matrix of <code>samples</code>.
For a recent tutorial on bridge sampling, see Gronau et al. (in press).
</p>
<p>When <code>method = "warp3"</code>, the proposal distribution is a standard
multivariate normal distribution and the posterior distribution is &quot;warped&quot;
(Meng &amp; Schilling, 2002) so that it has the same mean vector, covariance
matrix, and skew as the samples. <code>method = "warp3"</code> takes approximately
twice as long as <code>method = "normal"</code>.
</p>
<p>Note that for the <code>matrix</code> method, the lower and upper bound of a
parameter cannot be a function of the bounds of another parameter.
Furthermore, constraints that depend on multiple parameters of the model are
not supported. This usually excludes, for example, parameters that
constitute a covariance matrix or sets of parameters that need to sum to
one.
</p>
<p>However, if the retransformations are part of the model itself and the
<code>log_posterior</code> accepts parameters on the real line and performs the
appropriate Jacobian adjustments, such as done for <code>stanfit</code> and
<code>stanreg</code> objects, such constraints are obviously possible (i.e., we
currently do not know of any parameter supported within Stan that does not
work with the current implementation through a <code>stanfit</code> object).
</p>


<h4>Parallel Computation</h4>

<p> On unix-like systems forking is used via
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>. Hence elements needed for evaluation of
<code>log_posterior</code> should be in the <code><a href="base.html#topic+.GlobalEnv">.GlobalEnv</a></code>.
</p>
<p>On other OSes (e.g., Windows), things can get more complicated. For normal
parallel computation, the <code>log_posterior</code> function can be passed as
both function and function name. If the latter, it needs to exist in the
environment specified in the <code>envir</code> argument. For parallel computation
when using an <code>Rcpp</code> function, <code>log_posterior</code> can only be passed
as the function name (i.e., character). This function needs to result from
calling <code>sourceCpp</code> on the file specified in <code>rcppFile</code>.
</p>
<p>Due to the way <code>rstan</code> currently works, parallel computations with
<code>stanfit</code> and <code>stanreg</code> objects only work with forking (i.e., NOT
on Windows). </p>



<h3>Value</h3>

<p>if <code>repetitions = 1</code>, returns a list of class <code>"bridge"</code>
with components: </p>
 <ul>
<li> <p><code>logml</code>: estimate of log marginal
likelihood. </p>
</li>
<li> <p><code>niter</code>: number of iterations of the iterative
updating scheme. </p>
</li>
<li> <p><code>method</code>: bridge sampling method that was used
to obtain the estimate. </p>
</li>
<li> <p><code>q11</code>: log posterior evaluations for
posterior samples. </p>
</li>
<li> <p><code>q12</code>: log proposal evaluations for posterior
samples. </p>
</li>
<li> <p><code>q21</code>: log posterior evaluations for samples from
proposal. </p>
</li>
<li> <p><code>q22</code>: log proposal evaluations for samples from
proposal. </p>
</li></ul>
<p> if <code>repetitions &gt; 1</code>, returns a list of class
<code>"bridge_list"</code> with components: </p>
 <ul>
<li> <p><code>logml</code>: numeric
vector with estimates of log marginal likelihood. </p>
</li>
<li> <p><code>niter</code>:
numeric vector with number of iterations of the iterative updating scheme
for each repetition. </p>
</li>
<li> <p><code>method</code>: bridge sampling method that was
used to obtain the estimates. </p>
</li>
<li> <p><code>repetitions</code>: number of
repetitions. </p>
</li></ul>



<h3>Warning</h3>

<p>Note that the results depend strongly on the parameter
priors. Therefore, it is strongly advised to think carefully about the
priors before calculating marginal likelihoods. For example, the prior
choices implemented in <span class="pkg">rstanarm</span> or <span class="pkg">brms</span> might not be optimal
from a testing point of view. We recommend to use priors that have been
chosen from a testing and not a purely estimation perspective.
</p>
<p>Also note that for testing, the number of posterior samples usually needs to
be substantially larger than for estimation.
</p>


<h3>Note</h3>

<p>To be able to use a <code>stanreg</code> object for <code>samples</code>, the user
crucially needs to have specified the <code>diagnostic_file</code> when fitting
the model in <span class="pkg">rstanarm</span>.
</p>


<h3>Author(s)</h3>

<p>Quentin F. Gronau and Henrik Singmann. Parallel computing (i.e.,
<code>cores &gt; 1</code>) and the <code>stanfit</code> method use code from <code>rstan</code>
by Jiaqing Guo, Jonah Gabry, and Ben Goodrich. Ben Goodrich added the
<code>stanreg</code> method. Kees Mulder added methods for simplex and circular
variables.
</p>


<h3>References</h3>

<p>Gronau, Q. F., Singmann, H., &amp; Wagenmakers, E.-J. (2020). bridgesampling: An
R Package for Estimating Normalizing Constants. <em>Journal of Statistical
Software, 92</em>. doi: <a href="https://doi.org/10.18637/jss.v092.i10">10.18637/jss.v092.i10</a>
</p>
<p>Gronau, Q. F., Sarafoglou, A., Matzke, D., Ly, A., Boehm, U.,
Marsman, M., Leslie, D. S., Forster, J. J., Wagenmakers, E.-J., &amp;
Steingroever, H. (in press). A tutorial on bridge sampling. <em>Journal of
Mathematical Psychology</em>. <a href="https://arxiv.org/abs/1703.05984">https://arxiv.org/abs/1703.05984</a> <br />
<code>vignette("bridgesampling_tutorial")</code>
</p>
<p>Gronau, Q. F., Wagenmakers, E.-J., Heck, D. W., &amp; Matzke, D. (2017). <em>A
simple method for comparing complex models: Bayesian model comparison for
hierarchical multinomial processing tree models using Warp-III bridge
sampling</em>. Manuscript submitted for publication.
<a href="https://psyarxiv.com/yxhfm">https://psyarxiv.com/yxhfm</a>
</p>
<p>Meng, X.-L., &amp; Wong, W. H. (1996). Simulating ratios of normalizing
constants via a simple identity: A theoretical exploration. <em>Statistica
Sinica, 6</em>, 831-860.
<a href="http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm">http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm</a>
</p>
<p>Meng, X.-L., &amp; Schilling, S. (2002). Warp bridge sampling. <em>Journal of
Computational and Graphical Statistics, 11(3)</em>, 552-586.
doi: <a href="https://doi.org/10.1198/106186002457">10.1198/106186002457</a>
</p>
<p>Overstall, A. M., &amp; Forster, J. J. (2010). Default Bayesian model
determination methods for generalised linear mixed models.
<em>Computational Statistics &amp; Data Analysis, 54</em>, 3269-3288.
doi: <a href="https://doi.org/10.1016/j.csda.2010.03.008">10.1016/j.csda.2010.03.008</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bf">bf</a></code> allows the user to calculate Bayes factors and
<code><a href="#topic+post_prob">post_prob</a></code> allows the user to calculate posterior model
probabilities from bridge sampling estimates. <code><a href="#topic+bridge-methods">bridge-methods</a></code>
lists some additional methods that automatically invoke the
<code><a href="#topic+error_measures">error_measures</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ------------------------------------------------------------------------
## Example 1: Estimating the Normalizing Constant of a Two-Dimensional
##            Standard Normal Distribution
## ------------------------------------------------------------------------

library(bridgesampling)
library(mvtnorm)

samples &lt;- rmvnorm(1e4, mean = rep(0, 2), sigma = diag(2))
colnames(samples) &lt;- c("x1", "x2")
log_density &lt;- function(samples.row, data) {
  -.5*t(samples.row) %*% samples.row
}

lb &lt;- rep(-Inf, 2)
ub &lt;- rep(Inf, 2)
names(lb) &lt;- names(ub) &lt;- colnames(samples)
bridge_result &lt;- bridge_sampler(samples = samples, log_posterior = log_density,
                                data = NULL, lb = lb, ub = ub, silent = TRUE)

# compare to analytical value
analytical &lt;- log(2*pi)
print(cbind(bridge_result$logml, analytical))

## Not run: 

## ------------------------------------------------------------------------
## Example 2: Hierarchical Normal Model
## ------------------------------------------------------------------------

# for a full description of the example, see
vignette("bridgesampling_example_jags")

library(R2jags)

### generate data ###

set.seed(12345)

mu &lt;- 0
tau2 &lt;- 0.5
sigma2 &lt;- 1

n &lt;- 20
theta &lt;- rnorm(n, mu, sqrt(tau2))
y &lt;- rnorm(n, theta, sqrt(sigma2))


### set prior parameters
alpha &lt;- 1
beta &lt;- 1
mu0 &lt;- 0
tau20 &lt;- 1

### functions to get posterior samples ###

### H0: mu = 0

getSamplesModelH0 &lt;- function(data, niter = 52000, nburnin = 2000, nchains = 3) {

  model &lt;- "
    model {
      for (i in 1:n) {
        theta[i] ~ dnorm(0, invTau2)
          y[i] ~ dnorm(theta[i], 1/sigma2)
      }
      invTau2 ~ dgamma(alpha, beta)
      tau2 &lt;- 1/invTau2
    }"

  s &lt;- jags(data, parameters.to.save = c("theta", "invTau2"),
            model.file = textConnection(model),
            n.chains = nchains, n.iter = niter,
            n.burnin = nburnin, n.thin = 1)

  return(s)

}

### H1: mu != 0

getSamplesModelH1 &lt;- function(data, niter = 52000, nburnin = 2000,
                              nchains = 3) {

  model &lt;- "
    model {
      for (i in 1:n) {
        theta[i] ~ dnorm(mu, invTau2)
        y[i] ~ dnorm(theta[i], 1/sigma2)
      }
      mu ~ dnorm(mu0, 1/tau20)
      invTau2 ~ dgamma(alpha, beta)
      tau2 &lt;- 1/invTau2
    }"

  s &lt;- jags(data, parameters.to.save = c("theta", "mu", "invTau2"),
            model.file = textConnection(model),
            n.chains = nchains, n.iter = niter,
            n.burnin = nburnin, n.thin = 1)

  return(s)

}

### get posterior samples ###

# create data lists for Jags
data_H0 &lt;- list(y = y, n = length(y), alpha = alpha, beta = beta, sigma2 = sigma2)
data_H1 &lt;- list(y = y, n = length(y), mu0 = mu0, tau20 = tau20, alpha = alpha,
                beta = beta, sigma2 = sigma2)

# fit models
samples_H0 &lt;- getSamplesModelH0(data_H0)
samples_H1 &lt;- getSamplesModelH1(data_H1)


### functions for evaluating the unnormalized posteriors on log scale ###
log_posterior_H0 &lt;- function(samples.row, data) {

  mu &lt;- 0
  invTau2 &lt;- samples.row[[ "invTau2" ]]
  theta &lt;- samples.row[ paste0("theta[", seq_along(data$y), "]") ]

  sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
    sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
    dgamma(invTau2, data$alpha, data$beta, log = TRUE)

}

log_posterior_H1 &lt;- function(samples.row, data) {

  mu &lt;- samples.row[[ "mu" ]]
  invTau2 &lt;- samples.row[[ "invTau2" ]]
  theta &lt;- samples.row[ paste0("theta[", seq_along(data$y), "]") ]

  sum(dnorm(data$y, theta, data$sigma2, log = TRUE)) +
    sum(dnorm(theta, mu, 1/sqrt(invTau2), log = TRUE)) +
    dnorm(mu, data$mu0, sqrt(data$tau20), log = TRUE) +
    dgamma(invTau2, data$alpha, data$beta, log = TRUE)

}

# specify parameter bounds H0
cn &lt;- colnames(samples_H0$BUGSoutput$sims.matrix)
cn &lt;- cn[cn != "deviance"]
lb_H0 &lt;- rep(-Inf, length(cn))
ub_H0 &lt;- rep(Inf, length(cn))
names(lb_H0) &lt;- names(ub_H0) &lt;- cn
lb_H0[[ "invTau2" ]] &lt;- 0

# specify parameter bounds H1
cn &lt;- colnames(samples_H1$BUGSoutput$sims.matrix)
cn &lt;- cn[cn != "deviance"]
lb_H1 &lt;- rep(-Inf, length(cn))
ub_H1 &lt;- rep(Inf, length(cn))
names(lb_H1) &lt;- names(ub_H1) &lt;- cn
lb_H1[[ "invTau2" ]] &lt;- 0


# compute log marginal likelihood via bridge sampling for H0
H0.bridge &lt;- bridge_sampler(samples = samples_H0, data = data_H0,
                            log_posterior = log_posterior_H0, lb = lb_H0,
                            ub = ub_H0, silent = TRUE)
print(H0.bridge)

# compute log marginal likelihood via bridge sampling for H1
H1.bridge &lt;- bridge_sampler(samples = samples_H1, data = data_H1,
                            log_posterior = log_posterior_H1, lb = lb_H1,
                            ub = ub_H1, silent = TRUE)
print(H1.bridge)

# compute percentage error
print(error_measures(H0.bridge)$percentage)
print(error_measures(H1.bridge)$percentage)

# compute Bayes factor
BF01 &lt;- bf(H0.bridge, H1.bridge)
print(BF01)

# compute posterior model probabilities (assuming equal prior model probabilities)
post1 &lt;- post_prob(H0.bridge, H1.bridge)
print(post1)

# compute posterior model probabilities (using user-specified prior model probabilities)
post2 &lt;- post_prob(H0.bridge, H1.bridge, prior_prob = c(.6, .4))
print(post2)


## End(Not run)

## Not run: 

## ------------------------------------------------------------------------
## Example 3: rstanarm
## ------------------------------------------------------------------------
library(rstanarm)

# N.B.: remember to specify the diagnostic_file

fit_1 &lt;- stan_glm(mpg ~ wt + qsec + am, data = mtcars,
                  chains = 2, cores = 2, iter = 5000,
                  diagnostic_file = file.path(tempdir(), "df.csv"))
bridge_1 &lt;- bridge_sampler(fit_1)
fit_2 &lt;- update(fit_1, formula = . ~ . + cyl)
bridge_2 &lt;- bridge_sampler(fit_2, method = "warp3")
bf(bridge_1, bridge_2)


## End(Not run)

</code></pre>

<hr>
<h2 id='bridge-methods'>Methods for bridge and bridge_list objects</h2><span id='topic+bridge-methods'></span><span id='topic+summary.bridge'></span><span id='topic+summary.bridge_list'></span><span id='topic+print.summary.bridge'></span><span id='topic+print.summary.bridge_list'></span><span id='topic+print.bridge'></span><span id='topic+print.bridge_list'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the generic <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bridge'
summary(object, na.rm = TRUE, ...)

## S3 method for class 'bridge_list'
summary(object, na.rm = TRUE, ...)

## S3 method for class 'summary.bridge'
print(x, ...)

## S3 method for class 'summary.bridge_list'
print(x, ...)

## S3 method for class 'bridge'
print(x, ...)

## S3 method for class 'bridge_list'
print(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bridge-methods_+3A_object">object</code>, <code id="bridge-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>bridge</code> or <code>bridge_list</code> as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="bridge-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should NA estimates in <code>bridge_list</code> objects be removed? Passed to <code><a href="#topic+error_measures">error_measures</a></code>.</p>
</td></tr>
<tr><td><code id="bridge-methods_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> methods return a <code>data.frame</code> which contains the log marginal likelihood plus the result returned from invoking <code><a href="#topic+error_measures">error_measures</a></code>.
</p>
<p>The <code>print</code> methods simply print and return nothing.
</p>

<hr>
<h2 id='error_measures'>Error Measures for Estimated Marginal Likelihood</h2><span id='topic+error_measures'></span><span id='topic+error_measures.bridge'></span><span id='topic+error_measures.bridge_list'></span>

<h3>Description</h3>

<p>Computes error measures for estimated marginal likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_measures(bridge_object, ...)

## S3 method for class 'bridge'
error_measures(bridge_object, ...)

## S3 method for class 'bridge_list'
error_measures(bridge_object, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="error_measures_+3A_bridge_object">bridge_object</code></td>
<td>
<p>an object of class <code>"bridge"</code> or <code>"bridge_list"</code> as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="error_measures_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored).</p>
</td></tr>
<tr><td><code id="error_measures_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values in logml estimates should be removed.  Ignored for the <code>bridge</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes error measures for marginal likelihood bridge sampling estimates. The approximate errors for a <code>bridge_object</code> of class <code>"bridge"</code> that has been obtained with <code>method = "normal"</code> and <code>repetitions = 1</code> are based on Fruehwirth-Schnatter (2004).
Not applicable in case the object of class <code>"bridge"</code> has been obtained with <code>method = "warp3"</code> and <code>repetitions = 1</code>.
To assess the uncertainty of the estimate in this case, it is recommended to run the <code>"warp3"</code> procedure multiple times.
</p>


<h3>Value</h3>

<p>If <code>bridge_object</code> is of class <code>"bridge"</code> and has been obtained with <code>method = "normal"</code> and <code>repetitions = 1</code>, returns a list with components:
</p>

<ul>
<li> <p><code>re2</code>: approximate relative mean-squared error for marginal likelihood estimate.
</p>
</li>
<li> <p><code>cv</code>: approximate coefficient of variation for marginal likelihood estimate (assumes that bridge estimate is unbiased).
</p>
</li>
<li> <p><code>percentage</code>: approximate percentage error of marginal likelihood estimate.
</p>
</li></ul>

<p>If <code>bridge_object</code> is of class <code>"bridge_list"</code>, returns a list with components:
</p>

<ul>
<li> <p><code>min</code>: minimum of the log marginal likelihood estimates.
</p>
</li>
<li> <p><code>max</code>: maximum of the log marginal likelihood estimates.
</p>
</li>
<li> <p><code>IQR</code>: interquartile range of the log marginal likelihood estimates.
</p>
</li></ul>



<h3>Note</h3>

<p>For examples, see <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> and the accompanying vignettes: <br /> <code>vignette("bridgesampling_example_jags")</code> <br /> <code>vignette("bridgesampling_example_stan")</code>
</p>


<h3>Author(s)</h3>

<p>Quentin F. Gronau
</p>


<h3>References</h3>

<p>Fruehwirth-Schnatter, S. (2004). Estimating marginal likelihoods for mixture and Markov switching models using bridge sampling techniques. <em>The Econometrics Journal, 7</em>, 143-167. doi: <a href="https://doi.org/10.1111/j.1368-423X.2004.00125.x">10.1111/j.1368-423X.2004.00125.x</a>
</p>


<h3>See Also</h3>

<p>The <code>summary</code> methods for <code>bridge</code> and <code>bridge_list</code> objects automatically invoke this function, see <code><a href="#topic+bridge-methods">bridge-methods</a></code>.
</p>

<hr>
<h2 id='ier'>Standardized International Exchange Rate Changes from 1975 to 1986</h2><span id='topic+ier'></span>

<h3>Description</h3>

<p>This data set contains the changes in monthly international exchange rates for pounds sterling from January 1975 to December 1986 obtained from West and Harrison (1997, pp. 612-615). Currencies tracked are US Dollar (column <code>us_dollar</code>), Canadian Dollar (column <code>canadian_dollar</code>), Japanese Yen (column <code>yen</code>), French Franc (column <code>franc</code>), Italian Lira (column <code>lira</code>), and the (West) German Mark (column <code>mark</code>). Each series has been standardized with respect to its sample mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ier
</code></pre>


<h3>Format</h3>

<p>A matrix with 143 rows and 6 columns.
</p>


<h3>Source</h3>

<p>West, M., Harrison, J. (1997). <em>Bayesian forecasting and dynamic models</em> (2nd ed.). Springer-Verlag, New York.
</p>
<p>Lopes, H. F., West, M. (2004). Bayesian model assessment in factor analysis. <em>Statistica Sinica, 14</em>, 41-67. <a href="https://www.jstor.org/stable/24307179">https://www.jstor.org/stable/24307179</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

################################################################################
# BAYESIAN FACTOR ANALYSIS (AS PROPOSED BY LOPES &amp; WEST, 2004)
################################################################################

library(bridgesampling)
library(rstan)

cores &lt;- 4
options(mc.cores = cores)

data("ier")

#-------------------------------------------------------------------------------
# plot data
#-------------------------------------------------------------------------------

currency &lt;- colnames(ier)
label &lt;- c("US Dollar", "Canadian Dollar", "Yen", "Franc", "Lira", "Mark")
op &lt;- par(mfrow = c(3, 2), mar = c(6, 6, 3, 3))

for (i in seq_along(currency)) {
  plot(ier[,currency[i]], type = "l", col = "darkblue",  axes = FALSE,
       ylim = c(-4, 4), ylab = "", xlab = "", lwd = 2)
  axis(1, at = 0:12*12, labels = 1975:1987, cex.axis = 1.7)
  axis(2, at = pretty(c(-4, 4)), las = 1, cex.axis = 1.7)
  mtext("Year", 1, cex = 1.5, line = 3.2)
  mtext("Exchange Rate Changes", 2, cex = 1.4, line = 3.2)
  mtext(label[i], 3, cex = 1.6, line = .1)
}

par(op)

#-------------------------------------------------------------------------------
# stan model
#-------------------------------------------------------------------------------

model_code &lt;-
"data {
  int&lt;lower=1&gt; T; // number of observations
  int&lt;lower=1&gt; m; // number of variables
  int&lt;lower=1&gt; k; // number of factors
  matrix[T,m] Y;  // data matrix
}
transformed data {
  int&lt;lower = 1&gt; r;
  vector[m] zeros;
  r = m * k - k * (k - 1) / 2; // number of non-zero factor loadings
  zeros = rep_vector(0.0, m);
}
parameters {
  real beta_lower[r - k];  // lower-diagonal elements of beta
  real&lt;lower = 0&gt; beta_diag [k]; // diagonal elements of beta
  vector&lt;lower = 0&gt;[m] sigma2; // residual variances
}
transformed parameters {
  matrix[m,k] beta;
  cov_matrix[m] Omega;
  // construct lower-triangular factor loadings matrix
  {
    int index_lower = 1;
    for (j in 1:k) {
      for (i in 1:m) {
        if (i == j) {
          beta[j,j] = beta_diag[j];
        } else if (i &gt;= j) {
          beta[i,j] = beta_lower[index_lower];
          index_lower = index_lower + 1;
        } else {
          beta[i,j] = 0.0;
        }
      }
    }
  }
  Omega = beta * beta' + diag_matrix(sigma2);
}
model {
  // priors
  target += normal_lpdf(beta_diag | 0, 1) - k * normal_lccdf(0 | 0, 1);
  target += normal_lpdf(beta_lower | 0, 1);
  target += inv_gamma_lpdf(sigma2 | 2.2 / 2.0, 0.1 / 2.0);

  // likelihood
  for(t in 1:T) {
    target += multi_normal_lpdf(Y[t] | zeros, Omega);
  }
}"

# compile model
model &lt;- stan_model(model_code = model_code)


#-------------------------------------------------------------------------------
# fit models and compute log marginal likelihoods
#-------------------------------------------------------------------------------

# function for generating starting values
init_fun &lt;- function(nchains, k, m) {
  r &lt;- m * k - k * (k - 1) / 2
  out &lt;- vector("list", nchains)
  for (i in seq_len(nchains)) {
    beta_lower &lt;- array(runif(r - k, 0.05, 1), dim = r - k)
    beta_diag &lt;- array(runif(k, .05, 1), dim = k)
    sigma2 &lt;- array(runif(m, .05, 1.5), dim = m)
    out[[i]] &lt;- list(beta_lower = beta_lower,
                     beta_diag = beta_diag,
                     sigma2 = sigma2)
  }
  return(out)
}

set.seed(1)
stanfit &lt;- bridge &lt;- vector("list", 3)
for (k in 1:3) {
  stanfit[[k]] &lt;- sampling(model,
                           data = list(Y = ier, T = nrow(ier),
                                       m = ncol(ier), k = k),
                           iter = 11000, warmup = 1000, chains = 4,
                           init = init_fun(nchains = 4, k = k, m = ncol(ier)),
                           cores = cores, seed = 1)
  bridge[[k]] &lt;- bridge_sampler(stanfit[[k]], method = "warp3",
                                repetitions = 10, cores = cores)
}

# example output
summary(bridge[[2]])

#-------------------------------------------------------------------------------
# compute posterior model probabilities
#-------------------------------------------------------------------------------

pp &lt;- post_prob(bridge[[1]], bridge[[2]], bridge[[3]],
          model_names = c("k = 1", "k = 2", "k = 3"))
pp

op &lt;- par(mar = c(6, 6, 3, 3))
boxplot(pp, axes = FALSE,
     ylim = c(0, 1), ylab = "",
     xlab = "")
axis(1, at = 1:3, labels = colnames(pp), cex.axis = 1.7)
axis(2, cex.axis = 1.1)
mtext("Posterior Model Probability", 2, cex = 1.5, line = 3.2)
mtext("Number of Factors", 1, cex = 1.4, line = 3.2)
par(op)


## End(Not run)
</code></pre>

<hr>
<h2 id='logml'>Log Marginal Likelihoods from Bridge Objects</h2><span id='topic+logml'></span><span id='topic+logml.bridge'></span><span id='topic+logml.bridge_list'></span>

<h3>Description</h3>

<p>Generic function that returns log marginal likelihood from bridge objects. For objects of class <code>"bridge_list"</code>, which contains multiple log marginal likelihoods, <code>fun</code> is performed on the vector and its result returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logml(x, ...)

## S3 method for class 'bridge'
logml(x, ...)

## S3 method for class 'bridge_list'
logml(x, fun = median, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logml_+3A_x">x</code></td>
<td>
<p>Object of class <code>"bridge"</code> or <code>"bridge_list"</code> as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="logml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="logml_+3A_fun">fun</code></td>
<td>
<p>Function which returns a scalar value and is applied to the <code>logml</code> vector of <code>"bridge_list"</code> objects. Default is <code><a href="stats.html#topic+median">median</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar numeric
</p>

<hr>
<h2 id='post_prob'>Posterior Model Probabilities from Marginal Likelihoods</h2><span id='topic+post_prob'></span><span id='topic+post_prob.bridge'></span><span id='topic+post_prob.bridge_list'></span><span id='topic+post_prob.default'></span>

<h3>Description</h3>

<p>Generic function that computes posterior model probabilities from marginal
likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_prob(x, ..., prior_prob = NULL, model_names = NULL)

## S3 method for class 'bridge'
post_prob(x, ..., prior_prob = NULL, model_names = NULL)

## S3 method for class 'bridge_list'
post_prob(x, ..., prior_prob = NULL, model_names = NULL)

## Default S3 method:
post_prob(x, ..., prior_prob = NULL, model_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_prob_+3A_x">x</code></td>
<td>
<p>Object of class <code>"bridge"</code> or <code>"bridge_list"</code> as returned
from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>. Additionally, the default method assumes
that all passed objects are numeric log marginal likelihoods (e.g., from
<code><a href="#topic+logml">logml</a></code>) and will throw an error otherwise.</p>
</td></tr>
<tr><td><code id="post_prob_+3A_...">...</code></td>
<td>
<p>further objects of class <code>"bridge"</code> or <code>"bridge_list"</code>
as returned from <code><a href="#topic+bridge_sampler">bridge_sampler</a></code>. Or numeric values for the
default method.</p>
</td></tr>
<tr><td><code id="post_prob_+3A_prior_prob">prior_prob</code></td>
<td>
<p>numeric vector with prior model probabilities. If omitted,
a uniform prior is used (i.e., all models are equally likely a priori). The
default <code>NULL</code> corresponds to equal prior model weights.</p>
</td></tr>
<tr><td><code id="post_prob_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names derived
from deparsing the call. Otherwise will use the passed values as model
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the default method and the method for <code>"bridge"</code> objects, a
named numeric vector with posterior model probabilities (i.e., which sum to
one).
</p>
<p>For the method for <code>"bridge_list"</code> objects, a matrix consisting of
posterior model probabilities where each row sums to one and gives the
model probabilities for one set of logmls. The (named) columns correspond
to the models and the number of rows is given by the <code>"bridge_list"</code>
element with the most <code>repetitions</code>. Elements with fewer repetitions
will be recycled (with warning).
</p>


<h3>Note</h3>

<p>For realistic examples, see <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> and the
accompanying vignettes: <br /> <code>vignette("bridgesampling_example_jags")</code>
<br /> <code>vignette("bridgesampling_example_stan")</code>
</p>


<h3>Author(s)</h3>

<p>Quentin F. Gronau and Henrik Singmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
H0 &lt;- structure(list(logml = -20.8084543022433, niter = 4, method = "normal"),
                .Names = c("logml", "niter", "method"), class = "bridge")
H1 &lt;- structure(list(logml = -17.9623077558729, niter = 4, method = "normal"),
                .Names = c("logml", "niter", "method"), class = "bridge")
H2 &lt;- structure(list(logml = -19, niter = 4, method = "normal"),
                .Names = c("logml", "niter", "method"), class = "bridge")


post_prob(H0, H1, H2)
post_prob(H1, H0)

## all produce the same (only names differ):
post_prob(H0, H1, H2)
post_prob(H0$logml, H1$logml, H2$logml)
post_prob(c(H0$logml, H1$logml, H2$logml))
post_prob(H0$logml, c(H1$logml, H2$logml))
post_prob(H0$logml, c(H1$logml, H2$logml), model_names = c("H0", "H1", "H2"))


### with bridge list elements:
H0L &lt;- structure(list(logml = c(-20.8088381186739, -20.8072772698116,
-20.808454454621, -20.8083419072281, -20.8087870541247, -20.8084887398113,
-20.8086023582344, -20.8079083169745, -20.8083048489095, -20.8090050811436
), niter = c(4, 4, 4, 4, 4, 4, 4, 4, 4, 4), method = "normal",
    repetitions = 10), .Names = c("logml", "niter", "method",
"repetitions"), class = "bridge_list")

H1L &lt;- structure(list(logml = c(-17.961665507006, -17.9611290723151,
-17.9607509604499, -17.9608629535992, -17.9602093576442, -17.9600223300432,
-17.9610157118017, -17.9615557696561, -17.9608437034849, -17.9606743200309
), niter = c(4, 4, 4, 4, 4, 4, 4, 4, 3, 4), method = "normal",
    repetitions = 10), .Names = c("logml", "niter", "method",
"repetitions"), class = "bridge_list")

post_prob(H1L, H0L)
post_prob(H1L, H0L, H0) # last element recycled with warning.

</code></pre>

<hr>
<h2 id='turtles'>Turtles Data from Janzen, Tucker, and Paukstis (2000)</h2><span id='topic+turtles'></span>

<h3>Description</h3>

<p>This data set contains information about 244 newborn turtles from 31
different clutches. For each turtle, the data set includes information about
survival status (column <code>y</code>; 0 = died, 1 = survived), birth weight in
grams (column <code>x</code>), and clutch (family) membership (column
<code>clutch</code>; an integer between one and 31). The clutches have been ordered
according to mean birth weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turtles
</code></pre>


<h3>Format</h3>

<p>A data.frame with 244 rows and 3 variables.
</p>


<h3>Source</h3>

<p>Janzen, F. J., Tucker,  J. K., &amp; Paukstis, G. L. (2000). Experimental
analysis of an early life-history stage: Selection on size of hatchling
turtles. <em>Ecology, 81(8)</em>, 2290-2304.
doi: <a href="https://doi.org/10.2307/177115">10.2307/177115</a>
</p>
<p>Overstall, A. M., &amp; Forster, J. J. (2010). Default Bayesian model
determination methods for generalised linear mixed models.
<em>Computational Statistics &amp; Data Analysis, 54</em>, 3269-3288.
doi: <a href="https://doi.org/10.1016/j.csda.2010.03.008">10.1016/j.csda.2010.03.008</a>
</p>
<p>Sinharay, S., &amp; Stern, H. S. (2005). An empirical comparison of methods for
computing Bayes factors in generalized linear mixed models. <em>Journal
of Computational and Graphical Statistics, 14(2)</em>, 415-435.
doi: <a href="https://doi.org/10.1198/106186005X47471">10.1198/106186005X47471</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

################################################################################
# BAYESIAN GENERALIZED LINEAR MIXED MODEL (PROBIT REGRESSION)
################################################################################

library(bridgesampling)
library(rstan)

data("turtles")

#-------------------------------------------------------------------------------
# plot data
#-------------------------------------------------------------------------------

# reproduce Figure 1 from Sinharay &amp; Stern (2005)
xticks &lt;- pretty(turtles$clutch)
yticks &lt;- pretty(turtles$x)

plot(1, type = "n", axes = FALSE, ylab = "", xlab = "", xlim = range(xticks),
     ylim =  range(yticks))
points(turtles$clutch, turtles$x, pch = ifelse(turtles$y, 21, 4), cex = 1.3,
       col = ifelse(turtles$y, "black", "darkred"), bg = "grey", lwd = 1.3)
axis(1, cex.axis = 1.4)
mtext("Clutch Identifier", side = 1, line = 2.9, cex = 1.8)
axis(2, las = 1, cex.axis = 1.4)
mtext("Birth Weight (Grams)", side = 2, line = 2.6, cex = 1.8)

#-------------------------------------------------------------------------------
# Analysis: Natural Selection Study (compute same BF as Sinharay &amp; Stern, 2005)
#-------------------------------------------------------------------------------

### H0 (model without random intercepts) ###
H0_code &lt;-
"data {
  int&lt;lower = 1&gt; N;
  int&lt;lower = 0, upper = 1&gt; y[N];
  real&lt;lower = 0&gt; x[N];
}
parameters {
  real alpha0_raw;
  real alpha1_raw;
}
transformed parameters {
  real alpha0 = sqrt(10.0) * alpha0_raw;
  real alpha1 = sqrt(10.0) * alpha1_raw;
}
model {
  // priors
  target += normal_lpdf(alpha0_raw | 0, 1);
  target += normal_lpdf(alpha1_raw | 0, 1);

  // likelihood
  for (i in 1:N) {
    target += bernoulli_lpmf(y[i] | Phi(alpha0 + alpha1 * x[i]));
  }
}"

### H1 (model with random intercepts) ###
H1_code &lt;-
"data {
  int&lt;lower = 1&gt; N;
  int&lt;lower = 0, upper = 1&gt; y[N];
  real&lt;lower = 0&gt; x[N];
  int&lt;lower = 1&gt; C;
  int&lt;lower = 1, upper = C&gt; clutch[N];
}
parameters {
  real alpha0_raw;
  real alpha1_raw;
  vector[C] b_raw;
  real&lt;lower = 0&gt; sigma2;
}
transformed parameters {
  vector[C] b;
  real&lt;lower = 0&gt; sigma = sqrt(sigma2);
  real alpha0 = sqrt(10.0) * alpha0_raw;
  real alpha1 = sqrt(10.0) * alpha1_raw;
  b = sigma * b_raw;
}
model {
  // priors
  target += - 2 * log(1 + sigma2); // p(sigma2) = 1 / (1 + sigma2) ^ 2
  target += normal_lpdf(alpha0_raw | 0, 1);
  target += normal_lpdf(alpha1_raw | 0, 1);

  // random effects
  target += normal_lpdf(b_raw | 0, 1);

  // likelihood
  for (i in 1:N) {
    target += bernoulli_lpmf(y[i] | Phi(alpha0 + alpha1 * x[i] + b[clutch[i]]));
  }
}"

set.seed(1)
### fit models ###
stanfit_H0 &lt;- stan(model_code = H0_code,
                   data = list(y = turtles$y, x = turtles$x, N = nrow(turtles)),
                   iter = 15500, warmup = 500, chains = 4, seed = 1)
stanfit_H1 &lt;- stan(model_code = H1_code,
                   data = list(y = turtles$y, x = turtles$x, N = nrow(turtles),
                               C = max(turtles$clutch), clutch = turtles$clutch),
                   iter = 15500, warmup = 500, chains = 4, seed = 1)

set.seed(1)
### compute (log) marginal likelihoods ###
bridge_H0 &lt;- bridge_sampler(stanfit_H0)
bridge_H1 &lt;- bridge_sampler(stanfit_H1)

### compute approximate percentage errors ###
error_measures(bridge_H0)$percentage
error_measures(bridge_H1)$percentage

### summary ###
summary(bridge_H0)
summary(bridge_H1)

### compute Bayes factor ("true" value: BF01 = 1.273) ###
bf(bridge_H0, bridge_H1)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
