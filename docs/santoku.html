<!DOCTYPE html><html lang="en"><head><title>Help for package santoku</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {santoku}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#santoku-package'><p>A versatile cutting tool for R</p></a></li>
<li><a href='#breaks-class'><p>Class representing a set of intervals</p></a></li>
<li><a href='#brk_default'><p>Create a standard set of breaks</p></a></li>
<li><a href='#brk_manual'><p>Create a <code>breaks</code> object manually</p></a></li>
<li><a href='#brk_width-for-datetime'><p>Equal-width intervals for dates or datetimes</p></a></li>
<li><a href='#chop'><p>Cut data into intervals</p></a></li>
<li><a href='#chop_equally'><p>Chop equal-sized groups</p></a></li>
<li><a href='#chop_evenly'><p>Chop into equal-width intervals</p></a></li>
<li><a href='#chop_fn'><p>Chop using an existing function</p></a></li>
<li><a href='#chop_mean_sd'><p>Chop by standard deviations</p></a></li>
<li><a href='#chop_n'><p>Chop into fixed-sized groups</p></a></li>
<li><a href='#chop_pretty'><p>Chop using pretty breakpoints</p></a></li>
<li><a href='#chop_proportions'><p>Chop into proportions of the range of x</p></a></li>
<li><a href='#chop_quantiles'><p>Chop by quantiles</p></a></li>
<li><a href='#chop_width'><p>Chop into fixed-width intervals</p></a></li>
<li><a href='#exactly'><p>Define singleton intervals explicitly</p></a></li>
<li><a href='#fillet'><p>Chop data precisely (for programmers)</p></a></li>
<li><a href='#lbl_dash'><p>Label chopped intervals like 1-4, 4-5, ...</p></a></li>
<li><a href='#lbl_discrete'><p>Label discrete data</p></a></li>
<li><a href='#lbl_endpoints'><p>Label chopped intervals by their left or right endpoints</p></a></li>
<li><a href='#lbl_glue'><p>Label chopped intervals using the <code>glue</code> package</p></a></li>
<li><a href='#lbl_intervals'><p>Label chopped intervals using set notation</p></a></li>
<li><a href='#lbl_manual'><p>Defunct: label chopped intervals in a user-defined sequence</p></a></li>
<li><a href='#lbl_midpoints'><p>Label chopped intervals by their midpoints</p></a></li>
<li><a href='#lbl_seq'><p>Label chopped intervals in sequence</p></a></li>
<li><a href='#non-standard-types'><p>Tips for chopping non-standard types</p></a></li>
<li><a href='#percent'><p>Simple percentage formatter</p></a></li>
<li><a href='#santoku-cast'><p>Internal functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Versatile Cutting Tool</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Hugh-Jones &lt;davidhughjones@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool for cutting data into intervals. Allows singleton intervals.
  Always includes the whole range of data by default. Flexible labelling. 
  Convenience functions for cutting by quantiles etc. Handles dates, times, units
  and other vectors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, bit64, covr, haven, Hmisc, hms, knitr, lubridate,
purrr, rmarkdown, scales, stringi, testthat (&ge; 2.1.0), units,
withr, xts, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, assertthat, glue, lifecycle, rlang, vctrs</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hughjonesd/santoku">https://github.com/hughjonesd/santoku</a>,
<a href="https://hughjonesd.github.io/santoku/">https://hughjonesd.github.io/santoku/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hughjonesd/santoku/issues">https://github.com/hughjonesd/santoku/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-04 18:59:26 UTC; davidhugh-jones</td>
</tr>
<tr>
<td>Author:</td>
<td>David Hugh-Jones [aut, cre],
  Daniel Possenriede [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='santoku-package'>A versatile cutting tool for R</h2><span id='topic+santoku'></span><span id='topic+santoku-package'></span>

<h3>Description</h3>

<p>santoku is a tool for cutting data into intervals. It provides
the function <code><a href="#topic+chop">chop()</a></code>, which is similar to base R's <code><a href="base.html#topic+cut">cut()</a></code> or <code>Hmisc::cut2()</code>.
<code>chop(x, breaks)</code> takes a vector <code>x</code> and returns a factor of the
same length, coding which interval each element of <code>x</code> falls into.
</p>


<h3>Details</h3>

<p>Here are some advantages of santoku:
</p>

<ul>
<li><p> By default, <code>chop()</code> always covers the whole range of the data, so you
won't get unexpected <code>NA</code> values.
</p>
</li>
<li><p> Unlike <code>cut()</code> or <code>cut2()</code>, <code>chop()</code> can handle single values as well as
intervals. For example, <code>chop(x, breaks = c(1, 2, 2, 3))</code> will create a
separate factor level for values exactly equal to 2.
</p>
</li>
<li><p> Flexible and easy labelling.
</p>
</li>
<li><p> Convenience functions for creating quantile intervals, evenly-spaced
intervals or equal-sized groups.
</p>
</li>
<li><p> Convenience functions to quickly tabulate chopped data.
</p>
</li>
<li><p> Can chop numbers, dates, date-times and other objects.
</p>
</li></ul>

<p>These advantages make santoku especially useful for exploratory analysis,
where you may not know the range of your data in advance.
</p>
<p>To get started, read the vignette:
</p>
<div class="sourceCode r"><pre>vignette("santoku")
</pre></div>
<p>For more details, start with the documentation for <code><a href="#topic+chop">chop()</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Hugh-Jones <a href="mailto:davidhughjones@gmail.com">davidhughjones@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Daniel Possenriede <a href="mailto:possenriede@gmail.com">possenriede@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hughjonesd/santoku">https://github.com/hughjonesd/santoku</a>
</p>
</li>
<li> <p><a href="https://hughjonesd.github.io/santoku/">https://hughjonesd.github.io/santoku/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hughjonesd/santoku/issues">https://github.com/hughjonesd/santoku/issues</a>
</p>
</li></ul>


<hr>
<h2 id='breaks-class'>Class representing a set of intervals</h2><span id='topic+breaks-class'></span><span id='topic+format.breaks'></span><span id='topic+print.breaks'></span><span id='topic+is.breaks'></span>

<h3>Description</h3>

<p>Class representing a set of intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'breaks'
format(x, ...)

## S3 method for class 'breaks'
print(x, ...)

is.breaks(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breaks-class_+3A_x">x</code></td>
<td>
<p>A breaks object</p>
</td></tr>
<tr><td><code id="breaks-class_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>

<hr>
<h2 id='brk_default'>Create a standard set of breaks</h2><span id='topic+brk_default'></span>

<h3>Description</h3>

<p>Create a standard set of breaks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brk_default(breaks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brk_default_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which returns an object of class <code>breaks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chop(1:10, c(2, 5, 8))
chop(1:10, brk_default(c(2, 5, 8)))

</code></pre>

<hr>
<h2 id='brk_manual'>Create a <code>breaks</code> object manually</h2><span id='topic+brk_manual'></span>

<h3>Description</h3>

<p>Create a <code>breaks</code> object manually
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brk_manual(breaks, left_vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brk_manual_+3A_breaks">breaks</code></td>
<td>
<p>A vector, which must be sorted.</p>
</td></tr>
<tr><td><code id="brk_manual_+3A_left_vec">left_vec</code></td>
<td>
<p>A logical vector, the same length as <code>breaks</code>.
Specifies whether each break is left-closed or right-closed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All breaks must be closed on exactly one side, like <code style="white-space: pre;">&#8288;..., x) [x, ...&#8288;</code>
(left-closed) or <code style="white-space: pre;">&#8288;..., x) [x, ...&#8288;</code> (right-closed).
</p>
<p>For example, if <code>breaks = 1:3</code> and <code>left = c(TRUE, FALSE, TRUE)</code>, then the
resulting intervals are </p>
<pre>
T        F       T
[ 1,  2 ] ( 2, 3 )
</pre>
<p>Singleton breaks are created by repeating a number in <code>breaks</code>. Singletons
must be closed on both sides, so if there is a repeated number
at indices <code>i</code>, <code>i+1</code>, <code>left[i]</code> <em>must</em> be <code>TRUE</code> and <code>left[i+1]</code> must be
<code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A function which returns an object of class <code>breaks</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lbrks &lt;- brk_manual(1:3, rep(TRUE, 3))
chop(1:3, lbrks, extend = FALSE)

rbrks &lt;- brk_manual(1:3, rep(FALSE, 3))
chop(1:3, rbrks, extend = FALSE)

brks_singleton &lt;- brk_manual(
      c(1,    2,    2,     3),
      c(TRUE, TRUE, FALSE, TRUE))

chop(1:3, brks_singleton, extend = FALSE)

</code></pre>

<hr>
<h2 id='brk_width-for-datetime'>Equal-width intervals for dates or datetimes</h2><span id='topic+brk_width-for-datetime'></span><span id='topic+brk_width.Duration'></span>

<h3>Description</h3>

<p><code>brk_width()</code> can be used with time interval classes from base R or the
<code>lubridate</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Duration'
brk_width(width, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brk_width-for-datetime_+3A_width">width</code></td>
<td>
<p>A scalar <a href="base.html#topic+difftime">difftime</a>, <a href="lubridate.html#topic+Period-class">Period</a> or
<a href="lubridate.html#topic+Duration-class">Duration</a> object.</p>
</td></tr>
<tr><td><code id="brk_width-for-datetime_+3A_start">start</code></td>
<td>
<p>A scalar of class <a href="base.html#topic+Date">Date</a> or <a href="base.html#topic+DateTimeClasses">POSIXct</a>.
Can be omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>width</code> is a Period, <code><a href="lubridate.html#topic+mplus">lubridate::add_with_rollback()</a></code>
is used to calculate the widths. This can be useful for e.g. calendar months.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("lubridate")) {
  year2001 &lt;- as.Date("2001-01-01") + 0:364
  tab_width(year2001, months(1),
        labels = lbl_discrete(" to ", fmt = "%e %b %y"))
}

</code></pre>

<hr>
<h2 id='chop'>Cut data into intervals</h2><span id='topic+chop'></span><span id='topic+kiru'></span><span id='topic+tab'></span>

<h3>Description</h3>

<p><code>chop()</code> cuts <code>x</code> into intervals. It returns a <code><a href="base.html#topic+factor">factor</a></code> of the same length as
<code>x</code>, representing which interval contains each element of <code>x</code>.
<code>kiru()</code> is an alias for <code>chop</code>.
<code>tab()</code> calls <code>chop()</code> and returns a contingency <code><a href="base.html#topic+table">table()</a></code> from the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)

kiru(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)

tab(
  x,
  breaks,
  labels = lbl_intervals(),
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of cut-points or a function to create
cut-points from <code>x</code>.</p>
</td></tr>
<tr><td><code id="chop_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels or a function to create labels.</p>
</td></tr>
<tr><td><code id="chop_+3A_extend">extend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, always extend breaks to <code style="white-space: pre;">&#8288;+/-Inf&#8288;</code>. If <code>NULL</code>,
extend breaks to <code>min(x)</code> and/or <code>max(x)</code> only if necessary. If <code>NULL</code>, never
extend.</p>
</td></tr>
<tr><td><code id="chop_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
<tr><td><code id="chop_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
<tr><td><code id="chop_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
<tr><td><code id="chop_+3A_drop">drop</code></td>
<td>
<p>Logical. Drop unused levels from the result?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> may be a numeric vector, or more generally, any vector which can be
compared with <code>&lt;</code> and <code>==</code> (see <a href="base.html#topic+groupGeneric">Ops</a>). In particular <a href="base.html#topic+Date">Date</a>
and <a href="base.html#topic+DateTimeClasses">date-time</a> objects are supported. Character vectors
are supported with a warning.
</p>


<h4>Breaks</h4>

<p><code>breaks</code> may be a vector or a function.
</p>
<p>If it is a vector, <code>breaks</code> gives the break endpoints. Repeated values create
singleton intervals. For example <code>breaks = c(1, 3, 3, 5)</code> creates 3
intervals: <code>[1, 3)</code>, <code>{3}</code> and <code>(3, 5]</code>.
</p>
<p>If <code>breaks</code> is a function, it is called with the <code>x</code>, <code>extend</code>, <code>left</code> and
<code>close_end</code> arguments, and should return an object of class <code>breaks</code>.
Use <code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions to create a variety of data-dependent breaks.
</p>
<p>Names of <code>breaks</code> may be used for labels. See &quot;Labels&quot; below.
</p>



<h4>Options for breaks</h4>

<p>By default, left-closed intervals are created. If <code>left</code> is <code>FALSE</code>,
right-closed intervals are created.
</p>
<p>If <code>close_end</code> is <code>TRUE</code> the final break (or first break if <code>left</code> is <code>FALSE</code>)
will be closed at both ends. This guarantees that all values <code>x</code> with
<code style="white-space: pre;">&#8288;min(breaks) &lt;= x &lt;= max(breaks)&#8288;</code> are included in the intervals.
</p>
<p>Before version 0.9.0, <code>close_end</code> was <code>FALSE</code> by default, and also behaved
differently with respect to extended breaks: see &quot;Extending intervals&quot; below.
</p>
<p>Using <a href="#topic+lbl_intervals">mathematical set notation</a>:
</p>

<ul>
<li><p> If <code>left</code> is <code>TRUE</code> and <code>close_end</code> is <code>TRUE</code>, breaks will look like
<code>[b1, b2), [b2, b3) ... [b_n-1, b_n]</code>.
</p>
</li>
<li><p> If <code>left</code> is <code>FALSE</code> and <code>close_end</code> is <code>TRUE</code>, breaks will look like
<code>[b1, b2], (b2, b3] ... (b_n-1, b_n]</code>.
</p>
</li>
<li><p> If <code>left</code> is <code>TRUE</code> and <code>close_end</code> is <code>FALSE</code>, all breaks will look like
<code>...[b1, b2) ...</code>.
</p>
</li>
<li><p> If <code>left</code> is <code>FALSE</code> and <code>close_end</code> is <code>FALSE</code>, all breaks will look like
<code>...(b1, b2] ...</code>.
</p>
</li></ul>




<h4>Extending intervals</h4>

<p>If <code>extend</code> is <code>TRUE</code>, intervals will be extended to <code>[-Inf,
min(breaks))</code> and <code>(max(breaks), Inf]</code>.
</p>
<p>If <code>extend</code> is <code>NULL</code> (the default), intervals will be extended to
<code>[min(x), min(breaks))</code> and <code>(max(breaks), max(x)]</code>, <em>only</em> if
necessary &ndash; i.e. if elements of <code>x</code> would be below or above the unextended
breaks.
</p>
<p><code>close_end</code> is applied after breaks are extended, i.e. always to the very last
or very first break. This is a change from
previous behaviour. Up to version 0.8.0, <code>close_end</code> was applied to the
user-specified intervals, then <code>extend</code> was applied. Note that
if breaks are extended, then the extended break is always closed anyway.
</p>



<h4>Labels</h4>

<p><code>labels</code> may be a character vector. It should have the same length as the
(possibly extended) number of intervals. Alternatively, <code>labels</code> may be a
<code style="white-space: pre;">&#8288;lbl_*&#8288;</code> function such as <code><a href="#topic+lbl_seq">lbl_seq()</a></code>.
</p>
<p>If <code>breaks</code> is a named vector, then non-zero-length names of <code>breaks</code> will be
used as labels for the interval starting at the corresponding element. This
overrides the <code>labels</code> argument (but unnamed breaks will still use <code>labels</code>).
This feature is <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>.
</p>
<p>If <code>labels</code> is <code>NULL</code>, then integer codes will be returned instead of a
factor.
</p>
<p>If <code>raw</code> is <code>TRUE</code>, labels will show the actual numbers calculated by breaks.
If <code>raw</code> is <code>FALSE</code> then labels may show other objects, such
as quantiles for <code><a href="#topic+chop_quantiles">chop_quantiles()</a></code> and friends, proportions of the range for
<code><a href="#topic+chop_proportions">chop_proportions()</a></code>, or standard deviations for <code><a href="#topic+chop_mean_sd">chop_mean_sd()</a></code>.
</p>
<p>If <code>raw</code> is <code>NULL</code> then <code style="white-space: pre;">&#8288;lbl_*&#8288;</code> functions will use their default (usually
<code>FALSE</code>). Otherwise, <code>raw</code> argument to <code>chop()</code> overrides <code>raw</code> arguments
passed into <code style="white-space: pre;">&#8288;lbl_*&#8288;</code> functions directly.
</p>



<h4>Miscellaneous</h4>

<p><code>NA</code> values in <code>x</code>, and values which are outside the extended endpoints,
return <code>NA</code>.
</p>
<p><code>kiru()</code> is a synonym for <code>chop()</code>. If you load <code>{tidyr}</code>, you can use it to
avoid confusion with <code>tidyr::chop()</code>.
</p>
<p>Note that <code>chop()</code>, like all of R, uses binary arithmetic. Thus, numbers may
not be exactly equal to what you think they should be. There is an example
below.
</p>



<h3>Value</h3>

<p><code>chop()</code> returns a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>, representing the
intervals containing the value of <code>x</code>.
</p>
<p><code>tab()</code> returns a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">base::cut()</a></code>, <code><a href="#topic+non-standard-types">non-standard-types</a></code> for chopping objects that
aren't numbers.
</p>
<p>Other chopping functions: 
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chop(1:7, c(2, 4, 6))

chop(1:7, c(2, 4, 6), extend = FALSE)

# Repeat a number for a singleton break:
chop(1:7, c(2, 4, 4, 6))

chop(1:7, c(2, 4, 6), left = FALSE)

chop(1:7, c(2, 4, 6), close_end = FALSE)

chop(1:7, brk_quantiles(c(0.25, 0.75)))

# A single break is fine if `extend` is not `FALSE`:
chop(1:7, 4)

# Floating point inaccuracy:
chop(0.3/3, c(0, 0.1, 0.1, 1), labels = c("&lt; 0.1", "0.1", "&gt; 0.1"))

# -- Labels --

chop(1:7, c(Lowest = 1, Low = 2, Mid = 4, High = 6))

chop(1:7, c(2, 4, 6), labels = c("Lowest", "Low", "Mid", "High"))

chop(1:7, c(2, 4, 6), labels = lbl_dash())

# Mixing names and other labels:
chop(1:7, c("&lt;2" = 1, 2, 4, "&gt;=6" = 6), labels = lbl_dash())

# -- Non-standard types --

chop(as.Date("2001-01-01") + 1:7, as.Date("2001-01-04"))

suppressWarnings(chop(LETTERS[1:7], "D"))


tab(1:10, c(2, 5, 8))

</code></pre>

<hr>
<h2 id='chop_equally'>Chop equal-sized groups</h2><span id='topic+chop_equally'></span><span id='topic+brk_equally'></span><span id='topic+tab_equally'></span>

<h3>Description</h3>

<p><code>chop_equally()</code> chops <code>x</code> into groups with an equal number of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_equally(
  x,
  groups,
  ...,
  labels = lbl_intervals(),
  left = is.numeric(x),
  close_end = TRUE,
  raw = TRUE
)

brk_equally(groups)

tab_equally(x, groups, ..., left = is.numeric(x), raw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_equally_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_groups">groups</code></td>
<td>
<p>Number of groups.</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels or a function to create labels.</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
<tr><td><code id="chop_equally_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chop_equally()</code> uses <code><a href="#topic+brk_quantiles">brk_quantiles()</a></code> under the hood. If <code>x</code> has duplicate
elements, you may get fewer <code>groups</code> than requested. If so, a warning will
be emitted. See the examples.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_equally(1:10, 5)

# You can't always guarantee `groups` groups:
dupes &lt;- c(1, 1, 1, 2, 3, 4, 4, 4)
quantile(dupes, 0:4/4)
chop_equally(dupes, 4)
</code></pre>

<hr>
<h2 id='chop_evenly'>Chop into equal-width intervals</h2><span id='topic+chop_evenly'></span><span id='topic+brk_evenly'></span><span id='topic+tab_evenly'></span>

<h3>Description</h3>

<p><code>chop_evenly()</code> chops <code>x</code> into <code>intervals</code> intervals of equal width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_evenly(x, intervals, ..., close_end = TRUE)

brk_evenly(intervals)

tab_evenly(x, intervals, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_evenly_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_evenly_+3A_intervals">intervals</code></td>
<td>
<p>Integer: number of intervals to create.</p>
</td></tr>
<tr><td><code id="chop_evenly_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_evenly_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chop_evenly()</code> sets <code>close_end = TRUE</code> by default.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_evenly(0:10, 5)

</code></pre>

<hr>
<h2 id='chop_fn'>Chop using an existing function</h2><span id='topic+chop_fn'></span><span id='topic+brk_fn'></span><span id='topic+tab_fn'></span>

<h3>Description</h3>

<p><code>chop_fn()</code> is a convenience wrapper: <code>chop_fn(x, foo, ...)</code>
is the same as <code>chop(x, foo(x, ...))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_fn(
  x,
  fn,
  ...,
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)

brk_fn(fn, ...)

tab_fn(
  x,
  fn,
  ...,
  extend = NULL,
  left = TRUE,
  close_end = TRUE,
  raw = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_fn_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_fn">fn</code></td>
<td>
<p>A function which returns a numeric vector of breaks.</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>fn</code></p>
</td></tr>
<tr><td><code id="chop_fn_+3A_extend">extend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, always extend breaks to <code style="white-space: pre;">&#8288;+/-Inf&#8288;</code>. If <code>NULL</code>,
extend breaks to <code>min(x)</code> and/or <code>max(x)</code> only if necessary. If <code>NULL</code>, never
extend.</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
<tr><td><code id="chop_fn_+3A_drop">drop</code></td>
<td>
<p>Logical. Drop unused levels from the result?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("scales")) {
  chop_fn(rlnorm(10), scales::breaks_log(5))
  # same as
  # x &lt;- rlnorm(10)
  # chop(x, scales::breaks_log(5)(x))
}

</code></pre>

<hr>
<h2 id='chop_mean_sd'>Chop by standard deviations</h2><span id='topic+chop_mean_sd'></span><span id='topic+brk_mean_sd'></span><span id='topic+tab_mean_sd'></span>

<h3>Description</h3>

<p>Intervals are measured in standard deviations on either side of the
mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_mean_sd(x, sds = 1:3, ..., raw = FALSE, sd = deprecated())

brk_mean_sd(sds = 1:3, sd = deprecated())

tab_mean_sd(x, sds = 1:3, ..., raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_mean_sd_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_mean_sd_+3A_sds">sds</code></td>
<td>
<p>Positive numeric vector of standard deviations.</p>
</td></tr>
<tr><td><code id="chop_mean_sd_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_mean_sd_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
<tr><td><code id="chop_mean_sd_+3A_sd">sd</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In version 0.7.0, these functions changed to specifying <code>sds</code> as a vector.
To chop 1, 2 and 3 standard deviations around the mean, write
<code>chop_mean_sd(x, sds = 1:3)</code> instead of <code>chop_mean_sd(x, sd = 3)</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_mean_sd(1:10)

chop(1:10, brk_mean_sd())

tab_mean_sd(1:10)

</code></pre>

<hr>
<h2 id='chop_n'>Chop into fixed-sized groups</h2><span id='topic+chop_n'></span><span id='topic+brk_n'></span><span id='topic+tab_n'></span>

<h3>Description</h3>

<p><code>chop_n()</code> creates intervals containing a fixed number of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_n(x, n, ..., close_end = TRUE, tail = "split")

brk_n(n, tail = "split")

tab_n(x, n, ..., tail = "split")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_n_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_n_+3A_n">n</code></td>
<td>
<p>Integer. Number of elements in each interval.</p>
</td></tr>
<tr><td><code id="chop_n_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_n_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
<tr><td><code id="chop_n_+3A_tail">tail</code></td>
<td>
<p>String. What to do if the final interval has fewer than <code>n</code> elements?
<code>"split"</code> to keep it separate. <code>"merge"</code> to merge it with the neighbouring
interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm guarantees that intervals contain no more than <code>n</code> elements, so
long as there are no duplicates in <code>x</code> and <code>tail = "split"</code>. It also
guarantees that intervals contain no fewer than <code>n</code> elements, except possibly
the last interval (or first interval if <code>left</code> is <code>FALSE</code>).
</p>
<p>To ensure that all intervals contain at least <code>n</code> elements (so long as there
are at least <code>n</code> elements in <code>x</code>!) set <code>tail = "merge"</code>.
</p>
<p>If <code>tail = "split"</code> and there are intervals containing duplicates with more
than <code>n</code> elements, a warning is given.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_n(1:10, 5)

chop_n(1:5, 2)
chop_n(1:5, 2, tail = "merge")

# too many duplicates
x &lt;- rep(1:2, each = 3)
chop_n(x, 2)

tab_n(1:10, 5)

# fewer elements in one group
tab_n(1:10, 4)

</code></pre>

<hr>
<h2 id='chop_pretty'>Chop using pretty breakpoints</h2><span id='topic+chop_pretty'></span><span id='topic+brk_pretty'></span><span id='topic+tab_pretty'></span>

<h3>Description</h3>

<p><code>chop_pretty()</code> uses <code><a href="base.html#topic+pretty">base::pretty()</a></code> to calculate breakpoints
which are 1, 2 or 5 times a power of 10. These look nice in graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_pretty(x, n = 5, ...)

brk_pretty(n = 5, ...)

tab_pretty(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_pretty_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_pretty_+3A_n">n</code></td>
<td>
<p>Positive integer passed to <code><a href="base.html#topic+pretty">base::pretty()</a></code>. How many intervals to chop into?</p>
</td></tr>
<tr><td><code id="chop_pretty_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code> by <code>chop_pretty()</code> and <code>tab_pretty()</code>; passed
to <code><a href="base.html#topic+pretty">base::pretty()</a></code> by <code>brk_pretty()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+pretty">base::pretty()</a></code> tries to return <code>n+1</code> breakpoints, i.e. <code>n</code> intervals, but
note that this is not guaranteed. There are methods for Date and POSIXct
objects.
</p>
<p>For fine-grained control over <code><a href="base.html#topic+pretty">base::pretty()</a></code> parameters, use
<code>chop(x, brk_pretty(...))</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_pretty(1:10)

chop(1:10, brk_pretty(n = 5, high.u.bias = 0))

tab_pretty(1:10)

</code></pre>

<hr>
<h2 id='chop_proportions'>Chop into proportions of the range of x</h2><span id='topic+chop_proportions'></span><span id='topic+brk_proportions'></span><span id='topic+tab_proportions'></span>

<h3>Description</h3>

<p><code>chop_proportions()</code> chops <code>x</code> into <code>proportions</code> of its range, excluding
infinite values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_proportions(x, proportions, ..., raw = TRUE)

brk_proportions(proportions)

tab_proportions(x, proportions, ..., raw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_proportions_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_proportions_+3A_proportions">proportions</code></td>
<td>
<p>Numeric vector between 0 and 1: proportions of x's range.
If <code>proportions</code> has names, these will be used for labels.</p>
</td></tr>
<tr><td><code id="chop_proportions_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_proportions_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, labels show the raw numeric endpoints. To label intervals by
the proportions, use <code>raw = FALSE</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_proportions(0:10, c(0.2, 0.8))
chop_proportions(0:10, c(Low = 0, Mid = 0.2, High = 0.8))

</code></pre>

<hr>
<h2 id='chop_quantiles'>Chop by quantiles</h2><span id='topic+chop_quantiles'></span><span id='topic+chop_deciles'></span><span id='topic+brk_quantiles'></span><span id='topic+tab_quantiles'></span><span id='topic+tab_deciles'></span>

<h3>Description</h3>

<p><code>chop_quantiles()</code> chops data by quantiles.
<code>chop_deciles()</code> is a convenience function which chops into deciles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_quantiles(
  x,
  probs,
  ...,
  left = is.numeric(x),
  raw = FALSE,
  weights = NULL
)

chop_deciles(x, ...)

brk_quantiles(probs, ..., weights = NULL)

tab_quantiles(x, probs, ..., left = is.numeric(x), raw = FALSE)

tab_deciles(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_quantiles_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_quantiles_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities for the quantiles. If <code>probs</code> has
names, these will be used for labels.</p>
</td></tr>
<tr><td><code id="chop_quantiles_+3A_...">...</code></td>
<td>
<p>For <code>chop_quantiles</code>, passed to <code><a href="#topic+chop">chop()</a></code>. For <code>brk_quantiles()</code>,
passed to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code> or <code><a href="Hmisc.html#topic+wtd.stats">Hmisc::wtd.quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_quantiles_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
<tr><td><code id="chop_quantiles_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
<tr><td><code id="chop_quantiles_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> or numeric vector of same length as <code>x</code>. If not
<code>NULL</code>, <code><a href="Hmisc.html#topic+wtd.stats">Hmisc::wtd.quantile()</a></code> is used to calculate weighted quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-numeric <code>x</code>, <code>left</code> is set to <code>FALSE</code> by default. This works better
for calculating &quot;type 1&quot; quantiles, since they round down. See
<code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
</p>
<p>If <code>x</code> contains duplicates, consecutive quantiles may be the same number
so that some intervals get merged.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_quantiles(1:10, 1:3/4)

chop_quantiles(1:10, c(Q1 = 0, Q2 = 0.25, Q3 = 0.5, Q4 = 0.75))

chop(1:10, brk_quantiles(1:3/4))

chop_deciles(1:10)

# to label by the quantiles themselves:
chop_quantiles(1:10, 1:3/4, raw = TRUE)

# duplicates:
tab_quantiles(c(1, 1, 1, 2, 3), 1:5/5)

set.seed(42)
tab_quantiles(rnorm(100), probs = 1:3/4, raw = TRUE)

</code></pre>

<hr>
<h2 id='chop_width'>Chop into fixed-width intervals</h2><span id='topic+chop_width'></span><span id='topic+brk_width'></span><span id='topic+brk_width.default'></span><span id='topic+tab_width'></span>

<h3>Description</h3>

<p><code>chop_width()</code> chops <code>x</code> into intervals of fixed <code>width</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop_width(x, width, start, ..., left = sign(width) &gt; 0)

brk_width(width, start)

## Default S3 method:
brk_width(width, start)

tab_width(x, width, start, ..., left = sign(width) &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chop_width_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="chop_width_+3A_width">width</code></td>
<td>
<p>Width of intervals.</p>
</td></tr>
<tr><td><code id="chop_width_+3A_start">start</code></td>
<td>
<p>Starting point for intervals. By default the smallest
finite <code>x</code> (largest if <code>width</code> is negative).</p>
</td></tr>
<tr><td><code id="chop_width_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+chop">chop()</a></code>.</p>
</td></tr>
<tr><td><code id="chop_width_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>width</code> is negative, <code>chop_width()</code> sets <code>left = FALSE</code> and intervals will
go downwards from <code>start</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;chop_*&#8288;</code> functions return a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>.
</p>
<p><code style="white-space: pre;">&#8288;brk_*&#8288;</code> functions return a <code><a href="base.html#topic+function">function</a></code> to create <code>breaks</code>.
</p>
<p><code style="white-space: pre;">&#8288;tab_*&#8288;</code> functions return a contingency <code><a href="base.html#topic+table">table()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+brk_width-for-datetime">brk_width-for-datetime</a>
</p>
<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+fillet">fillet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop_width(1:10, 2)

chop_width(1:10, 2, start = 0)

chop_width(1:9, -2)

chop(1:10, brk_width(2, 0))

tab_width(1:10, 2, start = 0)

</code></pre>

<hr>
<h2 id='exactly'>Define singleton intervals explicitly</h2><span id='topic+exactly'></span>

<h3>Description</h3>

<p><code>exactly()</code> duplicates its input.
It lets you define singleton intervals like this: <code>chop(x, c(1, exactly(2), 3))</code>.
This is the same as <code>chop(x, c(1, 2, 2, 3))</code> but conveys your intent more
clearly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exactly_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as <code>rep(x, each = 2)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop(1:10, c(2, exactly(5), 8))

# same:
chop(1:10, c(2, 5, 5, 8))
</code></pre>

<hr>
<h2 id='fillet'>Chop data precisely (for programmers)</h2><span id='topic+fillet'></span>

<h3>Description</h3>

<p><code>fillet()</code> calls <code><a href="#topic+chop">chop()</a></code> with <code>extend = FALSE</code> and <code>drop = FALSE</code>. This
ensures that you get only the <code>breaks</code> and <code>labels</code> you ask for. When
programming, consider using <code>fillet()</code> instead of <code>chop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillet(
  x,
  breaks,
  labels = lbl_intervals(),
  left = TRUE,
  close_end = TRUE,
  raw = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillet_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="fillet_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of cut-points or a function to create
cut-points from <code>x</code>.</p>
</td></tr>
<tr><td><code id="fillet_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels or a function to create labels.</p>
</td></tr>
<tr><td><code id="fillet_+3A_left">left</code></td>
<td>
<p>Logical. Left-closed or right-closed breaks?</p>
</td></tr>
<tr><td><code id="fillet_+3A_close_end">close_end</code></td>
<td>
<p>Logical. Close last break at right? (If <code>left</code> is <code>FALSE</code>,
close first break at left?)</p>
</td></tr>
<tr><td><code id="fillet_+3A_raw">raw</code></td>
<td>
<p>Logical. Use raw values in labels?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fillet()</code> returns a <code><a href="base.html#topic+factor">factor</a></code> of the same length as <code>x</code>, representing
the intervals containing the value of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other chopping functions: 
<code><a href="#topic+chop">chop</a>()</code>,
<code><a href="#topic+chop_equally">chop_equally</a>()</code>,
<code><a href="#topic+chop_evenly">chop_evenly</a>()</code>,
<code><a href="#topic+chop_fn">chop_fn</a>()</code>,
<code><a href="#topic+chop_mean_sd">chop_mean_sd</a>()</code>,
<code><a href="#topic+chop_n">chop_n</a>()</code>,
<code><a href="#topic+chop_proportions">chop_proportions</a>()</code>,
<code><a href="#topic+chop_quantiles">chop_quantiles</a>()</code>,
<code><a href="#topic+chop_width">chop_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fillet(1:10, c(2, 5, 8))
</code></pre>

<hr>
<h2 id='lbl_dash'>Label chopped intervals like 1-4, 4-5, ...</h2><span id='topic+lbl_dash'></span>

<h3>Description</h3>

<p>This label style is user-friendly, but doesn't distinguish between
left- and right-closed intervals. It's good for continuous data
where you don't expect points to be exactly on the breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_dash(
  symbol = em_dash(),
  fmt = NULL,
  single = "{l}",
  first = NULL,
  last = NULL,
  raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_dash_+3A_symbol">symbol</code></td>
<td>
<p>String: symbol to use for the dash.</p>
</td></tr>
<tr><td><code id="lbl_dash_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_dash_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_dash_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_dash_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_dash_+3A_raw">raw</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use the <code>raw</code> argument to <code><a href="#topic+chop">chop()</a></code>
instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you don't want unicode output, use <code>lbl_dash("-")</code>.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop(1:10, c(2, 5, 8), lbl_dash())

chop(1:10, c(2, 5, 8), lbl_dash(" to ", fmt = "%.1f"))

chop(1:10, c(2, 5, 8), lbl_dash(first = "&lt;{r}"))

pretty &lt;- function (x) prettyNum(x, big.mark = ",", digits = 1)
chop(runif(10) * 10000, c(3000, 7000), lbl_dash(" to ", fmt = pretty))
</code></pre>

<hr>
<h2 id='lbl_discrete'>Label discrete data</h2><span id='topic+lbl_discrete'></span>

<h3>Description</h3>

<p><code>lbl_discrete()</code> creates labels for discrete data, such as integers.
For example, breaks
<code>c(1, 3, 4, 6, 7)</code> are labelled: <code style="white-space: pre;">&#8288;"1-2", "3", "4-5", "6-7"&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_discrete(
  symbol = em_dash(),
  unit = 1,
  fmt = NULL,
  single = NULL,
  first = NULL,
  last = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_discrete_+3A_symbol">symbol</code></td>
<td>
<p>String: symbol to use for the dash.</p>
</td></tr>
<tr><td><code id="lbl_discrete_+3A_unit">unit</code></td>
<td>
<p>Minimum difference between distinct values of data.
For integers, 1.</p>
</td></tr>
<tr><td><code id="lbl_discrete_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_discrete_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_discrete_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_discrete_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No check is done that the data are discrete-valued. If they are not, then
these labels may be misleading. Here, discrete-valued means that if
<code>x &lt; y</code>, then <code>x &lt;= y - unit</code>.
</p>
<p>Be aware that Date objects may have non-integer values. See <a href="base.html#topic+Date">Date</a>.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab(1:7, c(1, 3, 5), lbl_discrete())

tab(1:7, c(3, 5), lbl_discrete(first = "&lt;= {r}"))

tab(1:7 * 1000, c(1, 3, 5) * 1000, lbl_discrete(unit = 1000))

# Misleading labels for non-integer data
chop(2.5, c(1, 3, 5), lbl_discrete())

</code></pre>

<hr>
<h2 id='lbl_endpoints'>Label chopped intervals by their left or right endpoints</h2><span id='topic+lbl_endpoints'></span><span id='topic+lbl_endpoint'></span>

<h3>Description</h3>

<p>This is useful when the left endpoint unambiguously indicates the
interval. In other cases it may give errors due to duplicate labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_endpoints(
  left = TRUE,
  fmt = NULL,
  single = NULL,
  first = NULL,
  last = NULL,
  raw = FALSE
)

lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_endpoints_+3A_left">left</code></td>
<td>
<p>Flag. Use left endpoint or right endpoint?</p>
</td></tr>
<tr><td><code id="lbl_endpoints_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_endpoints_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_endpoints_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_endpoints_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_endpoints_+3A_raw">raw</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use the <code>raw</code> argument to <code><a href="#topic+chop">chop()</a></code>
instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lbl_endpoint()</code> is <a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a> and gives an
error since santoku 1.0.0.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop(1:10, c(2, 5, 8), lbl_endpoints(left = TRUE))
chop(1:10, c(2, 5, 8), lbl_endpoints(left = FALSE))
if (requireNamespace("lubridate")) {
  tab_width(
          as.Date("2000-01-01") + 0:365,
         months(1),
         labels = lbl_endpoints(fmt = "%b")
       )
}

## Not run: 
  # This gives breaks `[1, 2) [2, 3) {3}` which lead to
  # duplicate labels `"2", "3", "3"`:
  chop(1:3, 1:3, lbl_endpoints(left = FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='lbl_glue'>Label chopped intervals using the <code>glue</code> package</h2><span id='topic+lbl_glue'></span>

<h3>Description</h3>

<p>Use <code>"{l}"</code> and <code>"{r}"</code> to show the left and right endpoints of the intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_glue(
  label,
  fmt = NULL,
  single = NULL,
  first = NULL,
  last = NULL,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_glue_+3A_label">label</code></td>
<td>
<p>A glue string passed to <code><a href="glue.html#topic+glue">glue::glue()</a></code>.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_raw">raw</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use the <code>raw</code> argument to <code><a href="#topic+chop">chop()</a></code>
instead.</p>
</td></tr>
<tr><td><code id="lbl_glue_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="glue.html#topic+glue">glue::glue()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following variables are available in the glue string:
</p>

<ul>
<li> <p><code>l</code> is a character vector of left endpoints of intervals.
</p>
</li>
<li> <p><code>r</code> is a character vector of right endpoints of intervals.
</p>
</li>
<li> <p><code>l_closed</code> is a logical vector. Elements are <code>TRUE</code> when the left
endpoint is closed.
</p>
</li>
<li> <p><code>r_closed</code> is a logical vector, <code>TRUE</code> when the right endpoint is closed.
</p>
</li></ul>

<p>Endpoints will be formatted by <code>fmt</code> before being passed to <code>glue()</code>.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab(1:10, c(1, 3, 3, 7),
    labels = lbl_glue("{l} to {r}", single = "Exactly {l}"))

tab(1:10 * 1000, c(1, 3, 5, 7) * 1000,
    labels = lbl_glue("{l}-{r}",
                      fmt = function(x) prettyNum(x, big.mark=',')))

# reproducing lbl_intervals():
interval_left &lt;- "{ifelse(l_closed, '[', '(')}"
interval_right &lt;- "{ifelse(r_closed, ']', ')')}"
glue_string &lt;- paste0(interval_left, "{l}", ", ", "{r}", interval_right)
tab(1:10, c(1, 3, 3, 7), labels = lbl_glue(glue_string, single = "{{{l}}}"))

</code></pre>

<hr>
<h2 id='lbl_intervals'>Label chopped intervals using set notation</h2><span id='topic+lbl_intervals'></span>

<h3>Description</h3>

<p>These labels are the most exact, since they show you whether
intervals are &quot;closed&quot; or &quot;open&quot;, i.e. whether they include their endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_intervals(
  fmt = NULL,
  single = "{{{l}}}",
  first = NULL,
  last = NULL,
  raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_intervals_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_intervals_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_intervals_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_intervals_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_intervals_+3A_raw">raw</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use the <code>raw</code> argument to <code><a href="#topic+chop">chop()</a></code>
instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematical set notation looks like this:
</p>

<ul>
<li> <p><code>[a, b]</code>: all numbers <code>x</code> where <code style="white-space: pre;">&#8288;a &lt;= x &lt;= b&#8288;</code>;
</p>
</li>
<li> <p><code>(a, b)</code>: all numbers where <code style="white-space: pre;">&#8288;a &lt; x &lt; b&#8288;</code>;
</p>
</li>
<li> <p><code>[a, b)</code>: all numbers where <code style="white-space: pre;">&#8288;a &lt;= x &lt; b&#8288;</code>;
</p>
</li>
<li> <p><code>(a, b]</code>: all numbers where <code style="white-space: pre;">&#8288;a &lt; x &lt;= b&#8288;</code>;
</p>
</li>
<li> <p><code>{a}</code>: just the number <code>a</code> exactly.
</p>
</li></ul>



<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tab(-10:10, c(-3, 0, 0, 3),
      labels = lbl_intervals())

tab(-10:10, c(-3, 0, 0, 3),
      labels = lbl_intervals(fmt = list(nsmall = 1)))

tab_evenly(runif(20), 10,
      labels = lbl_intervals(fmt = percent))

</code></pre>

<hr>
<h2 id='lbl_manual'>Defunct: label chopped intervals in a user-defined sequence</h2><span id='topic+lbl_manual'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_manual(sequence, fmt = "%s")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_manual_+3A_sequence">sequence</code></td>
<td>
<p>A character vector of labels.</p>
</td></tr>
<tr><td><code id="lbl_manual_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lbl_manual()</code> is defunct since santoku 1.0.0. It is little used and is not
closely related to the rest of the package. It also risks mislabelling
intervals, e.g. if intervals are extended. Use of <code>lbl_manual()</code> will give
an error.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
chop(1:10, c(2, 5, 8), lbl_manual(c("w", "x", "y", "z")))
# -&gt;
chop(1:10, c(2, 5, 8), labels = c("w", "x", "y", "z"))

## End(Not run)
</code></pre>

<hr>
<h2 id='lbl_midpoints'>Label chopped intervals by their midpoints</h2><span id='topic+lbl_midpoints'></span>

<h3>Description</h3>

<p>This uses the midpoint of each interval for
its label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_midpoints(
  fmt = NULL,
  single = NULL,
  first = NULL,
  last = NULL,
  raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_midpoints_+3A_fmt">fmt</code></td>
<td>
<p>String, list or function. A format for break endpoints.</p>
</td></tr>
<tr><td><code id="lbl_midpoints_+3A_single">single</code></td>
<td>
<p>Glue string: label for singleton intervals. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_midpoints_+3A_first">first</code></td>
<td>
<p>Glue string: override label for the first category. Write e.g.
<code>first = "&lt;{r}"</code> to create a label like <code>"&lt;18"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_midpoints_+3A_last">last</code></td>
<td>
<p>String: override label for the last category. Write e.g.
<code>last = "&gt;{l}"</code> to create a label like <code>"&gt;65"</code>. See <code><a href="#topic+lbl_glue">lbl_glue()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="lbl_midpoints_+3A_raw">raw</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use the <code>raw</code> argument to <code><a href="#topic+chop">chop()</a></code>
instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>Formatting endpoints</h3>

<p>If <code>fmt</code> is not <code>NULL</code> then it is used to format the endpoints.
</p>

<ul>
<li><p> If <code>fmt</code> is a string, then numeric endpoints will be formatted by
<code>sprintf(fmt, breaks)</code>; other endpoints, e.g. <a href="base.html#topic+Date">Date</a> objects, will be
formatted by <code>format(breaks, fmt)</code>.
</p>
</li>
<li><p> If <code>fmt</code> is a list, then it will be used as arguments to <a href="base.html#topic+format">format</a>.
</p>
</li>
<li><p> If <code>fmt</code> is a function, it should take a vector of numbers (or other objects
that can be used as breaks) and return a character vector. It may be helpful
to use functions from the <code>{scales}</code> package, e.g. <code><a href="scales.html#topic+label_number">scales::label_comma()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_seq">lbl_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop(1:10, c(2, 5, 8), lbl_midpoints())
</code></pre>

<hr>
<h2 id='lbl_seq'>Label chopped intervals in sequence</h2><span id='topic+lbl_seq'></span>

<h3>Description</h3>

<p><code>lbl_seq()</code> labels intervals sequentially, using numbers or letters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbl_seq(start = "a")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbl_seq_+3A_start">start</code></td>
<td>
<p>String. A template for the sequence. See below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>start</code> shows the first element of the sequence. It must contain exactly <em>one</em>
character out of the set &quot;a&quot;, &quot;A&quot;, &quot;i&quot;, &quot;I&quot; or &quot;1&quot;. For later elements:
</p>

<ul>
<li><p> &quot;a&quot; will be replaced by &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...
</p>
</li>
<li><p> &quot;A&quot; will be replaced by &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, ...
</p>
</li>
<li><p> &quot;i&quot; will be replaced by lower-case Roman numerals &quot;i&quot;, &quot;ii&quot;, &quot;iii&quot;, ...
</p>
</li>
<li><p> &quot;I&quot; will be replaced by upper-case Roman numerals &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, ...
</p>
</li>
<li><p> &quot;1&quot; will be replaced by numbers &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...
</p>
</li></ul>

<p>Other characters will be retained as-is.
</p>


<h3>Value</h3>

<p>A function that creates a vector of labels.
</p>


<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+lbl_dash">lbl_dash</a>()</code>,
<code><a href="#topic+lbl_discrete">lbl_discrete</a>()</code>,
<code><a href="#topic+lbl_endpoints">lbl_endpoints</a>()</code>,
<code><a href="#topic+lbl_glue">lbl_glue</a>()</code>,
<code><a href="#topic+lbl_intervals">lbl_intervals</a>()</code>,
<code><a href="#topic+lbl_manual">lbl_manual</a>()</code>,
<code><a href="#topic+lbl_midpoints">lbl_midpoints</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chop(1:10, c(2, 5, 8), lbl_seq())

chop(1:10, c(2, 5, 8), lbl_seq("i."))

chop(1:10, c(2, 5, 8), lbl_seq("(A)"))
</code></pre>

<hr>
<h2 id='non-standard-types'>Tips for chopping non-standard types</h2><span id='topic+non-standard-types'></span>

<h3>Description</h3>

<p>Santoku can handle many non-standard types.
</p>


<h3>Details</h3>


<ul>
<li><p> If objects can be compared using <code>&lt;</code>, <code>==</code> etc. then they should
be choppable.
</p>
</li>
<li><p> Objects which can't be converted to numeric are handled within R code,
which may be slower.
</p>
</li>
<li><p> Character <code>x</code> and <code>breaks</code> are chopped with a warning.
</p>
</li>
<li><p> If <code>x</code> and <code>breaks</code> are not the same type, they should be able to
be cast to the same type, usually using <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast_common()</a></code>.
</p>
</li>
<li><p> Not all chopping operations make sense, for example, <code><a href="#topic+chop_mean_sd">chop_mean_sd()</a></code>
on a character vector.
</p>
</li>
<li><p> For indexed objects such as <code><a href="stats.html#topic+ts">stats::ts()</a></code> objects, indices will be dropped
from the result.
</p>
</li>
<li><p> If you get errors, try setting <code>extend = FALSE</code> (but also file a bug report).
</p>
</li>
<li><p> To request support for a type, open an issue on Github.
</p>
</li></ul>



<h3>See Also</h3>

<p>brk-width-for-Datetime
</p>

<hr>
<h2 id='percent'>Simple percentage formatter</h2><span id='topic+percent'></span>

<h3>Description</h3>

<p><code>percent()</code> formats <code>x</code> as a percentage.
For a wider range of formatters, consider the <a href="https://cran.r-project.org/package=scales"><code>scales</code> package</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="percent_+3A_x">x</code></td>
<td>
<p>Numeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> formatted as a percent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>percent(0.5)
</code></pre>

<hr>
<h2 id='santoku-cast'>Internal functions</h2><span id='topic+santoku-cast'></span><span id='topic+santoku_cast_common.default'></span><span id='topic+santoku_cast_common.double'></span><span id='topic+santoku_cast_common.Date'></span><span id='topic+santoku_cast_common.POSIXct'></span><span id='topic+santoku_cast_common.ts'></span><span id='topic+santoku_cast_common.zoo'></span><span id='topic+santoku_cast_common.integer64'></span><span id='topic+santoku_cast_common.hexmode'></span><span id='topic+santoku_cast_common.octmode'></span>

<h3>Description</h3>

<p>Internal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
santoku_cast_common(x, y)

## S3 method for class 'double'
santoku_cast_common(x, y)

## S3 method for class 'Date'
santoku_cast_common(x, y)

## S3 method for class 'POSIXct'
santoku_cast_common(x, y)

## S3 method for class 'ts'
santoku_cast_common(x, y)

## S3 method for class 'zoo'
santoku_cast_common(x, y)

## S3 method for class 'integer64'
santoku_cast_common(x, y)

## S3 method for class 'hexmode'
santoku_cast_common(x, y)

## S3 method for class 'octmode'
santoku_cast_common(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="santoku-cast_+3A_x">x</code>, <code id="santoku-cast_+3A_y">y</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
