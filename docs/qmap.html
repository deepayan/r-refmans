<!DOCTYPE html><html lang="en"><head><title>Help for package qmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qmap-package'>
<p>Statistical Transformations for Post-Processing Climate Model Output</p></a></li>
<li><a href='#bernexp'>
<p>The Bernoulli-Exponential distribution</p></a></li>
<li><a href='#berngamma'>
<p>The Bernoulli-Gamma distribution</p></a></li>
<li><a href='#bernlnorm'>
<p>The Bernoulli-Log-Normal distribution</p></a></li>
<li><a href='#bernweibull'>
<p>The Bernoulli-Weibull distribution</p></a></li>
<li><a href='#fitQmap'>
<p>Quantile mapping</p></a></li>
<li><a href='#fitQmapDIST'>
<p>Quantile mapping using distribution derived transformations</p></a></li>
<li><a href='#fitQmapPTF'>
<p>Quantile mapping using parametric transformations</p></a></li>
<li><a href='#fitQmapQUANT'>
<p>Non-parametric quantile mapping using empirical quantiles.</p></a></li>
<li><a href='#fitQmapRQUANT'>
<p>Non-parametric quantile mapping using robust empirical quantiles.</p></a></li>
<li><a href='#fitQmapSSPLIN'>
<p>Quantile mapping using a smoothing spline</p></a></li>
<li><a href='#obsprecip'><p>Daily precipitation data at three locations in Norway.</p></a></li>
<li><a href='#startbernexp'>
<p>Rough parameter estimate for the Bernoulli-Exponential distribution</p></a></li>
<li><a href='#startberngamma'>
<p>Rough parameter estimate for the Bernoulli-Gamma distribution</p></a></li>
<li><a href='#startbernlnorm'>
<p>Rough parameter estimate for the Bernoulli-Log-Normal distribution</p></a></li>
<li><a href='#startbernweibull'>
<p>Rough parameter estimate for the Bernoulli-Weibull distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Transformations for Post-Processing Climate Model
Output</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Gudmundsson &lt;lukas.gudmundsson@env.ethz.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.8.0), fitdistrplus</td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical adjustment of the distribution of variables originating from (regional) climate model simulations using quantile mapping.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-28 08:27:43 UTC; lukasgu</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Gudmundsson <a href="https://orcid.org/0000-0003-3539-8621"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-28 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qmap-package'>
Statistical Transformations for Post-Processing Climate Model Output
</h2><span id='topic+qmap-package'></span><span id='topic+qmap'></span>

<h3>Description</h3>

<p>Empirical adjustment (bias correction) of variables originating from
(regional) climate model simulations using quantile mapping. The 
workhorse functions of this package are <code><a href="#topic+fitQmap">fitQmap</a></code> and
<code><a href="#topic+doQmap">doQmap</a></code> which offer an easy to use interface to different
statistical transformations, also referred to as quantile mapping
methods.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qmap</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-05-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL &gt;= 2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Lukas Gudmundsson</p>


<h3>References</h3>

<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods. Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.  
</p>

<hr>
<h2 id='bernexp'>
The Bernoulli-Exponential distribution
</h2><span id='topic+bernexp'></span><span id='topic+dbernexp'></span><span id='topic+pbernexp'></span><span id='topic+qbernexp'></span><span id='topic+rbernexp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Bernoulli-Exponential distribution with parameters 
<code>prob</code>, and <code>rate</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernexp(x, prob, rate)
pbernexp(q, prob, rate)
qbernexp(p, prob, rate)
rbernexp(n, prob, rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bernexp_+3A_x">x</code>, <code id="bernexp_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="bernexp_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="bernexp_+3A_prob">prob</code></td>
<td>

<p>probability of non-zero event.
</p>
</td></tr>
<tr><td><code id="bernexp_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="bernexp_+3A_rate">rate</code></td>
<td>

<p>rate parameter of the Exponential distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture of the Bernoulli and the Exponential distribution. The mixture
is analogue to the one described for the <code><a href="#topic+berngamma">berngamma</a></code>
distribution.  
</p>


<h3>Value</h3>

<p><code>dbernexp</code> gives the density (pdf), <code>pbernexp</code> gives
the distribution function (cdf), <code>qbernexp</code> gives the
quantile function (inverse cdf), and <code>rbernexp</code> generates
random numbers.  
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Exponential">Exponential</a></code>, <code><a href="#topic+berngamma">berngamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)

(ts &lt;- startbernexp(obsprecip[,1]))
hist(obsprecip[,1],freq=FALSE) 
lines(seq(0,max(obsprecip[,1])),
      dbernexp(seq(0,max(obsprecip[,1])),
               prob=ts$prob,
               rate=ts$rate),
      col="red")

pp &lt;- seq(0.01,0.99,by=0.01)
qq &lt;-quantile(obsprecip[,1],probs=pp) 

plot(qq,pp)
lines(qbernexp(pp,
               prob=ts$prob,
               rate=ts$rate),
      pp,col="red")

plot(qq,pp)
lines(qq,
      pbernexp(qq,
               prob=ts$prob,
               rate=ts$rate),
      col="red")

hist(rbernexp(1000,prob=ts$prob,
              rate=ts$rate),freq=FALSE)

</code></pre>

<hr>
<h2 id='berngamma'>
The Bernoulli-Gamma distribution
</h2><span id='topic+berngamma'></span><span id='topic+dberngamma'></span><span id='topic+pberngamma'></span><span id='topic+qberngamma'></span><span id='topic+rberngamma'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Bernoulli-Gamma distribution with parameters
<code>prob</code>, <code>shape</code>,  and <code>scale</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dberngamma(x, prob, scale, shape)
pberngamma(q, prob, scale, shape)
qberngamma(p, prob, scale, shape)
rberngamma(n, prob, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="berngamma_+3A_x">x</code>, <code id="berngamma_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="berngamma_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="berngamma_+3A_prob">prob</code></td>
<td>

<p>probability of non-zero event.
</p>
</td></tr>
<tr><td><code id="berngamma_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="berngamma_+3A_scale">scale</code>, <code id="berngamma_+3A_shape">shape</code></td>
<td>

<p>shape and scale parameters of the gamma distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture of the Bernoulli and the Gamma distribution. The Bernoulli
distribution is used to model the occurrence of zero values with the
probability of <code>1-prob</code>. Non-zero values follow the Gamma
distribution with <code>shape</code> and <code>scale</code> parameters.
</p>
<p>The probability density function (PDF) is defined as:

</p>
<p style="text-align: center;"><code class="reqn">g(x) = \left\{
    \begin{array}{l l}
    \pi*\gamma(x) &amp; \quad \mbox{if } x &gt; 0 \\
    1- \pi &amp; \quad \mbox{if } x \leq 0    
    \end{array} \right.
  </code>
</p>


<p>where <code class="reqn">\gamma(x)</code> is the probability density function of
the gamma distribution and <code class="reqn">\pi</code> is probability of a non-zero
event. 
</p>
<p>The cumulative distribution function (CDF) is defined as:

</p>
<p style="text-align: center;"><code class="reqn">G(x) = \left\{
    \begin{array}{l l}
    1 - \pi + \pi*\Gamma(x) &amp; \quad \mbox{if } x &gt; 0 \\
    1 - \pi &amp; \quad \mbox{if } x \leq 0    
    \end{array} \right.
  </code>
</p>


<p>where <code class="reqn">\Gamma(x)</code> is the cumulative distribution
function of the gamma distribution.
</p>
<p>The quantile function (inverse of the CDF) is defined as

</p>
<p style="text-align: center;"><code class="reqn">G^{-1}(p) = \left\{
    \begin{array}{l l}
    \Gamma^{-1}\left(\frac{p-1+\pi}{\pi}\right) &amp; \quad \mbox{if } \pi &gt; 1-p \\
    0 &amp; \quad \mbox{if } p \leq 1-p    
    \end{array} \right.
  </code>
</p>


<p>where <code class="reqn">\Gamma^{-1}(p)</code> is the inverse CDF of the
gamma distribution and <code class="reqn">p</code> is a probability.  
</p>


<h3>Value</h3>

<p><code>dberngamma</code> gives the density (pdf), <code>pberngamma</code> gives
the distribution function (cdf), <code>qberngamma</code> gives the
quantile function (inverse cdf), and <code>rberngamma</code> generates
random deviates.  
</p>


<h3>Note</h3>

<p>The implementation is largely based on the <code>bgamma</code> family in
the <code>CaDENCE</code>-package (Cannon, 2012) that was only available as
test version at time of implementation (Mar. 2012). 
</p>
<p>For further details and meteorological application of Bernoulli-Gamma
distributions (also referred to as 'Mixed Gamma' distribution) see
Burger et al. 2012, Cannon 2008, Li et al. 2010, Mooley 1973,
Piani et al. 2010, Thom 1968, Sloughter et al. 2007.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Burger, G.; Murdock, T. Q.; Werner, A. T.; Sobie, S. R. &amp; Cannon,
A. J. Downscaling extremes - an intercomparison of multiple
statistical methods for present climate. Journal of
Climate, American Meteorological Society, early online release,
2012, &lt;doi:10.1175/JCLI-D-11-00408.1&gt;.
</p>
<p>Cannon, A. J. Probabilistic Multisite Precipitation Downscaling by an
Expanded Bernoulli-Gamma Density Network. Journal of
Hydrometeorology, American Meteorological Society, 2008, 9,
1284-1300, &lt;doi:10.1175/2008JHM960.1&gt;.
</p>
<p>Cannon, A. J. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation and
Evaluation (CaDENCE) in R. Computers &amp; Geosciences, 2012, 41, 126 -
135, &lt;doi:10.1016/j.cageo.2011.08.023&gt;.
</p>
<p>Li, H.; Sheffield, J. &amp; Wood, E. F. Bias correction of monthly
precipitation and temperature fields from Intergovernmental Panel on
Climate Change AR4 models using equidistant quantile matching.
J. Geophys. Res., AGU, 2010, 115, D10101, &lt;doi:10.1029/2009JD012882&gt;.
</p>
<p>Mooley, D. A. Gamma Distribution Probability Model for Asian Summer
Monsoon Monthly Rainfall. Monthly Weather Review, 1973, 101,
160-176, &lt;doi:10.1175/1520-0493(1973)101&lt;0160:GDPMFA&gt;2.3.CO;2&gt;.
</p>
<p>Piani, C.; Haerter, J. &amp; Coppola, E. Statistical bias correction for
daily precipitation in regional climate models over Europe. Theoretical
and Applied Climatology, 2010, 99,
187-192, &lt;doi:10.1007/s00704-009-0134-9&gt;.
</p>
<p>Thom, H. C. S. Approximate convolution of the gamma and mixed gamma
distributions. Monthly Weather Review, 1968, 96,
883-886, &lt;doi:10.1175/1520-0493(1968)096&lt;0883:ACOTGA&gt;2.0.CO;2&gt;.
</p>
<p>Sloughter, J. M. L.; Raftery, A. E.; Gneiting, T. &amp; Fraley,
C. Probabilistic Quantitative Precipitation Forecasting Using Bayesian
Model Averaging. Monthly Weather Review, 2007, 135,
3209-3220, &lt;doi:10.1175/MWR3441.1&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)

(ts &lt;- startberngamma(obsprecip[,1]))
hist(obsprecip[,1],freq=FALSE) 
lines(seq(0,20),dberngamma(0:20,
                           prob=ts$prob,
                           scale=ts$scale,
                           shape=ts$shape),
      col="red")

pp &lt;- seq(0.01,0.99,by=0.01)
qq &lt;-quantile(obsprecip[,1],probs=pp) 

plot(qq,pp)
lines(qberngamma(pp,
                 prob=ts$prob,
                 scale=ts$scale,
                 shape=ts$shape),
      pp,col="red")

plot(qq,pp)
lines(qq,
      pberngamma(qq,
                 prob=ts$prob,
                 scale=ts$scale,
                 shape=ts$shape),
      col="red")

hist(rberngamma(1000,
                prob=ts$prob,
                scale=ts$scale,
                shape=ts$shape),freq=FALSE)
</code></pre>

<hr>
<h2 id='bernlnorm'>
The Bernoulli-Log-Normal distribution
</h2><span id='topic+bernlnorm'></span><span id='topic+dbernlnorm'></span><span id='topic+pbernlnorm'></span><span id='topic+qbernlnorm'></span><span id='topic+rbernlnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Bernoulli-Log-Normal distribution with parameters
<code>prob</code>, <code>meanlog</code>,  and <code>sdlog</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernlnorm(x, prob, meanlog, sdlog)
pbernlnorm(q, prob, meanlog, sdlog)
qbernlnorm(p, prob, meanlog, sdlog)
rbernlnorm(n, prob, meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bernlnorm_+3A_x">x</code>, <code id="bernlnorm_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="bernlnorm_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="bernlnorm_+3A_prob">prob</code></td>
<td>

<p>probability of non-zero event.
</p>
</td></tr>
<tr><td><code id="bernlnorm_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="bernlnorm_+3A_meanlog">meanlog</code>, <code id="bernlnorm_+3A_sdlog">sdlog</code></td>
<td>

<p>meanlog and sdlog parameters of the Log-Normal distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture of Bernoulli and Log-Normal distribution. The mixture is analogue
to the one described for the <code><a href="#topic+berngamma">berngamma</a></code> distribution. 
</p>


<h3>Value</h3>

<p><code>dbernlnorm</code> gives the density (pdf), <code>pbernlnorm</code> gives
the distribution function (cdf), <code>qbernlnorm</code> gives the
quantile function (inverse cdf), and <code>rbernlnorm</code> generates
random deviates.  
</p>


<h3>Note</h3>

<p>The implementation is largely based on the <code>blnorm</code> family in
the <code>CaDENCE</code>-package (Cannon, 2012) that was only available as
test version at time of implementation (Mar. 2012). 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Cannon, A. J. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation and
Evaluation (CaDENCE) in R. Computers &amp; Geosciences, 2012, 41, 126 -
135, &lt;doi:10.1016/j.cageo.2011.08.023&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Lognormal">Lognormal</a></code>, <code><a href="#topic+berngamma">berngamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)

(ts &lt;- startbernlnorm(obsprecip[,1]))
hist(obsprecip[,1],freq=FALSE)
lines(seq(0,20),dbernlnorm(0:20,
                           prob=ts$prob,
                           meanlog=ts$meanlog,
                           sdlog=ts$sdlog),
      col="red")

pp &lt;- seq(0.01,0.99,by=0.01)
qq &lt;-quantile(obsprecip[,1],probs=pp) 

plot(qq,pp)
lines(qbernlnorm(pp,
                 prob=ts$prob,
                 meanlog=ts$meanlog,
                 sdlog=ts$sdlog),
      pp,col="red")

plot(qq,pp)
lines(qq,
      pbernlnorm(qq,
                 prob=ts$prob,
                 meanlog=ts$meanlog,
                 sdlog=ts$sdlog),
      col="red")

hist(rbernlnorm(1000,prob=ts$prob,
                meanlog=ts$meanlog,
                sdlog=ts$sdlog),freq=FALSE)

</code></pre>

<hr>
<h2 id='bernweibull'>
The Bernoulli-Weibull distribution
</h2><span id='topic+bernweibull'></span><span id='topic+dbernweibull'></span><span id='topic+pbernweibull'></span><span id='topic+qbernweibull'></span><span id='topic+rbernweibull'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Bernoulli-Weibull distribution with parameters
<code>prob</code>, <code>shape</code>,  and <code>scale</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernweibull(x, prob, scale, shape)
pbernweibull(q, prob, scale, shape)
qbernweibull(p, prob, scale, shape)
rbernweibull(n, prob, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bernweibull_+3A_x">x</code>, <code id="bernweibull_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="bernweibull_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="bernweibull_+3A_prob">prob</code></td>
<td>

<p>probability of non-zero event.
</p>
</td></tr>
<tr><td><code id="bernweibull_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="bernweibull_+3A_scale">scale</code>, <code id="bernweibull_+3A_shape">shape</code></td>
<td>

<p>shape and scale parameters of the weibull distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture of Bernoulli and Weibull distribution. The mixture is analogue
to the one described for the <code><a href="#topic+berngamma">berngamma</a></code> distribution. 
</p>


<h3>Value</h3>

<p><code>dbernweibull</code> gives the density (pdf), <code>pbernweibull</code> gives
the distribution function (cdf), <code>qbernweibull</code> gives the
quantile function (inverse cdf), and <code>rbernweibull</code> generates
random deviates.  
</p>


<h3>Note</h3>

<p>The implementation is largely based on the <code>bweibull</code> family in
the <code>CaDENCE</code>-package (Cannon, 2012) that was only available as
test version at time of implementation (Mar. 2012). 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Cannon, A. J. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation and
Evaluation (CaDENCE) in R. Computers &amp; Geosciences, 2012, 41, 126 -
135, &lt;doi:10.1016/j.cageo.2011.08.023&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code>, <code><a href="#topic+berngamma">berngamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)

(ts &lt;- startbernweibull(obsprecip[,1]))
hist(obsprecip[,1],freq=FALSE) 
lines(seq(0,max(obsprecip[,1])),
      dbernweibull(seq(0,max(obsprecip[,1])),
                   prob=ts$prob,
                   shape=ts$shape,
                   scale=ts$scale),
      col="red")

pp &lt;- seq(0.01,0.99,by=0.01)
qq &lt;-quantile(obsprecip[,1],probs=pp) 

plot(qq,pp)
lines(qbernweibull(pp,
                   prob=ts$prob,
                   scale=ts$scale,
                   shape=ts$shape),
      pp,col="red")

plot(qq,pp)
lines(qq,
      pbernweibull(qq,
                   prob=ts$prob,
                   scale=ts$scale,
                   shape=ts$shape),
      col="red")

hist(rbernweibull(1000,prob=ts$prob,
                      shape=ts$shape,
                      scale=ts$scale),freq=TRUE)

</code></pre>

<hr>
<h2 id='fitQmap'>
Quantile mapping
</h2><span id='topic+fitQmap'></span><span id='topic+doQmap'></span>

<h3>Description</h3>

<p><code>fitQmap</code> identifyes the parameters of different quantile mapping
methods. <code>doQmap</code> performs quantile  mapping using previously
identified parameters.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmap(obs,mod,method=c("PTF","DIST","RQUANT","QUANT","SSPLIN"),...)
doQmap(x, fobj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmap_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code> with
observed time series. 
</p>
</td></tr>
<tr><td><code id="fitQmap_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code> with
modelled time series corresponding to <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmap_+3A_method">method</code></td>
<td>

<p>A character string indicating the method to be used. See Details.
</p>
</td></tr>
<tr><td><code id="fitQmap_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series. Should have the same number of columns as <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmap_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmap</code> (or of method defined via
<code>method</code>).
</p>
</td></tr>
<tr><td><code id="fitQmap_+3A_...">...</code></td>
<td>

<p>arguments passed to the method specified by <code>method</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument decides upon which method for quantile
mapping is used:
</p>
<p><code>"PTF"</code> selects <code><a href="#topic+fitQmapPTF">fitQmapPTF</a></code>.
</p>
<p><code>"DIST"</code> selects <code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>
</p>
<p><code>"RQUANT"</code> selects <code><a href="#topic+fitQmapRQUANT">fitQmapRQUANT</a></code>
</p>
<p><code>"QUANT"</code> selects <code><a href="#topic+fitQmapQUANT">fitQmapQUANT</a></code>
</p>
<p><code>"SSPLIN"</code> selects <code><a href="#topic+fitQmapSSPLIN">fitQmapSSPLIN</a></code>  
</p>
<p><code>doQmap</code> investigates the class of <code>fobj</code> and chooses the
appropriate method for quantile mapping.
</p>


<h3>Value</h3>

<p><code>fitQmap</code> returns an object which class and structure depends on
the selected <code>method</code> (see Details). 
</p>
<p><code>doQmap</code> returns a <code>numeric</code> vector, <code>matrix</code> or
<code>data.frame</code> depending on the format of <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods, Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>, <code><a href="#topic+fitQmapPTF">fitQmapPTF</a></code>,
<code><a href="#topic+fitQmapRQUANT">fitQmapRQUANT</a></code>, <code><a href="#topic+fitQmapQUANT">fitQmapQUANT</a></code>,
<code><a href="#topic+fitQmapSSPLIN">fitQmapSSPLIN</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

## call to fitQmapPTF and doQmapPTF
qm1.fit &lt;- fitQmap(obsprecip,modprecip,
              method="PTF",
              transfun="expasympt",
              cost="RSS",wett.day=TRUE)
qm1 &lt;- doQmap(modprecip,qm1.fit)

## call to fitQmapDIST and doQmapDIST
qm2.fit &lt;- fitQmap(sqrt(obsprecip),sqrt(modprecip),
              method="DIST",qstep=0.001,
              transfun="berngamma")
qm2 &lt;- doQmap(sqrt(modprecip),qm2.fit)^2

## call to fitQmapRQUANT and doQmapRQUANT
qm3.fit &lt;- fitQmap(obsprecip,modprecip,
              method="RQUANT",qstep=0.01)
qm3 &lt;- doQmap(modprecip,qm3.fit,type="linear")


## call to fitQmapRQUANT and doQmapRQUANT
qm4.fit &lt;- fitQmap(obsprecip,modprecip,
              method="QUANT",qstep=0.01)
qm4 &lt;- doQmap(modprecip,qm4.fit,type="tricub")

## call to fitQmapSSPLIN and doQmapSSPLIN
qm5.fit &lt;- fitQmap(obsprecip,modprecip,qstep=0.01,
                   method="SSPLIN")
qm5 &lt;- doQmap(modprecip,qm5.fit)

sqrtquant &lt;- function(x,qstep=0.001){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}

op &lt;- par(mfrow=c(1,3))
for(i in 1:3){
  plot(sqrtquant(modprecip[,i]),
       sqrtquant(obsprecip[,i]),pch=19,col="gray",
       main=names(obsprecip)[i])
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm1[,i]),col=1)
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm2[,i]),col=2)
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm3[,i]),col=3)
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm4[,i]),col=4)
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm5[,i]),col=5)
}
legend("topleft",
       legend=c("PTF","DIST","RQUANT","QUANT","SSPLIN"),
       lty=1, col=1:5)
par(op)
</code></pre>

<hr>
<h2 id='fitQmapDIST'>
Quantile mapping using distribution derived transformations 
</h2><span id='topic+fitQmapDIST'></span><span id='topic+fitQmapDIST.default'></span><span id='topic+fitQmapDIST.matrix'></span><span id='topic+fitQmapDIST.data.frame'></span><span id='topic+doQmapDIST'></span><span id='topic+doQmapDIST.default'></span><span id='topic+doQmapDIST.matrix'></span><span id='topic+doQmapDIST.data.frame'></span>

<h3>Description</h3>

<p><code>fitQmapDIST</code> fits a theoretical distribution to observed and to  
modelled time series and returns these parameters as  well as a
transfer function derived from the distribution. <code>doQmapDIST</code>
uses the transfer function to transform the distribution of the
modelled data to match the distribution of the observations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmapDIST(obs, mod, ...)
## Default S3 method:
fitQmapDIST(obs,mod,distr="berngamma",start.fun,
qstep=NULL,mlepar,...)
## S3 method for class 'matrix'
fitQmapDIST(obs, mod, ...)
## S3 method for class 'data.frame'
fitQmapDIST(obs, mod, ...)
doQmapDIST(x,fobj,...)
## Default S3 method:
doQmapDIST(x,fobj,...)
## S3 method for class 'matrix'
doQmapDIST(x,fobj,...)
## S3 method for class 'data.frame'
doQmapDIST(x,fobj,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmapDIST_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code> with
observed time series. 
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code> with
modelled time series, corresponding to <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_distr">distr</code></td>
<td>

<p>A character string <code>"name"</code> naming a distribution for which the
corresponding density function (<code>dname</code>), the corresponding
distribution function (<code>pname</code>) and the quantile function
(<code>qname</code>) must be defined (see for example
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, <code><a href="#topic+berngamma">berngamma</a></code> or
<code><a href="#topic+bernweibull">bernweibull</a></code>. 
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_start.fun">start.fun</code></td>
<td>

<p>function estimating starting values for parameter
optimisation. Default starting values are provided for
<code><a href="#topic+berngamma">berngamma</a></code>, <code><a href="#topic+bernweibull">bernweibull</a></code>,
<code><a href="#topic+bernlnorm">bernlnorm</a></code>, <code><a href="#topic+bernexp">bernexp</a></code> and the  
distributions mentioned in the documentation of
<code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>.
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_qstep">qstep</code></td>
<td>

<p><code>NULL</code> or a numeric value between 0 and 1.
If <code>!is.null(qstep)</code> than <code>mod</code> and <code>obs</code> are
aggregated to quantiles before model identification as:
</p>
<p><code>quantile(x,probs=seq(0,1,by=qstep)</code>. This effectively reduces
the sample-size and can be used to speedup computations - but may
render estimates less reliable.
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_mlepar">mlepar</code></td>
<td>

<p>a named list. Names correspond to parameters passed to
<code><a href="fitdistrplus.html#topic+mledist">mledist</a></code> note that <code>start</code> may be overwritten by
<code>start.fun</code> See examples.  
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmapDIST</code>
</p>
</td></tr>
<tr><td><code id="fitQmapDIST_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile mapping using distribution derived transformations to adjust
the distribution of a modelled variable (<code class="reqn">P_m</code>) such that it
matches the distribution of an observed variable (<code class="reqn">P_o</code>). The
distribution derived transfer function is  defined as 

</p>
<p style="text-align: center;"><code class="reqn">P_o=F^{-1}_o(F_m(P_m))</code>
</p>


<p>where <code class="reqn">F</code> is a CDF and <code class="reqn">F^{-1}</code> is the corresponding quantile
function (inverse CDF). The subscripts <code class="reqn">o</code>  and <code class="reqn">m</code> indicate
parameters of the distribution that correspond to observed and
modelled data respectively.   
</p>


<h3>Value</h3>

<p><code>fitQmapDIST</code> returns an object of class <code>fitQmapDIST</code>
containing following elements:
</p>
<table role = "presentation">
<tr><td><code>tfun</code></td>
<td>
<p>The function used to transform the distribution of
modelled values such that the distribution of observations. The
function is build internally based on the distribution function
(&quot;pname&quot;) and quantile function (&quot;qname&quot;) corresponding to
<code>distr</code>.</p>
</td></tr>  
<tr><td><code>par</code></td>
<td>
<p>A matrix. The (named) columns correspond to the parameters
of the distribution specified in <code>distr</code> estimated for the
observed (suffix <code>.o</code>) and the modelled (suffix <code>.m</code>)
data. The rows correspond to each pair of time series in <code>obs</code>
and <code>mod</code>.</p>
</td></tr>
</table>
<p><code>doQmapDIST</code> returns a <code>numeric</code> vector, <code>matrix</code> or
<code>data.frame</code> depending on the format of <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Piani, C.; Haerter, J. &amp; Coppola, E. Statistical bias correction for
daily precipitation in regional climate models over
Europe. Theoretical and Applied Climatology, 2010, 99,
187-192, &lt;doi:10.1007/s00704-009-0134-9&gt;.
</p>
<p>Li, H.; Sheffield, J. &amp; Wood, E. F. Bias correction of monthly
precipitation and temperature fields from Intergovernmental Panel on
Climate Change AR4 models using equidistant quantile matching.
J. Geophys. Res., 2010, 115, D10101, &lt;doi:10.1029/2009JD012882&gt;.
</p>
<p>Ines, A. V. &amp; Hansen, J. W. Bias correction of daily GCM rainfall for
crop simulation studies. Agricultural and Forest Meteorology, 2006,
138, 44 - 53, &lt;doi:10.1016/j.agrformet.2006.03.009&gt;.
</p>
<p>For a general assessment of the methods see:
</p>
<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods. Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+doQmap">doQmap</a></code>, <code><a href="#topic+startberngamma">startberngamma</a></code>,
<code><a href="#topic+berngamma">berngamma</a></code>, <code><a href="#topic+startbernweibull">startbernweibull</a></code>,
<code><a href="#topic+bernweibull">bernweibull</a></code>, <code><a href="#topic+startbernlnorm">startbernlnorm</a></code>,
<code><a href="#topic+bernlnorm">bernlnorm</a></code>, <code><a href="#topic+startbernexp">startbernexp</a></code>,
<code><a href="#topic+bernexp">bernexp</a></code>, <code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>,
<code><a href="fitdistrplus.html#topic+fitdist">fitdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

qm.fit &lt;- fitQmapDIST(obsprecip[,1],modprecip[,1],
                      distr="berngamma",
                      qstep=0.001)
qm &lt;- doQmapDIST(modprecip[,1],qm.fit)


# adjusting settings of the maximum likelyhood estimator 
# here changing the convergence criterion in the optimizer 'optim'
# Note: the selected value might be to large for true applications.
# Please check for your context.
qm.lnorm.fit &lt;- fitQmapDIST(obsprecip[,1],modprecip[,1],
                      distr="bernlnorm",
                      qstep=0.001,
                      mlepar = list(control = list(
                            reltol = 1e-2
                      )))
qm.lnorm &lt;- doQmapDIST(modprecip[,1],qm.lnorm.fit)

qm.weibu.fit &lt;- fitQmapDIST(obsprecip[,1],modprecip[,1],
                      distr="bernweibull",
                      qstep=0.001)
qm.weibu &lt;- doQmapDIST(modprecip[,1],qm.weibu.fit)

qm.exp.fit &lt;- fitQmapDIST(sqrt(obsprecip[,1]),sqrt(modprecip[,1]),
                      distr="bernexp",
                      qstep=0.001)
qm.exp &lt;- doQmapDIST(sqrt(modprecip[,1]),qm.exp.fit)^2


## utility function. 
## plots are easier to investigate if
## precipitation data are sqrt transformed
sqrtquant &lt;- function(x,qstep=0.01){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}

plot(sqrtquant(modprecip[,1]),
     sqrtquant(obsprecip[,1]))
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm),col="red")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm.lnorm),col="blue")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm.weibu),col="green")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm.exp),col="orange")
legend("topleft",
       legend=c("berngamma","bernlnorm","bernweibull","bernexp"),
       lty=1,
       col=c("red","blue","green","orange"))

## effect of qstep on speed of fitting process:
system.time(
qm.a.fit &lt;- fitQmapDIST(obsprecip[,2],modprecip[,2],
                       distr="berngamma",
                       start.fun=startberngamma,
                       qstep=0.001)
)

system.time(
qm.b.fit &lt;- fitQmapDIST(obsprecip[,2],modprecip[,2],
                       distr="berngamma",
                       start.fun=startberngamma,
                       qstep=0.01)
)

qm.a &lt;- doQmapDIST(modprecip[,2],qm.a.fit)
qm.b &lt;- doQmapDIST(modprecip[,2],qm.b.fit)

plot(sqrtquant(modprecip[,2]),
     sqrtquant(obsprecip[,2]))
lines(sqrtquant(modprecip[,2]),
     sqrtquant(qm.a),col="red")
lines(sqrtquant(modprecip[,2]),
     sqrtquant(qm.b),col="blue")
legend("topleft",
       legend=c("qstep=0.001","qstep=0.01"),
       col=c("red","blue"),
       lty=1)


## method for matrix
## the sqrt() transformation renders the
## fitting procedure more stable
qm2.fit &lt;- fitQmapDIST(sqrt(obsprecip),sqrt(modprecip),
                       distr="berngamma",
                       qstep=0.001)
qm2 &lt;- doQmapDIST(sqrt(modprecip),qm2.fit)^2

if(!any(is.na(qm2.fit$par))){
  op &lt;- par(mfrow=c(1,3))
  for(i in 1:3){
    plot(sqrtquant(modprecip[,i]),
         sqrtquant(obsprecip[,i]))
    lines(sqrtquant(modprecip[,i]),
          sqrtquant(qm2[,i]),col="red")
  }
 par(op)
}
</code></pre>

<hr>
<h2 id='fitQmapPTF'>
Quantile mapping using parametric transformations
</h2><span id='topic+fitQmapPTF'></span><span id='topic+fitQmapPTF.default'></span><span id='topic+fitQmapPTF.matrix'></span><span id='topic+fitQmapPTF.data.frame'></span><span id='topic+doQmapPTF'></span><span id='topic+doQmapPTF.default'></span><span id='topic+doQmapPTF.matrix'></span><span id='topic+doQmapPTF.data.frame'></span>

<h3>Description</h3>

<p><code>fitQmapPTF</code> fits a parametric transformations to the
quantile-quantile relation of observed and modelled
values. <code>doQmapPTF</code> uses the transformation to adjust the
distribution of the modelled data to match the distribution of the
observations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmapPTF(obs, mod, ...)
## Default S3 method:
fitQmapPTF(obs, mod, transfun=c("power","linear","expasympt",
"scale","power.x0","expasympt.x0"), wet.day=TRUE,
cost=c("RSS","MAE"), qstep=0.001,opar,...)
## S3 method for class 'matrix'
fitQmapPTF(obs, mod, ...)
## S3 method for class 'data.frame'
fitQmapPTF(obs, mod, ...)
doQmapPTF(x,fobj,...)
## Default S3 method:
doQmapPTF(x,fobj,...)
## S3 method for class 'matrix'
doQmapPTF(x,fobj,...)
## S3 method for class 'data.frame'
doQmapPTF(x,fobj,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmapPTF_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with observed time series. 
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with modelled time series, corresponding to <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_transfun">transfun</code></td>
<td>

<p>either a character string specifying a predefined function used for
the transformation (see Details) or a function with <code>x</code> as
first argument e.g. <code>function(x,a,b){a*x^b}</code>
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_wet.day">wet.day</code></td>
<td>
   
<p><code>logical</code> indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. See Details. 
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_cost">cost</code></td>
<td>

<p>Criterion for optimisation. &quot;RSS&quot; minimises the residual sum of
squares and produces a least square fit. &quot;MAE&quot; minimises the mean
absolute error, which is less sensitive to outliers. 
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_qstep">qstep</code></td>
<td>

<p><code>NULL</code> or a numeric value between 0 and 1. See Details.
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_opar">opar</code></td>
<td>

<p>a named list with arguments passed to <code>optim</code>. Note that
<code>method</code> is chosen automatically. If <code>transfun</code> is a
character string  default values for <code>par</code> are available (but
can be overwritten). See examples. 
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmapDIST</code>
</p>
</td></tr>
<tr><td><code id="fitQmapPTF_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before further computations the empirical cumulative distribution
functions (CDF) of the observed (<code>obs</code>) and modelled (<code>mod</code>) are
estimated. If <code>!is.null(qstep)</code> than <code>mod</code> and <code>obs</code>
are aggregated to quantiles before model identification as:
<code>quantile(x,probs=seq(0,1,by=qstep)</code>. If <code>!is.null(qstep)</code> 
than <code>mod</code> and <code>obs</code> are sorted to produce an estimate of
the empirical CDF. In case of different length of <code>mod</code> and
<code>obs</code> than <code>quantile(x,probs=seq(0,1,len=n)]</code> is used, where
<code>n &lt;- min(length(obs),length(mod))</code>. NOTE that large values of
<code>qstep</code> effectively reduce the sample-size and can be used to
speedup computations - but may render estimates less reliable.    
</p>
<p><code>wet.day</code> is intended for the use for precipitation data. Wet day
correction  attempts to equalise the fraction of days with
precipitation between the observed and the modelled data. If
<code>wet.day=TRUE</code> the empirical probability of nonzero observations
is found (<code>obs&gt;=0</code>) and the corresponding modelled value is
selected as a threshold. All modelled  values below this threshold are
set to zero. If <code>wet.day</code> is <code>numeric</code> the same procedure is
performed after setting all <code>obs&lt;wet.day</code> to zero. The
transformations are then only fitted to the portion of the
distributions corresponding to observed wet days. See Piani et. al
(2010) for further explanations.
</p>
<p><b>Transformations</b> (<code>transfun</code>):
</p>
<p>NOTE: If wet day correction is performed (see <code>wet.day</code>), the
transformations are only fitted to the portion of the empirical CDF
with nonzero observations. 
</p>
<p>A series of predefined transformations are available and can be
accessed by setting <code>transfun</code> to one of the following options
(<code class="reqn">P_o</code> refers to observed and <code class="reqn">P_m</code> to modelled CDFs):
</p>
<p><code>"power"</code>:

</p>
<p style="text-align: center;"><code class="reqn">P_o=b*P_m^c</code>
</p>


<p><code>"linear"</code>:

</p>
<p style="text-align: center;"><code class="reqn">P_o=a+b*P_m</code>
</p>


<p><code>"expasympt"</code> (exponential tendency to an asymptote):

</p>
<p style="text-align: center;"><code class="reqn">P_o=(a+b*P_m)*(1-exp(-P_m/\tau))</code>
</p>


<p><code>"scale"</code>:

</p>
<p style="text-align: center;"><code class="reqn">P_o=b*P_m</code>
</p>


<p><code>"power.x0"</code>:

</p>
<p style="text-align: center;"><code class="reqn">P_o=b*(P_m-x0)^c</code>
</p>


<p><code>"expasympt.x0"</code> (exponential tendency to an asymptote):

</p>
<p style="text-align: center;"><code class="reqn">P_o=(a+b*P_m)*(1-exp(-(P_m-x0)/\tau))</code>
</p>




<h3>Value</h3>

 
<p><code>fitQmapPTF</code> returns an object of class <code>fitQmapPTF</code>
containing following elements:
</p>
<table role = "presentation">
<tr><td><code>tfun</code></td>
<td>

<p>The function used to transform the distribution of the modelled
values to match the distribution of the observations. 
</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>A matrix. The (named) columns correspond to the parameters
of the transfer function. The rows correspond to pairs of time
series in <code>obs</code> and <code>mod</code>.
</p>
</td></tr>
<tr><td><code>wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. 
</p>
</td></tr>
</table>
<p><code>doQmapPTF</code> returns a <code>numeric</code> vector, <code>matrix</code> or
<code>data.frame</code> depending on the format of <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>The implementation is closely related to the methods published in:
</p>
<p>Piani, C.; Weedon, G.; Best, M.; Gomes, S.; Viterbo, P.; Hagemann,
S. &amp; Haerter, J. Statistical bias correction of global simulated daily
precipitation and temperature for the application of hydrological
models. Journal of Hydrology, 2010, 395, 199 -
215, &lt;doi:10.1016/j.jhydrol.2010.10.024&gt;.
</p>
<p>Dosio, A. &amp; Paruolo, P. Bias correction of the ENSEMBLES
high-resolution climate change projections for use by impact models:
Evaluation on the present climate. J. Geophys. Res., AGU, 2011, 116,
D16106, &lt;doi:10.1029/2011JD015934&gt;.
</p>
<p>For a general assessment of the methods see:
</p>
<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods. Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmap">fitQmap</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

## data.frame example
qm.fit &lt;- fitQmapPTF(obsprecip,modprecip,
                     transfun="power.x0",
                     cost="RSS",wet.day=TRUE,
                     qstep=0.001)
qm &lt;- doQmapPTF(modprecip,qm.fit)

## application to "single time series"
qm.b.fit &lt;- fitQmapPTF(obsprecip[,1],modprecip[,1],
                     transfun="expasympt.x0",
                     cost="RSS",wet.day=0.1,
                     qstep=0.001)
qm.b &lt;- doQmapPTF(modprecip[,1],qm.b.fit)
qm.c.fit &lt;- fitQmapPTF(obsprecip[,1],modprecip[,1],
                     transfun="expasympt",
                     cost="RSS",wet.day=TRUE,
                     qstep=0.001)
qm.c &lt;- doQmapPTF(modprecip[,1],qm.c.fit)

## user defined transfer function
## and usage of the 'opar' argument
## (same as transfun="power")
myff &lt;- function(x,a,b) a*x^b

qm3.fit &lt;- fitQmapPTF(obsprecip[,1],modprecip[,1],
                     transfun=myff,
                     opar=list(par=c(a=1,b=1)),
                     cost="RSS",wet.day=TRUE,
                     qstep=0.001)
qm3 &lt;- doQmapPTF(modprecip[,1],qm3.fit)


sqrtquant &lt;- function(x,qstep=0.01){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}
plot(sqrtquant(modprecip[,1]),
     sqrtquant(obsprecip[,1]))
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm[,1]),col="red")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm.b),col="blue")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm.c),col="green")
lines(sqrtquant(modprecip[,1]),
      sqrtquant(qm3),col="orange")
legend("topleft",
       legend=c("power.x0","expasympt.x0",
         "expasympt","myff"),
       col=c("red","blue","green","orange"),lty=1)


</code></pre>

<hr>
<h2 id='fitQmapQUANT'>
Non-parametric quantile mapping using empirical quantiles.  
</h2><span id='topic+fitQmapQUANT'></span><span id='topic+fitQmapQUANT.default'></span><span id='topic+fitQmapQUANT.matrix'></span><span id='topic+fitQmapQUANT.data.frame'></span><span id='topic+doQmapQUANT'></span><span id='topic+doQmapQUANT.default'></span><span id='topic+doQmapQUANT.matrix'></span><span id='topic+doQmapQUANT.data.frame'></span>

<h3>Description</h3>

<p><code>fitQmapQUANT</code> estimates values of the empirical cumulative
distribution function of observed and modelled time series for
regularly spaced quantiles. <code>doQmapQUANT</code> uses these estimates to
perform quantile mapping. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmapQUANT(obs, mod, ...)
## Default S3 method:
fitQmapQUANT(obs,mod,wet.day=TRUE,qstep=0.01,
nboot = 1,...)
## S3 method for class 'matrix'
fitQmapQUANT(obs, mod, ...)
## S3 method for class 'data.frame'
fitQmapQUANT(obs, mod, ...)
doQmapQUANT(x,fobj,...)
## Default S3 method:
doQmapQUANT(x,fobj, type=c("linear","tricub"),...)
## S3 method for class 'matrix'
doQmapQUANT(x,fobj,...)
## S3 method for class 'data.frame'
doQmapQUANT(x,fobj,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmapQUANT_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with observed time series. 
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with modelled time series, corresponding to <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_wet.day">wet.day</code></td>
<td>

<p><code>logical</code> indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. See details.
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_qstep">qstep</code></td>
<td>

<p>a numeric value between 0 and 1. The quantile mapping is fitted only
for the quantiles defined by
<code>quantile(0,1,probs=seq(0,1,by=qstep)</code>. 
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_nboot">nboot</code></td>
<td>

<p>number of bootstrap samples used for estimation of the observed
quantiles. If <code>nboot==1</code> the estimation is based on all (and
not resampled) data. See details.   
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmapQUANT</code>
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_type">type</code></td>
<td>

<p>type of interpolation between the fitted transformed
values. See details.
</p>
</td></tr>
<tr><td><code id="fitQmapQUANT_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitQmapQUANT</code> estimates the empirical cumulative distribution
function of <code>mod</code> and <code>obs</code> for the quantiles defined by
<code>seq(0,1,by=qstep)</code>. The quantiles of <code>mod</code> are estimated
using the empirical quantiles. If <code>nboot&gt;1</code> the quantiles of
<code>obs</code> are estimated as the mean of <code>nboot</code> bootstrap
samples (if <code>nboot&gt;1</code>).  
</p>
<p><code>doQmapQUANT</code> transforms the variable <code>x</code> based on the
transformation identified using <code>fitQmapQUANT</code>. 
For all values that are not in
<code>quantile(mod,probs=seq(0,1,by=qstep))</code> the  transformation is
estimated using interpolation of the fitted  values. Available
interpolation options are: 
</p>
<p><code>type="linear"</code>: linear interpolation using <code><a href="stats.html#topic+approx">approx</a></code>, 
but using the extrapolation suggested by Boe et al. (2007) for values
of <code>x</code> larger than <code>max(mod)</code> (constant correction). 
</p>
<p><code>type="tricube"</code>: monotonic  tricubic spline interpolation using
<code><a href="stats.html#topic+splinefun">splinefun</a></code>. Spline  interpolation is performed using a
_monotone_ Hermite spline (<code>method="monoH.FC"</code> in
<code><a href="stats.html#topic+splinefun">splinefun</a></code>).
</p>
<p><code>wet.day</code> is intended for the use for precipitation data. Wet day
correction  attempts to equalise the fraction of days with
precipitation between the observed and the modelled data. If
<code>wet.day=TRUE</code> the empirical probability of nonzero observations
is found (<code>obs&gt;=0</code>) and the corresponding modelled value is
selected as a threshold. All modelled  values below this threshold are
set to zero. If <code>wet.day</code> is <code>numeric</code> the same procedure is
performed after setting all <code>obs&lt;wet.day</code> to zero.
</p>


<h3>Value</h3>

<p><code>fitQmapQUANT</code> returns an object of class <code>fitQmapQUANT</code>
containing following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>A list containing:</p>
</td></tr>
<tr><td><code>par$modq</code></td>
<td>

<p>a matrix. Each column <code>i</code> corresponds to the output
of <code>quantile(mod[,i],probs=seq(0,1,by=qstep))</code>.
</p>
</td></tr>
<tr><td><code>par$fitq</code></td>
<td>

<p>observed empirical quantiles corresponding to <code>par$modq</code>. 
</p>
</td></tr>
<tr><td><code>wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. 
</p>
</td></tr>
</table>
<p><code>doQmapQUANT</code> returns a <code>numeric</code> vector or <code>matrix</code>
depending on the format of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Boe, J.; Terray, L.; Habets, F. &amp; Martin, E. Statistical and dynamical
downscaling of the Seine basin climate for hydro-meteorological
studies. International Journal of Climatology, 2007, 27,
1643-1655, &lt;doi:10.1002/joc.1602&gt;.
</p>
<p>For a general assessment of the methods see:
</p>
<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods. Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmap">fitQmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

qm.fit &lt;- fitQmapQUANT(obsprecip[,2],modprecip[,2],
                      qstep=0.1,nboot=1,wet.day=TRUE)
qm.a &lt;- doQmapQUANT(modprecip[,2],qm.fit,type="linear")
qm.s &lt;- doQmapQUANT(modprecip[,2],qm.fit,type="tricub")


sqrtquant &lt;- function(x,qstep=0.01){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}

plot(sqrtquant(modprecip[,2]),
     sqrtquant(obsprecip[,2]))
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.a),col="red")
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.s),col="blue")
points(sqrt(qm.fit$par$modq),sqrt(qm.fit$par$fitq),
       pch=19,cex=0.5,col="green")
legend("topleft",
       legend=c("linear","tricub","support"),
       lty=c(1,1,NA),pch=c(NA,NA,19),
       col=c("red","blue","green"))
         

qm2.fit &lt;- fitQmapQUANT(obsprecip,modprecip,
                      qstep=0.01,nboot=1,wet.day=TRUE)
qm2 &lt;- doQmapQUANT(modprecip,qm2.fit,type="tricub")

op &lt;- par(mfrow=c(1,3))
for(i in 1:3){
  plot(sqrtquant(modprecip[,i]),
       sqrtquant(obsprecip[,i]),
       main=names(qm2)[i])
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm2[,i]),col="red")
  points(sqrt(qm2.fit$par$modq[,i]),
         sqrt(qm2.fit$par$fitq[,i]),
       pch=19,cex=0.5,col="green")

}
par(op)


</code></pre>

<hr>
<h2 id='fitQmapRQUANT'>
Non-parametric quantile mapping using robust empirical quantiles.  
</h2><span id='topic+fitQmapRQUANT'></span><span id='topic+fitQmapRQUANT.default'></span><span id='topic+fitQmapRQUANT.matrix'></span><span id='topic+fitQmapRQUANT.data.frame'></span><span id='topic+doQmapRQUANT'></span><span id='topic+doQmapRQUANT.default'></span><span id='topic+doQmapRQUANT.matrix'></span><span id='topic+doQmapRQUANT.data.frame'></span>

<h3>Description</h3>

<p><code>fitQmapRQUANT</code> estimates the values of the quantile-quantile
relation of observed and modelled time series for regularly spaced
quantiles using local linear least square
regression. <code>doQmapRQUANT</code> performs quantile mapping by
interpolating the empirical quantiles.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmapRQUANT(obs, mod, ...)
## Default S3 method:
fitQmapRQUANT(obs,mod,wet.day=TRUE,qstep=0.01,
nlls = 10,nboot = 10,...)
## S3 method for class 'matrix'
fitQmapRQUANT(obs, mod, ...)
## S3 method for class 'data.frame'
fitQmapRQUANT(obs, mod, ...)
doQmapRQUANT(x,fobj,...)
## Default S3 method:
doQmapRQUANT(x,fobj,slope.bound=c(lower=0,upper=Inf), 
type=c("linear","linear2","tricub"),...)
## S3 method for class 'matrix'
doQmapRQUANT(x,fobj,...)
## S3 method for class 'data.frame'
doQmapRQUANT(x,fobj,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmapRQUANT_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with observed time series. 
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector or column <code>matrix</code>/<code>data.frame</code> with
modelled time series, corresponding to <code>obs</code>
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_wet.day">wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. See details. 
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_qstep">qstep</code></td>
<td>

<p>A numeric value between 0 and 1. The values quantile-quantile plot
are estimated at the position of the values defined by:
</p>
<p><code>quantile(mod,probs=seq(0,1,by=qstep)</code>.
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_nlls">nlls</code></td>
<td>

<p>number of nearest data points to apply in the local regression
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_nboot">nboot</code></td>
<td>

<p>number of bootstrap samples in the estimation of the
transformation. If <code>nboot==1</code> the estimation is based on all 
(and not resampled) data. 
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmapRQUANT</code>
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_slope.bound">slope.bound</code></td>
<td>

<p>bounds for the slopes in case of extrapolation. Applies only if
<code>type="linear2"</code>    
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_type">type</code></td>
<td>

<p>type of interpolation between the fitted transformed
values. See details
</p>
</td></tr>
<tr><td><code id="fitQmapRQUANT_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitQmapRQUANT</code> produces a robust estimate of the empirical
quantile-quantile plot (QQ-plot) of <code>mod</code> vs <code>obs</code> for the
<code>seq(0,1,by=qstep)</code> quantiles <code>mod</code>. The corresponding value 
of the quantiles of <code>obs</code> is estimated using local linear least
squares regression. For each quantile of <code>mod</code> the <code>nlls</code>
nearest data points in the QQ-plot are identified and used to fit a
local regression line. This regression line is then used to estimate
value of the quantile of <code>obs</code>. The estimation is replicated for
<code>nboot</code> bootstrap samples and the mean of the bootstrap
replicates is returned.
</p>
<p>This procedure results in a table with empirical quantiles of
<code>mod</code> and a corresponding table with robust estimates of the
empirical quantiles of <code>obs</code>. 
</p>
<p><code>doQmapRQUANT</code> uses the tables of robust empirical quantiles
identified using <code>fitQmapRQUANT</code> to transform the variable
<code>x</code>. For values that are not in
</p>
<p><code>quantile(mod,probs=seq(0,1,by=qstep))</code> the transformation is
estimated using interpolation of the fitted  values. Available
interpolation options are:
</p>
<p><code>type="linear"</code>: linear interpolation using <code><a href="stats.html#topic+approx">approx</a></code>, 
but using the extrapolation suggested by Boe et al. (2007) for values
of <code>x</code> larger than max(mod) (constant correction).
</p>
<p><code>type="linear2"</code>: linear interpolation using
<code><a href="stats.html#topic+approx">approx</a></code>. For any value of <code>x</code> outside
<code>range(mod)</code> the transformation is extrapolated using the slope
of the local linear least squares regression at the outer most
points. 
</p>
<p><code>type="tricube"</code>: monotonic  tricubic spline interpolation using
<code><a href="stats.html#topic+splinefun">splinefun</a></code>. Spline  interpolation is performed using a
_monotone_ Hermite spline (<code>method="monoH.FC"</code> in
<code><a href="stats.html#topic+splinefun">splinefun</a></code>).
</p>
<p><code>wet.day</code> is intended for the use for precipitation data. Wet day
correction  attempts to equalise the fraction of days with
precipitation between the observed and the modelled data. If
<code>wet.day=TRUE</code> the empirical probability of nonzero observations
is found (<code>obs&gt;=0</code>) and the corresponding modelled value is
selected as a threshold. All modelled  values below this threshold are
set to zero. If <code>wet.day</code> is <code>numeric</code> the same procedure is
performed after setting all <code>obs&lt;wet.day</code> to zero.
</p>


<h3>Value</h3>

<p><code>fitQmapRQUANT</code> returns an object of class <code>fitQmapRQUANT</code>
containing following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>A list containing:</p>
</td></tr>
<tr><td><code>par$modq</code></td>
<td>

<p>a matrix. Each column <code>i</code> corresponds to the output
of
</p>
<p><code>quantile(mod[,i],probs=seq(0,1,by=qstep))</code>.
</p>
</td></tr>
<tr><td><code>par$fitq</code></td>
<td>

<p>the fitted values of the local linear least square regression
corresponding to <code>par$modq</code>
</p>
</td></tr>
<tr><td><code>par$slope</code></td>
<td>

<p>a matrix. the columns correspond to the columns of <code>mod</code>. The
rows contain the slope of the <code>"lower"</code> and the <code>"upper"</code> 
extreme points of the local linear fit and is used for
extrapolation if <code>type="linear2"</code>.    
</p>
</td></tr>
<tr><td><code>wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. 
</p>
</td></tr>
</table>
<p><code>doQmapRQUANT</code> returns a <code>numeric</code> vector or <code>matrix</code>
depending on the format of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>John Bjornar Bremnes and Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Boe, J.; Terray, L.; Habets, F. &amp; Martin, E. Statistical and dynamical
downscaling of the Seine basin climate for hydro-meteorological
studies. International Journal of Climatology, 2007, 27,
1643-1655, &lt;doi:10.1002/joc.1602&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmap">fitQmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

## single series example
qm.fit &lt;- fitQmapRQUANT(obsprecip[,2],modprecip[,2],
                      qstep=0.1,nboot=10,wet.day=TRUE)
qm.a &lt;- doQmapRQUANT(modprecip[,2],qm.fit,type="linear")
qm.b &lt;- doQmapRQUANT(modprecip[,2],qm.fit,type="tricub")

sqrtquant &lt;- function(x,qstep=0.01){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}

plot(sqrtquant(modprecip[,2]),
     sqrtquant(obsprecip[,2]))
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.a),col="red")
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.b),col="blue")
points(sqrt(qm.fit$par$modq),sqrt(qm.fit$par$fitq),
       pch=19,cex=1,col="green")
legend("topleft",
       legend=c("linear","tricub","support","data"),
       lty=c(1,1,NA,NA),pch=c(NA,NA,19,21),
       col=c("red","blue","green","black"))

qm2.fit &lt;- fitQmapRQUANT(obsprecip,modprecip,
                       qstep=0.02,nboot=1,
                       wet.day=TRUE)
qm2 &lt;- doQmapRQUANT(modprecip,qm2.fit,type="tricub")

op &lt;- par(mfrow=c(1,3))
for(i in 1:3){
  plot(sqrtquant(modprecip[,i]),
       sqrtquant(obsprecip[,i]),
       main=names(qm2)[i])
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm2[,i]),col="red")
  points(sqrt(qm2.fit$par$modq[,i]),
         sqrt(qm2.fit$par$fitq[,i]),
       pch=19,cex=0.5,col="green")

}
par(op)

</code></pre>

<hr>
<h2 id='fitQmapSSPLIN'>
Quantile mapping using a smoothing spline
</h2><span id='topic+fitQmapSSPLIN'></span><span id='topic+fitQmapSSPLIN.default'></span><span id='topic+fitQmapSSPLIN.matrix'></span><span id='topic+fitQmapSSPLIN.data.frame'></span><span id='topic+doQmapSSPLIN'></span><span id='topic+doQmapSSPLIN.default'></span><span id='topic+doQmapSSPLIN.matrix'></span><span id='topic+doQmapSSPLIN.data.frame'></span>

<h3>Description</h3>

<p><code>fitQmapSSPLIN</code> fits a smoothing spline to the quantile-quantile
plot of observed and modelled time series. <code>doQmapSSPLIN</code> uses
the spline function to adjust the distribution of the modelled data
to match the distribution of the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitQmapSSPLIN(obs, mod, ...)
## Default S3 method:
fitQmapSSPLIN(obs,mod,wet.day=TRUE,qstep=0.01,
spline.par,...)
## S3 method for class 'matrix'
fitQmapSSPLIN(obs, mod, ...)
## S3 method for class 'data.frame'
fitQmapSSPLIN(obs, mod, ...)
doQmapSSPLIN(x,fobj,...)
## Default S3 method:
doQmapSSPLIN(x,fobj,...)
## S3 method for class 'matrix'
doQmapSSPLIN(x,fobj,...)
## S3 method for class 'data.frame'
doQmapSSPLIN(x,fobj,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitQmapSSPLIN_+3A_obs">obs</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with observed time  series.
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_mod">mod</code></td>
<td>

<p><code>numeric</code> vector, column <code>matrix</code> or <code>data.frame</code>
with modelled time series, corresponding to <code>obs</code>.
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_wet.day">wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. See details. 
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_qstep">qstep</code></td>
<td>

<p><code>NULL</code> or a numeric value between 0 and 1. See Details.
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_spline.par">spline.par</code></td>
<td>

<p>a named list with parameters passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. 
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_x">x</code></td>
<td>

<p><code>numeric</code> vector or a column <code>matrix</code> of modelled time
series
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_fobj">fobj</code></td>
<td>

<p>output from <code>fitQmapDIST</code>
</p>
</td></tr>
<tr><td><code id="fitQmapSSPLIN_+3A_...">...</code></td>
<td>

<p>Further arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before further computations the empirical cumulative distribution
functions (CDF) of the observed (<code>obs</code>) and modelled (<code>mod</code>)
are estimated. If <code>!is.null(qstep)</code> than <code>mod</code> and
<code>obs</code> are aggregated to quantiles before model identification as: 
<code>quantile(x,probs=seq(0,1,by=qstep)</code>. If <code>!is.null(qstep)</code> 
than <code>mod</code> and <code>obs</code> are sorted to produce an estimate of
the empirical CDF. In case of different length of <code>mod</code> and
<code>obs</code> than <code>quantile(x,probs=seq(0,1,len=n)]</code> is used, where
</p>
<p><code>n &lt;- min(length(obs),length(mod))</code>. NOTE that large values of
<code>qstep</code> effectively reduce the sample-size and can be used to
speedup computations - but may render estimates less reliable.   
</p>
<p><code>wet.day</code> is intended for the use for precipitation data. Wet day
correction  attempts to equalise the fraction of days with
precipitation between the observed and the modelled data. If
<code>wet.day=TRUE</code> the empirical probability of nonzero observations
is found (<code>obs&gt;=0</code>) and the corresponding modelled value is
selected as a threshold. All modelled  values below this threshold are
set to zero. If <code>wet.day</code> is <code>numeric</code> the same procedure is
performed after setting all <code>obs&lt;wet.day</code> to zero. The
transformations are then only fitted to the portion of the
distributions corresponding to observed wet days.
</p>


<h3>Value</h3>

<p><code>fitQmapSSPLIN</code> returns an object of class <code>fitQmapSSPLIN</code>
containing following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>A list containing objects of class <code>smooth.spline.fit</code>, which
are equivalent to the value of the element <code>fit</code> in the output
of <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. The spline coefficients are checked
for monotony and adjusted if necessary by replacement with the
previous value. If <code>mod</code> is a matrix the names of <code>par</code>
correspond to <code>colnames(mod)</code>. 
</p>
</td></tr>
<tr><td><code>wet.day</code></td>
<td>

<p><code>logical</code>, indicating whether to perform wet day correction or
not. OR a <code>numeric</code> threshold below which all values are set to
zero. 
</p>
</td></tr>
</table>
<p><code>doQmapSSPLIN</code> returns a <code>numeric</code> vector or <code>matrix</code>
depending on the format of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>References</h3>

<p>Gudmundsson, L.; Bremnes, J. B.; Haugen, J. E. &amp; Engen-Skaugen,
T. Technical Note: Downscaling RCM precipitation to the station scale
using statistical transformations - a comparison of methods. Hydrology
and Earth System Sciences, 2012, 16, 3383-3390,
&lt;doi:10.5194/hess-16-3383-2012&gt;.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmap">fitQmap</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)

qm.a.fit &lt;- fitQmapSSPLIN(obsprecip[,2],modprecip[,2],
                      qstep=0.01,wet.day=TRUE)
qm.a &lt;- doQmapSSPLIN(modprecip[,2],qm.a.fit)

## example on how to use spline.par
## (this example has little effect)
qm.b.fit &lt;- fitQmapSSPLIN(obsprecip[,2],modprecip[,2],
                          qstep=0.01,wet.day=TRUE,
                          spline.par=list(cv=TRUE))
qm.b &lt;- doQmapSSPLIN(modprecip[,2],qm.b.fit)

sqrtquant &lt;- function(x,qstep=0.01){
  qq &lt;- quantile(x,prob=seq(0,1,by=qstep))
  sqrt(qq)
}

plot(sqrtquant(modprecip[,2]),
     sqrtquant(obsprecip[,2]))
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.a),col="red")
lines(sqrtquant(modprecip[,2]),
      sqrtquant(qm.b),col="blue")
legend("topleft",legend=c("cv=FALSE","cv=TRUE"),
       lty=1,col=c("red","blue"))

qm2.fit &lt;- fitQmapSSPLIN(obsprecip,modprecip,
                      qstep=0.1,wet.day=TRUE)
qm2 &lt;- doQmapSSPLIN(modprecip,qm2.fit)


op &lt;- par(mfrow=c(1,3))
for(i in 1:3){
  plot(sqrtquant(modprecip[,i]),
       sqrtquant(obsprecip[,i]),
       main=names(qm2)[i])
  lines(sqrtquant(modprecip[,i]),
        sqrtquant(qm2[,i]),col="red")
}
par(op)

</code></pre>

<hr>
<h2 id='obsprecip'>Daily precipitation data at three locations in Norway.</h2><span id='topic+obsprecip'></span><span id='topic+modprecip'></span>

<h3>Description</h3>

<p>Observed (<code>obsprecip</code>) and simulated (<code>modprecip</code>) daily
precipitation data for three locations in Norway covering the 1961 -
1990 period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)
</code></pre>


<h3>Format</h3>

<p>Data frame(s) with rows representing days and with the following 3 variables.
</p>

<dl>
<dt><code>MOSS</code></dt><dd><p>Daily Precipitation at Moss [mm/day]</p>
</dd>
<dt><code>GEIRANGER</code></dt><dd><p>Daily Precipitation at Geiranger [mm/day]</p>
</dd>
<dt><code>BARKESTAD</code></dt><dd><p>Daily Precipitation at Barkestad [mm/day]</p>
</dd>
</dl>



<h3>Details</h3>

<p>The time series in <code>obsprecip</code> stem from the observation-system
of the Norwegian Meteorological Institute.
</p>
<p>The time series in <code>modprecip</code> are based on simulations of
HIRHAM2/NorACIA regional climate model forced with simulation the
HadAM3H. The simulation setup is further described in Forland et
al. 2011. The simulations are free-running and there is consequently
no direct correspondence in the temporal evolution of <code>modprecip</code>
and <code>obsprecip</code>.
</p>
<p>NOTE that all months in the modelled data (<code>modprecip</code>) have 30
days (in contrast to the observations (<code>obsprecip</code>) which have
true calender days. 
</p>


<h3>Source</h3>

<p>The observations are taken form the observation network of the
Norwegian meteorological institute (<a href="https://www.met.no/">https://www.met.no/</a>).
</p>


<h3>References</h3>

<p>Forland, E. J.; Benestad, R.; Hanssen-Bauer, I.; Haugen, J. E. &amp;
Skaugen, T. E. Temperature and Precipitation Development at Svalbard 
1900-2100. Advances in Meteorology, 2011, Volume 2011, 893790, 
&lt;doi:10.1155/2011/893790&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obsprecip)
data(modprecip)
</code></pre>

<hr>
<h2 id='startbernexp'>
Rough parameter estimate for the Bernoulli-Exponential distribution
</h2><span id='topic+startbernexp'></span>

<h3>Description</h3>

<p>Estimates rough starting values for the Bernoulli-Exponential distribution
using the method of moments for the <code>rate</code> parameter. The
probability of non-zero events is estimated as the fraction of values
that are larger than zero. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startbernexp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startbernexp_+3A_x">x</code></td>
<td>

<p>numeric vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>probability of non-zero event.</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>rate parameter of the Exponential distribution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this package <code>startbernexp</code> is intended to be used in
conjunction with <code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code> (and <code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>)
with parameter <code>distr="bernexp"</code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>, <code><a href="#topic+bernexp">bernexp</a></code>,
<code><a href="fitdistrplus.html#topic+fitdist">fitdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- rbernexp(n=300, prob=0.2, rate=1)
startbernexp(gg)
mledist(gg,"bernexp",startbernexp(gg))
</code></pre>

<hr>
<h2 id='startberngamma'>
Rough parameter estimate for the Bernoulli-Gamma distribution
</h2><span id='topic+startberngamma'></span>

<h3>Description</h3>

<p>Estimates rough starting values for the Bernoulli-Gamma distribution
using the method of moments for the <code>shape</code> and the <code>scale</code>
parameters. The probability of non-zero events is estimated as the
fraction of values that are larger than zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startberngamma(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startberngamma_+3A_x">x</code></td>
<td>

<p>numeric vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>probability of non-zero event.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scale parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>shape parameter of the gamma distribution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this package <code>startberngamma</code> is intended to be used in
conjunction with <code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code> (and <code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>)
with parameter <code>distr="berngamma"</code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>, <code><a href="#topic+berngamma">berngamma</a></code>,
<code><a href="fitdistrplus.html#topic+fitdist">fitdist</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- rberngamma(n=300, prob=0.2, scale=1, shape=1)
startberngamma(gg)
mledist(gg,"berngamma",startberngamma(gg))
</code></pre>

<hr>
<h2 id='startbernlnorm'>
Rough parameter estimate for the Bernoulli-Log-Normal distribution
</h2><span id='topic+startbernlnorm'></span>

<h3>Description</h3>

<p>Estimates rough starting values for the Bernoulli-Log-Normal distribution
using the method of moments for the <code>meanlog</code> and the <code>sdlog</code>
parameters. The probability of non-zero events is estimated as the
fraction of values that are larger than zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startbernlnorm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startbernlnorm_+3A_x">x</code></td>
<td>

<p>numeric vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>probability of non-zero event.</p>
</td></tr>
<tr><td><code>meanlog</code></td>
<td>
<p>meanlog parameter of the Log-Normal distribution.</p>
</td></tr>
<tr><td><code>sdlog</code></td>
<td>
<p>sdlog parameter of the Log-Normal distribution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this package <code>startbernlnorm</code> is intended to be used in
conjunction with <code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code> (and <code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>)
with parameter <code>distr="bernlnorm"</code>.
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>, <code><a href="#topic+bernlnorm">bernlnorm</a></code>,
<code><a href="fitdistrplus.html#topic+fitdist">fitdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- rbernlnorm(n=300, prob=0.2, meanlog=1, sdlog=1)
startbernlnorm(gg)
mledist(gg,"bernlnorm",startbernlnorm(gg))
</code></pre>

<hr>
<h2 id='startbernweibull'>
Rough parameter estimate for the Bernoulli-Weibull distribution
</h2><span id='topic+startbernweibull'></span>

<h3>Description</h3>

<p>Estimates rough starting values for the Bernoulli-Weibull distribution
using the method of moments for the <code>shape</code> and the <code>scale</code>
parameters. The probability of non-zero events is estimated as the
fraction of values that are larger than zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startbernweibull(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startbernweibull_+3A_x">x</code></td>
<td>

<p>numeric vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>probability of non-zero event.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scale parameter of the weibull distribution.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>shape parameter of the weibull distribution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this package <code>startbernweibull</code> is intended to be used in
conjunction with <code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code> (and
<code><a href="fitdistrplus.html#topic+mledist">mledist</a></code>) with parameter <code>distr="bernweibull"</code>. 
</p>


<h3>Author(s)</h3>

<p>Lukas Gudmundsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitQmapDIST">fitQmapDIST</a></code>, <code><a href="#topic+bernweibull">bernweibull</a></code>,
<code><a href="fitdistrplus.html#topic+fitdist">fitdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- rbernweibull(n=300, prob=0.2, scale=1, shape=1)
startbernweibull(gg)
mledist(gg,"bernweibull",startbernweibull(gg))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
