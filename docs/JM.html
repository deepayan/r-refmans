<!DOCTYPE html><html lang="en"><head><title>Help for package JM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JM'>
<p>Joint Modeling of Longitudinal and Time-to-Event Data in R</p></a></li>
<li><a href='#aids'><p>Didanosine versus Zalcitabine in HIV Patients</p></a></li>
<li><a href='#anova'><p>Anova Method for Fitted Joint Models</p></a></li>
<li><a href='#aucJM'><p>Time-Dependent AUCs for Joint Models</p></a></li>
<li><a href='#coef'><p>Estimated Coefficients for Joint Models</p></a></li>
<li><a href='#crLong'><p> Transform Competing Risks Data in Long Format</p></a></li>
<li><a href='#DerivSplines'><p> Derivatives and Integrals of B-splines and Natural Cubic splines</p></a></li>
<li><a href='#dynCJM'><p>A Dynamic Discrimination Index for Joint Models</p></a></li>
<li><a href='#fitted'><p>Fitted Values for Joint Models</p></a></li>
<li><a href='#jointModel'><p>Joint Models for Longitudinal and Survival Data</p></a></li>
<li><a href='#jointModelObject'><p>Fitted jointModel Object</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#piecewiseExp.ph'><p> Proportional Hazards Models with Piecewise Constant Baseline Hazard Function</p></a></li>
<li><a href='#plot'><p>Plot Diagnostics for Joint Models</p></a></li>
<li><a href='#plot.rocJM'><p>Plot Method for rocJM Objects</p></a></li>
<li><a href='#plot.survfitJM'><p>Plot Method for survfitJM Objects</p></a></li>
<li><a href='#prederrJM'><p>Prediction Errors for Joint Models</p></a></li>
<li><a href='#predict'><p>Predictions for Joint Models</p></a></li>
<li><a href='#prothro'><p>Prednisone versus Placebo in Liver Cirrhosis Patients</p></a></li>
<li><a href='#ranef'><p>Random Effects Estimates for Joint Models</p></a></li>
<li><a href='#residuals'><p>Residuals for Joint Models</p></a></li>
<li><a href='#rocJM'><p> Predictive Accuracy Measures for Longitudinal Markers under a Joint Modelling Framework</p></a></li>
<li><a href='#simulate'><p>Simulate from Joint Models.</p></a></li>
<li><a href='#summary.weibull.frailty'><p> Summary Method for weibull.frailty Objects</p></a></li>
<li><a href='#survfitJM'><p>Prediction in Joint Models</p></a></li>
<li><a href='#wald.strata'><p> Wald Test for Stratification Factors</p></a></li>
<li><a href='#weibull.frailty'><p> Weibull Model with Gamma Frailties</p></a></li>
<li><a href='#xtable'><p>xtable Method from Joint Models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Joint Modeling of Longitudinal and Survival Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Shared parameter models for the joint modeling of longitudinal and time-to-event data. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), MASS, nlme, splines, survival</td>
</tr>
<tr>
<td>Enhances:</td>
<td>xtable</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://jmr.r-forge.r-project.org/">http://jmr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-08 12:58:55 UTC; drizo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-08 13:40:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='JM'>
Joint Modeling of Longitudinal and Time-to-Event Data in R
</h2><span id='topic+JM-package'></span><span id='topic+JM'></span>

<h3>Description</h3>

<p>This package fits shared parameter models for the joint modeling of normal longitudinal responses and event times 
under a maximum likelihood approach. Various options for the survival model and optimization/integration algorithms are 
provided.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> JM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> <abbr><span class="acronym">GPL</span></abbr> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package has a single model-fitting function called <code><a href="#topic+jointModel">jointModel</a></code>, which accepts as main arguments a linear
mixed effects object fit returned by function <code>lme()</code> of package <span class="pkg">nlme</span>, and a survival object fit returned 
by either function <code>coxph()</code> or function <code>survreg()</code> of package <span class="pkg">survival</span>. In addition, the <code>method</code>
argument of <code>jointModel()</code> specifies the type of the survival submodel to be fitted and the type of the numerical 
integration technique; available options are:
</p>

<dl>
<dt><code>"Cox-PH-GH"</code></dt><dd><p>the time-dependent version of a proportional hazards model with unspecified baseline hazard 
function. The Gauss-Hermite integration rule is used to approximate the required integrals. (This option 
corresponds to the joint model proposed by Wulfsohn and Tsiatis, 1997)</p>
</dd>
<dt><code>"weibull-PH-GH"</code></dt><dd><p>the Weibull model under the proportional hazards formulation. The Gauss-Hermite 
integration rule is used to approximate the required integrals.</p>
</dd>
<dt><code>"weibull-AFT-GH"</code></dt><dd><p>the Weibull model under the accelerated failure time formulation. The Gauss-Hermite 
integration rule is used to approximate the required integrals.</p>
</dd>
<dt><code>"piecewise-PH-GH"</code></dt><dd><p>a proportional hazards model with a piecewise constant baseline risk function. The Gauss-Hermite 
integration rule is used to approximate the required integrals.</p>
</dd>    
<dt><code>"spline-PH-GH"</code></dt><dd><p>a proportional hazards model, in which the log baseline hazard is 
approximated using B-splines. The Gauss-Hermite integration rule is used to approximate the required integrals.</p>
</dd>
<dt><code>"ch-Laplace"</code></dt><dd><p>an additive log cumulative hazard model, in which the log cumulative baseline hazard is 
approximated using B-splines. A fully exponential Laplace approximation method is used to approximate the 
required integrals (Rizopoulos et al., 2009).</p>
</dd>
</dl>

<p>For all the above mentioned options (except the last one), a pseudo-adaptive Gauss-Hermite integration rule is also available
(Rizopoulos, 2012b). This is much faster than the classical Gauss-Hermite rule, and in several simulations it has been 
shown to perform equally well (though its performance is still under investigation).
</p>
<p>The package also offers several utility functions that can extract useful information from fitted joint models. The most
important of those are included in the <b>See also</b> section below.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos
</p>
<p>Maintainer: Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;
</p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2000) Joint modelling of longitudinal measurements 
and event time data. <em>Biostatistics</em> <b>1</b>, 465&ndash;480.
</p>
<p>Rizopoulos, D. (2012a) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2012b) Fast fitting of joint models for longitudinal and event time data using a 
pseudo-adaptive Gaussian quadrature rule. <em>Computational Statistics and Data Analysis</em> <b>56</b>, 491&ndash;501.
</p>
<p>Rizopoulos, D. (2011) Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. (2010) JM: An R package for the joint modelling of longitudinal and time-to-event data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>
<p>Rizopoulos, D., Verbeke, G. and Lesaffre, E. (2009) Fully exponential Laplace approximation for the joint
modelling of survival and longitudinal data. <em>Journal of the Royal Statistical Society, Series B</em> 
<b>71</b>, 637&ndash;654.
</p>
<p>Rizopoulos, D., Verbeke, G. and Molenberghs, G. (2010) Multiple-imputation-based residuals and diagnostic 
plots for joint models of longitudinal and survival outcomes. <em>Biometrics</em> <b>66</b>, 20&ndash;29.
</p>
<p>Tsiatis, A. and Davidian, M. (2004) Joint modeling of longitudinal and time-to-event data: an overview. 
<em>Statistica Sinica</em> <b>14</b>, 809&ndash;834.
</p>
<p>Wulfsohn, M. and Tsiatis, A. (1997) A joint model for survival and longitudinal data measured with error. 
<em>Biometrics</em> <b>53</b>, 330&ndash;339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code>,
<code><a href="#topic+survfitJM">survfitJM</a></code>,
<code><a href="#topic+rocJM">rocJM</a></code>,
<code><a href="#topic+aucJM">aucJM</a></code>,
<code><a href="#topic+dynCJM">dynCJM</a></code>,
<code><a href="#topic+prederrJM">prederrJM</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>
</p>

<hr>
<h2 id='aids'>Didanosine versus Zalcitabine in HIV Patients</h2><span id='topic+aids'></span><span id='topic+aids.id'></span>

<h3>Description</h3>

<p>A randomized clinical trial in which both longitudinal and survival data were collected to compare the efficacy and 
safety of two antiretroviral drugs in treating patients who had failed or were intolerant of zidovudine (AZT) therapy.
</p>


<h3>Format</h3>

<p>A data frame with 1408 observations on the following 9 variables.
</p>

<dl>
<dt><code>patient</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>Time</code></dt><dd><p>the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>CD4</code></dt><dd><p>the CD4 cells count.</p>
</dd>
<dt><code>obstime</code></dt><dd><p>the time points at which the CD4 cells count was recorded.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>ddC</code> denoting zalcitabine and <code>ddI</code> denoting didanosine.</p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>female</code> and <code>male</code>.</p>
</dd>
<dt><code>prevOI</code></dt><dd><p>a factor with levels <code>AIDS</code> denoting previous opportunistic infection (AIDS 
diagnosis) at study entry, and <code>noAIDS</code> denoting no previous infection.</p>
</dd>
<dt><code>AZT</code></dt><dd><p>a factor with levels <code>intolerance</code> and <code>failure</code> denoting AZT intolerance and 
AZT failure, respectively.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>aids.id</code> contains the first CD4 cell count measurement for each patient. This data frame is used to 
fit the survival model.
</p>


<h3>References</h3>

<p>Goldman, A., Carlin, B., Crane, L., Launer, C., Korvick, J., Deyton, L. and Abrams, D. (1996) Response of CD4+ and
clinical consequences to treatment using ddI or ddC in patients with advanced HIV infection. <em>Journal of Acquired
Immune Deficiency Syndromes and Human Retrovirology</em> <b>11</b>, 161&ndash;169.
</p>
<p>Guo, X. and Carlin, B. (2004) Separate and joint modeling of longitudinal and event time data using standard
computer packages. <em>The American Statistician</em> <b>58</b>, 16&ndash;24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(aids.id)
</code></pre>

<hr>
<h2 id='anova'>Anova Method for Fitted Joint Models</h2><span id='topic+anova.jointModel'></span>

<h3>Description</h3>

<p>Produces marginal Wald tests or Performs a likelihood 
ratio test between two nested joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
anova(object, object2, test = TRUE, 
   process = c("both", "Longitudinal", "Event"), L = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>, nested in <code>object2</code>.</p>
</td></tr>
<tr><td><code id="anova_+3A_object2">object2</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="anova_+3A_test">test</code></td>
<td>
<p>logical; if <code>TRUE</code> the likelihood ratio test is performed.</p>
</td></tr>
<tr><td><code id="anova_+3A_process">process</code></td>
<td>
<p>for which of the two submodels to produce the marginal Wald tests table.</p>
</td></tr>
<tr><td><code id="anova_+3A_l">L</code></td>
<td>
<p>a numeric matrix of appropriate dimensions defining the contrasts of interest.</p>
</td></tr>
<tr><td><code id="anova_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>aov.jointModel</code> with components,
</p>
<table role = "presentation">
<tr><td><code>nam0</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
<tr><td><code>L0</code></td>
<td>
<p>the log-likelihood under the null hypothesis (<code>object</code>).</p>
</td></tr>
<tr><td><code>aic0</code></td>
<td>
<p>the AIC value for the model given by <code>object</code>.</p>
</td></tr>
<tr><td><code>bic0</code></td>
<td>
<p>the BIC value for the model given by <code>object</code>. </p>
</td></tr>
<tr><td><code>nam1</code></td>
<td>
<p>the name of <code>object2</code>.</p>
</td></tr>
<tr><td><code>L1</code></td>
<td>
<p>the log-likelihood under the alternative hypothesis (<code>object2</code>).</p>
</td></tr>
<tr><td><code>aic1</code></td>
<td>
<p>the AIC value for the model given by <code>object2</code>.</p>
</td></tr>
<tr><td><code>bic1</code></td>
<td>
<p>the BIC value for the model given by <code>object2</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom for the test (i.e., the difference in the number of parameters).</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>the value of the Likelihood Ratio Test statistic (returned if <code>test = TRUE</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the <code class="reqn">p</code>-value of the test (returned if <code>test = TRUE</code>).</p>
</td></tr>
<tr><td><code>aovTab.Y</code></td>
<td>
<p>a data.frame with the marginal Wald tests for the longitudinal process; 
produced only when <code>object2</code> is missing.</p>
</td></tr>
<tr><td><code>aovTab.T</code></td>
<td>
<p>a data.frame with the marginal Wald tests for the event process; 
produced only when <code>object2</code> is missing.</p>
</td></tr>
<tr><td><code>aovTab.L</code></td>
<td>
<p>a data.frame with the marginal Wald tests for the user-defined contrasts matrix; 
produced only when <code>object2</code> is missing and <code>L</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The code minimally checks whether the models are nested! The user is responsible to supply nested models in
order the LRT to be valid.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2010) JM: An R Package for the Joint Modelling of Longitudinal and Time-to-Event Data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit without treatment effect
fitLME.null &lt;- lme(sqrt(CD4) ~ obstime, 
    random = ~ 1 | patient, data = aids)
# cox model fit without treatment effect
fitCOX.null &lt;- coxph(Surv(Time, death) ~ 1, 
    data = aids.id, x = TRUE)
# joint model fit without treatment effect
fitJOINT.null &lt;- jointModel(fitLME.null, fitCOX.null, 
    timeVar = "obstime", method = "weibull-PH-aGH")

# linear mixed model fit with treatment effect
fitLME.alt &lt;- lme(sqrt(CD4) ~ obstime * drug - drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit with treatment effect
fitCOX.alt &lt;- coxph(Surv(Time, death) ~ drug, 
    data = aids.id, x = TRUE)
# joint model fit with treatment effect
fitJOINT.alt &lt;- jointModel(fitLME.alt, fitCOX.alt, timeVar = "obstime", 
    method = "weibull-PH-aGH")

# likelihood ratio test for treatment effect
anova(fitJOINT.null, fitJOINT.alt)

## End(Not run)
</code></pre>

<hr>
<h2 id='aucJM'>Time-Dependent AUCs for Joint Models</h2><span id='topic+aucJM'></span><span id='topic+aucJM.jointModel'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a starting time point, this function computes an estimate 
of the prediction error of survival at a horizon time point based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aucJM(object, newdata, Tstart, ...)

## S3 method for class 'jointModel'
aucJM(object, newdata, Tstart, Thoriz = NULL, 
    Dt = NULL, idVar = "id", simulate = FALSE, M = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aucJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModel">jointModel</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="aucJM_+3A_tstart">Tstart</code></td>
<td>
<p>numeric scalar denoting the time point up to which longitudinal information is to be used to derive predictions.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_thoriz">Thoriz</code></td>
<td>
<p>numeric scalar denoting the time point for which a prediction of the survival status is of interest; 
<code>Thoriz</code> mast be later than <code>Tstart</code> and either <code>Dt</code> or <code>Thoriz</code> must be specified. If <code>Thoriz</code> is <code>NULL</code>
is set equal to <code>Tstart + Dt</code>.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_dt">Dt</code></td>
<td>
<p>numeric scalar denoting the length of the time interval of prediction; either <code>Dt</code> or <code>Thoriz</code> must be specified.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>) and using the data supplied in argument <code>newdata</code>, this function
computes the following estimate of the AUC: </p>
<p style="text-align: center;"><code class="reqn">\mbox{AUC}(t, \Delta t) = \mbox{Pr} \bigl [ \pi_i(t + \Delta t \mid t) &lt; 
\pi_j(t + \Delta t \mid t) \mid \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + \Delta t \} \bigr ],</code>
</p>

<p>with <code class="reqn">i</code> and <code class="reqn">j</code> denote a randomly selected pair of subjects, and
<code class="reqn">\pi_i(t + \Delta t \mid t)</code> and <code class="reqn">\pi_j(t + \Delta t \mid t)</code> denote the conditional survival probabilities calculated by
<code><a href="#topic+survfitJM">survfitJM</a></code> for these two subjects, for different time windows <code class="reqn">\Delta t</code> specified by argument <code>Dt</code> using
the longitudinal information recorded up to time <code>t =</code> <code>Tstart</code>.
</p>
<p>The estimate of <code class="reqn">\mbox{AUC}(t, \Delta t)</code> provided by <code>aucJM()</code> is in the spirit of Harrell's 
<code class="reqn">c</code>-index, that is for the comparable subjects (i.e., the ones whose observed event times can be ordered), we 
compare their dynamic survival probabilities calculated by <code><a href="#topic+survfitJM">survfitJM</a></code>. As with Harrell's <code class="reqn">c</code>-index, 
<code class="reqn">\mbox{AUC}(t, \Delta t)</code> does not fully take into account censoring, and therefore is expected to mask the 
true discriminative capability of the joint model under heavy censoring.
</p>


<h3>Value</h3>

<p>A list of class <code>aucJM</code> with components:
</p>
<table role = "presentation">
<tr><td><code>auc</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Antolini, L., Boracchi, P., and Biganzoli, E. (2005). A time-dependent discrimination index
for survival data. <em>Statistics in Medicine</em> <b>24</b>, 3927&ndash;3944.
</p>
<p>Harrell, F., Kerry, L. and Mark, D. (1996). Multivariable prognostic models: issues in 
developing models, evaluating assumptions and adequacy, and measuring and reducing errors.
<em>Statistics in Medicine</em> <b>15</b>, 361&ndash;387.
</p>
<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves. 
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D., Murawska, M., Andrinopoulou, E.-R., Lesaffre, E. and Takkenberg, J. (2013). 
Dynamic predictions with time-dependent covariates in survival analysis: A comparison between 
joint modeling and landmarking. <em>under preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModel(lmeFit, survFit, timeVar = "year", 
    method = "piecewise-PH-aGH")

# AUC using data up to year 5 with horizon at year 8
aucJM(jointFit, pbc2, Tstart = 5, Thoriz = 8)

## End(Not run)
</code></pre>

<hr>
<h2 id='coef'>Estimated Coefficients for Joint Models</h2><span id='topic+coef.jointModel'></span><span id='topic+fixef.jointModel'></span>

<h3>Description</h3>

<p>Extracts estimated coefficients from fitted joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
coef(object, process = c("Longitudinal", "Event"), 
    include.splineCoefs = FALSE, ...)
## S3 method for class 'jointModel'
fixef(object, process = c("Longitudinal", "Event"), 
    include.splineCoefs = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="coef_+3A_process">process</code></td>
<td>
<p>for which model (i.e., linear mixed model or survival model) to extract the estimated 
coefficients.</p>
</td></tr>
<tr><td><code id="coef_+3A_include.splinecoefs">include.splineCoefs</code></td>
<td>
<p>logical; if <code>TRUE</code> and the method argument in <code>jointModel()</code> is 
<code>"ch-Laplace"</code>, the estimated B-spline coefficients are included as well.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>process = "Event"</code> both methods return the same output. However, for <code>process = "Longitudinal"</code>,
the <code>coef()</code> method returns the subject-specific coefficients, whereas <code>fixef()</code> only the fixed effects.
</p>


<h3>Value</h3>

<p>A numeric vector or a matrix of the estimated parameters for the fitted model.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.jointModel">ranef.jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime * drug - drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# joint model fit
fitJOINT &lt;- jointModel(fitLME, fitCOX, 
    timeVar = "obstime")

# fixed effects for the longitudinal process
fixef(fitJOINT)

# fixed effects + random effects estimates for the longitudinal 
# process
coef(fitJOINT)

# fixed effects for the event process
fixef(fitJOINT, process = "Event")
coef(fitJOINT, process = "Event")

## End(Not run)
</code></pre>

<hr>
<h2 id='crLong'> Transform Competing Risks Data in Long Format </h2><span id='topic+crLong'></span>

<h3>Description</h3>

<p>In a competing risks setting this function expands the data frame with a
single row per subject to the a data frame in long format in which each
subject has as many rows as the number of competing events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crLong(data, statusVar, censLevel,
    nameStrata = "strata", nameStatus = "status2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crLong_+3A_data">data</code></td>
<td>
<p>the data frame containing the competing risk data with a single
row per subject.</p>
</td></tr>
<tr><td><code id="crLong_+3A_statusvar">statusVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>data</code> that identifies the status variable which equals 1 if the
subject had any of the competing events and 0 otherwise.</p>
</td></tr>
<tr><td><code id="crLong_+3A_censlevel">censLevel</code></td>
<td>
<p>a character string or a scalar denoting the censoring level
in the <code>statusVar</code> variable of <code>data</code>.</p>
</td></tr>
<tr><td><code id="crLong_+3A_namestrata">nameStrata</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting the various causes of event.</p>
</td></tr>
<tr><td><code id="crLong_+3A_namestatus">nameStatus</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting if the subject experience any
of the competing events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in the long format with multiple rows per subject.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Putter, H., Fiocco, M., and Geskus, R. (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(crLong(pbc2.id, "status", "alive"))
</code></pre>

<hr>
<h2 id='DerivSplines'> Derivatives and Integrals of B-splines and Natural Cubic splines </h2><span id='topic+dns'></span><span id='topic+dbs'></span><span id='topic+ins'></span><span id='topic+ibs'></span>

<h3>Description</h3>

<p>Numerical derivatives and integrals of functions <code>bs()</code> and <code>ns()</code> at their first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dns(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), eps = 1e-03)

dbs(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), eps = 1e-03)

ins(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), from = 0, weight.fun = NULL, ...)

ibs(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), from = 0, weight.fun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DerivSplines_+3A_x">x</code>, <code id="DerivSplines_+3A_df">df</code>, <code id="DerivSplines_+3A_knots">knots</code>, <code id="DerivSplines_+3A_intercept">intercept</code>, <code id="DerivSplines_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>see the help pages of functions <code>ns()</code> and <code>bs()</code>.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_eps">eps</code></td>
<td>
<p>a numeric scalar denoting the step length for the central difference approximation, which
calculates the derivative.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_from">from</code></td>
<td>
<p>a numeric scalar denoting the lower limit of the integral.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_weight.fun">weight.fun</code></td>
<td>
<p>a function to applied as weights.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>weight.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dns</code>, <code>dbs</code>, <code>ins</code> or <code>ibs</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
dns(x, df = 4)
ins(x, df = 4)
</code></pre>

<hr>
<h2 id='dynCJM'>A Dynamic Discrimination Index for Joint Models</h2><span id='topic+dynCJM'></span><span id='topic+dynCJM.jointModel'></span>

<h3>Description</h3>

 
<p>This function computes a dynamic discrimination index for joint models based on a weighted average of time-dependent AUCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynCJM(object, newdata, Dt, ...)

## S3 method for class 'jointModel'
dynCJM(object, newdata, Dt, idVar = "id", t.max = NULL, 
    simulate = FALSE, M = 100, weightFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynCJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModel">jointModel</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_dt">Dt</code></td>
<td>
<p>a numeric scalar denoting the time frame within which the occurrence of events is of interest.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_t.max">t.max</code></td>
<td>
<p>a numeric scalar denoting the time maximum follow-up time up to which the dynamic discrimination index is to be calculated.
If <code>NULL</code>, it is set equal to <code>max(Time) + 1e-05</code> where <code>Time</code> denotes the observed event times.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_weightfun">weightFun</code></td>
<td>
<p>a function of two arguments the first denoting time and the second the length of the time frame of interest, i.e., <code>Dt</code>.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(<b>Note:</b> The following contain some math formulas, which are better viewed in the pdf version 
of the manual accessible at <a href="https://cran.r-project.org/package=JM">https://cran.r-project.org/package=JM</a>.)
</p>
<p>Function <code>dynC</code> computes the following discrimination index
</p>
<p style="text-align: center;"><code class="reqn">\mbox{C}_{dyn}^{\Delta t} = \int_0^{t_{max}} \mbox{AUC}(t, \Delta t) \, 
\mbox{Pr} \{ {\cal E}(t, \Delta t) \} \; dt \Big / \int_0^{t_{max}} \mbox{Pr} \{ {\cal E}(t, \Delta t) \} \; dt,</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\mbox{AUC}(t, \Delta t) = \mbox{Pr} \bigl [ \pi_i(t + \Delta t \mid t) &lt; 
\pi_j(t + \Delta t \mid t) \mid \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + \Delta t \} \bigr ],</code>
</p>

<p>and </p>
<p style="text-align: center;"><code class="reqn">{\cal E}(t, \Delta t) = \bigl [ \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + 
\Delta t \} \bigr ],</code>
</p>
<p> with <code class="reqn">i</code> and <code class="reqn">j</code> denote a randomly selected pair subjects, and
<code class="reqn">\pi_i(t + \Delta t \mid t)</code> and <code class="reqn">\pi_j(t + \Delta t \mid t)</code> denote the conditional survival probabilities calculated by
<code><a href="#topic+survfitJM">survfitJM</a></code> for these two subjects, for different time windows <code class="reqn">\Delta t</code> specified by argument <code>Dt</code>. 
The upper limit of integral in specified by argument <code>t.max</code>. The integrals in the numerator and denominator 
are approximated using a 15-point Gauss-Kronrod quadrature rule.
</p>
<p>Index <code class="reqn">\mbox{C}_{dyn}^{\Delta t}</code> is in the spirit of Harrell's <code class="reqn">c</code>-index, that is for the comparable 
subjects (i.e., the ones whose observed event times can be ordered), we compare their dynamic survival
probabilities calculated by <code><a href="#topic+survfitJM">survfitJM</a></code>. As with Harrell's <code class="reqn">c</code>-index, 
<code class="reqn">\mbox{C}_{dyn}^{\Delta t}</code> does not take into account censoring, and therefore is expected to mask the 
true discriminative capability of the joint model under heavy censoring.
</p>


<h3>Value</h3>

<p>A list of class <code>dynCJM</code> with components:
</p>
<table role = "presentation">
<tr><td><code>dynC</code></td>
<td>
<p>a numeric scalar denoting the dynamic discrimination index.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>a numeric vector of time points at which the AUC was calculated.</p>
</td></tr>
<tr><td><code>AUCs</code></td>
<td>
<p>a numeric vector of the estimated AUCs at the aforementioned time points.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a numeric vector of the estimated weights at the aforementioned time points.</p>
</td></tr>
<tr><td><code>t.max</code></td>
<td>
<p>a copy of the <code>t.max</code> argument.</p>
</td></tr>
<tr><td><code>Dt</code></td>
<td>
<p>a copy of the <code>Dt</code> argument.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Antolini, L., Boracchi, P., and Biganzoli, E. (2005). A time-dependent discrimination index
for survival data. <em>Statistics in Medicine</em> <b>24</b>, 3927&ndash;3944.
</p>
<p>Harrell, F., Kerry, L. and Mark, D. (1996). Multivariable prognostic models: issues in 
developing models, evaluating assumptions and adequacy, and measuring and reducing errors.
<em>Statistics in Medicine</em> <b>15</b>, 361&ndash;387.
</p>
<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves. 
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D., Murawska, M., Andrinopoulou, E.-R., Lesaffre, E. and Takkenberg, J. (2013). 
Dynamic predictions with time-dependent covariates in survival analysis: A comparison between 
joint modeling and landmarking. <em>under preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+aucJM">aucJM</a></code>, <code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModel(lmeFit, survFit, timeVar = "year", 
    method = "piecewise-PH-aGH")

# dynamic discrimination index up to year 10 using a two-year interval 
dynCJM(jointFit, pbc2, Dt = 2, t.max = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted'>Fitted Values for Joint Models</h2><span id='topic+fitted.jointModel'></span>

<h3>Description</h3>

<p>Calculates fitted values for joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
fitted(object, process = c("Longitudinal", "Event"), 
type = c("Marginal", "Subject", "EventTime", "Slope"), scale = c("survival", 
"cumulative-Hazard", "log-cumulative-Hazard"), M = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="fitted_+3A_process">process</code></td>
<td>
<p>for which model (i.e., linear mixed model or survival model) to calculate the fitted values.</p>
</td></tr>
<tr><td><code id="fitted_+3A_type">type</code></td>
<td>
<p>what type of fitted values to calculate for the survival outcome. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="fitted_+3A_scale">scale</code></td>
<td>
<p>in which scale to calculate; relevant only when <code>process = "Event"</code>.</p>
</td></tr>
<tr><td><code id="fitted_+3A_m">M</code></td>
<td>
<p>how many times to simulate random effects; see <b>Details</b> for more info.</p>
</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>process = "Longitudinal"</code>, let <code class="reqn">X</code> denote the design matrix for the fixed effects <code class="reqn">\beta</code>, and 
<code class="reqn">Z</code> the design matrix for the random effects <code class="reqn">b</code>. Then for <code>type = "Marginal"</code> the fitted values are 
<code class="reqn">X \hat{\beta},</code> whereas for <code>type = "Subject"</code> they are <code class="reqn">X \hat{\beta} + Z \hat{b}</code>. For <code>type = "EventTime"</code> 
is the same as <code>type = "Subject"</code> but evaluated at the observed event times. Finally, <code>type == "Slope"</code>
returns <code class="reqn">Xs \hat{\beta} + Zs \hat{b}</code> where <code class="reqn">Xs</code> and <code class="reqn">Zs</code> denote the fixed- and random-effects design
matrices corresponding to the slope term which is specified in the <code>derivForm</code> argument of <code><a href="#topic+jointModel">jointModel</a></code>.
</p>
<p>For <code>process = "Event"</code> and <code>type = "Subject"</code> the linear predictor conditional on the random effects 
estimates is calculated for each sample unit. Depending on the value of the <code>scale</code> argument the fitted survival 
function, cumulative hazard function or log cumulative hazard function is returned. For <code>type = "Marginal"</code>, 
random effects values for each sample unit are simulated <code>M</code> times from a normal distribution with zero mean and 
covariance matrix the estimated covariance matrix for the random effects. The marginal survival function for the 
<code class="reqn">i</code>th sample unit is approximated by </p>
<p style="text-align: center;"><code class="reqn">S_i(t) = \int S_i(t | b_i) p(b_i) db_i \approx (1/M) \sum_{m = 1}^M 
  S_i(t | b_{im}),</code>
</p>
<p> where <code class="reqn">p(b_i)</code> denotes the normal probability density function, and <code class="reqn">b_{im}</code> the <code class="reqn">m</code>th 
simulated value for the random effect of the <code class="reqn">i</code>th sample unit. The cumulative hazard and log cumulative hazard 
functions are calculated as <code class="reqn">H_i(t) = - \log S_i(t)</code> and <code class="reqn">\log H_i(t) = \log \{ - \log S_i(t)\},</code> respectively.
</p>


<h3>Value</h3>

<p>a numeric vector of fitted values.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2010) JM: An R Package for the Joint Modelling of Longitudinal and Time-to-Event Data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.jointModel">residuals.jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, 
    random = ~ 1 | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, 
    data = pbc2.id, x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")

# fitted for the longitudinal process
head(cbind(
    "Marg" = fitted(fitJOINT), 
    "Subj" = fitted(fitJOINT, type = "Subject")
))

# fitted for the event process - survival function
head(cbind(
    "Marg" = fitted(fitJOINT, process = "Ev"), 
    "Subj" = fitted(fitJOINT, process = "Ev", type = "Subject")
))

# fitted for the event process - cumulative hazard function
head(cbind(
    "Marg" = fitted(fitJOINT, process = "Ev", 
        scale = "cumulative-Hazard"), 
    "Subj" = fitted(fitJOINT, process = "Ev", type = "Subject", 
        scale = "cumulative-Hazard")
))

## End(Not run)
</code></pre>

<hr>
<h2 id='jointModel'>Joint Models for Longitudinal and Survival Data</h2><span id='topic+jointModel'></span>

<h3>Description</h3>

<p>This function fits shared parameter models for the joint modelling of normal longitudinal responses and time-to-event
data under a maximum likelihood approach. Various options for the survival model are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointModel(lmeObject, survObject, timeVar, 
  parameterization = c("value", "slope", "both"),
  method = c("weibull-PH-aGH", "weibull-PH-GH", "weibull-AFT-aGH", 
    "weibull-AFT-GH", "piecewise-PH-aGH", "piecewise-PH-GH", 
    "Cox-PH-aGH", "Cox-PH-GH", "spline-PH-aGH", "spline-PH-GH", 
    "ch-Laplace"),
  interFact = NULL, derivForm = NULL, lag = 0, scaleWB = NULL,
  CompRisk = FALSE, init = NULL, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointModel_+3A_lmeobject">lmeObject</code></td>
<td>
<p>an object inheriting from class <code>lme</code> (see also <b>Note</b>).</p>
</td></tr>
<tr><td><code id="jointModel_+3A_survobject">survObject</code></td>
<td>
<p>an object inheriting from class <code>coxph</code> or class <code>survreg</code>. In the call to <code>coxph()</code>
or <code>survreg()</code>, you need to specify the argument <code>x = TRUE</code> such that the design matrix is contained in 
the object fit. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_timevar">timeVar</code></td>
<td>
<p>a character string indicating the time variable in the linear mixed effects model.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_parameterization">parameterization</code></td>
<td>
<p>a character string indicating the type of parameterization. See <b>Details</b></p>
</td></tr>
<tr><td><code id="jointModel_+3A_method">method</code></td>
<td>
<p>a character string specifying the type of joint model to fit. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_interfact">interFact</code></td>
<td>
<p>a list with components <code>value</code> a formula for the interaction terms corresponding to the
<code>value</code> parameterization, <code>slope</code> a formula for the interaction terms corresponding to the
<code>slope</code> parameterization, <code>data</code> a data frame containing these variables (this should have the same
number of rows and ordering of subjects, as the one in <code>survObject</code>).</p>
</td></tr>
<tr><td><code id="jointModel_+3A_derivform">derivForm</code></td>
<td>
<p>a list with components <code>fixed</code> a formula representing the derivative of the fixed-effects part of the 
liner mixed model with respect to time, <code>indFixed</code> a numeric vector indicating which fixed effects of <code>lmeObject</code> 
correspond to the derivative, <code>random</code> a formula representing the derivative of the random-effects part of the 
liner mixed model with respect to time, and <code>indRamdom</code> a numeric vector indicating which random effects of <code>lmeObject</code> 
correspond to the derivative. When a random intercepts linear mixed model is assumed, then <code>random = ~ 1</code> and 
<code>indRandom = FALSE</code>. Required only when <code>parameterization == "slope"</code> or <code>parameterization == "both"</code>. 
See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_lag">lag</code></td>
<td>
<p>a numeric scalar denoting a lag effect in the time-dependent covariate represented by the mixed model; default is 0.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_scalewb">scaleWB</code></td>
<td>
<p>a numeric scalar denoting a fixed value for the scale parameter of the Weibull hazard; used only when 
<code>method = "weibull-AFT-GH"</code> or <code>method = "weibull-PH-GH"</code>. The default <code>NULL</code> means that the scale 
parameter is estimated.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_comprisk">CompRisk</code></td>
<td>
<p>logical; should a competing risks joint model be fitted.</p>
</td></tr>
<tr><td><code id="jointModel_+3A_init">init</code></td>
<td>
<p>a named list of user-specified initial values:
</p>

<dl>
<dt>betas</dt><dd><p>the vector of fixed effects for the linear mixed effects model.</p>
</dd>
<dt>sigma</dt><dd><p>the measurement error standard deviation for the linear mixed effects model.</p>
</dd>
<dt>D</dt><dd><p>the variance-covariance matrix of the random effects.</p>
</dd>
<dt>gammas</dt><dd><p>the vector of baseline covariates for the survival model. For <code>method = "ch-Laplace"</code> this vector should 
first contain initial values for the sorted B-spline coefficients used to model the log cumulative baseline hazard.</p>
</dd>
<dt>alpha</dt><dd><p>the association parameters.</p>
</dd>
<dt>Dalpha</dt><dd><p>the association parameters for the true slopes parameterization</p>
</dd>
<dt>xi</dt><dd><p>the vector of baseline risk function values within the intervals specified by the knots; specified only 
when <code>method = "piecewise-PH-GH"</code>.</p>
</dd>
<dt>gammas.bs</dt><dd><p>the vector of spline coefficients; specified only when <code>method = "spline-PH-GH"</code>.</p>
</dd>
<dt>sigma.t</dt><dd><p>the scale parameter for the Weibull baseline risk function; specified only when 
<code>method = "weibull-AFT-GH"</code> or <code>method = "weibull-PH-GH"</code>.</p>
</dd>
<dt>lambda0</dt><dd><p>a vector of the baseline hazard values at the sorted unique event times; specified only when 
<code>method = "Cox-PH-GH"</code>.</p>
</dd>
</dl>

<p>When this list of initial values does not contain some of these components or contains components 
not of the appropriate length, then the default initial values are used instead.
</p>
</td></tr>
<tr><td><code id="jointModel_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>

<dl>
<dt>only.EM</dt><dd><p>logical; if <code>TRUE</code> only the EM algorithm is used in the optimization, otherwise if 
convergence has not been achieved a quasi-Newton algorithm is initiated. Default is <code>FALSE</code> except for 
<code>method = "Cox-PH-GH"</code> for which only the EM algorithm is available.</p>
</dd>
<dt>iter.EM</dt><dd><p>the number of EM iterations. Default is 50 except for <code>method = "Cox-PH-GH"</code> for which
the default is 200.</p>
</dd>
<dt>iter.qN</dt><dd><p>the number of quasi-Newton iterations. Default is 150.</p>
</dd>
<dt>optimizer</dt><dd><p>a character string indicating which optimizer to use; options are &quot;optim&quot; (default) and
&quot;nlminb&quot;.</p>
</dd>
<dt>tol1</dt><dd><p>tolerance value for convergence in the parameters; see <b>Details</b>. Default is 1e-03.</p>
</dd>
<dt>tol2</dt><dd><p>tolerance value for convergence in the parameters; see <b>Details</b>. Default is 1e-04.</p>
</dd>
<dt>tol3</dt><dd><p>tolerance value for convergence in the log-likelihood; see <b>Details</b>. Default is 
<code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
<dt>numeriDeriv</dt><dd><p>a character string indicating which type of numerical derivative to use to compute the
Hessian matrix; options are &quot;fd&quot; (default) denoting the forward difference approximation, and &quot;cd&quot; 
denoting the central difference approximation.</p>
</dd>
<dt>eps.Hes</dt><dd><p>tolerance value used in the numerical derivative method. Default is 1e-06; if you choose 
<code>numeriDeriv = "cd"</code> a larger value (e.g., 1e-04) is suggested.</p>
</dd>
<dt>parscale</dt><dd><p>the <code>parscale</code> control argument for <code>optim()</code>, or the <code>scale</code> argument for 
<code>nlminb()</code>. It should be a numeric vector of length equal to the number of parameters. Default is 0.01
for all parameters.</p>
</dd>
<dt>step.max</dt><dd><p>tolerance value for the maximum step size in the Newton-Raphson algorithm used to update the 
parameters of the survival submodel for <code>method = "ch-Laplace"</code>. Default is 0.1.</p>
</dd>
<dt>backtrackSteps</dt><dd><p>the number of backtrack steps to use when updating the parameters of the survival submodel
under <code>method = "ch-Laplace"</code>.</p>
</dd>
<dt>knots</dt><dd><p>a numeric vector of the knots positions for the piecewise constant baseline risk function of for 
the log times used in the B-splines approximation of the log cumulative baseline hazard; therefore, this argument 
is relevant only when <code>method = "piecewise-PH-GH"</code>, <code>method = "spline-PH-GH"</code> or <code>method = "ch-Laplace"</code>. 
The default is to place equally-spaced <code>lng.in.kn</code> knots in the quantiles of the observed event times. For stratified models
fitted with <code>method = "spline-PH-GH"</code> this should be a list with elements numeric vectors of knots positions for each strata.</p>
</dd>
<dt>ObsTimes.knots</dt><dd><p>logical; if <code>TRUE</code> (default) the positions of the knots are specified based in the observed event times, 
otherwise the positions of the knots are specified using only the true event times.</p>
</dd>
<dt>lng.in.kn</dt><dd><p>the number of internal knots; relevant only when when <code>method = "piecewise-PH-GH"</code> where it 
denotes the number of internal knots for the piecewise constant baseline risk function or when <code>method = "spline-PH-GH"</code> 
or <code>method = "ch-Laplace"</code> where it denotes the number of internal knots for B-splines approximation of the log 
baseline hazard. Default is 6 when <code>method = "piecewise-PH-GH"</code> and 5 otherwise.</p>
</dd>
<dt>equal.strata.knots</dt><dd><p>logical; if <code>TRUE</code> (the default), then the same knots are used in the approximation of the 
baseline risk function in different strata when <code>method = "spline-PH-GH"</code>.</p>
</dd>
<dt>ord</dt><dd><p>a positive integer denoting the order of the B-splines used to approximate the log cumulative hazard
(default is 4); relevant only when <code>method = "spline-PH-GH"</code> or <code>method = "ch-Laplace"</code>.</p>
</dd>
<dt>typeGH</dt><dd><p>a character string indicating the type of Gauss-Hermite rule to be used. Options are &quot;simple&quot;
and &quot;adaptive&quot;. The default is &quot;simple&quot; but it is turned to adaptive when the user specifies in the
<code>method</code> argument an option that contains <code>aGH</code>.</p>
</dd>
<dt>GHk</dt><dd><p>the number of Gauss-Hermite quadrature points used to approximate the integrals over the random 
effects. The default is 15 for one- or two-dimensional integration and for <code class="reqn">N &lt; 2000</code>, and 9 otherwise for the 
simple Gauss-Hermite rule, and 5 for one-, two-dimensional or three-dimensional integration and for <code class="reqn">N &lt; 2000</code>, 
and 3 otherwise for the pseudo adaptive Gauss-Hermite rule, where <code class="reqn">N</code> denotes the total number of longitudinal
measurements.</p>
</dd>
<dt>GKk</dt><dd><p>the number of Gauss-Kronrod points used to approximate the integral involved in the calculation of the survival function. Two 
options are available, namely 7 or 15. For <code>method = "weibull-PH-GH"</code>, <code>method = "weibull-AFT-GH"</code> and
<code>method = "spline-PH-GH"</code> 15 are used, whereas for <code>method = "piecewise-PH-GH"</code> 7.</p>
</dd>
<dt>verbose</dt><dd><p>logical; if <code>TRUE</code>, the parameter estimates and the log-likelihood value are printed during
the optimization procedure. Default is <code>FALSE</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jointModel_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>jointModel</code> fits joint models for longitudinal and survival data (more detailed information about the formulation of these
models can be found in Rizopoulos (2010)). For the longitudinal responses the linear mixed effects model represented by the <code>lmeObject</code> is 
assumed. For the survival times let <code class="reqn">w_i</code> denote the vector of baseline covariates in <code>survObject</code>, with associated parameter vector 
<code class="reqn">\gamma</code>, <code class="reqn">m_i(t)</code> the value of the longitudinal outcome at time point <code class="reqn">t</code> as approximated by the linear mixed model 
(i.e., <code class="reqn">m_i(t)</code> equals the fixed-effects part <code>+</code> random-effects part of the linear mixed effects model for sample unit <code class="reqn">i</code>), 
<code class="reqn">\alpha</code> the association parameter for <code class="reqn">m_i(t)</code>, <code class="reqn">m_i'(t)</code> the derivative of <code class="reqn">m_i(t)</code> with respect to <code class="reqn">t</code>, and 
<code class="reqn">\alpha_d</code> the association parameter for <code class="reqn">m_i'(t)</code>. Then, for <code>method = "weibull-AFT-GH"</code> a time-dependent Weibull model under 
the accelerated failure time formulation is assumed. For <code>method = "weibull-PH-GH"</code> a time-dependent relative risk model is postulated 
with a Weibull baseline risk function. For <code>method = "piecewise-PH-GH"</code> a time-dependent relative risk model is postulated with a 
piecewise constant baseline risk function. For <code>method = "spline-PH-GH"</code> a time-dependent relative risk model is assumed in which the 
log baseline risk function is approximated using B-splines. For <code>method = "ch-Laplace"</code> an additive model on the log cumulative hazard 
scale is assumed (see Rizopoulos et al., 2009 for more info). Finally, for <code>method = "Cox-PH-GH"</code> a time-dependent relative risk model 
is assumed where the baseline risk function is left unspecified (Wulfsohn and Tsiatis, 1997). For all these options the linear predictor for the
survival submodel is written as </p>
<p style="text-align: center;"><code class="reqn">\eta = \gamma^\top w_i + \alpha m_i\{max(t-k, 0)\},</code>
</p>
<p> when 
<code>parameterization = "value"</code>, </p>
<p style="text-align: center;"><code class="reqn">\eta = \gamma^\top w_i + \alpha_s m_i'\{max(t-k, 0)\},</code>
</p>
 
<p>when <code>parameterization = "slope"</code>, and </p>
<p style="text-align: center;"><code class="reqn">\eta = \gamma^\top w_i + \alpha m_i\{max(t-k, 0)\} + \alpha_s m_i'\{max(t-k, 0)\},</code>
</p>
<p> when <code>parameterization = "both"</code>, where in all the above the value 
of <code class="reqn">k</code> is specified by the <code>lag</code> argument and <code class="reqn">m_i'(t) = d m_i(t) / dt</code>. If <code>interFact</code> is specified, then
<code class="reqn">m_i\{max(t-k, 0)\}</code> and/or <code class="reqn">m_i'\{max(t-k, 0)\}</code> are multiplied with the design matrices derived from the formulas
supplied as the first two arguments of <code>interFact</code>, respectively. In this case <code class="reqn">\alpha</code> and/or <code class="reqn">\alpha_s</code> become vectors of
association parameters.
</p>
<p>For <code>method = "spline-PH-GH"</code> it is also allowed to include stratification factors. These should be included in the specification of
the <code>survObject</code> using function <code>strata()</code>. Note that in this case <code>survObject</code> must only be a 'coxph' object.
</p>
<p>For all survival models except for the time-dependent proportional hazards model, the optimization algorithm starts 
with EM iterations, and if convergence is not achieved, it switches to quasi-Newton iterations (i.e., BFGS in 
<code>optim()</code> or <code>nlminb()</code>, depending on the value of the <code>optimizer</code> control argument). For <code>method = "Cox-PH-GH"</code> only the 
EM algorithm is used. During the EM iterations, convergence is declared if either of the following two conditions is satisfied: (i) 
<code class="reqn"> L(\theta^{it}) - L(\theta^{it - 1}) &lt; tol_3 \{ | L(\theta^{it - 1}) | + tol_3 \} </code>, or (ii) 
<code class="reqn"> \max \{ | \theta^{it} - \theta^{it - 1} | / ( | \theta^{it - 1} | + tol_1) \} &lt; tol_2</code>, where <code class="reqn">\theta^{it}</code> and 
<code class="reqn">\theta^{it - 1}</code> is the vector of parameter values at the current and previous iterations, respectively, and <code class="reqn">L(.)</code> is the 
log-likelihood function. The values for <code class="reqn">tol_1</code>, <code class="reqn">tol_2</code> and <code class="reqn">tol_3</code> are specified via the <code>control</code> argument. During the 
quasi-Newton iterations, the default convergence criteria of either <code>optim()</code> or <code>nlminb()</code> are used.
</p>
<p>The required integrals are approximated using the standard Gauss-Hermite quadrature rule when the chosen option for the <code>method</code>
argument contains the string &quot;GH&quot;, and the (pseudo) adaptive Gauss-Hermite rule when the chosen option for the <code>method</code>
argument contains the string &quot;aGH&quot;. For <code>method = "ch-Laplace"</code> the fully exponential Laplace approximation described in 
Rizopoulos et al. (2009) is used.  The (pseudo) adaptive Gauss-Hermite and the Laplace approximation are particularly useful when 
high-dimensional random effects vectors are considered (e.g., when modelling nonlinear subject-specific trajectories with splines 
or high-order polynomials).
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+jointModelObject">jointModelObject</a></code> for the components of the fit.
</p>


<h3>Note</h3>

<p>1. The <code>lmeObject</code> argument should represent a linear mixed model object with a simple random-effects 
structure, i.e., only the <code>pdDiag()</code> class is currently allowed.
</p>
<p>2. The <code>lmeObject</code> object should not contain any within-group correlation structure (i.e., <code>correlation</code> 
argument of <code>lme()</code>) or within-group heteroscedasticity structure (i.e., <code>weights</code> argument of <code>lme()</code>).
</p>
<p>3. It is assumed that the linear mixed effects model <code>lmeObject</code> and the survival model <code>survObject</code> have been 
fitted to the same subjects. Moreover, it is assumed that the ordering of the subjects is the same for both 
<code>lmeObject</code> and <code>survObject</code>, i.e., that the first line in the data frame containing the event times 
corresponds to the first set of lines identified by the grouping variable in the data frame containing the repeated 
measurements, and so on.
</p>
<p>4. In the <code>print</code> and <code>summary</code> generic functions for class <code>jointModel</code>, the estimated coefficients (and
standard errors for the <code>summary</code> generic) for the event process are augmented with the element &quot;Assoct&quot; that 
corresponds to the association parameter <code class="reqn">\alpha</code> and the element &quot;Assoct.s&quot; that corresponds to the parameter 
<code class="reqn">\alpha_s</code> when <code>parameterization</code> is <code>"slope"</code> or <code>"both"</code> (see <b>Details</b>).
</p>
<p>5. The standard errors returned by the <code>summary</code> generic function for class <code>jointModel</code> when 
<code>method = "Cox-PH-GH"</code> are based on the profile score vector (i.e., given the NPMLE for the unspecified baseline 
hazard). Hsieh et al. (2006) have noted that these standard errors are underestimated.
</p>
<p>6. As it is the case for all types of mixed models that require numerical integration, it is advisable (especially in
difficult datasets) to check the stability of the maximum likelihood estimates with an increasing number of 
Gauss-Hermite quadrature points.
</p>
<p>7. It is assumed that the scale of the time variable (e.g., days, months years) is the same in both <code>lmeObject</code> and <code>survObject</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2000) Joint modelling of longitudinal measurements and event time data.
<em>Biostatistics</em> <b>1</b>, 465&ndash;480.
</p>
<p>Hsieh, F., Tseng, Y.-K. and Wang, J.-L. (2006) Joint modeling of survival and longitudinal data: Likelihood 
approach revisited. <em>Biometrics</em> <b>62</b>, 1037&ndash;1043.
</p>
<p>Rizopoulos, D. (2012a) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2012b) Fast fitting of joint models for longitudinal and event time data using a 
pseudo-adaptive Gaussian quadrature rule. <em>Computational Statistics and Data Analysis</em> <b>56</b>, 491&ndash;501.
</p>
<p>Rizopoulos, D. (2011) Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. (2010) JM: An R package for the joint modelling of longitudinal and time-to-event data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>
<p>Rizopoulos, D., Verbeke, G. and Lesaffre, E. (2009) Fully exponential Laplace approximations for the joint
modelling of survival and longitudinal data. <em>Journal of the Royal Statistical Society, Series B</em> <b>71</b>, 
637&ndash;654.
</p>
<p>Rizopoulos, D., Verbeke, G. and Molenberghs, G. (2010) Multiple-imputation-based residuals and diagnostic plots
for joint models of longitudinal and survival outcomes. <em>Biometrics</em> <b>66</b>, 20&ndash;29.
</p>
<p>Tsiatis, A. and Davidian, M. (2004) Joint modeling of longitudinal and time-to-event data: an overview. 
<em>Statistica Sinica</em> <b>14</b>, 809&ndash;834.
</p>
<p>Wulfsohn, M. and Tsiatis, A. (1997) A joint model for survival and longitudinal data measured with error. 
<em>Biometrics</em> <b>53</b>, 330&ndash;339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelObject">jointModelObject</a></code>,
<code><a href="#topic+anova.jointModel">anova.jointModel</a></code>,
<code><a href="#topic+coef.jointModel">coef.jointModel</a></code>,
<code><a href="#topic+fixef.jointModel">fixef.jointModel</a></code>,
<code><a href="#topic+ranef.jointModel">ranef.jointModel</a></code>,
<code><a href="#topic+fitted.jointModel">fitted.jointModel</a></code>,
<code><a href="#topic+residuals.jointModel">residuals.jointModel</a></code>,
<code><a href="#topic+plot.jointModel">plot.jointModel</a></code>,
<code><a href="#topic+survfitJM">survfitJM</a></code>,
<code><a href="#topic+rocJM">rocJM</a></code>,
<code><a href="#topic+dynCJM">dynCJM</a></code>,
<code><a href="#topic+aucJM">aucJM</a></code>,
<code><a href="#topic+prederrJM">prederrJM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit (random intercepts)
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ 1 | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")
fitJOINT
summary(fitJOINT)

# linear mixed model fit (random intercepts + random slopes)
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ year | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")
fitJOINT
summary(fitJOINT)

# we also include an interaction term of log(serBilir) with drug
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year",
    interFact = list(value = ~ drug, data = pbc2.id))
fitJOINT
summary(fitJOINT)


# a joint model in which the risk for and event depends both on the true value of
# marker and the true value of the slope of the longitudinal trajectory
lmeFit &lt;- lme(sqrt(CD4) ~ obstime * drug, random = ~ obstime | patient, data = aids)
coxFit &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# to fit this model we need to specify the 'derivForm' argument, which is a list
# with first component the derivative of the fixed-effects formula of 'lmeFit' with
# respect to 'obstime', second component the indicator of which fixed-effects 
# coefficients correspond to the previous defined formula, third component the 
# derivative of the random-effects formula of 'lmeFit' with respect to 'obstime', 
# and fourth component the indicator of which random-effects correspond to the 
# previous defined formula
dForm &lt;- list(fixed = ~ 1 + drug, indFixed = c(2, 4), random = ~ 1, indRandom = 2)
jointModel(lmeFit, coxFit, timeVar = "obstime", method = "spline-PH-aGH",
  parameterization = "both", derivForm = dForm)


# Competing Risks joint model
# we first expand the PBC dataset in the competing risks long format
# with two competing risks being death and transplantation
pbc2.idCR &lt;- crLong(pbc2.id, "status", "alive")

# we fit the linear mixed model as before
lmeFit.pbc &lt;- lme(log(serBilir) ~ drug * ns(year, 3), 
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)

# however, for the survival model we need to use the data in the long
# format, and include the competing risks indicator as a stratification
# factor. We also take interactions of the baseline covariates with the
# stratification factor in order to allow the effect of these covariates
# to be different for each competing risk
coxCRFit.pbc &lt;- coxph(Surv(years, status2) ~ (drug + sex)*strata + strata(strata), 
    data = pbc2.idCR, x = TRUE)

# the corresponding joint model is fitted simply by including the above
# two submodels as main arguments, setting argument CompRisk to TRUE, 
# and choosing as method = "spline-PH-aGH". Similarly as above, we also 
# include strata as an interaction factor to allow serum bilirubin to 
# have a different effect for each of the two competing risks
jmCRFit.pbc &lt;- jointModel(lmeFit.pbc, coxCRFit.pbc, timeVar = "year", 
    method = "spline-PH-aGH", 
    interFact = list(value = ~ strata, data = pbc2.idCR), 
    CompRisk = TRUE)
summary(jmCRFit.pbc)

# linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime * drug - drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)
# joint model fit with a spline-approximated baseline hazard function
fitJOINT &lt;- jointModel(fitLME, fitCOX, 
    timeVar = "obstime", method = "spline-PH-aGH")
fitJOINT
summary(fitJOINT)

## End(Not run)
</code></pre>

<hr>
<h2 id='jointModelObject'>Fitted jointModel Object</h2><span id='topic+jointModelObject'></span>

<h3>Description</h3>

<p>An object returned by the <code>jointModel</code> function, inheriting from class <code>jointModel</code> and representing a fitted
joint model for longitudinal and time-to-event data. Objects of this class have methods for the generic functions 
<code>anova</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>, <code>logLik</code>, <code>plot</code>, <code>print</code>, 
<code>random.effects</code>, <code>residuals</code>, <code>summary</code>, and <code>vcov</code>.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>jointModel</code> object.
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a list with the estimated coefficients. The components of this list are:
</p>

<dl>
<dt>betas</dt><dd><p>the vector of fixed effects for the linear mixed effects model.</p>
</dd>
<dt>sigma</dt><dd><p>the measurement error standard deviation for the linear mixed effects model.</p>
</dd>
<dt>gammas</dt><dd><p>the vector of baseline covariates for the survival model.</p>
</dd>
<dt>alpha</dt><dd><p>the association parameter(s).</p>
</dd>
<dt>Dalpha</dt><dd><p>the association parameter(s) corresponding to the slope of the true trajectory.</p>
</dd>
<dt>sigma.t</dt><dd><p>the scale parameter for the Weibull survival model; returned only when
<code>method = "weibull-PH-GH"</code> or <code>method = "weibull-AFT-GH"</code>.</p>
</dd>
<dt>xi</dt><dd><p>the parameter of the piecewise constant baseline hazard; returned only when
<code>method = "piecewise-PH-GH"</code>.</p>
</dd>
<dt>gamma.bs</dt><dd><p>the coefficients of the B-splines use to approximate the baseline hazard;
returned only when <code>method = "spline-PH-GH"</code>.</p>
</dd>
<dt>lambda0</dt><dd><p>a two-column numeric matrix with the first column containing the estimated baseline hazard values,
and the second the unique sorted event times; returned only when <code>method = "Cox-PH-GH"</code>.</p>
</dd>
<dt>D</dt><dd><p>the variance-covariance matrix of the random effects.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>the Hessian matrix evaluated at the estimated parameter values.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood value.</p>
</td></tr>
<tr><td><code>EB</code></td>
<td>
<p>a list with components:
</p>

<dl>
<dt>post.b</dt><dd><p>the estimated random effects values.</p>
</dd>
<dt>post.vb</dt><dd><p>the estimated variance for the random effects estimates.</p>
</dd>
<dt>Zb</dt><dd><p>the estimated random effects part of the linear predictor for the longitudinal outcome (i.e., <code class="reqn">Z</code>
is the design matrix for the random effects <code class="reqn">b</code>).</p>
</dd>
<dt>Ztimeb</dt><dd><p>the estimated random effects part of the linear predictor for the survival outcome (i.e.,
evaluated at the observed event times).</p>
</dd>
<dt>Ztime2b</dt><dd><p>the estimated random effects part of the linear predictor for the survival outcome (i.e.,
for the <code class="reqn">i</code>th sample unit is evaluated at all event times that are less or equal to the <code class="reqn">i</code>th
observed event time); returned only when <code>method = "Cox-PH-GH"</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>the numeric vector of the knots positions; returned only when <code>method = "spline-PH-GH"</code>,
<code>method = "piecewise-PH-GH"</code> or <code>method = "ch-Laplace"</code>.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>the number of iterations in the optimization algorithm.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence identifier: 0 corresponds to successful convergence, whereas 1 to a problem
(i.e., when 1, usually more iterations are required).</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of sample units.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the total number of repeated measurements for the longitudinal outcome.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>a vector with the number of repeated measurements for each sample unit.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>a numeric vector with 0 denoting censored observation and 1 events.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>the grouping vector for the longitudinal responses.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with the design matrices for the longitudinal and event processes.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list with the response vectors for the longitudinal and event processes.</p>
</td></tr>
<tr><td><code>data.id</code></td>
<td>
<p>a <code>data.frame</code> containing the variables for the linear mixed effects model at the time of the
event.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the value of the <code>method</code> argument.</p>
</td></tr>
<tr><td><code>termsY</code></td>
<td>
<p>the <code>terms</code> component of the <code>lmeObject</code>.</p>
</td></tr>
<tr><td><code>termsT</code></td>
<td>
<p>the <code>terms</code> component of the <code>survObject</code>.</p>
</td></tr>
<tr><td><code>formYx</code></td>
<td>
<p>the formula for the fixed effects part of the longitudinal model.</p>
</td></tr>
<tr><td><code>formYz</code></td>
<td>
<p>the formula for the random effects part of the longitudinal model.</p>
</td></tr>
<tr><td><code>formT</code></td>
<td>
<p>the formula for the survival model.</p>
</td></tr>
<tr><td><code>timeVar</code></td>
<td>
<p>the value of the <code>timeVar</code> argument</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the <code>control</code> argument.</p>
</td></tr>
<tr><td><code>parameterization</code></td>
<td>
<p>the value of the <code>parameterization</code> argument.</p>
</td></tr>
<tr><td><code>interFact</code></td>
<td>
<p>the value of the <code>interFact</code> argument</p>
</td></tr>
<tr><td><code>derivForm</code></td>
<td>
<p>the value of the <code>derivForm</code> argument.</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>the value of the <code>lag</code> argument.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code>
</p>

<hr>
<h2 id='pbc2'>Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbc2'></span><span id='topic+pbc2.id'></span>

<h3>Description</h3>

<p>Followup of 312 randomised patients with primary biliary cirrhosis, a rare autoimmune liver disease, at Mayo Clinic.
</p>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of death, transplantion, or study 
analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code> and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date, remaining values on the line of 
data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e., no edema and no diuretic therapy for edema),
<code>edema no diuretics</code> (i.e., edema present without diuretics, or edema resolved by diuretics), and 
<code>edema despite diuretics</code> (i.e., edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in gm/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml / 1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the patient was dead,
and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>pbc2.id</code> contains the first measurement for each patient. This data frame is used to 
fit the survival model. 
</p>


<h3>References</h3>

<p>Fleming, T. and Harrington, D. (1991) <em>Counting Processes and Survival Analysis</em>. Wiley, New York.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending the Cox Model</em>. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(pbc2.id)
</code></pre>

<hr>
<h2 id='piecewiseExp.ph'> Proportional Hazards Models with Piecewise Constant Baseline Hazard Function </h2><span id='topic+piecewiseExp.ph'></span>

<h3>Description</h3>

<p>Based on a fitted Cox model this function fits the corresponding relative risk model with a 
piecewise constant baseline hazard using the Poisson regression equivalence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewiseExp.ph(coxObject, knots = NULL, length.knots = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="piecewiseExp.ph_+3A_coxobject">coxObject</code></td>
<td>
<p> an object of class <code>coxph</code>.</p>
</td></tr>
<tr><td><code id="piecewiseExp.ph_+3A_knots">knots</code></td>
<td>
<p>A numeric vector denoting the internal knots (cut points) defining the intervals in which the baseline hazard is assumed constant.</p>
</td></tr>
<tr><td><code id="piecewiseExp.ph_+3A_length.knots">length.knots</code></td>
<td>
<p>a numeric value denoting the number of internal knots to use in the fit. 
Used when <code>knots = NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>glm</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coxFit &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)
piecewiseExp.ph(coxFit)
</code></pre>

<hr>
<h2 id='plot'>Plot Diagnostics for Joint Models</h2><span id='topic+plot.jointModel'></span>

<h3>Description</h3>

<p>Produces a variety of plots for fitted joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
plot(x, which = 1:4, caption = c("Residuals vs Fitted", 
  "Normal Q-Q", "Marginal Survival", "Marginal Cumulative Hazard", 
  "Marginal log Cumulative Hazard", "Baseline Hazard", 
  "Cumulative Baseline Hazard", "Subject-specific Survival", 
  "Subject-specific Cumulative Hazard", 
  "Subject-specific log Cumulative Hazard"), survTimes = NULL, 
  main = "", 
  ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), 
  ..., ids = NULL, add.smooth = getOption("add.smooth"), 
  add.qqline = TRUE, add.KM = FALSE, cex.caption = 1, return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_which">which</code></td>
<td>
<p>which types of plots to produce, specify a subset of the numbers 1:10.</p>
</td></tr>
<tr><td><code id="plot_+3A_caption">caption</code></td>
<td>
<p>captions to appear above the plots defined by argument <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_survtimes">survTimes</code></td>
<td>
<p>a vector of survival times for which the survival, cumulative hazard or 
log cumulative hazard will be computed. Default is <code>seq(minT, maxT, length = 15)</code>, where <code>minT</code> and 
<code>maxT</code> are the minimum and maximum observed survival times, respectively.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>a character string specifying the title in the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot, see <code>par(ask=.)</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
<tr><td><code id="plot_+3A_ids">ids</code></td>
<td>
<p>a numeric vector specifying which subjects, the subject-specific plots will include; 
default is all subjects.</p>
</td></tr>
<tr><td><code id="plot_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical; if <code>TRUE</code> a smooth line is superimposed in the &quot;Residuals vs Fitted&quot; plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_add.qqline">add.qqline</code></td>
<td>
<p>logical; if <code>TRUE</code> a qq-line is superimposed in the &quot;Normal Q-Q&quot; plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_add.km">add.KM</code></td>
<td>
<p>logical; if <code>TRUE</code> the Kaplan-Meier estimate of the survival function is superimposed in the 
&quot;Marginal Survival&quot; plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_cex.caption">cex.caption</code></td>
<td>
<p>magnification of captions.</p>
</td></tr>
<tr><td><code id="plot_+3A_return">return</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>which</code> takes in values in <code>c(3:5, 8:10)</code>,
then the values used to create the plot are returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The plots of the baseline hazard and the cumulative baseline hazard are only produced when the joint model has
been fitted using <code>method = "Cox-PH-GH"</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2010) JM: An R package for the joint modelling of longitudinal and time-to-event data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ 1 | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")

plot(fitJOINT, 3, add.KM = TRUE, col = "red", lwd = 2)

par(mfrow = c(2, 2))
plot(fitJOINT)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.rocJM'>Plot Method for rocJM Objects</h2><span id='topic+plot.rocJM'></span>

<h3>Description</h3>

<p>Produces plots of ROC curves and the corresponding areas under the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rocJM'
plot(x, which = NULL, type = c("ROC", "AUC"), 
  ndt = "all", main = NULL, caption = NULL, xlab = NULL, 
  ylab = NULL, ask = NULL, legend = FALSE, lx = NULL, ly = NULL, 
  lty = NULL, col = NULL, cex.caption = 0.8, cex.axis = NULL, 
  cex.lab = NULL, cex.main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rocJM_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>rocJM</code>.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_which">which</code></td>
<td>
<p>a numeric vector specifying for which generic subjects to produce the plots. 
This refers to the different cases identified by the <code>idVar</code> argument in <code><a href="#topic+rocJM">rocJM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_type">type</code></td>
<td>
<p>a character string specifying which plot to produce the ROC curves or the areas under
the ROC curves.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_ndt">ndt</code></td>
<td>
<p>the character string <code>"all"</code> or a numeric scalar specifying for which time windows 
(<code>dt</code> argument of <code><a href="#topic+rocJM">rocJM</a></code>) to produce the plots.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_main">main</code></td>
<td>
<p>a character string specifying the title in the plot.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_caption">caption</code></td>
<td>
<p>a character string specifying a caption in the plot.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot, see <code>par()</code>.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend is included in the plot.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_lx">lx</code>, <code id="plot.rocJM_+3A_ly">ly</code></td>
<td>
<p>the <code>x</code> and <code>y</code> arguments of <code>legend()</code>.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_lty">lty</code></td>
<td>
<p>what types of lines to use.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_col">col</code></td>
<td>
<p>which colors to use.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_cex.caption">cex.caption</code></td>
<td>
<p>font size for the caption.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_cex.axis">cex.axis</code>, <code id="plot.rocJM_+3A_cex.lab">cex.lab</code>, <code id="plot.rocJM_+3A_cex.main">cex.main</code></td>
<td>
<p>graphical parameters; see <code>par</code> for more info.</p>
</td></tr>
<tr><td><code id="plot.rocJM_+3A_...">...</code></td>
<td>
<p>extra graphical parameters passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rocJM">rocJM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fitLME &lt;- lme(sqrt(CD4) ~ obstime + obstime:(drug + AZT + prevOI + gender), 
    random = ~ obstime | patient, data = aids)
fitSURV &lt;- coxph(Surv(Time, death) ~ drug + AZT + prevOI + gender, 
    data = aids.id, x = TRUE)
fit.aids &lt;- jointModel(fitLME, fitSURV, timeVar = "obstime", 
    method = "piecewise-PH-aGH")

ND &lt;- aids[aids$patient == "7", ]
roc &lt;- rocJM(fit.aids, dt = c(2, 4, 8), ND, idVar = "patient")
plot(roc, lwd = 2, legend = TRUE)
plot(roc, type = "AUC")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.survfitJM'>Plot Method for survfitJM Objects</h2><span id='topic+plot.survfitJM'></span>

<h3>Description</h3>

<p>Produces plots of conditional probabilities of survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfitJM'
plot(x, estimator = c("both", "mean", "median"), 
    which = NULL, fun = NULL, conf.int = FALSE, 
    fill.area = FALSE, col.area = "grey", col.abline = "black", col.points = "black",
    add.last.time.axis.tick = FALSE, include.y = FALSE, main = NULL, 
    xlab = NULL, ylab = NULL, ylab2 = NULL, lty = NULL, col = NULL, 
    lwd = NULL, pch = NULL, ask = NULL, legend = FALSE, ...,
    cex.axis.z = 1, cex.lab.z = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.survfitJM_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>survfitJM</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_estimator">estimator</code></td>
<td>
<p>character string specifying, whether to include in the plot the mean of the conditional probabilities of survival,
the median or both. The mean and median are taken as estimates of these conditional probabilities over the M replications of the
Monte Carlo scheme described in <code><a href="#topic+survfitJM">survfitJM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_which">which</code></td>
<td>
<p>a numeric or character vector specifying for which subjects to produce the plot. If a character vector, then is
should contain a subset of the values of the <code>idVar</code> variable of the <code>newdata</code> argument of <code><a href="#topic+survfitJM">survfitJM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_fun">fun</code></td>
<td>
<p>a vectorized function defining a transformation of the survival curve. For example with <code>fun=log</code> the log-survival curve 
is drawn.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; if <code>TRUE</code>, then a pointwise confidence interval is included in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_fill.area">fill.area</code></td>
<td>
<p>logical; if <code>TRUE</code> the area defined by the confidence interval of the survival function is put in color.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col.area">col.area</code></td>
<td>
<p>the color of the area defined by the confidence interval of the survival function.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col.abline">col.abline</code>, <code id="plot.survfitJM_+3A_col.points">col.points</code></td>
<td>
<p>the color for the vertical line and the points when <code>include.y</code> is <code>TRUE</code>.</p>
</td></tr> 
<tr><td><code id="plot.survfitJM_+3A_add.last.time.axis.tick">add.last.time.axis.tick</code></td>
<td>
<p>logical; if <code>TRUE</code>, a tick is added in the x-axis for the last available time point for which a
longitudinal measurement was available.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_include.y">include.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, two plots are produced per subject, i.e., the plot of conditional probabilities of survival 
and a scatterplot of his longitudinal measurements.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_main">main</code></td>
<td>
<p>a character string specifying the title in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_ylab2">ylab2</code></td>
<td>
<p>a character string specifying the y-axis label in the plotm when <code>include.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_lty">lty</code></td>
<td>
<p>what types of lines to use.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col">col</code></td>
<td>
<p>which colors to use.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_lwd">lwd</code></td>
<td>
<p>the thickness of the lines.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_pch">pch</code></td>
<td>
<p>the type of points to use.</p>
</td></tr>  
<tr><td><code id="plot.survfitJM_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot, see <code>par()</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend is included in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_cex.axis.z">cex.axis.z</code>, <code id="plot.survfitJM_+3A_cex.lab.z">cex.lab.z</code></td>
<td>
<p>the par <code>cex</code> argument for the axis at side 4, when <code>include.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_...">...</code></td>
<td>
<p>extra graphical parameters passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for longitudinal and time-to-event data. 
<em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. (2010) JM: An R Package for the Joint Modelling of Longitudinal and Time-to-Event Data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime + obstime:drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# joint model fit
fitJOINT &lt;- jointModel(fitLME, fitCOX, 
    timeVar = "obstime", method = "weibull-PH-aGH")

# sample of the patients who are still alive
ND &lt;- aids[aids$patient == "141", ]
ss &lt;- survfitJM(fitJOINT, newdata = ND, idVar = "patient", M = 50)
plot(ss)
plot(ss, include.y = TRUE, add.last.time.axis.tick = TRUE, legend = TRUE)
</code></pre>

<hr>
<h2 id='prederrJM'>Prediction Errors for Joint Models</h2><span id='topic+prederrJM'></span><span id='topic+prederrJM.jointModel'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a starting time point, this function computes an estimate 
of the prediction error of survival at a horizon time point based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prederrJM(object, newdata, Tstart, Thoriz, ...)

## S3 method for class 'jointModel'
prederrJM(object, newdata, Tstart, Thoriz, 
    lossFun = c("absolute", "square"), interval = FALSE, idVar = "id", 
    simulate = FALSE, M = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prederrJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModel">jointModel</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_tstart">Tstart</code></td>
<td>
<p>numeric scalar denoting the time point up to which longitudinal information is to be used to derive predictions.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_thoriz">Thoriz</code></td>
<td>
<p>numeric scalar denoting the time point for which a prediction of the survival status is of interest; <code>Thoriz</code> mast be later than <code>Tstart</code>.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_lossfun">lossFun</code></td>
<td>
<p>either the options <code>"absolute"</code> (default) or <code>"square"</code>,  or a user-specified loss function. As the names suggest, 
when <code>lossFun = "absolute"</code> the loss function is <code class="reqn">L(x) = |x|</code>, whereas when <code>lossFun = "square"</code> the loss function is 
<code class="reqn">L(x) = x^2</code>. If a user-specified function is supplied, this should have a single argument and be vectorized.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_interval">interval</code></td>
<td>
<p>logical; if <code>TRUE</code> the weighted prediction error in the interval <code>[Tstart, Thoriz]</code> is calculated, while
if <code>FALSE</code> the prediction error at time <code>Thoriz</code> is calculated using the longitudinal information up to time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code id="prederrJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>) and using the data supplied in argument <code>newdata</code>, this function
computes the following estimate of the prediction: </p>
<p style="text-align: center;"><code class="reqn">PE(u | t) = \{R(t)\}^{-1} \sum_{i: T_i \geq s} I(T_i \geq u) 
  L\{1 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \delta_i I(T_i &lt; u) L\{0 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>
 
<p style="text-align: center;"><code class="reqn">+ (1 - \delta_i) I(T_i &lt; u) [S_i(u \mid T_i, \tilde{y}_i(t)) L\{1 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \{1 - S_i(u \mid T_i, \tilde{y}_i(t))\} L\{0 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}],</code>
</p>

<p>where <code class="reqn">R(t)</code> denotes the number of subjects at risk at time <code class="reqn">t = </code> <code>Tstart</code>, <code class="reqn">\tilde{y}_i(t) = \{y_i(s), 0 \leq s \leq t\}</code> denotes the available 
longitudinal measurements up to time <code class="reqn">t</code>, <code class="reqn">T_i</code> denotes the observed event time for subject <code class="reqn">i</code>, <code class="reqn">\delta_i</code> is the event indicator, 
<code class="reqn">s</code> is the starting time point <code>Tstart</code> up to which the longitudinal information is used, and <code class="reqn">u &gt; s</code> is the horizon time point <code>Thoriz</code>.
Function <code class="reqn">L(.)</code> is the loss function that can be the absolute value (i.e., <code class="reqn">L(x) = |x|</code>), the squared value (i.e., <code class="reqn">L(x) = x^2</code>), 
or a user-specified function. The probabilities <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code> are calculated by <code><a href="#topic+survfitJM">survfitJM</a></code>.
</p>
<p>When <code>interval</code> is set to <code>TRUE</code>, then function <code>prederrJM</code> computes the integrated prediction error in the interval 
<code class="reqn">(u,t) =</code> <code>(Tstart, Thoriz)</code> defined as </p>
<p style="text-align: center;"><code class="reqn">IPE(u | t) = \sum_{i: t \leq T_i \leq u} w_i(T_i) PE(T_i | t),</code>
</p>
<p> where 
</p>
<p style="text-align: center;"><code class="reqn">w_i(T_i) = \frac{\delta_i G(T_i) / G(t)}{\sum_{i: t \leq T_i \leq u} \delta_i G(T_i) / G(t)},</code>
</p>
<p> with <code class="reqn">G(.)</code> denoting
the Kaplan-Meier estimator of the censoring time distribution.
</p>


<h3>Value</h3>

<p>A list of class <code>prederrJM</code> with components:
</p>
<table role = "presentation">
<tr><td><code>prederr</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>a copy of the <code>interval</code> argument.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
<tr><td><code>lossFun</code></td>
<td>
<p>a copy of the <code>lossFun</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2002). Identification and efficacy of longitudinal markers for survival.
<em>Biostatistics</em> <b>3</b>, 33&ndash;50.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for longitudinal and time-to-event data. 
<em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D., Murawska, M., Andrinopoulou, E.-R., Lesaffre, E. and Takkenberg, J. (2013). 
Dynamic predictions with time-dependent covariates in survival analysis: A comparison between 
joint modeling and landmarking. <em>under preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+aucJM">aucJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModel(lmeFit, survFit, timeVar = "year", 
    method = "piecewise-PH-aGH")

# prediction error at year 10 using longitudinal data up to year 5 
prederrJM(jointFit, pbc2, Tstart = 5, Thoriz = 10)
prederrJM(jointFit, pbc2, Tstart = 5, Thoriz = 6.5, interval = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict'>Predictions for Joint Models</h2><span id='topic+predict.jointModel'></span>

<h3>Description</h3>

<p>Calculates predicted values for the longitudinal part of a joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
predict(object, newdata, type = c("Marginal", "Subject"),
    interval = c("none", "confidence", "prediction"), level = 0.95, idVar = "id", 
    FtTimes = NULL, M = 300, returnData = FALSE, scale = 1.6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>a data frame in which to look for variables with which to predict.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of predictions to compute,
marginal or subject-specific. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="predict_+3A_interval">interval</code></td>
<td>
<p>a character string indicating what type of intervals should be computed.</p>
</td></tr>
<tr><td><code id="predict_+3A_level">level</code></td>
<td>
<p>a numeric scalar denoting the tolerance/confidence level.</p>
</td></tr>
<tr><td><code id="predict_+3A_idvar">idVar</code></td>
<td>
<p>a character string indicating the name of the variable in 
<code>newdata</code> that corresponds to the subject identifier; required 
when <code>type = "Subject"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_fttimes">FtTimes</code></td>
<td>
<p>a list with components numeric vectors denoting the time points 
for which we wish to compute subject-specific predictions after the last
available measurement provided in <code>newdata</code>. For each subject in
<code>newdata</code> the default is a sequence of 25 equally spaced time points 
from the last available measurement to the maximum follow-up time of all 
subjects (plus a small quantity). This argument is only used when 
<code>type = "Subject"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_m">M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples. 
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="predict_+3A_returndata">returnData</code></td>
<td>
<p>logical; if <code>TRUE</code> the data frame supplied in
<code>newdata</code> is returned augmented with the outputs of the function.</p>
</td></tr>
<tr><td><code id="predict_+3A_scale">scale</code></td>
<td>
<p>a numeric value setting the scaling of the covariance matrix
of the empirical Bayes estimates in the Metropolis step during the 
Monte Carlo sampling.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type = "Marginal"</code>, this function computes predicted values for the 
fixed-effects part of the longitudinal submodel. In particular,
let <code class="reqn">X</code> denote the fixed-effects design matrix calculated using
<code>newdata</code>. The <code>predict()</code> calculates <code class="reqn">\hat{y} = X \hat{\beta}</code>,
and if <code>interval = "confidence"</code>, <code class="reqn">var(\hat{y}) = X V X^t</code>, with <code class="reqn">V</code>
denoting the covariance matrix of <code class="reqn">\hat{\beta}</code>. Confidence intervals are constructed under 
the normal approximation.
</p>
<p>When <code>type = "Subject"</code>, this functions computes subject-specific 
predictions for the longitudinal outcome based on the joint model. 
This accomplished with a Monte Carlo simulation scheme, similar to the one
described in <code><a href="#topic+survfitJM">survfitJM</a></code>. The only difference is in Step 3, where
for <code>interval = "confidence"</code> <code class="reqn">y_i^* = X_i \beta^* + Z_i b_i^*</code>, whereas
for <code>interval = "prediction"</code> <code class="reqn">y_i^*</code> is a random vector from a normal 
distribution with mean <code class="reqn">X_i \beta^* + Z_i b_i^*</code> and standard deviation 
<code class="reqn">\sigma^*</code>. Based on this Monte Carlo simulation scheme we take as 
estimate of <code class="reqn">\hat{y}_i</code> the average of the <code>M</code> estimates <code class="reqn">y_i^*</code> 
from each Monte Carlo sample. Confidence intervals are constructed using the 
percentiles of <code class="reqn">y_i^*</code> from the Monte Carlo samples.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code> a numeric vector of predicted values, otherwise a
list with components <code>pred</code> the predicted values, <code>se.fit</code> the
standard error for the fitted values, and <code>low</code> and <code>upp</code> the lower
and upper limits of the confidence interval. If <code>returnData = TRUE</code>, it
returns the data frame <code>newdata</code> with the previously mentioned components
added.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, 
    random = ~ year | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, 
    data = pbc2.id, x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")

DF &lt;- with(pbc2, expand.grid(drug = levels(drug),
    year = seq(min(year), max(year), len = 100)))
Ps &lt;- predict(fitJOINT, DF, interval = "confidence", return = TRUE)
require(lattice)
xyplot(pred + low + upp ~ year | drug, data = Ps,
    type = "l", col = c(2,1,1), lty = c(1,2,2), lwd = 2,
    ylab = "Average log serum Bilirubin")


# Subject-specific predictions
ND &lt;- pbc2[pbc2$id == 2, ]
Ps.ss &lt;- predict(fitJOINT, ND, type = "Subject",
  interval = "confidence", return = TRUE)
require(lattice)
xyplot(pred + low + upp ~ year | id, data = Ps.ss,
    type = "l", col = c(2,1,1), lty = c(1,2,2), lwd = 2,
    ylab = "Average log serum Bilirubin")

## End(Not run)
</code></pre>

<hr>
<h2 id='prothro'>Prednisone versus Placebo in Liver Cirrhosis Patients</h2><span id='topic+prothro'></span><span id='topic+prothros'></span>

<h3>Description</h3>

<p>A randomized trial on 488 liver cirrhosis patients
</p>


<h3>Format</h3>

<p>Two data frames with the following variable.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>pro</code></dt><dd><p>prothrobin measurements.</p>
</dd>
<dt><code>time</code></dt><dd><p>for data frame <code>prothro</code> the time points at which the prothrobin measurements were taken; 
for data frame <code>prothros</code> the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>treat</code></dt><dd><p>randomized treatment; a factor with levels &quot;placebo&quot; and &quot;prednisone&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.gllamm.org/books/readme.html#14.6">http://www.gllamm.org/books/readme.html#14.6</a>, 
</p>


<h3>References</h3>

<p>Andersen, P. K., Borgan, O., Gill, R. D. and Keiding, N. (1993). 
<em>Statistical Models Based on Counting Processes</em>. New York: Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(prothros)
</code></pre>

<hr>
<h2 id='ranef'>Random Effects Estimates for Joint Models</h2><span id='topic+ranef.jointModel'></span>

<h3>Description</h3>

<p>Extracts the random effects estimates from a fitted joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
ranef(object, type = c("mean", "mode"), postVar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="ranef_+3A_type">type</code></td>
<td>
<p>what type of empirical Bayes estimates to compute, the mean of the posterior distribution or
the mode of the posterior distribution.</p>
</td></tr>
<tr><td><code id="ranef_+3A_postvar">postVar</code></td>
<td>
<p>logical; if <code>TRUE</code> the variance of the posterior distribution is also returned. When
<code>type == "mode"</code>, then this equals <code class="reqn">\{- \partial^2 \log p(b_i | T_i, 
	\delta_i, y_i) / \partial b_i^\top \partial b_i \}^{-1}</code>.</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with rows denoting the individuals and columns the random effects (e.g., intercepts, slopes, etc.). 
If <code>postVar = TRUE</code>, the numeric matrix has an extra attribute &ldquo;postVar&quot;.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.jointModel">coef.jointModel</a></code>, <code><a href="#topic+fixef.jointModel">fixef.jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ 1 | id, data = pbc2)
# survival regression fit
fitSURV &lt;- survreg(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)

# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModel(fitLME, fitSURV, timeVar = "year")
ranef(fitJOINT)

## End(Not run)
</code></pre>

<hr>
<h2 id='residuals'>Residuals for Joint Models</h2><span id='topic+residuals.jointModel'></span>

<h3>Description</h3>

<p>Calculates residuals for joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
residuals(object, process = c("Longitudinal", "Event"), 
  type = c("Marginal", "Subject", "stand-Marginal", 
  "stand-Subject", "Martingale", "nullMartingale", "CoxSnell", "AFT"), 
  MI = FALSE, M = 50, time.points = NULL, return.data = FALSE, 
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_process">process</code></td>
<td>
<p>for which model (i.e., linear mixed model or survival model) to calculate residuals.</p>
</td></tr>
<tr><td><code id="residuals_+3A_type">type</code></td>
<td>
<p>what type of residuals to calculate. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_mi">MI</code></td>
<td>
<p>logical; if <code>TRUE</code> multiple-imputation-based residuals are calculated.</p>
</td></tr>
<tr><td><code id="residuals_+3A_m">M</code></td>
<td>
<p>integer denoting how many imputations to use for the MI residuals.</p>
</td></tr>
<tr><td><code id="residuals_+3A_time.points">time.points</code></td>
<td>
<p>for fixed visit times, this should be a numeric vector with the unique times points at which 
longitudinal measurements are supposed to be taken; if <code>NULL</code>, then the code attempts to extract these unique time points
using the design matrix for the fixed effects of the longitudinal model and the value of the <code>timeVar</code> argument of
<code><a href="#topic+jointModel">jointModel</a></code>. For random visit times, this should be an object of class <code><a href="#topic+weibull.frailty">weibull.frailty</a></code> that represents the fit of
Weibull model with Gamma frailties for the visiting process. The user may also augment the object <code>weibull.frailty</code> with the following 
two attributes: <code>"prev.y"</code> denoting the variable name for the previous longitudinal responses, and <code>"tmax"</code> denoting the end of 
the study.</p>
</td></tr>
<tr><td><code id="residuals_+3A_return.data">return.data</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>MI = TRUE</code> and fixed visit times are considered, then the multiply imputed data sets 
are returned.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>process = "Longitudinal"</code>, residuals are calculated for the longitudinal outcomes. In particular, if 
<code>type = "Marginal"</code> these are <code class="reqn">e_{ij} = y_{ij} - x_{ij}^T \hat{\beta}</code>, whereas for <code>type = "Subject"</code>, 
<code class="reqn">e_{ij} = y_{ij} - x_{ij}^T \hat{\beta} - z_{ij}^T b_i</code>, where <code class="reqn">i</code> denotes the subject and <code class="reqn">j</code> the 
measurement, <code class="reqn">y_{ij}</code> the longitudinal responses, <code class="reqn">x_{ij}^T</code> and <code class="reqn">z_{ij}^T</code> the corresponding rows of the
fixed and random effects design matrices, respectively, and <code class="reqn">\beta</code> and <code class="reqn">b_i</code> denote the fixed effects 
and random effects components. If <code>type = "stand-Marginal"</code> or <code>type = "stand-Subject"</code>, the above defined 
residuals are divided by the estimated standard deviation of the corresponding error term. If <code>MI = TRUE</code>, multiple-imputation-based 
residuals are calculated for the longitudinal process; for more information regarding these residuals, check Rizopoulos et al. (2009).
</p>
<p>When <code>process = "Event"</code>, residuals are calculated for the survival outcome. Martingale residuals are available 
for all options for the survival submodel (for the different options of survival submodel, check the <code>method</code> 
argument of <code><a href="#topic+jointModel">jointModel</a></code>). when option <code>type = "nullMartingale"</code> is invoked, the martingale residuals
are calculated with the coefficient(s) that correspond to the marker set to zero. Cox-Snell residuals (Cox and Snell, 
1968) are available for the Weibull model and the additive log cumulative hazard model. AFT residuals are only 
available for the Weibull model.
</p>


<h3>Value</h3>

<p>If <code>MI = FALSE</code>, a numeric vector of residual values. Otherwise a list with components:
</p>
<table role = "presentation">
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values for the observed data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals for the observed data.</p>
</td></tr>
<tr><td><code>fitted.valsM</code></td>
<td>
<p>the fitted values for the missing data.</p>
</td></tr>
<tr><td><code>resid.valsM</code></td>
<td>
<p>the multiply imputed residuals for the missing longitudinal responses.</p>
</td></tr>
<tr><td><code>mean.resid.valsM</code></td>
<td>
<p>the average of the multiply imputed residuals for the missing longitudinal responses; returned only if 
fixed visit times are considered.</p>
</td></tr>
<tr><td><code>dataM</code></td>
<td>
<p>if <code>return.data = TRUE</code> and fixed visit times are considered, then it returns the data set with the simulated response 
values for the longitudinal outcome, for each of the multiple imputations.</p>
</td></tr>    
</table>


<h3>Note</h3>

<p>The multiple-imputation-based residuals are not available for joint models with <code>method = "Cox-PH-GH"</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Cox, D. and Snell, E. (1968) A general definition of residuals. <em>Journal of the Royal Statistical Society, 
Series B</em> <b>30</b>, 248&ndash;275.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D., Verbeke, G. and Molenberghs, G. (2010) Multiple-imputation-based residuals and diagnostic plots 
for joint models of longitudinal and survival outcomes. <em>Biometrics</em> <b>66</b>, 20&ndash;29.
</p>
<p>Rizopoulos, D. (2010) JM: An R Package for the Joint Modelling of Longitudinal and Time-to-Event Data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.jointModel">fitted.jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime * drug - drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# joint model fit, under the additive log cumulative hazard model
fitJOINT &lt;- jointModel(fitLME, fitCOX, 
    timeVar = "obstime")

# residuals for the longitudinal outcome
head(cbind(
    "Marginal" = residuals(fitJOINT),
    "std-Marginal" = residuals(fitJOINT, type = "stand-Marginal"),
    "Subject" = residuals(fitJOINT, type = "Subject"),
    "std-Subject" = residuals(fitJOINT, type = "stand-Subject")
))

# residuals for the survival outcome
head(cbind(
    "Martingale" = residuals(fitJOINT, process = "Event", type = "Martingale"),
    "CoxSnell" = residuals(fitJOINT, process = "Event", type = "CoxSnell")
))

## End(Not run)
</code></pre>

<hr>
<h2 id='rocJM'> Predictive Accuracy Measures for Longitudinal Markers under a Joint Modelling Framework </h2><span id='topic+rocJM'></span><span id='topic+rocJM.jointModel'></span>

<h3>Description</h3>

<p>It computes sensitivity, specificity, ROC and AUC measures for joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocJM(object, dt, data, idVar = "id", directionSmaller = NULL, cc = NULL, min.cc = NULL,
  max.cc = NULL, optThr = c("sens*spec", "youden"), 
  diffType = c("absolute", "relative"), abs.diff = 0, rel.diff = 1, 
  M = 300, burn.in = 100, scale = 1.6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rocJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_dt">dt</code></td>
<td>
<p>a numeric vector indicating the lengths of the time intervals of primary interest within which we want to 
distinguish between subjects who died within the intervals from subjects who survived longer than that.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_data">data</code></td>
<td>
<p>a data frame that contains the baseline covariates for the longitudinal and survival submodels,
including a case identifier (i.e., the variable denoted by the argument <code>idVar</code>), the time points on
which longitudinal measurements are assumed to be taken (this should have the same name as in the argument
<code>timeVar</code> of <code><a href="#topic+jointModel">jointModel</a></code>).</p>
</td></tr>
<tr><td><code id="rocJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>data</code> that identifies the different generic subjects to be considered.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_directionsmaller">directionSmaller</code></td>
<td>
<p>logical; if <code>TRUE</code>, then smaller values for the longitudinal outcome are associated 
with higher risk for an event.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_cc">cc</code></td>
<td>
<p>a numeric vector of threshold values for the longitudinal marker; if <code>NULL</code>, this is computed using 
a regular sequence based on percentiles of the observed marker values.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_min.cc">min.cc</code></td>
<td>
<p>the start of the regular sequence for the threshold values for the longitudinal marker; 
see argument <code>cc</code> above.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_max.cc">max.cc</code></td>
<td>
<p>the end of the regular sequence for the threshold values for the longitudinal marker; 
see argument <code>cc</code> above.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_optthr">optThr</code></td>
<td>
<p>character string defining how the optimal threshold is to be computed. The default chooses the
cut-point for the marker that maximizes the product of sensitivity and specificity. Option <code>"youden"</code>
chooses the cut-point that maximizes Youden's index that equals sensitivity + specificity - 1.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_difftype">diffType</code></td>
<td>
<p>character string defining the type of prediction rule. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_abs.diff">abs.diff</code></td>
<td>
<p>a numeric vector of absolute differences in the definition of composite prediction rules.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_rel.diff">rel.diff</code></td>
<td>
<p>a numeric vector of relative differences in the definition of composite prediction rules.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_burn.in">burn.in</code></td>
<td>
<p>a numeric scalar denoting the iterations to discard.</p>
</td></tr>
<tr><td><code id="rocJM_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar that controls the acceptance rate of the Metropolis-Hastings algorithm. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(<b>Note:</b> the following contain some math formulas, which are better viewed in the pdf version of the manual
accessible at <a href="https://cran.r-project.org/package=JM">https://cran.r-project.org/package=JM</a>.)
</p>
<p>Assume that we have collected longitudinal measurements <code class="reqn">Y_i(t) = \{y_i(s); 0 \leq s \leq t\}</code> up to time point <code class="reqn">t</code> for
subject <code class="reqn">i</code>. We are interested in events occurring in the medically relevant time frame <code class="reqn">(t, t + \Delta t]</code> within which the
physician can take an action to improve the survival chance of the patient. Using an appropriate function of the marker history
<code class="reqn">Y_i(t)</code>, we can define a prediction rule to discriminate between patients of high and low risk for an event.  For instance, 
for in HIV infected patients, we could consider values of CD4 cell count smaller than a specific threshold as predictive for death. 
Since we are in a longitudinal context, we have the flexibility of determining which values of the longitudinal history of the 
patient will contribute to the specification of the prediction rule. That is, we could define a composite prediction rule that is not 
based only on the last available measurement but rather on the last two or last three measurements of a patient. Furthermore, it 
could be of relevance to consider different threshold values for each of these measurements, for instance, we could define as success 
the event that the pre-last CD4 cell count is <code class="reqn">c</code> and the last one <code class="reqn">0.5c</code>, indicating that a 50% decrease is strongly 
indicative for death. Under this setting we define sensitivity and specificity as,
</p>
<p style="text-align: center;"><code class="reqn">Pr \bigl \{ {\cal S}_i(t, k, c) \mid T_i^* &gt; t, T_i^* \in (t, t + \Delta t] \bigr \},</code>
</p>
 
<p>and </p>
<p style="text-align: center;"><code class="reqn">Pr \bigl \{ {\cal F}_i(t, k, c) \mid T_i^* &gt; t, T_i^* &gt; t +
\Delta t \bigr \},</code>
</p>
<p> respectively, where we term <code class="reqn">{\cal S}_i(t, k, c) = \{y_i(s) \leq c_s; k \leq s \leq t\}</code> as success 
(i.e., occurrence of the event of interest), and <code class="reqn">{\cal F}_i(t, k, c) = \{y_i(s) &gt; c_s; k \leq s \leq t\}</code> as a failure,
<code class="reqn">T_i^*</code> denotes the time-to-event, and <code class="reqn">\Delta t</code> the length of the medically relevant time window (specified by argument 
<code>dt</code>). The cut values for the marker <code class="reqn">c</code> are specified by the <code>cc</code>, <code>min.cc</code> and <code>max.cc</code> arguments. Two types of
composite prediction rules can be defined depending on the value of the <code>diffType</code> argument. Absolute prediction rules in which, between
successive measurements there is an absolute difference of between the cut values, and relative prediction rules in which there is a 
relative difference between successive measurements of the marker. The lag values for these differences are defined by the <code>abs.diff</code>
and <code>rel.diff</code> arguments. Some illustrative examples:
</p>

<dl>
<dt>Ex1:</dt><dd><p>keeping the defaults we define a simple rule that is only based on the last available marker measurement.</p>
</dd>
<dt>Ex2:</dt><dd><p>to define a prediction rule that is based on the last two available measurements using the same cut values (e.g.,
if a patient had two successive measurements below a medically relevant threshold), we need to set <code>abs.diff = c(0, 0)</code>.</p>
</dd>
<dt>Ex3:</dt><dd><p>to define a prediction rule that is based on the last two available measurements using a drop of 5 units between the cut 
values (e.g., the pre-last measurement is <code class="reqn">c</code> and the last <code class="reqn">c-5</code>), we need to set <code>abs.diff = c(0, -5)</code>.</p>
</dd>
<dt>Ex4:</dt><dd><p>to define a prediction rule that is based on the last two available measurements using a drop of 20% units between the cut 
values (e.g., the pre-last measurement is <code class="reqn">c</code> and the last <code class="reqn">0.8c</code>), we need to set <code>diffType = "relative"</code> and 
<code>rel.diff = c(0, 0.8)</code>.</p>
</dd>
</dl>

<p>The estimation of the above defined probabilities is achieved with a Monte Carlo scheme similar to the one described in
<code><a href="#topic+survfitJM">survfitJM</a></code>. The number of Monte Carlo samples is defined by the <code>M</code> argument, and the burn-in iterations for
the Metropolis-Hastings algorithm using the <code>burn.in</code> argument.
</p>
<p>More details can be found in Rizopoulos (2011).
</p>


<h3>Value</h3>

<p>An object of class <code>rocJM</code> is a list with components,
</p>
<table role = "presentation">
<tr><td><code>MCresults</code></td>
<td>
<p>a list of length the number of distinct cases in <code>data</code>. Each component of this
list is again a list with four components the estimated Sensitivity <code>Sens</code> and its standard 
error <code>seSens</code>, and the estimated Specificity <code>Spec</code> and its standard error <code>seSpec</code>.
All these four components are matrices with rows corresponding to the different <code>dt</code> values and
columns corresponding to the different <code>cc</code> values.</p>
</td></tr>
<tr><td><code>AUCs</code></td>
<td>
<p>a numeric vector of estimated areas under the ROC curves for the different values of <code>dt</code>.</p>
</td></tr>
<tr><td><code>optThr</code></td>
<td>
<p>a numeric vector with the optimal threshold values for the markers for the different
<code>dt</code> under the choice made in argument <code>optThr</code>.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>a list of length the number of distinct cases in <code>data</code> with components numeric vectors
of the time points at which longitudinal measurements are supposed to be taken.</p>
</td></tr>
<tr><td><code>dt</code></td>
<td>
<p>a copy of the <code>dt</code> argument.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>a copy of the <code>M</code> argument.</p>
</td></tr>
<tr><td><code>diffType</code></td>
<td>
<p>a copy of the <code>diffType</code> argument.</p>
</td></tr>
<tr><td><code>abs.diff</code></td>
<td>
<p>a copy of the <code>abs.diff</code> argument.</p>
</td></tr>
<tr><td><code>rel.diff</code></td>
<td>
<p>a copy of the <code>rel.diff</code> argument.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>a copy of the <code>cc</code> argument.</p>
</td></tr>
<tr><td><code>min.cc</code></td>
<td>
<p>a copy of the <code>min.cc</code> argument.</p>
</td></tr>
<tr><td><code>max.cc</code></td>
<td>
<p>a copy of the <code>max.cc</code> argument.</p>
</td></tr>
<tr><td><code>success.rate</code></td>
<td>
<p>a numeric matrix with the success rates of the Metropolis-Hastings algorithm described above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves.
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. (2010) JM: An R package for the joint modelling of longitudinal and time-to-event data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>
<p>Zheng, Y. and Heagerty, P. (2007). Prospective accuracy for longitudinal markers.
<em>Biometrics</em> <b>63</b>, 332&ndash;341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rocJM">plot.rocJM</a></code>,
<code><a href="#topic+survfitJM">survfitJM</a></code>,
<code><a href="#topic+dynCJM">dynCJM</a></code>,
<code><a href="#topic+aucJM">aucJM</a></code>,
<code><a href="#topic+prederrJM">prederrJM</a></code>,
<code><a href="#topic+jointModel">jointModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fitLME &lt;- lme(sqrt(CD4) ~ obstime * (drug + AZT + prevOI + gender), 
    random = ~ obstime | patient, data = aids)
fitSURV &lt;- coxph(Surv(Time, death) ~ drug + AZT + prevOI + gender, 
    data = aids.id, x = TRUE)
fit.aids &lt;- jointModel(fitLME, fitSURV, timeVar = "obstime", 
    method = "piecewise-PH-aGH")

# the following will take some time to execute...
ND &lt;- aids[aids$patient == "7", ]
roc &lt;- rocJM(fit.aids, dt = c(2, 4, 8), ND, idVar = "patient")
roc

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate'>Simulate from Joint Models.</h2><span id='topic+simulateJM'></span><span id='topic+simulate.jointModel'></span>

<h3>Description</h3>

<p>simulate longitudinal responses and event times from joint models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateJM(nsim, nsub, thetas, times, formulas, Data = NULL, 
    method = c("weibull-PH", "weibull-AFT", "piecewise-PH", "spline-PH"), 
    lag = 0, censoring = "uniform", max.FUtime = NULL, seed = NULL, 
    return.ranef = FALSE)
## S3 method for class 'jointModel'
simulate(object, nsim, seed = NULL, times = NULL, 
    Data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>number of data sets to be simulated.</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsub">nsub</code></td>
<td>
<p>the number of subjects in each data set.</p>
</td></tr>
<tr><td><code id="simulate_+3A_thetas">thetas</code></td>
<td>
<p>a list with the parameter values. This should be of the same structure as 
the <code>coefficients</code> component returned by <code>jointModel()</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_times">times</code></td>
<td>
<p>a numeric vector denoting the time points at which longitudinal measurements
are planned to be taken.</p>
</td></tr>
<tr><td><code id="simulate_+3A_formulas">formulas</code></td>
<td>
<p>a list with components: <code>Yfixed</code> a formula for the fixed-effects part
of the linear mixed model, <code>Yrandom</code> a formula for the random-effects part of the
linear mixed model, <code>Tfixed</code> a formula for the baseline covariates part of the 
survival submodel, <code>timeVar</code> a character string indicating the name of the time 
variable in the linear mixed model.</p>
</td></tr>
<tr><td><code id="simulate_+3A_data">Data</code></td>
<td>
<p>a data frame containing any covariates used in the formulas defined in the
<code>formulas</code> argument.</p>
</td></tr>
<tr><td><code id="simulate_+3A_method">method</code></td>
<td>
<p>a character string indicating from what type of survival submodel to simulate.
There are the same options as the ones provided by <code><a href="#topic+jointModel">jointModel</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_lag">lag</code></td>
<td>
<p>a numeric value denoting a lagged effect; the same as the <code>lag</code> 
argument of <code><a href="#topic+jointModel">jointModel</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_censoring">censoring</code></td>
<td>
<p>a character string or a numeric vector.</p>
</td></tr>
<tr><td><code id="simulate_+3A_max.futime">max.FUtime</code></td>
<td>
<p>a numeric value denoting the maximum follow-up time for the study. The default
is <code>max(times) + 2 * IQR(times)</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should 
be initialized ('seeded'). It could be either <code>NULL</code> or an integer that 
will be used in a call to <code>set.seed()</code> before simulating the response 
vectors. If set, the value is saved as the &quot;seed&quot; attribute of the returned value.</p>
</td></tr>
<tr><td><code id="simulate_+3A_return.ranef">return.ranef</code></td>
<td>
<p>logical; if <code>TRUE</code>, each component of the returned list has the attributed
<code>"ranef"</code> that contains the random-effects values used in the simulation.</p>
</td></tr>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>nsim</code> of data frames that contains the simulated responses 
for the longitudinal process &quot;y&quot;, the simulated event times &quot;Time&quot;, the event indicator 
&quot;Event&quot;, and the subject identification number &quot;id&quot;. If extra covariates were assumed, 
these are also included.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prothro$t0 &lt;- as.numeric(prothro$time == 0)
lmeFit &lt;- lme(pro ~ treat * (time + t0), random = ~ time | id, data = prothro)
survFit &lt;- coxph(Surv(Time, death) ~ treat, data = prothros, x = TRUE)
jointFit &lt;- jointModel(lmeFit, survFit, timeVar = "time", 
    method = "weibull-PH-aGH")

newData &lt;- simulate(jointFit, nsim = 1, times = seq(0, 11, len = 15))
newData

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.weibull.frailty'> Summary Method for weibull.frailty Objects</h2><span id='topic+summary.weibull.frailty'></span>

<h3>Description</h3>

<p>Summarizes the fit of a Weibull model with Gamma frailties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weibull.frailty'
summary(object, sand.se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.weibull.frailty_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>weibull.frailty</code>.</p>
</td></tr>
<tr><td><code id="summary.weibull.frailty_+3A_sand.se">sand.se</code></td>
<td>
<p>logical; if <code>TRUE</code>, sandwich standard errors are also produced.</p>
</td></tr>
<tr><td><code id="summary.weibull.frailty_+3A_...">...</code></td>
<td>
<p> additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+weibull.frailty">weibull.frailty</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- weibull.frailty(Surv(time, status) ~ age + sex, kidney)
summary(fit)
summary(fit, TRUE)
</code></pre>

<hr>
<h2 id='survfitJM'>Prediction in Joint Models</h2><span id='topic+survfitJM'></span><span id='topic+survfitJM.jointModel'></span>

<h3>Description</h3>

 
<p>This function computes the conditional probability of surviving later times than the last observed time for which a
longitudinal measurement was available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survfitJM(object, newdata, ...)

## S3 method for class 'jointModel'
survfitJM(object, newdata, idVar = "id", simulate = TRUE, survTimes = NULL, 
	last.time = NULL, M = 200, CI.levels = c(0.025, 0.975), scale = 1.6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survfitJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code> or <code>survreg()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModel">jointModel</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_survtimes">survTimes</code></td>
<td>
<p>a numeric vector of times for which prediction survival probabilities are to be computed.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_last.time">last.time</code></td>
<td>
<p>a numeric vector or character string. This specifies the known time at which each of the subjects in <code>newdat</code>
was known to be alive. If <code>NULL</code>, then this is automatically taken as the last time each subject provided a longitudinal
measurement. If a numeric vector, then it is assumed to contain this last time point for each subject. If a character string, then
it should be a variable in the data frame <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_m">M</code></td>
<td>
<p>integer denoting how many Monte Carlo samples to use &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_ci.levels">CI.levels</code></td>
<td>
<p>a numeric vector of length two that specifies which quantiles to use for the calculation of confidence interval for the 
predicted probabilities &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar that controls the acceptance rate of the Metropolis-Hastings algorithm &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>), and a history of longitudinal responses 
<code class="reqn">\tilde{y}_i(t) = \{y_i(s), 0 \leq s \leq t\}</code> and a covariates vector <code class="reqn">x_i</code> (stored in
<code>newdata</code>), this function provides estimates of <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code>, i.e., the conditional probability of surviving time <code class="reqn">u</code> given that subject <code class="reqn">i</code>, with covariate information
<code class="reqn">x_i</code>, has survived up to time <code class="reqn">t</code> and has provided longitudinal the measurements <code class="reqn">\tilde{y}_i(t)</code>.
</p>
<p>To estimate <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code> and if <code>simulate = TRUE</code>, a 
Monte Carlo procedure is followed with the following steps:
</p>

<dl>
<dt>Step 1:</dt><dd><p>Simulate new parameter values, say <code class="reqn">\theta^*</code>, from <code class="reqn">N(\hat{\theta}, C(\hat{\theta}))</code>,
where <code class="reqn">\hat{\theta}</code> are the MLEs and <code class="reqn">C(\hat{\theta})</code> their large sample covariance matrix, which are extracted from
<code>object</code>.</p>
</dd>
<dt>Step 2:</dt><dd><p>Simulate random effects values, say <code class="reqn">b_i^*</code>, from their posterior distribution given survival up to time <code class="reqn">t</code>,
the vector of longitudinal responses <code class="reqn">\tilde{y}_i(t)</code> and <code class="reqn">\theta^*</code>. This is achieved using a Metropolis-Hastings algorithm with
independent proposals from a properly centered and scaled multivariate <code class="reqn">t</code> distribution. The <code>scale</code> argument controls the 
acceptance rate for this algorithm.</p>
</dd>
<dt>Step 3</dt><dd><p>Using <code class="reqn">\theta^*</code> and <code class="reqn">b_i^*</code>, compute <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, b_i^*, x_i; \theta^*)</code>.</p>
</dd>
<dt>Step 4:</dt><dd><p>Repeat Steps 1-3 <code>M</code> times.</p>
</dd>
</dl>

<p>Based on the <code>M</code> estimates of the conditional probabilities, we compute useful summary statistics, such as their mean, median, and
quantiles (to produce a confidence interval).
</p>
<p>If <code>simulate = FALSE</code>, then survival probabilities are estimated using the formula </p>
<p style="text-align: center;"><code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \hat{b}_i, x_i; 
    \hat{\theta}),</code>
</p>
<p> where <code class="reqn">\hat{\theta}</code> denotes the MLEs as above, and <code class="reqn">\hat{b}_i</code>
denotes the empirical Bayes estimates.
</p>


<h3>Value</h3>

<p>A list of class <code>survfitJM</code> with components:
</p>
<table role = "presentation">
<tr><td><code>summaries</code></td>
<td>
<p>a list with elements numeric matrices with numeric summaries of the predicted probabilities for each subject.</p>
</td></tr>
<tr><td><code>survTimes</code></td>
<td>
<p>a copy of the <code>survTimes</code> argument.</p>
</td></tr>
<tr><td><code>last.time</code></td>
<td>
<p>a numeric vector with the time of the last available longitudinal measurement of each subject.</p>
</td></tr>
<tr><td><code>obs.times</code></td>
<td>
<p>a list with elements numeric vectors denoting the timings of the longitudinal measurements for each subject.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list with elements numeric vectors denoting the longitudinal responses for each subject.</p>
</td></tr>
<tr><td><code>full.results</code></td>
<td>
<p>a list with elements numeric matrices with predicted probabilities for each subject in each replication of the Monte Carlo
scheme described above.</p>
</td></tr>
<tr><td><code>success.rate</code></td>
<td>
<p>a numeric vector with the success rates of the Metropolis-Hastings algorithm described above for each subject.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>a copy of the <code>scale</code> argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Predicted probabilities are not computed for joint models with <code>method = "ch-Laplace"</code> and <code>method = "Cox-PH-GH"</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for longitudinal and time-to-event data. 
<em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. (2010) JM: An R Package for the Joint Modelling of Longitudinal and Time-to-Event Data. 
<em>Journal of Statistical Software</em> <b>35</b> (9), 1&ndash;33. <a href="https://doi.org/10.18637/jss.v035.i09">doi:10.18637/jss.v035.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code>, <code><a href="#topic+plot.survfitJM">plot.survfitJM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime + obstime:drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# joint model fit
fitJOINT &lt;- jointModel(fitLME, fitCOX, 
    timeVar = "obstime", method = "weibull-PH-aGH")

# sample of the patients who are still alive
ND &lt;- aids[aids$patient == "141", ]
ss &lt;- survfitJM(fitJOINT, newdata = ND, idVar = "patient", M = 50)
ss
</code></pre>

<hr>
<h2 id='wald.strata'> Wald Test for Stratification Factors </h2><span id='topic+wald.strata'></span>

<h3>Description</h3>

<p>It performs a Wald test to test the hypothesis of equal spline coefficients among strata 
in the approximation of baseline risk function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wald.strata(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wald.strata_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>jointModel</code> with <code>method = "spline-PH-GH"</code>
and with a strata specification in the survival part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>wald.strata</code> with components:
</p>
<table role = "presentation">
<tr><td><code>alternative</code></td>
<td>
<p>a character string naming the alternative.</p>
</td></tr>
<tr><td><code>Result</code></td>
<td>
<p>a numeric matrix with the results of the Wald test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This test is valid when the same knots have been used across strata.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fitLME &lt;- lme(log(serBilir) ~ drug * year - drug, random = ~ year | id, 
    data = pbc2)
fitSURV &lt;- coxph(Surv(years, status2) ~ drug + strata(hepatomegaly), 
    data = pbc2.id, x = TRUE)
fit.pbc &lt;- jointModel(fitLME, fitSURV, timeVar = "year", method = "spline-PH-aGH")
wald.strata(fit.pbc)

## End(Not run)
</code></pre>

<hr>
<h2 id='weibull.frailty'> Weibull Model with Gamma Frailties </h2><span id='topic+weibull.frailty'></span>

<h3>Description</h3>

<p>Fits a Weibull model with Gamma frailties for multivariate survival data under maximum likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weibull.frailty(formula = formula(data), data = parent.frame(), 
    id = "id", subset, na.action, init, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibull.frailty_+3A_formula">formula</code></td>
<td>
<p> an object of class <code>formula</code>: a symbolic description of the model to be fitted. The response must 
be a survival object as returned by function <code>Surv()</code>.</p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables specified in the model. </p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_id">id</code></td>
<td>
<p> either a character string denoting a variable name in <code>data</code> or a numeric vector specifying which event times belong to
the same cluster (e.g., hospital, patient, etc.).</p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be used in the fitting process. </p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_na.action">na.action</code></td>
<td>
<p> what to do with missing values. </p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_init">init</code></td>
<td>
<p> a numeric vector of length <code class="reqn">p + 3</code> of initial values. The first <code class="reqn">p</code> elements should correspond to the regression coefficients 
for the covariates, and the last <code class="reqn">3</code> to log-scale, log-shape, and log-frailty-variance, respectively. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="weibull.frailty_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>

<dl>
<dt>optimizer</dt><dd><p>a character string indicating which optimizer to use; options are &quot;optim&quot; (default) and
&quot;nlminb&quot;.</p>
</dd>
<dt>parscale</dt><dd><p>the <code>parscale</code> control argument for <code>optim()</code>, or the <code>scale</code> argument for 
<code>nlminb()</code>. It should be a numeric vector of length equal to the number of parameters. Default is 0.01
for all parameters.</p>
</dd>
<dt>maxit</dt><dd><p>the maximum number of iterations. Default is 500.</p>
</dd>
<dt>numeriDeriv</dt><dd><p>a character string indicating which type of numerical derivative to use to compute the
Hessian matrix; options are &quot;fd&quot; denoting the forward difference approximation, and &quot;cd&quot; (default)
denoting the central difference approximation.</p>
</dd>
<dt>eps.Hes</dt><dd><p>tolerance value used in the numerical derivative method. Default is 1e-03.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The fitted model is defined as follows: </p>
<p style="text-align: center;"><code class="reqn">\lambda(t_i | \omega_i) = \lambda_0(t_i) \omega_i \exp(x_i^T \beta),</code>
</p>
<p> where <code class="reqn">i</code> denotes the subject, <code class="reqn">\lambda(\cdot)</code> 
denotes the hazard function, conditionally on the frailty <code class="reqn">\omega_i</code>, <code class="reqn">x_i</code> is a vector of covariates with corresponding regression 
coefficients <code class="reqn">\beta</code>, and <code class="reqn">\lambda_0(\cdot)</code> is the Weibull baseline hazard defined as <code class="reqn">\lambda_0(t) = shape * 
  scale * t^{shape -1}</code>. Finally, for the frailties we assume <code class="reqn">\omega_i \sim Gamma(\eta, \eta)</code>, with 
<code class="reqn">\eta^{-1}</code> denoting the unknown variance of <code class="reqn">\omega_i</code>'s.
</p>


<h3>Value</h3>

<p>an object of class <code>weibull.frailty</code> with components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a list with the estimated coefficients values. The components of this list are: <code>betas</code>, <code>scale</code>, <code>shape</code>, 
and <code>var.frailty</code>, and correspond to the coefficients with the same name.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>the hessian matrix at convergence. For the shape, scale, and var-frailty parameters the Hessian is computed on the log scale.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood value.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the <code>control</code> argument.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>an object of class <code>Surv</code> containing the observed event times and the censoring indicator.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the design matrix of the model.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>a numeric vector specifying which event times belong to the same cluster.</p>
</td></tr>
<tr><td><code>nam.id</code></td>
<td>
<p>the value of argument <code>id</code>, if that was a character string.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the term component of the fitted model.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a copy of <code>data</code> or the created <code>model.frame</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>weibull.frailty()</code> currently supports only right-censored data.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>weibull.frailty(Surv(time, status) ~ age + sex, kidney)
</code></pre>

<hr>
<h2 id='xtable'>xtable Method from Joint Models.</h2><span id='topic+xtable.jointModel'></span>

<h3>Description</h3>

<p>produces a LaTeX table with the results of a joint model using package xtable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointModel'
xtable(x, caption = NULL, label = NULL, align = NULL,
    digits = NULL, display = NULL, which = c("all", "Longitudinal", "Event"),
    varNames.Long = NULL, varNames.Event = NULL, p.values = TRUE, 
    digits.pval = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xtable_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_caption">caption</code></td>
<td>
<p>the <code>caption</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_label">label</code></td>
<td>
<p>the <code>label</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_align">align</code></td>
<td>
<p>the <code>align</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_digits">digits</code></td>
<td>
<p>the <code>digits</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_display">display</code></td>
<td>
<p>the <code>display</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_which">which</code></td>
<td>
<p>a character string indicating which results to include in the
LaTeX table. Options are all results, the results of longitudinal
submodel or the results of the survival submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_varnames.long">varNames.Long</code></td>
<td>
<p>a character vector of the variable names for the
longitudinal submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_varnames.event">varNames.Event</code></td>
<td>
<p>a character vector of the variable names for the
survival submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_p.values">p.values</code></td>
<td>
<p>logical; should p-values be included in the table.</p>
</td></tr>
<tr><td><code id="xtable_+3A_digits.pval">digits.pval</code></td>
<td>
<p>a numeric scalare denoting the number of significance
digits in the <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code id="xtable_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LaTeX code chunk with the results of the joint modeling analysis.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModel">jointModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(xtable)
prothro$t0 &lt;- as.numeric(prothro$time == 0)
lmeFit &lt;- lme(pro ~ treat * (time + t0), random = ~ time | id, data = prothro)
survFit &lt;- coxph(Surv(Time, death) ~ treat, data = prothros, x = TRUE)
jointFit &lt;- jointModel(lmeFit, survFit, timeVar = "time", 
    method = "weibull-PH-aGH")

xtable(jointFit, math.style.negative = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
