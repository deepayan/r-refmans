<!DOCTYPE html><html><head><title>Help for package kit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#charToFact'><p>Convert Character Vector to Factor</p></a></li>
<li><a href='#count'><p> count, countNA and countOccur</p></a></li>
<li><a href='#fduplicated+2Ffunique'><p> Fast duplicated and unique</p></a></li>
<li><a href='#fpos'><p> Find a matrix position inside a larger matrix</p></a></li>
<li><a href='#iif'><p> Fast if else</p></a></li>
<li><a href='#nif'><p>Nested if else</p></a></li>
<li><a href='#parallel-funs'><p>Parallel (Statistical) Functions</p></a></li>
<li><a href='#psort'><p>Parallel Sort</p></a></li>
<li><a href='#setlevels'><p> Set levels of a factor object</p></a></li>
<li><a href='#shareData+2FgetData+2FclearData'><p> Share Data between R Sessions</p></a></li>
<li><a href='#topn'><p> Top N values index</p></a></li>
<li><a href='#vswitch+2Fnswitch'><p> Vectorised switch</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Manipulation Functions Implemented in C</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Morgan Jacob [aut, cre, cph],
  Sebastian Krantz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Morgan Jacob &lt;morgan.emailbox@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic functions, implemented in C, for large data manipulation. Fast vectorised ifelse()/nested if()/switch() functions, psum()/pprod() functions equivalent to pmin()/pmax() plus others which are missing from base R. Most of these functions are callable at C level.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/2005m/kit/issues">https://github.com/2005m/kit/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 23:04:07 UTC; giuliabertuzzi</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='charToFact'>Convert Character Vector to Factor</h2><span id='topic+charToFact'></span>

<h3>Description</h3>

<p>Similar to <code>base::as.factor</code> but much faster and only for converting character vector to factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charToFact(x, decreasing=FALSE, addNA=TRUE,
           nThread=getOption("kit.nThread"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charToFact_+3A_x">x</code></td>
<td>
<p> A vector of type character</p>
</td></tr>
<tr><td><code id="charToFact_+3A_decreasing">decreasing</code></td>
<td>
<p> A boolean. Whether to order levels in decreasing order or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="charToFact_+3A_addna">addNA</code></td>
<td>
<p> A boolean. Whether to include <code>NA</code> in levels of the output or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="charToFact_+3A_nthread">nThread</code></td>
<td>
<p> Number of thread to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character vector input as a factor. Please note that, unlike <code>as.factor</code>, <code>NA</code> levels are preserved by default, however this can be changed by setting argument <code>addNA</code> to <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("b","A","B","a","\xe4","a")
Encoding(x) = "latin1"
identical(charToFact(x), as.factor(x))
identical(charToFact(c("a","b",NA,"a")), addNA(as.factor(c("a","b",NA,"a"))))
identical(charToFact(c("a","b",NA,"a"), addNA=FALSE), as.factor(c("a","b",NA,"a")))

# Benchmarks
# ----------
# x = sample(letters,3e7,TRUE)
# microbenchmark::microbenchmark(
#   kit=kit::charToFact(x,nThread = 1L),
#   base=as.factor(x),
#   times = 5L
# )
# Unit: milliseconds
# expr  min   lq   mean  median   uq  max neval
# kit   188  190    196     194  200  208     5
# base 1402 1403   1455    1414 1420 1637     5
</code></pre>

<hr>
<h2 id='count'> count, countNA and countOccur</h2><span id='topic+count'></span><span id='topic+countNA'></span><span id='topic+countOccur'></span>

<h3>Description</h3>

<p>Simple functions to count the number of times an element occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  count(x, value)
  countNA(x)
  countOccur(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_x">x</code></td>
<td>
<p> A vector or list for <code>countNA</code>. A vector for <code>count</code> and a vector or <code>data.frame</code> for <code>countOccur</code>.</p>
</td></tr>
<tr><td><code id="count_+3A_value">value</code></td>
<td>
<p> An element to look for. Must be non <code>NULL</code>, of length 1 and same type as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a vector <code>countNA</code> will return the total number of <code>NA</code> value. For a list, <code>countNA</code> will return a list with the number of <code>NA</code> in each item of the list.
This is a major difference with <code>sum(is.na(x))</code> which will return the aggregated number of <code>NA</code>.
Also, please note that every item of a list can be of different type and <code>countNA</code> will take them into account whether they are of type logical (<code>NA</code>), integer (<code>NA_integer_</code>), double (<code>NA_real_</code>), complex (<code>NA_complex_</code>) or character (<code>NA_character_</code>).
As opposed to <code>countNA</code>, <code>count</code> does not support list type and requires <code>x</code> and <code>value</code> to be of the same type.
Function <code>countOccur</code> takes vectors or data.frame as inputs and returns a <code>data.frame</code> with the number of times each value in the vector occurs or number of times each row in a <code>data.frame</code> occurs.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcount">pcount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1, 3, NA, 5)
count(x, 3)

countNA(x)
countNA(as.list(x))

countOccur(x)

# Benchmarks countNA
# ------------------
# x = sample(c(TRUE,NA,FALSE),1e8,TRUE) # 382 Mb
# microbenchmark::microbenchmark(
#   countNA(x),
#   sum(is.na(x)),
#   times=5L
# )
# Unit: milliseconds
#          expr   min    lq   mean  median    uq   max neval
# countNA(x)     98.7  99.2  101.2   100.1 101.4 106.4     5
# sum(is.na(x)) 405.4 441.3  478.9   461.1 523.9 562.6     5
#
# Benchmarks countOccur
# ---------------------
# x = rnorm(1e6)
# y = data.table::data.table(x)
# microbenchmark::microbenchmark(
#   kit= countOccur(x),
#   data.table = y[, .N, keyby = x],
#   table(x),
#   times = 10L
# )
# Unit: milliseconds
# expr        min         lq     mean    median      uq     max neval
# kit          62.26   63.88    89.29     75.49   95.17  162.40    10
# data.table  189.17  194.08   235.30    227.43  263.74  337.74    10 # setDTthreads(1L)
# data.table  140.15  143.91   190.04    182.85  234.48  261.43    10 # setDTthreads(2L)
# table(x)   3560.77 3705.06  3843.47   3807.12 4048.40 4104.11    10
</code></pre>

<hr>
<h2 id='fduplicated+2Ffunique'> Fast duplicated and unique</h2><span id='topic+fduplicated'></span><span id='topic+funique'></span><span id='topic+uniqLen'></span>

<h3>Description</h3>

<p>Similar to base R functions <code>duplicated</code> and <code>unique</code>, <code>fduplicated</code> and <code>funique</code> are slightly faster for vectors and much faster for <code>data.frame</code>. Function <code>uniqLen</code> is equivalent to base R <code>length(unique)</code> or <code>data.table::uniqueN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fduplicated(x, fromLast = FALSE)
  funique(x, fromLast = FALSE)
  uniqLen(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fduplicated+2B2Ffunique_+3A_x">x</code></td>
<td>
<p> A vector, data.frame or matrix.</p>
</td></tr>
<tr><td><code id="fduplicated+2B2Ffunique_+3A_fromlast">fromLast</code></td>
<td>
<p> A logical value to indicate whether the search should start from the end or beginning. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>fduplicated</code> returns a logical vector and <code>funique</code> returns a vector of the same type as <code>x</code> without the duplicated value. Function <code>uniqLen</code> returns an integer.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: fduplicated
fduplicated(iris$Species)

# Example 2: funique
funique(iris$Species)

# Example 3: uniqLen
uniqLen(iris$Species)

# Benchmarks
# ----------
# x = sample(c(1:10,NA_integer_),1e8,TRUE) # 382 Mb
# microbenchmark::microbenchmark(
#   duplicated(x),
#   fduplicated(x),
#   times = 5L
# )
# Unit: seconds
#           expr  min   lq  mean  median   uq   max neval
# duplicated(x)  2.21 2.21  2.48    2.21 2.22  3.55     5
# fduplicated(x) 0.38 0.39  0.45    0.48 0.49  0.50     5
#
# vs data.table
# -------------
# df = iris[,5:1]
# for (i in 1:16) df = rbind(df, df)  # 338 Mb
# dt = data.table::as.data.table(df)
# microbenchmark::microbenchmark(
#   kit = funique(df),
#   data.table = unique(dt),
#   times = 5L
# )
# Unit: seconds
#       expr  min   lq  mean  median    uq  max neval
# kit        1.22 1.27  1.33    1.27  1.36 1.55     5
# data.table 6.20 6.24  6.43    6.33  6.46 6.93     5 # (setDTthreads(1L))
# data.table 4.20 4.25  4.47    4.26  4.32 5.33     5 # (setDTthreads(2L))
#
# microbenchmark::microbenchmark(
#   kit=uniqLen(x),
#   data.table=uniqueN(x),
#   times = 5L, unit = "s"
# )
# Unit: seconds
#       expr  min    lq  mean  median   uq  max neval
# kit        0.17  0.17  0.17   0.17  0.17 0.17     5
# data.table 1.66  1.68  1.70   1.71  1.71 1.72     5 # (setDTthreads(1L))
# data.table 1.13  1.15  1.16   1.16  1.18 1.18     5 # (setDTthreads(2L))
</code></pre>

<hr>
<h2 id='fpos'> Find a matrix position inside a larger matrix </h2><span id='topic+fpos'></span>

<h3>Description</h3>

<p>The function <code>fpos</code> returns the locations (row and column index) where a small matrix may be found in a larger matrix. The function also works with vectors.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fpos(needle, haystack, all=TRUE, overlap=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpos_+3A_needle">needle</code></td>
<td>
<p> A matrix or vector to search for in the larger matrix or vector <code>haystack</code>. Note that the <code>needle</code> dimensions (row and column size) must be smaller than the <code>haystack</code> dimensions. </p>
</td></tr>
<tr><td><code id="fpos_+3A_haystack">haystack</code></td>
<td>
<p> A matrix or vector to look into.</p>
</td></tr>
<tr><td><code id="fpos_+3A_all">all</code></td>
<td>
<p> A logical value to indicate whether to return all occurrences (<code>TRUE</code>) or only the first one (<code>FALSE</code>). Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fpos_+3A_overlap">overlap</code></td>
<td>
<p> A logical value to indicate whether to allow the small matrix occurrences to overlap or not. Default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two columns matrix that contains the position or index where the small matrix (needle) can be found in the larger matrix. The first column refers to rows and the second to columns. In case both the needle and haystack are vectors, a vector is returned.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: find a matrix inside a larger one
big_matrix = matrix(c(1:30), nrow = 10)
small_matrix = matrix(c(14, 15, 24, 25), nrow = 2)

fpos(small_matrix, big_matrix)

# Example 2: find a vector inside a larger one  
fpos(14:15, 1:30)

# Example 3: 
big_matrix = matrix(c(1:5), nrow = 10, ncol = 5)
small_matrix = matrix(c(2:3), nrow = 2, ncol = 2)

# return all occurences
fpos(small_matrix, big_matrix)

# return only the first
fpos(small_matrix, big_matrix, all = FALSE)

# return non overlapping occurences
fpos(small_matrix, big_matrix, overlap = FALSE)

# Benchmarks
# ----------
# x = matrix(1:5, nrow=1e4, ncol=5e3) # 191Mb
# microbenchmark::microbenchmark(
#  fpos=kit::fpos(1L, x),
#  which=which(x==1L, arr.ind=TRUE),
#  times=10L
# )
# Unit: milliseconds
#  expr  min  lq  mean median   uq  max neval
# fpos   202  206  220    221  231  241    10
# which  612  637  667    653  705  724    10
</code></pre>

<hr>
<h2 id='iif'> Fast if else </h2><span id='topic+iif'></span>

<h3>Description</h3>

<p><code>iif</code> is a faster and more robust replacement of <code><a href="base.html#topic+ifelse">ifelse</a></code>. It is comparable to <code>dplyr::if_else</code>, <code>hutils::if_else</code> and <code>data.table::fifelse</code>. It returns a value with the same length as <code>test</code> filled with corresponding values from <code>yes</code>, <code>no</code> or eventually <code>na</code>, depending on <code>test</code>. It does not support S4 classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  iif(test, yes, no, na=NULL, tprom=FALSE, nThread=getOption("kit.nThread"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iif_+3A_test">test</code></td>
<td>
<p> A logical vector. </p>
</td></tr>
<tr><td><code id="iif_+3A_yes">yes</code>, <code id="iif_+3A_no">no</code></td>
<td>
<p> Values to return depending on <code>TRUE</code>/<code>FALSE</code> element of <code>test</code>. They must be the same type and be either length <code>1</code> or the same length of <code>test</code>. </p>
</td></tr>
<tr><td><code id="iif_+3A_na">na</code></td>
<td>
<p> Value to return if an element of <code>test</code> is missing. It must be the same type as <code>yes</code>/<code>no</code> and be either length <code>1</code> or the same length of <code>test</code>. Please note that <code>NA</code> is treated as logical value of length 1 as per the R documentation. <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code> and <code>NA_character_</code> are equivalent to <code>NA</code> but for integer, double, complex and character. Default value for argument <code>na</code> is <code>NULL</code> and will automatically default to the equivalent NA type of argument <code>yes</code>.</p>
</td></tr>
<tr><td><code id="iif_+3A_tprom">tprom</code></td>
<td>
<p> Argument to indicate whether type promotion of <code>yes</code> and <code>no</code> is allowed or not. Either <code>FALSE</code> or <code>TRUE</code>, default is <code>FALSE</code> to not allow type promotion. </p>
</td></tr>
<tr><td><code id="iif_+3A_nthread">nThread</code></td>
<td>
<p> A integer for the number of threads to use with <em>openmp</em>. Default value is <code>getOption("kit.nThread")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code><a href="base.html#topic+ifelse">ifelse</a></code> attributes are copied from <code>yes</code> to the output. This is useful when returning <code>Date</code>, <code>factor</code> or other classes.
Like <code>dplyr::if_else</code> and <code>hutils::if_else</code>, the <code>na</code> argument is by default set to <code>NULL</code>. This argument is set to <code>NA</code> in data.table::fifelse.
Similarly to <code>dplyr::if_else</code> and when <code>tprom=FALSE</code>, <code>iif</code> requires same type for arguments <code>yes</code> and <code>no</code>. This is not strictly the case for <code>data.table::fifelse</code> which will coerce integer to double. 
When <code>tprom=TRUE</code>, <code>iif</code> behavior is similar to <code>base::ifelse</code> in the sense that it will promote or coerce <code>yes</code> and <code>no</code>to the &quot;highest&quot; used type. Note, however, that unlike <code>base::ifelse</code> attributes are still conserved.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>test</code> and attributes as <code>yes</code>. Data values are taken from the values of <code>yes</code> and <code>no</code>, eventually <code>na</code>.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>See Also</h3>

<p><code><a href="#topic+nif">nif</a></code>
<code><a href="#topic+vswitch">vswitch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1:4, 3:2, 1:4)
iif(x &gt; 2L, x, x - 1L)

# unlike ifelse, iif preserves attributes, taken from the 'yes' argument
dates = as.Date(c("2011-01-01","2011-01-02","2011-01-03","2011-01-04","2011-01-05"))
ifelse(dates == "2011-01-01", dates - 1, dates)
iif(dates == "2011-01-01", dates - 1, dates)
yes = factor(c("a","b","c"))
no = yes[1L]
ifelse(c(TRUE,FALSE,TRUE), yes, no)
iif(c(TRUE,FALSE,TRUE), yes, no)

# Example of using the 'na' argument
iif(test = c(-5L:5L &lt; 0L, NA), yes = 1L, no = 0L, na = 2L)

# Example of using the 'tprom' argument
iif(test = c(-5L:5L &lt; 0L, NA), yes = 1L, no = "0", na = 2L, tprom = TRUE)
</code></pre>

<hr>
<h2 id='nif'>Nested if else</h2><span id='topic+nif'></span>

<h3>Description</h3>

<p><code>nif</code> is a fast implementation of SQL <code>CASE WHEN</code> statement for R. Conceptually, <code>nif</code> is a nested version of <code><a href="#topic+iif">iif</a></code> (with smarter implementation than manual nesting). It is not the same but it is comparable to <code>dplyr::case_when</code> and <code>data.table::fcase</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nif(..., default=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nif_+3A_...">...</code></td>
<td>
<p> A sequence consisting of logical condition (<code>when</code>)-resulting value (<code>value</code>) <em>pairs</em> in the following order <code>when1, value1, when2, value2, ..., whenN, valueN</code>. Logical conditions <code>when1, when2, ..., whenN</code> must all have the same length, type and attributes. Each <code>value</code> may either share length with <code>when</code> or be length 1. Please see Examples section for further details.</p>
</td></tr>
<tr><td><code id="nif_+3A_default">default</code></td>
<td>
<p> Default return value, <code>NULL</code> by default, for when all of the logical conditions <code>when1, when2, ..., whenN</code> are <code>FALSE</code> or missing for some entries. Argument <code>default</code> can be a vector either of length 1 or length of logical conditions <code>when1, when2, ..., whenN</code>. Note that argument 'default' must be named explicitly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>data.table::fcase</code>, the <code>default</code> argument is set to <code>NULL</code>. In addition, <code>nif</code> can be called by other packages at C level. Note that at C level, the function has an additional argument <code>SEXP md</code> which is either <code>TRUE</code> for lazy evaluation or <code>FALSE</code> for non lazy evaluation. This argument is not exposed to R users and is more for C users.
</p>


<h3>Value</h3>

<p>Vector with the same length as the logical conditions (<code>when</code>) in <code>...</code>, filled with the corresponding values (<code>value</code>) from <code>...</code>, or eventually <code>default</code>. Attributes of output values <code>value1, value2, ...valueN</code> in <code>...</code> are preserved.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>See Also</h3>

<p><code><a href="#topic+iif">iif</a></code>
<code><a href="#topic+vswitch">vswitch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:10
nif(
	x &lt; 5L, 1L,
	x &gt; 5L, 3L
)

nif(
	x &lt; 5L, 1L:10L,
	x &gt; 5L, 3L:12L
)

# Lazy evaluation example
nif(
	x &lt; 5L, 1L,
	x &gt;= 5L, 3L,
	x == 5L, stop("provided value is an unexpected one!")
)

# nif preserves attributes, example with dates
nif(
	x &lt; 5L, as.Date("2019-10-11"),
	x &gt; 5L, as.Date("2019-10-14")
)

# nif example with factor; note the matching levels
nif(
	x &lt; 5L, factor("a", levels=letters[1:3]),
	x &gt; 5L, factor("b", levels=letters[1:3])
)

# Example of using the 'default' argument
nif(
	x &lt; 5L, 1L,
	x &gt; 5L, 3L,
	default = 5L
)

nif(
	x &lt; 5L, 1L,
	x &gt; 5L, 3L,
	default = rep(5L, 10L)
)
</code></pre>

<hr>
<h2 id='parallel-funs'>Parallel (Statistical) Functions</h2><span id='topic+psum'></span><span id='topic+pprod'></span><span id='topic+pall'></span><span id='topic+pallNA'></span><span id='topic+pallv'></span><span id='topic+pany'></span><span id='topic+panyNA'></span><span id='topic+panyv'></span><span id='topic+pmean'></span><span id='topic+pcount'></span><span id='topic+pcountNA'></span><span id='topic+pfirst'></span><span id='topic+plast'></span>

<h3>Description</h3>

<p>Vector-valued (statistical) functions operating in parallel over vectors passed as arguments, or a single list of vectors (such as a data frame). Similar to <code><a href="base.html#topic+pmin">pmin</a></code> and <code><a href="base.html#topic+pmax">pmax</a></code>, except that these functions do not recycle vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  psum(..., na.rm = FALSE)
  pprod(..., na.rm = FALSE)
  pmean(..., na.rm = FALSE)
  pfirst(...)  # (na.rm = TRUE)
  plast(...)   # (na.rm = TRUE)
  pall(..., na.rm = FALSE)
  pallNA(...)
  pallv(..., value)
  pany(..., na.rm = FALSE)
  panyNA(...)
  panyv(..., value)
  pcount(..., value)
  pcountNA(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel-funs_+3A_...">...</code></td>
<td>
<p> suitable (atomic) vectors of the same length, or a single list of vectors (such as a <code>data.frame</code>). See Details on the allowed data types for each function, and Examples.</p>
</td></tr>
<tr><td><code id="parallel-funs_+3A_na.rm">na.rm</code></td>
<td>
<p> A logical indicating whether missing values should be removed. Default value is <code>FALSE</code>, except for <code>pfirst</code> and <code>plast</code>.</p>
</td></tr>
<tr><td><code id="parallel-funs_+3A_value">value</code></td>
<td>
<p> A non <code>NULL</code> value of length 1. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Functions <code>psum</code>, <code>pprod</code> work for integer, logical, double and complex types. <code>pmean</code> only supports integer, logical and double types. All 3 functions will error if used with factors.
</p>
<p><code>pfirst</code>/<code>plast</code> select the first/last non-missing value (or non-empty or <code>NULL</code> value for list-vectors). They accept all vector types with defined missing values + lists, but can only jointly handle integer and double types (not numeric and complex or character and factor). If factors are passed, they all need to have identical levels.
</p>
<p><code>pany</code> and <code>pall</code> are derived from base functions <code>all</code> and <code>any</code> and only allow logical inputs.
</p>
<p><code>pcount</code> counts the occurrence of <code>value</code>, and expects arguments of the same data type (except for <code>value = NA</code>). <code>pcountNA</code> is equivalent to <code>pcount</code> with <code>value = NA</code>, and they both allow <code>NA</code> counting in mixed-type data. <code>pcountNA</code> additionally supports list vectors and counts empty or <code>NULL</code> elements as <code>NA</code>. 
</p>
<p>Functions <code>panyv/pallv</code> are wrappers around <code>pcount</code>, and <code>panyNA/pallNA</code> are wrappers around <code>pcountNA</code>. They return a logical vector instead of the integer count. 
</p>
<p>None of these functions recycle vectors i.e. all input vectors need to have the same length. All functions support long vectors with up to <code>2^64-1</code> elements.
</p>


<h3>Value</h3>

<p><code>psum/pprod/pmean</code> return the sum, product or mean of all arguments. The value returned will be of the highest argument type (integer &lt; double &lt; complex). <code>pprod</code> only returns double or complex. <code>pall[v/NA]</code> and <code>pany[v/NA]</code> return a logical vector. <code>pcount[NA]</code> returns an integer vector. <code>pfirst/plast</code> return a vector of the same type as the inputs. 
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob and Sebastian Krantz</p>


<h3>See Also</h3>

<p>Package 'collapse' provides column-wise and scalar-valued analogues to many of these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1, 3, NA, 5)
y = c(2, NA, 4, 1)
z = c(3, 4, 4, 1)

# Example 1: psum 
psum(x, y, z, na.rm = FALSE)
psum(x, y, z, na.rm = TRUE)

# Example 2: pprod
pprod(x, y, z, na.rm = FALSE)
pprod(x, y, z, na.rm = TRUE)

# Example 3: pmean
pmean(x, y, z, na.rm = FALSE)
pmean(x, y, z, na.rm = TRUE)

# Example 4: pfirst and plast
pfirst(x, y, z)
plast(x, y, z)

# Adjust x, y, and z to use in pall and pany
x = c(TRUE, FALSE, NA, FALSE)
y = c(TRUE, NA, TRUE, TRUE)
z = c(TRUE, TRUE, FALSE, NA)

# Example 5: pall
pall(x, y, z, na.rm = FALSE)
pall(x, y, z, na.rm = TRUE)

# Example 6: pany
pany(x, y, z, na.rm = FALSE)
pany(x, y, z, na.rm = TRUE)

# Example 7: pcount
pcount(x, y, z, value = TRUE)
pcountNA(x, y, z)

# Example 8: list/data.frame as an input
pprod(iris[,1:2])
psum(iris[,1:2])
pmean(iris[,1:2])

# Benchmarks
# ----------
# n = 1e8L
# x = rnorm(n) # 763 Mb
# y = rnorm(n)
# z = rnorm(n)
# 
# microbenchmark::microbenchmark(
#   kit=psum(x, y, z, na.rm = TRUE),
#   base=rowSums(do.call(cbind,list(x, y, z)), na.rm=TRUE),
#   times = 5L, unit = "s"
# )
# Unit: Second
# expr  min   lq mean median   uq  max neval
# kit  0.52 0.52 0.65   0.55 0.83 0.84     5
# base 2.16 2.27 2.34   2.35 2.43 2.49     5
#
# x = sample(c(TRUE, FALSE, NA), n, TRUE) # 382 Mb
# y = sample(c(TRUE, FALSE, NA), n, TRUE)
# z = sample(c(TRUE, FALSE, NA), n, TRUE)
# 
# microbenchmark::microbenchmark(
#   kit=pany(x, y, z, na.rm = TRUE),
#   base=sapply(1:n, function(i) any(x[i],y[i],z[i],na.rm=TRUE)),
#   times = 5L
# )
# Unit: Second
# expr    min     lq   mean   median     uq    max neval
# kit    1.07   1.09   1.15     1.10   1.23   1.23     5
# base 111.31 112.02 112.78   112.97 113.55 114.03     5
</code></pre>

<hr>
<h2 id='psort'>Parallel Sort</h2><span id='topic+psort'></span>

<h3>Description</h3>

<p>Similar to <code>base::sort</code> but just for character vector and partially using parallelism.
It is currently experimental and might change in the future. Use with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  psort(x, decreasing=FALSE, na.last=NA,
        nThread=getOption("kit.nThread"),c.locale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psort_+3A_x">x</code></td>
<td>
<p> A vector of type character. If other, it will default to <code>base::sort</code></p>
</td></tr>
<tr><td><code id="psort_+3A_na.last">na.last</code></td>
<td>
<p> For controlling the treatment of <code>NA</code>s. If <code>TRUE</code>, missing values in the data are put last; if <code>FALSE</code>, they are put first; if <code>NA</code>, they are removed. </p>
</td></tr>
<tr><td><code id="psort_+3A_decreasing">decreasing</code></td>
<td>
<p> A boolean indicating where to sort the data in decreasing way. Default is <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="psort_+3A_nthread">nThread</code></td>
<td>
<p> Number of thread to use. Default value is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="psort_+3A_c.locale">c.locale</code></td>
<td>
<p> A boolean, whether to use C Locale or R session locale. Default TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>x</code> in sorted order similar to <code>base::sort</code> but usually faster. If <code>c.locale=FALSE</code>, <code>psort</code> will return the same output as <code>base::sort</code> with <code>method="quick"</code>, i.e. using R session locale. If <code>c.locale=TRUE</code>, <code>psort</code> will return the same output as <code>base::sort</code> with <code>method="radix"</code>, i.e. using C locale. See example below.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("b","A","B","a","\xe4")
Encoding(x) = "latin1"
identical(psort(x, c.locale=FALSE), sort(x))
identical(psort(x, c.locale=TRUE), sort(x, method="radix"))

# Benchmarks
# ----------
# strings = as.character(as.hexmode(1:1000))
# x = sample(strings, 1e8, replace=TRUE)
# system.time({kit::psort(x, na.last = TRUE, nThread = 1L)})
#   user  system elapsed 
#  2.833   0.434   3.277
# system.time({sort(x,method="radix",na.last = TRUE)})
#   user  system elapsed 
#  5.597   0.559   6.176
# system.time({x[order(x,method="radix",na.last = TRUE)]})
#   user  system elapsed 
#  5.561   0.563   6.143
</code></pre>

<hr>
<h2 id='setlevels'> Set levels of a factor object </h2><span id='topic+setlevels'></span>

<h3>Description</h3>

<p>A function to set levels of a factor object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setlevels(x, old=levels(x), new, skip_absent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setlevels_+3A_x">x</code></td>
<td>
<p> A factor object. </p>
</td></tr>
<tr><td><code id="setlevels_+3A_old">old</code></td>
<td>
<p> A character vector containing the factor levels to be changed. Default is levels of <code>x</code>. </p>
</td></tr>
<tr><td><code id="setlevels_+3A_new">new</code></td>
<td>
<p> The new character vector containing the factor levels to be added. </p>
</td></tr>
<tr><td><code id="setlevels_+3A_skip_absent">skip_absent</code></td>
<td>
<p> Skip items in <code>old</code> that are missing (i.e. absent) in 'names(x)'. Default <code>FALSE</code> halts with error if any are missing. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an invisible and modified factor object.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = factor(c("A", "A", "B", "B", "B", "C")) # factor vector with levels A B C
setlevels(x, new = c("X", "Y", "Z"))        # set factor levels to: X Y Z
setlevels(x, old = "X", new = "A")          # set factor levels X to A
</code></pre>

<hr>
<h2 id='shareData+2FgetData+2FclearData'> Share Data between R Sessions</h2><span id='topic+shareData'></span><span id='topic+getData'></span><span id='topic+clearData'></span>

<h3>Description</h3>

<p>Experimental functions that enable the user to share a R object between 2 <span class="rlang"><b>R</b></span> sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shareData(data, map_name, verbose=FALSE)
  getData(map_name, verbose=FALSE)
  clearData(x, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shareData+2B2FgetData+2B2FclearData_+3A_data">data</code></td>
<td>
<p> A <span class="rlang"><b>R</b></span> object like a vector or a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="shareData+2B2FgetData+2B2FclearData_+3A_map_name">map_name</code></td>
<td>
<p> A character. A name for the memory map location where to store the data.</p>
</td></tr>
<tr><td><code id="shareData+2B2FgetData+2B2FclearData_+3A_x">x</code></td>
<td>
<p> An external pointer like the one returned by function <code>shareData</code>.</p>
</td></tr>
<tr><td><code id="shareData+2B2FgetData+2B2FclearData_+3A_verbose">verbose</code></td>
<td>
<p> A logical value <code>TRUE</code> or <code>FALSE</code> to provide or not information to the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>shareData</code> returns a external pointer.
<code>getData</code> returns an <span class="rlang"><b>R</b></span> object stored in the memory location <code>map_name</code>.
<code>clearData</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether the data have been cleared in memory.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'># In R session 1: share data in memory
# &gt; x = shareData(mtcars,"share1")
#
# In R session 2: get data from session 1
# &gt; getData("share1")
#
# In R session 1: clear data in memory
# &gt; clearData(x)
</code></pre>

<hr>
<h2 id='topn'> Top N values index</h2><span id='topic+topn'></span>

<h3>Description</h3>

<p><code>topn</code> is used to get the indices of the few values of an input. This is an extension of <code><a href="base.html#topic+which.max">which.max</a></code>/<code><a href="base.html#topic+which.min">which.min</a></code> which provide <em>only</em> the first such index. 
</p>
<p>The output is the same as <code>order(vec)[1:n]</code>, but internally optimized not to sort the irrelevant elements of the input (and therefore much faster, for small <code>n</code> relative to input size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  topn(vec, n=6L, decreasing=TRUE, hasna=TRUE, index=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topn_+3A_vec">vec</code></td>
<td>
<p> A numeric vector of type numeric or integer. Other types are not supported yet. </p>
</td></tr>
<tr><td><code id="topn_+3A_n">n</code></td>
<td>
<p> A positive integer value greater or equal to 1. </p>
</td></tr>
<tr><td><code id="topn_+3A_decreasing">decreasing</code></td>
<td>
<p> A logical value (default <code>TRUE</code>) to indicate whether to sort <code>vec</code> in decreasing or increasing order. Equivalent to argument <code>decreasing</code> in function <code>base::order</code>. Please note that unlike <code>topn</code> default value in <code>base::order</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="topn_+3A_hasna">hasna</code></td>
<td>
<p> A logical value (default <code>TRUE</code>) to indicate whether <code>vec</code> contains <code>NA</code> values. </p>
</td></tr>
<tr><td><code id="topn_+3A_index">index</code></td>
<td>
<p> A logical value (default <code>TRUE</code>) to indicate whether indexes or values of <code>vec</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>integer</code> vector of indices of the most extreme (according to <code>decreasing</code>) <code>n</code> values in vector <code>vec</code>. Please note that for large value of <code>n</code>, i.e. 1500 or 2000 (depending on the value of <code>hasna</code>), <code>topn</code> will default to base R function <code>order</code>.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rnorm(1e4)

# Example 1: index of top 6 negative values 
topn(x, 6L, decreasing=FALSE)
order(x)[1:6]

# Example 2: index of top 6 positive values
topn(x, 6L, decreasing = TRUE)
order(x, decreasing=TRUE)[1:6]

# Example 3: top 6 negative values
topn(x, 6L, decreasing=FALSE, index=FALSE)
sort(x)[1:6]

# Benchmarks
# ----------
# x = rnorm(1e7) # 76Mb
# microbenchmark::microbenchmark(
#   topn=kit::topn(x, 6L),
#   order=order(x, decreasing=TRUE)[1:6],
#   times=10L
# )
# Unit: milliseconds
#  expr min   lq  mean median   uq  max neval
# topn   11   11    13     11   12   18    10
# order 563  565   587    566  602  661    10
#
# microbenchmark::microbenchmark(
#  topn=kit::topn(x, 6L, decreasing=FALSE, index=FALSE),
#  sort=sort(x, partial=1:6)[1:6],
#  times=10L
# )
# Unit: milliseconds
# expr min  lq  mean median   uq  max neval
# topn  11  11    11     11   12   12    10
# sort 167 175   197    178  205  303    10
</code></pre>

<hr>
<h2 id='vswitch+2Fnswitch'> Vectorised switch </h2><span id='topic+vswitch'></span><span id='topic+nswitch'></span>

<h3>Description</h3>

<p><code>vswitch</code>/ <code>nswitch</code> is a vectorised version of <code>base</code> function <code>switch</code>. This function can also be seen as a particular case of function <code>nif</code>, as shown in examples below, and should also be faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    vswitch(x, values, outputs, default=NULL,
            nThread=getOption("kit.nThread"),
            checkEnc=TRUE)
    nswitch(x, ..., default=NULL,
            nThread=getOption("kit.nThread"),
            checkEnc=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_x">x</code></td>
<td>
<p>A vector or list.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_values">values</code></td>
<td>
<p>A vector or list with values from <code>x</code> to match. Note that <code>x</code> and <code>values</code> must have the same class and attributes.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_outputs">outputs</code></td>
<td>
<p>A list or vector with the outputs to return for every matching values. Each item of the list must be of length 1 or length of <code>x</code>. Note that if all list items are of length 1 then it might be simpler to use a vector.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_...">...</code></td>
<td>
<p>A sequence of values and outputs in the following order <code>value1, output1, value2, output2, ..., valueN, outputN</code>. Values <code>value1, value2, ..., valueN</code> must all have length1, same type and attributes. Each <code>output</code> may either share length with <code>x</code> or be length 1. Please see Examples section for further details.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_default">default</code></td>
<td>
<p>Values to return is no match. Must be a vector or list of length 1 or same length as <code>x</code>. Also, <code>default</code> must have the same type, class and attributes as items from <code>outputs</code>.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_nthread">nThread</code></td>
<td>
<p> A integer for the number of threads to use with <em>openmp</em>. Default value is <code>getOption("kit.nThread")</code>.</p>
</td></tr>
<tr><td><code id="vswitch+2B2Fnswitch_+3A_checkenc">checkEnc</code></td>
<td>
<p> A logical value whether or not to check if <code>x</code> and <code>values</code> have comparable and consistent encoding. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list of the same length as <code>x</code> with values from <code>outputs</code> items and from <code>default</code> if missing.
</p>


<h3>Author(s)</h3>

<p>Morgan Jacob</p>


<h3>See Also</h3>

<p><code><a href="#topic+iif">iif</a></code>
<code><a href="#topic+nif">nif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = sample(c(10L, 20L, 30L, 40L, 50L, 60L), 3e2, replace=TRUE)

# The below example of 'vswitch' is
a1 = vswitch(
  x = x,
  values = c(10L,20L,30L,40L,50L),
  outputs = c(11L,21L,31L,41L,51L),
  default = NA_integer_
)

# equivalent to the following 'nif' example.
# However for large vectors 'vswitch' should be faster.
b1 = nif(
  x==10L, 11L,
  x==20L, 21L,
  x==30L, 31L,
  x==40L, 41L,
  x==50L, 51L,
  default = NA_integer_
)
identical(a1, b1)

# nswitch can also be used as follows:
c1 = nswitch(x,
  10L, 11L,
  20L, 21L,
  30L, 31L,
  40L, 41L,
  50L, 51L,
  default = NA_integer_
)
identical(a1, c1)

# Example with list in 'outputs' argument
y = c(1, 0, NA_real_)
a2 = vswitch(
  x = y,
  values = c(1, 0),
  outputs = list(c(2, 3, 4), c(5, 6, 7)),
  default = 8
)

b2 = nif(
  y==1, c(2, 3, 4),
  y==0, c(5, 6, 7),
  default = 8
)

identical(a2, b2)

c2 = nswitch(y,
  1, c(2, 3, 4),
  0, c(5, 6, 7),
  default = 8
)

identical(a2, c2)

# Benchmarks
# ----------
# x = sample(1:100, 3e8, TRUE) # 1.1Gb
# microbenchmark::microbenchmark(
# nif=kit::nif(
#   x==10L,  0L,
#   x==20L, 10L,
#   x==30L, 20L,
#   default= 30L
#  ),
# vswitch=kit::vswitch(
#   x, c( 10L, 20L, 30L), list(0L, 10L, 20L), 30L
# ),
# times=10L
# )
# Unit: seconds
#    expr   min    lq  mean median   uq  max neval
# nif      4.27  4.37  4.43   4.42 4.52 4.53    10
# vswitch  1.08  1.09  1.20   1.10 1.43 1.44    10 # 1 thread
# vswitch  0.46  0.57  0.57   0.58 0.58 0.60    10 # 2 threads
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
