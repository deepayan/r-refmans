<!DOCTYPE html><html><head><title>Help for package WoodSimulatR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WoodSimulatR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gdp_data'><p>Means and standard deviations of grade determining properties (GDPs) from literature</p></a></li>
<li><a href='#get_subsample_definitions'><p>Retrieve descriptive data for samples from literature</p></a></li>
<li><a href='#get_transform_names'><p>Return labels for given transforms</p></a></li>
<li><a href='#simbase'><p>Predefined simbases in WoodSimulatR</p></a></li>
<li><a href='#simbase_covar'><p>Calculate reference data for simulating values based on a covariance matrix approach</p></a></li>
<li><a href='#simbase_labeler'><p>Default labelling function for simbase objects</p></a></li>
<li><a href='#simbase_list'><p>Wrapper for the <code>simbase_*</code> functions for grouped data</p></a></li>
<li><a href='#simulate_conditionally'><p>Add simulated values to a dataset conditionally, based on a <code>simbase_*</code> object</p></a></li>
<li><a href='#simulate_conditionally.simbase_list'><p>Add simulated values to a dataset conditionally, based on a <code>simbase_list</code> object</p></a></li>
<li><a href='#simulate_dataset'><p>Generate an artificial dataset with correlated variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generate Simulated Sawn Timber Strength Grading Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for generating simulated sawn timber
    strength grading data with a main focus on statistical simulation based on
    covariance matrices. Simulation data
    for Norway spruce sawn timber from Austria and reference values of means and
    standard deviations of grade determining properties from literature
    for a number of European countries are provided, as well.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, dplyr, rlang (&ge; 0.4.6), purrr, tibble, tidyselect,
tidyr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, magrittr, pander, rmarkdown, scales,
testthat, utf8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 12:07:32 UTC; Weidenhiller</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Weidenhiller
    <a href="https://orcid.org/0000-0003-0938-2159"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Anton Wegscheider [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Weidenhiller &lt;a.weidenhiller@holzforschung.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gdp_data'>Means and standard deviations of grade determining properties (GDPs) from literature</h2><span id='topic+gdp_data'></span>

<h3>Description</h3>

<p>Means and standard deviations of grade determining properties (GDPs) from literature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdp_data
</code></pre>


<h3>Format</h3>


<dl>
<dt>species</dt><dd><p>Wood species as a four letter code according to EN 13556.
Currently, this is always &quot;PCAB&quot; for Norway spruce (<em>Picea abies</em>).</p>
</dd>
<dt>loadtype</dt><dd><p>Kind of destructive testing applied to the material &ndash;
&quot;t&quot; for material tested in tension, &quot;be&quot; for material tested in bending.</p>
</dd>
<dt>project</dt><dd><p>Research project from which the data originated; <code>"null"</code>
if unknown or not applicable.</p>
</dd>
<dt>country</dt><dd><p>Country from which the material originated, as a two letter
country code.</p>
</dd>
<dt>share</dt><dd><p>Number of pieces on which the values are based.</p>
</dd>
<dt>f_mean, f_sd</dt><dd><p>Mean and standard deviation of strength, in N/mm².</p>
</dd>
<dt>E_mean, E_sd</dt><dd><p>Mean and standard deviation of the static modulus of
elasticity, in N/mm².</p>
</dd>
<dt>rho_mean, rho_sd</dt><dd><p>Mean and standard deviation of density, in kg/m³.</p>
</dd>
<dt>literature</dt><dd><p>Reference to the literature source; <code>"null"</code> if not
published yet.</p>
</dd>
<dt>subsample</dt><dd><p>For distinguishing multiple rows with the same species,
loadtype and country &ndash; if there are no duplicates, it is the same as
<code>country</code>; if there are duplicates, it is <code>country</code> plus a
suffixed number separated by &quot;_&quot;.</p>
</dd>
</dl>



<h3>Details</h3>

<p>For simulation of an entire dataset with different subsamples with different
characteristics (see <code><a href="#topic+simulate_dataset">simulate_dataset</a></code>),
it may be useful to be able to refer to existing results
from literature as a basis.
</p>
<p>In the dataset <code>gdp_data</code>, means and standard deviations for a number of
such subsamples have been collected.
</p>
<p>The GDP values collected in <code>gdp_data</code> were selected from
publications which aimed at representative sampling within the respective
countries.
All the same, care must be taken when using these values,
due to the natural high variability of timber properties.
</p>


<h3>Source</h3>

<p>The values have been extracted from the following publications:
</p>
<p>Ranta-Maunus, Alpo, Julia K. Denzler, and Peter Stapel. 2011.
<em>Strength of European Timber. Part 2. Properties of Spruce and Pine
Tested in Gradewood Project.</em> VTT.
</p>
<p>Rohanová, Alena, and Erika Nunez. 2014. &quot;Prediction Models of Slovakian
Structural Timber.&quot; <em>Wood Research</em> 59 (5): 757–69.
</p>
<p>Stapel, Peter, and Jan-Willem G. van de Kuilen. 2014. “Efficiency of Visual
Strength Grading of Timber with Respect to Origin, Species, Cross Section,
and Grading Rules: A Critical Evaluation of the Common Standards.”
<em>Holzforschung</em> 68 (2): 203–16.
</p>

<hr>
<h2 id='get_subsample_definitions'>Retrieve descriptive data for samples from literature</h2><span id='topic+get_subsample_definitions'></span>

<h3>Description</h3>

<p>In the <code>WoodSimulatR</code> package, means and standard deviations of grade
determining properties (GDPs) for a number of Norway spruce
(<em>Picea abies</em>) samples from literature are stored for use in
<code><a href="#topic+simulate_dataset">simulate_dataset</a></code>. They are indexed by a two-letter country code
(and a suffixed number if disambiguation is required).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subsample_definitions(country = NULL, loadtype = "t", species = "PCAB")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subsample_definitions_+3A_country">country</code></td>
<td>
<p>Can be either the number of desired samples, or a
named vector of relative subsample sizes where the names can be
abbreviations of country names. Alternatively, <code>country</code> can also
be a character vector of country abbreviations.</p>
</td></tr>
<tr><td><code id="get_subsample_definitions_+3A_loadtype">loadtype</code></td>
<td>
<p>Can be either <code>"be"</code> for &quot;bending edgewise&quot; or
<code>"t"</code> for &quot;tension&quot;.</p>
</td></tr>
<tr><td><code id="get_subsample_definitions_+3A_species">species</code></td>
<td>
<p>A species code according to EN 13556:2003. Currently, only
'PCAB' (<em>Picea abies</em> = Norway spruce) is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The direct descriptive data can also be directly accessed
(<code><a href="#topic+gdp_data">gdp_data</a></code>).
The present function is meant to prepare the data
as input to the <code>subsets</code> argument of <code><a href="#topic+simulate_dataset">simulate_dataset</a></code>.
It allows picking multiple samples from the same country (disambiguating by
creating appropriately named entries in the column <code>subsample</code>) and
creating random sample data (uniformly distributed within the
range of values given in the full dataset <code><a href="#topic+gdp_data">gdp_data</a></code>
for the respective <code>loadtype</code> and <code>species</code>) for sample names not
found in this dataset.
</p>
<p>The dataset <code><a href="#topic+gdp_data">gdp_data</a></code> contains a column <code>share</code> which gives
the number of pieces in the original sample. Unless relative subsample sizes
are explicitly asked for by providing a named numeric vector for the
argument <code>country</code>, the present function always resets <code>share</code> to
1, prompting <code><a href="#topic+simulate_dataset">simulate_dataset</a></code> to create
(approximately) equal-sized subsamples.
</p>
<p>The GDPs depend on the type of destructive testing done
(<code>loadtype</code>) &ndash; therefore, giving the proper <code>loadtype</code> is
required for realistic values.
</p>
<p>If <code>country</code> is <code>NULL</code> (or omitted), the full dataset
<code><a href="#topic+gdp_data">gdp_data</a></code> for the
respective <code>loadtype</code> (and <code>species</code>) is returned.
</p>
<p>For sample names not contained in the internal list, a warning is issued
and random sample data is returned (uniformly distributed within the
range of values given in the full table for the respective <code>loadtype</code>
and <code>species</code>).
</p>
<p>If <code>country</code> is just a number (and <em>not</em> a named vector), also random
sample data is returned; the different &quot;countries&quot; are then named &quot;C1&quot;, &quot;C2&quot;
and so on.
</p>


<h3>Value</h3>

<p>A data frame with country and subsample names,
relative subsample sizes and some meta-information like project and
literature references, as well as mean
strength and standard deviation of strength, static modulus of elasticity and
density.
</p>


<h3>Notes</h3>

<p>The GDP values collected in <code><a href="#topic+gdp_data">gdp_data</a></code> were selected from
publications which aimed at representative sampling within the respective
countries.
All the same, care must be taken when using these values,
due to the natural high variability of timber properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get all subsample data for loadtype bending, or tension
get_subsample_definitions()
get_subsample_definitions(loadtype='be')

# get six random samples, explicitly state loadtype tension
get_subsample_definitions(country=6, loadtype='t')

# get subsample data for the German tension sample in different ways
get_subsample_definitions(country='de', loadtype='t')
get_subsample_definitions(country=c(de=1), loadtype='t')
get_subsample_definitions(country=c(de=6), loadtype='t')

# bending samples from Sweden (both samples), Poland, and France, equally
# weighted
get_subsample_definitions(c('se', 'se_1', 'pl', 'fr'))
get_subsample_definitions(c(se=1, se_1=1, pl=1, fr=1))
get_subsample_definitions(c(se=5, se_1=5, pl=5, fr=5))

# four tension samples from Romania, two from Ukraine and one from Slovakia,
# weighted so that each country contributes equally
get_subsample_definitions(c(ro=1, ro=1, ro=1, ro=1, ua=2, ua=2, sk=4), loadtype='t')

# non-existant subsample names get replaced by random values (which are based
# on the range of stored values for the respective loadtype)
get_subsample_definitions(c('xx', 'yy', 'zz'))
get_subsample_definitions(c('xx', 'yy', 'zz'), loadtype='t')

# subsample names are case-sensitive!
get_subsample_definitions(c('at', 'aT', 'At', 'AT'), loadtype='t')

</code></pre>

<hr>
<h2 id='get_transform_names'>Return labels for given transforms</h2><span id='topic+get_transform_names'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+simbase_covar">simbase_covar</a></code> allows the specification of a
transform for one or more variables. The present function creates short
names for such transforms for use in labelling (by default, the labelling is
done by <code><a href="#topic+simbase_labeler">simbase_labeler</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transform_names(
  transforms,
  prefer_primitive = c("if_shorter", "never", "always")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_transform_names_+3A_transforms">transforms</code></td>
<td>
<p>A named list of objects of class <code>trans</code>
or class <code>transform</code>
(see function <code>trans_new</code> in package <code>scales</code>)</p>
</td></tr>
<tr><td><code id="get_transform_names_+3A_prefer_primitive">prefer_primitive</code></td>
<td>
<p>If &quot;never&quot;, the function always returns the value of
the field <code>name</code> (except if this is missing).
If &quot;always&quot;, the name of the called function is returned unless it cannot be
identified (in many cases, the transform will not be primitive).
If &quot;if_shorter&quot;, the shorter option of the two above is returned if both can
be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The label of a transform could be the value of the field <code>name</code> from
each object of class <code>trans</code> (or <code>transform</code>),
but also the name of the transform
function itself, if it is a primitive function or just calls one function.
</p>
<p>Each object of class <code>trans</code> (or <code>transform</code>)
should have a field <code>name</code>
which can be returned by the present function.
</p>
<p>The function examines the field <code>transform</code>.
If this field contains a primitive function (see <code><a href="rlang.html#topic+is_primitive">is_primitive</a></code>),
or if there is just one function call in the body of this <code>transform</code>
function, we can also return the name of this called function.
</p>
<p>If there is no field <code>name</code> and no single function is called from the
function defined in the field <code>transform</code>,
a generic function name <code>"f."</code> is returned.
</p>


<h3>Value</h3>

<p>A named vector of transforms names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_transform_names(list(a = scales::log_trans(), b = scales::boxcox_trans(0)));
get_transform_names(list(x = list(name = 'a very long name', transform = log, inverse = exp)))
</code></pre>

<hr>
<h2 id='simbase'>Predefined simbases in WoodSimulatR</h2><span id='topic+simbase'></span><span id='topic+ws_t'></span><span id='topic+ws_t_tr'></span><span id='topic+ws_t_te'></span><span id='topic+ws_t_logf'></span><span id='topic+ws_t_tr_logf'></span><span id='topic+ws_t_te_logf'></span><span id='topic+ws_be'></span><span id='topic+ws_be_tr'></span><span id='topic+ws_be_te'></span><span id='topic+ws_be_logf'></span><span id='topic+ws_be_tr_logf'></span><span id='topic+ws_be_te_logf'></span>

<h3>Description</h3>

<p>Predefined simbases in WoodSimulatR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ws_t
 ws_t_tr
 ws_t_te
 ws_t_logf
 ws_t_tr_logf
 ws_t_te_logf
 ws_be
 ws_be_tr
 ws_be_te
 ws_be_logf
 ws_be_tr_logf
 ws_be_te_logf
</code></pre>


<h3>Format</h3>

<p>For statistical simulation of datasets in <code>WoodSimulatR</code>, one
needs a <code><a href="#topic+simbase_covar">simbase_covar</a></code> object. <code>WoodSimulatR</code> contains a
set of such predefined simbases for Norway spruce (<em>Picea abies</em>) grown
in Austria.
</p>
<p>The names of the simbases follow the following schema &ndash; the different parts
are separated by &quot;_&quot;:
</p>

<ul>
<li><p> &quot;ws&quot; &ndash; abbreviation of &quot;<strong>W</strong>oodSimulatR <strong>s</strong>imbase&quot;
</p>
</li>
<li><p> loadtype &ndash; can either be &quot;t&quot; for material tested in tension,
or &quot;be&quot; for material tested in bending
</p>
</li>
<li><p> subsample &ndash; empty for the full dataset, &quot;tr&quot; for the part of the
dataset that was used for training, &quot;te&quot; for the part that was used for
testing. The latter two can be used to more closely simulate independent
training and test samples
</p>
</li>
<li><p> transformation &ndash; empty for no transformation, &quot;logf&quot; if the strength
has been log-transformed prior to calculation of the simbase &ndash; see also
the argument <code>transforms</code> in <code><a href="#topic+simbase_covar">simbase_covar</a></code>.
</p>
</li></ul>

<p>The simbases contain the basis for simulating the following variables:
</p>

<dl>
<dt>f</dt><dd><p>Bending or tension strength, in N/mm².</p>
</dd>
<dt>E</dt><dd><p>Static modulus of elasticity in bending or tension, in N/mm².</p>
</dd>
<dt>rho</dt><dd><p>Density of a small clear sample, in kg/m³.</p>
</dd>
<dt>E_dyn</dt><dd><p>Dynamic modulus of elasticity of the timber after drying to a
moisture content of about 12%, in N/mm².</p>
</dd>
<dt>E_dyn_u</dt><dd><p>Dynamic modulus of elasticity of the timber in the green
state, with moisture contents mostly above fibre saturation point,
in N/mm².</p>
</dd>
<dt>ip_rho</dt><dd><p>An &quot;indicating property&quot; (IP) for density, established by
measuring the weight of each board and dividing by its volume, in kg/m³.</p>
</dd>
<dt>ip_f</dt><dd><p>An &quot;indicating property&quot; (IP) for strength, established by
linear regression on <code>E_dyn</code>, <code>ip_rho</code> and a knot parameter
called &quot;total knot area ratio&quot; (tKAR), in N/mm².</p>
</dd>
</dl>



<h3>Source</h3>

<p>The simbases were created based on data from the research project
SiOSiP of Holzforschung Austria. &quot;SiOSiP&quot; is short for &quot;simulation-based
optimization of sawn timber production&quot; and ran from 2014 to 2017.
</p>

<hr>
<h2 id='simbase_covar'>Calculate reference data for simulating values based on a covariance matrix approach</h2><span id='topic+simbase_covar'></span>

<h3>Description</h3>

<p>Given the covariance matrix and the means of a set of variables, we can
simulate not only the distribution of the variables, but also their
correlations. The present function calculates the basic values required for
the simulation and returns them packed into an object of class
<code>simbase_covar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simbase_covar(
  data,
  variables = NULL,
  transforms = list(),
  label = simbase_labeler,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simbase_covar_+3A_data">data</code></td>
<td>
<p>The dataset for the calculation of the reference data for
simulation; for grouped datasets (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>),
the reference data is
calculated for each group separately (see also <code><a href="#topic+simbase_list">simbase_list</a></code>).</p>
</td></tr>
<tr><td><code id="simbase_covar_+3A_variables">variables</code></td>
<td>
<p>Character vector containing the names in <code>data</code>
which should be included in the simulation. If missing, all numeric
variables in <code>data</code> are used.</p>
</td></tr>
<tr><td><code id="simbase_covar_+3A_transforms">transforms</code></td>
<td>
<p>A named list of objects of class <code>trans</code>
or class <code>transform</code>
(see function <code>trans_new</code> in package <code>scales</code>);
the name of each list entry
<b>must</b> correspond to a variable name in <code>variables</code>.</p>
</td></tr>
<tr><td><code id="simbase_covar_+3A_label">label</code></td>
<td>
<p>Either a string describing the data and the simulation approach,
or a labelling function which returns a label string and takes as input
the data, a string giving the class
of the simbase object (here <code>"simbase_covar"</code>) and the
transforms list.</p>
</td></tr>
<tr><td><code id="simbase_covar_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code><a href="#topic+simbase_list">simbase_list</a></code>
(<em>if</em> it is called).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some of the variables are non-normally distributed, a transform may
improve the prediction. The transforms are passed to the function as a named
list, where the name of a list entry must correspond to the name of the
variable in the data which is to be transformed.
</p>
<p>Predefined transforms can be found in the package <code>scales</code>, where they are
used for axis transformations as a preparation for plotting. The package
<code>scales</code> also contains a function <code>trans_new</code> which can be used
to define new transforms.
</p>
<p>In the context of destructively measured sawn timber properties, the type of
destructive test applied is of interest. If the dataset <code>data</code> contains a
variable <code>loadtype</code> which consistently throughout the dataset has either the
value &quot;t&quot; (i.e. all sawn timber has been tested in tension) or the
value &quot;be&quot; (i.e. all sawn timber has been tested in bending, edgewise),
then the returned object also has a field <code>loadtype</code> with that value.
</p>
<p>One can also calculate a simbase under the assumption that the correlations
are different for different subgroups of the data. This is done by grouping
the dataset <code>data</code> prior to passing it to the function,
using <code><a href="dplyr.html#topic+group_by">group_by</a></code>. In this case, several objects of
class <code>simbase_covar</code> are created and joined together in a <code><a href="dplyr.html#topic+tibble">tibble</a></code> &ndash;
see also <code><a href="#topic+simbase_list">simbase_list</a></code>.
</p>


<h3>Value</h3>

<p>An <code>S3</code> object of class <code>simbase_list</code> if <code>data</code> is grouped,
and an object of class <code>simbase_covar</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain a dataset for demonstration
dataset &lt;- simulate_dataset();

# calculate a simbase without transforms
simbase_covar(dataset, c('f', 'E', 'rho', 'E_dyn'));

# calculate a simbase with log-transformed f
simbase_covar(dataset, c('f', 'E', 'rho', 'E_dyn'), list(f = scales::log_trans()));

# if we group the dataset, we get a simbase_list object
simbase_covar(dplyr::group_by(dataset, country), c('f', 'E', 'rho', 'E_dyn'));

</code></pre>

<hr>
<h2 id='simbase_labeler'>Default labelling function for simbase objects</h2><span id='topic+simbase_labeler'></span>

<h3>Description</h3>

<p>Each simbase object should have a label which can be used for differentiating
different simulations. This function tries to simplify the label generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simbase_labeler(data, simbase_class, transforms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simbase_labeler_+3A_data">data</code></td>
<td>
<p>The dataset for the calculation of the basic simulation data.</p>
</td></tr>
<tr><td><code id="simbase_labeler_+3A_simbase_class">simbase_class</code></td>
<td>
<p>The class of the simbase object for which the label is
to be generated. Currently, only <code>"simbase_covar"</code> is supported.</p>
</td></tr>
<tr><td><code id="simbase_labeler_+3A_transforms">transforms</code></td>
<td>
<p>The transforms applied to variables in the dataset.
Must be objects of class <code>trans</code> or class <code>transform</code>
(see function <code>trans_new</code> in package <code>scales</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Primarily, this function is intended to be called as a default from
<code><a href="#topic+simbase_covar">simbase_covar</a></code>. It can also serve as a template for creating
custom labelling functions.
</p>


<h3>Value</h3>

<p>A string for labelling a simbase object.
</p>

<hr>
<h2 id='simbase_list'>Wrapper for the <code>simbase_*</code> functions for grouped data</h2><span id='topic+simbase_list'></span>

<h3>Description</h3>

<p>If a function of the <code>simbase_*</code> family encounters grouped <code>data</code>
(as caused by <code><a href="dplyr.html#topic+group_by">group_by</a></code>), it should invoke <code>simbase_list</code>
to create a collection of separate simbases for each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simbase_list(data, simbase_constructor, ..., suffix = "_lst")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simbase_list_+3A_data">data</code></td>
<td>
<p>A grouped dataset (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>)</p>
</td></tr>
<tr><td><code id="simbase_list_+3A_simbase_constructor">simbase_constructor</code></td>
<td>
<p>A function which returns a <code>simbase_*</code>
object, like <code><a href="#topic+simbase_covar">simbase_covar</a></code></p>
</td></tr>
<tr><td><code id="simbase_list_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>simbase_*</code> function.</p>
</td></tr>
<tr><td><code id="simbase_list_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to be added to the individual simbase labels if they are
all the same (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>simbase_list</code> object; this is essentially a
<code><a href="dplyr.html#topic+tibble">tibble</a></code> with the grouping columns of <code>data</code> and a column
<code>.simbase</code> which contains the <code>simbase_*</code> objects.
</p>


<h3>Technical details</h3>

<p>Currently, the &quot;<code>simbase_*</code> family&quot; only consists of
<code><a href="#topic+simbase_covar">simbase_covar</a></code> (although, in a broader sense,
<code>simbase_list</code> can also be thought to be part of this &quot;family&quot;).
It is planned to add further simulation types in a later release.
</p>
<p>The functions of the <code>simbase_*</code> family support label
generation (see e.g. <code><a href="#topic+simbase_covar">simbase_covar</a></code>). These functions should
generate the label <em>before</em> invoking <code>simbase_list</code>, so that there
is a common label for all of the simbases; <code>simbase_list</code> adds a suffix
<code>suffix</code>. A warning is issued if the labels of the different simbases
are not all equal; no suffix is added in this case.
</p>

<hr>
<h2 id='simulate_conditionally'>Add simulated values to a dataset conditionally, based on a <code>simbase_*</code> object</h2><span id='topic+simulate_conditionally'></span>

<h3>Description</h3>

<p>Add simulated values to a dataset conditionally, based on a <code>simbase_*</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_conditionally(data, simbase, force_positive = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_conditionally_+3A_data">data</code></td>
<td>
<p>The dataset where simulated values are added to.
The dataset has to contain at least one variable which is also included in
the <code>simbase_*</code> object.</p>
</td></tr>
<tr><td><code id="simulate_conditionally_+3A_simbase">simbase</code></td>
<td>
<p>Basic data object for the simulation, as calculated e.g.
by <code><a href="#topic+simbase_covar">simbase_covar</a></code> or <code><a href="#topic+simbase_list">simbase_list</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_conditionally_+3A_force_positive">force_positive</code></td>
<td>
<p>If <code>TRUE</code>, the resulting values are forced
to be <code class="reqn">\ge 0</code>.</p>
</td></tr>
<tr><td><code id="simulate_conditionally_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>simbase_*</code> object, this function adds simulated values to a
dataset, conditional on the values of some of the variables already
contained in the dataset.
</p>


<h3>Value</h3>

<p>The modified dataset <code>data</code> with simulated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add simulated tension data based on a simbase stored in WoodSimulatR
dataset &lt;- data.frame(E_dyn = rnorm(n = 100, mean = 12500, sd = 2200));
dataset_t &lt;- simulate_conditionally(dataset, ws_t)

# add simulated bending data
dataset_be &lt;- simulate_conditionally(dataset, ws_be)

</code></pre>

<hr>
<h2 id='simulate_conditionally.simbase_list'>Add simulated values to a dataset conditionally, based on a <code>simbase_list</code> object</h2><span id='topic+simulate_conditionally.simbase_list'></span>

<h3>Description</h3>

<p>Add simulated values to a dataset conditionally, based on a <code>simbase_list</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simbase_list'
simulate_conditionally(
  data,
  simbase,
  force_positive = TRUE,
  ...,
  error_when_groups_missing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_conditionally.simbase_list_+3A_data">data</code></td>
<td>
<p>The dataset where simulated values are added to.</p>
</td></tr>
<tr><td><code id="simulate_conditionally.simbase_list_+3A_simbase">simbase</code></td>
<td>
<p>Basic data object for the simulation, as calculated by
<code><a href="#topic+simbase_list">simbase_list</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_conditionally.simbase_list_+3A_force_positive">force_positive</code></td>
<td>
<p>If <code>TRUE</code>, the resulting values are forced
to be <code class="reqn">\ge 0</code>.</p>
</td></tr>
<tr><td><code id="simulate_conditionally.simbase_list_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="simulate_conditionally.simbase_list_+3A_error_when_groups_missing">error_when_groups_missing</code></td>
<td>
<p>Whether to raise an error if for a certain
value combination in the grouping variables no dedicated <code>simbase</code>
exists (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulating values based on a <code><a href="#topic+simbase_list">simbase_list</a></code> object
has some special aspects compared to that of other <code>simbase_*</code> objects,
(see <code><a href="#topic+simulate_conditionally">simulate_conditionally</a></code>).
</p>
<p>In particular, a <code><a href="#topic+simbase_list">simbase_list</a></code> object stores <code>simbase</code>s
for specific value combinations within the grouping variables.
</p>
<p>These grouping variables must also be present in <code>data</code>.
</p>
<p>If there is a value combination in these grouping variables for which no
dedicated <code>simbase</code> object exists, this will lead to <code>NA</code> values
in the columns to be simulated and either to an error
(if <code>error_when_groups_missing = TRUE</code>) or to a warning.
</p>
<p>Due to the internal call to <code><a href="tidyr.html#topic+nest">nest</a></code> and subsequent call to
<code><a href="tidyr.html#topic+unnest">unnest</a></code>, the returned dataset will be ordered according to
the grouping variables in the simbase, with any grouping variable
combinations missing in the simbase coming last.
</p>


<h3>Value</h3>

<p>The modified dataset <code>data</code> with simulated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a simbase_list object for the values of subsets = c('AT', 'DE')
dataset_0 &lt;- simulate_dataset(subsets = c('AT', 'DE'));
simbase &lt;- simbase_covar(dplyr::group_by(dataset_0, country), c('f', 'E', 'E_dyn'));

# simulate on another dataset
dataset &lt;- data.frame(E_dyn = rnorm(n = 100, mean = 12500, sd = 2200), country = 'AT');
dataset_1 &lt;- simulate_conditionally(dataset, simbase);
head(dataset_1);

# warning if for some value of country we don't have an entry in the simbase
dataset$country &lt;- 'CH';
dataset_2 &lt;- simulate_conditionally(dataset, simbase, error_when_groups_missing = FALSE);
head(dataset_2);

</code></pre>

<hr>
<h2 id='simulate_dataset'>Generate an artificial dataset with correlated variables</h2><span id='topic+simulate_dataset'></span>

<h3>Description</h3>

<p>Generate an artificial dataset with correlated variables and defined means
and standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dataset(
  n = 5000,
  subsets = 4,
  random_seed = NULL,
  simbase = WoodSimulatR::ws_t_logf,
  loadtype = NULL,
  ...,
  RNGversion = "3.6.0"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_dataset_+3A_n">n</code></td>
<td>
<p>Number of rows in the dataset</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_subsets">subsets</code></td>
<td>
<p>Either <code>NULL</code>,
or a <code>data.frame</code> describing the subsets (see
details) or a character vector or named numeric vector suitable for
argument <code>country</code> in <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_random_seed">random_seed</code></td>
<td>
<p>Allows to set an integer seed value for the random number
generator to achieve reproducible results
(see also <code><a href="base.html#topic+set.seed">set.seed</a></code>).</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_simbase">simbase</code></td>
<td>
<p>An object of class <code><a href="#topic+simbase_covar">simbase_covar</a></code> or
<code><a href="#topic+simbase_list">simbase_list</a></code>. In particular, one of the simbases stored in
<code>WoodSimulatR</code> may be used &ndash; see <code><a href="#topic+simbase">simbase</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_loadtype">loadtype</code></td>
<td>
<p>For passing on to <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>.
A string with either &quot;t&quot; (for material tested in tension) or &quot;be&quot; (for
material tested in edgewise bending). Is only used if the simbase doesn't
contain a field <code>loadtype</code> or if the loadtype is ambiguous or not
equal to &quot;t&quot; or &quot;be&quot;.</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_dataset_+3A_rngversion">RNGversion</code></td>
<td>
<p>In <code>WoodSimulatR 0.5</code>, the <code>RNGversion</code> had been
fixed to <code>RNGversion = "3.5.0"</code>, but this setting now causes a warning
because the random number generator was changed in R version 3.6.0
(see <code><a href="base.html#topic+RNGversion">RNGversion</a></code>).
For perfect reproducibility of results from <code>WoodSimulatR 0.5</code>,
one should set <code>RNGversion = "3.5.0"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the package WoodSimulatR, a number of predefined base values for simulation
are stored &ndash; see <code><a href="#topic+simbase">simbase</a></code>.
</p>
<p>Using a character vector for the argument <code>subsets</code> leads to subsets
as equal in size as possible.
</p>
<p>The argument <code>subsets</code> enables differing means and standard deviations
for different subsamples. There are several possible usages:
</p>

<ul>
<li><p> If <code>subsets = NULL</code>, the information about means and standard
deviations is taken from the <code>simbase</code>. There can still be different
means and standard deviations if <code>simbase</code> is an object of class
<code><a href="#topic+simbase_list">simbase_list</a></code>.
</p>
</li>
<li><p> If a numeric vector or a character vector, it is used as argument
<code>country</code> in an internal call to <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>.
</p>
</li>
<li><p> If a dataset, there are the following requirements:
</p>

<ul>
<li> <p><em>identifier columns</em>: The dataset has to have one or more
discrete-valued <em>identifier columns</em> (usually character vectors or
factors) which uniquely identify each row.
These <em>identifier columns</em> are named <code>"country"</code> and
<code>"subsample"</code> in the standard case as yielded by
<code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>.
In the general case, the identifier columns are detected as those
columns which are not named <code>share, species, loadtype</code> or
<code>literature</code> and which do not end in <code>_mean</code> or <code>_sd</code>.
If the argument <code>simbase</code> is of class <code><a href="#topic+simbase_list">simbase_list</a></code>,
further restrictions apply (see below).
</p>
</li>
<li> <p><em>means and standard deviations</em>: For at least one of the
variables defined in the <code>simbase</code>, also the mean <em>and</em> the
standard deviation need to be given in each row; the column names for
this data must be the name of the respective variable(s)
from the <code>simbase</code>, suffixed by <code>_mean</code> and <code>_sd</code>,
respectively.
</p>
</li>
<li> <p><em>optional</em>: A column <code>share</code> can be used to create
subsamples of different sizes proportional to the values in
<code>share</code>.
</p>
</li></ul>

</li></ul>

<p>The argument <code>simbase</code> can be either an object of class
<code><a href="#topic+simbase_covar">simbase_covar</a></code> or of class <code><a href="#topic+simbase_list">simbase_list</a></code>.
</p>

<ul>
<li><p> various predefined <code><a href="#topic+simbase_covar">simbase_covar</a></code> objects are available
in <code>WoodSimulatR</code> &ndash; see <code><a href="#topic+simbase">simbase</a></code>.
</p>
</li>
<li><p> for objects of class <code><a href="#topic+simbase_list">simbase_list</a></code>, additional
restrictions apply:
</p>

<ol>
<li><p> the object may only have grouping variable(s) which are also
<em>identifier columns</em> according to the <code>subsets</code> definition
above &ndash; if the <code>subsets</code> argument is <em>not</em> a data frame,
the <em>identifier columns</em> are &quot;country&quot; and &quot;subsample&quot;.
</p>
</li>
<li><p> The value combinations in the <em>identifier columns</em> have to
match those which the <code>subsets</code> argument leads to
(see also <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>).
</p>
</li></ol>

</li></ul>

<p>Both the means and standard deviations in the subsample definitions
(see <code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>) as well as the values in the
<code>simbase</code> depend on the way the destructive testing of the sawn timber was
done. If the <code>simbase</code> has a field <code>loadtype</code>
(see also <code><a href="#topic+simbase_covar">simbase_covar</a></code>), this value is used in the call to
<code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code>. Otherwise, the <code>loadtype</code> has to be
passed directly to the present function unless no call to
<code><a href="#topic+get_subsample_definitions">get_subsample_definitions</a></code> is necessary (this depends on the
value of <code>subsets</code> &ndash; see above). If a loadtype has been defined, a variable
<code>loadtype</code> is also created in the resulting dataset for reference.
</p>
<p>Negative values in any numeric column of the result dataset are forced to
zero.
</p>
<p>If <code>random_seed</code> is not <code>NULL</code>, reproducibility of results
is enforced by using <code><a href="base.html#topic+set.seed">set.seed</a></code> with arguments
<code>kind='Mersenne-Twister'</code> and <code>normal.kind='Inversion'</code>,
and by calling <code><a href="base.html#topic+RNGversion">RNGversion</a></code> with argument <code>RNGversion</code>.
</p>
<p>If <code>random_seed</code> is not <code>NULL</code>, the random number generator
is reset at the end of the function using <code>set.seed(NULL)</code> and
<code>RNGversion(toString(getRversion()))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_dataset(n = 10, subsets = 1, random_seed = 1)

# As the loadtype is defined in the simbase, the argument loadtype is ignored
# with a warning
simulate_dataset(n = 10, subsets = 1, random_seed = 1, loadtype = 'be')

# Two subsamples
simulate_dataset(n = 10, subsets = 2, random_seed = 1)

# Two subsamples from pre-defined countries
simulate_dataset(n = 10, subsets = c('at', 'de'), random_seed = 1)

# Two subsamples from pre-defined countries with different sample sizes
simulate_dataset(n = 10, subsets = c(at = 3, de = 2), random_seed = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
