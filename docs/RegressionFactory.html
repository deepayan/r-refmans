<!DOCTYPE html><html lang="en"><head><title>Help for package RegressionFactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RegressionFactory}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fbase1.binomial.logit'>
<p>Single-Parameter Base Log-likelihood Function(s) for Binomial GLM</p></a></li>
<li><a href='#fbase1.exponential.log'>
<p>Single-Parameter Base Log-likelihood Function for Exponential GLM</p></a></li>
<li><a href='#fbase1.geometric.logit'>
<p>Single-Parameter Base Log-likelihood Function for Exponential GLM</p></a></li>
<li><a href='#fbase1.poisson.log'>
<p>Single-Parameter Base Log-likelihood Function for Poisson GLM</p></a></li>
<li><a href='#fbase2.gamma.log.log'>
<p>Double-Parameter Base Log-likelihood Function for Gamma GLM</p></a></li>
<li><a href='#fbase2.gaussian.identity.log'>
<p>Double-Parameter Base Log-likelihood Function for Gaussian GLM</p></a></li>
<li><a href='#fbase2.inverse.gaussian.log.log'>
<p>Double-Parameter Base Log-likelihood Function for Inverse-Gaussian GLM</p></a></li>
<li><a href='#regfac.expand.1par'>
<p>Expander Function for Single-Parameter Base Distributions</p></a></li>
<li><a href='#regfac.expand.2par'>
<p>Expander Function for Two-Parameter Base Distributions</p></a></li>
<li><a href='#regfac.merge'>
<p>Utility Function for Adding Two Functions and Their Derivatives</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Expander Functions for Generating Full Gradient and Hessian from
Single-Slot and Multi-Slot Base Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Alireza S. Mahani, Mansour T.A. Sharabiani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alireza S. Mahani &lt;alireza.s.mahani@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The expander functions rely on the mathematics developed for the Hessian-definiteness invariance theorem for linear projection transformations of variables, described in authors' paper, to generate the full, high-dimensional gradient and Hessian from the lower-dimensional derivative objects. This greatly relieves the computational burden of generating the regression-function derivatives, which in turn can be fed into any optimization routine that utilizes such derivatives. The theorem guarantees that Hessian definiteness is preserved, meaning that reasoning about this property can be performed in the low-dimensional space of the base distribution. This is often a much easier task than its equivalent in the full, high-dimensional space. Definiteness of Hessian can be useful in selecting optimization/sampling algorithms such as Newton-Raphson optimization or its sampling equivalent, the Stochastic Newton Sampler. Finally, in addition to being a computational tool, the regression expansion framework is of conceptual value by offering new opportunities to generate novel regression problems.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sns, MfUSampler</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-26 06:20:03 UTC; ec2-user</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-26 06:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='fbase1.binomial.logit'>
Single-Parameter Base Log-likelihood Function(s) for Binomial GLM
</h2><span id='topic+fbase1.binomial.logit'></span><span id='topic+fbase1.binomial.probit'></span><span id='topic+fbase1.binomial.cauchit'></span><span id='topic+fbase1.binomial.cloglog'></span>

<h3>Description</h3>

<p>Vectorized, single-parameter base log-likelihood functions for binomial GLM using various link functions. These base functions can be supplied to the expander function <code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase1.binomial.logit(u, y, fgh=2, n=1)
fbase1.binomial.probit(u, y, fgh=2, n=1)
fbase1.binomial.cauchit(u, y, fgh=2, n=1)
fbase1.binomial.cloglog(u, y, fgh=2, n=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase1.binomial.logit_+3A_u">u</code></td>
<td>
<p>Varying parameter of the base log-likelihood function. This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase1.binomial.logit_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model. For <code>binomial</code> family, it must be an integer vector with values between <code>0</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="fbase1.binomial.logit_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
<tr><td><code id="fbase1.binomial.logit_+3A_n">n</code></td>
<td>
<p>Number of trials in the binomial model. This parameter is assumed to be fixed, and must be supplied by the user. If <code>n==1</code>, the model is reduced to binary logit/probit/cauchit/cloglog regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the <code>logit</code> version returns <code>-(n*log(1+exp(-u))+(n-y)*u)</code>, the <code>probit</code> returns <code>y*log(pnorm(u))+(n-y)*log(1-pnorm(u))</code>, the <code>cauchit</code> returns <code>y*log(pcauchy(u))+(n-y)*log(1-pcauchy(u))</code>, and the <code>cloglog</code> returns <code>y*log(1-exp(-exp(u)))-(n-y)*exp(u)</code>                                                                                                                                                                                                                                                                                             . If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where the latter is a vector of length <code>length(u)</code>, with each element being the first derivative of the above expressions. If <code>fgh==2</code>, the list will include an element named <code>h</code>, consisting of the second derivatives of <code>f</code> with respect to <code>u</code>.
</p>


<h3>Note</h3>

<p>In all base log-likelihood functions, we have dropped any additive terms that are independent of the distribution parameter, e.g. constant terms or those terms that are dependent on the response variable only. This is done for computational efficiency. Therefore, these functions cannot be used to obtain the absolute values of log-likelihood functions but only in the context of optimization and/or sampling. Users can write thin wrappers around these functions to add the constant terms to the function value. (Derivatives do not need correction. For binomial family, all factorial terms are ignored since they only depend on <code>n</code> and y.)
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
library(MfUSampler)

# using the expander framework and binomial base log-likelihood
# to define log-likelihood function for binary logit regression
loglike.logit &lt;- function(beta, X, y, fgh) {
  regfac.expand.1par(beta, X, y, fbase1.binomial.logit, fgh, n=1)
}

# generate data for logistic regression
N &lt;- 1000
K &lt;- 5
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
y &lt;- 1*(runif(N) &lt; 1.0/(1+exp(-X%*%beta)))

# obtaining glm coefficients for comparison
beta.glm &lt;- glm(y~X-1, family="binomial")$coefficients

# mcmc sampling of log-likelihood
nsmp &lt;- 100

# Slice Sampler (no derivatives needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp
    , f=function(beta, X, y) loglike.logit(beta, X, y, fgh=0), X=X, y=y)
  beta.smp[n,] &lt;- beta.tmp
}
beta.slice &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# Adaptive Rejection Sampler
# (only first derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp, uni.sampler="ars"
    , f=function(beta, X, y, grad) {
        if (grad)
          loglike.logit(beta, X, y, fgh=1)$g
        else
          loglike.logit(beta, X, y, fgh=0)
      }
    , X=X, y=y)
  beta.smp[n,] &lt;- beta.tmp
}
beta.ars &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# SNS (Stochastic Newton Sampler)
# (both first and second derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- sns(beta.tmp, fghEval=loglike.logit, X=X, y=y, fgh=2)
  beta.smp[n,] &lt;- beta.tmp
}
beta.sns &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# compare results
cbind(beta.glm, beta.slice, beta.ars, beta.sns)

## End(Not run)
</code></pre>

<hr>
<h2 id='fbase1.exponential.log'>
Single-Parameter Base Log-likelihood Function for Exponential GLM
</h2><span id='topic+fbase1.exponential.log'></span>

<h3>Description</h3>

<p>Vectorized, single-parameter base log-likelihood functions for exponential GLM using log link function. The base function(s) can be supplied to the expander function <code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase1.exponential.log(u, y, fgh=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase1.exponential.log_+3A_u">u</code></td>
<td>
<p>Varying parameter of the base log-likelihood function. This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase1.exponential.log_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model. For <code>Poisson</code> family, it must be a vector of non-negative integers.</p>
</td></tr>
<tr><td><code id="fbase1.exponential.log_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>-u-y*exp(-u)</code> for <code>log</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where the latter is a vector of length <code>length(u)</code>, with each element being the first derivative of the above expressions. If <code>fgh==2</code>, the list will include an element named <code>h</code>, consisting of the second derivatives of <code>f</code> with respect to <code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
library(MfUSampler)

# using the expander framework and base distributions to define
# log-likelihood function for exponential regression
loglike.exponential &lt;- function(beta, X, y, fgh) {
  regfac.expand.1par(beta, X, y, fbase1.exponential.log, fgh)
}

# generate data for exponential regression
N &lt;- 1000
K &lt;- 5
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
y &lt;- rexp(N, rate = exp(-X%*%beta))

# mcmc sampling of log-likelihood
nsmp &lt;- 100

# Slice Sampler (no derivatives needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp
    , f=loglike.exponential, X=X, y=y, fgh=0)
  beta.smp[n,] &lt;- beta.tmp
}
beta.slice &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# Adaptive Rejection Sampler
# (only first derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp, uni.sampler="ars"
    , f=function(beta, X, y, grad) {
        if (grad)
          loglike.exponential(beta, X, y, fgh=1)$g
        else
          loglike.exponential(beta, X, y, fgh=0)
      }
    , X=X, y=y)
  beta.smp[n,] &lt;- beta.tmp
}
beta.ars &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# SNS (Stochastic Newton Sampler)
# (both first and second derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- sns(beta.tmp, fghEval=loglike.exponential, X=X, y=y, fgh=2)
  beta.smp[n,] &lt;- beta.tmp
}
beta.sns &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# compare results
cbind(beta, beta.slice, beta.ars, beta.sns)


## End(Not run)
</code></pre>

<hr>
<h2 id='fbase1.geometric.logit'>
Single-Parameter Base Log-likelihood Function for Exponential GLM
</h2><span id='topic+fbase1.geometric.logit'></span>

<h3>Description</h3>

<p>Vectorized, single-parameter base log-likelihood functions for geometric GLM using logit link function. The base function(s) can be supplied to the expander function <code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase1.geometric.logit(u, y, fgh=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase1.geometric.logit_+3A_u">u</code></td>
<td>
<p>Varying parameter of the base log-likelihood function. This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase1.geometric.logit_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model. For <code>Geometric</code> family, it must be a vector of non-negative integers.</p>
</td></tr>
<tr><td><code id="fbase1.geometric.logit_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>-(y*u+(1+y)*log(1+exp(-u)))</code> for <code>log</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where the latter is a vector of length <code>length(u)</code>, with each element being the first derivative of the above expressions. If <code>fgh==2</code>, the list will include an element named <code>h</code>, consisting of the second derivatives of <code>f</code> with respect to <code>u</code>.
</p>


<h3>Note</h3>

<p>The logit function must be applied to the probability parameter to give <code>X%*%beta</code>, which is in turn the inverse of the mean of the geometric distribution. For brevity, we still call the link function 'logit'.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
library(MfUSampler)

# using the expander framework and base distributions to define
# log-likelihood function for geometric regression
loglike.geometric &lt;- function(beta, X, y, fgh) {
  regfac.expand.1par(beta, X, y, fbase1.geometric.logit, fgh)
}

# generate data for geometric regression
N &lt;- 1000
K &lt;- 5
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
y &lt;- rgeom(N, prob = 1/(1+exp(-X%*%beta)))

# mcmc sampling of log-likelihood
nsmp &lt;- 100

# Slice Sampler
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp
    , f=loglike.geometric, X=X, y=y, fgh=0)
  beta.smp[n,] &lt;- beta.tmp
}
beta.slice &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# Adaptive Rejection Sampler
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp, uni.sampler="ars"
   , f=function(beta, X, y, grad) {
     if (grad)
       loglike.geometric(beta, X, y, fgh=1)$g
     else
       loglike.geometric(beta, X, y, fgh=0)
   }
   , X=X, y=y)
  beta.smp[n,] &lt;- beta.tmp
}
beta.ars &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# SNS (Stochastic Newton Sampler)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- sns(beta.tmp, fghEval=loglike.geometric, X=X, y=y, fgh=2, rnd = n&gt;nsmp/4)
  beta.smp[n,] &lt;- beta.tmp
}
beta.sns &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# compare sample averages with actual values
cbind(beta, beta.sns, beta.slice, beta.ars)

## End(Not run)
</code></pre>

<hr>
<h2 id='fbase1.poisson.log'>
Single-Parameter Base Log-likelihood Function for Poisson GLM
</h2><span id='topic+fbase1.poisson.log'></span>

<h3>Description</h3>

<p>Vectorized, single-parameter base log-likelihood functions for Poisson GLM using log link function. The base function(s) can be supplied to the expander function <code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase1.poisson.log(u, y, fgh=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase1.poisson.log_+3A_u">u</code></td>
<td>
<p>Varying parameter of the base log-likelihood function. This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase1.poisson.log_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model. For <code>Poisson</code> family, it must be a vector of non-negative integers.</p>
</td></tr>
<tr><td><code id="fbase1.poisson.log_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>y*u-exp(u)-lfactorial(y)</code> for <code>log</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where the latter is a vector of length <code>length(u)</code>, with each element being the first derivative of the above expressions. If <code>fgh==2</code>, the list will include an element named <code>h</code>, consisting of the second derivatives of <code>f</code> with respect to <code>u</code>.
</p>


<h3>Note</h3>

<p>In all base log-likelihood functions, we have dropped any additive terms that are independent of the distribution parameter, e.g. constant terms or those terms that are dependent on the response variable only. This is done for computational efficiency. Therefore, these functions cannot be used to obtain the absolute values of log-likelihood functions but only in the context of optimization and/or sampling. Users can write thin wrappers around these functions to add the constant terms to the function value. (Derivatives do not need correction. For Poisson family, the <code>lfactorial(y)</code> term is dropped.)
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
library(MfUSampler)

# using the expander framework and base distributions to define
# log-likelihood function for Poisson regression
loglike.poisson &lt;- function(beta, X, y, fgh) {
  regfac.expand.1par(beta, X, y, fbase1.poisson.log, fgh)
}

# generate data for Poisson regression
N &lt;- 1000
K &lt;- 5
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
y &lt;- rpois(N, lambda = exp(X%*%beta))

# obtaining glm coefficients for comparison
beta.glm &lt;- glm(y~X-1, family="poisson")$coefficients

# mcmc sampling of log-likelihood
nsmp &lt;- 100

# Slice Sampler (no derivatives needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp
    , f=loglike.poisson, X=X, y=y, fgh=0)
  beta.smp[n,] &lt;- beta.tmp
}
beta.slice &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# Adaptive Rejection Sampler
# (only first derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- MfU.Sample(beta.tmp, uni.sampler="ars"
    , f=function(beta, X, y, grad) {
        if (grad)
          loglike.poisson(beta, X, y, fgh=1)$g
        else
          loglike.poisson(beta, X, y, fgh=0)
      }
    , X=X, y=y)
  beta.smp[n,] &lt;- beta.tmp
}
beta.ars &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# SNS (Stochastic Newton Sampler)
# (both first and second derivative needed)
beta.smp &lt;- array(NA, dim=c(nsmp,K)) 
beta.tmp &lt;- rep(0,K)
for (n in 1:nsmp) {
  beta.tmp &lt;- sns(beta.tmp, fghEval=loglike.poisson, X=X, y=y, fgh=2, rnd = n&gt;nsmp/4)
  beta.smp[n,] &lt;- beta.tmp
}
beta.sns &lt;- colMeans(beta.smp[(nsmp/2+1):nsmp,])

# compare results
cbind(beta.glm, beta.slice, beta.ars, beta.sns)

## End(Not run)
</code></pre>

<hr>
<h2 id='fbase2.gamma.log.log'>
Double-Parameter Base Log-likelihood Function for Gamma GLM
</h2><span id='topic+fbase2.gamma.log.log'></span>

<h3>Description</h3>

<p>Vectorized, double-parameter base log-likelihood functions for Gamma GLM. The link functions map the mean and dispersion parameter to linear predictors. The base function can be supplied to the expander function <code><a href="#topic+regfac.expand.2par">regfac.expand.2par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase2.gamma.log.log(u, v, y, fgh = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase2.gamma.log.log_+3A_u">u</code></td>
<td>
<p>First parameter of the base log-likelihood function (usually the result of applying a link function to distribution mean). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.2par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code> or <code>v</code>.</p>
</td></tr>
<tr><td><code id="fbase2.gamma.log.log_+3A_v">v</code></td>
<td>
<p>Second parameter of the base log-likelihood function (usually the result of applying a link function to distribution dispersion parameter). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>v &lt;- Z%*%gamma</code>. In the typical use-case where the caller is <code>regfac.expand.2par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code> or <code>v</code>.</p>
</td></tr>
<tr><td><code id="fbase2.gamma.log.log_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model.</p>
</td></tr>
<tr><td><code id="fbase2.gamma.log.log_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>-exp(-v)*(u + y*exp(-u) + v - log(y)) - log(y) - log(gamma(exp(-v)))</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where <code>f</code> is the same object as in <code>fgh==0</code> and <code>g</code> is a matrix of dimensions <code>length(u)</code>-by-2, with first column being the derivative of the above expression with respect to <code>u</code>, and the second column being the derivative of the above expression with respect to <code>v</code>. If <code>fgh==2</code>, the list will include an element named <code>h</code>, which is a matrix of dimensions <code>length(u)</code>-by-3, with the first column being the second derivative of <code>f</code> with respect to <code>u</code>, the second column being the second derivative of <code>f</code> with respect to <code>v</code>, and the third column is the cross-derivative term, i.e. the derivative of <code>f</code> with respect to <code>u</code> and <code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p>regfac.expand.2par
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we use this library for univariate slice sampling
# of multivariate distributions
library(MfUSampler)
library(dglm)

# simulating data according to assumed generative model
# we assume log link functions for both mean and dispersion
# given variance function V(mu) = mu^2, we have:
# log(mu) = X%*%beta
# log(phi) = X%*%gamma
N &lt;- 10000
K &lt;- 5
X &lt;- cbind(1,matrix(runif(N*(K-1), min=-0.5, max=+0.5), ncol=K-1))
beta &lt;- runif(K, min=0.0, max=+1.0)
gamma &lt;- runif(K, min=0.0, max=+1.0)
shape.vec &lt;- 1 / exp(X%*%gamma)
rate.vec &lt;- 1 / exp(X%*%gamma + X%*%beta)
y &lt;- rgamma(N, shape = shape.vec, rate = rate.vec)
# implied dispersion:
dispersion.vec &lt;- 1 / shape.vec

# model estimation using dglm package
reg.dglm &lt;- dglm(y~X-1, dformula = ~X-1, family=Gamma(link="log"), dlink = "log")
beta.dglm &lt;- reg.dglm$coefficients
gamma.dglm &lt;- reg.dglm$dispersion.fit$coefficients

# model estimation using RegressionFactory
# (with univariate slice sampling)
# defining the log-likelihood using the expander framework
# assumng same covariates for both slots, hence we set Z=X
# slice sampler does not need derivatives, hence we set fgh=0
loglike.gamma &lt;- function(coeff, X, y) {
  regfac.expand.2par(coeff, X=X, Z=X, y=y, fbase2=fbase2.gamma.log.log, fgh=0)
}
nsmp &lt;- 100
coeff.smp &lt;- array(NA, dim=c(nsmp, 2*K)) 
coeff.tmp &lt;- rep(0.1, 2*K)
for (n in 1:nsmp) {
  coeff.tmp &lt;- MfU.Sample(coeff.tmp, f=loglike.gamma, X=X, y=y)
  coeff.smp[n,] &lt;- coeff.tmp
}
beta.slice &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, 1:K])
gamma.slice &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, K+1:K])

# compare results
cbind(beta.dglm, beta.slice)
cbind(gamma.dglm, gamma.slice)


## End(Not run)
</code></pre>

<hr>
<h2 id='fbase2.gaussian.identity.log'>
Double-Parameter Base Log-likelihood Function for Gaussian GLM
</h2><span id='topic+fbase2.gaussian.identity.log'></span>

<h3>Description</h3>

<p>Vectorized, double-parameter base log-likelihood functions for Gaussian GLM. The link functions map the mean and variance to linear predictors. The base function can be supplied to the expander function <code><a href="#topic+regfac.expand.2par">regfac.expand.2par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase2.gaussian.identity.log(u, v, y, fgh = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase2.gaussian.identity.log_+3A_u">u</code></td>
<td>
<p>First parameter of the base log-likelihood function (usually the mean). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase2.gaussian.identity.log_+3A_v">v</code></td>
<td>
<p>Second parameter of the base log-likelihood function (usually the mean). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>v &lt;- Z%*%gamma</code>. In the typical use-case where the caller is <code>regfac.expand.1par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code>.</p>
</td></tr>
<tr><td><code id="fbase2.gaussian.identity.log_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model. For <code>binomial</code> family, it must be an integer vector with values between <code>0</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="fbase2.gaussian.identity.log_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>-0.5*(v + exp(-v)*(u-y)*(u-y))</code> (ignoring additive terms that are independent of <code>u,v</code>). It will therefore be of the same length as <code>u</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where <code>f</code> is the same object as in <code>fgh==1</code> and <code>g</code> is a matrix of dimensions <code>length(u)</code>-by-2, with first column being the derivative of the above expression with respect to <code>u</code>, and the second column being the derivative of the above expression with respect to <code>v</code>. If <code>fgh==2</code>, the list will include an element named <code>h</code>, which is a matrix of dimensions <code>length(u)</code>-by-3, with the first column being the second derivative of <code>f</code> with respect to <code>u</code>, the second column being the second derivative of <code>f</code> with respect to <code>v</code>, and the third column is the cross-derivative term, i.e. the derivative of <code>f</code> with respect to <code>u</code> and <code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p>regfac.expand.2par
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
library(MfUSampler)
library(dglm)

# defining log-likelihood function
# vd==FALSE leads to constant-dispersion model (ordinary linear regression)
# while vd==TRUE produces varying-dispersion model
loglike.linreg &lt;- function(coeff, X, y, fgh, block.diag = F, vd = F) {
  if (vd) regfac.expand.2par(coeff = coeff, X = X, Z = X, y = y
    , fbase2 = fbase2.gaussian.identity.log, fgh = fgh, block.diag = block.diag)
  else regfac.expand.2par(coeff = coeff, X = X, y = y
    , fbase2 = fbase2.gaussian.identity.log, fgh = fgh, block.diag = block.diag)
}

# simulating data according to generative model
N &lt;- 1000 # number of observations
K &lt;- 5 # number of covariates
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
gamma &lt;- runif(K, min=-0.5, max=+0.5)
mean.vec &lt;- X%*%beta
sd.vec &lt;- exp(X%*%gamma)
y &lt;- rnorm(N, mean.vec, sd.vec)

# constant-dispersion model
# estimation using glm
est.glm &lt;- lm(y~X-1)
beta.glm &lt;- est.glm$coefficients
sigma.glm &lt;- summary(est.glm)$sigma
# estimation using RegressionFactory
# (we set rnd=F in sns to allow for better comparison with glm)
nsmp &lt;- 20
coeff.smp &lt;- array(NA, dim=c(nsmp, K+1)) 
coeff.tmp &lt;- rep(0, K+1)
for (n in 1:nsmp) {
  coeff.tmp &lt;- sns(coeff.tmp, fghEval=loglike.linreg
    , X=X, y=y, fgh=2, block.diag = F, vd = F, rnd = F)
  coeff.smp[n,] &lt;- coeff.tmp
}
beta.regfac.cd &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, 1:K])
sigma.regfac.cd &lt;- sqrt(exp(mean(coeff.smp[(nsmp/2+1):nsmp, K+1])))
# comparing glm and RegressionFactory results
# beta's must match exactly between glm and RegressionFactory
cbind(beta, beta.glm, beta.regfac.cd)
# sigma's won't match exactly
cbind(mean(sd.vec), sigma.glm, sigma.regfac.cd)

# varying-dispersion model
# estimation using dglm
est.dglm &lt;- dglm(y~X-1, dformula = ~X-1, family = "gaussian", dlink = "log")
beta.dglm &lt;- est.dglm$coefficients
gamma.dglm &lt;- est.dglm$dispersion.fit$coefficients
# estimation using RegressionFactory
coeff.smp &lt;- array(NA, dim=c(nsmp, 2*K)) 
coeff.tmp &lt;- rep(0, 2*K)
for (n in 1:nsmp) {
  coeff.tmp &lt;- sns(coeff.tmp, fghEval=loglike.linreg
    , X=X, y=y, fgh=2, block.diag = F, vd = T, rnd = F)
  coeff.smp[n,] &lt;- coeff.tmp
}
beta.regfac.vd &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, 1:K])
gamma.regfac.vd &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, K+1:K])
# comparing dglm and RegressionFactory results
# neither beta's nor gamma's will match exactly
cbind(beta, beta.dglm, beta.regfac.vd)
cbind(gamma, gamma.dglm, gamma.regfac.vd)


## End(Not run)
</code></pre>

<hr>
<h2 id='fbase2.inverse.gaussian.log.log'>
Double-Parameter Base Log-likelihood Function for Inverse-Gaussian GLM
</h2><span id='topic+fbase2.inverse.gaussian.log.log'></span>

<h3>Description</h3>

<p>Vectorized, double-parameter base log-likelihood functions for Inverse-Gaussian GLM. The link functions map the mean and dispersion parameter to linear predictors. The base function can be supplied to the expander function <code><a href="#topic+regfac.expand.2par">regfac.expand.2par</a></code> in order to obtain the full, high-dimensional log-likleihood and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbase2.inverse.gaussian.log.log(u, v, y, fgh = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbase2.inverse.gaussian.log.log_+3A_u">u</code></td>
<td>
<p>First parameter of the base log-likelihood function (usually the result of applying a link function to distribution mean). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>u &lt;- X%*%beta</code>. In the typical use-case where the caller is <code>regfac.expand.2par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code> or <code>v</code>.</p>
</td></tr>
<tr><td><code id="fbase2.inverse.gaussian.log.log_+3A_v">v</code></td>
<td>
<p>Second parameter of the base log-likelihood function (usually the result of applying a link function to distribution dispersion parameter). This parameter is intended to be projected onto a high-dimensional space using the familiar regression transformation of <code>v &lt;- Z%*%gamma</code>. In the typical use-case where the caller is <code>regfac.expand.2par</code>, a vector of values are supplied, and return objects will have the same length as <code>u</code> or <code>v</code>.</p>
</td></tr>
<tr><td><code id="fbase2.inverse.gaussian.log.log_+3A_y">y</code></td>
<td>
<p>Fixed slot of the base distribution, corresponding to the response variable in the regression model.</p>
</td></tr>
<tr><td><code id="fbase2.inverse.gaussian.log.log_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood vector and no derivatives. If <code>fgh=1</code>, it returns the log-likelihood and its first derivative in a list. If <code>fgh=2</code>, it returns the log-likelihood, as well as its first and second derivatives in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, the function returns <code>-v/2 - 0.5*exp(-v-2*u)*(y - exp(u))^2/y</code>. If <code>fgh==1</code>, a list is returned with elements <code>f</code> and <code>g</code>, where <code>f</code> is the same object as in <code>fgh==0</code> and <code>g</code> is a matrix of dimensions <code>length(u)</code>-by-2, with first column being the derivative of the above expression with respect to <code>u</code>, and the second column being the derivative of the above expression with respect to <code>v</code>. If <code>fgh==2</code>, the list will include an element named <code>h</code>, which is a matrix of dimensions <code>length(u)</code>-by-3, with the first column being the second derivative of <code>f</code> with respect to <code>u</code>, the second column being the second derivative of <code>f</code> with respect to <code>v</code>, and the third column is the cross-derivative term, i.e. the derivative of <code>f</code> with respect to <code>u</code> and <code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>See Also</h3>

<p>regfac.expand.2par
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we use this library for univariate slice sampling
# of multivariate distributions
library(MfUSampler)
library(dglm)

# simulating data according to assumed generative model
# we assume log link functions for both mean and dispersion
# (shape parameter is inverse of dispersion)
N &lt;- 10000
K &lt;- 5
X &lt;- cbind(1,matrix(runif(N*(K-1), min=-0.5, max=+0.5), ncol=K-1))
beta &lt;- runif(K, min=-0.5, max=+0.5)
gamma &lt;- runif(K, min=-0.5, max=+0.5)
mean.vec &lt;- exp(X %*% beta)
dispersion.vec &lt;- exp(X %*% gamma)
y &lt;- rinvgauss(N, mean = mean.vec, dispersion = dispersion.vec)

# model estimation using dglm package
reg.dglm &lt;- dglm(y~X-1, dformula = ~X-1, family=inverse.gaussian(link="log"), dlink = "log")
beta.dglm &lt;- reg.dglm$coefficients
gamma.dglm &lt;- reg.dglm$dispersion.fit$coefficients

# model estimation using RegressionFactory
# (with univariate slice sampling)
# defining the log-likelihood using the expander framework
# assumng same covariates for both slots, hence we set Z=X
# slice sampler does not need derivatives, hence we set fgh=0
loglike.inverse.gaussian &lt;- function(coeff, X, y) {
  regfac.expand.2par(coeff, X=X, Z=X, y=y, fbase2=fbase2.inverse.gaussian.log.log, fgh=0)
}
nsmp &lt;- 100
coeff.smp &lt;- array(NA, dim=c(nsmp, 2*K)) 
coeff.tmp &lt;- rep(0.1, 2*K)
for (n in 1:nsmp) {
  coeff.tmp &lt;- MfU.Sample(coeff.tmp, f=loglike.inverse.gaussian, X=X, y=y)
  coeff.smp[n,] &lt;- coeff.tmp
}
beta.slice &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, 1:K])
gamma.slice &lt;- colMeans(coeff.smp[(nsmp/2+1):nsmp, K+1:K])

# compare results
cbind(beta.dglm, beta.slice)
cbind(gamma.dglm, gamma.slice)


## End(Not run)
</code></pre>

<hr>
<h2 id='regfac.expand.1par'>
Expander Function for Single-Parameter Base Distributions
</h2><span id='topic+regfac.expand.1par'></span>

<h3>Description</h3>

<p>This function produces the full, high-dimensional gradient and Hessian from the base-distribution derivatives for linear transformations of the arguments of a single-parameter base distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regfac.expand.1par(beta, X, y, fbase1, fgh=2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regfac.expand.1par_+3A_beta">beta</code></td>
<td>
<p>Vector of coefficients in the regression model.</p>
</td></tr>
<tr><td><code id="regfac.expand.1par_+3A_x">X</code></td>
<td>
<p>Matrix of covariates in the regression model. Note that <code>ncol(X)</code> must be equal to <code>length(beta)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.1par_+3A_y">y</code></td>
<td>
<p>Vector of response variable in the regression model. Note that <code>length(y)</code> must be equal to <code>nrow(X)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.1par_+3A_fbase1">fbase1</code></td>
<td>
<p>Base distribution function <code>fbase1(u, y, ...)</code> for the regression model. It must return a list with elements <code>f,g,h</code> corresponding to the function and its first and second derivatives relative to its first argument, <code>u</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.1par_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood function. If <code>fgh=1</code>, it returns the log-likelihood and its gradient vector. If <code>fgh=2</code>, it returns the log-likelihood, the gradient vector and the Hessian matrix.</p>
</td></tr>
<tr><td><code id="regfac.expand.1par_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>fbase1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>f,g,h</code> corresponding to the function, gradient vector, and Hessian matrix of the function <code>fbase(X%*%beta,y)</code>, i.e. the base function <code>fbase(u,y)</code> projected onto the high-dimensional space of <code>beta</code> through the linear transformation of its first argument (<code>u &lt;- X%*%beta</code>).
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Mahani, Alireza S. and Sharabiani, Mansour T.A. (2013)
<em>Metropolis-Hastings Sampling Using Multivariate Gaussian Tangents</em>
<a href="https://arxiv.org/pdf/1308.0657v1.pdf">https://arxiv.org/pdf/1308.0657v1.pdf</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.2par">regfac.expand.2par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sns)
# simulating logistic regression data
N &lt;- 1000 # number of observations
K &lt;- 10 # number of variables
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
Xbeta &lt;- X%*%beta
y &lt;- 1*(runif(N)&lt;1/(1+exp(-Xbeta)))
beta.est &lt;- rep(0,K)
# run sns in non-stochastic mode, i.e. Newton-Raphson optimization
for (i in 1:10) {
  beta.est &lt;- sns(beta.est, regfac.expand.1par, rnd=F, X=X, y=y
    , fbase1=fbase1.binomial.logit)
}
# use glm to estimate beta and compare
beta.est.glm &lt;- glm(y~X-1, family="binomial")$coefficients
cbind(beta.est, beta.est.glm)

## End(Not run)
</code></pre>

<hr>
<h2 id='regfac.expand.2par'>
Expander Function for Two-Parameter Base Distributions
</h2><span id='topic+regfac.expand.2par'></span>

<h3>Description</h3>

<p>This function produces the full, high-dimensional gradient and Hessian from the base-distribution derivatives for linear transformations of the arguments of a two-parameter base distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regfac.expand.2par(coeff, X, Z=matrix(1.0, nrow=nrow(X), ncol=1)
  , y, fbase2, fgh=2, block.diag=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regfac.expand.2par_+3A_coeff">coeff</code></td>
<td>
<p>Vector of coefficients in the regression model. The first <code>ncol(X)</code> elements correspond to the first parameter of the base distribution <code>fbase2(u, v, y, ...)</code>, and the next <code>ncol(Z)</code> elements corresponds to the second parameter of the base distribution <code>fbase2(u, v, y, ...)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_x">X</code></td>
<td>
<p>Matrix of covariates corresponding to the first parameter of the base distribution <code>fbase2(u, v, y, ...)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_z">Z</code></td>
<td>
<p>Matrix of covariates corresponding to the second parameter of the base distribution <code>fbase2(u, v, y, ...)</code>. Default is a single column of 1's, corresponding to an intercept-only model for the second parameter, i.e. assuming the second parameter is constant across all observations. Note that <code>nrow(Z)</code> must be equal to <code>nrow(X)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_y">y</code></td>
<td>
<p>Vector of response variables. Note that <code>length(y)</code> must be equal to <code>nrow(X)</code>.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_fbase2">fbase2</code></td>
<td>
<p>Base distribution function <code>fbase2(u, v, y, ...)</code> for the regression model. It must return a list with elements <code>f,g,h</code> corresponding to the function and its first and second derivatives relative to its first two argument, <code>u,v</code>. The gradient must be a matrix of dimensions <code>nrow(X)</code>-by-2, where the first column is the gradient of the log-likelihood function with respect to its first parameter (fbase2_u), evaluated at each of the <code>nrow(X)</code> observations, and the second column is the gradient of the log-likelihood function with repsect to its second parameter (fbase2_v), also evaluated at each observation point. Similarly, the Hessian must be a matrix of dimensions <code>nrow(X)</code>-by-3, with elements being equal to fbase2_uu, fbase2_vv and fbase2_uv evaluated at each observation point (taking advantage of the Hessian being symmetric).</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_fgh">fgh</code></td>
<td>
<p>Integer with possible values 0,1,2. If <code>fgh=0</code>, the function only calculates and returns the log-likelihood function. If <code>fgh=1</code>, it returns the log-likelihood and its gradient vector. If <code>fgh=2</code>, it returns the log-likelihood, the gradient vector and the Hessian matrix.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_block.diag">block.diag</code></td>
<td>
<p>If <code>TRUE</code>, Hessian matrix is block-diagonalized by setting cross-terms between <code>beta</code> and <code>gamma</code> to zero. This can be useful if the full - i.e. non-block-diagonalized - Hessian is not negative definite, but block-diagonalization leads to definiteness. If <code>TRUE</code>, third element of the Hessian of <code>fbase</code> is not needed and thus it can be vector of length 2 instead of 3.</p>
</td></tr>
<tr><td><code id="regfac.expand.2par_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>fbase2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>f,g,h</code> corresponding to the function, gradient vector, and Hessian matrix of the function <code>fbase2(X%*%beta, Z%*%gamma, y, ...)</code>, where <code>beta=coeff[1:ncol(X)]</code> and <code>gamma=coeff[ncol(X)+1:ncol(Z)]</code>. (Derivatives are evaluated relative to <code>coeff</code>.) In other words, the base function <code>fbase2(u, v, y, ...)</code> is projected onto the high-dimensional space of <code>c(beta, gamma)</code> through the linear transformations of its first argument (<code>u &lt;- X%*%beta</code>) and its second argument (<code>v &lt;- Z%*%gamma</code>).
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Mahani, Alireza S. and Sharabiani, Mansour T.A. (2013)
<em>Metropolis-Hastings Sampling Using Multivariate Gaussian Tangents</em>
<a href="https://arxiv.org/pdf/1308.0657v1.pdf">https://arxiv.org/pdf/1308.0657v1.pdf</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regfac.expand.1par">regfac.expand.1par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dglm)
library(sns)

# defining log-likelihood function
loglike.linreg &lt;- function(coeff, X, y) {
  regfac.expand.2par(coeff = coeff, X = X, Z = X, y = y
    , fbase2 = fbase2.gaussian.identity.log, fgh = 2, block.diag = T)
}

# simulating data according to generative model
N &lt;- 1000 # number of observations
K &lt;- 5 # number of covariates
X &lt;- matrix(runif(N*K, min=-0.5, max=+0.5), ncol=K)
beta &lt;- runif(K, min=-0.5, max=+0.5)
gamma &lt;- runif(K, min=-0.5, max=+0.5)
mean.vec &lt;- X%*%beta
sd.vec &lt;- exp(X%*%gamma)
y &lt;- rnorm(N, mean.vec, sd.vec)

# estimation using dglm
est.dglm &lt;- dglm(y~X-1, dformula = ~X-1, family = "gaussian", dlink = "log")
beta.dglm &lt;- est.dglm$coefficients
gamma.dglm &lt;- est.dglm$dispersion.fit$coefficients

# estimation using RegressionFactory
coeff.tmp &lt;- rep(0, 2*K)
for (n in 1:10) {
  coeff.tmp &lt;- sns(coeff.tmp, fghEval=loglike.linreg
    , X=X, y=y, rnd = F)
}
beta.regfac.vd &lt;- coeff.tmp[1:K]
gamma.regfac.vd &lt;- coeff.tmp[K+1:K]

# comparing dglm and RegressionFactory results
# neither beta's nor gamma's will match exactly
cbind(beta.dglm, beta.regfac.vd)
cbind(gamma.dglm, gamma.regfac.vd)

## End(Not run)
</code></pre>

<hr>
<h2 id='regfac.merge'>
Utility Function for Adding Two Functions and Their Derivatives
</h2><span id='topic+regfac.merge'></span>

<h3>Description</h3>

<p>Combining two log-density functions by adding the corresponding elements of their lists (function, gradient, Hessian). This can be useful, e.g. in combining the likelihood and the prior (in log domain) to form the posterior according to Bayes rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regfac.merge(fgh1, fgh2, fgh = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regfac.merge_+3A_fgh1">fgh1</code></td>
<td>
<p>First log-density list, containing elements <code>f</code>, <code>g</code> and <code>h</code>, corresponding to log-density function, its gradient vector, and its Hessian matrix.</p>
</td></tr>
<tr><td><code id="regfac.merge_+3A_fgh2">fgh2</code></td>
<td>
<p>Second log-density list, containing elements <code>f</code>, <code>g</code> and <code>h</code>, corresponding to log-density function, its gradient vector, and its Hessian matrix.</p>
</td></tr>
<tr><td><code id="regfac.merge_+3A_fgh">fgh</code></td>
<td>
<p>Integer flag with possible values <code>0,1,2</code>, indicating the maximum order of derivative to be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fgh==0</code>, <code>fgh1+fgh2</code> is returned. Otherwise, a list is returned with elements <code>f</code>, <code>g</code>, and <code>h</code>, each of which is the sum of corresponding elements of <code>fgh1</code> and <code>fgh2</code> lists.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constructing the log-posterior for Bayesian logistic regression
# log-likelihood
loglike.logistic &lt;- function(beta, X, y, fgh) {
  regfac.expand.1par(beta, X, y, fbase1.binomial.logit, fgh, n=1)
}
# log-prior
logprior.logistic &lt;- function(beta, mu.beta, sd.beta, fgh) {
  f &lt;- sum(dnorm(beta, mu.beta, sd.beta, log=TRUE))
  if (fgh==0) return (f)
  g &lt;- -(beta-mu.beta)/sd.beta^2
  if (fgh==1) return (list(f=f, g=g))
  #h &lt;- diag(rep(-1/sd.beta^2,length(beta)))
  h &lt;- diag(-1/sd.beta^2)
  return (list(f=f, g=g, h=h))
}
# adding log-likelihood and log-prior according to Bayes rule
logpost.logistic &lt;- function(beta, X, y, mu.beta, sd.beta, fgh) {
  ret.loglike &lt;- loglike.logistic(beta, X, y, fgh)
  ret.logprior &lt;- logprior.logistic(beta, mu.beta, sd.beta, fgh)
  regfac.merge(ret.loglike,ret.logprior, fgh=fgh)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
