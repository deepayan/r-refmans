<!DOCTYPE html><html><head><title>Help for package VAR.spec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VAR.spec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#VAR.spec-package'>
<p>Allows Specifying a Bivariate VAR (Vector Autoregression) with Desired Spectral Characteristics</p></a></li>
<li><a href='#calc.VAR.spec.from.coefs'>
<p>Calculates the spectral matrix of a multivariate VAR (Vector autoregression) model.</p></a></li>
<li><a href='#calculate.VAR'>
<p>Attempts to define a bivariate VAR (Vector autoregression) model.</p></a></li>
<li><a href='#Init.var'><p>Initializes an object of class <code>var</code></p></a></li>
<li><a href='#plot_VAR.Phase.details'>
<p>Plots details related to the Phase spectrum of a bivariate VAR (Vector autoregression) model.</p></a></li>
<li><a href='#plot_VAR.spectra'>
<p>Plots spectra of a bivariate VAR (Vector autoregression) model.</p></a></li>
<li><a href='#simulate.VAR'>
<p>Simulates a bivariate series from a bivariate VAR (Vector autoregression) model.</p></a></li>
<li><a href='#VAR.inv.roots.from.det.cross'>
<p>An example <code>data.frame</code> defining a VAR (Vector autoregression) model.</p></a></li>
<li><a href='#VAR.inv.roots.from.eta.ksi.zeta'>
<p>An example <code>data.frame</code> defining a VAR model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Allows Specifying a Bivariate VAR (Vector Autoregression) with
Desired Spectral Characteristics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-7</td>
</tr>
<tr>
<td>Description:</td>
<td>The spectral characteristics of a bivariate series (Marginal Spectra, Coherency- and Phase-Spectrum) determine whether there is a strong presence of short-, medium-, or long-term fluctuations (components of certain frequencies in the spectral representation of the series) in each one of them.  These are induced by strong peaks of the marginal spectra of each series at the corresponding frequencies. The spectral characteristics also determine how strongly these short-, medium-, or long-term fluctuations of the two series are correlated between the two series. Information on this is provided by the Coherency spectrum at the corresponding frequencies. Finally, certain fluctuations of the two series may be lagged to each other. Information on this is provided by the Phase spectrum at the corresponding frequencies. The idea in this package is to define a VAR (Vector autoregression) model with desired spectral characteristics by specifying a number of polynomials, required to define the VAR. See Ioannidis(2007) &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2005.12.013">doi:10.1016/j.jspi.2005.12.013</a>&gt;. These are specified via their roots, instead of via their coefficients. This is an idea borrowed from the Time Series Library of R. Dahlhaus, where it is used for defining ARMA models for univariate time series. This way, one may e.g. specify a VAR inducing a strong presence of long-term fluctuations in series 1 and in series 2, which are weakly correlated, but lagged by a number of time units to each other, while short-term fluctuations in series 1 and in series 2, are strongly present only in one of the two series, while they are strongly correlated to each other between the two series. Simulation from such models allows studying the behavior of data-analysis tools, such as estimation of the spectra, under different circumstances, as e.g. peaks in the spectra, generating bias, induced by leakage.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-10 08:36:15 UTC; Dell</td>
</tr>
<tr>
<td>Author:</td>
<td>Evangelos Ioannidis [cre, aut, cph],
  Panagiotis Papastamoulis [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evangelos Ioannidis &lt;eioannid@aueb.gr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-11 11:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='VAR.spec-package'>
Allows Specifying a Bivariate VAR (Vector Autoregression) with Desired Spectral Characteristics
</h2><span id='topic+VAR.spec-package'></span><span id='topic+VAR.spec'></span>

<h3>Description</h3>

<p>The spectral characteristics of a bivariate series (Marginal Spectra, Coherency- and Phase-Spectrum) determine whether there is a strong presence of short-, medium-, or long-term fluctuations (components of certain frequencies in the spectral representation of the series) in each one of them.  These are induced by strong peaks of the marginal spectra of each series at the corresponding frequencies. The spectral characteristics also determine how strongly these short-, medium-, or long-term fluctuations of the two series are correlated between the two series. Information on this is provided by the Coherency spectrum at the corresponding frequencies. Finally, certain fluctuations of the two series may be lagged to each other. Information on this is provided by the Phase spectrum at the corresponding frequencies. The idea in this package is to define a VAR (Vector autoregression) model with desired spectral characteristics by specifying a number of polynomials, required to define the VAR. See Ioannidis(2007) &lt;doi:10.1016/j.jspi.2005.12.013&gt;. These are specified via their roots, instead of via their coefficients. This is an idea borrowed from the Time Series Library of R. Dahlhaus, where it is used for defining ARMA models for univariate time series. This way, one may e.g. specify a VAR inducing a strong presence of long-term fluctuations in series 1 and in series 2, which are weakly correlated, but lagged by a number of time units to each other, while short-term fluctuations in series 1 and in series 2, are strongly present only in one of the two series, while they are strongly correlated to each other between the two series. Simulation from such models allows studying the behavior of data-analysis tools, such as estimation of the spectra, under different circumstances, as e.g. peaks in the spectra, generating bias, induced by leakage.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> VAR.spec</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Allows Specifying a Bivariate VAR (Vector Autoregression) with Desired Spectral Characteristics</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-06-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
    person("Evangelos", "Ioannidis", email = "eioannid@aueb.gr", role =  c("cre", "aut", "cph") ),
    person("Panagiotis", "Papastamoulis", email = "papapast@yahoo.gr", role = c("aut", "cph")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The spectral characteristics of a bivariate series (Marginal Spectra, Coherency- and Phase-Spectrum) determine whether there is a strong presence of short-, medium-, or long-term fluctuations (components of certain frequencies in the spectral representation of the series) in each one of them.  These are induced by strong peaks of the marginal spectra of each series at the corresponding frequencies. The spectral characteristics also determine how strongly these short-, medium-, or long-term fluctuations of the two series are correlated between the two series. Information on this is provided by the Coherency spectrum at the corresponding frequencies. Finally, certain fluctuations of the two series may be lagged to each other. Information on this is provided by the Phase spectrum at the corresponding frequencies. The idea in this package is to define a VAR (Vector autoregression) model with desired spectral characteristics by specifying a number of polynomials, required to define the VAR. See Ioannidis(2007) &lt;doi:10.1016/j.jspi.2005.12.013&gt;. These are specified via their roots, instead of via their coefficients. This is an idea borrowed from the Time Series Library of R. Dahlhaus, where it is used for defining ARMA models for univariate time series. This way, one may e.g. specify a VAR inducing a strong presence of long-term fluctuations in series 1 and in series 2, which are weakly correlated, but lagged by a number of time units to each other, while short-term fluctuations in series 1 and in series 2, are strongly present only in one of the two series, while they are strongly correlated to each other between the two series. Simulation from such models allows studying the behavior of data-analysis tools, such as estimation of the spectra, under different circumstances, as e.g. peaks in the spectra, generating bias, induced by leakage.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Evangelos Ioannidis [cre, aut, cph],
  Panagiotis Papastamoulis [aut, cph]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Evangelos Ioannidis &lt;eioannid@aueb.gr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Init.var                Initializes an object of class 'var'
VAR.inv.roots.from.det.cross
                        An example 'data.frame' defining a VAR (Vector
                        autoregression) model.
VAR.inv.roots.from.eta.ksi.zeta
                        An example 'data.frame' defining a VAR model.
VAR.spec-package        Allows Specifying a Bivariate VAR (Vector
                        Autoregression) with Desired Spectral
                        Characteristics
calc.VAR.spec.from.coefs
                        Calculates the spectral matrix of a
                        multivariate VAR (Vector autoregression) model.
calculate.VAR           Attempts to define a bivariate VAR (Vector
                        autoregression) model.
plot_VAR.Phase.details
                        Plots details related to the Phase spectrum of
                        a bivariate VAR (Vector autoregression) model.
plot_VAR.spectra        Plots spectra of a bivariate VAR (Vector
                        autoregression) model.
simulate.VAR            Simulates a bivariate series from a bivariate
                        VAR (Vector autoregression) model.
</pre>
<p>The specification of the VAR (Vector autoregression) model is based on the following fact (see Ioannidis (2007))
</p>
<p>&lt;doi:10.1016/j.jspi.2005.12.013&gt;: 
</p>
<p>For any four complex polynomials <code class="reqn">det(z), cross(z)</code> of degree <code class="reqn">2p</code> and <code class="reqn">chi.1(z), chi.2(z)</code> of degree <code class="reqn">p</code>, satisfying
</p>
<p>EQ(*) </p>
<p style="text-align: center;"><code class="reqn">|det(z)|^2+|cross(z)|^2 = |chi.1(z)|^2 * |chi.2(z)|^2</code>
</p>
<p> on <code class="reqn">|z|=1</code>, there exists a bivariate  VAR(p) with marginal spectra </p>
<p style="text-align: center;"><code class="reqn">f.i (w) = (1/2\pi) |chi.i(z)|^2 /|det(z)|^2,</code>
</p>
<p> and cross-spectrum </p>
<p style="text-align: center;"><code class="reqn">f.1.2 (w) = (1/2\pi) z^{(-p)}cross(z) /|det(z)|^2,</code>
</p>
<p> where <code class="reqn">z=exp(-iw)</code>. The squared Coherency is then given by </p>
<p style="text-align: center;"><code class="reqn">|cross(z)|^2 /(|det(z)|^2+|cross(z)|^2).</code>
</p>

<p>The idea in this package is to define the necessary polynomials by specifying their roots, instead of their coefficients. This is an idea  borrowed from the Time Series Library of R. Dahlhaus,  where it is used for defining ARMA models for univariate time series. 
</p>
<p>Moreover, the package allows the user to specify only some of the roots of <code class="reqn">det(z), cross(z)</code> and <code class="reqn">chi.1(z), chi.2(z)</code>, while it attempts to find further non-specified roots in a way such that EQ(*) is satisfied. 
</p>
<p>By specifying certain roots of <code class="reqn">det(z), cross(z)</code> and <code class="reqn">chi.1(z), chi.2(z)</code> one can induce desired features in the spectra and in the series. For example,
</p>

<ul>
<li><p> if one wishes a strong presence of frequency <code class="reqn">w_0</code> components in series 1,
there should be a root with modulus close to 1 and angle equal to <code class="reqn">w_0</code>, the multiplicity of which for <code class="reqn">det(z)</code> is higher than its multiplicity for <code class="reqn">chi.1(z)</code>, forcing the spectrum of series 1 to have a peak at <code class="reqn">w_0</code>. 
</p>
</li>
<li><p> If the frequency-<code class="reqn">w_0</code>-components should be strongly correlated between series 1 and series 2, the multiplicity of this root for <code class="reqn">det(z)</code> should be higher than its multiplicity for <code class="reqn">cross(z)</code>, forcing the Coherency at <code class="reqn">w_0</code> close to 1.
</p>
</li></ul>

<p>Required polynomials (see argument <code>calc.method</code> of function <code>calculate.VAR</code> and related <code>Details</code>) are first passed to function <code>Init.var</code>, via a <code>data.frame</code> or a text file, which contains the multiplicities of desired roots (rows) for each required polynomial (columns).
</p>
<p>After calling <code>Init.var</code>, function <code>calculate.VAR</code> must be called, which attempts to find a VAR model which is compatible with the polynomials specified in its attribute <code>inv.roots</code>, by making necessary adjustments, calculates its spectra, coefficients and order, makes the necessary checks and plots it's spectra. Then, one can simulate from the specified model calling <code>simulate.VAR</code>.
</p>


<h3>Author(s)</h3>

<p>Evangelos Ioannidis [cre, aut, cph],
  Panagiotis Papastamoulis [aut, cph]
</p>
<p>Maintainer: Evangelos Ioannidis &lt;eioannid@aueb.gr&gt;
</p>


<h3>References</h3>

<p>Ioannidis, E. E. (2007). Spectra of bivariate VAR(p) models. Journal of Statistical Planning and Inference 137(2), 554-566. 
</p>
<p>Ioannidis, E. E. and Chronis, G. A. (2005). Extreme spectra of VAR models and orders of near-cointegration. J. Time Ser. Anal. 26, 399-421.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>, <code><a href="#topic+simulate.VAR">simulate.VAR</a></code>,
</p>
<p><code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>,
</p>
<p><code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR (a.var = my.var, calc.method="from.det.cross", 
            plot.spectra=TRUE,suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)

</code></pre>

<hr>
<h2 id='calc.VAR.spec.from.coefs'>
Calculates the spectral matrix of a multivariate VAR (Vector autoregression) model.
</h2><span id='topic+calc.VAR.spec.from.coefs'></span>

<h3>Description</h3>

<p>Calculates the spectral matrix for all grid points for any (multivariate) VAR model, represented by an object of class <code>var</code>, with specified coefficients (in attribute <code>ar.list</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.VAR.spec.from.coefs(a.var)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.VAR.spec.from.coefs_+3A_a.var">a.var</code></td>
<td>

<p>an object of class <code>var</code> for which the spectral matrix will be calculated. Actually only the attributes <code>grid, order</code> and <code>ar.list</code> of <code>a.var</code> are needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is being called in <code>calculate.VAR</code>, so there is no need to call it again after <code>calculate.VAR</code> has been called. Can also be used to calculate the spectral matrix of a VAR model which has been fitted to data, e.g. using function <code>ar</code>. See Brockwell and Davis, 1990, Example 11.8.1, Hannan, 1970, Chapter II, Section 5.iv or Brillinger, 2001, Sections 2.8 and 2.9.
</p>


<h3>Value</h3>

<p>Returns the object of class <code>var</code> after having calculated and set the following attributes:
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>A one dimensional array of length <code>grid</code>, containing the grid-points at which <code>spec</code> has been calculated. </p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>A three dimensional array (<code>grid</code>xkxk), where k is the number of series of the VAR model. Contains for each grid-point the spectral matrix, as calculated at the basis of <code>ar.list</code>. That is, <code>spec[j,1,1]</code> is the spectrum of series 1 at grid-point j, <code>spec[j,1,2]</code> is the cross-spectrum between series 1 and 2 at grid-point j, etc.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Brillinger, D.R. (2001). Time Series: Data Analysis and Theory, second ed. Classics in Applied Mathematics, vol. 36. SIAM, Philadelphia.
</p>
<p>Brockwell, P. J., Davis, R. A. (1990). Time Series: Theory and Methods, second ed. Springer, New York.
</p>
<p>Hannan, E. J. (1970). Multiple Time Series. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>,<code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>, <code><a href="#topic+simulate.VAR">simulate.VAR</a></code>,
</p>
<p><code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.det.cross",
          suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)
my.sample &lt;-simulate.VAR(a.var=my.var, sample.size=250, burn.in = 500)
est.var&lt;-list()
est.var$ar.outp &lt;- ar(x=my.sample, aic=FALSE, order.max=6, demean=FALSE, method="ols", 
		series=c("ser1","ser2"))
est.var$label &lt;-"MY VAR(6)"
est.var$order&lt;-dim(est.var$ar.outp$ar)[1]
est.var$ar.list$ar &lt;- est.var$ar.outp$ar
est.var$ar.list$var.pred &lt;- est.var$ar.outp$var.pred
est.var$grid &lt;- 501 
est.var &lt;- calc.VAR.spec.from.coefs(est.var)
plot_VAR.spectra(a.var=est.var,both=FALSE)


</code></pre>

<hr>
<h2 id='calculate.VAR'>
Attempts to define a bivariate VAR (Vector autoregression) model.
</h2><span id='topic+calculate.VAR'></span>

<h3>Description</h3>

<p>Attempts to find a VAR model which is compatible with the polynomials specified in its attribute <code>inv.roots</code>, makes necessary adjustments, calculates its spectra, coefficients and order, makes the necessary checks and plots the spectra. Finding a VAR model involves finding complex polynomials <code class="reqn">det(z), cross(z), chi.1(z)</code> and <code class="reqn">chi.2(z)</code>, satisfying 
EQ(*): </p>
<p style="text-align: center;"><code class="reqn">|det(z)|^2+|cross(z)|^2 = |chi.1(z)|^2 |chi.2(z)|^2</code>
</p>
<p> on <code class="reqn">z|=1</code>. If <code>calculate.VAR</code> is successful in finding such polynomials, there exists a bivariate VAR(p) model with marginal spectra </p>
<p style="text-align: center;"><code class="reqn">f.i (w) = (1/2\pi)* |chi.i(z)|^2 /|det(z)|^2,</code>
</p>
<p> and cross-spectrum </p>
<p style="text-align: center;"><code class="reqn">f.1.2 (w) = (1/2\pi)* z^{(-p)}*cross(z) /|det(z)|^2,</code>
</p>
<p> where <code class="reqn">z=exp(-iw)</code>. The squared Coherency is then given by </p>
<p style="text-align: center;"><code class="reqn">|cross(z)|^2 /(|det(z)|^2+|cross(z)|^2).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calculate.VAR(a.var, calc.method = "from.det.cross", M.fact = 1.1, 
              plot.spectra = TRUE,suppr.spec.check.warn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.VAR_+3A_a.var">a.var</code></td>
<td>

<p>An object of class <code>var</code>, previously initialized by <code>Init.var</code>.
</p>
</td></tr>
<tr><td><code id="calculate.VAR_+3A_calc.method">calc.method</code></td>
<td>

<p>One of 'from.det.cross' or 'from.eta.ksi.zeta'. See details for further explanations.
</p>
</td></tr>
<tr><td><code id="calculate.VAR_+3A_m.fact">M.fact</code></td>
<td>

<p>Numeric. A factor &gt;1, by which the <code class="reqn">min (|ksi.c(z) /[eta.1(z)eta.2(z)zeta(z)]|^2 )</code> is multiplied, in order to ensure that <code class="reqn">|chi.1(z)*chi.2(z)|^2 - |det(z)|^2</code> is positive on <code class="reqn">|z|=1</code>. Only relevant when <code>calc.method</code> = 'from.eta.ksi.zeta'. Affects the range of values of the Coherency spectrum.
</p>
</td></tr>
<tr><td><code id="calculate.VAR_+3A_plot.spectra">plot.spectra</code></td>
<td>

<p>Logical. If TRUE, the marginal spectra, Coherency and Phase spectra will be plotted.
</p>
</td></tr>
<tr><td><code id="calculate.VAR_+3A_suppr.spec.check.warn">suppr.spec.check.warn</code></td>
<td>

<p>Logical. If TRUE, warnings on whether spectra obtained directly from <code class="reqn">cross, det, chi.1</code> and <code class="reqn">chi.2</code>  (in <code>spec.1, spec.2, Coher, Phase</code>) differ by more than <code>eps.for.spectra</code> from the spectra (in <code>spec</code>) obtained from the coefficients of the VAR model (see <code>Note</code>, below)  are suppressed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to define a VAR model, one seeks to define <code class="reqn">det(z), cross(z)</code> and <code class="reqn">chi.1(z), chi.2(z)</code>, such that EQ(*) holds. There are two ways implemented for doing so, which are specified by argument <code>calc.method</code>:
</p>

<ul>
<li> <p><code>calc.method</code> = 'from.det.cross'. (See Ioannidis (2007), Proposition 2). One must first specify the roots for <code class="reqn">det(z)</code> and <code class="reqn">cross(z)</code>. They fix these two polynomials, which will not be modified during the calculation. One may also specify some roots for <code class="reqn">chi.1(z)</code> and <code class="reqn">chi.2(z)</code>. If these two latter are compatible with EQ(*) they will be kept. If not, they may be modified during the calculation. Further roots may be added by <code>compute.VAR</code> during the calculation to <code class="reqn">chi.2</code> to ensure that EQ(*) holds. All changes are recorded in attribute <code>inv.roots</code>.  If the user wishes some of the roots of <code class="reqn">chi.2</code> to be rather added to <code class="reqn">chi.1</code>, he may do so by editing attribute <code>inv.roots</code> after running the function once, by increasing the multiplicity of the root for <code class="reqn">chi.1</code> and decreasing it by the same amount for <code class="reqn">chi.2</code>, and then, re-running the function. With the option <code>calc.method</code> = 'from.det.cross' one has more direct control over peaks for the marginal spectra (via <code class="reqn">chi.i</code> and <code class="reqn">det</code>) and the Coherency being close to 0 or 1 (via <code class="reqn">det</code> and <code class="reqn">cross</code>), as well as the Phase spectrum, i.e., the lag-/lead- structure between the two series (via <code class="reqn">cross</code>). 
</p>
</li>
<li> <p><code>calc.method</code> = 'from.eta.ksi.zeta'. (See Ioannidis (2007), Proposition 1). One must specify the roots of <code class="reqn">eta.1, eta.2, ksi.1, ksi.2</code> and <code class="reqn">zeta</code>. These fix </p>
<p style="text-align: center;"><code class="reqn">chi.i(z) = M* eta.i(z) zeta(z) ksi.j(z)/ksi.c(z))</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">det(z)=M *zeta(z) ksi.1(z) ksi.2(z)/ksi.c(z),</code>
</p>
<p> where <code class="reqn">M</code> equals <code>M.fact</code>*<code class="reqn">min (|ksi.c(z) /[eta.1(z) eta.2(z) zeta(z)]|^2 )</code> and <code class="reqn">ksi.c</code> is the maximal common divisor of <code class="reqn">ksi.1(z)</code> and <code class="reqn">ksi.2(z)</code>. Then, <code class="reqn">cross(z)</code> is automatically determined so as that EQ(*) is satisfied. The result is that marginal spectra are given by </p>
<p style="text-align: center;"><code class="reqn">f.i (w) = |eta.i(z)|^2 /|ksi.i(z)|^2</code>
</p>
<p> and the squared Coherency is given by </p>
<p style="text-align: center;"><code class="reqn">1-|ksi.c(z)|^2 /|M* eta.1(z) eta.2(z) zeta(z)|^2.</code>
</p>
<p> With the option <code>calc.method</code> = 'from.eta.ksi.zeta' one has more direct control over peaks (via <code class="reqn">ksi</code>) and zeroes (via <code class="reqn">eta</code>) of the marginal spectra and, partially, over the Coherency (via <code class="reqn">ksi.c, eta</code> and <code class="reqn">zeta</code>), but not of the Phase spectrum. However, for certain aspects of the Coherency, a more direct control over the relation of <code class="reqn">cross</code> and <code class="reqn">det</code> would be required, which is not available with this option. For example, with this option, it is not possible to set the multiplicity of a root to be higher for <code class="reqn">cross</code> than for <code class="reqn">det</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class var, basically a list including elements:
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>The number of equidistant gridpoints in <code class="reqn">[0,\pi]</code>, used for plotting and numerical approximations.</p>
</td></tr>
<tr><td><code>p.max.init</code></td>
<td>
<p>An initial limitation on the order of the VAR model.</p>
</td></tr>
<tr><td><code>inv.roots</code></td>
<td>
<p>A <code>data.frame</code> containing the roots of certain polynomials, used to specify the VAR model.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>An integer specifying the maximal number of iterations for the Innovations algorithm.</p>
</td></tr>
<tr><td><code>eps.max.for.UIA</code></td>
<td>
<p>Numeric close to 0. Specifies the threshold for the relative increase in precision achieved at a step of the Innovations algorithm, for accepting that the algorithm has converged.</p>
</td></tr>
<tr><td><code>eps.for.roots</code></td>
<td>
<p>Numeric close to 0. A threshold for considering two roots as identical, if a) the inverses of their radii and b) their angles (in their polar representation) differ by less than this threshold.</p>
</td></tr>
<tr><td><code>eps.for.spectra</code></td>
<td>

<p>Numeric close to 0. A threshold for checking the validity of the calculation of the VAR model. It's spectra are calculated on the basis of the polynomials used to specify the VAR model in <code>inv.roots.def</code> should coincide with the spectra calculated on the basis of the VAR model's coefficients. If they differ by more than <code>a.eps.for.spectra</code> warning messages will be written out to the console.</p>
</td></tr>
<tr><td><code>validity.msg</code></td>
<td>
<p>A message containing more precise information on a) the convergence of the Innovations Algorithm and b) on the maximal difference between the spectra of the VAR model as calculated on the basis of the polynomials used to specify it and the spectra obtained on the basis of the VAR model's coefficients. The message should be printed after each call to <code>calculate.var</code>.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>(Integer) The final order of the VAR model.</p>
</td></tr>
<tr><td><code>ar.list</code></td>
<td>
<p>A list with entries (calculated solving the Yule-Walker equations): 
</p>

<ul>
<li> <p><code>order</code> (Integer) The final order of the VAR model. 
</p>
</li>
<li>	<p><code>ar</code> A three dimensional array (orderx2x2), containing the coefficients of the VAR model. 
</p>
</li>
<li>	<p><code>var.pred</code> A 2x2 matrix containing the covariance matrix of the innovations.</p>
</li></ul>

</td></tr>
<tr><td><code>cov.1</code>, <code>cov.2</code>, <code>cov.cross</code>, <code>cov.cross.neg</code></td>
<td>
<p>Three one dimensional arrays of length <code>order</code>+1 containing the auto- and the cross- covariances (for lags and leads respectively) of the two series for lags=0,...,<code>order</code>. They are being calculated as Dirichlet-approximations to the Fourier transforms of the spectra, which have been calculated from <code class="reqn">det, cross, chi.1</code> and <code class="reqn">chi.2</code>.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>A one dimensional array of length <code>grid</code>. It contains the grid-points at which spectra are being calculated.</p>
</td></tr> 
<tr><td><code>spec</code></td>
<td>
<p>A three dimensional array (<code>grid</code>x2x2). Contains for each grid-point the spectral matrix, as calculated <b>at the basis of the VAR model's coefficients</b>, given in attribute <code>ar.list</code>. That is, <code>spec</code>[j,1,1] is the spectrum of series 1 at grid-point j, <code>spec</code>[j,1,2] is the cross-spectrum between the series 1 and 2 at grid-point j, etc.</p>
</td></tr>
<tr><td><code>spec.1</code>, <code>spec.2</code></td>
<td>
<p>Two one dimensional arrays of length <code>grid</code> containing the <b>log</b> of the values of the spectra of series 1 and 2, respectively, <b>as calculated from <code class="reqn">chi, det</code></b>, i.e.  <code class="reqn">\code{spec.1}[j]=log[(1/2\pi)  |chi.i(z)|^2 /|det(z)|^2]</code>, where <code class="reqn">z=exp(-ij\pi/(\code{grid}-1))</code>.</p>
</td></tr>
<tr><td><code>Coher</code></td>
<td>
<p>A one dimensional array of length <code>grid</code> containing the values of the log of the squared Coherency spectrum between series 1 and 2, <b>as calculated from <code class="reqn">cross, det</code></b>, i.e.  <code class="reqn">\code{Coher}[j] = log(|cross(z)|^2 /(|det(z)|^2+|cross(z)|^2])</code>, <code class="reqn">z=exp(-ij\pi/(\code{grid}-1))</code>.</p>
</td></tr>
<tr><td><code>Phase</code></td>
<td>
<p>A one dimensional array of length <code>grid</code> containing the values of the Phase spectrum between series 1 and 2, <b>as calculated from <code class="reqn">cross</code></b>, i.e., <code class="reqn">\code{Phase} (w) = arg[ z^{(-p)}*cross(z)]</code> , where <code class="reqn">z=exp(-ij\pi/(\code{grid}-1))</code>.</p>
</td></tr>
<tr><td><code>Phase.div.freq</code>, <code>group.delay</code></td>
<td>
<p>Two one dimensional arrays of length <code>grid</code> containing the values of <code>Phase</code>(w)/w, which gives the lead/lag in units of time, and the derivative of <code>Phase</code>(w) with respect to w, respectively.</p>
</td></tr>
<tr><td><code>det</code>, <code>cross</code>, <code>chi.1</code>, <code>chi.2</code>, <code>ksi.1</code>, <code>ksi.2</code>, <code>eta.1</code>, <code>eta.2</code>, <code>zeta</code></td>
<td>
<p>Contain detailed information on the respective polynomials (the last five only if <code>calc.method</code> = 'from.eta.ksi.zeta' was used), as modified during the calculation, each one with attributes:
</p>

<ul>
<li> <p><code>const</code> the constant of the polynomial;
</p>
</li>
<li> <p><code>inv.roots</code> the modulus and angle for the inverses of the roots of the polynomial (for conjugate pairs only the one with angle in <code class="reqn">[0,\pi]</code>);
</p>
</li>
<li>	<p><code>inv.roots.number</code>, the number of the roots of the polynomial (pairs of complex roots are counted only once);
</p>
</li>
<li>	<p><code>order</code>, the degree of the polynomial;
</p>
</li>
<li>	<p><code>coefs</code>, an array of length <code class="reqn">2( \code{inv.roots.number} +1)</code> containing the coefficients of the polynomial;
</p>
</li>
<li>	<p><code>fourier.coefs</code>, an array of length <code class="reqn">2\code{pmax.init}+1</code> containing the Fourier transform of the <code class="reqn">|polynomial(z)|^2</code> on <code class="reqn">|z|=1</code>;
</p>
</li>
<li>	<p><code>values$spec</code>, an array of length <code>grid</code>, containing the values of the squared modulus of the polynomial, i.e. <code class="reqn">|polynomial(z)|^2</code> on <code class="reqn">|z|=1</code>;
</p>
</li>
<li> <p><code>Inv.values$spec</code>, an array of length <code>grid</code>, containing the <b>log of the inverses</b> of the values of the squared modulus of the polynomial, i.e. <code class="reqn">-log [ |polynomial(z)|^2 ]</code> on <code class="reqn">|z|=1</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Note</h3>

<p><code>calculate.VAR</code> performs a check on the validity of the output and stores relevant information in attribute <code>validity.msg</code>. There are certain reasons for which the output may  not be valid: First, the calculation involves numerical approximations; the relevant algorithms may have not achieved convergence to the desired precision. Second, there may be features in the spectra, which cannot be well represented by a VAR model, resulting in polynomials <code class="reqn">cross, det, chi.1</code> and <code class="reqn">chi.2</code> not satisfying EQ(*). Thus, it is imperative to check a) the validity of EQ(*). It is also important to check b) that the spectra obtained directly from <code class="reqn">cross, det, chi.1</code> and <code class="reqn">chi.2</code>  (in <code>spec.1, spec.2, Coher, Phase</code>) coincide with the spectra (in <code>spec</code>) obtained from the coefficients of the VAR model (in <code>ar.list</code>). The checks performed by <code>calculate.VAR</code> concern exactly the checks under a) and b): the maximum absolute difference between the relevant quantities (in log scale, where appropriate) is passed in <code>validity.msg</code>. Moreover, warnings are written out to the console if the Innovations algorithm did not converge or if any of the quantities in 'b' exceeds <code>eps.for.spectra</code>, provided that <code>suppr.spec.check.warn</code>=FALSE. The same check is conducted visually if <code>plot.spectra</code>=TRUE: each spectrum is calculated and plotted according to both methods. The two should coincide.
</p>
<p>The option <code>method</code>='from.det.cross' seems generally numerically more stable than the option
</p>
<p><code>method</code>='from.eta.ksi.zeta'.
</p>
<p><b>Suggestions on how to obtain desired spectral characteristics:</b>
</p>
<p>Let <code class="reqn">z_0:= r_0^{-1}exp(iw_0)</code>, with <code class="reqn">r_0</code> close to 1. 
For a polynomial <code class="reqn">p(z)</code> denote by <code class="reqn">[p(z_0)]</code> the multiplicity of <code class="reqn">z_0</code> as root of <code class="reqn">p(z)</code>.
</p>
<p>To obtain
</p>

<ul>
<li><p> a peak in <code class="reqn">f.1(w_0)</code>
</p>

<ul>
<li><p> with <code>method</code>='from.det.cross': choose <code class="reqn">[det(z_0)] &gt; [chi.1(z_0)]</code>.
</p>
</li>
<li><p> with <code>method</code>='from.eta.ksi.zeta': choose <code class="reqn">[ksi.1(z_0)] &gt; [eta.1(z_0)]</code>.
</p>
</li></ul>

</li>
<li><p> a trough in <code class="reqn">f.1(w_0)</code>
</p>

<ul>
<li><p> with <code>method</code>='from.eta.ksi.zeta': choose <code class="reqn">[ksi.1(z_0)] &lt; [eta.1(z_0)]</code>.
</p>
</li></ul>

</li>
<li><p> a <code class="reqn">Coh(w_0)</code> close to 1
</p>

<ul>
<li><p> with <code>method</code>='from.det.cross': choose <code class="reqn">[det(z_0)] &gt; [cross(z_0)]</code>.
</p>
</li>
<li><p> with <code>method</code>='from.eta.ksi.zeta': choose <code class="reqn">min([ksi.1(z_0)],[ksi.2(z_0)]) &gt; [eta.1(z_0)]+[eta.2(z_0)]+[zeta(z_0)]</code>.
</p>
</li></ul>

</li>
<li><p> a <code class="reqn">Coh(w_0)</code> close to 0
</p>

<ul>
<li><p> with <code>method</code>='from.det.cross': choose <code class="reqn">[det(z_0)] &lt; [cross(z_0)]</code>.
</p>
</li>
<li><p> with <code>method</code>='from.eta.ksi.zeta': choose <code class="reqn">min([ksi.1(z_0)],[ksi.2(z_0)]) &lt; [eta.1(z_0)]+[eta.2(z_0)]+[zeta(z_0)]</code>.
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Ioannidis, E. E. (2007). Spectra of bivariate VAR(p) models. Journal of Statistical Planning and Inference 137(2), 554-566. 
</p>
<p>Ioannidis, E. E. and Chronis, G. A. (2005). Extreme spectra of VAR models and orders of near-cointegration. J. Time Ser. Anal. 26, 399-421.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>,<code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+simulate.VAR">simulate.VAR</a></code>,
</p>
<p><code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>,
</p>
<p><code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR (a.var = my.var, calc.method="from.det.cross", 
          plot.spectra=TRUE,suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)

</code></pre>

<hr>
<h2 id='Init.var'>Initializes an object of class <code>var</code>
</h2><span id='topic+Init.var'></span>

<h3>Description</h3>

<p>Initializes an object of class <code>var</code>, representing a VAR (Vector autoregression) model, sets some of its parameters and reads  the specification of certain polynomials which determine the VAR model from a <code>data.frame</code> or from a tab-delimited text file (, which is converted to a <code>data.frame</code>). In this <code>data.frame</code> each polynomial is specified via it's (complex) roots and constant. If no such text file or <code>data.frame</code> is specified, an appropriate default <code>data.frame</code> is created, which can then be modified by the user. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Init.var(grid = 1001, order.max.init = 10, inv.roots.def = NULL,
              a.niter = 5000, a.eps.max.for.UIA = 1e-10, 
              a.eps.for.roots = 1e-05,a.eps.for.spectra=1E-4)
              </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Init.var_+3A_grid">grid</code></td>
<td>

<p>An integer specifying the number of equidistant gridpoints in <code class="reqn">[0,\pi]</code> used for plotting and numerical approximations. They are given by <code class="reqn">j\pi /((grid-1)), j=0,...,grid</code>.
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_order.max.init">order.max.init</code></td>
<td>

<p>An integer providing an initial limitation on the order of the VAR model. The degrees of the polynomials specified in the <code>inv.roots.def</code> should not exceed 2*<code>order.max.init</code> and the lines of the <code>inv.roots.def</code> should be at least equal to 6*<code>order.max.init</code>+2 (if this not the case, appropriate lines will be automatically added). 
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_inv.roots.def">inv.roots.def</code></td>
<td>

<p>Either NULL or a <code>data.frame</code> or a tab-delimited text file (, which is converted to a <code>data.frame</code>). This <code>data.frame</code> contains the roots (rows) of the polynomials (columns) used to specify the VAR model. See <code>Details</code> for the specific structure of the text file. If set to NULL, a <code>data.frame</code> of the appropriate structure will be created, which contains no roots, and corresponds, thus, to a bivariate white noise series. The <code>data.frame</code> in any of the above cases may be modified after the call of <code>init.var</code>, via e.g.  <code>var.name$inv.roots &lt;- edit(var.name$inv.roots)</code>.
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_a.niter">a.niter</code></td>
<td>

<p>An integer specifying the maximal number of iterations for the Innovations algorithm.
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_a.eps.max.for.uia">a.eps.max.for.UIA</code></td>
<td>

<p>Numeric close to 0. Specifies the threshold for the relative increase in precision achieved at a step of the Innovations algorithm, for accepting that the algorithm has converged. 
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_a.eps.for.roots">a.eps.for.roots</code></td>
<td>

<p>Numeric close to 0. A threshold for considering two roots as identical, if a) the inverses of their radii and b) their angles (in their polar representation) differ by less than this threshold.
</p>
</td></tr>
<tr><td><code id="Init.var_+3A_a.eps.for.spectra">a.eps.for.spectra</code></td>
<td>

<p>Numeric close to 0. A threshold for checking the validity of the calculation of the VAR model. It's spectra are calculated on the basis of the polynomials used to specify the VAR model in <code>inv.roots.def</code> should coincide with the spectra calculated on the basis of the VAR model's coefficients. If they differ by more than <code>a.eps.for.spectra</code> warning messages will be written out to the console.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The text file [/ <code>data.frame</code>] passed in argument <code>inv.roots.def</code> should have a specific structure:
</p>

<ul>
<li><p> The first row of the file (headers) [/ names of columns of the <code>data.frame</code>] should be 'radius angle det cross chi.1 chi.2 chi.1.prod.2 ma.1 ma.2 eta.1 eta.2 ksi.1 ksi.2 ksi.c zeta'.
</p>
</li>
<li><p> The second row of the file [/ first row-'observation' in the data.frame] contains the constants of the polynomials, usually set initially to 1, while the first two entries, corresponding to columns radius and angle, are set to '#NA' [/ 'NA'].
</p>
</li>
<li><p> Subsequent rows, containing each one the specification of a root and the multiplicity of this root for each relevant polynomial, should have the following entries: The first entry is the inverse of its modulus (radius). For all polynomials, except for <code>cross</code>, this should be in <code class="reqn">[0,1)</code>. The second entry is it's argument (angle). This should be a figure in <code class="reqn">[0,\pi]</code>.  Complex conjugates for each non-real root will be automatically added, in order to ensure real coefficients of the polynomials. Subsequent entries in the row are non-negative integers determining the multiplicity of the given root for the polynomial corresponding to the column of the entry. Not all polynomials need to be specified (see parameter <code>calc.method</code> in function <code>calculate.VAR</code>). Non relevant polynomials should have '0' as entry for their multiplicity of the root. 
</p>
</li>
<li><p> Subsequent rows containing no specified roots should have the following structure: the first two entries, corresponding to radius and angle, should equal '#NA' [/ 'NA']. The rest of the row should be filled with '0'. The total number of rows should be at least 6*<code>order.max.init</code>+2 for the file (, including headers) [/ or 6*<code>order.max.init</code>+1 for the <code>data.frame</code>].
</p>
</li></ul>

<p>Two example text files of the appropriate structure, <code>VAR.inv.roots.from.det.cross.txt</code> and <code>VAR.inv.roots.from.eta.ksi.zeta.txt</code> may be found in the <code>extdata</code> folder of the package. A path to them may be obtained via 
</p>
<p><code>fpath&lt;-system.file("extdata","text.file",package="VAR.spec").</code> 
</p>
<p>The corresponding example <code>data.frames</code> are also directly accessible to the user as 
</p>
<p><code>VAR.inv.roots.from.det.cross</code> and <code>VAR.inv.roots.from.eta.ksi.zeta</code>.
</p>


<h3>Value</h3>

<p>An object of class var, basically a list including elements:
</p>
<table>
<tr><td><code>grid</code></td>
<td>
<p>The integer contained in argument <code>grid</code>. The number of equidistant gridpoints in <code class="reqn">[0,\pi]</code>, used for plotting and numerical approximations.</p>
</td></tr>
<tr><td><code>p.max.init</code></td>
<td>
<p>The integer contained in argument <code>order.max.init</code>. An initial limitation on the order of the VAR model.</p>
</td></tr>
<tr><td><code>inv.roots</code></td>
<td>
<p>A <code>data.frame</code> containing the roots of certain polynomials, required to specify the VAR model.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>The integer contained in argument <code>a.niter</code>. An integer specifying the maximal number of iterations for the Innovations algorithm.</p>
</td></tr>
<tr><td><code>eps.max.for.UIA</code></td>
<td>
<p>Numeric close to 0. Specifies the threshold for the relative increase in precision achieved at a step of the Innovations algorithm, for accepting that the algorithm has converged.</p>
</td></tr>
<tr><td><code>eps.for.roots</code></td>
<td>
<p>Numeric close to 0. A threshold for considering two roots as identical, if a) the inverses of their radii and b) their angles (in their polar representation) differ by less than this threshold.</p>
</td></tr>
<tr><td><code>eps.for.spectra</code></td>
<td>

<p>Numeric close to 0. A threshold for checking the validity of the calculation of the VAR model. It's spectra are calculated on the basis of the polynomials used to specify the VAR model in <code>inv.roots.def</code> should coincide with the spectra calculated on the basis of the VAR model's coefficients. If they differ by more than <code>a.eps.for.spectra</code> warning messages will be written out to the console.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>, <code><a href="#topic+simulate.VAR">simulate.VAR</a></code>,
</p>
<p><code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>,
</p>
<p><code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.var &lt;- Init.var(grid=201, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var$inv.roots

</code></pre>

<hr>
<h2 id='plot_VAR.Phase.details'>
Plots details related to the Phase spectrum of a bivariate VAR (Vector autoregression) model.
</h2><span id='topic+plot_VAR.Phase.details'></span>

<h3>Description</h3>

<p>Plots in a 2x2 layout the Phase spectrum of a VAR model for a bivariate series, represented by an object of class <code>var</code>, the Phase spectrum divided by frequency -which gives the lag-/lead-structure between the two series in units of time &ndash;, the derivative of the Phase spectrum with respect to frequency -also known as the group-delay&ndash;, and the Coherency spectrum of the VAR model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_VAR.Phase.details(a.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_VAR.Phase.details_+3A_a.var">a.var</code></td>
<td>

<p>An object of class <code>var</code> obtained from <code>calculate.VAR</code> for which details of the Phase spectrum are to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>,<code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>,
</p>
<p><code><a href="#topic+simulate.VAR">simulate.VAR</a></code>, <code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, 
</p>
<p><code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.det.cross",
                        suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)
plot_VAR.Phase.details (a.var=my.var)

</code></pre>

<hr>
<h2 id='plot_VAR.spectra'>
Plots spectra of a bivariate VAR (Vector autoregression) model.
</h2><span id='topic+plot_VAR.spectra'></span>

<h3>Description</h3>

<p>Plots in a 2x2 layout the marginal spectra, the squared Coherency spectrum and the Phase spectrum of a VAR model, represented by an object of class <code>var</code>. If <code>both</code>=TRUE, each one is calculated (and plotted) in two ways: once directly from <code class="reqn">det, cross, chi.1, chi.2</code>, and once from the coefficients in <code>ar.list</code>. For each quantity the values from the two ways of calculation should coincide, if the calculation of the VAR model undertaken in <code>calculate.VAR</code>  was correct. If <code>both</code>=FALSE,  only the calculation based on the coefficients in attribute <code>ar.list</code> is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_VAR.spectra(a.var, both = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_VAR.spectra_+3A_a.var">a.var</code></td>
<td>

<p>An object of class <code>var</code> for which spectra are to be plotted.
</p>
</td></tr>
<tr><td><code id="plot_VAR.spectra_+3A_both">both</code></td>
<td>

<p>Logical. If TRUE, each quantity will be plotted calculated in two ways: once directly from <code class="reqn">det, cross, chi.1, chi.2</code> and once from the coefficients in <code>ar.list</code>. If FALSE, each quantity will be plotted calculated from the coefficients in <code>ar.list</code> only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>both</code>=TRUE the var should have been obtained from <code>calculate.VAR</code>. If <code>both</code>=FALSE only the attributes <code>grid, freq</code> and <code>spec</code> are required. Thus, it can also be used to plot spectra of a VAR model fitted to a bivariate series, e.g. using function <code>ar</code>, the spectra of which have previously been calculated by a call to <code>calc.VAR.spec.from.coefs</code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>,<code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>,
</p>
<p><code><a href="#topic+simulate.VAR">simulate.VAR</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>,
</p>
<p><code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.det.cross",
          suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)
my.var &lt;- calc.VAR.spec.from.coefs(a.var=my.var)
plot_VAR.spectra(a.var=my.var)

</code></pre>

<hr>
<h2 id='simulate.VAR'>
Simulates a bivariate series from a bivariate VAR (Vector autoregression) model.
</h2><span id='topic+simulate.VAR'></span>

<h3>Description</h3>

<p>Simulates a Gaussian bivariate series from a VAR model, described by an object of class <code>var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate.VAR(a.var, sample.size, burn.in = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.VAR_+3A_a.var">a.var</code></td>
<td>

<p>An object of class <code>var</code>, obtained from <code>calculate.VAR</code>. Actually only the attributes <code>order</code> and <code>ar.list</code> of <code>a.var</code> are needed.
</p>
</td></tr>
<tr><td><code id="simulate.VAR_+3A_sample.size">sample.size</code></td>
<td>

<p>Integer. The size of the bivariate sample to be generated.
</p>
</td></tr>
<tr><td><code id="simulate.VAR_+3A_burn.in">burn.in</code></td>
<td>

<p>Integer. The number of initial observations to be discarded. The bivariate series is simulated by iterating the VAR recursion, starting with white noise (with the covariance structure of the innovations, given in <code>ar.list$var.pred</code> ). This iteration converges to the correct distribution after a <code>burn.in</code> period, provided the roots of <code class="reqn">det</code> are outside the unit circle, i.e. their inverses have a modulus less than 1. The closer roots of <code class="reqn">det</code> are to the unit circle, the longer the <code>burn.in</code> period should be chosen.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array of dimensions <code>sample.size</code>x2, the bivariate sample series simulated from the VAR model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR.spec-package">VAR.spec-package</a></code>, <code><a href="#topic+Init.var">Init.var</a></code>, <code><a href="#topic+calculate.VAR">calculate.VAR</a></code>, 
<code><a href="#topic+plot_VAR.spectra">plot_VAR.spectra</a></code>, <code><a href="#topic+plot_VAR.Phase.details">plot_VAR.Phase.details</a></code>,
<code><a href="#topic+calc.VAR.spec.from.coefs">calc.VAR.spec.from.coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=NULL)
my.var$inv.roots[2,]&lt;- c(0.98,0.017261,2,3,1,1,2, rep(0,8))
my.var$inv.roots[3,]&lt;- c(0.92,0.897598,2,1,1,1,2, rep(0,8))
my.var$inv.roots[4,]&lt;- c(0.98,1.795196,1,1,0,1,1, rep(0,8))
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.det.cross",
                        suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)
my.sample &lt;-simulate.VAR(a.var=my.var, sample.size=250, burn.in = 500)

</code></pre>

<hr>
<h2 id='VAR.inv.roots.from.det.cross'>
An example <code>data.frame</code> defining a VAR (Vector autoregression) model.
</h2><span id='topic+VAR.inv.roots.from.det.cross'></span>

<h3>Description</h3>

<p>An example <code>data.frame</code> to be used for argument <code>inv.roots.def</code> of function <code>Init.var</code>, when subsequently argument <code>method</code> of function <code>calculate.VAR</code> is set to &quot;from.det.cross&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR.inv.roots.from.det.cross
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing 3 roots (rows) and their multiplicities for the polynomials <code class="reqn">det(z), cross(z)</code>, <code class="reqn">chi.1(z)</code> and <code class="reqn">chi.2(z)</code>, as well as their constants in the first row.</p>


<h3>See Also</h3>

<p><code>Init.var</code>, <code>calculate.VAR</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.var &lt;- Init.var(grid=501, order.max.init=10, inv.roots.def=VAR.inv.roots.from.det.cross)
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.det.cross",
                        suppr.spec.check.warn=TRUE)
print(my.var$validity.msg)
</code></pre>

<hr>
<h2 id='VAR.inv.roots.from.eta.ksi.zeta'>
An example <code>data.frame</code> defining a VAR model.
</h2><span id='topic+VAR.inv.roots.from.eta.ksi.zeta'></span>

<h3>Description</h3>

<p>An example <code>data.frame</code> to be used for argument <code>inv.roots.def</code> of function <code>Init.var</code>, when subsequently argument <code>method</code> of function <code>calculate.VAR</code> is set to &quot;from.eta.ksi.zeta&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR.inv.roots.from.eta.ksi.zeta
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing 3 roots (rows) and their multiplicities for the polynomials <code class="reqn">eta.1(z), eta.2(z)</code>, <code class="reqn">ksi.1(z), ksi.2(z)</code> and <code class="reqn">zeta(z)</code>, as well as their constants in the first row.</p>


<h3>See Also</h3>

<p><code>Init.var</code>, <code>calculate.VAR</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.var &lt;- Init.var(grid=501, order.max.init=10, 
                        inv.roots.def=VAR.inv.roots.from.eta.ksi.zeta)
my.var &lt;- calculate.VAR(a.var=my.var,calc.method="from.eta.ksi.zeta")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
