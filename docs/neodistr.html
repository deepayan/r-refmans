<!DOCTYPE html><html lang="en"><head><title>Help for package neodistr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neodistr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bnrm'><p>Neo-normal model using brms</p></a></li>
<li><a href='#brms_custom_family'><p>Neonormal as custom distribution family in brms</p></a></li>
<li><a href='#gmsnburr'><p>GMSNBurr distribution</p></a></li>
<li><a href='#jfst'><p>Jones Faddy's Skew-t Distribution</p></a></li>
<li><a href='#msnburr'><p>MSNBurr Distribution</p></a></li>
<li><a href='#msnburr2a'><p>MSNBurr-IIa distribution.</p></a></li>
<li><a href='#neoshiny'><p>Starts shiny application for the neodistr package</p></a></li>
<li><a href='#stanf_gmsnburr'><p>Stan function of GMSNBurr Distribution</p></a></li>
<li><a href='#stanf_jfst'><p>Stan function of Jones and Faddys Skew-t Distribution</p></a></li>
<li><a href='#stanf_msnburr'><p>Stan function of MSNBurr Distribution</p></a></li>
<li><a href='#stanf_msnburr2a'><p>Stan function of MSNBurr-IIa Distribution</p></a></li>
<li><a href='#summary_dist'><p>Summaries of Neo-normal Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Neo-Normal Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Achmad Syahrul Choir &lt;madsyair@stis.ac.id&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for calculating the 
    density, cumulative distribution, quantile, and random number of 
    neo-normal distribution. It also interfaces with the 'brms' package, 
    allowing the use of the neo-normal distribution as a custom family. 
    This integration enables the application of various 'brms' formulas 
    for neo-normal regression. The package implements the following 
    distributions: Modified to be Stable as Normal from Burr (MSNBurr), Modified to be Stable as Normal from Burr-IIa (MSNBurr-IIa), Generalized of MSNBurr (GMSNBurr), and Jones-Faddy Skew-t. 
    References:
    Choir, A. S. (2020).Unpublished Dissertation.
    Iriawan, N. (2000).Unpublished Dissertation.
    Jones,  M. C. and Faddy,M. J. (2003).&lt;<a href="https://doi.org/10.1111%2F1467-9868.00378">doi:10.1111/1467-9868.00378</a>&gt;.
    Rigby, R. A., Stasinopoulos, M. D., Heller, G. Z., &amp; Bastiani, F. D. (2019) &lt;<a href="https://doi.org/10.1201%2F9780429298547">doi:10.1201/9780429298547</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0),shinythemes,plotly,brms</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan , stats,Rmpfr,ggplot2,shiny</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra,knitr, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/madsyair/neodistr">https://github.com/madsyair/neodistr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/madsyair/neodistr/issues">https://github.com/madsyair/neodistr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-25 12:34:26 UTC; madsyair</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Achmad Syahrul Choir
    <a href="https://orcid.org/0000-0001-7088-0646"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Anisa' Faoziah [aut],
  Nur Iriawan <a href="https://orcid.org/0000-0003-2833-6115"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-26 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bnrm'>Neo-normal model using brms</h2><span id='topic+bnrm'></span>

<h3>Description</h3>

<p>Neo-normal model using brms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnrm(
  formula,
  data,
  family = msnburr(),
  prior = NULL,
  data2 = NULL,
  sample_prior = "no",
  knots = NULL,
  drop_unused_levels = TRUE,
  stanvars = NULL,
  fit = NA,
  save_pars = getOption("brms.save_pars", NULL),
  init = NULL,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  cores = getOption("mc.cores", 1),
  threads = getOption("brms.threads", NULL),
  opencl = getOption("brms.opencl", NULL),
  normalize = getOption("brms.normalize", TRUE),
  control = list(adapt_delta = 0.9),
  algorithm = getOption("brms.algorithm", "sampling"),
  backend = getOption("brms.backend", "rstan"),
  future = getOption("future", FALSE),
  silent = 1,
  seed = NA,
  save_model = NULL,
  stan_model_args = list(),
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("brms.file_refit", "never"),
  empty = FALSE,
  rename = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bnrm_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="brms.html#topic+brmsformula">brmsformula</a></code>, or <code><a href="brms.html#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="brms.html#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_family">family</code></td>
<td>
<p>the neo-normal distribution as response in  regression:msnburr(),msnburr2a(),gmsnburr(),jfst()
default argument in family is vectorize=TRUE. if not vectorize, give argument vectorize=FALSE, example:msnburr(vectorize=FALSE)</p>
</td></tr>
<tr><td><code id="bnrm_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="brms.html#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="brms.html#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="brms.html#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="brms.html#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="brms.html#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_stanvars">stanvars</code></td>
<td>
<p>An optional <code>stanvars</code> object generated by function
<code><a href="brms.html#topic+stanvar">stanvar</a></code> to define additional variables for use in
<span class="pkg">Stan</span>'s program blocks.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_fit">fit</code></td>
<td>
<p>An instance of S3 class <code>brmsfit</code> derived from a previous
fit; defaults to <code>NA</code>. If <code>fit</code> is of class <code>brmsfit</code>, the
compiled model associated with the fitted result is re-used and all
arguments modifying the model code or data are ignored. It is not
recommended to use this argument directly, but to call the
<code><a href="brms.html#topic+update.brmsfit">update</a></code> method, instead.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_save_pars">save_pars</code></td>
<td>
<p>An object generated by <code><a href="brms.html#topic+save_pars">save_pars</a></code> controlling
which parameters should be saved in the model. The argument has no
impact on the model fitting itself.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_init">init</code></td>
<td>
<p>Initial values for the sampler. If <code>NULL</code> (the default) or
<code>"random"</code>, Stan will randomly generate initial values for parameters
in a reasonable range. If <code>0</code>, all parameters are initialized to zero
on the unconstrained space. This option is sometimes useful for certain
families, as it happens that default random initial values cause draws to
be essentially constant. Generally, setting <code>init = 0</code> is worth a try,
if chains do not initialize or behave well. Alternatively, <code>init</code> can
be a list of lists containing the initial values, or a function (or
function name) generating initial values. The latter options are mainly
implemented for internal testing but are available to users if necessary.
If specifying initial values using a list or a function then currently the
parameter names must correspond to the names used in the generated Stan
code (not the names used in <span class="rlang"><b>R</b></span>). For more details on specifying initial
values you can consult the documentation of the selected <code>backend</code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains (defaults to 4).</p>
</td></tr>
<tr><td><code id="bnrm_+3A_iter">iter</code></td>
<td>
<p>Number of total iterations per chain (including warmup; defaults
to 2000).</p>
</td></tr>
<tr><td><code id="bnrm_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying number of warmup (aka burnin)
iterations. This also specifies the number of iterations used for stepsize
adaptation, so warmup draws should not be used for inference. The number
of warmup should not be larger than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_thin">thin</code></td>
<td>
<p>Thinning rate. Must be a positive integer. Set <code>thin &gt; 1</code> to
save memory and computation time if <code>iter</code> is large.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
which defaults to 1 but we recommend setting the <code>mc.cores</code> option to
be as many processors as the hardware and RAM allow (up to the number of
chains). For non-Windows OS in non-interactive <span class="rlang"><b>R</b></span> sessions, forking is used
instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in within-chain parallelization. For
more control over the threading process, <code>threads</code> may also be a
<code>brmsthreads</code> object created by <code><a href="brms.html#topic+threading">threading</a></code>. Within-chain
parallelization is experimental! We recommend its use only if you are
experienced with Stan's <code>reduce_sum</code> function and have a slow running
model that cannot be sped up by any other means. Can be set globally for
the current <span class="rlang"><b>R</b></span> session via the <code>"brms.threads"</code> option.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_opencl">opencl</code></td>
<td>
<p>The platform and device IDs of the OpenCL device to use for
fitting using GPU support. If you don't know the IDs of your OpenCL device,
<code>c(0,0)</code> is most likely what you need. For more details, see
<code><a href="brms.html#topic+opencl">opencl</a></code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via
the <code>"brms.opencl"</code> option</p>
</td></tr>
<tr><td><code id="bnrm_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Indicates whether normalization constants should
be included in the Stan code (defaults to <code>TRUE</code>). Setting it
to <code>FALSE</code> requires Stan version &gt;= 2.25 to work. If <code>FALSE</code>,
sampling efficiency may be increased but some post processing functions
such as <code><a href="brms.html#topic+bridge_sampler">bridge_sampler</a></code> will not be available. Can be
controlled globally for the current <span class="rlang"><b>R</b></span> session via the 'brms.normalize'
option.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
The most important control parameters are discussed in the 'Details'
section below. For a comprehensive overview see
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with independent normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, or <code>"fixed_param"</code> for sampling from fixed parameter
values. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option .</p>
</td></tr>
<tr><td><code id="bnrm_+3A_backend">backend</code></td>
<td>
<p>Character string naming the package to use as the backend for
fitting the Stan model. Options are <code>"rstan"</code> (the default) or
<code>"cmdstanr"</code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.backend"</code> option . Details on the
<span class="pkg">rstan</span> and <span class="pkg">cmdstanr</span> packages are available at
<a href="https://mc-stan.org/rstan/">https://mc-stan.org/rstan/</a> and <a href="https://mc-stan.org/cmdstanr/">https://mc-stan.org/cmdstanr/</a>,
respectively. Additionally a <code>"mock"</code> backend is available to make
testing <span class="pkg">brms</span> and packages that depend on it easier.
The <code>"mock"</code> backend does not actually do any fitting, it only checks
the generated Stan code for correctness and then returns whatever is passed
in an additional <code>mock_fit</code> argument as the result of the fit.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_future">future</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the <span class="pkg"><a href="future.html#topic+future">future</a></span>
package is used for parallel execution of the chains and argument
<code>cores</code> will be ignored. Can be set globally for the current <span class="rlang"><b>R</b></span>
session via the <code>"future"</code> option. The execution type is controlled via
<code><a href="future.html#topic+plan">plan</a></code> (see the examples section below).</p>
</td></tr>
<tr><td><code id="bnrm_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>.
If <code>1</code> (the default), most of the
informational messages of compiler and sampler are suppressed.
If <code>2</code>, even more messages are suppressed. The actual
sampling progress is still printed. Set <code>refresh = 0</code> to turn this off
as well. If using <code>backend = "rstan"</code> you can also set
<code>open_progress = FALSE</code> to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation to make results
reproducible. If <code>NA</code> (the default), <span class="pkg">Stan</span> will set the seed
randomly.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_save_model">save_model</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter
case, the model's Stan code is saved via <code><a href="base.html#topic+cat">cat</a></code> in a text file
named after the string supplied in <code>save_model</code>.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_stan_model_args">stan_model_args</code></td>
<td>
<p>A <code>list</code> of further arguments passed to
<code><a href="rstan.html#topic+stan_model">rstan::stan_model</a></code> for <code>backend =
"rstan"</code> or to <code>cmdstanr::cmdstan_model</code> for <code>backend =
"cmdstanr"</code>, which allows to change how models are compiled.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object is saved via <code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named
after the string supplied in <code>file</code>. The <code>.rds</code> extension is
added automatically. If the file already exists, <code>brm</code> will load and
return the saved model object instead of refitting the model.
Unless you specify the <code>file_refit</code> argument as well, the existing
files won't be overwritten, you have to manually remove the file in order
to refit and save the model under an existing file name. The file name
is stored in the <code>brmsfit</code> object for later usage.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. If the
<code>file</code> argument is provided, this compression will be used when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_file_refit">file_refit</code></td>
<td>
<p>Modifies when the fit stored via the <code>file</code> argument
is re-used. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.file_refit"</code> option .
For <code>"never"</code> (default) the fit is always loaded if it
exists and fitting is skipped. For <code>"always"</code> the model is always
refitted. If set to <code>"on_change"</code>, brms will
refit the model if model, data or algorithm as passed to Stan differ from
what is stored in the file. This also covers changes in priors,
<code>sample_prior</code>, <code>stanvars</code>, covariance structure, etc. If you
believe there was a false positive, you can use
<code><a href="brms.html#topic+brmsfit_needs_refit">brmsfit_needs_refit</a></code> to see why refit is deemed necessary.
Refit will not be triggered for changes in additional parameters of the fit
(e.g., initial values, number of iterations, control arguments, ...). A
known limitation is that a refit will be triggered if within-chain
parallelization is switched on/off.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_empty">empty</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Stan model is not created
and compiled and the corresponding <code>'fit'</code> slot of the <code>brmsfit</code>
object will be empty. This is useful if you have estimated a brms-created
Stan model outside of <span class="pkg">brms</span> and want to feed it back into the package.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_rename">rename</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code id="bnrm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to Stan.
For <code>backend = "rstan"</code> the arguments are passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+vb">vb</a></code>.
For <code>backend = "cmdstanr"</code> the arguments are passed to the
<code>cmdstanr::sample</code> or <code>cmdstanr::variational</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a neo-normal model that using brm function in brms package.All arguments in this functions follow arguments of brm function, except family
</p>


<h3>Value</h3>

<p>An object of class <code>brmsfit</code>, which contains the posterior
draws along with many other useful information about the model. Use
<code>methods(class = "brmsfit")</code> for an overview on available methods.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir
</p>


<h3>References</h3>

<p>Buerkner,P-C (2017). brms: An R Package for Bayesian Multilevel
Models Using Stan. <em>Journal of Statistical Software</em>, 80(1), 1-28.
<code>doi:10.18637/jss.v080.i01</code>
</p>
<p>Choir, A. S. (2020). The New Neo-Normal Distributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>
<p>Iriawan, N. (2000). Computationally Intensive Approaches to Inference in Neo-Normal Linear Models. Curtin University of Technology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(neodistr)
  x&lt;-runif(100)
  e&lt;-rmsnburr(100,0,1,0.8)
  y&lt;-0.5+0.8*x+e
  data&lt;-data.frame(y,x)
  fit &lt;- bnrm(
    y ~ x, data = data,
    family = msnburr())
  summary(fit)
  pp &lt;- posterior_predict(fit)
  ppe &lt;- posterior_epred(fit)
  loo(fit)
  
</code></pre>

<hr>
<h2 id='brms_custom_family'>Neonormal as custom distribution family in brms</h2><span id='topic+brms_custom_family'></span>

<h3>Description</h3>

<p>Neonormal as custom distribution family in brms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brms_custom_family(family = "msnburr", vectorize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brms_custom_family_+3A_family">family</code></td>
<td>
<p>distribution neo-normal option: &quot;msnburr&quot;, &quot;msnburr2a&quot;, &quot;gmsnburr&quot;, and &quot;jfst&quot;</p>
</td></tr>
<tr><td><code id="brms_custom_family_+3A_vectorize">vectorize</code></td>
<td>
<p>logical; if TRUE,  Stan code of family distribution is vectorize 
The default value of this parameter is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>custom_family is an object of class custom family of brms and stanvars_family is stanvars object (the Stan code of function of neo-normal distributions (lpdf,cdf,lcdf,lccdf,quantile and rng))
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(brms)
  library(neodistr)
  x&lt;-runif(100)
  e&lt;-rmsnburr(100,0,1,0.8)
  y&lt;-0.5+0.8*x+e
  data&lt;-data.frame(y,x)
  msnburr&lt;-brms_custom_family("msnburr")
  fit &lt;- brm(
    y ~ x, data = data,
    family = msnburr$custom_family, stanvars = msnburr$stanvars_family,
    prior=c(set_prior("cauchy(0,5)",class="alpha"),set_prior("cauchy(0,1)",class="sigma"))
  )
  summary(fit)
  pp &lt;- posterior_predict(fit)
  ppe &lt;- posterior_epred(fit)
  loo(fit)
  
</code></pre>

<hr>
<h2 id='gmsnburr'>GMSNBurr distribution</h2><span id='topic+gmsnburr'></span><span id='topic+dgmsnburr'></span><span id='topic+pgmsnburr'></span><span id='topic+qgmsnburr'></span><span id='topic+rgmsnburr'></span>

<h3>Description</h3>

<p>To calculate density function, distribution funcion, quantile function, and  build data from random generator function 
for the GMSNBurr Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgmsnburr(x, mu = 0, sigma = 1, alpha = 1, beta = 1, log = FALSE)

pgmsnburr(
  q,
  mu = 0,
  sigma = 1,
  alpha = 1,
  beta = 1,
  lower.tail = TRUE,
  log.p = FALSE
)

qgmsnburr(
  p,
  mu = 0,
  sigma = 1,
  alpha = 1,
  beta = 1,
  lower.tail = TRUE,
  log.p = FALSE
)

rgmsnburr(n, mu = 0, sigma = 1, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmsnburr_+3A_x">x</code>, <code id="gmsnburr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_mu">mu</code></td>
<td>
<p>a  location parameter.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_sigma">sigma</code></td>
<td>
<p>a scale parameter.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_beta">beta</code></td>
<td>
<p>a shape parameter.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_log">log</code>, <code id="gmsnburr_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p)
The default value of this parameter is FALSE.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;if TRUE (default), probabilities are
<code class="reqn">P\left[ X\leq x\right]</code>, otherwise, <code class="reqn">P\left[ X&gt;x\right] </code>.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_p">p</code></td>
<td>
<p>vectors of probabilities.</p>
</td></tr>
<tr><td><code id="gmsnburr_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GMSNBurr Distribution 
</p>
<p>The GMSNBurr distribution with parameters <code class="reqn">\mu</code>, <code class="reqn">\sigma</code>,<code class="reqn">\alpha</code>, and <code class="reqn">\beta</code>
has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x |\mu,\sigma,\alpha,\beta) =  {\frac{\omega}{{B(\alpha,\beta)}\sigma}}{{\left(\frac{\beta}{\alpha}\right)}^\beta} {{\exp{\left(-\beta \omega {\left(\frac{x-\mu}{\sigma}\right)}\right)} {{\left(1+{\frac{\beta}{\alpha}} {\exp{\left(-\omega {\left(\frac{x-\mu}{\sigma}\right)}\right)}}\right)}^{-(\alpha+\beta)}}}}</code>
</p>

<p>where <code class="reqn">-\infty&lt;x&lt;\infty,  -\infty&lt;\mu&lt;\infty,  \sigma&gt;0, \alpha&gt;0, \beta&gt;0</code> 
and  <code class="reqn">\omega = {\frac{B(\alpha,\beta)}{\sqrt{2\pi}}}{{\left(1+{\frac{\beta}{\alpha}}\right)}^{\alpha+\beta}}{\left(\frac{\beta}{\alpha}\right)}^{-\beta}</code>
</p>


<h3>Value</h3>

<p><code>dgmsnburr</code> gives the density , <code>pgmasnburr</code> gives the distribution function,
<code>qgmsnburr</code> gives quantiles function, <code>rgmsnburr</code> generates random numbers.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir
</p>


<h3>References</h3>

<p>Choir, A. S. (2020). The New Neo-Normal Distributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>
<p>Iriawan, N. (2000). Computationally Intensive Approaches to Inference in Neo-Normal Linear Models. Curtin University of Technology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("neodistr")
dgmsnburr(0, mu=0, sigma=1, alpha=1,beta=1)
pgmsnburr(4, mu=0, sigma=1, alpha=1, beta=1)
qgmsnburr(0.4, mu=0, sigma=1, alpha=1, beta=1)
r=rgmsnburr(10000, mu=0, sigma=1, alpha=1, beta=1)
head(r)
hist(r, xlab = 'GMSNBurr random number', ylab = 'Frequency', 
main = 'Distribution of GMSNBurr Random Number ')
</code></pre>

<hr>
<h2 id='jfst'>Jones Faddy's Skew-t Distribution</h2><span id='topic+jfst'></span><span id='topic+djfst'></span><span id='topic+pjfst'></span><span id='topic+qjfst'></span><span id='topic+rjfst'></span>

<h3>Description</h3>

<p>To calculate density function, distribution funcion, quantile function, and  build data from random generator function 
for the Jones-Faddy's Skew-t Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>djfst(x, mu = 0, sigma = 1, alpha = 2, beta = 2, log = FALSE)

pjfst(
  q,
  mu = 0,
  sigma = 1,
  alpha = 2,
  beta = 2,
  lower.tail = TRUE,
  log.p = FALSE
)

qjfst(
  p,
  mu = 0,
  sigma = 1,
  alpha = 2,
  beta = 2,
  lower.tail = TRUE,
  log.p = FALSE
)

rjfst(n, mu = 0, sigma = 1, alpha = 2, beta = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jfst_+3A_x">x</code>, <code id="jfst_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="jfst_+3A_mu">mu</code></td>
<td>
<p>a location parameter.</p>
</td></tr>
<tr><td><code id="jfst_+3A_sigma">sigma</code></td>
<td>
<p>a scale parameter.</p>
</td></tr>
<tr><td><code id="jfst_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter (skewness).</p>
</td></tr>
<tr><td><code id="jfst_+3A_beta">beta</code></td>
<td>
<p>a shape parameter (kurtosis).</p>
</td></tr>
<tr><td><code id="jfst_+3A_log">log</code>, <code id="jfst_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p)
The default value of this parameter is FALSE</p>
</td></tr>
<tr><td><code id="jfst_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;if TRUE (default), probabilities are
<code class="reqn">P\left[ X\leq x\right]</code>, otherwise, <code class="reqn">P\left[ X&gt;x\right] </code>.</p>
</td></tr>
<tr><td><code id="jfst_+3A_p">p</code></td>
<td>
<p>vectors of probabilities.</p>
</td></tr>
<tr><td><code id="jfst_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jones-Faddy's Skew-t Distribution 
</p>
<p>The Jones-Faddy's Skew-t distribution with parameters <code class="reqn">\mu</code>, <code class="reqn">\sigma</code>,<code class="reqn">\alpha</code>, and <code class="reqn">\beta</code>
has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x |\mu,\sigma,\beta,\alpha)= \frac{c}{\sigma} {\left[{1+\frac{z}{\sqrt{\alpha+\beta+z^2}}}\right]}^{\alpha+\frac{1}{2}}
{\left[{1-\frac{z}{\sqrt{\alpha+\beta+z^2}}}\right]}^{\beta+\frac{1}{2}}</code>
</p>

<p>where <code class="reqn">-\infty&lt;x&lt;\infty,  -\infty&lt;\mu&lt;\infty,  \sigma&gt;0, \alpha&gt;0, \beta&gt;0,</code> 
<code class="reqn">z =\frac{x-\mu}{\sigma} </code>, <code class="reqn"> c = {\left[2^{\left(\alpha+\beta-1\right)} {\left(\alpha+\beta\right)^{\frac{1}{2}}} B(a,b)\right]}^{-1} </code>,
</p>


<h3>Value</h3>

<p><code>djfst</code> gives the density , <code>pjfst</code> gives the distribution function,
<code>qjfst</code> gives quantiles function, <code>rjfst</code> generates random numbers.
</p>


<h3>Author(s)</h3>

<p>Anisa' Faoziah
</p>


<h3>References</h3>

<p>Jones, M.C. and Faddy, M. J. (2003) A skew extension of the t distribution,
with applications. Journal of the Royal Statistical Society, 
Series B, 65, pp 159-174
</p>
<p>Rigby, R.A. and Stasinopoulos, M.D. and Heller, G.Z. and De Bastiani, F. 
(2019) Distributions for Modeling Location, Scale, 
and Shape: Using GAMLSS in R.CRC Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>djfst(4, mu=0, sigma=1, alpha=2, beta=2)
pjfst(4, mu=0, sigma=1, alpha=2, beta=2)
qjfst(0.4, mu=0, sigma=1, alpha=2, beta=2)
r=rjfst(10000, mu=0, sigma=1, alpha=2, beta=2)
head(r)
hist(r, xlab = 'jfst random number', ylab = 'Frequency', 
main = 'Distribution of jfst Random Number ')
</code></pre>

<hr>
<h2 id='msnburr'>MSNBurr Distribution</h2><span id='topic+msnburr'></span><span id='topic+dmsnburr'></span><span id='topic+pmsnburr'></span><span id='topic+qmsnburr'></span><span id='topic+rmsnburr'></span>

<h3>Description</h3>

<p>To calculate density function, distribution funcion, quantile function, and  build data from random generator function 
for the MSNBurr Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmsnburr(x, mu = 0, sigma = 1, alpha = 1, log = FALSE)

pmsnburr(q, mu = 0, sigma = 1, alpha = 1, lower.tail = TRUE, log.p = FALSE)

qmsnburr(p, mu = 0, sigma = 1, alpha = 1, lower.tail = TRUE, log.p = FALSE)

rmsnburr(n, mu = 0, sigma = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msnburr_+3A_x">x</code>, <code id="msnburr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_mu">mu</code></td>
<td>
<p>a location parameter.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_sigma">sigma</code></td>
<td>
<p>a scale parameter.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_log">log</code>, <code id="msnburr_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p)
The default value of this parameter is FALSE.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;if TRUE (default), probabilities are
<code class="reqn">P\left[ X\leq x\right]</code>, otherwise, <code class="reqn">P\left[ X&gt;x\right] </code>.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_p">p</code></td>
<td>
<p>vectors of probabilities.</p>
</td></tr>
<tr><td><code id="msnburr_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MSNBurr Distribution 
</p>
<p>The MSNBurr distribution with parameters <code class="reqn">\mu</code>, <code class="reqn">\sigma</code>,and <code class="reqn">\alpha</code>
has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x |\mu,\sigma,\alpha)=\frac{\omega}{\sigma}\exp{\left(\omega{\left(\frac{x-\mu}{\sigma}\right)}\right)}{{\left(1+\frac{\exp{\left(\omega{(\frac{x-\mu}{\sigma})}\right)}}{\alpha}\right)}^{-(\alpha+1)}}</code>
</p>

<p>where <code class="reqn">-\infty &lt; x &lt; \infty, -\infty &lt; \mu&lt; \infty, \sigma&gt;0, \alpha&gt;0, 
\omega = \frac{1}{\sqrt{2\pi}} {\left(1+\frac{1}{\alpha}\right)^{\alpha+1}}</code>
</p>


<h3>Value</h3>

<p><code>dmsnburr</code> gives the density , <code>pmsnburr</code> gives the distribution function,
<code>qmsnburr</code> gives quantiles function, <code>rmsnburr</code> generates random  numbers.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir and Nur Iriawan
</p>


<h3>References</h3>

<p>Iriawan, N. (2000). Computationally Intensive Approaches to Inference in Neo-Normal Linear Models. Curtin University of Technology.
</p>
<p>Choir, A. S. (2020). The New Neo-Normal Distributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("neodistr")
dmsnburr(0, mu=0, sigma=1, alpha=0.1)
plot(function(x) dmsnburr(x, alpha=0.1), -20, 3,
main = "Left Skew MSNBurr Density ",ylab="density")
pmsnburr(7, mu=0, sigma=1, alpha=1)
qmsnburr(0.6, mu=0, sigma=1, alpha=1)
r&lt;- rmsnburr(10000, mu=0, sigma=1, alpha=1)
head(r)
hist(r, xlab = 'MSNBurr random number', ylab = 'Frequency', 
main = 'Distribution of MSNBurr Random Number ')
</code></pre>

<hr>
<h2 id='msnburr2a'>MSNBurr-IIa distribution.</h2><span id='topic+msnburr2a'></span><span id='topic+dmsnburr2a'></span><span id='topic+pmsnburr2a'></span><span id='topic+qmsnburr2a'></span><span id='topic+rmsnburr2a'></span>

<h3>Description</h3>

<p>To calculate density function, distribution funcion, quantile function, and  build data from random generator function 
for the MSNBurr distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmsnburr2a(x, mu = 0, sigma = 1, alpha = 1, log = FALSE)

pmsnburr2a(q, mu = 0, sigma = 1, alpha = 1, lower.tail = TRUE, log.p = FALSE)

qmsnburr2a(p, mu = 0, sigma = 1, alpha = 1, lower.tail = TRUE, log.p = FALSE)

rmsnburr2a(n, mu = 0, sigma = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msnburr2a_+3A_x">x</code>, <code id="msnburr2a_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_mu">mu</code></td>
<td>
<p>a location parameter.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_sigma">sigma</code></td>
<td>
<p>a scale parameter.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_alpha">alpha</code></td>
<td>
<p>a shape parameter</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_log">log</code>, <code id="msnburr2a_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p),
The default value of this parameter is FALSE.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;if TRUE (default), probabilities are
<code class="reqn">P\left[ X\leq x\right]</code>, otherwise, <code class="reqn">P\left[ X&gt;x\right] </code>.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_p">p</code></td>
<td>
<p>vectors of probabilities.</p>
</td></tr>
<tr><td><code id="msnburr2a_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MSNBurr-IIa Distribution 
</p>
<p>The MSNBurr-IIa distribution with parameters <code class="reqn">\mu</code>, <code class="reqn">\sigma</code>, and <code class="reqn">\alpha</code>
has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x |\mu,\sigma,\alpha)=\frac{\omega}{\sigma}\exp{\left(\omega{\left(\frac{x-\mu}{\sigma}\right)}\right)}{{\left(1+\frac{\exp{\left(\omega{(\frac{x-\mu}{\sigma})}\right)}}{\alpha}\right)}^{-(\alpha+1)}}</code>
</p>

<p>where <code class="reqn">-\infty &lt; x &lt; \infty, -\infty &lt; \mu&lt; \infty, \sigma&gt;0, \alpha&gt;0, 
\omega = \frac{1}{\sqrt{2\pi}} {\left(1+\frac{1}{\alpha}\right)^{\alpha+1}}</code>
</p>


<h3>Value</h3>

<p><code>dmsnburr2a</code> gives the density, <code>pmsnburr2a</code> gives the distribution
function, <code>qmsnburr2a</code> gives the quantile function and <code>rmsnburr2a</code> generates
random numbers.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir and Nur Iriawan
</p>


<h3>References</h3>

<p>Choir, A. S. (2020). The New Neo-Normal DDistributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("neodistr")
dmsnburr2a(7, mu=0, sigma=1, alpha=0.1)
plot(function(x) dmsnburr2a(x, alpha=0.1), -3, 20,
main = "Right Skew MSNBurr-IIa Density ",ylab="density")
p=pmsnburr2a(4, mu=0, sigma=1, alpha=1)
p
q=qmsnburr2a(p, mu=0, sigma=1, alpha=1)
q
qmsnburr2a(0.5, mu=0, sigma=1, alpha=1)
r=rmsnburr2a(10000, mu=0, sigma=1, alpha=0.1)
head(r)
hist(r, xlab = 'MSNBurr random number', ylab = 'Frequency', 
main = 'Distribution of MSNBurr-IIa Random Number ')
</code></pre>

<hr>
<h2 id='neoshiny'>Starts shiny application for the neodistr package</h2><span id='topic+neoshiny'></span>

<h3>Description</h3>

<p>Starts shiny application for the neodistr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neoshiny()
</code></pre>


<h3>Value</h3>

<p>Starts shiny application for the neodistr package.
</p>


<h3>Author(s)</h3>

<p>Anisa' Faoziah and Achmad Syahrul Choir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if 	(interactive()) {
	suppressMessages(library(neodistr))	
	neoshiny()
	}
</code></pre>

<hr>
<h2 id='stanf_gmsnburr'>Stan function of GMSNBurr Distribution</h2><span id='topic+stanf_gmsnburr'></span>

<h3>Description</h3>

<p>Stan code of GMSNBurr distribution for custom distribution in stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanf_gmsnburr(vectorize = TRUE, rng = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanf_gmsnburr_+3A_vectorize">vectorize</code></td>
<td>
<p>logical; if TRUE, Vectorize Stan code of GMSNBurr distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
<tr><td><code id="stanf_gmsnburr_+3A_rng">rng</code></td>
<td>
<p>logical; if TRUE,  Stan code of quantile and 
random number generation of GMSNBurr distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GMSNBurr Distribution has density:
</p>
<p style="text-align: center;"><code class="reqn">f(y |\mu,\sigma,\alpha,\beta) =  {\frac{\omega}{{B(\alpha,\beta)}\sigma}}{{\left(\frac{\beta}{\alpha}\right)}^\beta} {{\exp{\left(-\beta \omega {\left(\frac{y-\mu}{\sigma}\right)}\right)} {{\left(1+{\frac{\beta}{\alpha}} {\exp{\left(-\omega {\left(\frac{y-\mu}{\sigma}\right)}\right)}}\right)}^{-(\alpha+\beta)}}}}</code>
</p>

<p>where <code class="reqn">-\infty&lt;y&lt;\infty,  -\infty&lt;\mu&lt;\infty,  \sigma&gt;0, \alpha&gt;0, \beta&gt;0</code> 
and  <code class="reqn">\omega = {\frac{B(\alpha,\beta)}{\sqrt{2\pi}}}{{\left(1+{\frac{\beta}{\alpha}}\right)}^{\alpha+\beta}}{\left(\frac{\beta}{\alpha}\right)}^{-\beta}</code>
</p>
<p>This function gives stan code  of log density, cumulative distribution, log of cumulatif distribution, log complementary cumulative distribution, quantile, random number of GMSNBurr distribution
</p>


<h3>Value</h3>

<p><code>msnburr_lpdf</code> gives the stans's code of log of density, <code>msnburr_cdf</code> gives the stans's code of distribution
function, <code>gmsnburr_lcdf</code> gives the stans's code of log of distribution function, <code>gmsnburr_lccdf</code> gives the stans's code of complement of log ditribution function (1-gmsnburr_lcdf),
and <code>gmsnburr_rng</code> the stans's code of generates random numbers.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir
</p>


<h3>References</h3>

<p>Choir, A. S. (2020). The New Neo-Normal DDistributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(neodistr)
library(rstan)
#inputting data
set.seed(136)
dt &lt;- rgmsnburr(100,0,1,0.5,0.5) # random generating MSNBurr-IIA data 
dataf &lt;- list(
  n = 100,
  y = dt
)
#### not vector  
##Calling the function of the neo-normal distribution that is available in the package.
func_code&lt;-paste(c("functions{",neodistr::stanf_gmsnburr(vectorize=FALSE),"}"),collapse="\n")
#define stan model code
model&lt;-"
  data {
  int&lt;lower=1&gt; n;
  vector[n] y;
  }
  parameters {
  real mu;
  real &lt;lower=0&gt; sigma;
  real &lt;lower=0&gt; alpha;
  real &lt;lower=0&gt; beta; 
  }
  model {
  for(i in 1:n){
  y[i]~gmsnburr(mu,sigma,alpha,beta);
  }
  mu~cauchy(0,1);
  sigma~cauchy(0,2.5);
  alpha~cauchy(0,1);
  beta~cauchy(0,1);
  }
   "
#merge stan model code and selected neo-normal stan function
fit_code&lt;-paste(c(func_code,model,"\n"),collapse="\n") 

# Create the model using stan function
fit1 &lt;- stan(
  model_code = fit_code,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2,              # number of cores (could use one per chain)
  control = list(         #control samplers behavior
    adapt_delta=0.9
  )
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit1, pars=c("mu", "sigma", "alpha", "beta","lp__"), probs=c(.025,.5,.975))


# Vector
##Calling the function of the neo-normal distribution that is available in the package.
func_code_vector&lt;-paste(c("functions{",neodistr::stanf_gmsnburr(vectorize=TRUE),"}"),collapse="\n")
# define stan model as vector
model_vector&lt;-"
 data {
   int&lt;lower=1&gt; n;
   vector[n] y;
 }
 parameters {
   real mu;
   real &lt;lower=0&gt; sigma;
   real &lt;lower=0&gt; alpha;
   real &lt;lower=0&gt; beta;
 }
 model {
   y~gmsnburr(rep_vector(mu,n),sigma,alpha,beta);
   mu~cauchy(0,1);
   sigma~cauchy(0,2.5);
   alpha~cauchy(0,1);
   beta~cauchy(0,1);
 }
 "
#merge stan model code and selected neo-normal stan function
fit_code_vector&lt;-paste(c(func_code_vector,model_vector,"\n"),collapse="\n")

# Create the model using stan function
fit2 &lt;- stan(
  model_code = fit_code_vector,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2,              # number of cores (could use one per chain)
  control = list(         #control samplers behavior
    adapt_delta=0.9
  )
)

# Showing the estimation results of the parameters 
print(fit2, pars=c("mu", "sigma", "alpha","beta",  "lp__"), probs=c(.025,.5,.975))

</code></pre>

<hr>
<h2 id='stanf_jfst'>Stan function of Jones and Faddys Skew-t Distribution</h2><span id='topic+stanf_jfst'></span>

<h3>Description</h3>

<p>Stan code of JFST distribution for custom distribution in stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanf_jfst(vectorize = TRUE, rng = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanf_jfst_+3A_vectorize">vectorize</code></td>
<td>
<p>logical; if TRUE, Vectorize Stan code of Jones and faddy distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
<tr><td><code id="stanf_jfst_+3A_rng">rng</code></td>
<td>
<p>logical; if TRUE,  Stan code of quantile and 
random number generation of Jones and faddy distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jones-Faddy’s Skew-t distribution has density:
</p>
<p style="text-align: center;"><code class="reqn">f(y |\mu,\sigma,\beta,\alpha)= \frac{c}{\sigma} {\left[{1+\frac{z}{\sqrt{\alpha+\beta+z^2}}}\right]}^{\alpha+\frac{1}{2}}
{\left[{1-\frac{z}{\sqrt{\alpha+\beta+z^2}}}\right]}^{\beta+\frac{1}{2}}</code>
</p>

<p>where <code class="reqn">-\infty&lt;y&lt;\infty,  -\infty&lt;\mu&lt;\infty,  \sigma&gt;0, \alpha&gt;0, \beta&gt;0,</code> 
<code class="reqn">z =\frac{y-\mu}{\sigma} </code>, <code class="reqn"> c = {\left[2^{\left(\alpha+\beta-1\right)} {\left(\alpha+\beta\right)^{\frac{1}{2}}} B(a,b)\right]}^{-1} </code>,
</p>
<p>This function gives stan code  of log density, cumulative distribution, log of cumulatif distribution, log complementary cumulative distribution,
quantile, random number of Jones-Faddy's Skew-t distribution
</p>


<h3>Value</h3>

<p><code>jfst_lpdf</code> gives stan's code of the log of density, <code>jfst_cdf</code> gives stan's code of the distribution
function, <code>jfst_lcdf</code> gives stan's code of the log of distribution function and <code>jfst_rng</code> gives stan's code of generates
random numbers.
</p>


<h3>Author(s)</h3>

<p>Anisa' Faoziah and Achmad Syahrul Choir
</p>


<h3>References</h3>

<p>Jones, M.C. and Faddy, M. J. (2003) A skew extension of the t distribution, with applications. Journal of the Royal Statistical Society, Series B, 65, pp 159-174
</p>
<p>Rigby, R.A. and Stasinopoulos, M.D. and Heller, G.Z. and De Bastiani, F. (2019) Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R.CRC Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library (neodistr)
library (rstan)

# inputting data
set.seed(400)
dt &lt;- neodistr::rjfst(100,mu=0, sigma=1, alpha = 2, beta = 2) # random generating JFST data
dataf &lt;- list(
 n = 100,
 y = dt
 )
 
 
#### not vector
## Calling the function of the neo-normal distribution that is available in the package.
func_code&lt;-paste(c("functions{",neodistr::stanf_jfst(vectorize=FALSE),"}"),collapse="\n")

# Define Stan Model Code
model &lt;-"
    data{
      int&lt;lower=1&gt; n;
      vector[n] y;
    }
    parameters{
      real mu;
      real &lt;lower=0&gt; sigma;
      real &lt;lower=0&gt; alpha;
      real &lt;lower=0&gt; beta;
    }
    model {
      for(i in 1 : n){
      y[i] ~ jfst(mu,sigma, alpha, beta);
      }
      mu ~ cauchy(0,1);
      sigma ~ cauchy(0, 2.5);
      alpha ~ lognormal(0,5);
      beta ~ lognormal(0,5);
      
    }
"

# Merge stan model code and selected neo-normal stan function
fit_code &lt;- paste (c(func_code,model,"\n"), collapse = "\n")

# Create the model using Stan Function
fit1 &lt;- stan(
    model_code = fit_code,  # Stan Program
    data = dataf,           # named list data
    chains = 2,             # number of markov chains
    warmup = 5000,          # total number of warmup iterarions per chain
    iter = 10000,           # total number of iterations iterarions per chain
    cores = 2,              # number of cores (could use one per chain)
    control = list(         # control sampel behavior
      adapt_delta = 0.99
    ),
    refresh = 1000          # progress has shown if refresh &gt;=1, else no progress shown
)

# Showing the estimation result of the parameters that were executed using the Stan file
print(fit1, pars = c("mu", "sigma", "alpha", "beta", "lp__"), probs=c(.025,.5,.975))


#### Vector
## Calling the function of the neonormal distribution that is available in the package.
func_code_vector&lt;-paste(c("functions{",neodistr::stanf_jfst(vectorize=TRUE),"}"),collapse="\n")

# Define Stan Model Code
model_vector &lt;-"
    data{
      int&lt;lower=1&gt; n;
      vector[n] y;
    }
    parameters{
      real mu;
      real &lt;lower=0&gt; sigma;
      real &lt;lower=0&gt; alpha;
      real &lt;lower=0&gt;beta;
    }
    model {
      y ~ jfst(rep_vector(mu,n),sigma, alpha, beta);
      mu ~ cauchy (0,1);
      sigma ~ cauchy (0, 2.5);
      alpha ~ lognormal(0,5);
      beta ~ lognormal(0,5);
      
    }
 "
 
 # Merge stan model code and selected neo-normal stan function
fit_code_vector &lt;- paste (c(func_code_vector,model_vector,"\n"), collapse = "\n")

# Create the model using Stan Function
fit2 &lt;- stan(
    model_code = fit_code_vector,  # Stan Program
    data = dataf,                  # named list data
    chains = 2,                    # number of markov chains
    warmup = 5000,                 # total number of warmup iterarions per chain
    iter = 10000,                  # total number of iterations iterarions per chain
    cores = 2,                     # number of cores (could use one per chain)
    control = list(                # control sampel behavior
      adapt_delta = 0.99
    ),
    refresh = 1000                 # progress has shown if refresh &gt;=1, else no progress shown
)

# Showing the estimation result of the parameters that were executed using the Stan file
print(fit2, pars = c("mu", "sigma", "alpha", "beta", "lp__"), probs=c(.025,.5,.975))
 
</code></pre>

<hr>
<h2 id='stanf_msnburr'>Stan function of MSNBurr Distribution</h2><span id='topic+stanf_msnburr'></span>

<h3>Description</h3>

<p>Stan code of MSNBurr distribution for custom distribution in stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanf_msnburr(vectorize = TRUE, rng = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanf_msnburr_+3A_vectorize">vectorize</code></td>
<td>
<p>logical; if TRUE, Vectorize Stan code of MSNBurr distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
<tr><td><code id="stanf_msnburr_+3A_rng">rng</code></td>
<td>
<p>logical; if TRUE,  Stan code of quantile and 
random number generation of MSNBurr distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MSNBurr Distribution has density:
</p>
<p style="text-align: center;"><code class="reqn">f(y |\mu,\sigma,\alpha)=\frac{\omega}{\sigma}\exp{\left(-\omega{\left(\frac{y-\mu}{\sigma}\right)}\right)}{{\left(1+\frac{\exp{\left(-\omega{(\frac{y-\mu}{\sigma})}\right)}}{\alpha}\right)}^{-(\alpha+1)}}</code>
</p>

<p>where <code class="reqn">-\infty &lt; y &lt; \infty, -\infty &lt; \mu&lt; \infty, \sigma&gt;0, \alpha&gt;0, 
\omega = \frac{1}{\sqrt{2\pi}} {\left(1+\frac{1}{\alpha}\right)^{\alpha+1}}</code>
</p>
<p>This function gives stan code  of log density, cumulative distribution, log of cumulatif distribution, log complementary cumulative distribution, quantile, random number of MSNBurr distribution
</p>


<h3>Value</h3>

<p><code>msnburr_lpdf</code> gives the log of density, <code>msnburr_cdf</code> gives the distribution
function, <code>msnburr_lcdf</code> gives the log of distribution function, <code>msnburr_lccdf</code> gives the complement of log ditribution function (1-msnburr_lcdf),
and <code>msnburr_rng</code> generates
random deviates.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir and Nur Iriawan
</p>


<h3>References</h3>

<p>Iriawan, N. (2000). Computationally Intensive Approaches to Inference in Neo-Normal Linear Models. Curtin University of Technology.
Choir, A. S. (2020). The New Neo-Normal DDistributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library (neodistr)
library(rstan)
#inputting data
set.seed(136)
dt &lt;- neodistr::rmsnburr(100,0,1,0.5) # random generating MSNBurr data 
dataf &lt;- list(
  n = 100,
  y = dt
)
#### not vector  
##Calling the function of the neo-normal distribution that is available in the package.
func_code&lt;-paste(c("functions{",neodistr::stanf_msnburr(vectorize=FALSE),"}"),collapse="\n")
#define stan model code
model&lt;-"
 data {
 int&lt;lower=1&gt; n;
 vector[n] y;
 }
 parameters {
 real mu;
 real &lt;lower=0&gt; sigma;
 real &lt;lower=0&gt; alpha;
 
 }
 model {
 for(i in 1:n){
 y[i]~msnburr(mu,sigma,alpha);
 }
 mu~cauchy(0,1);
 sigma~cauchy(0,2.5);
 alpha~cauchy(0,1);
 }
  "
#merge stan model code and selected neo-normal stan function
fit_code&lt;-paste(c(func_code,model,"\n"),collapse="\n") 

# Create the model using stan function
fit1 &lt;- stan(
  model_code = fit_code,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2              # number of cores (could use one per chain)
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit1, pars=c("mu", "sigma", "alpha", "lp__"), probs=c(.025,.5,.975))


# Vector
##Calling the function of the neo-normal distribution that is available in the package.
func_code_vector&lt;-paste(c("functions{",neodistr::stanf_msnburr(vectorize=TRUE),"}"),collapse="\n")
# define stan model as vector
model_vector&lt;-"
data {
  int&lt;lower=1&gt; n;
  vector[n] y;
}
parameters {
  real mu;
  real &lt;lower=0&gt; sigma;
  real &lt;lower=0&gt; alpha;
}
model {
  y~msnburr(rep_vector(mu,n),sigma,alpha);
  mu~cauchy(0,1);
  sigma~cauchy(0,2.5);
  alpha~cauchy(0,1);
}
"
#merge stan model code and selected neo-normal stan function
fit_code_vector&lt;-paste(c(func_code_vector,model_vector,"\n"),collapse="\n")

# Create the model using stan function
fit2 &lt;- stan(
  model_code = fit_code_vector,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2             # number of cores (could use one per chain)
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit2, pars=c("mu", "sigma", "alpha",  "lp__"), probs=c(.025,.5,.975))


</code></pre>

<hr>
<h2 id='stanf_msnburr2a'>Stan function of MSNBurr-IIa Distribution</h2><span id='topic+stanf_msnburr2a'></span>

<h3>Description</h3>

<p>Stan code of MSNBurr-IIa distribution for custom distribution in stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanf_msnburr2a(vectorize = TRUE, rng = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanf_msnburr2a_+3A_vectorize">vectorize</code></td>
<td>
<p>logical; if TRUE, Vectorize Stan code of MSNBurr-IIa distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
<tr><td><code id="stanf_msnburr2a_+3A_rng">rng</code></td>
<td>
<p>logical; if TRUE,  Stan code of quantile and 
random number generation of MSNBurr-IIa distribution are given 
The default value of this parameter is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MSNBurr-IIa Distribution has density function:
</p>
<p style="text-align: center;"><code class="reqn">f(y |\mu,\sigma,\alpha)=\frac{\omega}{\sigma}\exp{\left(\omega{\left(\frac{y-\mu}{\sigma}\right)}\right)}{{\left(1+\frac{\exp{\left(\omega{(\frac{y-\mu}{\sigma})}\right)}}{\alpha}\right)}^{-(\alpha+1)}}</code>
</p>

<p>where <code class="reqn">-\infty &lt; y &lt; \infty, -\infty &lt; \mu&lt; \infty, \sigma&gt;0, \alpha&gt;0, 
\omega = \frac{1}{\sqrt{2\pi}} {\left(1+\frac{1}{\alpha}\right)^{\alpha+1}}</code>
This function gives stan code  of log density, cumulative distribution, log of cumulatif distribution, log complementary cumulative distribution, quantile, random number of MSNBurr-IIa distribution
</p>


<h3>Value</h3>

<p><code>msnburr_lpdf</code> gives the log of density, <code>msnburr_cdf</code> gives the distribution
function, <code>msnburr_lcdf</code> gives the log of distribution function, <code>msnburr_lccdf</code> gives the complement of log ditribution function (1-msnburr_lcdf),
and <code>msnburr_rng</code> generates
random deviates.
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir and Nur Iriawan
</p>


<h3>References</h3>

<p>Choir, A. S. (2020). The New Neo-Normal DDistributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library (neodistr)
library(rstan)
#inputting data
set.seed(136)
dt &lt;- neodistr::rmsnburr2a(100,0,1,0.5) # random generating MSNBurr-IIA data 
dataf &lt;- list(
  n = 100,
  y = dt
)
#### not vector  
##Calling the function of the neo-normal distribution that is available in the package.
func_code&lt;-paste(c("functions{",neodistr::stanf_msnburr2a(vectorize=FALSE),"}"),collapse="\n")
#define stan model code
model&lt;-"
 data {
 int&lt;lower=1&gt; n;
 vector[n] y;
 }
 parameters {
 real mu;
 real &lt;lower=0&gt; sigma;
 real &lt;lower=0&gt; alpha;
 
 }
 model {
 for(i in 1:n){
 y[i]~msnburr2a(mu,sigma,alpha);
 }
 mu~cauchy(0,1);
 sigma~cauchy(0,2.5);
 alpha~cauchy(0,1);
 }
  "
#merge stan model code and selected neo-normal stan function
fit_code&lt;-paste(c(func_code,model,"\n"),collapse="\n") 

# Create the model using stan function
fit1 &lt;- stan(
  model_code = fit_code,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2              # number of cores (could use one per chain)
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit1, pars=c("mu", "sigma", "alpha", "lp__"), probs=c(.025,.5,.975))


# Vector
##Calling the function of the neo-normal distribution that is available in the package.
func_code_vector&lt;-paste(c("functions{",neodistr::stanf_msnburr2a(vectorize=TRUE),"}"),collapse="\n")
# define stan model as vector
model_vector&lt;-"
data {
  int&lt;lower=1&gt; n;
  vector[n] y;
}
parameters {
  real mu;
  real &lt;lower=0&gt; sigma;
  real  alpha;
}
model {
  y~msnburr2a(rep_vector(mu,n),sigma,alpha);
  mu~cauchy(0,1);
  sigma~cauchy(0,2.5);
  alpha~cauchy(0,1);
}
"
#merge stan model code and selected neo-normal stan function
fit_code_vector&lt;-paste(c(func_code_vector,model_vector,"\n"),collapse="\n")

# Create the model using stan function
fit2 &lt;- stan(
  model_code = fit_code_vector,  # Stan program
  data = dataf,    # named list of data
  chains = 2,             # number of Markov chains
  #warmup = 5000,          # number of warmup iterations per chain
  iter = 10000,           # total number of iterations per chain
  cores = 2              # number of cores (could use one per chain)
)

# Showing the estimation results of the parameters that were executed using the Stan file
print(fit2, pars=c("mu", "sigma", "alpha",  "lp__"), probs=c(.025,.5,.975))


</code></pre>

<hr>
<h2 id='summary_dist'>Summaries of Neo-normal Distribution</h2><span id='topic+summary_dist'></span>

<h3>Description</h3>

<p>To display a summary of calculations for a specific neo-normal distribution, 
including the mean,median, mode, variance, skewness, and excess.kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_dist(family = "msnburr", par = c(mu = 0, sigma = 1, alpha = 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_dist_+3A_family">family</code></td>
<td>
<p>identify the type of Neo-normal distribution to be used. There are four categories of neo-normal distributions,
which encompass &quot;msnburr&quot; for MSNBurr , &quot;msnburr2a&quot; for MSNBurr-IIa, &quot;gmsnburr&quot; for GMSNBurr, and &quot;jfst&quot; for Jones-Faddy's Skew-t Distribution. 
The default value of this parameter is  &quot;msnburr&quot;</p>
</td></tr>
<tr><td><code id="summary_dist_+3A_par">par</code></td>
<td>
<p>list values of each parameter, based on the chosen distribution. The default value is &quot;par=c(alpha=1,mu=0,sigma=1)&quot; for MSNBurr parameter
parameter of MSNBurr and MSNBurr-IIa are mu, sigma, alpha
parameter of GMSNBurr and JFST are mu, sigma, alpha, beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>media, mean, mode,  variance, skewness, and excess kurtosis of neo-normal distributions
</p>


<h3>Author(s)</h3>

<p>Achmad Syahrul Choir
</p>


<h3>References</h3>

<p>Choir, A. S. (2020). The New Neo-Normal Distributions and their Properties. Disertation. Institut Teknologi Sepuluh Nopember.
Jones, M.C. and Faddy, M. J. (2003) A skew extension of the t distribution, with applications. Journal of the Royal Statistical Society, Series B, 65, pp 159-174
Rigby, R.A. and Stasinopoulos, M.D. and Heller, G.Z. and De Bastiani, F. 
(2020) Distributions for Modeling Location, Scale, and Shape: 
Using GAMLSS in R.CRC Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary_dist (family="msnburr2a", par=c(mu=0,sigma=1,alpha=4))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
