<!DOCTYPE html><html><head><title>Help for package netmediate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netmediate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMME'>
<p>Function to estimate the average micro mediated effect (AMME).</p></a></li>
<li><a href='#identity_function'><p>Function to map micro_process onto macro_model within calls to <code>AMME</code>.</p></a></li>
<li><a href='#MEMS'>
<p>Function to estimate the micro effect on macro structure (MEMS).</p></a></li>
<li><a href='#Moran_dv'><p>Function to calculate Moran's first order network autocorrelation in co-evolution SAOM.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Micro-Macro Analysis for Social Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Duxbury &lt;duxbury@email.unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates micro effects on macro structures (MEMS) and average micro mediated effects (AMME).
    URL: <a href="https://github.com/sduxbury/netmediate">https://github.com/sduxbury/netmediate</a>.
    BugReports: <a href="https://github.com/sduxbury/netmediate/issues">https://github.com/sduxbury/netmediate/issues</a>.
    Robins, Garry, Phillipa Pattison, and Jodie Woolcock (2005) &lt;<a href="https://doi.org/10.1086%2F427322">doi:10.1086/427322</a>&gt;.
    Snijders, Tom A. B., and Christian E. G. Steglich (2015) &lt;<a href="https://doi.org/10.1177%2F0049124113494573">doi:10.1177/0049124113494573</a>&gt;.
    Imai, Kosuke, Luke Keele, and Dustin Tingley (2010) &lt;<a href="https://doi.org/10.1037%2Fa0020761">doi:10.1037/a0020761</a>&gt;.
    Duxbury, Scott (2023) &lt;<a href="https://doi.org/10.1177%2F00811750231209040">doi:10.1177/00811750231209040</a>&gt;.
    Duxbury, Scott (2024) &lt;<a href="https://doi.org/10.1177%2F00811750231220950">doi:10.1177/00811750231220950</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, btergm, stats, ergm, RSiena, sna, network, ergMargins,
VGAM, plyr, lme4, plm, gam, intergraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, igraph, relevent, statnet, statnet.common</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 17:06:51 UTC; Scott D</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Duxbury [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 23:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMME'>
Function to estimate the average micro mediated effect (AMME).</h2><span id='topic+AMME'></span>

<h3>Description</h3>

<p><code>AMME</code> implements parametric and nonparametric estimation routines to estimate the
average mediated micro effect. It requires two models. The first is a generative network model (i.e., a model where the dyad, dyad-time period, or dyad-group is the unit of analysis) of the form <code class="reqn">f(A_{ij}|T_{ij},Z_{ij})</code>, where <code class="reqn">A</code> is a cross-sectional or longitudinal network or group of longitudinal or cross-sectional networks, <code class="reqn">T</code> is the possibly endogenous network selection process of interest and <code class="reqn">Z</code> is a matrix of possibly endogenous confounding selection mechanisms.
</p>
<p>The second model is a cross-sectional or longitudinal macro model (i.e., a model where the unit of analysis is a node, subgraph, or network or a combination of nodes, subgraphs, and networks measured collected from multiple settings [such as distinct schools or organizations]) of the form <code class="reqn">g(Y_i|M_{i},X_{i},T_{i})</code>, where <code class="reqn">Y_i</code> is the outcome variable, <code class="reqn">M_i</code> is the mediating macro variable,  <code class="reqn">X_i</code> is a matrix of control variables that possibly vary as a function of selection process <code class="reqn">T_{ij}</code>, and <code class="reqn">T_i</code> is the optional unit-level measure of <code class="reqn">T_{ij}</code>. The AMME is the change in <code class="reqn">Y_i</code> when <code class="reqn">T_{ij}</code> allowed to vary versus set to 0 because of an associated change in <code class="reqn">M_i</code>. The AMME is given by </p>
<p style="text-align: center;"><code class="reqn">AMME=\frac{1}{2n} y_i(T_i(t),M_i(T_{ij}),X_i(t))-y_i(T_i(t),M_i(0),X_i(t))</code>
</p>
<p>, where <code class="reqn">n</code> is the number of observations and <code class="reqn">t=0,T_{ij}</code>. AMME currently accepts the following micro models: <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects. The following macro model objects are accepted: <code>lm</code>, <code>glm</code>, <code>lmer</code>, <code>glmer</code>, <code>gam</code>, <code>plm</code>, and <code>lnam</code> objects. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> micro models. Both parametric and nonparametric estimation are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMME(micro_model,
      macro_model,
      micro_process,
      mediator,
      macro_function,
      link_id,
      object_type=NULL,
      controls=NULL,
      control_functions=NULL,
      interval=c(0,1),
      nsim=500,
      algorithm="parametric",
      silent=FALSE,
      full_output=FALSE,
      SAOM_data=NULL,
      SAOM_var=NULL,
      time_interval=NULL,
      covar_list=NULL,
      edgelist=NULL,
      net_logit_y=NULL,
      net_logit_x=NULL,
      group_id=NULL,
      node_numbers=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AMME_+3A_micro_model">micro_model</code></td>
<td>
<p>the micro-model. Currently accepts <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> objects. To implement pooled estimation, <code>model</code> should be provided as a list of <code>ergm</code> or <code>sienaFit</code> objects.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_macro_model">macro_model</code></td>
<td>
<p>the macro model. Currently accepts <code>lm</code>, <code>glm</code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code>, <code><a href="gam.html#topic+gam">gam</a></code>, <code><a href="plm.html#topic+plm">plm</a></code>, and <code><a href="sna.html#topic+lnam">lnam</a></code> objects.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_micro_process">micro_process</code></td>
<td>
<p>a character string containing the name of the micro process of interest. The character string should exactly match the relevant coefficient name in <code>micro_model</code> output.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_mediator">mediator</code></td>
<td>
<p>a character string containing the name of the mediating variable of interest.  The character string should exactly match the relevant coefficient name in <code>macro_model</code> output.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_macro_function">macro_function</code></td>
<td>
<p>a <code>function</code> that calculates <code>mediator</code> on the simulated networks. Currently accepts user defined functions as well as functions inherent in the <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code>statnet</code> packages for <span class="rlang"><b>R</b></span>.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_link_id">link_id</code></td>
<td>
<p>a required vector of IDs used to link the <code>micro_model</code> output to the <code>macro_model</code> input. If calculating a network-level mediator, this should be the network identifier or network-group/network-time period identifier. If calculating a node-level mediator, this should be the node ID or node-time-period/node-group identifier. Observations should correspond exactly to rows in the <code>macro_model</code> data matrix. If calculating multiple network statistics at different levels of analysis when <code>controls</code> are included, <code>link_id</code> may be provided as an ordered list of identifiers. In this case, each entry in the list is a vector of IDs corresponding to the unique entries of the relevant statistics. If provided as a list, the first entry should correspond to <code>macro_function</code> (i.e., the mediator) and the remaining entries should correspond to <code>control_functions</code> (i.e., the controls).
</p>
</td></tr>
<tr><td><code id="AMME_+3A_controls">controls</code></td>
<td>
<p>a vector of character strings listing the control variables in <code>macro_model</code> that may vary as a function of <code>micro_process</code>. Each element in <code>controls</code> should correspond exactly to a coefficient in <code>macro_model</code> output. If <code>controls</code> is left <code>NULL</code>,then the AMME is calculated without controlling for confounding network variables.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_control_functions">control_functions</code></td>
<td>
<p>a list of functions used to calculate <code>controls</code>. The elements in <code>control_functions</code> should correspond exactly to the elements in <code>controls</code> and should be provided in the same order. If <code>micro_process</code> appears as an independent variable in <code>macro_model</code>, then this can be specified by specifying the <code>netmediate</code> helper function <code>identity_function</code> to <code>control_functions</code>.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_object_type">object_type</code></td>
<td>
<p>A character string or vector of character strings that tells <code>netmediate</code> the type of object to apply the <code>macro_function</code> and <code>control_functions</code> to. If <code>controls</code> are included into the <code>AMME</code> call, then <code>object_type</code> should be provided as a vector of character strings where the first element is the <code>object_type</code> for <code>macro_function</code> and the remaining elements are the ordered <code>object_type</code> for <code>control_functions</code>. Currently accepts <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code><a href="network.html#topic+network">network</a></code> objects. If left <code>NULL</code>, <code><a href="network.html#topic+network">network</a></code> objects are assumed. Can be over-ridden to use other object types with a user-function by defining a function that accepts either a <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> object and returns a numeric value or vector of numeric values (see examples).
</p>
</td></tr>
<tr><td><code id="AMME_+3A_interval">interval</code></td>
<td>
<p>Tuning parameters to vary the strength of <code class="reqn">\theta</code>. Should be provided as a vector of numeric values with 2 entries.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations or bootstrap samples to use during estimation.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_algorithm">algorithm</code></td>
<td>
<p>The estimation algorithm to be used. Currently accepts <code>"parametric"</code> and <code>"nonparametric"</code>. If <code>"parametric"</code>, estimation is obtained with Monte Carlo sampling. If <code>"nonparametric"</code>, estimation uses bootstrap resampling.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_silent">silent</code></td>
<td>
<p>logical parameter. Whether to provide updates on the progress of the simulation or not.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_full_output">full_output</code></td>
<td>
<p>logical parameter. If set to <code>TRUE</code>, the entire distribution of simulated statistics will be provided as part of the model output.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_saom_data">SAOM_data</code></td>
<td>
<p>required when <code>micro_model</code> is a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object; ignored otherwise. If a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object is provided, <code>SAOM_data</code> should be the <code>siena</code> object that contains the data for SAOM estimation. If using pooled estimation on multiple <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects (i.e., providing a list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects), then <code>SAOM_data</code> should be provided as an ordered list with each entry containing the <code><a href="RSiena.html#topic+siena">siena</a></code> object corresponding to list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_saom_var">SAOM_var</code></td>
<td>
<p>optional parameter when <code>micro_model</code> is a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object. <code>SAOM_var</code> is a list of of the <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects used to assign time varying node and dyad covariates when calling <code><a href="RSiena.html#topic+sienaDataCreate">sienaDataCreate</a></code>. If provided, <code>netmediate</code> assigns the varying node covariates and dyad covariates to each simulated network. This parameter is required when <code>macro_function</code> computes a statistic that varies as a function of time varying node or dyad covariates (i.e., network segregation, assorativity). Time invariant characteristics (<code><a href="RSiena.html#topic+coCovar">coCovar</a></code> and <code><a href="RSiena.html#topic+coDyadCovar">coDyadCovar</a></code>) are handled internally by <code>MEMS</code> and should not be provided. When providing a list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects for pooled estimation, <code>SAOM_var</code> should be provided as a list of lists, where each entry in the list contains a list of <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects associated with corresponding <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_time_interval">time_interval</code></td>
<td>
<p>an optional parameter to be used when <code>micro_model</code> is a  <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> object. May be provided as a numeric vector or the character string <code>"aggregate"</code>. If a numeric vector is provided unique network snapshots at each interval. For example, <code>time_interval=c(0,2,3)</code> would induce two networks, one for the 0 - 2 time period and one for the 2 - 3 time period. If specified as <code>"aggregate"</code>, the AMME is calculated by creating an aggregated cross-sectional representation of the entire event sequence. If left <code>NULL</code>, defaults to |<code>"aggregate"</code>. Note that <code>time_interval</code> must correspond to the time periods observed in <code>macro_model</code>. That is, <code>time_interval</code> must be set to <code>"aggregate"</code> when <code>macro_model</code> is cross-sectional and the entries in <code>time_interval</code> must correspond to the time periods observed in the repeated measurement data when <code>macro_model</code> is longitudinal.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_covar_list">covar_list</code></td>
<td>
<p>an optional list of sender/receiver covariates used in <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> estimation. Only required when a <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> object is the <code>micro_model</code> and covariates are in the <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> call. The list format should correspond to the format required by <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code>.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_edgelist">edgelist</code></td>
<td>
<p>an optional three column edgelist providing the sender, receiver, and time of event occurrence when <code>micro_model</code> is a <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> object. Only required when <code>time_interval</code> is set to <code>NULL</code> or <code>"aggregate"</code>. Ignored for other types of models.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_net_logit_y">net_logit_y</code></td>
<td>
<p>the dependent variable when <code>micro_model</code> is a <code><a href="sna.html#topic+netlogit">netlogit</a></code> object. Should be provided as a vector.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_net_logit_x">net_logit_x</code></td>
<td>
<p>the matrix of independent variables when <code>micro_model</code> is a <code><a href="sna.html#topic+netlogit">netlogit</a></code> object
</p>
</td></tr>
<tr><td><code id="AMME_+3A_group_id">group_id</code></td>
<td>
<p>optional vector of group identifiers to use when <code>micro_model</code> is a <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code> on grouped data (i.e., multiple time periods, multiple networks). When specified,  <code>AMME</code> will induce unique networks for each grouping factor. If left unspecified, all groups/time periods are pooled. If using <code><a href="lme4.html#topic+glmer">glmer</a></code>, the grouping factor does not have to be provided as part of the model or used as a random effect. If specified, the entries in the <code>macro_model</code> model matrix are assumed to be sequentially ordered by unit_id-group_id.
</p>
</td></tr>
<tr><td><code id="AMME_+3A_node_numbers">node_numbers</code></td>
<td>
<p>a numeric vector containing the number of nodes in each group_id when using <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code>. If estimating AMME aggregated over all networks (i.e., <code>group_id=NULL</code>), this shoud be the total number of nodes in all networks. Required when using <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code>, ignored otherwise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the AMME over the provided intervals. Standard errors and confidence intervals are based on the sampling distribution of simulated values, which are calculated either parametrically or nonparametrically according to <code>algorithm</code>. Parametric estimation is typically faster, but cannot be used for nonparametric network models (e.g., quadratic assignment procedure).
</p>
<p><code>macro_function</code> and <code>control_functions</code> make up the core utilites of <code>AMME</code>. <code>macro_function</code> calculates the mediating variable of interest, while <code>control_functions</code> calculates all control variables that vary as a function of <code>micro_process</code> and potentially confound the effect of <code>mediator</code>. When <code>controls</code> are left <code>NULL</code>, then <code>AMME</code> estimates the AMME without accounting for confounding variables. Specifying <code>controls</code> and <code>control_functions</code> ensures that estimates of the AMME account for alternative pathways from <code>micro_process</code> to the outcome variable in <code>macro_model</code>. In cases where <code>micro_process</code> is included as a predictor variable in <code>macro_model</code>, this can be specified by including the <code>netmediate</code> helper function <code>identity_function</code> into <code>control_functions</code>.
</p>
<p><code>netmediate</code> currently supports functions calculated on <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code><a href="network.html#topic+network">network</a></code> objects, which should be specified using the <code>object_type</code> argument. These may be functions inherent to the <code><a href="statnet.html#topic+statnet">statnet</a></code> and <code><a href="igraph.html#topic+igraph">igraph</a></code> software package or they may be functions from other packages that accept <code><a href="network.html#topic+network">network</a></code>/<code><a href="igraph.html#topic+igraph">igraph</a></code> objects. The functions provided to <code>macro_function</code> and <code>control_functions</code> may also be user-defined functions that accept <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> objects as inputs and return a numeric value or vector of numeric values as output. It is also possible to over-ride the <code><a href="network.html#topic+network">network</a></code> and <code><a href="igraph.html#topic+igraph">igraph</a></code> object requirements within a user function. To do so, set the <code>object_type</code> argument (or relevant element within the <code>object_type</code> argument when <code>object_type</code> is a list) to either <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> and then define a user-function that accepts a <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> object as its input, converts the object to the desired data structure, calculates the statistic of interest, and  returns a numeric value or vector of numeric values. See examples below for an illustration.
</p>
<p>By default, the AMME is calculated by averaging over the distribution of simulated values. If <code>full_output</code> is set to <code>TRUE</code>, the distribution of simualted statistics is returned. This may be useful when the median or mode of the simulated distribution is required or if the researcher wants to inspect the distributional shape of simulated values.
</p>
<p><code>AMME</code> also supports pooled estimation for when multiple <code><a href="ergm.html#topic+ergm">ergm</a></code> or <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects are used as the <code>micro_model</code>. To use pooled estimation, the model parameter should be specified as a list of <code><a href="ergm.html#topic+ergm">ergm</a></code> or <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects. If using <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code>, the <code>SAOM_data</code> argument will also need to be specified as an ordered list with elements corresponding to entries in the list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects. Similarly, the <code>SAOM_var</code> parameter will need to be specified as a list of lists, where each entry in the list is, itself, a list containing all <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects used to calculate macro statistics of interest. Note that <code>SAOM_var</code> should not be provided if the macro statistic of interest is not a function of the variables contained in <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code>.
</p>


<h3>Value</h3>

<p>If <code>full_output=FALSE</code>, then a table is returned with the AMME, its standard error, confidence interval, and p-value.
</p>
<p>If <code>full_output=TRUE</code>, then a list is returned with the following three elements.
</p>
<table>
<tr><td><code>summary_dat</code></td>
<td>
<p>is the table of summary output ucontaining the AMME, its standard error, confidence interval, and p-value.</p>
</td></tr>
<tr><td><code>AMME_obs</code></td>
<td>
<p>is vector of observations where each entry is the AMME for a single simulation trial.</p>
</td></tr>
<tr><td><code>prop_explained_obs</code></td>
<td>
<p>is vector containing the proportion explained values for each simulation trial.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duxbury, Scott W. Associate Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. 2024. &quot;Micro-macro Mediation Analysis in Social Networks.&quot; Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEMS">MEMS</a></code>
<code><a href="ergMargins.html#topic+ergm.mma">ergm.mma</a></code>
<code><a href="mediation.html#topic+mediate">mediate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##############################
#   Basic AMME specifications
#############################


####create ERGM generative model
library(statnet)
data("faux.mesa.high")
ergm_model&lt;-ergm(faux.mesa.high~edges+
                   nodecov("Grade")+
                   nodefactor("Race")+
                   nodefactor("Sex")+
                   nodematch("Race")+
                   nodematch("Sex")+
                   absdiff("Grade"))


###create node-level data for second stage analysis with
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            race=faux.mesa.high%v%"Race",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high))

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high) #define ID for each observation

probit_model&lt;-glm(senior~race+sex+degree,
                data=node_level_data,
                family=binomial(link="probit"))

###estimate the indirect effect of grade homophily on senior status acting through degree centrality
  #in a model with no network control variables
AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id, #specify vertex IDs
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)

#use nonparametric estimation for a generalized additive model
library(gam)

gam_model&lt;-gam(senior~race+sex+s(degree),
               data=node_level_data)

AMME(micro_model=ergm_model,
     macro_model=gam_model,
     micro_process="absdiff.Grade",
     mediator="s(degree)",
     macro_function=degree,
     link_id=node_level_data$v_id,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="nonparametric",
     silent=FALSE)



###estimate AMME with linear network autocorrelation model

lnam_model&lt;-lnam(node_level_data$grade,
                 x=as.matrix(node_level_data[,4:5]),
                 W1=as.sociomatrix(faux.mesa.high))


AMME(micro_model=ergm_model,
     macro_model=lnam_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)




############################
#   Including controls
###########################

##single control
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            race=faux.mesa.high%v%"Race",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high))

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high) #define ID for each observation

probit_model&lt;-glm(senior~race+sex+degree+betweenness,
                  data=node_level_data,
                  family=binomial(link="probit"))


AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id, #specify vertex IDs
     controls="betweenness", #should match model output exactly
     control_functions=betweenness,
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##multiple controls
##include an AR 1 parameter to make it a nonlinear network autocorrelation model
node_level_data$AR1&lt;-as.sociomatrix(faux.mesa.high)%*%node_level_data$senior
probit_model&lt;-glm(senior~race+sex+degree+betweenness+AR1,
                  data=node_level_data,
                  family=binomial(link="probit"))

#specify user function
ar_function&lt;-function(x){
  return(as.sociomatrix(x)%*%node_level_data$senior)
}


AMME(micro_model=ergm_model,
     macro_model=probit_model,
     micro_process="absdiff.Grade",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     controls=c("betweenness","AR1"), #should match model output exactly
     control_functions=list(betweenness,ar_function), #provide functions as a list
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##using identity_function when micro_process has a direct effect on y
  #to use identity_function, the control and micro_process need to have the same
  #name and the macro control variable has to be numeric

node_level_data$Sex&lt;-as.numeric(as.factor(node_level_data$sex))
logit_model&lt;-glm(senior~race+Sex+degree+betweenness+AR1,
                  data=node_level_data,
                  family=binomial)



AMME(micro_model=ergm_model,
     macro_model=logit_model,
     micro_process="nodefactor.Sex.M",
     mediator="degree",
     macro_function=degree,
     link_id=node_level_data$v_id,
     controls=c("betweenness","AR1","Sex"), #should match model output exactly
     control_functions=list(betweenness,ar_function,identity_function),
     object_type="network",
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)





################################
#   More complex data structures
###############################


###############################
# AMME with longitudinal data
##############################

#bootstrap TERGM and panel data model
library(btergm)
library(plm)
data(alliances)

ally_data&lt;-list(LSP[[1]],
                LSP[[2]],
                LSP[[3]])

#fit bootstrap TERGM with 200 replications
bt_model&lt;-btergm(ally_data~edges+
                   gwesp(.7,fixed=T)+
                   mutual,R=200)


#create node data
ally_node_data&lt;-data.frame(outdeg=c(rowSums(LSP[[1]]),rowSums(LSP[[2]]),rowSums(LSP[[3]])),
                           indeg=c(colSums(LSP[[1]]),colSums(LSP[[2]]),colSums(LSP[[3]])))

ally_node_data$v_id&lt;-rep(rownames(LSP[[1]]),3) #create node IDS
ally_node_data$t_id&lt;-c(rep(1, nrow(ally_data[[1]])), #create time IDS
                       rep(2, nrow(ally_data[[1]])),
                       rep(3, nrow(ally_data[[1]])))
ally_node_data$link_id&lt;-paste(ally_node_data$v_id,ally_node_data$t_id)#create node-panel identifiers

ally_node_data$v_id&lt;-as.factor(as.character(ally_node_data$v_id))

#estimate a linear model with node fixed effects
lm_model&lt;- lm(outdeg~indeg +v_id,
          data = ally_node_data)



AMME(micro_model=bt_model,
     macro_model=lm_model,
     micro_process="gwesp.OTP.fixed.0.7",
     mediator="indeg",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=ally_node_data$link_id, #provide node-panel identifiers
     object_type="network",
     interval=c(0,1),
     nsim=11,
     algorithm="nonparametric",
     silent=FALSE)


##include controls at different units of analysis
  #include global transitivity statistic at each network panel
transitivity_list&lt;-c(gtrans(as.network(LSP[[1]])),
                     gtrans(as.network(LSP[[2]])),
                     gtrans(as.network(LSP[[3]])))


ally_node_data$transitivity&lt;-c(rep(transitivity_list[1],nrow(LSP[[1]])),
                               rep(transitivity_list[2],nrow(LSP[[2]])),
                               rep(transitivity_list[3],nrow(LSP[[3]])))



lm_model&lt;- lm(outdeg~indeg+transitivity +v_id,
              data = ally_node_data)



AMME(micro_model=bt_model,
     macro_model=lm_model,
     micro_process="gwesp.OTP.fixed.0.7",
     mediator="indeg",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(ally_node_data$link_id,ally_node_data$t_id),#list of IDs for nodes and time
     controls="transitivity",
     control_functions = gtrans,
     object_type="network",
     interval=c(0,1),
     nsim=11,
     algorithm="nonparametric",
     silent=FALSE)




#SAOM and panel data model with PLM package
library(RSiena)
#specify 3 wave network panel data as DV
network_list&lt;-array(c(s501,s502,s503),dim = c(50,50,3))

Network&lt;-sienaDependent(network_list)
Smoking&lt;-varCovar(s50s)
Alcohol&lt;-varCovar(s50a)
SAOM.Data&lt;-sienaDataCreate(Network=Network,Smoking,Alcohol)

#specify
SAOM.terms&lt;-getEffects(SAOM.Data)
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Alcohol")
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Smoking")
SAOM.terms&lt;-includeEffects(SAOM.terms,transTies,inPop)


create.model&lt;-sienaAlgorithmCreate(projname="netmediate",
                                   nsub=5,
                                   n3=2000)


##estimate the SAOM
SAOM_model&lt;-siena07(create.model,
                        data=SAOM.Data,
                        effects=SAOM.terms,
                        verbose=TRUE)


##create node-level data
node_level_data&lt;-data.frame(smoking=s50s[,1], #smoking behavior for DV
                            alcohol=s50a[,1],
                            v_id=rownames(s501), #unique node IDS
                            wave="Wave 1",       #unique time IDS
                            outdegree=rowSums(s501),
                            indegree=colSums(s501),
                            AR1=s501%*%s50s[,1],  #assign network autocorrelation
                            gcc=gtrans(as.network(s501)))

node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,2],
                                                  alcohol=s50a[,2],
                                                  v_id=rownames(s502),
                                                  wave="Wave 2",
                                                  outdegree=rowSums(s502),
                                                  indegree=colSums(s502),
                                                  AR1=s502%*%s50s[,2],
                                                  gcc=gtrans(as.network(s502))))



node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,3],
                                                  alcohol=s50a[,3],
                                                  v_id=rownames(s503),
                                                  wave="Wave 3",
                                                  outdegree=rowSums(s503),
                                                  indegree=colSums(s503),
                                                  AR1=s503%*%s50s[,3],
                                                  gcc=gtrans(as.network(s503))))


##create unique identifiers for node-panel
node_level_data$unique_ids&lt;-paste(node_level_data$v_id,node_level_data$wave)

##estimate one-way fixed effects model with PLM
library(plm)
FE_model&lt;-plm(smoking~alcohol+outdegree+indegree+AR1+gcc,
               data=node_level_data,
               index=c("v_id","wave"))



##create AR function to provide to AMME
ar_function&lt;-function(x){return(as.sociomatrix(x)%*%(x%v%"Smoking"))}


AMME(micro_model=SAOM_model,
     macro_model=FE_model,
     micro_process="reciprocity",
     mediator="indegree",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(node_level_data$unique_id,node_level_data$unique_id,
                      node_level_data$unique_id,node_level_data$wave),
     object_type="network",
     controls=c("outdegree","AR1","gcc"),
     control_functions=list(function(x){degree(x,cmode="outdegree")},ar_function,gtrans),
     interval=c(0,.1),
     nsim=500,
     algorithm="parametric",
     silent=FALSE,
     SAOM_data = SAOM.Data,
     SAOM_var=list(Smoking=Smoking,Alcohol=Alcohol)) #provide var_list






################################
# AMME with pooled ERGM and SAOM
################################



#pooled ERGM
  #fit two ERGMs to two networks
data("faux.mesa.high")
model1&lt;-ergm(faux.mesa.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))

data("faux.magnolia.high")
model2&lt;-ergm(faux.magnolia.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))


#create node level data
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high),
                            gcc=gtrans(faux.mesa.high),
                            net_id="Mesa")

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high)


node_level_data2&lt;-data.frame(grade=faux.magnolia.high%v%"Grade",
                            sex=faux.magnolia.high%v%"Sex",
                            degree=degree(faux.magnolia.high),
                            betweenness=betweenness(faux.magnolia.high),
                            gcc=gtrans(faux.magnolia.high),
                            net_id="Magnolia")

node_level_data2$senior&lt;-0
node_level_data2$senior[node_level_data$grade==max(node_level_data2$grade)]&lt;-1
node_level_data2$v_id&lt;-206:(network.size(faux.magnolia.high)+205)
node_level_data&lt;-rbind(node_level_data,node_level_data2)


#estimate glm macro model with an AR 1 process
probit_model&lt;-glm(senior~sex+degree+betweenness+gcc,
                data=node_level_data,
                family=binomial(link="probit"))



AMME(micro_model=list(model1,model2),
     macro_model=probit_model,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE)



##pooled SAOM with control functions using time varying covariates

library(RSiena)
#specify 3 wave network panel data as DV
network_list&lt;-array(c(s501,s502,s503),dim = c(50,50,3))

Network&lt;-sienaDependent(network_list)
Smoking&lt;-varCovar(s50s)
Alcohol&lt;-varCovar(s50a)
SAOM.Data&lt;-sienaDataCreate(Network=Network,Smoking,Alcohol)

#specify
SAOM.terms&lt;-getEffects(SAOM.Data)
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Alcohol")
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Smoking")
SAOM.terms&lt;-includeEffects(SAOM.terms,transTies,inPop)


create.model&lt;-sienaAlgorithmCreate(projname="netmediate",
                                   nsub=5,
                                   n3=2000)


##estimate the SAOM
SAOM_model&lt;-siena07(create.model,
                    data=SAOM.Data,
                    effects=SAOM.terms,
                    verbose=TRUE)


##create node-level data
node_level_data&lt;-data.frame(smoking=s50s[,1], #smoking behavior for DV
                            alcohol=s50a[,1],
                            v_id=rownames(s501), #unique node IDS
                            wave="Wave 1",       #unique time IDS
                            outdegree=rowSums(s501),
                            indegree=colSums(s501),
                            AR1=s501%*%s50s[,1],  #assign network autocorrelation
                            gcc=gtrans(as.network(s501)))

node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,2],
                                                  alcohol=s50a[,2],
                                                  v_id=rownames(s502),
                                                  wave="Wave 2",
                                                  outdegree=rowSums(s502),
                                                  indegree=colSums(s502),
                                                  AR1=s502%*%s50s[,2],
                                                  gcc=gtrans(as.network(s502))))



node_level_data&lt;-rbind(node_level_data,data.frame(smoking=s50s[,3],
                                                  alcohol=s50a[,3],
                                                  v_id=rownames(s503),
                                                  wave="Wave 3",
                                                  outdegree=rowSums(s503),
                                                  indegree=colSums(s503),
                                                  AR1=s503%*%s50s[,3],
                                                  gcc=gtrans(as.network(s503))))


#recycle the same model for illustrative purposes
node_level_data$net_ID&lt;-"Model 1"
node_level_data&lt;-rbind(node_level_data,node_level_data)
node_level_data$net_ID[151:300]&lt;-"Model 2"

##create unique identifiers for node-panel
  #ID for node-panel-model
node_level_data$unique_id&lt;-paste(node_level_data$v_id,node_level_data$wave,node_level_data$net_ID)
  #ID for panel-model
node_level_data$unique_waves&lt;-paste(node_level_data$wave,node_level_data$net_ID)

#estimate a linear network autocorrelation model with node fixed effects
FE_model&lt;-lm(smoking~alcohol+outdegree+indegree+AR1+gcc+v_id,
              data=node_level_data)



##create user function calculate AR1 process on time varying node attributes
ar_function&lt;-function(x){return(as.sociomatrix(x)%*%(x%v%"Smoking"))}

##estimate AMME
AMME(micro_model=list(SAOM_model,SAOM_model), #provide list of sienaFit objects
     macro_model=FE_model,
     micro_process="reciprocity",
     mediator="indegree",
     macro_function=function(x){degree(x,cmode="indegree")},
     link_id=list(node_level_data$unique_id,node_level_data$unique_id,
                        node_level_data$unique_id,node_level_data$unique_waves),
     object_type="network",
     controls=c("outdegree","AR1","gcc"),
     control_functions=list(function(x){degree(x,cmode="outdegree")},ar_function,gtrans),
     interval=c(0,.1),
     nsim=100,                  #parametric estimation requires more simulations than coefficients
     algorithm="parametric",
     silent=FALSE,
     SAOM_data = list(SAOM.Data,SAOM.Data), #list of siena objects
     SAOM_var=list(list(Smoking=Smoking,Alcohol=Alcohol),#provide var_list
                  list(Smoking=Smoking,Alcohol=Alcohol)))





#################################
# AMME with nested data
################################

####create dyad-level data

library(lme4)
library(btergm)
##use small data to simplify estimation
glm_dat&lt;-edgeprob(model1)
glm_dat$net_id&lt;-"mesa"
glm_dat2&lt;-edgeprob(model2)
glm_dat2$net_id&lt;-"magnolia"
glm_dat&lt;-rbind(glm_dat,glm_dat2[,-c(4)])


##estimate micro model as glm for btoh networks using pooled ERGM data
net_glm&lt;-glm(tie~nodecov.Grade+
                 nodefactor.Race.Hisp+
                 nodefactor.Race.NatAm+
                 nodefactor.Race.Other+
                 nodefactor.Sex.M+
                 nodematch.Race+
                 nodematch.Sex+
                 absdiff.Grade,
               data=glm_dat)


#create macro data
node_level_data&lt;-data.frame(grade=faux.mesa.high%v%"Grade",
                            sex=faux.mesa.high%v%"Sex",
                            degree=degree(faux.mesa.high),
                            betweenness=betweenness(faux.mesa.high),
                            gcc=gtrans(faux.mesa.high),
                            net_id="Mesa")

node_level_data$senior&lt;-0
node_level_data$senior[node_level_data$grade==max(node_level_data$grade)]&lt;-1
node_level_data$v_id&lt;-1:network.size(faux.mesa.high)


node_level_data2&lt;-data.frame(grade=faux.magnolia.high%v%"Grade",
                             sex=faux.magnolia.high%v%"Sex",
                             degree=degree(faux.magnolia.high),
                             betweenness=betweenness(faux.magnolia.high),
                             gcc=gtrans(faux.magnolia.high),
                             net_id="Magnolia")

node_level_data2$senior&lt;-0
node_level_data2$senior[node_level_data$grade==max(node_level_data2$grade)]&lt;-1
node_level_data2$v_id&lt;-206:(network.size(faux.magnolia.high)+205)
node_level_data&lt;-rbind(node_level_data,node_level_data2)


#estimate glm macro model
probit_model&lt;-glm(senior~sex+degree+betweenness+gcc,
                  data=node_level_data,
                  family=binomial(link="probit"))




AMME(micro_model=net_glm,
     macro_model=probit_model,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE,
     group_id=glm_dat$net_id,
     node_numbers = c(network.size(faux.mesa.high),
                      network.size(faux.magnolia.high)))




###using glmer for micro model
net_glmer&lt;-glmer(tie~nodecov.Grade+
                 nodefactor.Race.Hisp+
                 nodefactor.Race.NatAm+
                 nodefactor.Race.Other+
                 nodefactor.Sex.M+
                 nodematch.Race+
                 nodematch.Sex+
                 absdiff.Grade+
                 (1|net_id),
               data=glm_dat)

probit_glmer&lt;-glm(senior~sex+degree+betweenness+gcc,
                data=node_level_data,
                family=binomial(link="probit"))


AMME(micro_model=net_glm,
     macro_model=probit_glmer,
     micro_process="nodematch.Sex",
     mediator="degree",
     macro_function=degree,
     link_id=list(node_level_data$v_id,node_level_data$v_id,node_level_data$net_id),
     object_type="network",
     controls=c("betweenness","gcc"),
     control_functions=list(betweenness,gtrans),
     interval=c(0,1),
     nsim=50,
     algorithm="parametric",
     silent=FALSE,
     group_id=glm_dat$net_id,
     node_numbers = c(network.size(faux.mesa.high),
                      network.size(faux.magnolia.high)))








</code></pre>

<hr>
<h2 id='identity_function'>Function to map micro_process onto macro_model within calls to <code>AMME</code>.
</h2><span id='topic+identity_function'></span>

<h3>Description</h3>

<p> A function to control for a node-level <code>micro_process</code> in <code>AMME</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identity_function(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identity_function_+3A_x">x</code></td>
<td>
<p>a network object used to transfer <code>micro_process</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used internally with <code>AMME</code></p>

<hr>
<h2 id='MEMS'>
Function to estimate the micro effect on macro structure (MEMS).</h2><span id='topic+MEMS'></span>

<h3>Description</h3>

<p><code>MEMS</code> implements parametric and nonparametric estimation routines to estimate the
micro effect on macro structure when using a generative network model (i.e., a model
where the dyad, dyad-time period, or dyad-group is the unit of analysis). The MEMS is defined in postestimation as a function of the possibly endogenous micro process <code class="reqn">X</code>, which is assumed to be a predictor in the micro model of the form <code class="reqn">A=f(\theta X + \gamma ^TZ)</code>, where <code class="reqn">Z</code> is a matrix of possibly endogenous controls and <code class="reqn">A</code> is the network of interest. The MEMS when <code class="reqn">\theta</code> changes from 0 to 1 is given by </p>
<p style="text-align: center;"><code class="reqn">MEMS=\sum_i \frac{M(\theta, X, \gamma, Z)_i-M(\gamma, Z)_i}{n}</code>
</p>
<p>, for <code class="reqn">n</code> observations. Tuning parameters can be assigned to toggle the strength of <code class="reqn">\theta</code> in model-implied estimates of <code class="reqn">MEMS</code>. <code>MEMS</code> currently accepts <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects and implements both parametric and nonparametric estimation. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEMS(model,
      micro_process,
      macro_function,
      object_type=NULL,
      interval=c(0,1),
      nsim=500,
      algorithm="parametric",
      silent=FALSE,
      full_output=FALSE,
      SAOM_data=NULL,
      SAOM_var=NULL,
      time_interval=NULL,
      covar_list=NULL,
      edgelist=NULL,
      net_logit_y=NULL,
      net_logit_x=NULL,
      group_id=NULL,
      node_numbers=NULL,
      mediator=NULL,
      link_id=NULL,
      controls=NULL,
      control_functions=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEMS_+3A_model">model</code></td>
<td>
<p>the micro-model to be analyzed. Currently accepts <code>glm</code>, <code>glmer</code>, <code>ergm</code>, <code>btergm</code>, <code>sienaFit</code>, <code>rem.dyad</code>, and <code>netlogit</code> objects. Pooled estimation for multiple network models is also implemented for <code>ergm</code> and <code>sienaFit</code> objects. To implement pooled estimation, <code>model</code> should be provided as a list of <code>ergm</code> or <code>sienaFit</code> objects.
</p>
</td></tr>
<tr><td><code id="MEMS_+3A_micro_process">micro_process</code></td>
<td>
<p>a character string containing the name of the micro process of interest. The character string should exactly match coefficient names in <code>model</code> output.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_macro_function">macro_function</code></td>
<td>
<p>a <code>function</code> that calculates the macro statistic of interest. Currently accepts user defined functions as well as functions inherent in the <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code>statnet</code> packages for <span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_object_type">object_type</code></td>
<td>
<p>A character string that tells netmediate the type of object to apply the
<code>macro_function</code> to. Currently accepts <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code><a href="network.html#topic+network">network</a></code> objects. If left <code>NULL</code>, <code><a href="network.html#topic+network">network</a></code> objects are assumed. Can be over-ridden to use other object types with a user-function by defining a function that accepts either a <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> object and returns a numeric value or vector of numeric values (see examples).</p>
</td></tr>
<tr><td><code id="MEMS_+3A_interval">interval</code></td>
<td>
<p>The value of tuning parameters to assign to <code class="reqn">\theta</code>. Should be provided as a vector of numeric values with 2 entries.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations or bootstrap samples to use during estimation.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_algorithm">algorithm</code></td>
<td>
<p>The estimation algorithm to be used. Currently accepts <code>"parametric"</code> and <code>"nonparametric"</code>. If <code>"parametric"</code>, estimation is obtained with Monte Carlo sampling. If <code>"nonparametric"</code>, estimation uses bootstrap resampling.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_silent">silent</code></td>
<td>
<p>logical parameter. Whether to provide updates on the progress of the simulation or not.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_full_output">full_output</code></td>
<td>
<p>logical parameter. If set to <code>TRUE</code>, the entire distribution of simulated statistics will be provided as part of the model output.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_saom_data">SAOM_data</code></td>
<td>
<p>required when the model is a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object; ignored otherwise. If a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object is provided, <code>SAOM_data</code> should be the <code>siena</code> object that contains the data for SAOM estimation. If using pooled estimation on multiple <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects (i.e., providing a list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects), then <code>SAOM_data</code> should be provided as an ordered list with each entry containing the <code><a href="RSiena.html#topic+siena">siena</a></code> object corresponding to list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_saom_var">SAOM_var</code></td>
<td>
<p>optional parameter when the model is a <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object. <code>SAOM_var</code> is a list of of the <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects used to assign time varying node and dyad covariates when calling <code><a href="RSiena.html#topic+sienaDataCreate">sienaDataCreate</a></code>. If provided, <code>netmediate</code> assigns the varying node covariates and dyad covariates to each simulated network. This parameter is required when <code>macro_function</code> computes a statistic that varies as a function of time varying node or dyad covariates (i.e., network segregation, assorativity). Time invariant characteristics (<code><a href="RSiena.html#topic+coCovar">coCovar</a></code> and <code><a href="RSiena.html#topic+coDyadCovar">coDyadCovar</a></code>) are handled internally by <code>MEMS</code> and should not be provided. When providing a list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects for pooled estimation, <code>SAOM_var</code> should be provided as a list of lists, where each entry in the list contains a list of <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects associated with corresponding <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> object. </p>
</td></tr>
<tr><td><code id="MEMS_+3A_time_interval">time_interval</code></td>
<td>
<p>an optional parameter to be used with <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> objects. May be provided as a numeric vector or the character string <code>"aggregate"</code>. If a numeric vector is provided unique network snapshots at each interval. For example, <code>time_interval=c(0,2,3)</code> would induce two networks, one for the 0 - 2 time period and one for the 2 - 3 time period. If specified as <code>"aggregate"</code>, the MEMS is calculated by creating an aggregated cross-sectional representation of the entire event sequence. If left <code>NULL</code>, defaults to |<code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_covar_list">covar_list</code></td>
<td>
<p>an optional list of sender/receiver covariates used in <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> estimation. Only required for <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> objects when covariates are included. The list format should correspond to the format required by <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="MEMS_+3A_edgelist">edgelist</code></td>
<td>
<p>an optional three column edgelist providing the sender, receiver, and time of event occurrence when using rem.<code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code>. Only required when <code>time_interval</code> is set to <code>NULL</code> or <code>"aggregate"</code>. Ignored for other types of models.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_net_logit_y">net_logit_y</code></td>
<td>
<p>the dependent variable for <code><a href="sna.html#topic+netlogit">netlogit</a></code> objects. Should be provided as a vector. Only required when model is a <code><a href="sna.html#topic+netlogit">netlogit</a></code> object.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_net_logit_x">net_logit_x</code></td>
<td>
<p>the matrix of independent variables for <code><a href="sna.html#topic+netlogit">netlogit</a></code> type objects. Only required when model is a <code><a href="sna.html#topic+netlogit">netlogit</a></code> object.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_group_id">group_id</code></td>
<td>
<p>optional vector of group identifiers to use when estimating a <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code> on grouped data (i.e., multiple time periods, multiple networks). When specified,  <code>MEMS</code> will induce unique networks for each grouping factor. If left unspecified, all groups/time periods are pooled. If using <code><a href="lme4.html#topic+glmer">glmer</a></code>, the grouping factor does not have to be provided as part of the model or used as a random effect.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_node_numbers">node_numbers</code></td>
<td>
<p>a numeric vector containing the number of nodes in each group_id when using <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code>. If estimating MEMS aggregated over all networks (i.e., <code>group_id=NULL</code>), this shoud be the total number of nodes in all networks. Required when using <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code>, ignored otherwise.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_mediator">mediator</code></td>
<td>
<p>a character string detailing the mediator of interest. Intended for internal use with the <code><a href="#topic+AMME">AMME</a></code> function; not intended for end users.</p>
</td></tr>
<tr><td><code id="MEMS_+3A_link_id">link_id</code></td>
<td>
<p>a vector or list of vectors corresponding to unique identifiers. Intended for internal use with the <code><a href="#topic+AMME">AMME</a></code> function; not intended for end users. </p>
</td></tr>
<tr><td><code id="MEMS_+3A_controls">controls</code></td>
<td>
<p>a vector of character strings listing the controls to be calculated when using <code><a href="#topic+AMME">AMME</a></code>. Intended for internal use with the <code><a href="#topic+AMME">AMME</a></code> function; not intended for end users. </p>
</td></tr>
<tr><td><code id="MEMS_+3A_control_functions">control_functions</code></td>
<td>
<p>a list of functions to calculate the macro control variables provided in controls. Intended for internal use with the <code><a href="#topic+AMME">AMME</a></code> function; not intended for end users. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the MEMS over the provided intervals. If the macro statistic is calculated on the node or subgraph levels or on multiple network observations, the aMEMS is provided instead. Standard errors and confidence intervals are based on the sampling distribution of simulated values, which are calculated either parametrically or nonparametrically according to <code>algorithm</code>. Parametric estimation is typically faster, but cannot be used for nonparametric network models (e.g., quadratic assignment procedure).
</p>
<p><code>macro_function</code> is the workhorse component of MEMS. The function should calculate the macro statistic of interest. <code>netmediate</code> currently supports functions calculated on <code><a href="igraph.html#topic+igraph">igraph</a></code> and <code><a href="network.html#topic+network">network</a></code> objects, which should be specified as using the <code>object_type</code> argument. These may be functions inherent to the <code><a href="statnet.html#topic+statnet">statnet</a></code> and <code><a href="igraph.html#topic+igraph">igraph</a></code> software package or they may be functions from other packages that accept <code><a href="network.html#topic+network">network</a></code>/<code><a href="igraph.html#topic+igraph">igraph</a></code> objects. They may also be user-defined functions that accept <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> objects as input and return a numeric value or vector of numeric values as output. It is also possible to over-ride the <code><a href="network.html#topic+network">network</a></code> and <code><a href="igraph.html#topic+igraph">igraph</a></code> object requirements within a user function. To do so, set the <code>object_type</code> argument to either <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> and then define a user-function that accepts a <code><a href="network.html#topic+network">network</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> object as its input, converts the object to the desired data structure, calculates the statistic of interest, and finally returns a numeric value or vector of numeric values. See examples below for an illustration.
</p>
<p>By default, the MEMS is provided by averaging over the distribution of simulated values. If <code>full_output</code> is set to <code>TRUE</code>, the entire distribution of simualted statistics is returned. This may be useful when the median or mode of the simulated distribution is required or if the researcher wants to inspect the distributional shape of simulated values.
</p>
<p><code>MEMS</code> also supports pooled estimation for multiple <code><a href="ergm.html#topic+ergm">ergm</a></code> or <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects. To use pooled estimation, the model parameter should be specified as a list of <code><a href="ergm.html#topic+ergm">ergm</a></code> or <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects. If using <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code>, the <code>SAOM_data</code> argument will also need to be specified as an ordered list with elements corresponding to entries in the list of <code><a href="RSiena.html#topic+sienaFit">sienaFit</a></code> objects. Similarly, the <code>SAOM_var</code> parameter will need to be specified as a list of lists, where each entry in the list is, itself, a list containing all <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code> objects used to calculate macro statistics of interest. Note that <code>SAOM_var</code> should not be provided if the macro statistic of interest is not a function of the variables contained in <code><a href="RSiena.html#topic+varCovar">varCovar</a></code> and <code><a href="RSiena.html#topic+varDyadCovar">varDyadCovar</a></code>.
</p>
<p>When estimating a relational event model with a <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> object, <code>time_interval</code> can be specified to provide exact time intervals over which to induce unique networks. This utility is often useful when combining <code><a href="relevent.html#topic+rem.dyad">rem.dyad</a></code> estimation with <code><a href="#topic+AMME">AMME</a></code> when the <code>macro_model</code> is panel data with coarse timing information. The same behavior can be obtained when estimating a relational event model using <code>glm</code> or <code><a href="lme4.html#topic+glmer">glmer</a></code> by assigning the desired time intervals in the model matrix and then providing the vector of time intervals to the <code>group_id</code> parameter when calling <code>MEMS</code>.
</p>


<h3>Value</h3>

<p>If <code>full_output=FALSE</code>, then a table is returned with the MEMS, its standard error, confidence interval, and p-value.
</p>
<p>If <code>full_output=TRUE</code>, then a list is returned with the following three elements.
</p>
<table>
<tr><td><code>summary_dat</code></td>
<td>
<p>is the table of summary output containing the MEMS, its standard error, confidence interval, and p-value.</p>
</td></tr>
<tr><td><code>output_data</code></td>
<td>
<p>is a matrix where each row is a simulated draw of the MEMS (or a simulation draw for a specific network in the case of temporal data or pooled estimation) and each column corresponds to a unique value provided in the interval argument.</p>
</td></tr>
<tr><td><code>mems_samples</code></td>
<td>
<p>is vector matrix corresponding where each row is a simulated draw of the MEM (or a simulation draw for a specific network in the case of temporal data or pooled estimation) and each column represents the differences in MEMS/aMEMS when subtracting the value of a macro statistic at one interval level from the next highest interval level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duxbury, Scott W. Associate Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. 2024. &quot;Micro Effects on Macro Structure in Social Networks.&quot; Sociological Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AMME">AMME</a></code>
<code><a href="ergMargins.html#topic+ergm.mma">ergm.mma</a></code>
<code><a href="mediation.html#topic+mediate">mediate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


########################################
# ERGM examples and basic utilities
#######################################


####start with a simple model
library(statnet)

data("faux.mesa.high")

model1&lt;-ergm(faux.mesa.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))



##calculate the MEMS when the absolute difference in grade is changed from an interval of 0 to 1
  #with default specifications for gtrans
MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = gtrans,
     object_type = "network",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")

#call an argument from gtrans by specifying it as a function
  #use nonparametric estimation
MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = function(x){gtrans(x,measure="strongcensus")},
     object_type = "network",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "nonparametric")




####calculate the MEMS using igraph
MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = function(x){igraph::transitivity(x,type="local")},
     object_type = "igraph",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")



##specify a user function that counts the number of communities
community_counts&lt;-function(x){
  walktrap&lt;-igraph::walktrap.community(x) #use walktrap community detection
  return(length(unique(walktrap$membership))) #return the number of communities
}

MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = community_counts,
     object_type = "igraph",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")



##calculate a function using exogenous node attributes
assortativity_grade&lt;-function(x){
  require(igraph)
  return(assortativity_nominal(x,V(x)$Grade))
}

MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = assortativity_grade,
     object_type = "igraph",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")

##specify a user function that does not depend on either igraph or statnet
  #assuming a network input object, we have
manual_user_function&lt;-function(x){
  x&lt;-as.sociomatrix(x)
  return(colSums(x))
}

MEMS(model1,
     micro_process="absdiff.Grade",
     macro_function = manual_user_function,
     object_type = "network",
     nsim=100,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")







####estimation for POOLED ERGM
data("faux.magnolia.high")

model2&lt;-ergm(faux.magnolia.high~edges+
               nodecov("Grade")+
               nodefactor("Race")+
               nodefactor("Sex")+
               nodematch("Race")+
               nodematch("Sex")+
               absdiff("Grade"))



MEMS(list(model1,model2),
     micro_process="absdiff.Grade",
     macro_function = assortativity_grade,
     object_type = "igraph",
     nsim=50,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "parametric")



#################################
#   Estimation with GLM and GLMER
#################################
library(btergm)

#use models 1 and 2 from examples above
glm_dat&lt;-edgeprob(model1)
glm_dat2&lt;-edgeprob(model2)
glm_dat2&lt;-glm_dat2[,-c(4)]


##create stacked dataset for the purposes of grouped estimation
glm_dat$net_id&lt;-"mesa" #specify ID for each network
glm_dat2$net_id&lt;-"magnolia"
glm_dat&lt;-rbind(glm_dat,glm_dat2)


##estimate as a linear probability model
net_glm&lt;-glm(tie~nodecov.Grade+
               nodefactor.Race.Hisp+
               nodefactor.Race.NatAm+
               nodefactor.Race.Other+
               nodefactor.Sex.M+
               nodematch.Race+
               nodematch.Sex+
               absdiff.Grade,
             data=glm_dat)



MEMS(net_glm,
     micro_process="nodematch.Race", #should be written as in netlogit output
     macro_function = function(x){gtrans(x)},
     object_type = "network",
     nsim=100,
     interval=c(0,.5),
     silent=FALSE,
     full_output = FALSE,
     algorithm = "parametric",
     group_id=glm_dat$net_id, #provide network ID for estimation
     node_numbers =c(network.size(faux.mesa.high), #provide the number of nodes in each network
                      network.size(faux.magnolia.high)))


##estimate as a multilevel model
library(lme4)
net_glmer&lt;-glmer(tie~nodecov.Grade+
               nodefactor.Race.Hisp+
               nodefactor.Race.NatAm+
               nodefactor.Race.Other+
               nodefactor.Sex.M+
               nodematch.Race+
               nodematch.Sex+
               absdiff.Grade+
                 (1|net_id),
             data=glm_dat,
             family=gaussian)



MEMS(net_glmer,
     micro_process="nodematch.Race", #should be written as in netlogit output
     macro_function = function(x){gtrans(x)},
     object_type = "network",
     nsim=50,
     interval=c(0,.5),
     silent=FALSE,
     full_output = FALSE,
     algorithm = "parametric",
     group_id=glm_dat$net_id,
     node_numbers =c(203,974))




##############################################
##nonparametric estimation for bootstrap TERGM
##############################################

library(btergm)
data(alliances)
ally_data&lt;-list(LSP[[1]],
                LSP[[2]],
                LSP[[3]])

bt_model&lt;-btergm(ally_data~edges+
                   gwesp(.7,fixed=T)+
                   mutual,R=200)



MEMS(bt_model,
     micro_process="gwesp.OTP.fixed.0.7",
     macro_function = gtrans,
     object_type = "network",
     nsim=50,
     interval=c(0,1),
     silent=FALSE,
     algorithm = "nonparametric")





################################
# Parametric estimation using SAOM
##################################
library(RSiena)
#specify 3 wave network panel data as DV
network_list&lt;-array(c(s501,s502,s503),dim = c(50,50,3))

Network&lt;-sienaDependent(network_list)
Smoking&lt;-varCovar(s50s)
Alcohol&lt;-varCovar(s50a)
SAOM.Data&lt;-sienaDataCreate(Network=Network,Smoking,Alcohol)

#specify
SAOM.terms&lt;-getEffects(SAOM.Data)
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Alcohol")
SAOM.terms&lt;-includeEffects(SAOM.terms,egoX,altX,sameX,interaction1="Smoking")
SAOM.terms&lt;-includeEffects(SAOM.terms,transTies,inPop)


create.model&lt;-sienaAlgorithmCreate(projname="netmediate",
                                   nsub=5,
                                   n3=2000)


##estimate the model using siena07
SAOM_model&lt;-siena07(create.model,
                        data=SAOM.Data,
                        effects=SAOM.terms,
                        verbose=TRUE)


SAOM_model




##basic specification for reciprocity effects on outdegree distribution
MEMS(SAOM_model,
     micro_process="reciprocity", #should be written as in SIENA output
     macro_function = function(x){igraph::degree(x,mode="out")},
     object_type = "igraph",
     interval=c(0,.5),
     SAOM_data=SAOM.Data,
     silent=FALSE,
     algorithm = "parametric")



##include user functions on time varying covariates
assortativity_smoking&lt;-function(x){
  return(assortativity_nominal(x,V(x)$Smoking))
}


MEMS(SAOM_model,
     micro_process="reciprocity",
     macro_function = assortativity_smoking,
     object_type = "igraph",
     interval=c(0,.5),
     SAOM_data=SAOM.Data,
     SAOM_var=list(Smoking=Smoking,Alcohol=Alcohol), #Smoking and Alcohol are varCovar objects
     silent=FALSE,
     full_output = FALSE,
     algorithm = "parametric")




###Pooled SAOM
MEMS(list(SAOM_model,SAOM_model),
     micro_process="reciprocity",
     macro_function = gtrans,
     object_type = "network",
     interval=c(0,.5),
     SAOM_data=list(SAOM.Data,SAOM.Data),
     silent=FALSE,
     full_output = FALSE,
     nsim=100,
     algorithm = "parametric")


#Pooled SAOM with user functions and time varying attributes
assortativity_smoking&lt;-function(x){
  return(assortativity_nominal(x,V(x)$Smoking))
}



MEMS(list(SAOM_model,SAOM_model),
     micro_process="reciprocity",
     macro_function = assortativity_smoking,
     object_type = "igraph",
     interval=c(0,.5),
     SAOM_data=list(SAOM.Data,SAOM.Data),
     SAOM_var=list(list(Smoking=Smoking,Alcohol=Alcohol),
                    list(Smoking=Smoking,Alcohol=Alcohol)),
     silent=FALSE,
     full_output = FALSE,
     nsim=100,
     algorithm = "parametric")








################################################
## Selection and Influence in SAOM when analyzing
## co-evolution of networks and behavior
################################################


##Example Moran decomposition
library(RSiena)

###run the model--taken from RSiena scripts

# prepare first two waves of s50 data for RSiena analysis:
(thedata &lt;- sienaDataCreate(
  friendship = sienaDependent(array(
    c(s501,s502),dim=c(50,50,2))),
  drinking = sienaDependent(s50a[,1:2])
))

# specify a model with (generalised) selection and influence:
themodel &lt;- getEffects(thedata)
themodel &lt;- includeEffects(themodel,name='friendship',gwespFF)
themodel &lt;- includeEffects(themodel,name='friendship',simX,interaction1='drinking')
themodel &lt;- includeEffects(themodel,name='drinking',avSim,interaction1='friendship')
themodel



# estimate this model:
estimation.options &lt;- sienaAlgorithmCreate(projname='results',cond=FALSE,seed=1234567)
(theresults &lt;- siena07(estimation.options,data=thedata,effects=themodel))



##calculate MEMS for selection effect
  #Uses Moran_dv--a function internally called by netmediate
  #to calculate change in amount of network autocorrelation
  #as a function of both endogenous behavior and network dependent
  #variables

MEMS(theresults,
     micro_process="drinking similarity",
     macro_function =Moran_dv,
     object_type = "network",
     SAOM_data = thedata,
     silent=FALSE,
     nsim=50)

#just influence
MEMS(theresults,
     micro_process="drinking average similarity",
     macro_function =Moran_dv,
     object_type = "network",
     SAOM_data = thedata,
     silent=FALSE,
     nsim=50)

##joint effect of selection and influence
MEMS(theresults,
     micro_process=c("drinking similarity","drinking average similarity"),
     macro_function =Moran_dv,
     object_type = "network",
     SAOM_data = thedata,
     silent=FALSE,
     nsim=500)







#######################################
# Relational event models using relevent
#######################################
set.seed(21093)
library(relevent)
##generate a network with 15 discrete time periods
  #example based on relevent rem.dyad example
library(relevent)
roweff&lt;-rnorm(10) #Build rate matrix
roweff&lt;-roweff-roweff[1] #Adjust for later convenience
coleff&lt;-rnorm(10)
coleff&lt;-coleff-coleff[1]
lambda&lt;-exp(outer(roweff,coleff,"+"))
diag(lambda)&lt;-0
ratesum&lt;-sum(lambda)
esnd&lt;-as.vector(row(lambda)) #List of senders/receivers
erec&lt;-as.vector(col(lambda))
time&lt;-0
edgelist&lt;-vector()
while(time&lt;15){ # Observe the system for 15 time units
  drawsr&lt;-sample(1:100,1,prob=as.vector(lambda)) #Draw from model
  time&lt;-time+rexp(1,ratesum)
  if(time&lt;=15) #Censor at 15
    edgelist&lt;-rbind(edgelist,c(time,esnd[drawsr],erec[drawsr]))
  else
    edgelist&lt;-rbind(edgelist,c(15,NA,NA))
}
effects&lt;-c("CovSnd","FERec")



##estimate model
fit.time&lt;-rem.dyad(edgelist,10,effects=effects,
                   covar=list(CovSnd=roweff),
                   ordinal=FALSE,hessian=TRUE)


###aggregate estimation
MEMS(fit.time,
     micro_process="CovSnd.1", #should be written as in relevent output
     macro_function = function(x){sna::degree(x)},
     object_type = "network",
     nsim=10,
     interval=c(0,.5),
     silent=FALSE,
     covar_list=list(CovSnd=roweff), #covariate effects
     time_interval="aggregate", ##aggregated estimation
     edgelist=edgelist,
     algorithm = "parametric")


##time interval estimation
##estimation with time intervals
MEMS(fit.time,
     micro_process="CovSnd.1",
     macro_function = function(x){igraph::degree(x)},
     object_type = "igraph",
     nsim=10,
     interval=c(0,.1),
     silent=TRUE,
     covar_list=list(CovSnd=roweff),
     time_interval=c(0,5,10,15), #specify three time intervals, 0 - 5, 5 - 10, and 10 - 15
     algorithm = "parametric")







########################################################
# Network regression with quadratic assignment procedure
########################################################
library(sna)
##generate network data
set.seed(21093)
x&lt;-rgraph(20,4)
y.l&lt;-x[1,,]+4*x[2,,]+2*x[3,,]
y.p&lt;-apply(y.l,c(1,2),function(a){1/(1+exp(-a))})
y&lt;-rgraph(20,tprob=y.p)

nl&lt;-netlogit(y,x,reps=100)
summary(nl)



MEMS(nl,
     micro_process="x2", #should be written as in netlogit output
     macro_function = function(x){degree(x)},
     object_type = "igraph",
     nsim=20,
     interval=c(0,1),
     silent=FALSE,
     full_output = FALSE,
     net_logit_y=y,
     net_logit_x=x,
     algorithm = "nonparametric")















</code></pre>

<hr>
<h2 id='Moran_dv'>Function to calculate Moran's first order network autocorrelation in co-evolution SAOM.
</h2><span id='topic+Moran_dv'></span>

<h3>Description</h3>

<p> A function to calculate Moran's first order network autocorrelation in co-evolution SAOM using both the endogenous dependent variables (behavior and network functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Moran_dv(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moran_dv_+3A_network">network</code></td>
<td>
<p>a network object used to calculate autocorrelation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used internally with <code>MEMS</code> and <code>AMME</code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
