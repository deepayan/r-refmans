<!DOCTYPE html><html><head><title>Help for package actuar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {actuar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#actuar-package'><p>Actuarial Functions and Heavy Tailed Distributions</p></a></li>
<li><a href='#adjCoef'><p>Adjustment Coefficient</p></a></li>
<li><a href='#aggregateDist'><p>Aggregate Claim Amount Distribution</p></a></li>
<li><a href='#betaint'><p>The &ldquo;Beta Integral&rdquo;</p></a></li>
<li><a href='#BetaMoments'><p>Raw and Limited Moments of the Beta Distribution</p></a></li>
<li><a href='#Burr'><p>The Burr Distribution</p></a></li>
<li><a href='#ChisqSupp'><p>Moments and Moment Generating Function of the (non-central) Chi-Squared Distribution</p></a></li>
<li><a href='#cm'><p>Credibility Models</p></a></li>
<li><a href='#coverage'><p>Density and Cumulative Distribution Function for Modified Data</p></a></li>
<li><a href='#CTE'><p>Conditional Tail Expectation</p></a></li>
<li><a href='#dental'><p>Individual Dental Claims Data Set</p></a></li>
<li><a href='#discretize'><p>Discretization of a Continuous Distribution</p></a></li>
<li><a href='#elev'><p>Empirical Limited Expected Value</p></a></li>
<li><a href='#emm'><p>Empirical Moments</p></a></li>
<li><a href='#ExponentialSupp'><p>Moments and Moment Generating Function of the Exponential Distribution</p></a></li>
<li><a href='#Extract.grouped.data'><p>Extract or Replace Parts of a Grouped Data Object</p></a></li>
<li><a href='#FellerPareto'><p>The Feller Pareto Distribution</p></a></li>
<li><a href='#GammaSupp'><p>Moments and Moment Generating Function of the Gamma Distribution</p></a></li>
<li><a href='#gdental'><p>Grouped Dental Claims Data Set</p></a></li>
<li><a href='#GeneralizedBeta'><p>The Generalized Beta Distribution</p></a></li>
<li><a href='#GeneralizedPareto'><p>The Generalized Pareto Distribution</p></a></li>
<li><a href='#grouped.data'><p>Grouped data</p></a></li>
<li><a href='#Gumbel'><p>The Gumbel Distribution</p></a></li>
<li><a href='#hachemeister'><p>Hachemeister Data Set</p></a></li>
<li><a href='#hist.grouped.data'><p>Histogram for Grouped Data</p></a></li>
<li><a href='#InverseBurr'><p>The Inverse Burr Distribution</p></a></li>
<li><a href='#InverseExponential'><p>The Inverse Exponential Distribution</p></a></li>
<li><a href='#InverseGamma'><p>The Inverse Gamma Distribution</p></a></li>
<li><a href='#InverseGaussian'><p>The Inverse Gaussian Distribution</p></a></li>
<li><a href='#InverseParalogistic'><p>The Inverse Paralogistic Distribution</p></a></li>
<li><a href='#InversePareto'><p>The Inverse Pareto Distribution</p></a></li>
<li><a href='#InverseTransformedGamma'><p>The Inverse Transformed Gamma Distribution</p></a></li>
<li><a href='#InverseWeibull'><p>The Inverse Weibull Distribution</p></a></li>
<li><a href='#Logarithmic'><p>The Logarithmic Distribution</p></a></li>
<li><a href='#Loggamma'><p>The Loggamma Distribution</p></a></li>
<li><a href='#Loglogistic'><p>The Loglogistic Distribution</p></a></li>
<li><a href='#LognormalMoments'><p>Raw and Limited Moments of the Lognormal Distribution</p></a></li>
<li><a href='#mde'><p>Minimum Distance Estimation</p></a></li>
<li><a href='#mean.grouped.data'><p>Arithmetic Mean</p></a></li>
<li><a href='#NormalSupp'><p>Moments and Moment generating function of the Normal Distribution</p></a></li>
<li><a href='#ogive'><p>Ogive for Grouped Data</p></a></li>
<li><a href='#Paralogistic'><p>The Paralogistic Distribution</p></a></li>
<li><a href='#Pareto'><p>The Pareto Distribution</p></a></li>
<li><a href='#Pareto2'><p>The Pareto II Distribution</p></a></li>
<li><a href='#Pareto3'><p>The Pareto III Distribution</p></a></li>
<li><a href='#Pareto4'><p>The Pareto IV Distribution</p></a></li>
<li><a href='#PhaseType'><p>The Phase-type Distribution</p></a></li>
<li><a href='#PoissonInverseGaussian'><p>The Poisson-Inverse Gaussian Distribution</p></a></li>
<li><a href='#quantile.aggregateDist'><p>Quantiles of Aggregate Claim Amount Distribution</p></a></li>
<li><a href='#quantile.grouped.data'><p>Quantiles of Grouped Data</p></a></li>
<li><a href='#rcomphierarc'><p>Simulation from Compound Hierarchical Models</p></a></li>
<li><a href='#rcomphierarc.summaries'><p>Summary Statistics of a Portfolio</p></a></li>
<li><a href='#rcompound'><p>Simulation from Compound Models</p></a></li>
<li><a href='#rmixture'><p>Simulation from Discrete Mixtures</p></a></li>
<li><a href='#ruin'><p>Probability of Ruin</p></a></li>
<li><a href='#severity'><p>Manipulation of Individual Claim Amounts</p></a></li>
<li><a href='#SingleParameterPareto'><p>The Single-parameter Pareto Distribution</p></a></li>
<li><a href='#TransformedBeta'><p>The Transformed Beta Distribution</p></a></li>
<li><a href='#TransformedGamma'><p>The Transformed Gamma Distribution</p></a></li>
<li><a href='#UniformSupp'><p>Moments and Moment Generating Function of the Uniform Distribution</p></a></li>
<li><a href='#unroll'><p>Display a Two-Dimension Version of a Matrix of Vectors</p></a></li>
<li><a href='#var'><p>Variance and Standard Deviation</p></a></li>
<li><a href='#VaR'><p>Value at Risk</p></a></li>
<li><a href='#WeibullMoments'><p>Raw and Limited Moments of the Weibull Distribution</p></a></li>
<li><a href='#ZeroModifiedBinomial'><p>The Zero-Modified Binomial Distribution</p></a></li>
<li><a href='#ZeroModifiedGeometric'><p>The Zero-Modified Geometric Distribution</p></a></li>
<li><a href='#ZeroModifiedLogarithmic'><p>The Zero-Modified Logarithmic Distribution</p></a></li>
<li><a href='#ZeroModifiedNegativeBinomial'><p>The Zero-Modified Negative Binomial Distribution</p></a></li>
<li><a href='#ZeroModifiedPoisson'><p>The Zero-Modified Poisson Distribution</p></a></li>
<li><a href='#ZeroTruncatedBinomial'><p>The Zero-Truncated Binomial Distribution</p></a></li>
<li><a href='#ZeroTruncatedGeometric'><p>The Zero-Truncated Geometric Distribution</p></a></li>
<li><a href='#ZeroTruncatedNegativeBinomial'><p>The Zero-Truncated Negative Binomial Distribution</p></a></li>
<li><a href='#ZeroTruncatedPoisson'><p>The Zero-Truncated Poisson Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Actuarial Functions and Heavy Tailed Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and data sets for actuarial science:
  modeling of loss distributions; risk theory and ruin theory;
  simulation of compound models, discrete mixtures and compound
  hierarchical models; credibility theory. Support for many additional
  probability distributions to model insurance loss size and
  frequency: 23 continuous heavy tailed distributions; the
  Poisson-inverse Gaussian discrete distribution; zero-truncated and
  zero-modified extensions of the standard discrete distributions.
  Support for phase-type distributions commonly used to compute ruin
  probabilities. Main reference: &lt;<a href="https://doi.org/10.18637%2Fjss.v025.i07">doi:10.18637/jss.v025.i07</a>&gt;.
  Implementation of the Feller-Pareto family of distributions:
  &lt;<a href="https://doi.org/10.18637%2Fjss.v103.i06">doi:10.18637/jss.v103.i06</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, expint</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>expint</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/vigou3/actuar">https://gitlab.com/vigou3/actuar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/vigou3/actuar/-/issues">https://gitlab.com/vigou3/actuar/-/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Classification/MSC-2010:</td>
<td>62P05, 91B30, 62G32</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-08 01:10:54 UTC; vincent</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Goulet [cre, aut],
  SÃ©bastien Auclair [ctb],
  Christophe Dutang [aut],
  Walter Garcia-Fontes [ctb],
  Nicholas Langevin [ctb],
  Xavier Milhaud [ctb],
  Tommy Ouellet [ctb],
  Alexandre Parent [ctb],
  Mathieu Pigeon [aut],
  Louis-Philippe Pouliot [ctb],
  Jeffrey A. Ryan [aut] (Package API),
  Robert Gentleman [aut] (Parts of the R to C interface),
  Ross Ihaka [aut] (Parts of the R to C interface),
  R Core Team [aut] (Parts of the R to C interface),
  R Foundation [aut] (Parts of the R to C interface)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent Goulet &lt;vincent.goulet@act.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-08 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='actuar-package'>Actuarial Functions and Heavy Tailed Distributions</h2><span id='topic+actuar-package'></span><span id='topic+actuar'></span>

<h3>Description</h3>

<p>Functions and data sets for actuarial science:
  modeling of loss distributions; risk theory and ruin theory;
  simulation of compound models, discrete mixtures and compound
  hierarchical models; credibility theory. Support for many additional
  probability distributions to model insurance loss size and
  frequency: 23 continuous heavy tailed distributions; the
  Poisson-inverse Gaussian discrete distribution; zero-truncated and
  zero-modified extensions of the standard discrete distributions.
  Support for phase-type distributions commonly used to compute ruin
  probabilities. Main reference: &lt;doi:10.18637/jss.v025.i07&gt;.
  Implementation of the Feller-Pareto family of distributions:
  &lt;doi:10.18637/jss.v103.i06&gt;.</p>


<h3>Details</h3>

<p><span class="pkg">actuar</span> provides additional actuarial science
functionality and support for heavy tailed distributions to the <span class="rlang"><b>R</b></span>
statistical system.
</p>
<p>The current feature set of the package can be split into five main
categories.
</p>

<ol>
<li><p>Additional probability distributions: 23 continuous heavy
tailed distributions from the Feller-Pareto and Transformed
Gamma families, the loggamma, the Gumbel, the inverse Gaussian
and the generalized beta; phase-type distributions; the
Poisson-inverse Gaussian discrete distribution; zero-truncated and
zero-modified extensions of the standard discrete distributions;
computation of raw moments, limited moments and the moment
generating function (when it exists) of continuous distributions.
See the &ldquo;distributions&rdquo; package vignette for details.
</p>
</li>
<li><p>Loss distributions modeling: extensive support of grouped
data; functions to compute empirical raw and limited moments;
support for minimum distance estimation using three different
measures; treatment of coverage modifications (deductibles,
limits, inflation, coinsurance). See the &ldquo;modeling&rdquo; and
&ldquo;coverage&rdquo; package vignettes for details.
</p>
</li>
<li><p>Risk and ruin theory: discretization of the claim amount
distribution; calculation of the aggregate claim amount
distribution; calculation of the adjustment coefficient;
calculation of the probability of ruin, including using phase-type
distributions. See the &ldquo;risk&rdquo; package vignette for details.
</p>
</li>
<li><p>Simulation of discrete mixtures, compound models (including
the compound Poisson), and compound hierarchical models. See the
&ldquo;simulation&rdquo; package vignette for details.
</p>
</li>
<li><p>Credibility theory: function <code>cm</code> fits hierarchical
(including BÃ¼hlmann, BÃ¼hlmann-Straub), regression and linear Bayes
credibility models. See the &ldquo;credibility&rdquo; package vignette
for details.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Christophe Dutang, Vincent Goulet, Mathieu Pigeon and many other
contributors; use <code>packageDescription("actuar")</code> for the complete
list.
</p>
<p>Maintainer: Vincent Goulet.
</p>


<h3>References</h3>

<p>Dutang, C., Goulet, V. and Pigeon, M. (2008).
actuar: An R Package for Actuarial Science.
<em>Journal of Statistical Software</em>, <b>25</b>(7), 1&ndash;37.
<a href="https://doi.org/10.18637/jss.v025.i07">doi:10.18637/jss.v025.i07</a>.
</p>
<p>Dutang, C., Goulet, V., Langevin, N. (2022).
Feller-Pareto and Related Distributions: Numerical Implementation and Actuarial
Applications.
<em>Journal of Statistical Software</em>, <b>103</b>(6), 1&ndash;22.
<a href="https://doi.org/10.18637/jss.v103.i06">doi:10.18637/jss.v103.i06</a>.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p>For probability distributions support functions, use as starting
points:
<code><a href="#topic+FellerPareto">FellerPareto</a></code>, 
<code><a href="#topic+TransformedGamma">TransformedGamma</a></code>, 
<code><a href="#topic+Loggamma">Loggamma</a></code>, 
<code><a href="#topic+Gumbel">Gumbel</a></code>, 
<code><a href="#topic+InverseGaussian">InverseGaussian</a></code>, 
<code><a href="#topic+PhaseType">PhaseType</a></code>, 
<code><a href="#topic+PoissonInverseGaussian">PoissonInverseGaussian</a></code> and, e.g.,
<code><a href="#topic+ZeroTruncatedPoisson">ZeroTruncatedPoisson</a></code>, 
<code><a href="#topic+ZeroModifiedPoisson">ZeroModifiedPoisson</a></code>.
</p>
<p>For loss modeling support functions:
<code><a href="#topic+grouped.data">grouped.data</a></code>,
<code><a href="#topic+ogive">ogive</a></code>,
<code><a href="#topic+emm">emm</a></code>,
<code><a href="#topic+elev">elev</a></code>,
<code><a href="#topic+mde">mde</a></code>,
<code><a href="#topic+coverage">coverage</a></code>.
</p>
<p>For risk and ruin theory functions:
<code><a href="#topic+discretize">discretize</a></code>,
<code><a href="#topic+aggregateDist">aggregateDist</a></code>,
<code><a href="#topic+adjCoef">adjCoef</a></code>,
<code><a href="#topic+ruin">ruin</a></code>.
</p>
<p>For credibility theory functions and datasets:
<code><a href="#topic+cm">cm</a></code>,
<code><a href="#topic+hachemeister">hachemeister</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The package comes with extensive demonstration scripts;
## use the following command to obtain the list.
## Not run: demo(package = "actuar")
</code></pre>

<hr>
<h2 id='adjCoef'>Adjustment Coefficient</h2><span id='topic+adjCoef'></span><span id='topic+plot.adjCoef'></span>

<h3>Description</h3>

<p>Compute the adjustment coefficient in ruin theory, or return a
function to compute the adjustment coefficient for various reinsurance
retentions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjCoef(mgf.claim, mgf.wait = mgfexp, premium.rate, upper.bound,
        h, reinsurance = c("none", "proportional", "excess-of-loss"),
        from, to, n = 101)

## S3 method for class 'adjCoef'
plot(x, xlab = "x", ylab = "R(x)",
     main = "Adjustment Coefficient", sub = comment(x),
     type = "l", add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjCoef_+3A_mgf.claim">mgf.claim</code></td>
<td>
<p>an expression written as a function of <code>x</code> or of
<code>x</code> and <code>y</code>, or alternatively the name of a function,
giving the moment generating function (mgf) of the claim severity
distribution.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_mgf.wait">mgf.wait</code></td>
<td>
<p>an expression written as a function of <code>x</code>, or
alternatively the name of a function, giving the mgf of the
claims interarrival time distribution. Defaults to an exponential
distribution with mean 1.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_premium.rate">premium.rate</code></td>
<td>
<p>if <code>reinsurance = "none"</code>, a numeric value of
the premium rate; otherwise, an expression written as a function of
<code>y</code>, or alternatively the name of a function, giving the
premium rate function.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_upper.bound">upper.bound</code></td>
<td>
<p>numeric; an upper bound for the coefficient,
usually the upper bound of the support of the claim severity mgf.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_h">h</code></td>
<td>
<p>an expression written as a function of <code>x</code> or of
<code>x</code> and <code>y</code>, or alternatively the name of a function,
giving function <code class="reqn">h</code> in the Lundberg equation (see below);
ignored if <code>mgf.claim</code> is provided.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_reinsurance">reinsurance</code></td>
<td>
<p>the type of reinsurance for the portfolio; can
be abbreviated.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_from">from</code>, <code id="adjCoef_+3A_to">to</code></td>
<td>
<p>the range over which the adjustment coefficient will
be calculated.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_n">n</code></td>
<td>
<p>integer; the number of values at which to evaluate the
adjustment coefficient.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_x">x</code></td>
<td>
<p>an object of class <code>"adjCoef"</code>.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_xlab">xlab</code>, <code id="adjCoef_+3A_ylab">ylab</code></td>
<td>
<p>label of the x and y axes, respectively.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_sub">sub</code></td>
<td>
<p>subtitle, defaulting to the type of reinsurance.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired; see
<code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> add to already existing plot.</p>
</td></tr>
<tr><td><code id="adjCoef_+3A_...">...</code></td>
<td>
<p>further graphical parameters accepted by
<code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the typical case <code>reinsurance = "none"</code>, the coefficient of
determination is the smallest (strictly) positive root of the Lundberg
equation
</p>
<p style="text-align: center;"><code class="reqn">h(x) = E[e^{x B - x c W}] = 1</code>
</p>

<p>on <code class="reqn">[0, m)</code>, where <code class="reqn">m =</code> <code>upper.bound</code>, <code class="reqn">B</code> is the
claim severity random variable, <code class="reqn">W</code> is the claim interarrival
(or wait) time random variable and <code class="reqn">c =</code> <code>premium.rate</code>. The
premium rate must satisfy the positive safety loading constraint
<code class="reqn">E[B - c W] &lt; 0</code>.
</p>
<p>With <code>reinsurance = "proportional"</code>, the equation becomes
</p>
<p style="text-align: center;"><code class="reqn">h(x, y) = E[e^{x y B - x c(y) W}] = 1,</code>
</p>

<p>where <code class="reqn">y</code> is the retention rate and <code class="reqn">c(y)</code> is the premium rate
function.
</p>
<p>With <code>reinsurance = "excess-of-loss"</code>, the equation becomes
</p>
<p style="text-align: center;"><code class="reqn">h(x, y) = E[e^{x \min(B, y) - x c(y) W}] = 1,</code>
</p>

<p>where <code class="reqn">y</code> is the retention limit and <code class="reqn">c(y)</code> is the premium rate
function.
</p>
<p>One can use argument <code>h</code> as an alternative way to provide
function <code class="reqn">h(x)</code> or <code class="reqn">h(x, y)</code>. This is necessary in cases where
random variables <code class="reqn">B</code> and <code class="reqn">W</code> are not independent.
</p>
<p>The root of <code class="reqn">h(x) = 1</code> is found by minimizing <code class="reqn">(h(x) - 1)^2</code>.
</p>


<h3>Value</h3>

<p>If <code>reinsurance = "none"</code>, a numeric vector of length one.
Otherwise, a function of class <code>"adjCoef"</code> inheriting from the
<code>"function"</code> class.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang, Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Bowers, N. J. J., Gerber, H. U., Hickman, J., Jones, D. and Nesbitt, C.
(1986), <em>Actuarial Mathematics</em>, Society of Actuaries.
</p>
<p>Centeno, M. d. L. (2002), Measuring the effects of reinsurance by the
adjustment coefficient in the Sparre-Anderson model, <em>Insurance:
Mathematics and Economics</em> <b>30</b>, 37&ndash;49.
</p>
<p>Gerber, H. U. (1979), <em>An Introduction to Mathematical Risk
Theory</em>, Huebner Foundation.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2008),
<em>Loss Models, From Data to Decisions, Third Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic example: no reinsurance, exponential claim severity and wait
## times, premium rate computed with expected value principle and
## safety loading of 20%.
adjCoef(mgfexp, premium = 1.2, upper = 1)

## Same thing, giving function h.
h &lt;- function(x) 1/((1 - x) * (1 + 1.2 * x))
adjCoef(h = h, upper = 1)

## Example 11.4 of Klugman et al. (2008)
mgfx &lt;- function(x) 0.6 * exp(x) + 0.4 * exp(2 * x)
adjCoef(mgfx(x), mgfexp(x, 4), prem = 7, upper = 0.3182)

## Proportional reinsurance, same assumptions as above, reinsurer's
## safety loading of 30%.
mgfx &lt;- function(x, y) mgfexp(x * y)
p &lt;- function(x) 1.3 * x - 0.1
h &lt;- function(x, a) 1/((1 - a * x) * (1 + x * p(a)))
R1 &lt;- adjCoef(mgfx, premium = p, upper = 1, reins = "proportional",
              from = 0, to = 1, n = 11)
R2 &lt;- adjCoef(h = h, upper = 1, reins = "p",
             from = 0, to = 1, n = 101)
R1(seq(0, 1, length = 10))	# evaluation for various retention rates
R2(seq(0, 1, length = 10))	# same
plot(R1)		        # graphical representation
plot(R2, col = "green", add = TRUE) # smoother function

## Excess-of-loss reinsurance
p &lt;- function(x) 1.3 * levgamma(x, 2, 2) - 0.1
mgfx &lt;- function(x, l)
    mgfgamma(x, 2, 2) * pgamma(l, 2, 2 - x) +
    exp(x * l) * pgamma(l, 2, 2, lower = FALSE)
h &lt;- function(x, l) mgfx(x, l) * mgfexp(-x * p(l))
R1 &lt;- adjCoef(mgfx, upper = 1, premium = p, reins = "excess-of-loss",
             from = 0, to = 10, n = 11)
R2 &lt;- adjCoef(h = h, upper = 1, reins = "e",
             from = 0, to = 10, n = 101)
plot(R1)
plot(R2, col = "green", add = TRUE)
</code></pre>

<hr>
<h2 id='aggregateDist'>Aggregate Claim Amount Distribution</h2><span id='topic+aggregateDist'></span><span id='topic+print.aggregateDist'></span><span id='topic+plot.aggregateDist'></span><span id='topic+summary.aggregateDist'></span><span id='topic+mean.aggregateDist'></span><span id='topic+diff.aggregateDist'></span>

<h3>Description</h3>

<p>Compute the aggregate claim amount cumulative distribution function of
a portfolio over a period using one of five methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateDist(method = c("recursive", "convolution", "normal",
                         "npower", "simulation"),
              model.freq = NULL, model.sev = NULL, p0 = NULL,
              x.scale = 1, convolve = 0, moments, nb.simul, ...,
              tol = 1e-06, maxit = 500, echo = FALSE)

## S3 method for class 'aggregateDist'
print(x, ...)

## S3 method for class 'aggregateDist'
plot(x, xlim, ylab = expression(F[S](x)),
     main = "Aggregate Claim Amount Distribution",
     sub = comment(x), ...)

## S3 method for class 'aggregateDist'
summary(object, ...)

## S3 method for class 'aggregateDist'
mean(x, ...)

## S3 method for class 'aggregateDist'
diff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateDist_+3A_method">method</code></td>
<td>
<p>method to be used</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_model.freq">model.freq</code></td>
<td>
<p>for <code>"recursive"</code> method: a character string
giving the name of a distribution in the <code class="reqn">(a, b, 0)</code> or <code class="reqn">(a,
      b, 1)</code> families of distributions. For <code>"convolution"</code> method:
a vector of claim number probabilities. For <code>"simulation"</code>
method: a frequency simulation model (see <code><a href="#topic+rcomphierarc">rcomphierarc</a></code> for
details) or <code>NULL</code>. Ignored with <code>normal</code> and
<code>npower</code> methods.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_model.sev">model.sev</code></td>
<td>
<p>for <code>"recursive"</code> and <code>"convolution"</code>
methods: a vector of claim amount probabilities. For
<code>"simulation"</code> method: a severity simulation model (see
<code><a href="#topic+rcomphierarc">rcomphierarc</a></code> for details) or <code>NULL</code>. Ignored with
<code>normal</code> and <code>npower</code> methods.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_p0">p0</code></td>
<td>
<p>arbitrary probability at zero for the frequency
distribution. Creates a zero-modified or zero-truncated
distribution if not <code>NULL</code>. Used only with <code>"recursive"</code>
method.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_x.scale">x.scale</code></td>
<td>
<p>value of an amount of 1 in the severity model (monetary
unit). Used only with <code>"recursive"</code> and <code>"convolution"</code>
methods.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_convolve">convolve</code></td>
<td>
<p>number of times to convolve the resulting distribution
with itself. Used only with <code>"recursive"</code> method.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_moments">moments</code></td>
<td>
<p>vector of the true moments of the aggregate claim
amount distribution; required only by the <code>"normal"</code> or
<code>"npower"</code> methods.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_nb.simul">nb.simul</code></td>
<td>
<p>number of simulations for the <code>"simulation"</code> method.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_...">...</code></td>
<td>
<p>parameters of the frequency distribution for the
<code>"recursive"</code> method; further arguments to be passed to or
from other methods otherwise.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_tol">tol</code></td>
<td>
<p>the resulting cumulative distribution in the
<code>"recursive"</code> method will get less than <code>tol</code> away from
1.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of recursions in the <code>"recursive"</code>
method.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_echo">echo</code></td>
<td>
<p>logical; echo the recursions to screen in the
<code>"recursive"</code> method.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_x">x</code>, <code id="aggregateDist_+3A_object">object</code></td>
<td>
<p>an object of class <code>"aggregateDist"</code>.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_xlim">xlim</code></td>
<td>
<p>numeric of length 2; the <code class="reqn">x</code> limits of the plot.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_ylab">ylab</code></td>
<td>
<p>label of the y axis.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="aggregateDist_+3A_sub">sub</code></td>
<td>
<p>subtitle, defaulting to the calculation method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aggregateDist</code> returns a function to compute the cumulative
distribution function (cdf) of the aggregate claim amount distribution
in any point.
</p>
<p>The <code>"recursive"</code> method computes the cdf using the Panjer
algorithm; the <code>"convolution"</code> method using convolutions; the
<code>"normal"</code> method using a normal approximation; the
<code>"npower"</code> method using the Normal Power 2 approximation; the
<code>"simulation"</code> method using simulations. More details follow.
</p>


<h3>Value</h3>

<p>A function of class <code>"aggregateDist"</code>, inheriting from the
<code>"function"</code> class when using normal and Normal Power
approximations and additionally inheriting from the <code>"ecdf"</code> and
<code>"stepfun"</code> classes when other methods are used.
</p>
<p>There are methods available to summarize (<code>summary</code>), represent
(<code>print</code>), plot (<code>plot</code>), compute quantiles
(<code>quantile</code>) and compute the mean (<code>mean</code>) of
<code>"aggregateDist"</code> objects.
</p>
<p>For the <code>diff</code> method: a numeric vector of probabilities
corresponding to the probability mass function evaluated
at the knots of the distribution.
</p>


<h3>Recursive method</h3>

<p>The frequency distribution must be a member of the <code class="reqn">(a, b, 0)</code> or
<code class="reqn">(a, b, 1)</code> families of discrete distributions.
</p>
<p>To use a distribution from the <code class="reqn">(a, b, 0)</code> family,
<code>model.freq</code> must be one of
<code>"binomial"</code>,
<code>"geometric"</code>,
<code>"negative binomial"</code> or
<code>"poisson"</code>,
and <code>p0</code> must be <code>NULL</code>.
</p>
<p>To use a zero-truncated distribution from the <code class="reqn">(a, b, 1)</code> family,
<code>model.freq</code> may be one of the strings above together with
<code>p0 = 0</code>. As a shortcut, <code>model.freq</code> may also be one of
<code>"zero-truncated binomial"</code>,
<code>"zero-truncated geometric"</code>,
<code>"zero-truncated negative binomial"</code>,
<code>"zero-truncated poisson"</code> or
<code>"logarithmic"</code>,
and <code>p0</code> is then ignored (with a warning if non <code>NULL</code>).
</p>
<p>(Note: since the logarithmic distribution is always zero-truncated.
<code>model.freq = "logarithmic"</code> may be used with either <code>p0 =
  NULL</code> or <code>p0 = 0</code>.)
</p>
<p>To use a zero-modified distribution from the <code class="reqn">(a, b, 1)</code> family,
<code>model.freq</code> may be one of standard frequency distributions
mentioned above with <code>p0</code> set to some probability that the
distribution takes the value <code class="reqn">0</code>. It is equivalent, but more
explicit, to set <code>model.freq</code> to one of
<code>"zero-modified binomial"</code>,
<code>"zero-modified geometric"</code>,
<code>"zero-modified negative binomial"</code>,
<code>"zero-modified poisson"</code> or
<code>"zero-modified logarithmic"</code>.
</p>
<p>The parameters of the frequency distribution must be specified using
names identical to the arguments of the appropriate function
<code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="stats.html#topic+dgeom">dgeom</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>,
<code><a href="stats.html#topic+dpois">dpois</a></code> or <code><a href="#topic+dlogarithmic">dlogarithmic</a></code>. In the latter case,
do take note that the parametrization of <code>dlogarithmic</code> is
different from Appendix B of Klugman et al. (2012).
</p>
<p>If the length of <code>p0</code> is greater than one, only the first element
is used, with a warning.
</p>
<p><code>model.sev</code> is a vector of the (discretized) claim amount
distribution <code class="reqn">X</code>; the first element <strong>must</strong> be <code class="reqn">f_X(0) =
    \Pr[X = 0]</code>.
</p>
<p>The recursion will fail to start if the expected number of claims is
too large. One may divide the appropriate parameter of the frequency
distribution by <code class="reqn">2^n</code> and convolve the resulting distribution
<code class="reqn">n =</code> <code>convolve</code> times.
</p>
<p>Failure to obtain a cumulative distribution function less than
<code>tol</code> away from 1 within <code>maxit</code> iterations is often due
to too coarse a discretization of the severity distribution.
</p>


<h3>Convolution method</h3>

<p>The cumulative distribution function (cdf) <code class="reqn">F_S(x)</code> of the
aggregate claim amount of a portfolio in the collective risk model is
</p>
<p style="text-align: center;"><code class="reqn">F_S(x) = \sum_{n = 0}^{\infty} F_X^{*n}(x) p_n,</code>
</p>

<p>for <code class="reqn">x = 0, 1, \dots</code>; <code class="reqn">p_n = \Pr[N = n]</code> is
the frequency probability mass function and
<code class="reqn">F_X^{*n}(x)</code> is the cdf of the <code class="reqn">n</code>th convolution of
the (discrete) claim amount random variable.
</p>
<p><code>model.freq</code> is vector <code class="reqn">p_n</code> of the number of claims
probabilities; the first element <strong>must</strong> be <code class="reqn">\Pr[N =
  0]</code>.
</p>
<p><code>model.sev</code> is vector <code class="reqn">f_X(x)</code> of the (discretized)
claim amount distribution; the first element <strong>must</strong> be
<code class="reqn">f_X(0)</code>.
</p>


<h3>Normal and Normal Power 2 methods</h3>

<p>The Normal approximation of a cumulative distribution function (cdf)
<code class="reqn">F(x)</code> with mean <code class="reqn">\mu</code> and standard deviation
<code class="reqn">\sigma</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) \approx \Phi\left( \frac{x - \mu}{\sigma} \right).</code>
</p>

<p>The Normal Power 2 approximation of a cumulative distribution function (cdf)
<code class="reqn">F(x)</code> with mean <code class="reqn">\mu</code>, standard deviation <code class="reqn">\sigma</code>
and skewness <code class="reqn">\gamma</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) \approx \Phi \left(%
    -\frac{3}{\gamma} + \sqrt{\frac{9}{\gamma^2} + 1 %
      + \frac{6}{\gamma} \frac{x - \mu}{\sigma}} \right).</code>
</p>

<p>This formula is valid only for the right-hand tail of the distribution
and skewness should not exceed unity.
</p>


<h3>Simulation method</h3>

<p>This methods returns the empirical distribution function of a sample
of size <code>nb.simul</code> of the aggregate claim amount distribution
specified by <code>model.freq</code> and
<code>model.sev</code>. <code><a href="#topic+rcomphierarc">rcomphierarc</a></code> is used for the simulation of
claim amounts, hence both the frequency and severity models can be
mixtures of distributions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Daykin, C.D., PentikÃ¤inen, T. and Pesonen, M.
(1994), <em>Practical Risk Theory for Actuaries</em>, Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discretize">discretize</a></code> to discretize a severity distribution;
<code><a href="#topic+mean.aggregateDist">mean.aggregateDist</a></code> to compute the mean of the
distribution;
<code><a href="#topic+quantile.aggregateDist">quantile.aggregateDist</a></code> to compute the quantiles or the
Value-at-Risk;
<code><a href="#topic+CTE.aggregateDist">CTE.aggregateDist</a></code> to compute the Conditional Tail
Expectation (or Tail Value-at-Risk);
<code><a href="#topic+rcomphierarc">rcomphierarc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convolution method (example 9.5 of Klugman et al. (2012))
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
pn &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.15, 0.06, 0.03, 0.01)
Fs &lt;- aggregateDist("convolution", model.freq = pn,
                    model.sev = fx, x.scale = 25)
summary(Fs)
c(Fs(0), diff(Fs(25 * 0:21))) # probability mass function
plot(Fs)

## Recursive method (example 9.10 of Klugman et al. (2012))
fx &lt;- c(0, crossprod(c(2, 1)/3,
                     matrix(c(0.6, 0.7, 0.4, 0, 0, 0.3), 2, 3)))
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 3)
plot(Fs)
Fs(knots(Fs))		      # cdf evaluated at its knots
diff(Fs)                      # probability mass function

## Recursive method (high frequency)
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
## Not run: Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 1000)
## End(Not run)
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 250, convolve = 2, maxit = 1500)
plot(Fs)

## Recursive method (zero-modified distribution; example 9.11 of
## Klugman et al. (2012))
Fn &lt;- aggregateDist("recursive", model.freq = "binomial",
                    model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
                    p0 = 0.4, size = 3, prob = 0.3)
diff(Fn)

## Equivalent but more explicit call
aggregateDist("recursive", model.freq = "zero-modified binomial",
              model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
              p0 = 0.4, size = 3, prob = 0.3)

## Recursive method (zero-truncated distribution). Using 'fx' above
## would mean that both Pr[N = 0] = 0 and Pr[X = 0] = 0, therefore
## Pr[S = 0] = 0 and recursions would not start.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "upper")
fx[1L] # non zero
aggregateDist("recursive", model.freq = "zero-truncated poisson",
              model.sev = fx, lambda = 3, x.scale = 25, echo=TRUE)

## Normal Power approximation
Fs &lt;- aggregateDist("npower", moments = c(200, 200, 0.5))
Fs(210)

## Simulation method
model.freq &lt;- expression(data = rpois(3))
model.sev &lt;- expression(data = rgamma(100, 2))
Fs &lt;- aggregateDist("simulation", nb.simul = 1000,
                    model.freq, model.sev)
mean(Fs)
plot(Fs)

## Evaluation of ruin probabilities using Beekman's formula with
## Exponential(1) claim severity, Poisson(1) frequency and premium rate
## c = 1.2.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "lower")
phi0 &lt;- 0.2/1.2
Fs &lt;- aggregateDist(method = "recursive", model.freq = "geometric",
                    model.sev = fx, prob = phi0)
1 - Fs(400)			# approximate ruin probability
u &lt;- 0:100
plot(u, 1 - Fs(u), type = "l", main = "Ruin probability")
</code></pre>

<hr>
<h2 id='betaint'>The &ldquo;Beta Integral&rdquo;</h2><span id='topic+betaint'></span>

<h3>Description</h3>

<p>The &ldquo;beta integral&rdquo; which is just a multiple of the non
regularized incomplete beta function. This function merely
provides an R interface to the C level routine. It is not exported
by the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaint(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaint_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="betaint_+3A_a">a</code>, <code id="betaint_+3A_b">b</code></td>
<td>
<p>parameters. See Details for admissible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>betaint</code> computes the &ldquo;beta integral&rdquo;
</p>
<p style="text-align: center;"><code class="reqn">
    B(a, b; x) = \Gamma(a + b) \int_0^x t^{a-1} (1-t)^{b-1} dt</code>
</p>

<p>for <code class="reqn">a &gt; 0</code>, <code class="reqn">b \neq -1, -2, \ldots</code> and
<code class="reqn">0 &lt; x &lt; 1</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
When <code class="reqn">b &gt; 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">
    B(a, b; x) = \Gamma(a) \Gamma(b) I_x(a, b),</code>
</p>

<p>where <code class="reqn">I_x(a, b)</code> is <code>pbeta(x, a, b)</code>. When <code class="reqn">b &lt; 0</code>,
<code class="reqn">b \neq -1, -2, \ldots</code>, and <code class="reqn">a &gt; 1 +
  [-b]</code>,
</p>
<p style="text-align: center;"><code class="reqn">%
    \begin{array}{rcl}
      B(a, b; x)
      &amp;=&amp; \displaystyle
          -\Gamma(a + b) \left[ \frac{x^{a-1} (1-x)^b}{b}
          + \frac{(a-1) x^{a-2} (1-x)^{b+1}}{b (b+1)} \right. \\
      &amp; &amp; \displaystyle\left.
	  + \cdots + \frac{(a-1) \cdots (a-r) x^{a-r-1}
	  (1-x)^{b+r}}{b (b+1) \cdots (b+r)} \right] \\
      &amp; &amp;  \displaystyle
  	  + \frac{(a-1) \cdots (a-r-1)}{b (b+1) \cdots (b+r)}
	  \Gamma(a-r-1) \\
      &amp; &amp; \times \Gamma(b+r+1) I_x(a-r-1, b+r+1),
      \end{array}</code>
</p>

<p>where <code class="reqn">r = [-b]</code>.
</p>
<p>This function is used (at the C level) to compute the
limited expected value for distributions of the transformed beta
family; see, for example, <code><a href="#topic+levtrbeta">levtrbeta</a></code>.
</p>


<h3>Value</h3>

<p>The value of the integral.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>The need for this function in the package is well explained in the
introduction of Appendix A of Klugman et al. (2012). See also chapter
6 and 15 of Abramowitz and Stegun (1972) for definitions and relations
to the hypergeometric series.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A. (1972), <em>Handbook of Mathematical
Functions</em>, Dover.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0.3
a &lt;- 7

## case with b &gt; 0
b &lt;- 2
actuar:::betaint(x, a, b)
gamma(a) * gamma(b) * pbeta(x, a, b)    # same

## case with b &lt; 0
b &lt;- -2.2
r &lt;- floor(-b)        # r = 2
actuar:::betaint(x, a, b)

## "manual" calculation
s &lt;- (x^(a-1) * (1-x)^b)/b +
    ((a-1) * x^(a-2) * (1-x)^(b+1))/(b * (b+1)) +
    ((a-1) * (a-2) * x^(a-3) * (1-x)^(b+2))/(b * (b+1) * (b+2))
-gamma(a+b) * s +
    (a-1)*(a-2)*(a-3) * gamma(a-r-1)/(b*(b+1)*(b+2)) *
    gamma(b+r+1)*pbeta(x, a-r-1, b+r+1)
</code></pre>

<hr>
<h2 id='BetaMoments'>Raw and Limited Moments of the Beta Distribution</h2><span id='topic+BetaMoments'></span><span id='topic+mbeta'></span><span id='topic+levbeta'></span>

<h3>Description</h3>

<p>Raw moments and limited moments for the (central) Beta distribution
with parameters <code>shape1</code> and <code>shape2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbeta(order, shape1, shape2)
levbeta(limit, shape1, shape2, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaMoments_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="BetaMoments_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="BetaMoments_+3A_shape1">shape1</code>, <code id="BetaMoments_+3A_shape2">shape2</code></td>
<td>
<p>positive parameters of the Beta distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, <code class="reqn">k &gt; -\alpha</code>.
</p>
<p>The noncentral beta distribution is not supported.
</p>


<h3>Value</h3>

<p><code>mbeta</code> gives the <code class="reqn">k</code>th raw moment and
<code>levbeta</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a
warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code> for details on the beta distribution and
functions <code>[dpqr]beta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mbeta(2, 3, 4) - mbeta(1, 3, 4)^2
levbeta(10, 3, 4, order = 2)
</code></pre>

<hr>
<h2 id='Burr'>The Burr Distribution</h2><span id='topic+Burr'></span><span id='topic+dburr'></span><span id='topic+pburr'></span><span id='topic+qburr'></span><span id='topic+rburr'></span><span id='topic+mburr'></span><span id='topic+levburr'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Burr distribution with
parameters <code>shape1</code>, <code>shape2</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburr(x, shape1, shape2, rate = 1, scale = 1/rate,
      log = FALSE)
pburr(q, shape1, shape2, rate = 1, scale = 1/rate,
      lower.tail = TRUE, log.p = FALSE)
qburr(p, shape1, shape2, rate = 1, scale = 1/rate,
      lower.tail = TRUE, log.p = FALSE)
rburr(n, shape1, shape2, rate = 1, scale = 1/rate)
mburr(order, shape1, shape2, rate = 1, scale = 1/rate)
levburr(limit, shape1, shape2, rate = 1, scale = 1/rate,
        order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Burr_+3A_x">x</code>, <code id="Burr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Burr_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Burr_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Burr_+3A_shape1">shape1</code>, <code id="Burr_+3A_shape2">shape2</code>, <code id="Burr_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Burr_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Burr_+3A_log">log</code>, <code id="Burr_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Burr_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Burr_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Burr_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Burr distribution with parameters <code>shape1</code> <code class="reqn">=
    \alpha</code>, <code>shape2</code> <code class="reqn">= \gamma</code> and <code>scale</code>
<code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha \gamma (x/\theta)^\gamma}{%
      x [1 + (x/\theta)^\gamma]^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code>
and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The Burr is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\theta \left(\frac{X}{1 - X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">1</code>
and <code class="reqn">\alpha</code>.
</p>
<p>The Burr distribution has the following special cases:
</p>

<ul>
<li><p> A <a href="#topic+dllogis">Loglogistic</a> distribution when <code>shape1
      == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dparalogis">Paralogistic</a> distribution when
<code>shape2 == shape1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto">Pareto</a> distribution when <code>shape2 ==
      1</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\gamma &lt; k &lt; \alpha\gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\gamma</code>
and <code class="reqn">\alpha - k/\gamma</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dburr</code> gives the density,
<code>pburr</code> gives the distribution function,
<code>qburr</code> gives the quantile function,
<code>rburr</code> generates random deviates,
<code>mburr</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levburr</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levburr</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>Distribution also known as the Burr Type XII or Singh-Maddala
distribution. See also Kleiber and Kotz (2003) for alternative names
and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpareto4">dpareto4</a></code> for an equivalent distribution with a location
parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dburr(1, 2, 3, log = TRUE))
p &lt;- (1:10)/10
pburr(qburr(p, 2, 3, 2), 2, 3, 2)

## variance
mburr(2, 2, 3, 1) - mburr(1, 2, 3, 1) ^ 2

## case with shape1 - order/shape2 &gt; 0
levburr(10, 2, 3, 1, order = 2)

## case with shape1 - order/shape2 &lt; 0
levburr(10, 1.5, 0.5, 1, order = 2)
</code></pre>

<hr>
<h2 id='ChisqSupp'>Moments and Moment Generating Function of the (non-central) Chi-Squared Distribution</h2><span id='topic+ChisqSupp'></span><span id='topic+mchisq'></span><span id='topic+levchisq'></span><span id='topic+mgfchisq'></span>

<h3>Description</h3>

<p>Raw moments, limited moments and moment generating function for the
chi-squared (<code class="reqn">\chi^2</code>) distribution with <code>df</code> degrees
of freedom and optional non-centrality parameter <code>ncp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mchisq(order, df, ncp = 0)
levchisq(limit, df, ncp = 0, order = 1)
mgfchisq(t, df, ncp = 0, log= FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChisqSupp_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="ChisqSupp_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="ChisqSupp_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="ChisqSupp_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter (non-negative).</p>
</td></tr>
<tr><td><code id="ChisqSupp_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="ChisqSupp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the cumulant generating function
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)]</code> and the moment generating
function is <code class="reqn">E[e^{tX}]</code>.
</p>
<p>Only integer moments are supported for the non central Chi-square
distribution (<code>ncp &gt; 0</code>).
</p>
<p>The limited expected value is supported for the centered Chi-square
distribution (<code>ncp = 0</code>).
</p>


<h3>Value</h3>

<p><code>mchisq</code> gives the <code class="reqn">k</code>th raw moment,
<code>levchisq</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable, and
<code>mgfchisq</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang, Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Johnson, N. L. and Kotz, S. (1970), <em>Continuous Univariate
Distributions, Volume 1</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Chisquare">Chisquare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mchisq(2, 3, 4)
levchisq(10, 3, order = 2)
mgfchisq(0.25, 3, 2)
</code></pre>

<hr>
<h2 id='cm'>Credibility Models</h2><span id='topic+cm'></span><span id='topic+print.cm'></span><span id='topic+predict.cm'></span><span id='topic+summary.cm'></span><span id='topic+print.summary.cm'></span>

<h3>Description</h3>

<p>Fit the following credibility models: BÃ¼hlmann,
BÃ¼hlmann-Straub, hierarchical, regression
(Hachemeister) or linear Bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm(formula, data, ratios, weights, subset,
   regformula = NULL, regdata, adj.intercept = FALSE,
   method = c("Buhlmann-Gisler", "Ohlsson", "iterative"),
   likelihood, ...,
   tol = sqrt(.Machine$double.eps), maxit = 100, echo = FALSE)

## S3 method for class 'cm'
print(x, ...)

## S3 method for class 'cm'
predict(object, levels = NULL, newdata, ...)

## S3 method for class 'cm'
summary(object, levels = NULL, newdata, ...)

## S3 method for class 'summary.cm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm_+3A_formula">formula</code></td>
<td>
<p>character string <code>"bayes"</code> or an object of
class <code>"<a href="stats.html#topic+formula">formula</a>"</code>: a symbolic description of the
model to be fit. The details of model specification are given
below.</p>
</td></tr>
<tr><td><code id="cm_+3A_data">data</code></td>
<td>
<p>a matrix or a data frame containing the portfolio
structure, the ratios or claim amounts and their associated weights,
if any.</p>
</td></tr>
<tr><td><code id="cm_+3A_ratios">ratios</code></td>
<td>
<p>expression indicating the columns of <code>data</code>
containing the ratios or claim amounts.</p>
</td></tr>
<tr><td><code id="cm_+3A_weights">weights</code></td>
<td>
<p>expression indicating the columns of <code>data</code>
containing the weights associated with <code>ratios</code>.</p>
</td></tr>
<tr><td><code id="cm_+3A_subset">subset</code></td>
<td>
<p>an optional logical expression indicating a subset of
observations to be used in the modeling process. All observations
are included by default.</p>
</td></tr>
<tr><td><code id="cm_+3A_regformula">regformula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code>:
symbolic description of the regression component (see
<code><a href="stats.html#topic+lm">lm</a></code> for details). No left hand side is needed
in the formula; if present it is ignored. If <code>NULL</code>, no
regression is done on the data.</p>
</td></tr>
<tr><td><code id="cm_+3A_regdata">regdata</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the regression model.</p>
</td></tr>
<tr><td><code id="cm_+3A_adj.intercept">adj.intercept</code></td>
<td>
<p>if <code>TRUE</code>, the intercept of the regression
model is located at the barycenter of the regressor instead of the
origin.</p>
</td></tr>
<tr><td><code id="cm_+3A_method">method</code></td>
<td>
<p>estimation method for the variance components of the
model; see Details.</p>
</td></tr>
<tr><td><code id="cm_+3A_likelihood">likelihood</code></td>
<td>
<p>a character string giving the name of the likelihood
function in one of the supported linear Bayes cases; see Details.</p>
</td></tr>
<tr><td><code id="cm_+3A_tol">tol</code></td>
<td>
<p>tolerance level for the stopping criteria for iterative
estimation method.</p>
</td></tr>
<tr><td><code id="cm_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations in iterative estimation
method.</p>
</td></tr>
<tr><td><code id="cm_+3A_echo">echo</code></td>
<td>
<p>logical; whether to echo the iterative procedure or not.</p>
</td></tr>
<tr><td><code id="cm_+3A_x">x</code>, <code id="cm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"cm"</code>.</p>
</td></tr>
<tr><td><code id="cm_+3A_levels">levels</code></td>
<td>
<p>character vector indicating the levels to predict or to
include in the summary; if <code>NULL</code> all levels are included.</p>
</td></tr>
<tr><td><code id="cm_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the variables used to predict
credibility regression models.</p>
</td></tr>
<tr><td><code id="cm_+3A_...">...</code></td>
<td>
<p>parameters of the prior distribution for <code>cm</code>;
additional attributes to attach to the result for the
<code>predict</code> and <code>summary</code> methods; further arguments to
<code><a href="base.html#topic+format">format</a></code> for the <code>print.summary</code> method;
unused for the <code>print</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cm</code> is the unified front end for credibility models fitting. The
function supports hierarchical models with any number of levels (with
BÃ¼hlmann and BÃ¼hlmann-Straub models as
special cases) and the regression model of Hachemeister. Usage of
<code>cm</code> is similar to <code><a href="stats.html#topic+lm">lm</a></code> for these cases.
<code>cm</code> can also fit linear Bayes models, in which case usage is
much simplified; see the section on linear Bayes below.
</p>
<p>When not <code>"bayes"</code>, the <code>formula</code> argument symbolically
describes the structure of the portfolio in the form <code class="reqn">~ terms</code>.
Each term is an interaction between risk factors contributing to the
total variance of the portfolio data. Terms are separated by <code>+</code>
operators and interactions within each term by <code>:</code>. For a
portfolio divided first into sectors, then units and finally
contracts, <code>formula</code> would be <code>~ sector + sector:unit +
  sector:unit:contract</code>, where <code>sector</code>, <code>unit</code> and
<code>contract</code> are column names in <code>data</code>. In general, the
formula should be of the form <code>~ a + a:b + a:b:c + a:b:c:d +
  ...</code>.
</p>
<p>If argument <code>regformula</code> is not <code>NULL</code>, the regression model
of Hachemeister is fit to the data. The response is usually time. By
default, the intercept of the model is located at time origin. If
argument <code>adj.intercept</code> is <code>TRUE</code>, the intercept is moved
to the (collective) barycenter of time, by orthogonalization of the
design matrix. Note that the regression coefficients may be difficult
to interpret in this case.
</p>
<p>Arguments <code>ratios</code>, <code>weights</code> and <code>subset</code> are used
like arguments <code>select</code>, <code>select</code> and <code>subset</code>,
respectively, of function <code><a href="base.html#topic+subset">subset</a></code>.
</p>
<p>Data does not have to be sorted by level. Nodes with no data (complete
lines of <code>NA</code> except for the portfolio structure) are allowed,
with the restriction mentioned above.
</p>


<h3>Value</h3>

<p>Function <code>cm</code> computes the structure parameters estimators of the
model specified in <code>formula</code>. The value returned is an object of
class <code>cm</code>.
</p>
<p>An object of class <code>"cm"</code> is a list with at least the following
components:
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p>a list containing, for each level, the vector of linearly
sufficient statistics.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a list containing, for each level, the vector of total
weights.</p>
</td></tr>
<tr><td><code>unbiased</code></td>
<td>
<p>a vector containing the unbiased variance components
estimators, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code>iterative</code></td>
<td>
<p>a vector containing the iterative variance components
estimators, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code>cred</code></td>
<td>
<p>for multi-level hierarchical models: a list containing,
the vector of credibility factors for each level. For one-level
models: an array or vector of credibility factors.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>a list containing, for each level, the vector of the
number of nodes in the level.</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>the columns of <code>data</code> containing the
portfolio classification structure.</p>
</td></tr>
<tr><td><code>ordering</code></td>
<td>
<p>a list containing, for each level, the affiliation of
a node to the node of the level above.</p>
</td></tr>
</table>
<p>Regression fits have in addition the following components:
</p>
<table>
<tr><td><code>adj.models</code></td>
<td>
<p>a list containing, for each node, the credibility
adjusted regression model as obtained with
<code><a href="stats.html#topic+lm.fit">lm.fit</a></code> or <code><a href="stats.html#topic+lm.wfit">lm.wfit</a></code>.</p>
</td></tr>
<tr><td><code>transition</code></td>
<td>
<p>if <code>adj.intercept</code> is <code>TRUE</code>, a transition
matrix from the basis of the orthogonal design matrix to the basis
of the original design matrix.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
</table>
<p>The method of <code>predict</code> for objects of class <code>"cm"</code> computes
the credibility premiums for the nodes of every level included in
argument <code>levels</code> (all by default). Result is a list the same
length as <code>levels</code> or the number of levels in <code>formula</code>, or
an atomic vector for one-level models.
</p>


<h3>Hierarchical models</h3>

<p>The credibility premium at one level is a convex combination between
the linearly sufficient statistic of a node and the credibility
premium of the level above. (For the first level, the complement of
credibility is given to the collective premium.) The linearly
sufficient statistic of a node is the credibility weighted average of
the data of the node, except at the last level, where natural weights
are used. The credibility factor of node <code class="reqn">i</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">\frac{w_i}{w_i + a/b},</code>
</p>

<p>where <code class="reqn">w_i</code> is the weight of the node used in the linearly
sufficient statistic, <code class="reqn">a</code> is the average within node variance and
<code class="reqn">b</code> is the average between node variance.
</p>


<h3>Regression models</h3>

<p>The credibility premium of node <code class="reqn">i</code> is equal to
</p>
<p style="text-align: center;"><code class="reqn">y^\prime b_i^a,</code>
</p>

<p>where <code class="reqn">y</code> is a matrix created from <code>newdata</code> and
<code class="reqn">b_i^a</code> is the vector of credibility adjusted regression
coefficients of node <code class="reqn">i</code>. The latter is given by
</p>
<p style="text-align: center;"><code class="reqn">b_i^a = Z_i b_i + (I - Z_I) m,</code>
</p>

<p>where <code class="reqn">b_i</code> is the vector of regression coefficients based
on data of node <code class="reqn">i</code> only, <code class="reqn">m</code> is the vector of collective
regression coefficients, <code class="reqn">Z_i</code> is the credibility matrix and
<code class="reqn">I</code> is the identity matrix. The credibility matrix of node <code class="reqn">i</code>
is equal to
</p>
<p style="text-align: center;"><code class="reqn">A^{-1} (A + s^2 S_i),</code>
</p>

<p>where <code class="reqn">S_i</code> is the unscaled regression covariance matrix of
the node, <code class="reqn">s^2</code> is the average within node variance and
<code class="reqn">A</code> is the within node covariance matrix.
</p>
<p>If the intercept is positioned at the barycenter of time, matrices
<code class="reqn">S_i</code> and <code class="reqn">A</code> (and hence <code class="reqn">Z_i</code>) are diagonal.
This amounts to use BÃ¼hlmann-Straub models for each
regression coefficient.
</p>
<p>Argument <code>newdata</code> provides the &ldquo;future&rdquo; value of the
regressors for prediction purposes. It should be given as specified in
<code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>


<h3>Variance components estimation</h3>

<p>For hierarchical models, two sets of estimators of the variance
components (other than the within node variance) are available:
unbiased estimators and iterative estimators.
</p>
<p>Unbiased estimators are based on sums of squares of the form
</p>
<p style="text-align: center;"><code class="reqn">B_i = \sum_j w_{ij} (X_{ij} - \bar{X}_i)^2 - (J - 1) a</code>
</p>

<p>and constants of the form
</p>
<p style="text-align: center;"><code class="reqn">c_i = w_i - \sum_j \frac{w_{ij}^2}{w_i},</code>
</p>

<p>where <code class="reqn">X_{ij}</code> is the linearly sufficient statistic of
level <code class="reqn">(ij)</code>; <code class="reqn">\bar{X_{i}}</code> is the weighted average of
the latter using weights <code class="reqn">w_{ij}</code>; <code class="reqn">w_i = \sum_j
  w_{ij}</code>; <code class="reqn">J</code> is the effective number of
nodes at level <code class="reqn">(ij)</code>; <code class="reqn">a</code> is the within variance of this
level. Weights <code class="reqn">w_{ij}</code> are the natural weights at the
lowest level, the sum of the natural weights the next level and the
sum of the credibility factors for all upper levels.
</p>
<p>The BÃ¼hlmann-Gisler estimators (<code>method =
    "Buhlmann-Gisler"</code>) are given by
</p>
<p style="text-align: center;"><code class="reqn">b = \frac{1}{I} \sum_i \max \left( \frac{B_i}{c_i}, 0
    \right),</code>
</p>

<p>that is the average of the per node variance estimators truncated at
0.
</p>
<p>The Ohlsson estimators (<code>method = "Ohlsson"</code>) are given by
</p>
<p style="text-align: center;"><code class="reqn">b = \frac{\sum_i B_i}{\sum_i c_i},</code>
</p>

<p>that is the weighted average of the per node variance estimators
without any truncation. Note that negative estimates will be truncated
to zero for credibility factor calculations.
</p>
<p>In the BÃ¼hlmann-Straub model, these estimators are
equivalent.
</p>
<p>Iterative estimators <code>method = "iterative"</code> are pseudo-estimators
of the form
</p>
<p style="text-align: center;"><code class="reqn">b = \frac{1}{d} \sum_i w_i (X_i - \bar{X})^2,</code>
</p>

<p>where <code class="reqn">X_i</code> is the linearly sufficient statistic of one
level, <code class="reqn">\bar{X}</code> is the linearly sufficient statistic of
the level above and <code class="reqn">d</code> is the effective number of nodes at one
level minus the effective number of nodes of the level above. The
Ohlsson estimators are used as starting values.
</p>
<p>For regression models, with the intercept at time origin, only
iterative estimators are available. If <code>method</code> is different from
<code>"iterative"</code>, a warning is issued. With the intercept at the
barycenter of time, the choice of estimators is the same as in the
BÃ¼hlmann-Straub model.
</p>


<h3>Linear Bayes</h3>

<p>When <code>formula</code> is <code>"bayes"</code>, the function computes pure
Bayesian premiums for the following combinations of distributions
where they are linear credibility premiums:
</p>

<ul>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Poisson}(\theta)</code> and
<code class="reqn">\Theta \sim \mathrm{Gamma}(\alpha, \lambda)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Exponential}(\theta)</code> and
<code class="reqn">\Theta \sim  \mathrm{Gamma}(\alpha, \lambda)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Gamma}(\tau, \theta)</code> and
<code class="reqn">\Theta \sim  \mathrm{Gamma}(\alpha, \lambda)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Normal}(\theta, \sigma_2^2)</code> and
<code class="reqn">\Theta \sim \mathrm{Normal}(\mu, \sigma_1^2)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Bernoulli}(\theta)</code> and
<code class="reqn">\Theta \sim \mathrm{Beta}(a, b)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Binomial}(\nu, \theta)</code> and
<code class="reqn">\Theta \sim \mathrm{Beta}(a, b)</code>;
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Geometric}(\theta)</code> and
<code class="reqn">\Theta \sim \mathrm{Beta}(a, b)</code>.
</p>
</li>
<li><p><code class="reqn">X|\Theta = \theta \sim \mathrm{Negative~Binomial}(r, \theta)</code> and
<code class="reqn">\Theta \sim \mathrm{Beta}(a, b)</code>.</p>
</li></ul>

<p>The following combination is also supported:
<code class="reqn">X|\Theta = \theta \sim \mathrm{Single~Parameter~Pareto}(\theta)</code>
and <code class="reqn">\Theta \sim \mathrm{Gamma}(\alpha, \lambda)</code>. In this case, the Bayesian estimator not of
the risk premium, but rather of parameter <code class="reqn">\theta</code> is linear with
a &ldquo;credibility&rdquo; factor that is not restricted to <code class="reqn">(0, 1)</code>.
</p>
<p>Argument <code>likelihood</code> identifies the distribution of <code class="reqn">X|\Theta
    = \theta</code> as one of
<code>"poisson"</code>,
<code>"exponential"</code>,
<code>"gamma"</code>,
<code>"normal"</code>,
<code>"bernoulli"</code>,
<code>"binomial"</code>,
<code>"geometric"</code>,
<code>"negative binomial"</code> or
<code>"pareto"</code>.
</p>
<p>The parameters of the distributions of <code class="reqn">X|\Theta = \theta</code> (when
needed) and <code class="reqn">\Theta</code> are set in <code>...</code> using the argument
names (and default values) of <code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dbeta">dbeta</a></code>,
<code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a></code> or
<code>dpareto1</code>, as appropriate. For the Gamma/Gamma case, use
<code>shape.lik</code> for the shape parameter <code class="reqn">\tau</code> of the Gamma
likelihood. For the Normal/Normal case, use <code>sd.lik</code> for the
standard error <code class="reqn">\sigma_2</code> of the Normal likelihood.
</p>
<p>Data for the linear Bayes case may be a matrix or data frame as usual;
an atomic vector to fit the model to a single contract; missing or
<code>NULL</code> to fit the prior model. Arguments <code>ratios</code>,
<code>weights</code> and <code>subset</code> are ignored.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Xavier Milhaud, Tommy Ouellet, Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>BÃ¼hlmann, H. and Gisler, A. (2005), <em>A Course in
Credibility Theory and its Applications</em>, Springer.
</p>
<p>Belhadj, H., Goulet, V. and Ouellet, T. (2009), On parameter
estimation in hierarchical credibility, <em>Astin Bulletin</em> <b>39</b>.
</p>
<p>Goulet, V. (1998), Principles and application of credibility
theory, <em>Journal of Actuarial Practice</em> <b>6</b>, ISSN
1064-6647.
</p>
<p>Goovaerts, M. J. and Hoogstad, W. J. (1987), <em>Credibility Theory</em>,
Surveys of Actuarial Studies, No. 4, Nationale-Nederlanden N.V.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hachemeister)

## Buhlmann-Straub model
fit &lt;- cm(~state, hachemeister,
          ratios = ratio.1:ratio.12, weights = weight.1:weight.12)
fit				# print method
predict(fit)			# credibility premiums
summary(fit)			# more details

## Two-level hierarchical model. Notice that data does not have
## to be sorted by level
X &lt;- data.frame(unit = c("A", "B", "A", "B", "B"), hachemeister)
fit &lt;- cm(~unit + unit:state, X, ratio.1:ratio.12, weight.1:weight.12)
predict(fit)
predict(fit, levels = "unit")	# unit credibility premiums only
summary(fit)
summary(fit, levels = "unit")	# unit summaries only

## Regression model with intercept at time origin
fit &lt;- cm(~state, hachemeister,
          regformula = ~time, regdata = data.frame(time = 12:1),
          ratios = ratio.1:ratio.12, weights = weight.1:weight.12)
fit
predict(fit, newdata = data.frame(time = 0))
summary(fit, newdata = data.frame(time = 0))

## Same regression model, with intercept at barycenter of time
fit &lt;- cm(~state, hachemeister, adj.intercept = TRUE,
          regformula = ~time, regdata = data.frame(time = 12:1),
          ratios = ratio.1:ratio.12, weights = weight.1:weight.12)
fit
predict(fit, newdata = data.frame(time = 0))
summary(fit, newdata = data.frame(time = 0))

## Poisson/Gamma pure Bayesian model
fit &lt;- cm("bayes", data = c(5, 3, 0, 1, 1),
          likelihood = "poisson", shape = 3, rate = 3)
fit
predict(fit)
summary(fit)

## Normal/Normal pure Bayesian model
cm("bayes", data = c(5, 3, 0, 1, 1),
   likelihood = "normal", sd.lik = 2,
   mean = 2, sd = 1)
</code></pre>

<hr>
<h2 id='coverage'>Density and Cumulative Distribution Function for Modified Data</h2><span id='topic+coverage'></span><span id='topic+Coverage'></span>

<h3>Description</h3>

<p>Compute probability density function or cumulative distribution
function of the payment per payment or payment per loss random
variable under any combination of the following coverage
modifications: deductible, limit, coinsurance, inflation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(pdf, cdf, deductible = 0, franchise = FALSE,
         limit = Inf, coinsurance = 1, inflation = 0,
         per.loss = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_pdf">pdf</code>, <code id="coverage_+3A_cdf">cdf</code></td>
<td>
<p>function object or character string naming a function
to compute, respectively, the probability density function and cumulative
distribution function of a probability law.</p>
</td></tr>
<tr><td><code id="coverage_+3A_deductible">deductible</code></td>
<td>
<p>a unique positive numeric value.</p>
</td></tr>
<tr><td><code id="coverage_+3A_franchise">franchise</code></td>
<td>
<p>logical; <code>TRUE</code> for a franchise deductible,
<code>FALSE</code> (default) for an ordinary deductible.</p>
</td></tr>
<tr><td><code id="coverage_+3A_limit">limit</code></td>
<td>
<p>a unique positive numeric value larger than
<code>deductible</code>.</p>
</td></tr>
<tr><td><code id="coverage_+3A_coinsurance">coinsurance</code></td>
<td>
<p>a unique value between 0 and 1; the proportion of
coinsurance.</p>
</td></tr>
<tr><td><code id="coverage_+3A_inflation">inflation</code></td>
<td>
<p>a unique value between 0 and 1; the rate of
inflation.</p>
</td></tr>
<tr><td><code id="coverage_+3A_per.loss">per.loss</code></td>
<td>
<p>logical; <code>TRUE</code> for the per loss distribution,
<code>FALSE</code> (default) for the per payment distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coverage</code> returns a function to compute the probability
density function (pdf) or the cumulative distribution function (cdf)
of the distribution of losses under coverage modifications. The pdf
and cdf of unmodified losses are <code>pdf</code> and <code>cdf</code>,
respectively.
</p>
<p>If <code>pdf</code> is specified, the pdf is returned; if <code>pdf</code> is
missing or <code>NULL</code>, the cdf is returned. Note that <code>cdf</code> is
needed if there is a deductible or a limit.
</p>


<h3>Value</h3>

<p>An object of mode <code>"function"</code> with the same arguments as
<code>pdf</code> or <code>cdf</code>, except <code>"lower.tail"</code>,
<code>"log.p"</code> and <code>"log"</code>, which are not supported.
</p>


<h3>Note</h3>

<p>Setting arguments of the function returned by <code>coverage</code> using
<code><a href="base.html#topic+formals">formals</a></code> may very well not work as expected.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code>vignette("coverage")</code> for the exact definitions of the
per payment and per loss random variables under an ordinary or
franchise deductible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default case: pdf of the per payment random variable with
## an ordinary deductible
coverage(dgamma, pgamma, deductible = 1)

## Add a limit
f &lt;- coverage(dgamma, pgamma, deductible = 1, limit = 7)
f &lt;- coverage("dgamma", "pgamma", deductible = 1, limit = 7) # same
f(0, shape = 3, rate = 1)
f(2, shape = 3, rate = 1)
f(6, shape = 3, rate = 1)
f(8, shape = 3, rate = 1)
curve(dgamma(x, 3, 1), xlim = c(0, 10), ylim = c(0, 0.3))    # original
curve(f(x, 3, 1), xlim = c(0.01, 5.99), col = 4, add = TRUE) # modified
points(6, f(6, 3, 1), pch = 21, bg = 4)

## Cumulative distribution function
F &lt;- coverage(cdf = pgamma, deductible = 1, limit = 7)
F(0, shape = 3, rate = 1)
F(2, shape = 3, rate = 1)
F(6, shape = 3, rate = 1)
F(8, shape = 3, rate = 1)
curve(pgamma(x, 3, 1), xlim = c(0, 10), ylim = c(0, 1))    # original
curve(F(x, 3, 1), xlim = c(0, 5.99), col = 4, add = TRUE)  # modified
curve(F(x, 3, 1), xlim = c(6, 10), col = 4, add = TRUE)    # modified

## With no deductible, all distributions below are identical
coverage(dweibull, pweibull, limit = 5)
coverage(dweibull, pweibull, per.loss = TRUE, limit = 5)
coverage(dweibull, pweibull, franchise = TRUE, limit = 5)
coverage(dweibull, pweibull, per.loss = TRUE, franchise = TRUE,
         limit = 5)

## Coinsurance alone; only case that does not require the cdf
coverage(dgamma, coinsurance = 0.8)
</code></pre>

<hr>
<h2 id='CTE'>Conditional Tail Expectation</h2><span id='topic+CTE'></span><span id='topic+TVaR'></span><span id='topic+CTE.aggregateDist'></span>

<h3>Description</h3>

<p>Conditional Tail Expectation, also called Tail Value-at-Risk.
</p>
<p><code>TVaR</code> is an alias for <code>CTE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTE(x, ...)

## S3 method for class 'aggregateDist'
CTE(x, conf.level = c(0.9, 0.95, 0.99),
         names = TRUE, ...)

TVaR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CTE_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="CTE_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric vector of probabilities with values
in <code class="reqn">[0, 1)</code>.</p>
</td></tr>
<tr><td><code id="CTE_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code>names</code>
attribute.  Set to <code>FALSE</code> for speedup with many <code>probs</code>.</p>
</td></tr>
<tr><td><code id="CTE_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Conditional Tail Expectation (or Tail Value-at-Risk) measures the
average of losses above the Value at Risk for some given confidence
level, that is <code class="reqn">E[X|X &gt; \mathrm{VaR}(X)]</code> where <code class="reqn">X</code> is the loss random
variable.
</p>
<p><code>CTE</code> is a generic function with, currently, only a method for
objects of class <code>"aggregateDist"</code>.
</p>
<p>For the recursive, convolution and simulation methods of
<code><a href="#topic+aggregateDist">aggregateDist</a></code>, the CTE is computed from the definition
using the empirical cdf.
</p>
<p>For the normal approximation method, an explicit formula exists:
</p>
<p style="text-align: center;"><code class="reqn">\mu + \frac{\sigma}{(1 - \alpha) \sqrt{2 \pi}}
    e^{-\mathrm{VaR}(X)^2/2},</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean, <code class="reqn">\sigma</code> the standard
deviation and <code class="reqn">\alpha</code> the confidence level.
</p>
<p>For the Normal Power approximation, the explicit formula given in
CastaÃ±er et al. (2013) is
</p>
<p style="text-align: center;"><code class="reqn">\mu + \frac{\sigma}{(1 - \alpha) \sqrt{2 \pi}}
    e^{-\mathrm{VaR}(X)^2/2}
    \left( 1 + \frac{\gamma}{6} \mathrm{VaR}(X) \right),</code>
</p>

<p>where, as above, <code class="reqn">\mu</code> is the mean, <code class="reqn">\sigma</code> the standard
deviation, <code class="reqn">\alpha</code> the confidence level and <code class="reqn">\gamma</code> is
the skewness.
</p>


<h3>Value</h3>

<p>A numeric vector, named if <code>names</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Tommy Ouellet
</p>


<h3>References</h3>

<p>CastaÃ±er, A. and Claramunt, M.M. and MÃ¡rmol, M. (2013), Tail value at
risk. An analysis with the Normal-Power approximation. In <em>Statistical
and Soft Computing Approaches in Insurance Problems</em>, pp. 87-112. Nova
Science Publishers, 2013. ISBN 978-1-62618-506-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregateDist">aggregateDist</a></code>; <code><a href="#topic+VaR">VaR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model.freq &lt;- expression(data = rpois(7))
model.sev &lt;- expression(data = rnorm(9, 2))
Fs &lt;- aggregateDist("simulation", model.freq, model.sev, nb.simul = 1000)
CTE(Fs)
</code></pre>

<hr>
<h2 id='dental'>Individual Dental Claims Data Set</h2><span id='topic+dental'></span>

<h3>Description</h3>

<p>Basic dental claims on a policy with a deductible of 50.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dental</code></pre>


<h3>Format</h3>

<p>A vector containing 10 observations</p>


<h3>Source</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>

<hr>
<h2 id='discretize'>Discretization of a Continuous Distribution</h2><span id='topic+discretize'></span><span id='topic+discretise'></span>

<h3>Description</h3>

<p>Compute a discrete probability mass function from a continuous
cumulative distribution function (cdf) with various methods.
</p>
<p><code>discretise</code> is an alias for <code>discretize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(cdf, from, to, step = 1,
           method = c("upper", "lower", "rounding", "unbiased"),
           lev, by = step, xlim = NULL)

discretise(cdf, from, to, step = 1,
           method = c("upper", "lower", "rounding", "unbiased"),
           lev, by = step, xlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_cdf">cdf</code></td>
<td>
<p>an expression written as a function of <code>x</code>, or
alternatively the name of a function, giving the cdf to discretize.</p>
</td></tr>
<tr><td><code id="discretize_+3A_from">from</code>, <code id="discretize_+3A_to">to</code></td>
<td>
<p>the range over which the function will be discretized.</p>
</td></tr>
<tr><td><code id="discretize_+3A_step">step</code></td>
<td>
<p>numeric; the discretization step (or span, or lag).</p>
</td></tr>
<tr><td><code id="discretize_+3A_method">method</code></td>
<td>
<p>discretization method to use.</p>
</td></tr>
<tr><td><code id="discretize_+3A_lev">lev</code></td>
<td>
<p>an expression written as a function of <code>x</code>, or
alternatively the name of a function, to compute the limited
expected value of the distribution corresponding to
<code>cdf</code>. Used only with the <code>"unbiased"</code> method.</p>
</td></tr>
<tr><td><code id="discretize_+3A_by">by</code></td>
<td>
<p>an alias for <code>step</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_xlim">xlim</code></td>
<td>
<p>numeric of length 2; if specified, it serves as default
for <code>c(from, to)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage is similar to <code><a href="graphics.html#topic+curve">curve</a></code>.
</p>
<p><code>discretize</code> returns the probability mass function (pmf) of the
random variable obtained by discretization of the cdf specified in
<code>cdf</code>.
</p>
<p>Let <code class="reqn">F(x)</code> denote the cdf, <code class="reqn">E[\min(X, x)]</code> the
limited expected value at <code class="reqn">x</code>, <code class="reqn">h</code> the step, <code class="reqn">p_x</code>
the probability mass at <code class="reqn">x</code> in the discretized distribution and
set <code class="reqn">a =</code> <code>from</code> and <code class="reqn">b =</code> <code>to</code>.
</p>
<p>Method <code>"upper"</code> is the forward difference of the cdf <code class="reqn">F</code>:
</p>
<p style="text-align: center;"><code class="reqn">p_x = F(x + h) - F(x)</code>
</p>

<p>for <code class="reqn">x = a, a + h, \dots, b - step</code>.
</p>
<p>Method <code>"lower"</code> is the backward difference of the cdf <code class="reqn">F</code>:
</p>
<p style="text-align: center;"><code class="reqn">p_x = F(x) - F(x - h)</code>
</p>
<p> for <code class="reqn">x = a +
    h, \dots, b</code> and <code class="reqn">p_a = F(a)</code>.
</p>
<p>Method <code>"rounding"</code> has the true cdf pass through the
midpoints of the intervals <code class="reqn">[x - h/2, x + h/2)</code>:
</p>
<p style="text-align: center;"><code class="reqn">p_x = F(x + h/2) - F(x - h/2)</code>
</p>

<p>for <code class="reqn">x = a + h, \dots, b - step</code> and <code class="reqn">p_a = F(a + h/2)</code>. The function assumes the cdf is continuous. Any
adjusment necessary for discrete distributions can be done via
<code>cdf</code>.
</p>
<p>Method <code>"unbiased"</code> matches the first moment of the discretized
and the true distributions. The probabilities are as follows:
</p>
<p style="text-align: center;"><code class="reqn">p_a = \frac{E[\min(X, a)] - E[\min(X, a + h)]}{h} + 1 - F(a)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_x = \frac{2 E[\min(X, x)] - E[\min(X, x - h)] - E[\min(X, x +
      h)]}{h}, \quad a &lt; x &lt; b</code>
</p>

<p style="text-align: center;"><code class="reqn">p_b = \frac{E[\min(X, b)] - E[\min(X, b - h)]}{h} - 1 + F(b),</code>
</p>



<h3>Value</h3>

<p>A numeric vector of probabilities suitable for use in
<code><a href="#topic+aggregateDist">aggregateDist</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregateDist">aggregateDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0, 5, 0.5)

op &lt;- par(mfrow = c(1, 1), col = "black")

## Upper and lower discretization
fu &lt;- discretize(pgamma(x, 1), method = "upper",
                 from = 0, to = 5, step = 0.5)
fl &lt;- discretize(pgamma(x, 1), method = "lower",
                 from = 0, to = 5, step = 0.5)
curve(pgamma(x, 1), xlim = c(0, 5))
par(col = "blue")
plot(stepfun(head(x, -1), diffinv(fu)), pch = 19, add = TRUE)
par(col = "green")
plot(stepfun(x, diffinv(fl)), pch = 19, add = TRUE)
par(col = "black")

## Rounding (or midpoint) discretization
fr &lt;- discretize(pgamma(x, 1), method = "rounding",
                 from = 0, to = 5, step = 0.5)
curve(pgamma(x, 1), xlim = c(0, 5))
par(col = "blue")
plot(stepfun(head(x, -1), diffinv(fr)), pch = 19, add = TRUE)
par(col = "black")

## First moment matching
fb &lt;- discretize(pgamma(x, 1), method = "unbiased",
                 lev = levgamma(x, 1), from = 0, to = 5, step = 0.5)
curve(pgamma(x, 1), xlim = c(0, 5))
par(col = "blue")
plot(stepfun(x, diffinv(fb)), pch = 19, add = TRUE)

par(op)
</code></pre>

<hr>
<h2 id='elev'>Empirical Limited Expected Value</h2><span id='topic+elev'></span><span id='topic+elev.default'></span><span id='topic+elev.grouped.data'></span><span id='topic+print.elev'></span><span id='topic+summary.elev'></span><span id='topic+knots.elev'></span><span id='topic+plot.elev'></span>

<h3>Description</h3>

<p>Compute the empirical limited expected value for individual or grouped
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elev(x, ...)

## Default S3 method:
elev(x, ...)

## S3 method for class 'grouped.data'
elev(x, ...)

## S3 method for class 'elev'
print(x, digits = getOption("digits") - 2, ...)

## S3 method for class 'elev'
summary(object, ...)

## S3 method for class 'elev'
knots(Fn, ...)

## S3 method for class 'elev'
plot(x, ..., main = NULL, xlab = "x", ylab = "Empirical LEV")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elev_+3A_x">x</code></td>
<td>
<p>a vector or an object of class <code>"grouped.data"</code> (in
which case only the first column of frequencies is used); for the
methods, an object of class <code>"elev"</code>, typically.</p>
</td></tr>
<tr><td><code id="elev_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use, see
<code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="elev_+3A_fn">Fn</code>, <code id="elev_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"ogive"</code>.</p>
</td></tr>
<tr><td><code id="elev_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="elev_+3A_xlab">xlab</code>, <code id="elev_+3A_ylab">ylab</code></td>
<td>
<p>labels of x and y axis.</p>
</td></tr>
<tr><td><code id="elev_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The limited expected value (LEV) at <code class="reqn">u</code> of a random variable
<code class="reqn">X</code> is
<code class="reqn">E[X \wedge u] = E[\min(X, u)]</code>. For
individual data <code class="reqn">x_1, \dots, x_n</code>, the
empirical LEV <code class="reqn">E_n[X \wedge u]</code> is thus
</p>
<p style="text-align: center;"><code class="reqn">E_n[X \wedge u] = \frac{1}{n}
    \left( \sum_{x_j &lt; u} x_j + \sum_{x_j \geq u} u \right).</code>
</p>

<p>Methods of <code>elev</code> exist for individual data or for grouped data
created with <code><a href="#topic+grouped.data">grouped.data</a></code>. The formula in this case is
too long to show here. See the reference for details.
</p>


<h3>Value</h3>

<p>For <code>elev</code>, a function of class <code>"elev"</code>, inheriting from the
<code>"<a href="base.html#topic+function">function</a>"</code> class.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped data objects;
<code><a href="stats.html#topic+stepfun">stepfun</a></code> for related documentation (even though the
empirical LEV is not a step function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)
lev &lt;- elev(gdental)
lev
summary(lev)
knots(lev)            # the group boundaries

lev(knots(lev))       # empirical lev at boundaries
lev(c(80, 200, 2000)) # and at other limits

plot(lev, type = "o", pch = 16)
</code></pre>

<hr>
<h2 id='emm'>Empirical Moments</h2><span id='topic+emm'></span><span id='topic+emm.default'></span><span id='topic+emm.grouped.data'></span>

<h3>Description</h3>

<p>Raw empirical moments for individual and grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emm(x, order = 1, ...)

## Default S3 method:
emm(x, order = 1, ...)

## S3 method for class 'grouped.data'
emm(x, order = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emm_+3A_x">x</code></td>
<td>
<p>a vector or matrix of individual data, or an object of class
<code>"grouped data"</code>.</p>
</td></tr>
<tr><td><code id="emm_+3A_order">order</code></td>
<td>
<p>order of the moment. Must be positive.</p>
</td></tr>
<tr><td><code id="emm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>...</code> are passed to <code><a href="Matrix.html#topic+colMeans">colMeans</a></code>;
<code>na.rm = TRUE</code> may be useful for individual data with missing
values. 
</p>
<p>For individual data, the <code class="reqn">k</code>th empirical moment is
<code class="reqn">\sum_{j = 1}^n x_j^k</code>.
</p>
<p>For grouped data with group boundaries <code class="reqn">c_0, c_1, \dots,
    c_r</code> and group frequencies <code class="reqn">n_1, \dots,
    n_r</code>, the <code class="reqn">k</code>th empirical moment is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n} \sum_{j = 1}^r \frac{n_j (c_j^{k + 1} - c_{j - 1}^{k + 1})}{%
      (k + 1) (c_j - c_{j - 1})},</code>
</p>

<p>where <code class="reqn">n = \sum_{j = 1}^r n_j</code>.
</p>


<h3>Value</h3>

<p>A named vector or matrix of moments.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code> and <code><a href="#topic+mean.grouped.data">mean.grouped.data</a></code> for simpler
access to the first moment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Individual data
data(dental)
emm(dental, order = 1:3)

## Grouped data
data(gdental)
emm(gdental)
x &lt;- grouped.data(cj = gdental[, 1],
                  nj1 = sample(1:100, nrow(gdental)),
                  nj2 = sample(1:100, nrow(gdental)))
emm(x) # same as mean(x)
</code></pre>

<hr>
<h2 id='ExponentialSupp'>Moments and Moment Generating Function of the Exponential Distribution</h2><span id='topic+ExponentialSupp'></span><span id='topic+mexp'></span><span id='topic+levexp'></span><span id='topic+mgfexp'></span>

<h3>Description</h3>

<p>Raw moments, limited moments and moment generating function for the
exponential distribution with rate <code>rate</code> (i.e., mean
<code>1/rate</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexp(order, rate = 1)
levexp(limit, rate = 1, order = 1)
mgfexp(t, rate = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExponentialSupp_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="ExponentialSupp_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="ExponentialSupp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="ExponentialSupp_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="ExponentialSupp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the cumulant generating function
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code> and the moment
generating function is <code class="reqn">E[e^{tX}]</code>, <code class="reqn">k &gt; -1</code>.
</p>


<h3>Value</h3>

<p><code>mexp</code> gives the <code class="reqn">k</code>th raw moment,
<code>levexp</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable, and
<code>mgfexp</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Christophe Dutang and Mathieu Pigeon.
</p>


<h3>References</h3>

<p>Johnson, N. L. and Kotz, S. (1970), <em>Continuous Univariate
Distributions, Volume 1</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Exponential">Exponential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mexp(2, 3) - mexp(1, 3)^2
levexp(10, 3, order = 2)
mgfexp(1,2)
</code></pre>

<hr>
<h2 id='Extract.grouped.data'>Extract or Replace Parts of a Grouped Data Object</h2><span id='topic+Extract.grouped.data'></span><span id='topic++5B.grouped.data'></span><span id='topic++5B+3C-.grouped.data'></span>

<h3>Description</h3>

<p>Extract or replace subsets of grouped data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped.data'
x[i, j]
## S3 replacement method for class 'grouped.data'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.grouped.data_+3A_x">x</code></td>
<td>
<p>an object of class <code>grouped.data</code>.</p>
</td></tr>
<tr><td><code id="Extract.grouped.data_+3A_i">i</code>, <code id="Extract.grouped.data_+3A_j">j</code></td>
<td>
<p>elements to extract or replace. <code>i, j</code> are
<code>numeric</code> or <code>character</code> or, for <code>[</code> only, empty.
Numeric values are coerced to integer as if by
<code><a href="base.html#topic+as.integer">as.integer</a></code>. For replacement by <code>[</code>, a logical
matrix is allowed, but not replacement in the group boundaries and
group frequencies simultaneously.</p>
</td></tr>
<tr><td><code id="Extract.grouped.data_+3A_value">value</code></td>
<td>
<p>a suitable replacement value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"grouped.data"</code> can mostly be indexed like data
frames, with the following restrictions:
</p>

<ol>
<li><p> For <code>[</code>, the extracted object must keep a group
boundaries column and at least one group frequencies column to
remain of class <code>"grouped.data"</code>;
</p>
</li>
<li><p> For <code>[&lt;-</code>, it is not possible to replace group boundaries
and group frequencies simultaneously;
</p>
</li>
<li><p> When replacing group boundaries, <code>length(value) ==
      length(i) + 1</code>.
</p>
</li></ol>

<p><code>x[, 1]</code> will return the plain vector of group boundaries.
</p>
<p>Replacement of non adjacent group boundaries is not possible for
obvious reasons.
</p>
<p>Otherwise, extraction and replacement should work just like for data
frames.
</p>


<h3>Value</h3>

<p>For <code>[</code> an object of class <code>"grouped.data"</code>, a data frame or a
vector.
</p>
<p>For <code>[&lt;-</code> an object of class <code>"grouped.data"</code>.
</p>


<h3>Note</h3>

<p>Currently <code>[[</code>, <code>[[&lt;-</code>, <code>$</code> and <code>$&lt;-</code> are not 
specifically supported, but should work as usual on group frequency
columns.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> for extraction and replacement
methods of data frames, <code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped
data objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)

(x &lt;- gdental[1])         # select column 1
class(x)                  # no longer a grouped.data object
class(gdental[2])         # same
gdental[, 1]              # group boundaries
gdental[, 2]              # group frequencies

gdental[1:4,]             # a subset
gdental[c(1, 3, 5),]      # avoid this

gdental[1:2, 1] &lt;- c(0, 30, 60) # modified boundaries
gdental[, 2] &lt;- 10              # modified frequencies
## Not run: gdental[1, ] &lt;- 2   # not allowed
</code></pre>

<hr>
<h2 id='FellerPareto'>The Feller Pareto Distribution</h2><span id='topic+FellerPareto'></span><span id='topic+dfpareto'></span><span id='topic+pfpareto'></span><span id='topic+qfpareto'></span><span id='topic+rfpareto'></span><span id='topic+mfpareto'></span><span id='topic+levfpareto'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Feller Pareto distribution
with parameters <code>min</code>, <code>shape1</code>, <code>shape2</code>, <code>shape3</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfpareto(x, min, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        log = FALSE)
pfpareto(q, min, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
qfpareto(p, min, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
rfpareto(n, min, shape1, shape2, shape3, rate = 1, scale = 1/rate)
mfpareto(order, min, shape1, shape2, shape3, rate = 1, scale = 1/rate)
levfpareto(limit, min, shape1, shape2, shape3, rate = 1, scale = 1/rate,
          order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FellerPareto_+3A_x">x</code>, <code id="FellerPareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_min">min</code></td>
<td>
<p>lower bound of the support of the distribution.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_shape1">shape1</code>, <code id="FellerPareto_+3A_shape2">shape2</code>, <code id="FellerPareto_+3A_shape3">shape3</code>, <code id="FellerPareto_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly
positive.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_log">log</code>, <code id="FellerPareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="FellerPareto_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Feller-Pareto distribution with parameters <code>min</code> <code class="reqn">= \mu</code>,
<code>shape1</code> <code class="reqn">= \alpha</code>, <code>shape2</code> <code class="reqn">= \gamma</code>,
<code>shape3</code> <code class="reqn">= \tau</code> and <code>scale</code> <code class="reqn">= \theta</code>, has
density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\Gamma(\alpha + \tau)}{\Gamma(\alpha)\Gamma(\tau)}
    \frac{\gamma ((x - \mu)/\theta)^{\gamma \tau - 1}}{%
      \theta [1 + ((x - \mu)/\theta)^\gamma]^{\alpha + \tau}}</code>
</p>

<p>for <code class="reqn">x &gt; \mu</code>, <code class="reqn">-\infty &lt; \mu &lt; \infty</code>,
<code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code>,
<code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The Feller-Pareto is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\mu + \theta \left(\frac{1 - X}{X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">\alpha</code>
and <code class="reqn">\tau</code>.
</p>
<p>The Feller-Pareto defines a large family of distributions encompassing
the transformed beta family and many variants of the Pareto
distribution. Setting <code class="reqn">\mu = 0</code> yields the
<a href="#topic+dtrbeta">transformed beta</a> distribution.
</p>
<p>The Feller-Pareto distribution also has the following direct special
cases:
</p>

<ul>
<li><p> A <a href="#topic+dpareto4">Pareto IV</a> distribution when <code>shape3
      == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto3">Pareto III</a> distribution when <code>shape1
      shape3 == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto2">Pareto II</a> distribution when <code>shape1
      shape2 == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto1">Pareto I</a> distribution when <code>shape1
      shape2 == 1</code> and <code>min = scale</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> for nonnegative integer values of <code class="reqn">k &lt;
  \alpha\gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code> for nonnegative integer values of <code class="reqn">k</code>
and <code class="reqn">\alpha - j/\gamma</code>, <code class="reqn">j = 1, \dots, k</code>
not a negative integer.
</p>
<p>Note that the range of admissible values for <code class="reqn">k</code> in raw and
limited moments is larger when <code class="reqn">\mu = 0</code>.
</p>


<h3>Value</h3>

<p><code>dfpareto</code> gives the density,
<code>pfpareto</code> gives the distribution function,
<code>qfpareto</code> gives the quantile function,
<code>rfpareto</code> generates random deviates,
<code>mfpareto</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levfpareto</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levfpareto</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>For the Feller-Pareto and other Pareto distributions, we use the
classification of Arnold (2015) with the parametrization of Klugman et
al. (2012).  
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Nicholas Langevin
</p>


<h3>References</h3>

<p>Dutang, C., Goulet, V., Langevin, N. (2022).
Feller-Pareto and Related Distributions: Numerical Implementation and Actuarial
Applications.
<em>Journal of Statistical Software</em>, <b>103</b>(6), 1&ndash;22.
<a href="https://doi.org/10.18637/jss.v103.i06">doi:10.18637/jss.v103.i06</a>.
</p>
<p>Abramowitz, M. and Stegun, I. A. (1972), <em>Handbook of 
Mathematical Functions</em>, Dover.
</p>
<p>Arnold, B. C. (2015), <em>Pareto Distributions</em>, Second Edition, CRC
Press.
</p>
<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtrbeta">dtrbeta</a></code> for the transformed beta distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dfpareto(2, 1, 2, 3, 4, 5, log = TRUE))
p &lt;- (1:10)/10
pfpareto(qfpareto(p, 1, 2, 3, 4, 5), 1, 2, 3, 4, 5)

## variance
mfpareto(2, 1, 2, 3, 4, 5) - mfpareto(1, 1, 2, 3, 4, 5)^2

## case with shape1 - order/shape2 &gt; 0
levfpareto(10, 1, 2, 3, 4, scale = 1, order = 2)

## case with shape1 - order/shape2 &lt; 0
levfpareto(20, 10, 0.1, 14, 2, scale = 1.5, order = 2)
</code></pre>

<hr>
<h2 id='GammaSupp'>Moments and Moment Generating Function of the Gamma Distribution</h2><span id='topic+GammaSupp'></span><span id='topic+mgamma'></span><span id='topic+levgamma'></span><span id='topic+mgfgamma'></span>

<h3>Description</h3>

<p>Raw moments, limited moments and moment generating function for the
Gamma distribution with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgamma(order, shape, rate = 1, scale = 1/rate)
levgamma(limit, shape, rate = 1, scale = 1/rate, order = 1)
mgfgamma(t, shape, rate = 1, scale = 1/rate, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GammaSupp_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="GammaSupp_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="GammaSupp_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="GammaSupp_+3A_shape">shape</code>, <code id="GammaSupp_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters. Must be strictly
positive.</p>
</td></tr>
<tr><td><code id="GammaSupp_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="GammaSupp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the cumulant generating function
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code> and the moment
generating function is <code class="reqn">E[e^{tX}]</code>, <code class="reqn">k &gt;
  -\alpha</code>.
</p>


<h3>Value</h3>

<p><code>mgamma</code> gives the <code class="reqn">k</code>th raw moment,
<code>levgamma</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable, and
<code>mgfgamma</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Christophe Dutang and Mathieu Pigeon
</p>


<h3>References</h3>

<p>Johnson, N. L. and Kotz, S. (1970), <em>Continuous Univariate
Distributions, Volume 1</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgamma(2, 3, 4) - mgamma(1, 3, 4)^2
levgamma(10, 3, 4, order = 2)
mgfgamma(1,3,2)
</code></pre>

<hr>
<h2 id='gdental'>Grouped Dental Claims Data Set</h2><span id='topic+gdental'></span>

<h3>Description</h3>

<p>Grouped dental claims, that is presented in a number of claims per
claim amount group form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdental</code></pre>


<h3>Format</h3>

<p>An object of class <code>"grouped.data"</code> (inheriting from class
<code>"data.frame"</code>) consisting of 10 rows and 2 columns. The
environment of the object contains the plain vector of <code>cj</code> of
group boundaries
</p>


<h3>Source</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped.data">grouped.data</a></code> for a description of grouped data objects.
</p>

<hr>
<h2 id='GeneralizedBeta'>The Generalized Beta Distribution</h2><span id='topic+GeneralizedBeta'></span><span id='topic+dgenbeta'></span><span id='topic+pgenbeta'></span><span id='topic+qgenbeta'></span><span id='topic+rgenbeta'></span><span id='topic+mgenbeta'></span><span id='topic+levgenbeta'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Generalized Beta distribution
with parameters <code>shape1</code>, <code>shape2</code>, <code>shape3</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenbeta(x, shape1, shape2, shape3, rate = 1, scale = 1/rate,
         log = FALSE)
pgenbeta(q, shape1, shape2, shape3, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qgenbeta(p, shape1, shape2, shape3, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rgenbeta(n, shape1, shape2, shape3, rate = 1, scale = 1/rate)
mgenbeta(order, shape1, shape2, shape3, rate = 1, scale = 1/rate)
levgenbeta(limit, shape1, shape2, shape3, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralizedBeta_+3A_x">x</code>, <code id="GeneralizedBeta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_shape1">shape1</code>, <code id="GeneralizedBeta_+3A_shape2">shape2</code>, <code id="GeneralizedBeta_+3A_shape3">shape3</code>, <code id="GeneralizedBeta_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly
positive.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_log">log</code>, <code id="GeneralizedBeta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="GeneralizedBeta_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized beta distribution with parameters <code>shape1</code> <code class="reqn">=
    \alpha</code>, <code>shape2</code> <code class="reqn">= \beta</code>, <code>shape3</code>
<code class="reqn">= \tau</code> and <code>scale</code> <code class="reqn">= \theta</code>, has
density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
    (x/\theta)^{\alpha \tau} (1 - (x/\theta)^\tau)^{\beta - 1}
    \frac{\tau}{x}</code>
</p>

<p>for <code class="reqn">0 &lt; x &lt; \theta</code>, <code class="reqn">\alpha &gt; 0</code>,
<code class="reqn">\beta &gt; 0</code>, <code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>. (Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The generalized beta is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\theta X^{1/\tau},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">\alpha</code>
and <code class="reqn">\beta</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)]</code>, <code class="reqn">k &gt; -\alpha\tau</code>.
</p>


<h3>Value</h3>

<p><code>dgenbeta</code> gives the density,
<code>pgenbeta</code> gives the distribution function,
<code>qgenbeta</code> gives the quantile function,
<code>rgenbeta</code> generates random deviates,
<code>mgenbeta</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levgenbeta</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>This is <em>not</em> the generalized three-parameter beta distribution
defined on page 251 of Johnson et al, 1995.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Johnson, N. L., Kotz, S. and Balakrishnan, N. (1995)
<em>Continuous Univariate Distributions, Volume 2</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dgenbeta(2, 2, 3, 4, 0.2, log = TRUE))
p &lt;- (1:10)/10
pgenbeta(qgenbeta(p, 2, 3, 4, 0.2), 2, 3, 4, 0.2)
mgenbeta(2, 1, 2, 3, 0.25) - mgenbeta(1, 1, 2, 3, 0.25) ^ 2
levgenbeta(10, 1, 2, 3, 0.25, order = 2)
</code></pre>

<hr>
<h2 id='GeneralizedPareto'>The Generalized Pareto Distribution</h2><span id='topic+GeneralizedPareto'></span><span id='topic+dgenpareto'></span><span id='topic+pgenpareto'></span><span id='topic+qgenpareto'></span><span id='topic+rgenpareto'></span><span id='topic+mgenpareto'></span><span id='topic+levgenpareto'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Generalized Pareto
distribution with parameters <code>shape1</code>, <code>shape2</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenpareto(x, shape1, shape2, rate = 1, scale = 1/rate,
           log = FALSE)
pgenpareto(q, shape1, shape2, rate = 1, scale = 1/rate,
           lower.tail = TRUE, log.p = FALSE)
qgenpareto(p, shape1, shape2, rate = 1, scale = 1/rate,
           lower.tail = TRUE, log.p = FALSE)
rgenpareto(n, shape1, shape2, rate = 1, scale = 1/rate)
mgenpareto(order, shape1, shape2, rate = 1, scale = 1/rate)
levgenpareto(limit, shape1, shape2, rate = 1, scale = 1/rate,
             order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralizedPareto_+3A_x">x</code>, <code id="GeneralizedPareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_shape1">shape1</code>, <code id="GeneralizedPareto_+3A_shape2">shape2</code>, <code id="GeneralizedPareto_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_log">log</code>, <code id="GeneralizedPareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="GeneralizedPareto_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generalized Pareto distribution with parameters <code>shape1</code>
<code class="reqn">= \alpha</code>, <code>shape2</code> <code class="reqn">= \tau</code> and <code>scale</code>
<code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\Gamma(\alpha + \tau)}{\Gamma(\alpha)\Gamma(\tau)}
    \frac{\theta^\alpha x^{\tau - 1}}{%
      (x + \theta)^{\alpha + \tau}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\tau &gt; 0</code> and
<code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The Generalized Pareto is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\theta \left(\frac{X}{1 - X}\right),</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">\alpha</code>
and <code class="reqn">\tau</code>.
</p>
<p>The Generalized Pareto distribution has the following special cases:
</p>

<ul>
<li><p> A <a href="#topic+dpareto">Pareto</a> distribution when <code>shape2 ==
      1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvpareto">Inverse Pareto</a> distribution when
<code>shape1 == 1</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\tau &lt; k &lt; \alpha</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>,
<code class="reqn">k &gt; -\tau</code> and <code class="reqn">\alpha - k</code> not a
negative integer.
</p>


<h3>Value</h3>

<p><code>dgenpareto</code> gives the density,
<code>pgenpareto</code> gives the distribution function,
<code>qgenpareto</code> gives the quantile function,
<code>rgenpareto</code> generates random deviates,
<code>mgenpareto</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levgenpareto</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levgenpareto</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>Distribution also known as the Beta of the Second Kind. See also
Kleiber and Kotz (2003) for alternative names and parametrizations.
</p>
<p>The Generalized Pareto distribution defined here is different from the
one in Embrechts et al. (1997) and in
<a href="https://en.wikipedia.org/wiki/Generalized_Pareto_distribution">Wikipedia</a>;
see also Kleiber and Kotz (2003, section 3.12). One may most likely
compute quantities for the latter using functions for the
<a href="#topic+dpareto">Pareto</a> distribution with the appropriate change of
parametrization.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Embrechts, P., KlÃ¼ppelberg, C. and Mikisch, T. (1997), <em>Modelling
Extremal Events for Insurance and Finance</em>, Springer.
</p>
<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dgenpareto(3, 3, 4, 4, log = TRUE))
p &lt;- (1:10)/10
pgenpareto(qgenpareto(p, 3, 3, 1), 3, 3, 1)
qgenpareto(.3, 3, 4, 4, lower.tail = FALSE)

## variance
mgenpareto(2, 3, 2, 1) - mgenpareto(1, 3, 2, 1)^2

## case with shape1 - order &gt; 0
levgenpareto(10, 3, 3, scale = 1, order = 2)

## case with shape1 - order &lt; 0
levgenpareto(10, 1.5, 3, scale = 1, order = 2)
</code></pre>

<hr>
<h2 id='grouped.data'>Grouped data</h2><span id='topic+grouped.data'></span>

<h3>Description</h3>

<p>Creation of grouped data objects, from either a provided set of group
boundaries and group frequencies, or from individual data using
automatic or specified breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped.data(..., breaks = "Sturges", include.lowest = TRUE,
             right = TRUE, nclass = NULL, group = FALSE,
             row.names = NULL, check.rows = FALSE,
             check.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped.data_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>value</code> or <code>tag = value</code>;
see Details.</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_breaks">breaks</code></td>
<td>
<p>same as for <code><a href="graphics.html#topic+hist">hist</a></code>, namely one of:
</p>

<ul>
<li><p>a vector giving the breakpoints between groups;
</p>
</li>
<li><p>a function to compute the vector of breakpoints;
</p>
</li>
<li><p>a single number giving the number of groups;
</p>
</li>
<li><p>a character string naming an algorithm to compute the
number of groups (see <code><a href="graphics.html#topic+hist">hist</a></code>);
</p>
</li>
<li><p>a function to compute the number of groups.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; the
breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values.  If
<code>breaks</code> is a function, the first element in <code>...</code>
is supplied to it as the only argument.
</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical; if <code>TRUE</code>, a data point equal to
the <code>breaks</code> value will be included in the first (or last, for
<code>right = FALSE</code>) group. Used only for individual data; see
Details.</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_right">right</code></td>
<td>
<p>logical; indicating if the intervals should be closed on
the right (and open on the left) or vice versa.</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_nclass">nclass</code></td>
<td>
<p>numeric (integer); equivalent to <code>breaks</code> for a
scalar or character argument.</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_group">group</code></td>
<td>
<p>logical; an alternative way to force grouping of
individual data.</p>
</td></tr>
<tr><td><code id="grouped.data_+3A_row.names">row.names</code>, <code id="grouped.data_+3A_check.rows">check.rows</code>, <code id="grouped.data_+3A_check.names">check.names</code></td>
<td>
<p>arguments identical to those
of <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grouped data object is a special form of data frame consisting of
one column of contiguous group boundaries and one or more columns of
frequencies within each group.
</p>
<p>The function can create a grouped data object from two types of
arguments.
</p>

<ol>
<li><p>Group boundaries and frequencies. This is the default mode of
operation if the call has at least two elements in <code>...</code>.
</p>
<p>The first argument will then be taken as the vector of group
boundaries. This vector must be exactly one element longer than
the other arguments, which will be taken as vectors of group
frequencies. All arguments are coerced to data frames.
</p>
</li>
<li><p>Individual data. This mode of operation is active if there
is a single argument in <code>...</code>, or if either <code>breaks</code>
or <code>nclass</code> is specified or <code>group</code> is <code>TRUE</code>.
</p>
<p>Arguments of <code>...</code> are first grouped using
<code><a href="graphics.html#topic+hist">hist</a></code>. If needed, breakpoints are set using the first
argument.
</p>
</li></ol>

<p>Missing (<code>NA</code>) frequencies are replaced by zeros, with a
warning.
</p>
<p>Extraction and replacement methods exist for <code>grouped.data</code>
objects, but working on non adjacent groups will most likely yield
useless results.
</p>


<h3>Value</h3>

<p>An object of <code>class</code> <code>c("grouped.data", "data.frame")</code> with
an environment containing the vector <code>cj</code> of group boundaries.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Mathieu Pigeon and Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B.grouped.data">[.grouped.data</a></code> for extraction and replacement methods.
</p>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code> for usual data frame creation and
manipulation.
</p>
<p><code><a href="graphics.html#topic+hist">hist</a></code> for details on the calculation of breakpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Most common usage using a predetermined set of group
## boundaries and group frequencies.
cj &lt;- c(0, 25, 50, 100, 250, 500, 1000)
nj &lt;- c(30, 31, 57, 42, 45, 10)
(x &lt;- grouped.data(Group = cj, Frequency = nj))
class(x)

x[, 1] # group boundaries
x[, 2] # group frequencies

## Multiple frequency columns are supported
x &lt;- sample(1:100, 9)
y &lt;- sample(1:100, 9)
grouped.data(cj = 1:10, nj.1 = x, nj.2 = y)

## Alternative usage with grouping of individual data.
grouped.data(x)                         # automatic breakpoints
grouped.data(x, breaks = 7)             # forced number of groups
grouped.data(x, breaks = c(0,25,75,100))    # specified groups
grouped.data(x, y, breaks = c(0,25,75,100)) # multiple data sets

## Not run: ## Providing two or more data sets and automatic breakpoints is
## very error-prone since the range of the first data set has to
## include the ranges of all the other data sets.
range(x)
range(y)
grouped.data(x, y, group = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='Gumbel'>The Gumbel Distribution</h2><span id='topic+Gumbel'></span><span id='topic+dgumbel'></span><span id='topic+pgumbel'></span><span id='topic+qgumbel'></span><span id='topic+rgumbel'></span><span id='topic+mgumbel'></span><span id='topic+mgfgumbel'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random
generation and raw moments for the Gumbel extreme value distribution
with parameters <code>alpha</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, alpha, scale, log = FALSE)
pgumbel(q, alpha, scale, lower.tail = TRUE, log.p = FALSE)
qgumbel(p, alpha, scale, lower.tail = TRUE, log.p = FALSE)
rgumbel(n, alpha, scale)
mgumbel(order, alpha, scale)
mgfgumbel(t, alpha, scale, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_x">x</code>, <code id="Gumbel_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_alpha">alpha</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_scale">scale</code></td>
<td>
<p>parameter. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_log">log</code>, <code id="Gumbel_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_order">order</code></td>
<td>
<p>order of the moment. Only values <code class="reqn">1</code> and <code class="reqn">2</code> are
supported.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gumbel distribution with parameters <code>alpha</code> <code class="reqn">=
    \alpha</code> and <code>scale</code> <code class="reqn">= \theta</code> has distribution
function:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp[-\exp(-(x - \alpha)/\theta)]</code>
</p>

<p>for <code class="reqn">-\infty &lt; x &lt; \infty</code>, <code class="reqn">-\infty &lt; a &lt;
    \infty</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The mode of the distribution is in <code class="reqn">\alpha</code>, the mean is
<code class="reqn">\alpha + \gamma\theta</code>, where <code class="reqn">\gamma</code> <code class="reqn">=
  0.57721566</code> is the Euler-Mascheroni constant, and the variance is
<code class="reqn">\pi^2 \theta^2/6</code>.
</p>


<h3>Value</h3>

<p><code>dgumbel</code> gives the density,
<code>pgumbel</code> gives the distribution function,
<code>qgumbel</code> gives the quantile function,
<code>rgumbel</code> generates random deviates,
<code>mgumbel</code> gives the <code class="reqn">k</code>th raw moment, <code class="reqn">k = 1, 2</code>, and
<code>mgfgamma</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>Distribution also knonw as the generalized extreme value distribution
Type-I.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgumbel(c(-5, 0, 10, 20), 0.5, 2)

p &lt;- (1:10)/10
pgumbel(qgumbel(p, 2, 3), 2, 3)

curve(pgumbel(x, 0.5, 2), from = -5, to = 20, col = "red")
curve(pgumbel(x, 1.0, 2), add = TRUE, col = "green")
curve(pgumbel(x, 1.5, 3), add = TRUE, col = "blue")
curve(pgumbel(x, 3.0, 4), add = TRUE, col = "cyan")

a &lt;- 3; s &lt;- 4
mgumbel(1, a, s)                        # mean
a - s * digamma(1)                      # same

mgumbel(2, a, s) - mgumbel(1, a, s)^2   # variance
(pi * s)^2/6                            # same
</code></pre>

<hr>
<h2 id='hachemeister'>Hachemeister Data Set</h2><span id='topic+hachemeister'></span>

<h3>Description</h3>

<p>Hachemeister (1975) data set giving average claim amounts in private
passenger bodily injury insurance in five U.S. states over 12 quarters
between July 1970 and June 1973 and the corresponding number of
claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hachemeister</code></pre>


<h3>Format</h3>

<p>A matrix with 5 rows and the following 25 columns:
</p>

<dl>
<dt><code>state</code></dt><dd><p>the state number;</p>
</dd>
<dt><code>ratio.1</code>, ..., <code>ratio.12</code></dt><dd><p>the average claim
amounts;</p>
</dd>
<dt><code>weight.1</code>, ..., <code>weight.12</code></dt><dd><p>the
corresponding number of claims.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hachemeister, C. A. (1975), <em>Credibility for regression
models with application to trend</em>, Proceedings of the Berkeley
Actuarial Research Conference on Credibility, Academic Press.
</p>

<hr>
<h2 id='hist.grouped.data'>Histogram for Grouped Data</h2><span id='topic+hist.grouped.data'></span>

<h3>Description</h3>

<p>This method for the generic function <code><a href="graphics.html#topic+hist">hist</a></code> is mainly
useful to plot the histogram of grouped data. If <code>plot = FALSE</code>,
the resulting object of class <code>"histogram"</code> is returned for
compatibility with <code><a href="graphics.html#topic+hist.default">hist.default</a></code>, but does not contain
much information not already in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped.data'
hist(x, freq = NULL, probability = !freq,
     density = NULL, angle = 45, col = NULL, border = NULL,
     main = paste("Histogram of" , xname),
     xlim = range(x), ylim = NULL, xlab = xname, ylab,
     axes = TRUE, plot = TRUE, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.grouped.data_+3A_x">x</code></td>
<td>
<p>an object of class <code>"grouped.data"</code>; only the first
column of frequencies is used.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_freq">freq</code></td>
<td>
<p>logical; if <code>TRUE</code>, the histogram graphic is a
representation of frequencies, the <code>counts</code> component of
the result; if <code>FALSE</code>, probability densities, component
<code>density</code>, are plotted (so that the histogram has a total area
of one). Defaults to <code>TRUE</code> <em>iff</em> group boundaries are
equidistant (and <code>probability</code> is not specified).</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_probability">probability</code></td>
<td>
<p>an <em>alias</em> for <code>!freq</code>, for S compatibility.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch.
The default value of <code>NULL</code> means that no shading lines
are drawn. Non-positive values of <code>density</code> also inhibit the
drawing of shading lines.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in
degrees (counter-clockwise).</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_col">col</code></td>
<td>
<p>a colour to be used to fill the bars.
The default of <code>NULL</code> yields unfilled bars.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_border">border</code></td>
<td>
<p>the color of the border around the bars. The default
is to use the standard foreground color.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_main">main</code>, <code id="hist.grouped.data_+3A_xlab">xlab</code>, <code id="hist.grouped.data_+3A_ylab">ylab</code></td>
<td>
<p>these arguments to <code>title</code> have useful
defaults here.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_xlim">xlim</code>, <code id="hist.grouped.data_+3A_ylim">ylim</code></td>
<td>
<p>the range of x and y values with sensible defaults.
Note that <code>xlim</code> is <em>not</em> used to define the histogram
(breaks), but only for plotting (when <code>plot = TRUE</code>).</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_axes">axes</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), axes are draw if the
plot is drawn.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), a histogram is
plotted, otherwise a list of breaks and counts is returned.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_labels">labels</code></td>
<td>
<p>logical or character. Additionally draw labels on top
of bars, if not <code>FALSE</code>; see <code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>.</p>
</td></tr>
<tr><td><code id="hist.grouped.data_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to
<code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code> and their to <code><a href="graphics.html#topic+title">title</a></code> and
<code><a href="graphics.html#topic+axis">axis</a></code> (if <code>plot=TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"histogram"</code> which is a list with components:
</p>
<table>
<tr><td><code>breaks</code></td>
<td>
<p>the <code class="reqn">r + 1</code> group boundaries.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p><code class="reqn">r</code> integers; the frequency within each group.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>the relative frequencies within each group
<code class="reqn">n_j/n</code>, where <code class="reqn">n_j</code> = <code>counts[j]</code>.</p>
</td></tr>
<tr><td><code>intensities</code></td>
<td>
<p>same as <code>density</code>. Deprecated, but retained
for compatibility.</p>
</td></tr>
<tr><td><code>mids</code></td>
<td>
<p>the <code class="reqn">r</code> group midpoints.</p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p>a character string with the actual <code>x</code> argument name.</p>
</td></tr>
<tr><td><code>equidist</code></td>
<td>
<p>logical, indicating if the distances between
<code>breaks</code> are all the same.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The resulting value does <em>not</em> depend on the values of
the arguments <code>freq</code> (or <code>probability</code>)
or <code>plot</code>. This is intentionally different from S.
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code> and <code><a href="graphics.html#topic+hist.default">hist.default</a></code> for histograms of
individual data and fancy examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)
hist(gdental)
</code></pre>

<hr>
<h2 id='InverseBurr'>The Inverse Burr Distribution</h2><span id='topic+InverseBurr'></span><span id='topic+dinvburr'></span><span id='topic+pinvburr'></span><span id='topic+qinvburr'></span><span id='topic+rinvburr'></span><span id='topic+minvburr'></span><span id='topic+levinvburr'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random
generation, raw moments and limited moments for the Inverse Burr
distribution with parameters <code>shape1</code>, <code>shape2</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvburr(x, shape1, shape2, rate = 1, scale = 1/rate,
         log = FALSE)
pinvburr(q, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qinvburr(p, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rinvburr(n, shape1, shape2, rate = 1, scale = 1/rate)
minvburr(order, shape1, shape2, rate = 1, scale = 1/rate)
levinvburr(limit, shape1, shape2, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseBurr_+3A_x">x</code>, <code id="InverseBurr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_shape1">shape1</code>, <code id="InverseBurr_+3A_shape2">shape2</code>, <code id="InverseBurr_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_log">log</code>, <code id="InverseBurr_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseBurr_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse Burr distribution with parameters <code>shape1</code> <code class="reqn">=
    \tau</code>, <code>shape2</code> <code class="reqn">= \gamma</code> and <code>scale</code>
<code class="reqn">= \theta</code>, has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau \gamma (x/\theta)^{\gamma \tau}}{%
      x [1 + (x/\theta)^\gamma]^{\tau + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\tau &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code> and
<code class="reqn">\theta &gt; 0</code>.
</p>
<p>The inverse Burr is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\theta \left(\frac{X}{1 - X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">\tau</code>
and <code class="reqn">1</code>.
</p>
<p>The inverse Burr distribution has the following special cases:
</p>

<ul>
<li><p> A <a href="#topic+dllogis">Loglogistic</a> distribution when <code>shape1
      == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvpareto">Inverse Pareto</a> distribution when
<code>shape2 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvparalogis">Inverse Paralogistic</a> distribution
when <code>shape1 == shape2</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\tau\gamma &lt; k &lt; \gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\tau\gamma</code>
and <code class="reqn">1 - k/\gamma</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dinvburr</code> gives the density,
<code>invburr</code> gives the distribution function,
<code>qinvburr</code> gives the quantile function,
<code>rinvburr</code> generates random deviates,
<code>minvburr</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvburr</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvburr</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>Also known as the Dagum distribution. See also Kleiber and Kotz (2003)
for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvburr(2, 2, 3, 1, log = TRUE))
p &lt;- (1:10)/10
pinvburr(qinvburr(p, 2, 3, 1), 2, 3, 1)

## variance
minvburr(2, 2, 3, 1) - minvburr(1, 2, 3, 1) ^ 2

## case with 1 - order/shape2 &gt; 0
levinvburr(10, 2, 3, 1, order = 2)

## case with 1 - order/shape2 &lt; 0
levinvburr(10, 2, 1.5, 1, order = 2)
</code></pre>

<hr>
<h2 id='InverseExponential'>The Inverse Exponential Distribution</h2><span id='topic+InverseExponential'></span><span id='topic+dinvexp'></span><span id='topic+pinvexp'></span><span id='topic+qinvexp'></span><span id='topic+rinvexp'></span><span id='topic+minvexp'></span><span id='topic+levinvexp'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation
raw moments and limited moments for the Inverse Exponential
distribution with parameter <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvexp(x, rate = 1, scale = 1/rate, log = FALSE)
pinvexp(q, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)
qinvexp(p, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)
rinvexp(n, rate = 1, scale = 1/rate)
minvexp(order, rate = 1, scale = 1/rate)
levinvexp(limit, rate = 1, scale = 1/rate, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseExponential_+3A_x">x</code>, <code id="InverseExponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_scale">scale</code></td>
<td>
<p>parameter. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_log">log</code>, <code id="InverseExponential_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseExponential_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse exponential distribution with parameter <code>scale</code>
<code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\theta e^{-\theta/x}}{x^2}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k &lt; 1</code>, and the <code class="reqn">k</code>th limited moment at
some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, all
<code class="reqn">k</code>.
</p>


<h3>Value</h3>

<p><code>dinvexp</code> gives the density,
<code>pinvexp</code> gives the distribution function,
<code>qinvexp</code> gives the quantile function,
<code>rinvexp</code> generates random deviates,
<code>minvexp</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvexp</code> calculates the <code class="reqn">k</code>th limited moment.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvexp</code> computes the limited expected value using
<code>gammainc</code> from package <span class="pkg">expint</span>.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvexp(2, 2, log = TRUE))
p &lt;- (1:10)/10
pinvexp(qinvexp(p, 2), 2)
minvexp(0.5, 2)
</code></pre>

<hr>
<h2 id='InverseGamma'>The Inverse Gamma Distribution</h2><span id='topic+InverseGamma'></span><span id='topic+dinvgamma'></span><span id='topic+pinvgamma'></span><span id='topic+qinvgamma'></span><span id='topic+rinvgamma'></span><span id='topic+minvgamma'></span><span id='topic+levinvgamma'></span><span id='topic+mgfinvgamma'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments, and limited moments for the Inverse Gamma distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)
pinvgamma(q, shape, rate = 1, scale = 1/rate,
          lower.tail = TRUE, log.p = FALSE)
qinvgamma(p, shape, rate = 1, scale = 1/rate,
          lower.tail = TRUE, log.p = FALSE)
rinvgamma(n, shape, rate = 1, scale = 1/rate)
minvgamma(order, shape, rate = 1, scale = 1/rate)
levinvgamma(limit, shape, rate = 1, scale = 1/rate,
            order = 1)
mgfinvgamma(t, shape, rate =1, scale = 1/rate, log =FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseGamma_+3A_x">x</code>, <code id="InverseGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_shape">shape</code>, <code id="InverseGamma_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_log">log</code>, <code id="InverseGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="InverseGamma_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse gamma distribution with parameters <code>shape</code> <code class="reqn">=
    \alpha</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{u^\alpha e^{-u}}{x \Gamma(\alpha)}, %
    \quad u = \theta/x</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The special case <code>shape == 1</code> is an
<a href="#topic+dinvexp">Inverse Exponential</a> distribution.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k &lt; \alpha</code>, and the <code class="reqn">k</code>th
limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, all <code class="reqn">k</code>.
</p>
<p>The moment generating function is given by <code class="reqn">E[e^{tX}]</code>.
</p>


<h3>Value</h3>

<p><code>dinvgamma</code> gives the density,
<code>pinvgamma</code> gives the distribution function,
<code>qinvgamma</code> gives the quantile function,
<code>rinvgamma</code> generates random deviates,
<code>minvgamma</code> gives the <code class="reqn">k</code>th raw moment,
<code>levinvgamma</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable, and
<code>mgfinvgamma</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvgamma</code> computes the limited expected value using
<code>gammainc</code> from package <span class="pkg">expint</span>.
</p>
<p>Also known as the Vinci distribution. See also Kleiber and
Kotz (2003) for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvgamma(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pinvgamma(qinvgamma(p, 2, 3), 2, 3)
minvgamma(-1, 2, 2) ^ 2
levinvgamma(10, 2, 2, order = 1)
mgfinvgamma(-1, 3, 2)
</code></pre>

<hr>
<h2 id='InverseGaussian'>The Inverse Gaussian Distribution</h2><span id='topic+InverseGaussian'></span><span id='topic+dinvgauss'></span><span id='topic+pinvgauss'></span><span id='topic+qinvgauss'></span><span id='topic+rinvgauss'></span><span id='topic+minvgauss'></span><span id='topic+levinvgauss'></span><span id='topic+mgfinvgauss'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random
generation, raw moments, limited moments and moment generating
function for the Inverse Gaussian distribution with parameters
<code>mean</code> and <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgauss(x, mean, shape = 1, dispersion = 1/shape,
          log = FALSE)
pinvgauss(q, mean, shape = 1, dispersion = 1/shape,
          lower.tail = TRUE, log.p = FALSE)
qinvgauss(p, mean, shape = 1, dispersion = 1/shape,
          lower.tail = TRUE, log.p = FALSE,
          tol = 1e-14, maxit = 100, echo = FALSE, trace = echo)
rinvgauss(n, mean, shape = 1, dispersion = 1/shape)
minvgauss(order, mean, shape = 1, dispersion = 1/shape)
levinvgauss(limit, mean, shape = 1, dispersion = 1/shape, order = 1)
mgfinvgauss(t, mean, shape = 1, dispersion = 1/shape, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseGaussian_+3A_x">x</code>, <code id="InverseGaussian_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_mean">mean</code>, <code id="InverseGaussian_+3A_shape">shape</code></td>
<td>
<p>parameters. Must be strictly positive. Infinite
values are supported.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_dispersion">dispersion</code></td>
<td>
<p>an alternative way to specify the shape.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_log">log</code>, <code id="InverseGaussian_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_order">order</code></td>
<td>
<p>order of the moment. Only <code>order = 1</code> is
supported by <code>levinvgauss</code>.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_tol">tol</code></td>
<td>
<p>small positive value. Tolerance to assess convergence in
the Newton computation of quantiles.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_maxit">maxit</code></td>
<td>
<p>positive integer; maximum number of recursions in the
Newton computation of quantiles.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_echo">echo</code>, <code id="InverseGaussian_+3A_trace">trace</code></td>
<td>
<p>logical; echo the recursions to screen in the
Newton computation of quantiles.</p>
</td></tr>
<tr><td><code id="InverseGaussian_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse Gaussian distribution with parameters <code>mean</code> <code class="reqn">=
    \mu</code> and <code>dispersion</code> <code class="reqn">= \phi</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \left( \frac{1}{2 \pi \phi x^3} \right)^{1/2}
    \exp\left( -\frac{(x - \mu)^2}{2 \mu^2 \phi x} \right),</code>
</p>

<p>for <code class="reqn">x \ge 0</code>, <code class="reqn">\mu &gt; 0</code> and <code class="reqn">\phi &gt; 0</code>.
</p>
<p>The limiting case <code class="reqn">\mu = \infty</code> is an inverse
chi-squared distribution (or inverse gamma with <code>shape</code> <code class="reqn">=
  1/2</code> and <code>rate</code> <code class="reqn">= 2</code><code>phi</code>). This distribution has no
finite strictly positive, integer moments.
</p>
<p>The limiting case <code class="reqn">\phi = 0</code> is an infinite spike in <code class="reqn">x = 0</code>.
</p>
<p>If the random variable <code class="reqn">X</code> is IG<code class="reqn">(\mu, \phi)</code>, then
<code class="reqn">X/\mu</code> is IG<code class="reqn">(1, \phi \mu)</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k = 1, 2, \dots</code>, the limited expected
value at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X, d)]</code> and
the moment generating function is <code class="reqn">E[e^{tX}]</code>.
</p>
<p>The moment generating function of the inverse guassian is defined for
<code>t &lt;= 1/(2 * mean^2 * phi)</code>.
</p>


<h3>Value</h3>

<p><code>dinvgauss</code> gives the density,
<code>pinvgauss</code> gives the distribution function,
<code>qinvgauss</code> gives the quantile function,
<code>rinvgauss</code> generates random deviates,
<code>minvgauss</code> gives the <code class="reqn">k</code>th raw moment,
<code>levinvgauss</code> gives the limited expected value, and
<code>mgfinvgauss</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>Functions <code>dinvgauss</code>, <code>pinvgauss</code> and <code>qinvgauss</code> are
C implementations of functions of the same name in package
<span class="pkg">statmod</span>; see Giner and Smyth (2016).
</p>
<p>Devroye (1986, chapter 4) provides a nice presentation of the
algorithm to generate random variates from an inverse Gaussian
distribution.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Giner, G. and Smyth, G. K. (2016), &ldquo;<span class="pkg">statmod</span>: Probability
Calculations for the Inverse Gaussian Distribution&rdquo;, <em>R
Journal</em>, vol. 8, no 1, p. 339-351.
<a href="https://journal.r-project.org/archive/2016-1/giner-smyth.pdf">https://journal.r-project.org/archive/2016-1/giner-smyth.pdf</a>
</p>
<p>Chhikara, R. S. and Folk, T. L. (1989), <em>The Inverse Gaussian
Distribution: Theory, Methodology and Applications</em>, Decker.
</p>
<p>Devroye, L. (1986), <em>Non-Uniform Random Variate Generation</em>,
Springer-Verlag. <a href="http://luc.devroye.org/rnbookindex.html">http://luc.devroye.org/rnbookindex.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dinvgamma">dinvgamma</a></code> for the inverse gamma distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dinvgauss(c(-1, 0, 1, 2, Inf), mean = 1.5, dis = 0.7)
dinvgauss(c(-1, 0, 1, 2, Inf), mean = Inf, dis = 0.7)
dinvgauss(c(-1, 0, 1, 2, Inf), mean = 1.5, dis = Inf) # spike at zero

## Typical graphical representations of the inverse Gaussian
## distribution. First fixed mean and varying shape; second
## varying mean and fixed shape.
col = c("red", "blue", "green", "cyan", "yellow", "black")
par = c(0.125, 0.5, 1, 2, 8, 32)
curve(dinvgauss(x, 1, par[1]), from = 0, to = 2, col = col[1])
for (i in 2:6)
    curve(dinvgauss(x, 1, par[i]), add = TRUE, col = col[i])

curve(dinvgauss(x, par[1], 1), from = 0, to = 2, col = col[1])
for (i in 2:6)
    curve(dinvgauss(x, par[i], 1), add = TRUE, col = col[i])

pinvgauss(qinvgauss((1:10)/10, 1.5, shape = 2), 1.5, 2)

minvgauss(1:4, 1.5, 2)

levinvgauss(c(0, 0.5, 1, 1.2, 10, Inf), 1.5, 2)
</code></pre>

<hr>
<h2 id='InverseParalogistic'>The Inverse Paralogistic Distribution</h2><span id='topic+InverseParalogistic'></span><span id='topic+dinvparalogis'></span><span id='topic+pinvparalogis'></span><span id='topic+qinvparalogis'></span><span id='topic+rinvparalogis'></span><span id='topic+minvparalogis'></span><span id='topic+levinvparalogis'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Inverse Paralogistic
distribution with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvparalogis(x, shape, rate = 1, scale = 1/rate, log = FALSE)
pinvparalogis(q, shape, rate = 1, scale = 1/rate,
              lower.tail = TRUE, log.p = FALSE)
qinvparalogis(p, shape, rate = 1, scale = 1/rate,
              lower.tail = TRUE, log.p = FALSE)
rinvparalogis(n, shape, rate = 1, scale = 1/rate)
minvparalogis(order, shape, rate = 1, scale = 1/rate)
levinvparalogis(limit, shape, rate = 1, scale = 1/rate,
                order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseParalogistic_+3A_x">x</code>, <code id="InverseParalogistic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_shape">shape</code>, <code id="InverseParalogistic_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_log">log</code>, <code id="InverseParalogistic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseParalogistic_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse paralogistic distribution with parameters <code>shape</code>
<code class="reqn">= \tau</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau^2 (x/\theta)^{\tau^2}}{%
      x [1 + (x/\theta)^\tau]^{\tau + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\tau^2 &lt; k &lt; \tau</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\tau^2</code>
and <code class="reqn">1 - k/\tau</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dinvparalogis</code> gives the density,
<code>pinvparalogis</code> gives the distribution function,
<code>qinvparalogis</code> gives the quantile function,
<code>rinvparalogis</code> generates random deviates,
<code>minvparalogis</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvparalogis</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvparalogis</code> computes computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>See Kleiber and Kotz (2003) for alternative names and
parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvparalogis(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pinvparalogis(qinvparalogis(p, 2, 3), 2, 3)

## first negative moment
minvparalogis(-1, 2, 2)

## case with 1 - order/shape &gt; 0
levinvparalogis(10, 2, 2, order = 1)

## case with 1 - order/shape &lt; 0
levinvparalogis(10, 2/3, 2, order = 1)
</code></pre>

<hr>
<h2 id='InversePareto'>The Inverse Pareto Distribution</h2><span id='topic+InversePareto'></span><span id='topic+dinvpareto'></span><span id='topic+pinvpareto'></span><span id='topic+qinvpareto'></span><span id='topic+rinvpareto'></span><span id='topic+minvpareto'></span><span id='topic+levinvpareto'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation
raw moments and limited moments for the Inverse Pareto distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvpareto(x, shape, scale, log = FALSE)
pinvpareto(q, shape, scale, lower.tail = TRUE, log.p = FALSE)
qinvpareto(p, shape, scale, lower.tail = TRUE, log.p = FALSE)
rinvpareto(n, shape, scale)
minvpareto(order, shape, scale)
levinvpareto(limit, shape, scale, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InversePareto_+3A_x">x</code>, <code id="InversePareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_shape">shape</code>, <code id="InversePareto_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_log">log</code>, <code id="InversePareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InversePareto_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse Pareto distribution with parameters <code>shape</code> <code class="reqn">=
    \tau</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau \theta x^{\tau - 1}}{%
      (x + \theta)^{\tau + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\tau &lt; k &lt; 1</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>,
<code class="reqn">k &gt; -\tau</code>.
</p>


<h3>Value</h3>

<p><code>dinvpareto</code> gives the density,
<code>pinvpareto</code> gives the distribution function,
<code>qinvpareto</code> gives the quantile function,
<code>rinvpareto</code> generates random deviates,
<code>minvpareto</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvpareto</code> calculates the <code class="reqn">k</code>th limited moment.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>Evaluation of <code>levinvpareto</code> is done using numerical integration.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvpareto(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pinvpareto(qinvpareto(p, 2, 3), 2, 3)
minvpareto(0.5, 1, 2)
</code></pre>

<hr>
<h2 id='InverseTransformedGamma'>The Inverse Transformed Gamma Distribution</h2><span id='topic+InverseTransformedGamma'></span><span id='topic+dinvtrgamma'></span><span id='topic+pinvtrgamma'></span><span id='topic+qinvtrgamma'></span><span id='topic+rinvtrgamma'></span><span id='topic+minvtrgamma'></span><span id='topic+levinvtrgamma'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments, and limited moments for the Inverse Transformed Gamma
distribution with parameters <code>shape1</code>, <code>shape2</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvtrgamma(x, shape1, shape2, rate = 1, scale = 1/rate,
            log = FALSE)
pinvtrgamma(q, shape1, shape2, rate = 1, scale = 1/rate,
            lower.tail = TRUE, log.p = FALSE)
qinvtrgamma(p, shape1, shape2, rate = 1, scale = 1/rate,
            lower.tail = TRUE, log.p = FALSE)
rinvtrgamma(n, shape1, shape2, rate = 1, scale = 1/rate)
minvtrgamma(order, shape1, shape2, rate = 1, scale = 1/rate)
levinvtrgamma(limit, shape1, shape2, rate = 1, scale = 1/rate,
              order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseTransformedGamma_+3A_x">x</code>, <code id="InverseTransformedGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_shape1">shape1</code>, <code id="InverseTransformedGamma_+3A_shape2">shape2</code>, <code id="InverseTransformedGamma_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_log">log</code>, <code id="InverseTransformedGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseTransformedGamma_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse transformed gamma distribution with parameters
<code>shape1</code> <code class="reqn">= \alpha</code>, <code>shape2</code> <code class="reqn">= \tau</code> and
<code>scale</code> <code class="reqn">= \theta</code>, has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau u^\alpha e^{-u}}{x \Gamma(\alpha)}, %
      \quad u = (\theta/x)^\tau</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\tau &gt; 0</code>
and <code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The inverse transformed gamma is the distribution of the random
variable
<code class="reqn">\theta X^{-1/\tau},</code>
where <code class="reqn">X</code> has a gamma distribution with shape parameter
<code class="reqn">\alpha</code> and scale parameter <code class="reqn">1</code> or, equivalently, of the
random variable
<code class="reqn">Y^{-1/\tau}</code>
with <code class="reqn">Y</code> a gamma distribution with shape parameter <code class="reqn">\alpha</code>
and scale parameter <code class="reqn">\theta^{-\tau}</code>.
</p>
<p>The inverse transformed gamma distribution defines a family of
distributions with the following special cases:
</p>

<ul>
<li><p> An <a href="#topic+dinvgamma">Inverse Gamma</a> distribution when
<code>shape2 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvweibull">Inverse Weibull</a> distribution when
<code>shape1 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvexp">Inverse Exponential</a> distribution when
<code>shape1 == shape2 == 1</code>;
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k &lt; \alpha\tau</code>, and
the <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code> for all <code class="reqn">k</code>.
</p>


<h3>Value</h3>

<p><code>dinvtrgamma</code> gives the density,
<code>pinvtrgamma</code> gives the distribution function,
<code>qinvtrgamma</code> gives the quantile function,
<code>rinvtrgamma</code> generates random deviates,
<code>minvtrgamma</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvtrgamma</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvtrgamma</code> computes the limited expected value using
<code>gammainc</code> from package <span class="pkg">expint</span>.
</p>
<p>Distribution also known as the Inverse Generalized Gamma. See also Kleiber and
Kotz (2003) for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvtrgamma(2, 3, 4, 5, log = TRUE))
p &lt;- (1:10)/10
pinvtrgamma(qinvtrgamma(p, 2, 3, 4), 2, 3, 4)
minvtrgamma(2, 3, 4, 5)
levinvtrgamma(200, 3, 4, 5, order = 2)
</code></pre>

<hr>
<h2 id='InverseWeibull'>The Inverse Weibull Distribution</h2><span id='topic+InverseWeibull'></span><span id='topic+dinvweibull'></span><span id='topic+pinvweibull'></span><span id='topic+qinvweibull'></span><span id='topic+rinvweibull'></span><span id='topic+minvweibull'></span><span id='topic+levinvweibull'></span><span id='topic+dlgompertz'></span><span id='topic+plgompertz'></span><span id='topic+qlgompertz'></span><span id='topic+rlgompertz'></span><span id='topic+mlgompertz'></span><span id='topic+levlgompertz'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Inverse Weibull distribution
with parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvweibull(x, shape, rate = 1, scale = 1/rate, log = FALSE)
pinvweibull(q, shape, rate = 1, scale = 1/rate,
            lower.tail = TRUE, log.p = FALSE)
qinvweibull(p, shape, rate = 1, scale = 1/rate,
            lower.tail = TRUE, log.p = FALSE)
rinvweibull(n, shape, rate = 1, scale = 1/rate)
minvweibull(order, shape, rate = 1, scale = 1/rate)
levinvweibull(limit, shape, rate = 1, scale = 1/rate,
              order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InverseWeibull_+3A_x">x</code>, <code id="InverseWeibull_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_shape">shape</code>, <code id="InverseWeibull_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_log">log</code>, <code id="InverseWeibull_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="InverseWeibull_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse Weibull distribution with parameters <code>shape</code> <code class="reqn">=
    \tau</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau (\theta/x)^\tau e^{-(\theta/x)^\tau}}{x}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The special case <code>shape == 1</code> is an
<a href="#topic+dinvexp">Inverse Exponential</a> distribution.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k &lt; \tau</code>, and the <code class="reqn">k</code>th
limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, all <code class="reqn">k</code>.
</p>


<h3>Value</h3>

<p><code>dinvweibull</code> gives the density,
<code>pinvweibull</code> gives the distribution function,
<code>qinvweibull</code> gives the quantile function,
<code>rinvweibull</code> generates random deviates,
<code>minvweibull</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levinvweibull</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levinvweibull</code> computes the limited expected value using
<code>gammainc</code> from package <span class="pkg">expint</span>.
</p>
<p>Distribution also knonw as the log-Gompertz. See also Kleiber and
Kotz (2003) for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dinvweibull(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pinvweibull(qinvweibull(p, 2, 3), 2, 3)
mlgompertz(-1, 3, 3)
levinvweibull(10, 2, 3, order = 1)
</code></pre>

<hr>
<h2 id='Logarithmic'>The Logarithmic Distribution</h2><span id='topic+Logarithmic'></span><span id='topic+dlogarithmic'></span><span id='topic+plogarithmic'></span><span id='topic+qlogarithmic'></span><span id='topic+rlogarithmic'></span><span id='topic+log-series'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Logarithmic (or log-series) distribution with parameter
<code>prob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogarithmic(x, prob, log = FALSE)
plogarithmic(q, prob, lower.tail = TRUE, log.p = FALSE)
qlogarithmic(p, prob, lower.tail = TRUE, log.p = FALSE)
rlogarithmic(n, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logarithmic_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt;= prob &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_log">log</code>, <code id="Logarithmic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Logarithmic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logarithmic (or log-series) distribution with parameter
<code>prob</code> <code class="reqn">= \theta</code> has probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{a \theta^x}{x},</code>
</p>

<p>with <code class="reqn">a = -1/\log(1 - \theta)</code> and for <code class="reqn">x =
    1, 2, \ldots</code>, <code class="reqn">0 \le \theta &lt; 1</code>.
</p>
<p>The logarithmic distribution is the limiting case of the
zero-truncated negative binomial distribution with <code>size</code>
parameter equal to <code class="reqn">0</code>. Note that in this context, parameter
<code>prob</code> generally corresponds to the probability of <em>failure</em>
of the zero-truncated negative binomial.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dlogarithmic</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dlogarithmic</code> gives the probability mass function,
<code>plogarithmic</code> gives the distribution function,
<code>qlogarithmic</code> gives the quantile function, and
<code>rlogarithmic</code> generates random deviates.
</p>
<p>Invalid <code>prob</code> will result in return value <code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rlogarithmic</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p><code>qlogarithmic</code> is based on <code>qbinom</code> et al.; it uses the
Cornish&ndash;Fisher Expansion to include a skewness correction to a normal
approximation, followed by a search.
</p>
<p><code>rlogarithmic</code> is an implementation of the LS and LK algorithms
of Kemp (1981) with automatic selection. As suggested by Devroye
(1986), the LS algorithm is used when <code>prob &lt; 0.95</code>, and the LK
algorithm otherwise.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Johnson, N. L., Kemp, A. W. and Kotz, S. (2005), <em>Univariate
Discrete Distributions, Third Edition</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Kemp, A. W. (1981), &ldquo;Efficient Generation of Logarithmically
Distributed Pseudo-Random Variables&rdquo;, <em>Journal of the Royal
Statistical Society, Series C</em>, vol. 30, p. 249-253.
</p>
<p>Devroye, L. (1986), <em>Non-Uniform Random Variate Generation</em>,
Springer-Verlag. <a href="http://luc.devroye.org/rnbookindex.html">http://luc.devroye.org/rnbookindex.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dztnbinom">dztnbinom</a></code> for the zero-truncated negative binomial
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table 1 of Kemp (1981) [also found in Johnson et al. (2005), chapter 7]
p &lt;- c(0.1, 0.3, 0.5, 0.7, 0.8, 0.85, 0.9, 0.95, 0.99, 0.995, 0.999, 0.9999)
round(rbind(dlogarithmic(1, p),
            dlogarithmic(2, p),
            plogarithmic(9, p, lower.tail = FALSE),
            -p/((1 - p) * log(1 - p))), 2)

qlogarithmic(plogarithmic(1:10, 0.9), 0.9)

x &lt;- rlogarithmic(1000, 0.8)
y &lt;- sort(unique(x))
plot(y, table(x)/length(x), type = "h", lwd = 2,
     pch = 19, col = "black", xlab = "x", ylab = "p(x)",
     main = "Empirical vs theoretical probabilities")
points(y, dlogarithmic(y, prob = 0.8),
       pch = 19, col = "red")
legend("topright", c("empirical", "theoretical"),
       lty = c(1, NA), pch = c(NA, 19), col = c("black", "red"))
</code></pre>

<hr>
<h2 id='Loggamma'>The Loggamma Distribution</h2><span id='topic+Loggamma'></span><span id='topic+dlgamma'></span><span id='topic+plgamma'></span><span id='topic+qlgamma'></span><span id='topic+rlgamma'></span><span id='topic+mlgamma'></span><span id='topic+levlgamma'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Loggamma distribution with
parameters <code>shapelog</code> and <code>ratelog</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlgamma(x, shapelog, ratelog, log = FALSE)
plgamma(q, shapelog, ratelog, lower.tail = TRUE, log.p = FALSE)
qlgamma(p, shapelog, ratelog, lower.tail = TRUE, log.p = FALSE)
rlgamma(n, shapelog, ratelog)
mlgamma(order, shapelog, ratelog)
levlgamma(limit, shapelog, ratelog, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Loggamma_+3A_x">x</code>, <code id="Loggamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_shapelog">shapelog</code>, <code id="Loggamma_+3A_ratelog">ratelog</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_log">log</code>, <code id="Loggamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Loggamma_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loggamma distribution with parameters <code>shapelog</code> <code class="reqn">=
    \alpha</code> and <code>ratelog</code> <code class="reqn">= \lambda</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\lambda^\alpha}{\Gamma(\alpha)}%
    \frac{(\log x)^{\alpha - 1}}{x^{\lambda + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 1</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\lambda &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The loggamma is the distribution of the random variable
<code class="reqn">e^X</code>,  where <code class="reqn">X</code> has a gamma distribution with
shape parameter <code class="reqn">alpha</code> and scale parameter
<code class="reqn">1/\lambda</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, <code class="reqn">k &lt; \lambda</code>.
</p>


<h3>Value</h3>

<p><code>dlgamma</code> gives the density,
<code>plgamma</code> gives the distribution function,
<code>qlgamma</code> gives the quantile function,
<code>rlgamma</code> generates random deviates,
<code>mlgamma</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levlgamma</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Hogg, R. V. and Klugman, S. A. (1984), <em>Loss Distributions</em>,
Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dlgamma(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
plgamma(qlgamma(p, 2, 3), 2, 3)
mlgamma(2, 3, 4) - mlgamma(1, 3, 4)^2
levlgamma(10, 3, 4, order = 2)
</code></pre>

<hr>
<h2 id='Loglogistic'>The Loglogistic Distribution</h2><span id='topic+Loglogistic'></span><span id='topic+dllogis'></span><span id='topic+pllogis'></span><span id='topic+qllogis'></span><span id='topic+rllogis'></span><span id='topic+mllogis'></span><span id='topic+levllogis'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Loglogistic distribution with
parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dllogis(x, shape, rate = 1, scale = 1/rate, log = FALSE)
pllogis(q, shape, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
qllogis(p, shape, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
rllogis(n, shape, rate = 1, scale = 1/rate)
mllogis(order, shape, rate = 1, scale = 1/rate)
levllogis(limit, shape, rate = 1, scale = 1/rate,
          order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Loglogistic_+3A_x">x</code>, <code id="Loglogistic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_shape">shape</code>, <code id="Loglogistic_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_log">log</code>, <code id="Loglogistic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Loglogistic_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loglogistic distribution with parameters <code>shape</code> <code class="reqn">=
    \gamma</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\gamma (x/\theta)^\gamma}{%
      x [1 + (x/\theta)^\gamma]^2}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\gamma &lt; k &lt; \gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\gamma</code>
and <code class="reqn">1 - k/\gamma</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dllogis</code> gives the density,
<code>pllogis</code> gives the distribution function,
<code>qllogis</code> gives the quantile function,
<code>rllogis</code> generates random deviates,
<code>mllogis</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levllogis</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levllogis</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>Also known as the Fisk distribution. See also Kleiber and Kotz (2003)
for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpareto3">dpareto3</a></code> for an equivalent distribution with a location
parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dllogis(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pllogis(qllogis(p, 2, 3), 2, 3)

## mean
mllogis(1, 2, 3)

## case with 1 - order/shape &gt; 0
levllogis(10, 2, 3, order = 1)

## case with 1 - order/shape &lt; 0
levllogis(10, 2/3, 3, order = 1)
</code></pre>

<hr>
<h2 id='LognormalMoments'>Raw and Limited Moments of the Lognormal Distribution</h2><span id='topic+LognormalMoments'></span><span id='topic+mlnorm'></span><span id='topic+levlnorm'></span>

<h3>Description</h3>

<p>Raw moments and limited moments for the Lognormal distribution whose
logarithm has mean equal to <code>meanlog</code> and standard deviation
equal to <code>sdlog</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlnorm(order, meanlog = 0, sdlog = 1)
levlnorm(limit, meanlog = 0, sdlog = 1, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LognormalMoments_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="LognormalMoments_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="LognormalMoments_+3A_meanlog">meanlog</code>, <code id="LognormalMoments_+3A_sdlog">sdlog</code></td>
<td>
<p>mean and standard deviation of the distribution
on the log scale with default values of <code>0</code> and <code>1</code>
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mlnorm</code> gives the <code class="reqn">k</code>th raw moment and
<code>levlnorm</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Lognormal">Lognormal</a></code> for details on the lognormal distribution and
functions <code>[dpqr]lnorm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mlnorm(2, 3, 4) - mlnorm(1, 3, 4)^2
levlnorm(10, 3, 4, order = 2)
</code></pre>

<hr>
<h2 id='mde'>Minimum Distance Estimation</h2><span id='topic+Mde'></span><span id='topic+mde'></span>

<h3>Description</h3>

<p>Minimum distance fitting of univariate distributions, allowing
parameters to be held fixed if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mde(x, fun, start, measure = c("CvM", "chi-square", "LAS"),
    weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mde_+3A_x">x</code></td>
<td>
<p>a vector or an object of class <code>"grouped data"</code> (in
which case only the first column of frequencies is used).</p>
</td></tr>
<tr><td><code id="mde_+3A_fun">fun</code></td>
<td>
<p>function returning a cumulative distribution (for
<code>measure = "CvM"</code> and <code>measure = "chi-square"</code>) or a
limited expected value (for <code>measure = "LAS"</code>) evaluated at
its first argument.</p>
</td></tr>
<tr><td><code id="mde_+3A_start">start</code></td>
<td>
<p>a named list giving the parameters to be optimized with
initial values</p>
</td></tr>
<tr><td><code id="mde_+3A_measure">measure</code></td>
<td>
<p>either <code>"CvM"</code> for the Cramer-von Mises method,
<code>"chi-square"</code> for the modified chi-square method, or <code>"LAS"</code>
for the layer average severity method.</p>
</td></tr>
<tr><td><code id="mde_+3A_weights">weights</code></td>
<td>
<p>weights; see Details.</p>
</td></tr>
<tr><td><code id="mde_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for <code>fun</code> or for
<code>optim</code>. In particular, it can be used to specify bounds via
<code>lower</code> or <code>upper</code> or both.  If arguments of <code>fun</code>
are included they will be held fixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cramer-von Mises method (<code>"CvM"</code>) minimizes the squared
difference between the theoretical cdf and the empirical cdf at the
data points (for individual data) or the ogive at the knots (for
grouped data).
</p>
<p>The modified chi-square method (<code>"chi-square"</code>) minimizes the
modified chi-square statistic for grouped data, that is the squared
difference between the expected and observed frequency within each
group.
</p>
<p>The layer average severity method (<code>"LAS"</code>) minimizes the
squared difference between the theoretical and empirical limited
expected value within each group for grouped data.
</p>
<p>All sum of squares can be weighted. If arguments <code>weights</code> is
missing, weights default to 1 for <code>measure = "CvM"</code> and
<code>measure = "LAS"</code>; for <code>measure = "chi-square"</code>, weights
default to <code class="reqn">1/n_j</code>, where <code class="reqn">n_j</code> is the frequency
in group <code class="reqn">j = 1, \dots, r</code>.
</p>
<p>Optimization is performed using <code><a href="stats.html#topic+optim">optim</a></code>. For
one-dimensional problems the Nelder-Mead method is used and for
multi-dimensional problems the BFGS method, unless arguments named
<code>lower</code> or <code>upper</code> are supplied when <code>L-BFGS-B</code> is used
or <code>method</code> is supplied explicitly.
</p>


<h3>Value</h3>

<p>An object of class <code>"mde"</code>, a list with two components:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the parameter estimates, and</p>
</td></tr>  
<tr><td><code>distance</code></td>
<td>
<p>the distance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Individual data example
data(dental)
mde(dental, pexp, start = list(rate = 1/200), measure = "CvM")

## Example 2.21 of Klugman et al. (1998)
data(gdental)
mde(gdental, pexp, start = list(rate = 1/200), measure = "CvM")
mde(gdental, pexp, start = list(rate = 1/200), measure = "chi-square")
mde(gdental, levexp, start = list(rate = 1/200), measure = "LAS")

## Two-parameter distribution example
try(mde(gdental, ppareto, start = list(shape = 3, scale = 600),
        measure = "CvM")) # no convergence

## Working in log scale often solves the problem
pparetolog &lt;- function(x, shape, scale)
    ppareto(x, exp(shape), exp(scale))

( p &lt;- mde(gdental, pparetolog, start = list(shape = log(3),
           scale = log(600)), measure = "CvM") )
exp(p$estimate)
</code></pre>

<hr>
<h2 id='mean.grouped.data'>Arithmetic Mean</h2><span id='topic+mean.grouped.data'></span>

<h3>Description</h3>

<p>Mean of grouped data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped.data'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.grouped.data_+3A_x">x</code></td>
<td>
<p>an object of class <code>"grouped.data"</code>.</p>
</td></tr>
<tr><td><code id="mean.grouped.data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of grouped data with group boundaries <code class="reqn">c_0, c_1, \dots,
    c_r</code> and group frequencies <code class="reqn">n_1, \dots,
    n_r</code> is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n} \sum_{j = 1}^r a_j n_j,</code>
</p>

<p>where
<code class="reqn">a_j = (c_{j - 1} + c_j)/2</code>
is the midpoint of the <code class="reqn">j</code>th interval, and
<code class="reqn">n = \sum_{j = 1}^r n_j</code>.
</p>


<h3>Value</h3>

<p>A named vector of means.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped data objects;
<code><a href="#topic+emm">emm</a></code> to compute higher moments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)
mean(gdental)
</code></pre>

<hr>
<h2 id='NormalSupp'>Moments and Moment generating function of the Normal Distribution</h2><span id='topic+NormalSupp'></span><span id='topic+mnorm'></span><span id='topic+mgfnorm'></span>

<h3>Description</h3>

<p>Raw moments and moment generating function for the normal distribution with
mean equal to <code>mean</code> and standard deviation equal to <code>sd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnorm(order, mean = 0, sd = 1)
mgfnorm(t, mean = 0, sd = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalSupp_+3A_order">order</code></td>
<td>
<p>vector of integers; order of the moment.</p>
</td></tr>
<tr><td><code id="NormalSupp_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="NormalSupp_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="NormalSupp_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="NormalSupp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the cumulant generating function
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the moment generating function is
<code class="reqn">E[e^{tX}]</code>.
</p>
<p>Only integer moments are supported.
</p>


<h3>Value</h3>

<p><code>mnorm</code> gives the <code class="reqn">k</code>th raw moment and
<code>mgfnorm</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Christophe Dutang
</p>


<h3>References</h3>

<p>Johnson, N. L. and Kotz, S. (1970), <em>Continuous Univariate
Distributions, Volume 1</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgfnorm(0:4,1,2)
mnorm(3)
</code></pre>

<hr>
<h2 id='ogive'>Ogive for Grouped Data</h2><span id='topic+ogive'></span><span id='topic+ogive.default'></span><span id='topic+ogive.grouped.data'></span><span id='topic+print.ogive'></span><span id='topic+summary.ogive'></span><span id='topic+knots.ogive'></span><span id='topic+plot.ogive'></span>

<h3>Description</h3>

<p>Compute a smoothed empirical distribution function for grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ogive(x, ...)

## Default S3 method:
ogive(x, y = NULL, breaks = "Sturges", nclass = NULL, ...)

## S3 method for class 'grouped.data'
ogive(x, ...)

## S3 method for class 'ogive'
print(x, digits = getOption("digits") - 2, ...)

## S3 method for class 'ogive'
summary(object, ...)

## S3 method for class 'ogive'
knots(Fn, ...)

## S3 method for class 'ogive'
plot(x, main = NULL, xlab = "x", ylab = "F(x)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ogive_+3A_x">x</code></td>
<td>
<p>for the generic and all but the default method, an object of
class <code>"grouped.data"</code>; for the default method, a vector of
individual data if <code>y</code> is <code>NULL</code>, a vector of group
boundaries otherwise.</p>
</td></tr>
<tr><td><code id="ogive_+3A_y">y</code></td>
<td>
<p>a vector of group frequencies.</p>
</td></tr>
<tr><td><code id="ogive_+3A_breaks">breaks</code>, <code id="ogive_+3A_nclass">nclass</code></td>
<td>
<p>arguments passed to <code><a href="#topic+grouped.data">grouped.data</a></code>;
used only for individual data (when <code>y</code> is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="ogive_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use, see
<code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="ogive_+3A_fn">Fn</code>, <code id="ogive_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"ogive"</code>.</p>
</td></tr>
<tr><td><code id="ogive_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="ogive_+3A_xlab">xlab</code>, <code id="ogive_+3A_ylab">ylab</code></td>
<td>
<p>labels of x and y axis.</p>
</td></tr>
<tr><td><code id="ogive_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ogive is a linear interpolation of the empirical cumulative
distribution function.
</p>
<p>The equation of the ogive is
</p>
<p style="text-align: center;"><code class="reqn">G_n(x) = \frac{(c_j - x) F_n(c_{j - 1}) +
      (x - c_{j - 1}) F_n(c_j)}{c_j - c_{j - 1}}</code>
</p>

<p>for <code class="reqn">c_{j-1} &lt; x \leq c_j</code> and where
<code class="reqn">c_0, \dots, c_r</code> are the <code class="reqn">r + 1</code> group
boundaries and <code class="reqn">F_n</code> is the empirical distribution function of
the sample.
</p>


<h3>Value</h3>

<p>For <code>ogive</code>, a function of class <code>"ogive"</code>, inheriting from the
<code>"<a href="base.html#topic+function">function</a>"</code> class.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped data objects;
<code><a href="#topic+quantile.grouped.data">quantile.grouped.data</a></code> for the inverse function;
<code><a href="stats.html#topic+approxfun">approxfun</a></code>, which is used to compute the ogive;
<code><a href="stats.html#topic+stepfun">stepfun</a></code> for related documentation (even though the ogive
is not a step function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Most common usage: create ogive from grouped data object.
Fn &lt;- ogive(gdental)
Fn
summary(Fn)
knots(Fn)                      # the group boundaries

Fn(knots(Fn))                  # true values of the empirical cdf
Fn(c(80, 200, 2000))           # linear interpolations

plot(Fn)                       # graphical representation

## Alternative 1: create ogive directly from individual data
## without first creating a grouped data object.
ogive(dental)                  # automatic class boundaries
ogive(dental, breaks = c(0, 50, 200, 500, 1500, 2000))

## Alternative 2: create ogive from set of group boundaries and
## group frequencies.
cj &lt;- c(0, 25, 50, 100, 250, 500, 1000)
nj &lt;- c(30, 31, 57, 42, 45, 10)
ogive(cj, nj)
</code></pre>

<hr>
<h2 id='Paralogistic'>The Paralogistic Distribution</h2><span id='topic+Paralogistic'></span><span id='topic+dparalogis'></span><span id='topic+pparalogis'></span><span id='topic+qparalogis'></span><span id='topic+rparalogis'></span><span id='topic+mparalogis'></span><span id='topic+levparalogis'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Paralogistic distribution with
parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dparalogis(x, shape, rate = 1, scale = 1/rate, log = FALSE)
pparalogis(q, shape, rate = 1, scale = 1/rate,
           lower.tail = TRUE, log.p = FALSE)
qparalogis(p, shape, rate = 1, scale = 1/rate,
           lower.tail = TRUE, log.p = FALSE)
rparalogis(n, shape, rate = 1, scale = 1/rate)
mparalogis(order, shape, rate = 1, scale = 1/rate)
levparalogis(limit, shape, rate = 1, scale = 1/rate,
             order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Paralogistic_+3A_x">x</code>, <code id="Paralogistic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_shape">shape</code>, <code id="Paralogistic_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_log">log</code>, <code id="Paralogistic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Paralogistic_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The paralogistic distribution with parameters <code>shape</code> <code class="reqn">=
    \alpha</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha^2 (x/\theta)^\alpha}{%
      x [1 + (x/\theta)^\alpha)^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\alpha &lt; k &lt; \alpha^2</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\alpha</code>
and <code class="reqn">\alpha - k/\alpha</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dparalogis</code> gives the density,
<code>pparalogis</code> gives the distribution function,
<code>qparalogis</code> gives the quantile function,
<code>rparalogis</code> generates random deviates,
<code>mparalogis</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levparalogis</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levparalogis</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>See Kleiber and Kotz (2003) for alternative names and
parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dparalogis(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
pparalogis(qparalogis(p, 2, 3), 2, 3)

## variance
mparalogis(2, 2, 3) - mparalogis(1, 2, 3)^2

## case with shape - order/shape &gt; 0
levparalogis(10, 2, 3, order = 2)

## case with shape - order/shape &lt; 0
levparalogis(10, 1.25, 3, order = 2)
</code></pre>

<hr>
<h2 id='Pareto'>The Pareto Distribution</h2><span id='topic+Pareto'></span><span id='topic+dpareto'></span><span id='topic+ppareto'></span><span id='topic+qpareto'></span><span id='topic+rpareto'></span><span id='topic+mpareto'></span><span id='topic+levpareto'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Pareto distribution with
parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto(x, shape, scale, log = FALSE)
ppareto(q, shape, scale, lower.tail = TRUE, log.p = FALSE)
qpareto(p, shape, scale, lower.tail = TRUE, log.p = FALSE)
rpareto(n, shape, scale)
mpareto(order, shape, scale)
levpareto(limit, shape, scale, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto_+3A_x">x</code>, <code id="Pareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_shape">shape</code>, <code id="Pareto_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_log">log</code>, <code id="Pareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pareto distribution with parameters <code>shape</code> <code class="reqn">=
    \alpha</code> and <code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha \theta^\alpha}{(x + \theta)^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta</code>.
</p>
<p>There are many different definitions of the Pareto distribution in the
literature; see Arnold (2015) or Kleiber and Kotz (2003). In the
nomenclature of <span class="pkg">actuar</span>, The &ldquo;Pareto distribution&rdquo; does
not have a location parameter. The version with a location parameter
is the <a href="#topic+dpareto2">Pareto II</a>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-1 &lt; k &lt; \alpha</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>,
<code class="reqn">k &gt; -1</code> and <code class="reqn">\alpha - k</code> not a
negative integer.
</p>


<h3>Value</h3>

<p><code>dpareto</code> gives the density,
<code>ppareto</code> gives the distribution function,
<code>qpareto</code> gives the quantile function,
<code>rpareto</code> generates random deviates,
<code>mpareto</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levpareto</code> gives the <code class="reqn">k</code>th moment of the limited loss variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levpareto</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>The version of the Pareto defined for <code class="reqn">x &gt; \theta</code> is named
Single Parameter Pareto, or Pareto I, in <span class="pkg">actuar</span>.  
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpareto2">dpareto2</a></code> for an equivalent distribution with location
parameter.
</p>
<p><code><a href="#topic+dpareto1">dpareto1</a></code> for the Single Parameter Pareto distribution.
</p>
<p><code>"distributions"</code> package vignette for details on the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and complete formulas underlying the above functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dpareto(2, 3, 4, log = TRUE))
p &lt;- (1:10)/10
ppareto(qpareto(p, 2, 3), 2, 3)

## variance
mpareto(2, 4, 1) - mpareto(1, 4, 1)^2

## case with shape - order &gt; 0
levpareto(10, 3, scale = 1, order = 2)

## case with shape - order &lt; 0
levpareto(10, 1.5, scale = 1, order = 2)
</code></pre>

<hr>
<h2 id='Pareto2'>The Pareto II Distribution</h2><span id='topic+Pareto2'></span><span id='topic+dpareto2'></span><span id='topic+ppareto2'></span><span id='topic+qpareto2'></span><span id='topic+rpareto2'></span><span id='topic+mpareto2'></span><span id='topic+levpareto2'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Pareto II distribution with
parameters <code>min</code>, <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto2(x, min, shape, rate = 1, scale = 1/rate,
         log = FALSE)
ppareto2(q, min, shape, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qpareto2(p, min, shape, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rpareto2(n, min, shape, rate = 1, scale = 1/rate)
mpareto2(order, min, shape, rate = 1, scale = 1/rate)
levpareto2(limit, min, shape, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto2_+3A_x">x</code>, <code id="Pareto2_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_min">min</code></td>
<td>
<p>lower bound of the support of the distribution.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_shape">shape</code>, <code id="Pareto2_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_log">log</code>, <code id="Pareto2_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Pareto2_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pareto II (or &ldquo;type II&rdquo;) distribution with parameters
<code>min</code> <code class="reqn">= \mu</code>,
<code>shape</code> <code class="reqn">= \alpha</code> and
<code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha}{%
      \theta [1 + (x - \mu)/\theta]^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; \mu</code>, <code class="reqn">-\infty &lt; \mu &lt; \infty</code>,
<code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The Pareto II is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\mu + \theta \left(\frac{X}{1 - X}\right),</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">1</code> and
<code class="reqn">\alpha</code>. It derives from the <a href="#topic+dfpareto">Feller-Pareto</a>
distribution with <code class="reqn">\tau = \gamma = 1</code>.
Setting <code class="reqn">\mu = 0</code> yields the familiar
<a href="#topic+dpareto">Pareto</a> distribution.
</p>
<p>The <a href="#topic+dpareto1">Pareto I</a> (or Single parameter Pareto)
distribution is a special case of the Pareto II with <code>min ==
  scale</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> for nonnegative integer values of <code class="reqn">k &lt;
  \alpha</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code> for nonnegative integer values of <code class="reqn">k</code>
and <code class="reqn">\alpha - j</code>, <code class="reqn">j = 1, \dots, k</code>
not a negative integer.
</p>


<h3>Value</h3>

<p><code>dpareto2</code> gives the density,
<code>ppareto2</code> gives the distribution function,
<code>qpareto2</code> gives the quantile function,
<code>rpareto2</code> generates random deviates,
<code>mpareto2</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levpareto2</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levpareto2</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>For Pareto distributions, we use the classification of Arnold (2015)
with the parametrization of Klugman et al. (2012).
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Arnold, B.C. (2015), <em>Pareto Distributions</em>, Second Edition, CRC
Press.
</p>
<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpareto">dpareto</a></code> for the Pareto distribution without a location
parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dpareto2(1, min = 10, 3, 4, log = TRUE))
p &lt;- (1:10)/10
ppareto2(qpareto2(p, min = 10, 2, 3), min = 10, 2, 3)

## variance
mpareto2(2, min = 10, 4, 1) - mpareto2(1, min = 10, 4, 1)^2

## case with shape - order &gt; 0
levpareto2(10, min = 10, 3, scale = 1, order = 2)

## case with shape - order &lt; 0
levpareto2(10, min = 10, 1.5, scale = 1, order = 2)
</code></pre>

<hr>
<h2 id='Pareto3'>The Pareto III Distribution</h2><span id='topic+Pareto3'></span><span id='topic+dpareto3'></span><span id='topic+ppareto3'></span><span id='topic+qpareto3'></span><span id='topic+rpareto3'></span><span id='topic+mpareto3'></span><span id='topic+levpareto3'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Pareto III distribution with
parameters <code>min</code>, <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto3(x, min, shape, rate = 1, scale = 1/rate,
         log = FALSE)
ppareto3(q, min, shape, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qpareto3(p, min, shape, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rpareto3(n, min, shape, rate = 1, scale = 1/rate)
mpareto3(order, min, shape, rate = 1, scale = 1/rate)
levpareto3(limit, min, shape, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto3_+3A_x">x</code>, <code id="Pareto3_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_min">min</code></td>
<td>
<p>lower bound of the support of the distribution.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_shape">shape</code>, <code id="Pareto3_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_log">log</code>, <code id="Pareto3_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Pareto3_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pareto III (or &ldquo;type III&rdquo;) distribution with parameters
<code>min</code> <code class="reqn">= \mu</code>,
<code>shape</code> <code class="reqn">= \gamma</code> and
<code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\gamma ((x - \mu)/\theta)^{\gamma - 1}}{%
      \theta [1 + ((x - \mu)/\theta)^\gamma]^2}</code>
</p>

<p>for <code class="reqn">x &gt; \mu</code>, <code class="reqn">-\infty &lt; \mu &lt; \infty</code>,
<code class="reqn">\gamma &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The Pareto III is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\mu + \theta \left(\frac{X}{1 - X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a uniform distribution on <code class="reqn">(0, 1)</code>. It derives
from the <a href="#topic+dfpareto">Feller-Pareto</a> 
distribution with <code class="reqn">\alpha = \tau = 1</code>.
Setting <code class="reqn">\mu = 0</code> yields the <a href="#topic+dllogis">loglogistic</a>
distribution.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> for nonnegative integer values of <code class="reqn">k &lt;
    \gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code> for nonnegative integer values of <code class="reqn">k</code>
and <code class="reqn">1 - j/\gamma</code>, <code class="reqn">j = 1, \dots, k</code>
not a negative integer.
</p>


<h3>Value</h3>

<p><code>dpareto3</code> gives the density,
<code>ppareto3</code> gives the distribution function,
<code>qpareto3</code> gives the quantile function,
<code>rpareto3</code> generates random deviates,
<code>mpareto3</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levpareto3</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levpareto3</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>For Pareto distributions, we use the classification of Arnold (2015)
with the parametrization of Klugman et al. (2012).
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Arnold, B.C. (2015), <em>Pareto Distributions</em>, Second Edition, CRC
Press.
</p>
<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dllogis">dllogis</a></code> for the loglogistic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dpareto3(1, min = 10, 3, 4, log = TRUE))
p &lt;- (1:10)/10
ppareto3(qpareto3(p, min = 10, 2, 3), min = 10, 2, 3)

## mean
mpareto3(1, min = 10, 2, 3)

## case with 1 - order/shape &gt; 0
levpareto3(20, min = 10, 2, 3, order = 1)

## case with 1 - order/shape &lt; 0
levpareto3(20, min = 10, 2/3, 3, order = 1)
</code></pre>

<hr>
<h2 id='Pareto4'>The Pareto IV Distribution</h2><span id='topic+Pareto4'></span><span id='topic+dpareto4'></span><span id='topic+ppareto4'></span><span id='topic+qpareto4'></span><span id='topic+rpareto4'></span><span id='topic+mpareto4'></span><span id='topic+levpareto4'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Pareto IV distribution with
parameters <code>min</code>, <code>shape1</code>, <code>shape2</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto4(x, min, shape1, shape2, rate = 1, scale = 1/rate,
         log = FALSE)
ppareto4(q, min, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qpareto4(p, min, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rpareto4(n, min, shape1, shape2, rate = 1, scale = 1/rate)
mpareto4(order, min, shape1, shape2, rate = 1, scale = 1/rate)
levpareto4(limit, min, shape1, shape2, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto4_+3A_x">x</code>, <code id="Pareto4_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_min">min</code></td>
<td>
<p>lower bound of the support of the distribution.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_shape1">shape1</code>, <code id="Pareto4_+3A_shape2">shape2</code>, <code id="Pareto4_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_log">log</code>, <code id="Pareto4_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="Pareto4_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pareto IV (or &ldquo;type IV&rdquo;) distribution with parameters
<code>min</code> <code class="reqn">= \mu</code>,
<code>shape1</code> <code class="reqn">= \alpha</code>,
<code>shape2</code> <code class="reqn">= \gamma</code> and
<code>scale</code> <code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha \gamma ((x - \mu)/\theta)^{\gamma - 1}}{%
      \theta [1 + ((x - \mu)/\theta)^\gamma]^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; \mu</code>, <code class="reqn">-\infty &lt; \mu &lt; \infty</code>,
<code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code>
and <code class="reqn">\theta &gt; 0</code>.
</p>
<p>The Pareto IV is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\mu + \theta \left(\frac{X}{1 - X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">1</code> and
<code class="reqn">\alpha</code>. It derives from the <a href="#topic+dfpareto">Feller-Pareto</a>
distribution with <code class="reqn">\tau = 1</code>. Setting <code class="reqn">\mu = 0</code> yields the <a href="#topic+dburr">Burr</a> distribution.
</p>
<p>The Pareto IV distribution also has the following direct special
cases:
</p>

<ul>
<li><p> A <a href="#topic+dpareto3">Pareto III</a> distribution when <code>shape1
      == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto2">Pareto II</a> distribution when <code>shape1
      == 1</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> for nonnegative integer values of <code class="reqn">k &lt;
  \alpha\gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code> for nonnegative integer values of <code class="reqn">k</code>
and <code class="reqn">\alpha - j/\gamma</code>, <code class="reqn">j = 1, \dots, k</code>
not a negative integer.
</p>


<h3>Value</h3>

<p><code>dpareto4</code> gives the density,
<code>ppareto4</code> gives the distribution function,
<code>qpareto4</code> gives the quantile function,
<code>rpareto4</code> generates random deviates,
<code>mpareto4</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levpareto4</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levpareto4</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>For Pareto distributions, we use the classification of Arnold (2015)
with the parametrization of Klugman et al. (2012).
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Arnold, B.C. (2015), <em>Pareto Distributions</em>, Second Edition, CRC
Press.
</p>
<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dburr">dburr</a></code> for the Burr distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dpareto4(1, min = 10, 2, 3, log = TRUE))
p &lt;- (1:10)/10
ppareto4(qpareto4(p, min = 10, 2, 3, 2), min = 10, 2, 3, 2)

## variance
mpareto4(2, min = 10, 2, 3, 1) - mpareto4(1, min = 10, 2, 3, 1) ^ 2

## case with shape1 - order/shape2 &gt; 0
levpareto4(10, min = 10, 2, 3, 1, order = 2)

## case with shape1 - order/shape2 &lt; 0
levpareto4(10, min = 10, 1.5, 0.5, 1, order = 2)
</code></pre>

<hr>
<h2 id='PhaseType'>The Phase-type Distribution</h2><span id='topic+PhaseType'></span><span id='topic+dphtype'></span><span id='topic+pphtype'></span><span id='topic+rphtype'></span><span id='topic+mphtype'></span><span id='topic+mgfphtype'></span>

<h3>Description</h3>

<p>Density, distribution function, random generation, raw moments and
moment generating function for the (continuous) Phase-type
distribution with parameters <code>prob</code> and <code>rates</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dphtype(x, prob, rates, log = FALSE)
pphtype(q, prob, rates, lower.tail = TRUE, log.p = FALSE)
rphtype(n, prob, rates)
mphtype(order, prob, rates)
mgfphtype(t, prob, rates, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhaseType_+3A_x">x</code>, <code id="PhaseType_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_prob">prob</code></td>
<td>
<p>vector of initial probabilities for each of the transient
states of the underlying Markov chain. The initial probability of
the absorbing state is <code>1 - sum(prob)</code>.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_rates">rates</code></td>
<td>
<p>square matrix of the rates of transition among the states
of the underlying Markov chain.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_log">log</code>, <code id="PhaseType_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="PhaseType_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The phase-type distribution with parameters <code>prob</code> <code class="reqn">= \pi</code> and <code>rates</code> <code class="reqn">= \boldsymbol{T}</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \pi e^{\boldsymbol{T} x} \boldsymbol{t}</code>
</p>

<p>for <code class="reqn">x \ge 0</code> and <code class="reqn">f(0) = 1 - \pi \boldsymbol{e}</code>, where 
<code class="reqn">\boldsymbol{e}</code> 
is a column vector with all components equal to one, 
<code class="reqn">\boldsymbol{t} = -\boldsymbol{T} \boldsymbol{e}</code> 
is the exit rates vector and 
<code class="reqn">e^{\boldsymbol{T}x}</code> 
denotes the matrix exponential of <code class="reqn">\boldsymbol{T}x</code>. The
matrix exponential of a matrix <code class="reqn">\boldsymbol{M}</code> is defined as
the Taylor series
</p>
<p style="text-align: center;"><code class="reqn">e^{\boldsymbol{M}} = \sum_{n = 0}^{\infty}
    \frac{\boldsymbol{M}^n}{n!}.</code>
</p>

<p>The parameters of the distribution must satisfy
<code class="reqn">\pi \boldsymbol{e} \leq 1</code>,
<code class="reqn">\boldsymbol{T}_{ii} &lt; 0</code>,
<code class="reqn">\boldsymbol{T}_{ij} \geq 0</code> and
<code class="reqn">\boldsymbol{T} \boldsymbol{e} \leq 0</code>.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the moment generating function is
<code class="reqn">E[e^{tX}]</code>.
</p>


<h3>Value</h3>

<p><code>dphasetype</code> gives the density,
<code>pphasetype</code> gives the distribution function,
<code>rphasetype</code> generates random deviates,
<code>mphasetype</code> gives the <code class="reqn">k</code>th raw moment, and
<code>mgfphasetype</code> gives the moment generating function in <code>x</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Christophe Dutang
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Phase-type_distribution">https://en.wikipedia.org/wiki/Phase-type_distribution</a>
</p>
<p>Neuts, M. F. (1981), <em>Generating random variates from a
distribution of phase type</em>, WSC '81: Proceedings of the 13th
conference on Winter simulation, IEEE Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Erlang(3, 2) distribution
T &lt;- cbind(c(-2, 0, 0), c(2, -2, 0), c(0, 2, -2))
pi &lt;- c(1,0,0)
x &lt;- 0:10

dphtype(x, pi, T)		# density
dgamma(x, 3, 2)			# same
pphtype(x, pi, T)		# cdf
pgamma(x, 3, 2)			# same

rphtype(10, pi, T)		# random values

mphtype(1, pi, T)		# expected value

curve(mgfphtype(x, pi, T), from = -10, to = 1)
</code></pre>

<hr>
<h2 id='PoissonInverseGaussian'>The Poisson-Inverse Gaussian Distribution</h2><span id='topic+PoissonInverseGaussian'></span><span id='topic+PIG'></span><span id='topic+dpoisinvgauss'></span><span id='topic+ppoisinvgauss'></span><span id='topic+qpoisinvgauss'></span><span id='topic+rpoisinvgauss'></span><span id='topic+dpig'></span><span id='topic+ppig'></span><span id='topic+qpig'></span><span id='topic+rpig'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Poisson-inverse Gaussian discrete distribution with
parameters <code>mean</code> and <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisinvgauss(x, mean, shape = 1, dispersion = 1/shape,
              log = FALSE)
ppoisinvgauss(q, mean, shape = 1, dispersion = 1/shape,
              lower.tail = TRUE, log.p = FALSE)
qpoisinvgauss(p, mean, shape = 1, dispersion = 1/shape,
              lower.tail = TRUE, log.p = FALSE)
rpoisinvgauss(n, mean, shape = 1, dispersion = 1/shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonInverseGaussian_+3A_x">x</code></td>
<td>
<p>vector of (positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_mean">mean</code>, <code id="PoissonInverseGaussian_+3A_shape">shape</code></td>
<td>
<p>parameters. Must be strictly positive. Infinite
values are supported.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_dispersion">dispersion</code></td>
<td>
<p>an alternative way to specify the shape.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_log">log</code>, <code id="PoissonInverseGaussian_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="PoissonInverseGaussian_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson-inverse Gaussian distribution is the result of the
continuous mixture between a Poisson distribution and an inverse
Gaussian, that is, the distribution with probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \int_0^\infty \frac{\lambda^x e^{-\lambda}}{x!}\,
           g(\lambda; \mu, \phi)\, d\lambda,</code>
</p>

<p>where <code class="reqn">g(\lambda; \mu, \phi)</code> is the density
function of the inverse Gaussian distribution with parameters
<code>mean</code> <code class="reqn">= \mu</code> and <code>dispersion</code> <code class="reqn">= \phi</code> (see
<code><a href="#topic+dinvgauss">dinvgauss</a></code>).
</p>
<p>The resulting probability mass function is
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \sqrt{\frac{2}{\pi \phi}}
    \frac{e^{(\phi\mu)^{-1}}}{x!}
    \left(
      \sqrt{2\phi\left(1 + \frac{1}{2\phi\mu^2}\right)}
    \right)^{-(x - \frac{1}{2})}
    K_{x - \frac{1}{2}}
    \left(
      \sqrt{\frac{2}{\phi}\left(1 + \frac{1}{2\phi\mu^2}\right)}
    \right),</code>
</p>

<p>for <code class="reqn">x = 0, 1, \dots</code>, <code class="reqn">\mu &gt; 0</code>, <code class="reqn">\phi &gt; 0</code> and where
<code class="reqn">K_\nu(x)</code> is the modified Bessel function of the third
kind implemented by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+besselK">besselK</a>()</code> and defined in its
help.
</p>
<p>The limiting case <code class="reqn">\mu = \infty</code> has well defined
probability mass and distribution functions, but has no finite
strictly positive, integer moments. The pmf in this case reduces to
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \sqrt{\frac{2}{\pi \phi}}
    \frac{1}{x!}
    (\sqrt{2\phi})^{-(x - \frac{1}{2})}
    K_{x - \frac{1}{2}}(\sqrt{2/\phi}).</code>
</p>

<p>The limiting case <code class="reqn">\phi = 0</code> is a degenerate distribution in
<code class="reqn">x = 0</code>.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dpoisinvgauss</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dpoisinvgauss</code> gives the probability mass function,
<code>ppoisinvgauss</code> gives the distribution function,
<code>qpoisinvgauss</code> gives the quantile function, and
<code>rpoisinvgauss</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rpoisinvgauss</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p><code>[dpqr]pig</code> are aliases for <code>[dpqr]poisinvgauss</code>.
</p>
<p><code>qpoisinvgauss</code> is based on <code>qbinom</code> et al.; it uses the
Cornish&ndash;Fisher Expansion to include a skewness correction to a normal
approximation, followed by a search.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Holla, M. S. (1966), &ldquo;On a Poisson-Inverse Gaussian
Distribution&rdquo;, <em>Metrika</em>, vol. 15, p. 377-384.
</p>
<p>Johnson, N. L., Kemp, A. W. and Kotz, S. (2005), <em>Univariate
Discrete Distributions, Third Edition</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Shaban, S. A., (1981) &ldquo;Computation of the poisson-inverse
gaussian distribution&rdquo;, <em>Communications in Statistics - Theory
and Methods</em>, vol. 10, no. 14, p. 1389-1399.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson distribution,
<code><a href="#topic+dinvgauss">dinvgauss</a></code> for the inverse Gaussian distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Tables I and II of Shaban (1981)
x &lt;- 0:2
sapply(c(0.4, 0.8, 1), dpoisinvgauss, x = x, mean = 0.1)
sapply(c(40, 80, 100, 130), dpoisinvgauss, x = x, mean = 1)

qpoisinvgauss(ppoisinvgauss(0:10, 1, dis = 2.5), 1, dis = 2.5)

x &lt;- rpoisinvgauss(1000, 1, dis = 2.5)
y &lt;- sort(unique(x))
plot(y, table(x)/length(x), type = "h", lwd = 2,
     pch = 19, col = "black", xlab = "x", ylab = "p(x)",
     main = "Empirical vs theoretical probabilities")
points(y, dpoisinvgauss(y, 1, dis = 2.5),
       pch = 19, col = "red")
legend("topright", c("empirical", "theoretical"),
       lty = c(1, NA), pch = c(NA, 19), col = c("black", "red"))
</code></pre>

<hr>
<h2 id='quantile.aggregateDist'>Quantiles of Aggregate Claim Amount Distribution</h2><span id='topic+quantile.aggregateDist'></span><span id='topic+VaR.aggregateDist'></span>

<h3>Description</h3>

<p>Quantile and Value-at-Risk methods for objects of class
<code>"aggregateDist"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aggregateDist'
quantile(x, 
         probs = c(0.25, 0.5, 0.75, 0.9, 0.95, 0.975, 0.99, 0.995),
         smooth = FALSE, names = TRUE, ...)

## S3 method for class 'aggregateDist'
VaR(x, conf.level = c(0.9, 0.95, 0.99),
         smooth = FALSE, names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.aggregateDist_+3A_x">x</code></td>
<td>
<p>an object of class <code>"aggregateDist"</code>.</p>
</td></tr>
<tr><td><code id="quantile.aggregateDist_+3A_probs">probs</code>, <code id="quantile.aggregateDist_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric vector of probabilities with values
in <code class="reqn">[0, 1)</code>.</p>
</td></tr>
<tr><td><code id="quantile.aggregateDist_+3A_smooth">smooth</code></td>
<td>
<p>logical; when <code>TRUE</code> and <code>x</code> is a step
function, quantiles are linearly interpolated between knots.</p>
</td></tr>
<tr><td><code id="quantile.aggregateDist_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code>names</code>
attribute.  Set to <code>FALSE</code> for speedup with many <code>probs</code>.</p>
</td></tr>
<tr><td><code id="quantile.aggregateDist_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantiles are taken directly from the cumulative distribution
function defined in <code>x</code>. Linear interpolation is available for
step functions.
</p>


<h3>Value</h3>

<p>A numeric vector, named if <code>names</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and 
Louis-Philippe Pouliot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregateDist">aggregateDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model.freq &lt;- expression(data = rpois(3))
model.sev &lt;- expression(data = rlnorm(10, 1.5))
Fs &lt;- aggregateDist("simulation", model.freq, model.sev, nb.simul = 1000)
quantile(Fs, probs = c(0.25, 0.5, 0.75))
VaR(Fs)
</code></pre>

<hr>
<h2 id='quantile.grouped.data'>Quantiles of Grouped Data</h2><span id='topic+quantile.grouped.data'></span><span id='topic+summary.grouped.data'></span>

<h3>Description</h3>

<p>Sample quantiles corresponding to the given probabilities for objects
of class <code>"grouped.data"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped.data'
quantile(x, probs = seq(0, 1, 0.25),
         names = TRUE, ...)

## S3 method for class 'grouped.data'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.grouped.data_+3A_x">x</code>, <code id="quantile.grouped.data_+3A_object">object</code></td>
<td>
<p>an object of class <code>"grouped.data"</code>.</p>
</td></tr>
<tr><td><code id="quantile.grouped.data_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values
in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="quantile.grouped.data_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code>names</code>
attribute. Set to <code>FALSE</code> for speedup with many <code>probs</code>.</p>
</td></tr>
<tr><td><code id="quantile.grouped.data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantile function is the inverse of the ogive, that is a linear
interpolation of the empirical quantile function.
</p>
<p>The equation of the quantile function is
</p>
<p style="text-align: center;"><code class="reqn">x = \frac{c_j (F_n(c_{j - 1}) - q) +
      c_{j - 1} (q - F_n(c_j)}{F_n(c_j) - F_n(c_{j - 1})}</code>
</p>

<p>for <code class="reqn">0 \leq q \leq c_j</code> and where <code class="reqn">c_0, \dots,
  c_r</code> are the <code class="reqn">r + 1</code> group
boundaries and <code class="reqn">F_n</code> is the empirical distribution function of
the sample.
</p>


<h3>Value</h3>

<p>For <code>quantile</code>, a numeric vector, named if <code>names</code> is
<code>TRUE</code>.
</p>
<p>For the <code>summary</code> method, an object of class
<code>c("summaryDefault", "<a href="base.html#topic+table">table</a>")</code> which has specialized
<code><a href="base.html#topic+format">format</a></code> and <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ogive">ogive</a></code> for the smoothed empirical distribution of which
<code>quantile.grouped.data</code> is an inverse;
<code><a href="#topic+mean.grouped.data">mean.grouped.data</a></code> and <code><a href="#topic+var.grouped.data">var.grouped.data</a></code> to
compute the mean and variance of grouped data.
</p>
<p><code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped data objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)
quantile(gdental)
summary(gdental)
Fn &lt;- ogive(gdental)
Fn(quantile(gdental))		# inverse function
</code></pre>

<hr>
<h2 id='rcomphierarc'>Simulation from Compound Hierarchical Models</h2><span id='topic+rcomphierarc'></span><span id='topic+simul'></span><span id='topic+print.portfolio'></span>

<h3>Description</h3>

<p>Simulate data for insurance applications allowing hierarchical
structures and separate models for the frequency and severity of
claims distributions.
</p>
<p><code>rcomphierarc</code> is an alias for <code>simul</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcomphierarc(nodes, model.freq = NULL, model.sev = NULL, weights = NULL)

## S3 method for class 'portfolio'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcomphierarc_+3A_nodes">nodes</code></td>
<td>
<p>a vector or a named list giving the number of &quot;nodes&quot; at each level
in the hierarchy of the portfolio. The nodes are listed from top
(portfolio) to bottom (usually the years of experience).</p>
</td></tr>
<tr><td><code id="rcomphierarc_+3A_model.freq">model.freq</code></td>
<td>
<p>a named vector of expressions specifying the
frequency of claims model (see Details); if <code>NULL</code>, only claim
amounts are simulated.</p>
</td></tr>
<tr><td><code id="rcomphierarc_+3A_model.sev">model.sev</code></td>
<td>
<p>a named vector of expressions specifying the severity
of claims model (see Details); if <code>NULL</code>, only claim numbers
are simulated.</p>
</td></tr>
<tr><td><code id="rcomphierarc_+3A_weights">weights</code></td>
<td>
<p>a vector of weights.</p>
</td></tr>
<tr><td><code id="rcomphierarc_+3A_x">x</code></td>
<td>
<p>a <code>portfolio</code> object.</p>
</td></tr>
<tr><td><code id="rcomphierarc_+3A_...">...</code></td>
<td>
<p>potential further arguments required by generic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order and the names of the elements in <code>nodes</code>,
<code>model.freq</code> and <code>model.sev</code> must match. At least one of
<code>model.freq</code> and <code>model.sev</code> must be non <code>NULL</code>.
</p>
<p><code>nodes</code> may be a basic vector, named or not, for non hierarchical
models. The rule above still applies, so <code>model.freq</code> and
<code>model.sev</code> should not be named if <code>nodes</code> is not. However,
for non hierarchical models, <code><a href="#topic+rcompound">rcompound</a></code> is faster and has
a simpler interface.
</p>
<p><code>nodes</code> specifies the hierarchical layout of the portfolio. Each
element of the list is a vector of the number of nodes at a given
level. Vectors are recycled as necessary.
</p>
<p><code>model.freq</code> and <code>model.sev</code> specify the simulation models
for claim numbers and claim amounts, respectively. A model is
expressed in a semi-symbolic fashion using an object of mode
<code><a href="base.html#topic+expression">expression</a></code>. Each element of the object
must be named and should be a complete call to a random number
generation function, with the number of variates omitted. Hierarchical
(or mixtures of) models are achieved by replacing one or more
parameters of a distribution at a given level by any combination of
the names of the levels above. If no mixing is to take place at a
level, the model for this level can be <code>NULL</code>.
</p>
<p>The argument of the random number generation functions for the number
of variates to simulate <strong>must</strong> be named <code>n</code>.
</p>
<p>Weights will be used wherever the name <code>"weights"</code> appears in a
model. It is the user's responsibility to ensure that the length of
<code>weights</code> will match the number of nodes when weights are to be
used. Normally, there should be one weight per node at the lowest
level of the model.
</p>
<p>Data is generated in lexicographic order, that is by row in the output
matrix.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"portfolio"</code>. A
<code>print</code> method for this class displays the models used in the
simulation as well as the frequency of claims for each year and entity
in the portfolio.
</p>
<p>An object of class <code>"portfolio"</code> is a list containing the
following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a two dimension list where each element is a vector of
claim amounts;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the vector of weights given in argument reshaped as a
matrix matching element <code>data</code>, or <code>NULL</code>;</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>a matrix of integers where each row is a unique
set of subscripts identifying an entity in the portfolio
(e.g. integers <code class="reqn">i</code>, <code class="reqn">j</code> and <code class="reqn">k</code> for data
<code class="reqn">X_{ijkt}</code>);</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>the <code>nodes</code> argument, appropriately recycled;</p>
</td></tr>
<tr><td><code>model.freq</code></td>
<td>
<p>the frequency model as given in argument;</p>
</td></tr>
<tr><td><code>model.sev</code></td>
<td>
<p>the severity model as given in argument.</p>
</td></tr>
</table>
<p>It is recommended to manipulate objects of class <code>"portfolio"</code> by
means of the corresponding methods of functions <code>aggregate</code>,
<code>frequency</code> and <code>severity</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
SÃ©bastien Auclair and Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>Goulet, V. and Pouliot, L.-P. (2008), Simulation of compound
hierarchical models in R, <em>North American Actuarial Journal</em>
<b>12</b>, 401&ndash;412.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcomphierarc.summaries">rcomphierarc.summaries</a></code> for the functions to create the
matrices of aggregate claim amounts, frequencies and individual claim
amounts.
</p>
<p><code><a href="#topic+rcompound">rcompound</a></code> for a simpler and much faster way to generate
variates from standard, non hierarchical, compound models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two level (contracts and years) portfolio with frequency model
## Nit|Theta_i ~ Poisson(Theta_i), Theta_i ~ Gamma(2, 3) and severity
## model X ~ Lognormal(5, 1)
rcomphierarc(nodes = list(contract = 10, year = 5),
             model.freq = expression(contract = rgamma(2, 3),
                                     year = rpois(contract)),
             model.sev = expression(contract = NULL,
                                    year = rlnorm(5, 1)))

## Model with weights and mixtures for both frequency and severity
## models
nodes &lt;- list(entity = 8, year = c(5, 4, 4, 5, 3, 5, 4, 5))
mf &lt;- expression(entity = rgamma(2, 3),
                 year = rpois(weights * entity))
ms &lt;- expression(entity = rnorm(5, 1),
                 year = rlnorm(entity, 1))
wit &lt;- sample(2:10, 35, replace = TRUE)
pf &lt;- rcomphierarc(nodes, mf, ms, wit)
pf 				# print method
weights(pf)			# extraction of weights
aggregate(pf)[, -1]/weights(pf)[, -1] # ratios

## Four level hierarchical model for frequency only
nodes &lt;- list(sector = 3, unit = c(3, 4),
              employer = c(3, 4, 3, 4, 2, 3, 4), year = 5)
mf &lt;- expression(sector = rexp(1),
                 unit = rexp(sector),
                 employer = rgamma(unit, 1),
                 year = rpois(employer))
pf &lt;- rcomphierarc(nodes, mf, NULL)
pf 				# print method
aggregate(pf) 			# aggregate claim amounts
frequency(pf)  			# frequencies
severity(pf)			# individual claim amounts

## Standard, non hierarchical, compound model with simplified
## syntax (function rcompound() is much faster for such cases)
rcomphierarc(10,
             model.freq = expression(rpois(2)),
             model.sev = expression(rgamma(2, 3)))
</code></pre>

<hr>
<h2 id='rcomphierarc.summaries'>Summary Statistics of a Portfolio</h2><span id='topic+rcomphierarc.summaries'></span><span id='topic+aggregate.portfolio'></span><span id='topic+frequency.portfolio'></span><span id='topic+severity.portfolio'></span><span id='topic+weights.portfolio'></span>

<h3>Description</h3>

<p>Methods for <a href="base.html#topic+class">class</a> <code>"portfolio"</code> objects.
</p>
<p><code>aggregate</code> splits portfolio data into subsets and computes
summary statistics for each.
</p>
<p><code>frequency</code> computes the frequency of claims for subsets of
portfolio data.
</p>
<p><code>severity</code> extracts the individual claim amounts.
</p>
<p><code>weights</code> extracts the matrix of weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'portfolio'
aggregate(x, by = names(x$nodes), FUN = sum,
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
frequency(x, by = names(x$nodes),
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
severity(x, by = head(names(x$node), -1), splitcol = NULL,
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
weights(object, classification = TRUE, prefix = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcomphierarc.summaries_+3A_x">x</code>, <code id="rcomphierarc.summaries_+3A_object">object</code></td>
<td>
<p>an object of class <code>"portfolio"</code>, typically
created with <code><a href="#topic+simul">simul</a></code>.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_by">by</code></td>
<td>
<p>character vector of grouping elements using the level names
of the portfolio in <code>x</code>. The names can be abbreviated.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to data subsets.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_classification">classification</code></td>
<td>
<p>boolean; if <code>TRUE</code>, the node identifier
columns are included in the output.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_prefix">prefix</code></td>
<td>
<p>characters to prefix column names with; if <code>NULL</code>,
sensible defaults are used when appropriate.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_splitcol">splitcol</code></td>
<td>
<p>columns of the data matrix to extract separately;
usual matrix indexing methods are supported.</p>
</td></tr>
<tr><td><code id="rcomphierarc.summaries_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>, or passed to or from
other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>aggregate.portfolio</code> computes the aggregate claim amounts
for the grouping specified in <code>by</code>. Any other statistic based on
the individual claim amounts can be used through argument <code>FUN</code>.
</p>
<p><code>frequency.portfolio</code> is equivalent to using <code>aggregate.portfolio</code>
with argument <code>FUN</code> equal to <code>if (identical(x, NA)) NA else
    length(x)</code>.
</p>
<p><code>severity.portfolio</code> extracts individual claim amounts of a portfolio
by groupings using the default method of <code><a href="#topic+severity">severity</a></code>.
Argument <code>splitcol</code> allows to get the individual claim amounts of
specific columns separately.
</p>
<p><code>weights.portfolio</code> extracts the weight matrix of a portfolio.
</p>


<h3>Value</h3>

<p>A matrix or vector depending on the groupings specified in <code>by</code>.
</p>
<p>For the <code>aggregate</code> and <code>frequency</code> methods: if at least one
level other than the last one is used for grouping, the result is a
matrix obtained by binding the appropriate node identifiers extracted
from <code>x$classification</code> if <code>classification = TRUE</code>, and the
summaries per grouping. If the last level is used for grouping, the
column names of <code>x$data</code> are retained; if the last level is not
used for grouping, the column name is replaced by the deparsed name of
<code>FUN</code>. If only the last level is used (column summaries), a named
vector is returned.
</p>
<p>For the <code>severity</code> method: a list of two elements:
</p>
<table>
<tr><td><code>main</code></td>
<td>
<p><code>NULL</code> or a matrix of claim amounts for the
columns not specified in <code>splitcol</code>, with the appropriate node
identifiers extracted from <code>x$classification</code> if
<code>classification = TRUE</code>;</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p>same as above, but for the columns specified in
<code>splitcol</code>.</p>
</td></tr>
</table>
<p>For the <code>weights</code> method: the weight matrix of the portfolio with
node identifiers if <code>classification = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Louis-Philippe Pouliot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcomphierarc">rcomphierarc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- list(sector = 3, unit = c(3, 4),
              employer = c(3, 4, 3, 4, 2, 3, 4), year = 5)
model.freq &lt;- expression(sector = rexp(1),
                         unit = rexp(sector),
                         employer = rgamma(unit, 1),
                         year = rpois(employer))
model.sev &lt;- expression(sector = rnorm(6, 0.1),
                        unit = rnorm(sector, 1),
                        employer = rnorm(unit, 1),
                        year = rlnorm(employer, 1))
pf &lt;- rcomphierarc(nodes, model.freq, model.sev)

aggregate(pf)            # aggregate claim amount by employer and year
aggregate(pf, classification = FALSE) # same, without node identifiers
aggregate(pf, by = "sector")	      # by sector
aggregate(pf, by = "y")		      # by year
aggregate(pf, by = c("s", "u"), mean) # average claim amount

frequency(pf)			      # number of claims
frequency(pf, prefix = "freq.")       # more explicit column names

severity(pf)			      # claim amounts by row
severity(pf, by = "year")	      # by column
severity(pf, by = c("s", "u"))        # by unit
severity(pf, splitcol = "year.5")     # last year separate
severity(pf, splitcol = 5)            # same
severity(pf, splitcol = c(FALSE, FALSE, FALSE, FALSE, TRUE)) # same

weights(pf)

## For portfolios with weights, the following computes loss ratios.
## Not run: aggregate(pf, classif = FALSE) / weights(pf, classif = FALSE)
</code></pre>

<hr>
<h2 id='rcompound'>Simulation from Compound Models</h2><span id='topic+rcompound'></span><span id='topic+rcomppois'></span>

<h3>Description</h3>

<p><code>rcompound</code> generates random variates from a compound model.
</p>
<p><code>rcomppois</code> is a simplified version for a common case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcompound(n, model.freq, model.sev, SIMPLIFY = TRUE)

rcomppois(n, lambda, model.sev, SIMPLIFY = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcompound_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="rcompound_+3A_model.freq">model.freq</code>, <code id="rcompound_+3A_model.sev">model.sev</code></td>
<td>
<p>expressions specifying the frequency and
severity simulation models with the number of variates omitted; see
Details.</p>
</td></tr>
<tr><td><code id="rcompound_+3A_lambda">lambda</code></td>
<td>
<p>Poisson parameter.</p>
</td></tr>
<tr><td><code id="rcompound_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>boolean; if <code>FALSE</code> the frequency and severity
variates are returned along with the aggregate variates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rcompound</code> generates variates from a random variable of the form
</p>
<p style="text-align: center;"><code class="reqn">S = X_1 + ... X_N,</code>
</p>

<p>where <code class="reqn">N</code> is the frequency random variable and <code class="reqn">X_1, X_2,
    \dots</code> are the severity random variables. The latter are mutually
independent, identically distributed and independent from <code class="reqn">N</code>.
</p>
<p><code>model.freq</code> and <code>model.sev</code> specify the simulation models
for the frequency and the severity random variables, respectively. A
model is a complete call to a random number generation function, with
the number of variates omitted. This is similar to
<code><a href="#topic+rcomphierarc">rcomphierarc</a></code>, but the calls need not be wrapped into
<code><a href="base.html#topic+expression">expression</a></code>. Either argument may also be the name of an
object containing an expression, in which case the object will be
evaluated in the parent frame to retrieve the expression.
</p>
<p>The argument of the random number generation functions for the number
of variates to simulate <strong>must</strong> be named <code>n</code>.
</p>
<p><code>rcomppois</code> generates variates from the common Compound Poisson
model, that is when random variable <code class="reqn">N</code> is Poisson distributed
with mean <code>lambda</code>.
</p>


<h3>Value</h3>

<p>When <code>SIMPLIFY = TRUE</code>, a vector of aggregate amounts <code class="reqn">S_1,
  \dots, S_n</code>. 
</p>
<p>When <code>SIMPLIFY = FALSE</code>, a list of three elements:
</p>
<table>
<tr><td><code>aggregate</code></td>
<td>
<p>vector of aggregate amounts <code class="reqn">S_1, \dots,
      S_n</code>;</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>vector of frequencies <code class="reqn">N_1, \dots,
      N_n</code>;</p>
</td></tr>
<tr><td><code>severity</code></td>
<td>
<p>vector of severities <code class="reqn">X_1, X_2, \dots</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcomphierarc">rcomphierarc</a></code> to simulate from compound hierarchical models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compound Poisson model with gamma severity.
rcompound(10, rpois(2), rgamma(2, 3))
rcomppois(10, 2, rgamma(2, 3))          # same

## Frequencies and individual claim amounts along with aggregate
## values.
rcomppois(10, 2, rgamma(2, 3), SIMPLIFY = FALSE)

## Wrapping the simulation models into expression() is allowed, but
## not needed.
rcompound(10, expression(rpois(2)), expression(rgamma(2, 3)))

## Not run: ## Speed comparison between rcompound() and rcomphierarc().
## [Also note the simpler syntax for rcompound().]
system.time(rcompound(1e6, rpois(2), rgamma(2, 3)))
system.time(rcomphierarc(1e6, expression(rpois(2)), expression(rgamma(2, 3))))
## End(Not run)
## The severity can itself be a compound model. It makes sense
## in such a case to use a zero-truncated frequency distribution
## for the second level model.
rcomppois(10, 2,
          rcompound(rztnbinom(1.5, 0.7), rlnorm(1.2, 1)))
</code></pre>

<hr>
<h2 id='rmixture'>Simulation from Discrete Mixtures</h2><span id='topic+rmixture'></span>

<h3>Description</h3>

<p>Generate random variates from a discrete mixture of distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmixture(n, probs, models, shuffle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmixture_+3A_n">n</code></td>
<td>
<p>number of random variates to generate. If <code>length(n) &gt;
    1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rmixture_+3A_probs">probs</code></td>
<td>
<p>numeric non-negative vector specifying the probability
for each model; is internally normalized to sum 1. Infinite
and missing values are not allowed. Values are recycled as necessary
to match the length of <code>models</code>.</p>
</td></tr>
<tr><td><code id="rmixture_+3A_models">models</code></td>
<td>
<p>vector of expressions specifying the simulation models
with the number of variates omitted; see Details. Models are
recycled as necessary to match the length of <code>probs</code>.</p>
</td></tr>
<tr><td><code id="rmixture_+3A_shuffle">shuffle</code></td>
<td>
<p>logical; should the random variates from the
distributions be shuffled?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rmixture</code> generates variates from a discrete mixture, that is
the random variable with a probability density function of the form
</p>
<p style="text-align: center;"><code class="reqn">f(x) = p_1 f_1(x) + ... + p_n f_n(x),</code>
</p>

<p>where <code class="reqn">f_1, \dots, f_n</code> are densities and <code class="reqn">\sum_{i = 1}^n p_i
    = 1</code>.
</p>
<p>The values in <code>probs</code> will be internally normalized to be
used as probabilities <code class="reqn">p_1 + \dots + p_n</code>.
</p>
<p>The specification of simulation models uses the syntax of
<code><a href="#topic+rcomphierarc">rcomphierarc</a></code>. Models <code class="reqn">f_1, \dots, f_n</code> are expressed in a
semi-symbolic fashion using an object of mode
<code><a href="base.html#topic+expression">expression</a></code> where each element is a complete call
to a random number generation function, with the number of variates
omitted.
</p>
<p>The argument of the random number generation functions for the number
of variates to simulate <strong>must</strong> be named <code>n</code>.
</p>
<p>If <code>shuffle</code> is <code>FALSE</code>, the output vector contains all the
random variates from the first model, then all the random variates
from the second model, and so on. If the order of the variates is
irrelevant, this cuts the time to generate the variates roughly in
half.
</p>


<h3>Value</h3>

<p>A vector of random variates from the mixture with density <code class="reqn">f(x)</code>.
</p>


<h3>Note</h3>

<p>Building the expressions in <code>models</code> from the arguments of
another function is delicate. The expressions must be such that
evaluation is possible in the frame of <code>rmixture</code> or its parent.
See the examples.  
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcompound">rcompound</a></code> to simulate from compound models.
</p>
<p><code><a href="#topic+rcomphierarc">rcomphierarc</a></code> to simulate from compound hierarchical models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Mixture of two exponentials (with means 1/3 and 1/7) with equal
## probabilities.
rmixture(10, 0.5, expression(rexp(3), rexp(7)))
rmixture(10, 42, expression(rexp(3), rexp(7))) # same

## Mixture of two lognormals with different probabilities.
rmixture(10, probs = c(0.55, 0.45),
         models = expression(rlnorm(3.6, 0.6),
                             rlnorm(4.6, 0.3)))

## Building the model expressions in the following example
## works as 'rate' is defined in the parent frame of
## 'rmixture'.
probs &lt;- c(2, 5)
g &lt;- function(n, p, rate)
    rmixture(n, p, expression(rexp(rate[1]), rexp(rate[2])))
g(10, probs, c(3, 7))

## The following example does not work: 'rate' does not exist
## in the evaluation frame of 'rmixture'.
f &lt;- function(n, p, model) rmixture(n, p, model)
h &lt;- function(n, p, rate)
    f(n, p, expression(rexp(rate[1]), rexp(rate[2])))
## Not run: h(10, probs, c(3, 7))

## Fix: substitute the values in the model expressions.
h &lt;- function(n, p, rate)
{
    models &lt;- eval(substitute(expression(rexp(a[1]), rexp(a[2])),
                              list(a = rate)))
    f(n, p, models)
}
h(10, probs, c(3, 7))
</code></pre>

<hr>
<h2 id='ruin'>Probability of Ruin</h2><span id='topic+ruin'></span><span id='topic+plot.ruin'></span>

<h3>Description</h3>

<p>Calulation of infinite time probability of ruin in the models of
CramÃ©r-Lundberg and Sparre Andersen, that is with
exponential or phase-type (including mixtures of exponentials, Erlang
and mixture of Erlang) claims interarrival time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruin(claims = c("exponential", "Erlang", "phase-type"), par.claims,
     wait = c("exponential", "Erlang", "phase-type"), par.wait,
     premium.rate = 1, tol = sqrt(.Machine$double.eps),
     maxit = 200L, echo = FALSE)

## S3 method for class 'ruin'
plot(x, from = NULL, to = NULL, add = FALSE,
     xlab = "u", ylab = expression(psi(u)),
     main = "Probability of Ruin", xlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruin_+3A_claims">claims</code></td>
<td>
<p>character; the type of claim severity distribution.</p>
</td></tr>
<tr><td><code id="ruin_+3A_wait">wait</code></td>
<td>
<p>character; the type of claim interarrival (wait) time
distribution.</p>
</td></tr>
<tr><td><code id="ruin_+3A_par.claims">par.claims</code>, <code id="ruin_+3A_par.wait">par.wait</code></td>
<td>
<p>named list containing the parameters of
the distribution; see Details.</p>
</td></tr>
<tr><td><code id="ruin_+3A_premium.rate">premium.rate</code></td>
<td>
<p>numeric vector of length 1; the premium rate.</p>
</td></tr>
<tr><td><code id="ruin_+3A_tol">tol</code>, <code id="ruin_+3A_maxit">maxit</code>, <code id="ruin_+3A_echo">echo</code></td>
<td>
<p>respectively the tolerance level of the
stopping criteria, the maximum number of iterations and whether or
not to echo the procedure when the transition rates matrix is
determined iteratively. Ignored if <code>wait = "exponential"</code>.</p>
</td></tr>
<tr><td><code id="ruin_+3A_x">x</code></td>
<td>
<p>an object of class <code>"ruin"</code>.</p>
</td></tr>
<tr><td><code id="ruin_+3A_from">from</code>, <code id="ruin_+3A_to">to</code></td>
<td>
<p>the range over which the function will be plotted.</p>
</td></tr>
<tr><td><code id="ruin_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> add to already existing plot.</p>
</td></tr>
<tr><td><code id="ruin_+3A_xlim">xlim</code></td>
<td>
<p>numeric of length 2; if specified, it serves as default
for <code>c(from, to)</code>.</p>
</td></tr>
<tr><td><code id="ruin_+3A_xlab">xlab</code>, <code id="ruin_+3A_ylab">ylab</code></td>
<td>
<p>label of the x and y axes, respectively.</p>
</td></tr>
<tr><td><code id="ruin_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="ruin_+3A_...">...</code></td>
<td>
<p>further graphical parameters accepted by
<code><a href="graphics.html#topic+curve">curve</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the parameters in <code>par.claims</code> and <code>par.wait</code>
must the same as in <code><a href="stats.html#topic+dexp">dexp</a></code>,
<code><a href="stats.html#topic+dgamma">dgamma</a></code> or <code><a href="#topic+dphtype">dphtype</a></code>, as appropriate.
A model will be a mixture of exponential or Erlang distributions (but
not phase-type) when the parameters are vectors of length <code class="reqn">&gt; 1</code>
and the parameter list contains a vector <code>weights</code> of the
coefficients of the mixture.
</p>
<p>Parameters are recycled when needed. Their names can be abbreviated.
</p>
<p>Combinations of exponentials as defined in Dufresne and Gerber (1988)
are <em>not</em> supported.
</p>
<p>Ruin probabilities are evaluated using <code><a href="#topic+pphtype">pphtype</a></code> except
when both distributions are exponential, in which case an explicit
formula is used.
</p>
<p>When <code>wait != "exponential"</code> (Sparre Andersen model), the
transition rate matrix <code class="reqn">\boldsymbol{Q}</code> of the distribution of
the probability of ruin is determined iteratively using a fixed
point-like algorithm. The stopping criteria used is
</p>
<p style="text-align: center;"><code class="reqn">\max \left\{
    \sum_{j = 1}^n |\boldsymbol{Q}_{ij} - \boldsymbol{Q}_{ij}^\prime|
    \right\} &lt; \code{tol},</code>
</p>

<p>where <code class="reqn">\boldsymbol{Q}</code> and <code class="reqn">\boldsymbol{Q}^\prime</code> are
two successive values of the matrix.
</p>


<h3>Value</h3>

<p>A function of class <code>"ruin"</code> inheriting from the
<code>"function"</code> class to compute the probability of ruin given
initial surplus levels. The function has arguments:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>numeric vector of initial surplus levels;</p>
</td></tr>
<tr><td><code>survival</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), probabilities are
<code class="reqn">\psi(u)</code>, otherwise, <code class="reqn">\phi(u) = 1 - \psi(u)</code>;</p>
</td></tr>
<tr><td><code>lower.tail</code></td>
<td>
<p>an alias for <code>!survival</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
and Christophe Dutang
</p>


<h3>References</h3>

<p>Asmussen, S. and Rolski, T. (1991), Computational methods in risk theory:
A matrix algorithmic approach, <em>Insurance: Mathematics and
Economics</em> <b>10</b>, 259&ndash;274.
</p>
<p>Dufresne, F. and Gerber, H. U. (1988), Three methods to calculate
the probability of ruin, <em>Astin Bulletin</em> <b>19</b>, 71&ndash;90.
</p>
<p>Gerber, H. U. (1979), <em>An Introduction to Mathematical Risk
Theory</em>, Huebner Foundation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Case with an explicit formula: exponential claims and exponential
## interarrival times.
psi &lt;- ruin(claims = "e", par.claims = list(rate = 5),
            wait   = "e", par.wait   = list(rate = 3))
psi
psi(0:10)
plot(psi, from = 0, to = 10)

## Mixture of two exponentials for claims, exponential interarrival
## times (Gerber 1979)
psi &lt;- ruin(claims = "e", par.claims = list(rate = c(3, 7), w = 0.5),
            wait   = "e", par.wait   = list(rate = 3), pre = 1)
u &lt;- 0:10
psi(u)
(24 * exp(-u) + exp(-6 * u))/35	# same

## Phase-type claims, exponential interarrival times (Asmussen and
## Rolski 1991)
p &lt;- c(0.5614, 0.4386)
r &lt;- matrix(c(-8.64, 0.101, 1.997, -1.095), 2, 2)
lambda &lt;- 1/(1.1 * mphtype(1, p, r))
psi &lt;- ruin(claims = "p", par.claims = list(prob = p, rates = r),
            wait   = "e", par.wait   = list(rate = lambda))
psi
plot(psi, xlim = c(0, 50))

## Phase-type claims, mixture of two exponentials for interarrival times
## (Asmussen and Rolski 1991)
a &lt;- (0.4/5 + 0.6) * lambda
ruin(claims = "p", par.claims = list(prob = p, rates = r),
     wait   = "e", par.wait   = list(rate = c(5 * a, a), weights =
                                     c(0.4, 0.6)),
     maxit = 225L)
</code></pre>

<hr>
<h2 id='severity'>Manipulation of Individual Claim Amounts</h2><span id='topic+severity'></span><span id='topic+severity.default'></span>

<h3>Description</h3>

<p><code>severity</code> is a generic function created to manipulate individual
claim amounts. The function invokes particular <em>methods</em> which
depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>severity(x, ...)

## Default S3 method:
severity(x, bycol = FALSE, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="severity_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="severity_+3A_bycol">bycol</code></td>
<td>
<p>logical; whether to &ldquo;unroll&rdquo; horizontally
(<code>FALSE</code>) or vertically (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="severity_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="severity_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result is coerced to the
lowest possible dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the default method is equivalent to
<code><a href="#topic+unroll">unroll</a></code>. This is liable to change since the link between
the name and the use of the function is rather weak.
</p>


<h3>Value</h3>

<p>A vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Louis-Philippe Pouliot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+severity.portfolio">severity.portfolio</a></code> for the original motivation of these
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(1:3), c(1:8), c(1:4), c(1:3))
(mat &lt;- matrix(x, 2, 2))
severity(mat)
severity(mat, bycol = TRUE)
</code></pre>

<hr>
<h2 id='SingleParameterPareto'>The Single-parameter Pareto Distribution</h2><span id='topic+SingleParameterPareto'></span><span id='topic+dpareto1'></span><span id='topic+ppareto1'></span><span id='topic+qpareto1'></span><span id='topic+rpareto1'></span><span id='topic+mpareto1'></span><span id='topic+levpareto1'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments, and limited moments for the Single-parameter Pareto
distribution with parameter <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto1(x, shape, min, log = FALSE)
ppareto1(q, shape, min, lower.tail = TRUE, log.p = FALSE)
qpareto1(p, shape, min, lower.tail = TRUE, log.p = FALSE)
rpareto1(n, shape, min)
mpareto1(order, shape, min)
levpareto1(limit, shape, min, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleParameterPareto_+3A_x">x</code>, <code id="SingleParameterPareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_shape">shape</code></td>
<td>
<p>parameter. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_min">min</code></td>
<td>
<p>lower bound of the support of the distribution.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_log">log</code>, <code id="SingleParameterPareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="SingleParameterPareto_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The single-parameter Pareto, or Pareto I, distribution with parameter
<code>shape</code> <code class="reqn">= \alpha</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\alpha \theta^\alpha}{x^{\alpha + 1}}</code>
</p>

<p>for <code class="reqn">x &gt; \theta</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\theta &gt;
    0</code>.
</p>
<p>Although there appears to be two parameters, only <code>shape</code> is a true
parameter. The value of <code>min</code> <code class="reqn">= \theta</code> must be set in
advance.
</p>
<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">k &lt; \alpha</code> and the <code class="reqn">k</code>th
limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, <code class="reqn">x \ge \theta</code>.
</p>


<h3>Value</h3>

<p><code>dpareto1</code> gives the density,
<code>ppareto1</code> gives the distribution function,
<code>qpareto1</code> gives the quantile function,
<code>rpareto1</code> generates random deviates,
<code>mpareto1</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levpareto1</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>For Pareto distributions, we use the classification of Arnold (2015)
with the parametrization of Klugman et al. (2012).
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Arnold, B.C. (2015), <em>Pareto Distributions</em>, Second Edition, CRC
Press.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpareto">dpareto</a></code> for the two-parameter Pareto distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dpareto1(5, 3, 4, log = TRUE))
p &lt;- (1:10)/10
ppareto1(qpareto1(p, 2, 3), 2, 3)
mpareto1(2, 3, 4) - mpareto(1, 3, 4) ^ 2
levpareto(10, 3, 4, order = 2)
</code></pre>

<hr>
<h2 id='TransformedBeta'>The Transformed Beta Distribution</h2><span id='topic+TransformedBeta'></span><span id='topic+dtrbeta'></span><span id='topic+ptrbeta'></span><span id='topic+qtrbeta'></span><span id='topic+rtrbeta'></span><span id='topic+mtrbeta'></span><span id='topic+levtrbeta'></span><span id='topic+Pearson6'></span><span id='topic+dpearson6'></span><span id='topic+ppearson6'></span><span id='topic+qpearson6'></span><span id='topic+rpearson6'></span><span id='topic+mpearson6'></span><span id='topic+levpearson6'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Transformed Beta distribution
with parameters <code>shape1</code>, <code>shape2</code>, <code>shape3</code> and
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtrbeta(x, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        log = FALSE)
ptrbeta(q, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
qtrbeta(p, shape1, shape2, shape3, rate = 1, scale = 1/rate,
        lower.tail = TRUE, log.p = FALSE)
rtrbeta(n, shape1, shape2, shape3, rate = 1, scale = 1/rate)
mtrbeta(order, shape1, shape2, shape3, rate = 1, scale = 1/rate)
levtrbeta(limit, shape1, shape2, shape3, rate = 1, scale = 1/rate,
          order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformedBeta_+3A_x">x</code>, <code id="TransformedBeta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_shape1">shape1</code>, <code id="TransformedBeta_+3A_shape2">shape2</code>, <code id="TransformedBeta_+3A_shape3">shape3</code>, <code id="TransformedBeta_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly
positive.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_log">log</code>, <code id="TransformedBeta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="TransformedBeta_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformed beta distribution with parameters <code>shape1</code> <code class="reqn">=
    \alpha</code>, <code>shape2</code> <code class="reqn">= \gamma</code>, <code>shape3</code>
<code class="reqn">= \tau</code> and <code>scale</code> <code class="reqn">= \theta</code>, has
density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\Gamma(\alpha + \tau)}{\Gamma(\alpha)\Gamma(\tau)}
    \frac{\gamma (x/\theta)^{\gamma \tau}}{%
      x [1 + (x/\theta)^\gamma]^{\alpha + \tau}}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\gamma &gt; 0</code>,
<code class="reqn">\tau &gt; 0</code> and <code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The transformed beta is the distribution of the random variable
</p>
<p style="text-align: center;"><code class="reqn">\theta \left(\frac{X}{1 - X}\right)^{1/\gamma},</code>
</p>

<p>where <code class="reqn">X</code> has a beta distribution with parameters <code class="reqn">\tau</code>
and <code class="reqn">\alpha</code>.
</p>
<p>The transformed beta distribution defines a family of distributions
with the following special cases:
</p>

<ul>
<li><p> A <a href="#topic+dburr">Burr</a> distribution when <code>shape3 == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dllogis">loglogistic</a> distribution when <code>shape1
      == shape3 == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dparalogis">paralogistic</a> distribution when
<code>shape3 == 1</code> and <code>shape2 == shape1</code>;
</p>
</li>
<li><p> A <a href="#topic+dgenpareto">generalized Pareto</a> distribution when
<code>shape2 == 1</code>;
</p>
</li>
<li><p> A <a href="#topic+dpareto">Pareto</a> distribution when <code>shape2 ==
      shape3 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvburr">inverse Burr</a> distribution when
<code>shape1 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvpareto">inverse Pareto</a> distribution when
<code>shape2 == shape1 == 1</code>;
</p>
</li>
<li><p> An <a href="#topic+dinvparalogis">inverse paralogistic</a> distribution
when <code>shape1 == 1</code> and <code>shape3 == shape2</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, <code class="reqn">-\tau\gamma &lt; k &lt; \alpha\gamma</code>.
</p>
<p>The <code class="reqn">k</code>th limited moment at some limit <code class="reqn">d</code> is <code class="reqn">E[\min(X,
  d)^k]</code>, <code class="reqn">k &gt; -\tau\gamma</code>
and <code class="reqn">\alpha - k/\gamma</code> not a negative integer.
</p>


<h3>Value</h3>

<p><code>dtrbeta</code> gives the density,
<code>ptrbeta</code> gives the distribution function,
<code>qtrbeta</code> gives the quantile function,
<code>rtrbeta</code> generates random deviates,
<code>mtrbeta</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levtrbeta</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p><code>levtrbeta</code> computes the limited expected value using
<code><a href="#topic+betaint">betaint</a></code>.
</p>
<p>Distribution also known as the Generalized Beta of the Second
Kind and Pearson Type VI. See also Kleiber and Kotz (2003) for
alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfpareto">dfpareto</a></code> for an equivalent distribution with a location
parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dtrbeta(2, 2, 3, 4, 5, log = TRUE))
p &lt;- (1:10)/10
ptrbeta(qtrbeta(p, 2, 3, 4, 5), 2, 3, 4, 5)
qpearson6(0.3, 2, 3, 4, 5, lower.tail = FALSE)

## variance
mtrbeta(2, 2, 3, 4, 5) - mtrbeta(1, 2, 3, 4, 5)^2

## case with shape1 - order/shape2 &gt; 0
levtrbeta(10, 2, 3, 4, scale = 1, order = 2)

## case with shape1 - order/shape2 &lt; 0
levtrbeta(10, 1/3, 0.75, 4, scale = 0.5, order = 2)
</code></pre>

<hr>
<h2 id='TransformedGamma'>The Transformed Gamma Distribution</h2><span id='topic+TransformedGamma'></span><span id='topic+dtrgamma'></span><span id='topic+ptrgamma'></span><span id='topic+qtrgamma'></span><span id='topic+rtrgamma'></span><span id='topic+mtrgamma'></span><span id='topic+levtrgamma'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation,
raw moments and limited moments for the Transformed Gamma distribution
with parameters <code>shape1</code>, <code>shape2</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtrgamma(x, shape1, shape2, rate = 1, scale = 1/rate,
         log = FALSE)
ptrgamma(q, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
qtrgamma(p, shape1, shape2, rate = 1, scale = 1/rate,
         lower.tail = TRUE, log.p = FALSE)
rtrgamma(n, shape1, shape2, rate = 1, scale = 1/rate)
mtrgamma(order, shape1, shape2, rate = 1, scale = 1/rate)
levtrgamma(limit, shape1, shape2, rate = 1, scale = 1/rate,
           order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformedGamma_+3A_x">x</code>, <code id="TransformedGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_shape1">shape1</code>, <code id="TransformedGamma_+3A_shape2">shape2</code>, <code id="TransformedGamma_+3A_scale">scale</code></td>
<td>
<p>parameters. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_log">log</code>, <code id="TransformedGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/densities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="TransformedGamma_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformed gamma distribution with parameters <code>shape1</code> <code class="reqn">=
    \alpha</code>, <code>shape2</code> <code class="reqn">= \tau</code> and <code>scale</code>
<code class="reqn">= \theta</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\tau u^\alpha e^{-u}}{x \Gamma(\alpha)}, %
      \quad u = (x/\theta)^\tau</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code>, <code class="reqn">\tau &gt; 0</code>
and <code class="reqn">\theta &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented
by <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.)
</p>
<p>The transformed gamma is the distribution of the random variable
<code class="reqn">\theta X^{1/\tau},</code>
where <code class="reqn">X</code> has a gamma distribution with shape parameter
<code class="reqn">\alpha</code> and scale parameter <code class="reqn">1</code> or, equivalently, of the
random variable
<code class="reqn">Y^{1/\tau}</code>
with <code class="reqn">Y</code> a gamma distribution with shape parameter <code class="reqn">\alpha</code>
and scale parameter <code class="reqn">\theta^\tau</code>.
</p>
<p>The transformed gamma probability distribution defines a family of
distributions with the following special cases:
</p>

<ul>
<li><p> A <a href="stats.html#topic+dgamma">Gamma</a> distribution when <code>shape2 == 1</code>;
</p>
</li>
<li><p> A <a href="stats.html#topic+dweibull">Weibull</a> distribution when <code>shape1 ==
      1</code>;
</p>
</li>
<li><p> An <a href="stats.html#topic+dexp">Exponential</a> distribution when <code>shape2 ==
      shape1 == 1</code>.
</p>
</li></ul>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, <code class="reqn">k &gt;
  -\alpha\tau</code>.
</p>


<h3>Value</h3>

<p><code>dtrgamma</code> gives the density,
<code>ptrgamma</code> gives the distribution function,
<code>qtrgamma</code> gives the quantile function,
<code>rtrgamma</code> generates random deviates,
<code>mtrgamma</code> gives the <code class="reqn">k</code>th raw moment, and
<code>levtrgamma</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Note</h3>

<p>Distribution also known as the Generalized Gamma. See also Kleiber and
Kotz (2003) for alternative names and parametrizations.
</p>
<p>The <code>"distributions"</code> package vignette provides the
interrelations between the continuous size distributions in
<span class="pkg">actuar</span> and the complete formulas underlying the above functions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003), <em>Statistical Size Distributions
in Economics and Actuarial Sciences</em>, Wiley.
</p>
<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(dtrgamma(2, 3, 4, 5, log = TRUE))
p &lt;- (1:10)/10
ptrgamma(qtrgamma(p, 2, 3, 4), 2, 3, 4)
mtrgamma(2, 3, 4, 5) - mtrgamma(1, 3, 4, 5) ^ 2
levtrgamma(10, 3, 4, 5, order = 2)
</code></pre>

<hr>
<h2 id='UniformSupp'>Moments and Moment Generating Function of the Uniform Distribution</h2><span id='topic+UniformSupp'></span><span id='topic+munif'></span><span id='topic+levunif'></span><span id='topic+mgfunif'></span>

<h3>Description</h3>

<p>Raw moments, limited moments and moment generating function for the
Uniform distribution from <code>min</code> to <code>max</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>munif(order, min = 0, max = 1)
levunif(limit, min = 0, max =1, order = 1)
mgfunif(t, min = 0, max = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniformSupp_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="UniformSupp_+3A_min">min</code>, <code id="UniformSupp_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution. Must be finite.</p>
</td></tr>
<tr><td><code id="UniformSupp_+3A_limit">limit</code></td>
<td>
<p>limit of the random variable.</p>
</td></tr>
<tr><td><code id="UniformSupp_+3A_t">t</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="UniformSupp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the cumulant generating function
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code>, the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code> and the moment
generating function is <code class="reqn">E[e^{tX}]</code>.
</p>


<h3>Value</h3>

<p><code>munif</code> gives the <code class="reqn">k</code>th raw moment,
<code>levunif</code> gives the <code class="reqn">k</code>th moment of the limited random
variable, and
<code>mgfunif</code> gives the moment generating function in <code>t</code>.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Christophe Dutang
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29">https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Uniform">Uniform</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>munif(-1)
munif(1:5)
levunif(3, order=1:5)
levunif(3, 2, 4)
mgfunif(1, 1, 2)
</code></pre>

<hr>
<h2 id='unroll'>Display a Two-Dimension Version of a Matrix of Vectors</h2><span id='topic+unroll'></span>

<h3>Description</h3>

<p>Displays all values of a matrix of vectors by &ldquo;unrolling&rdquo; the
object vertically or horizontally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unroll(x, bycol = FALSE, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unroll_+3A_x">x</code></td>
<td>
<p>a list of vectors with a <code><a href="base.html#topic+dim">dim</a></code> attribute of
length 0, 1 or 2.</p>
</td></tr>
<tr><td><code id="unroll_+3A_bycol">bycol</code></td>
<td>
<p>logical; whether to unroll horizontally
(<code>FALSE</code>) or vertically (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="unroll_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result is coerced to the
lowest possible dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unroll</code> returns a matrix where elements of <code>x</code>
are concatenated (&ldquo;unrolled&rdquo;) by row (<code>bycol = FALSE</code>) or
by column (<code>bycol = TRUE</code>). <code>NA</code> is used to make
rows/columns of equal length.
</p>
<p>Vectors and one dimensional arrays are coerced to <strong>row</strong>
matrices.
</p>


<h3>Value</h3>

<p>A vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Louis-Philippe Pouliot
</p>


<h3>See Also</h3>

<p>This function was originally written for use in
<code><a href="#topic+severity.portfolio">severity.portfolio</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(1:3), c(1:8), c(1:4), c(1:3))
(mat &lt;- matrix(x, 2, 2))

unroll(mat)
unroll(mat, bycol = TRUE)

unroll(mat[1, ])
unroll(mat[1, ], drop = FALSE)
</code></pre>

<hr>
<h2 id='var'>Variance and Standard Deviation</h2><span id='topic+var'></span><span id='topic+var.default'></span><span id='topic+var.grouped.data'></span><span id='topic+sd'></span><span id='topic+sd.default'></span><span id='topic+sd.grouped.data'></span>

<h3>Description</h3>

<p>Generic functions for the variance and standard deviation, and methods
for individual and grouped data.
</p>
<p>The default methods for individual data are the functions from the
<span class="pkg">stats</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var(x, ...)

## Default S3 method:
var(x, y = NULL, na.rm = FALSE, use, ...)

## S3 method for class 'grouped.data'
var(x, ...)

sd(x, ...)

## Default S3 method:
sd(x, na.rm = FALSE, ...)

## S3 method for class 'grouped.data'
sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p>a vector or matrix of individual data, or an object of class
<code>"grouped data"</code>.</p>
</td></tr>
<tr><td><code id="var_+3A_y">y</code></td>
<td>
<p>see <code><a href="stats.html#topic+var">stats::var</a></code>.</p>
</td></tr>
<tr><td><code id="var_+3A_na.rm">na.rm</code></td>
<td>
<p>see <code><a href="stats.html#topic+var">stats::var</a></code>.</p>
</td></tr>
<tr><td><code id="var_+3A_use">use</code></td>
<td>
<p>see <code><a href="stats.html#topic+var">stats::var</a></code>.</p>
</td></tr>
<tr><td><code id="var_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This page documents variance and standard deviation computations for
grouped data. For individual data, see <code><a href="stats.html#topic+var">var</a></code> and
<code><a href="stats.html#topic+sd">sd</a></code> from the <span class="pkg">stats</span> package.
</p>
<p>For grouped data with group boundaries <code class="reqn">c_0, c_1, \dots,
  c_r</code> and group frequencies <code class="reqn">n_1, \dots,
  n_r</code>, <code>var</code> computes the sample variance
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n - 1} \sum_{j = 1}^r n_j (a_j - m_1)^2,</code>
</p>

<p>where
<code class="reqn">a_j = (c_{j - 1} + c_j)/2</code>
is the midpoint of the <code class="reqn">j</code>th interval,
<code class="reqn">m_1</code> is the sample mean (or sample first moment) of the data,
and
<code class="reqn">n = \sum_{j = 1}^r n_j</code>.
The sample sample standard deviation is the square root of the sample
variance.
</p>
<p>The sample variance for grouped data differs from the variance
computed from the empirical raw moments with <code><a href="#topic+emm">emm</a></code> in two
aspects. First, it takes into account the degrees of freedom. Second,
it applies Sheppard's correction factor to compensate for the
overestimation of the true variation in the data. For groups of equal
width <code class="reqn">k</code>, Sheppard's correction factor is equal to <code class="reqn">-k^2/12</code>.
</p>


<h3>Value</h3>

<p>A named vector of variances or standard deviations.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>. Variance and
standard deviation methods for grouped data contributed by Walter
Garcia-Fontes <a href="mailto:walter.garcia@upf.edu">walter.garcia@upf.edu</a>.
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (1998),
<em>Loss Models, From Data to Decisions</em>, Wiley.
</p>
<p>Heumann, C., Schomaker, M., Shalabh (2016), <em>Introduction to
Statistics and Data Analysis</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped.data">grouped.data</a></code> to create grouped data objects;
<code><a href="#topic+mean.grouped.data">mean.grouped.data</a></code> for the mean and <code><a href="#topic+emm">emm</a></code> for
higher moments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gdental)
var(gdental)
sd(gdental)

## Illustration of Sheppard's correction factor
cj &lt;- c(0, 2, 4, 6, 8)
nj &lt;- c(1, 5,  3,  2)
gd &lt;- grouped.data(Group = cj, Frequency = nj)
(sum(nj) - 1)/sum(nj) * var(gd)
(emm(gd, 2) - emm(gd)^2) - 4/12
</code></pre>

<hr>
<h2 id='VaR'>Value at Risk</h2><span id='topic+VaR'></span>

<h3>Description</h3>

<p>Value at Risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VaR_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="VaR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function with, currently, only a method for objects
of class <code>"aggregateDist"</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>numeric</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and 
Tommy Ouellet
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VaR.aggregateDist">VaR.aggregateDist</a></code>, <code><a href="#topic+aggregateDist">aggregateDist</a></code>
</p>

<hr>
<h2 id='WeibullMoments'>Raw and Limited Moments of the Weibull Distribution</h2><span id='topic+WeibullMoments'></span><span id='topic+mweibull'></span><span id='topic+levweibull'></span>

<h3>Description</h3>

<p>Raw moments and limited moments for the Weibull distribution with
parameters <code>shape</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mweibull(order, shape, scale = 1)
levweibull(limit, shape, scale = 1, order = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeibullMoments_+3A_order">order</code></td>
<td>
<p>order of the moment.</p>
</td></tr>
<tr><td><code id="WeibullMoments_+3A_limit">limit</code></td>
<td>
<p>limit of the loss variable.</p>
</td></tr>
<tr><td><code id="WeibullMoments_+3A_shape">shape</code>, <code id="WeibullMoments_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting
to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>th raw moment of the random variable <code class="reqn">X</code> is
<code class="reqn">E[X^k]</code> and the <code class="reqn">k</code>th limited moment at some limit
<code class="reqn">d</code> is <code class="reqn">E[\min(X, d)^k]</code>, <code class="reqn">k &gt;
  -\tau</code>.
</p>


<h3>Value</h3>

<p><code>mweibull</code> gives the <code class="reqn">k</code>th raw moment and
<code>levweibull</code> gives the <code class="reqn">k</code>th moment of the limited loss
variable.
</p>
<p>Invalid arguments will result in return value <code>NaN</code>, with a warning.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Mathieu Pigeon
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code> for details on the Weibull distribution and
functions <code>[dpqr]weibull</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mweibull(2, 3, 4) - mweibull(1, 3, 4)^2
levweibull(10, 3, 4, order = 2)
</code></pre>

<hr>
<h2 id='ZeroModifiedBinomial'>The Zero-Modified Binomial Distribution</h2><span id='topic+ZeroModifiedBinomial'></span><span id='topic+ZMBinomial'></span><span id='topic+dzmbinom'></span><span id='topic+pzmbinom'></span><span id='topic+qzmbinom'></span><span id='topic+rzmbinom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Modified Binomial distribution with
parameters <code>size</code> and <code>prob</code>, and probability at zero
<code>p0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzmbinom(x, size, prob, p0, log = FALSE)
pzmbinom(q, size, prob, p0, lower.tail = TRUE, log.p = FALSE)
qzmbinom(p, size, prob, p0, lower.tail = TRUE, log.p = FALSE)
rzmbinom(n, size, prob, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroModifiedBinomial_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_size">size</code></td>
<td>
<p>number of trials (strictly positive integer).</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial. <code>0 &lt;= prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_p0">p0</code></td>
<td>
<p>probability mass at zero. <code>0 &lt;= p0 &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_log">log</code>, <code id="ZeroModifiedBinomial_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-modified binomial distribution with <code>size</code> <code class="reqn">= n</code>,
<code>prob</code> <code class="reqn">= p</code> and <code>p0</code> <code class="reqn">= p_0</code> is a discrete
mixture between a degenerate distribution at zero and a (standard)
binomial. The probability mass function is <code class="reqn">p(0) = p_0</code>
and
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{(1-p_0)}{(1 - (1-p)^n)} f(x)</code>
</p>

<p>for <code class="reqn">x = 1, \ldots, n</code>, <code class="reqn">0 &lt; p \le 1</code> and <code class="reqn">0 \le
  p_0 \le 1</code>, where <code class="reqn">f(x)</code> is the probability mass
function of the binomial.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = p_0 + (1 - p_0) \left(\frac{F(x) - F(0)}{1 - F(0)}\right)</code>
</p>

<p>The mean is <code class="reqn">(1-p_0) \mu</code> and the variance is
<code class="reqn">(1-p_0) \sigma^2 + p_0(1-p_0) \mu^2</code>,
where <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code> are the mean and variance of
the zero-truncated binomial.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-modified
binomial is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = -p/(1-p)</code> and <code class="reqn">b = (n+1)p/(1-p)</code>.
</p>
<p>The special case <code>p0 == 0</code> is the zero-truncated binomial.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dzmbinom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dzmbinom</code> gives the probability mass function,
<code>pzmbinom</code> gives the distribution function,
<code>qzmbinom</code> gives the quantile function, and
<code>rzmbinom</code> generates random deviates.
</p>
<p>Invalid <code>size</code>, <code>prob</code> or <code>p0</code> will result in return
value <code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rzmbinom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}zmbinom</code> use <code>{d,p,q}binom</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial distribution.
</p>
<p><code><a href="#topic+dztbinom">dztbinom</a></code> for the zero-truncated binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dzmbinom(1:5, size = 5, prob = 0.4, p0 = 0.2)
(1-0.2) * dbinom(1:5, 5, 0.4)/pbinom(0, 5, 0.4, lower = FALSE) # same

## simple relation between survival functions
pzmbinom(0:5, 5, 0.4, p0 = 0.2, lower = FALSE)
(1-0.2) * pbinom(0:5, 5, 0.4, lower = FALSE) /
    pbinom(0, 5, 0.4, lower = FALSE) # same

qzmbinom(pzmbinom(1:10, 10, 0.6, p0 = 0.1), 10, 0.6, p0 = 0.1)

n &lt;- 8; p &lt;- 0.3; p0 &lt;- 0.025
x &lt;- 0:n
title &lt;- paste("ZM Binomial(", n, ", ", p, ", p0 = ", p0,
               ") and Binomial(", n, ", ", p,") PDF",
               sep = "")
plot(x, dzmbinom(x, n, p, p0), type = "h", lwd = 2, ylab = "p(x)",
     main = title)
points(x, dbinom(x, n, p), pch = 19, col = "red")
legend("topright", c("ZT binomial probabilities", "Binomial probabilities"),
       col = c("black", "red"), lty = c(1, 0), lwd = 2, pch = c(NA, 19))
</code></pre>

<hr>
<h2 id='ZeroModifiedGeometric'>The Zero-Modified Geometric Distribution</h2><span id='topic+ZeroModifiedGeometric'></span><span id='topic+Zmgeometric'></span><span id='topic+dzmgeom'></span><span id='topic+pzmgeom'></span><span id='topic+qzmgeom'></span><span id='topic+rzmgeom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Modified Geometric distribution with
parameter <code>prob</code> and arbitrary probability at zero <code>p0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzmgeom(x, prob, p0, log = FALSE)
pzmgeom(q, prob, p0, lower.tail = TRUE, log.p = FALSE)
qzmgeom(p, prob, p0, lower.tail = TRUE, log.p = FALSE)
rzmgeom(n, prob, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroModifiedGeometric_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_p0">p0</code></td>
<td>
<p>probability mass at zero. <code>0 &lt;= p0 &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_log">log</code>, <code id="ZeroModifiedGeometric_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedGeometric_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-modified geometric distribution with <code>prob</code> <code class="reqn">= p</code>
and <code>p0</code> <code class="reqn">= p_0</code> is a discrete mixture between a
degenerate distribution at zero and a (standard) geometric. The
probability mass function is <code class="reqn">p(0) = p_0</code> and
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{(1-p_0)}{(1-p)} f(x)</code>
</p>

<p>for <code class="reqn">x = 1, 2, \ldots</code>, <code class="reqn">0 &lt; p &lt; 1</code> and <code class="reqn">0 \le
  p_0 \le 1</code>, where <code class="reqn">f(x)</code> is the probability mass
function of the geometric.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = p_0 + (1 - p_0) \left(\frac{F(x) - F(0)}{1 - F(0)}\right)</code>
</p>

<p>The mean is <code class="reqn">(1-p_0) \mu</code> and the variance is
<code class="reqn">(1-p_0) \sigma^2 + p_0(1-p_0) \mu^2</code>,
where <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code> are the mean and variance of
the zero-truncated geometric.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-modified
geometric is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = 1-p</code> and <code class="reqn">b = 0</code>.
</p>
<p>The special case <code>p0 == 0</code> is the zero-truncated geometric.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dzmgeom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dzmgeom</code> gives the (log) probability mass function,
<code>pzmgeom</code> gives the (log) distribution function,
<code>qzmgeom</code> gives the quantile function, and
<code>rzmgeom</code> generates random deviates.
</p>
<p>Invalid <code>prob</code> or <code>p0</code> will result in return value
<code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rzmgeom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}zmgeom</code> use <code>{d,p,q}geom</code> for all but
the trivial input values and <code class="reqn">p(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dgeom">dgeom</a></code> for the geometric distribution.
</p>
<p><code><a href="#topic+dztgeom">dztgeom</a></code> for the zero-truncated geometric distribution.
</p>
<p><code><a href="#topic+dzmnbinom">dzmnbinom</a></code> for the zero-modified negative binomial, of
which the zero-modified geometric is a special case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 1/(1 + 0.5)
dzmgeom(1:5, prob = p, p0 = 0.6)
(1-0.6) * dgeom(1:5, p)/pgeom(0, p, lower = FALSE) # same

## simple relation between survival functions
pzmgeom(0:5, p, p0 = 0.2, lower = FALSE)
(1-0.2) * pgeom(0:5, p, lower = FALSE)/pgeom(0, p, lower = FALSE) # same

qzmgeom(pzmgeom(0:10, 0.3, p0 = 0.6), 0.3, p0 = 0.6)
</code></pre>

<hr>
<h2 id='ZeroModifiedLogarithmic'>The Zero-Modified Logarithmic Distribution</h2><span id='topic+ZeroModifiedLogarithmic'></span><span id='topic+ZMLogarithmic'></span><span id='topic+dzmlogarithmic'></span><span id='topic+pzmlogarithmic'></span><span id='topic+qzmlogarithmic'></span><span id='topic+rzmlogarithmic'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Modified Logarithmic (or log-series)
distribution with parameter <code>prob</code> and arbitrary probability at
zero <code>p0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzmlogarithmic(x, prob, p0, log = FALSE)
pzmlogarithmic(q, prob, p0, lower.tail = TRUE, log.p = FALSE)
qzmlogarithmic(p, prob, p0, lower.tail = TRUE, log.p = FALSE)
rzmlogarithmic(n, prob, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt;= prob &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_p0">p0</code></td>
<td>
<p>probability mass at zero. <code>0 &lt;= p0 &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_log">log</code>, <code id="ZeroModifiedLogarithmic_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedLogarithmic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-modified logarithmic distribution with <code>prob</code> <code class="reqn">= p</code>
and <code>p0</code> <code class="reqn">= p_0</code> is a discrete mixture between a
degenerate distribution at zero and a (standard) logarithmic. The
probability mass function is <code class="reqn">p(0) = p_0</code> and
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = (1-p_0) f(x)</code>
</p>

<p>for <code class="reqn">x = 1, 2, \ldots</code>, <code class="reqn">0 &lt; p &lt; 1</code> and <code class="reqn">0 \le
  p_0 \le 1</code>, where <code class="reqn">f(x)</code> is the probability mass
function of the logarithmic.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = p_0 + (1 - p_0) F(x)</code>
</p>

<p>The special case <code>p0 == 0</code> is the standard logarithmic.
</p>
<p>The zero-modified logarithmic distribution is the limiting case of the
zero-modified negative binomial distribution with <code>size</code>
parameter equal to <code class="reqn">0</code>. Note that in this context, parameter
<code>prob</code> generally corresponds to the probability of <em>failure</em>
of the zero-truncated negative binomial.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dzmlogarithmic</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dzmlogarithmic</code> gives the probability mass function,
<code>pzmlogarithmic</code> gives the distribution function,
<code>qzmlogarithmic</code> gives the quantile function, and
<code>rzmlogarithmic</code> generates random deviates.
</p>
<p>Invalid <code>prob</code> or <code>p0</code> will result in return value
<code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rzmlogarithmic</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}zmlogarithmic</code> use
<code>{d,p,q}logarithmic</code> for all but the trivial input values and
<code class="reqn">p(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlogarithmic">dlogarithmic</a></code> for the logarithmic distribution.
</p>
<p><code><a href="#topic+dztnbinom">dztnbinom</a></code> for the zero modified negative binomial
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 1/(1 + 0.5)
dzmlogarithmic(1:5, prob = p, p0 = 0.6)
(1-0.6) * dlogarithmic(1:5, p)/plogarithmic(0, p, lower = FALSE) # same

## simple relation between survival functions
pzmlogarithmic(0:5, p, p0 = 0.2, lower = FALSE)
(1-0.2) * plogarithmic(0:5, p, lower = FALSE)/plogarithmic(0, p, lower = FALSE) # same

qzmlogarithmic(pzmlogarithmic(0:10, 0.3, p0 = 0.6), 0.3, p0 = 0.6)
</code></pre>

<hr>
<h2 id='ZeroModifiedNegativeBinomial'>The Zero-Modified Negative Binomial Distribution</h2><span id='topic+ZeroModifiedNegativeBinomial'></span><span id='topic+ZMNegativeBinomial'></span><span id='topic+ZMNegBinomial'></span><span id='topic+dzmnbinom'></span><span id='topic+pzmnbinom'></span><span id='topic+qzmnbinom'></span><span id='topic+rzmnbinom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Modified Negative Binomial distribution with
parameters <code>size</code> and <code>prob</code>, and arbitrary probability at
zero <code>p0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzmnbinom(x, size, prob, p0, log = FALSE)
pzmnbinom(q, size, prob, p0, lower.tail = TRUE, log.p = FALSE)
qzmnbinom(p, size, prob, p0, lower.tail = TRUE, log.p = FALSE)
rzmnbinom(n, size, prob, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter. Must be positive, need not be integer.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_p0">p0</code></td>
<td>
<p>probability mass at zero. <code>0 &lt;= p0 &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_log">log</code>, <code id="ZeroModifiedNegativeBinomial_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedNegativeBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-modified negative binomial distribution with <code>size</code>
<code class="reqn">= r</code>, <code>prob</code> <code class="reqn">= p</code> and <code>p0</code> <code class="reqn">= p_0</code> is a
discrete mixture between a degenerate distribution at zero and a
(standard) negative binomial. The probability mass function is
<code class="reqn">p(0) = p_0</code> and
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{(1-p_0)}{(1-p^r)} f(x)</code>
</p>

<p>for <code class="reqn">x = 1, 2, \ldots</code>, <code class="reqn">r \ge 0</code>, <code class="reqn">0 &lt; p &lt; 1</code> and <code class="reqn">0 \le
  p_0 \le 1</code>, where <code class="reqn">f(x)</code> is the probability mass
function of the negative binomial.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = p_0 + (1 - p_0) \left(\frac{F(x) - F(0)}{1 - F(0)}\right)</code>
</p>

<p>The mean is <code class="reqn">(1-p_0) \mu</code> and the variance is
<code class="reqn">(1-p_0) \sigma^2 + p_0(1-p_0) \mu^2</code>,
where <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code> are the mean and variance of
the zero-truncated negative binomial.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-modified
negative binomial is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = 1-p</code> and <code class="reqn">b = (r-1)(1-p)</code>.
</p>
<p>The special case <code>p0 == 0</code> is the zero-truncated negative
binomial.
</p>
<p>The limiting case <code>size == 0</code> is the zero-modified logarithmic
distribution with parameters <code>1 - prob</code> and <code>p0</code>.
</p>
<p>Unlike the standard negative binomial functions, parametrization
through the mean <code>mu</code> is not supported to avoid ambiguity as
to whether <code>mu</code> is the mean of the underlying negative binomial
or the mean of the zero-modified distribution.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dzmnbinom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dzmnbinom</code> gives the (log) probability mass function,
<code>pzmnbinom</code> gives the (log) distribution function,
<code>qzmnbinom</code> gives the quantile function, and
<code>rzmnbinom</code> generates random deviates.
</p>
<p>Invalid <code>size</code>, <code>prob</code> or <code>p0</code> will result in return
value <code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rzmnbinom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}zmnbinom</code> use <code>{d,p,q}nbinom</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnbinom">dnbinom</a></code> for the negative binomial distribution.
</p>
<p><code><a href="#topic+dztnbinom">dztnbinom</a></code> for the zero-truncated negative binomial
distribution.
</p>
<p><code><a href="#topic+dzmgeom">dzmgeom</a></code> for the zero-modified geometric and
<code><a href="#topic+dzmlogarithmic">dzmlogarithmic</a></code> for the zero-modified logarithmic, which
are special cases of the zero-modified negative binomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 6.3 of Klugman et al. (2012)
p &lt;- 1/(1 + 0.5)
dzmnbinom(1:5, size = 2.5, prob = p, p0 = 0.6)
(1-0.6) * dnbinom(1:5, 2.5, p)/pnbinom(0, 2.5, p, lower = FALSE) # same

## simple relation between survival functions
pzmnbinom(0:5, 2.5, p, p0 = 0.2, lower = FALSE)
(1-0.2) * pnbinom(0:5, 2.5, p, lower = FALSE) /
    pnbinom(0, 2.5, p, lower = FALSE) # same

qzmnbinom(pzmnbinom(0:10, 2.5, 0.3, p0 = 0.1), 2.5, 0.3, p0 = 0.1)
</code></pre>

<hr>
<h2 id='ZeroModifiedPoisson'>The Zero-Modified Poisson Distribution</h2><span id='topic+ZeroModifiedPoisson'></span><span id='topic+ZMpoisson'></span><span id='topic+dzmpois'></span><span id='topic+pzmpois'></span><span id='topic+qzmpois'></span><span id='topic+rzmpois'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random
generation for the Zero-Modified Poisson distribution with parameter
<code>lambda</code> and arbitrary probability at zero <code>p0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzmpois(x, lambda, p0, log = FALSE)
pzmpois(q, lambda, p0, lower.tail = TRUE, log.p = FALSE)
qzmpois(p, lambda, p0, lower.tail = TRUE, log.p = FALSE)
rzmpois(n, lambda, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroModifiedPoisson_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_n">n</code></td>
<td>
<p>number of values to return.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non negative) means.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_p0">p0</code></td>
<td>
<p>probability mass at zero. <code>0 &lt;= p0 &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_log">log</code>, <code id="ZeroModifiedPoisson_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroModifiedPoisson_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-modified Poisson distribution is a discrete mixture between a
degenerate distribution at zero and a (standard) Poisson. The
probability mass function is <code class="reqn">p(0) = p_0</code> and
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{(1-p_0)}{(1-e^{-\lambda})} f(x)</code>
</p>

<p>for <code class="reqn">x = 1, 2, ...</code>, <code class="reqn">\lambda &gt; 0</code> and <code class="reqn">0 \le
  p_0 \le 1</code>, where <code class="reqn">f(x)</code> is the probability mass
function of the Poisson.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = p_0 + (1 - p_0) \left(\frac{F(x) - F(0)}{1 - F(0)}\right).</code>
</p>

<p>The mean is <code class="reqn">(1-p_0) \mu</code> and the variance is
<code class="reqn">(1-p_0) \sigma^2 + p_0(1-p_0) \mu^2</code>,
where <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code> are the mean and variance of
the zero-truncated Poisson.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-modified
Poisson is a member of the <code class="reqn">(a, b, 1)</code> class of distributions
with <code class="reqn">a = 0</code> and <code class="reqn">b = \lambda</code>.
</p>
<p>The special case <code>p0 == 0</code> is the zero-truncated Poisson.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dzmpois</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dzmpois</code> gives the (log) probability mass function,
<code>pzmpois</code> gives the (log) distribution function,
<code>qzmpois</code> gives the quantile function, and
<code>rzmpois</code> generates random deviates.
</p>
<p>Invalid <code>lambda</code> or <code>p0</code> will result in return value
<code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rzmpois</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}zmpois</code> use <code>{d,p,q}pois</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the standard Poisson distribution.
</p>
<p><code><a href="#topic+dztpois">dztpois</a></code> for the zero-truncated Poisson distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dzmpois(0:5, lambda = 1, p0 = 0.2)
(1-0.2) * dpois(0:5, lambda = 1)/ppois(0, 1, lower = FALSE) # same

## simple relation between survival functions
pzmpois(0:5, 1, p0 = 0.2, lower = FALSE)
(1-0.2) * ppois(0:5, 1, lower = FALSE) /
    ppois(0, 1, lower = FALSE) # same

qzmpois(pzmpois(0:10, 1, p0 = 0.7), 1, p0 = 0.7)
</code></pre>

<hr>
<h2 id='ZeroTruncatedBinomial'>The Zero-Truncated Binomial Distribution</h2><span id='topic+ZeroTruncatedBinomial'></span><span id='topic+ZTBinomial'></span><span id='topic+dztbinom'></span><span id='topic+pztbinom'></span><span id='topic+qztbinom'></span><span id='topic+rztbinom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Truncated Binomial distribution with
parameters <code>size</code> and <code>prob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztbinom(x, size, prob, log = FALSE)
pztbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE)
qztbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE)
rztbinom(n, size, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroTruncatedBinomial_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_size">size</code></td>
<td>
<p>number of trials (strictly positive integer).</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial. <code>0 &lt;= prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_log">log</code>, <code id="ZeroTruncatedBinomial_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-truncated binomial distribution with <code>size</code>
<code class="reqn">= n</code> and <code>prob</code> <code class="reqn">= p</code> has probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = {n \choose x} \frac{p^x (1 - p)^{n-x}}{1 - (1 - p)^n}</code>
</p>

<p>for <code class="reqn">x = 1, \ldots, n</code> and <code class="reqn">0 &lt; p \le 1</code>, and <code class="reqn">p(1) = 1</code>
when <code class="reqn">p = 0</code>.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = \frac{F(x) - F(0)}{1 - F(0)},</code>
</p>

<p>where <code class="reqn">F(x)</code> is the distribution function of the standard binomial.
</p>
<p>The mean is <code class="reqn">np/(1 - (1-p)^n)</code> and the variance is
<code class="reqn">np[(1-p) - (1-p+np)(1-p)^n]/[1 - (1-p)^n]^2</code>.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-truncated
binomial is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = -p/(1-p)</code> and <code class="reqn">b = (n+1)p/(1-p)</code>.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dztbinom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dztbinom</code> gives the probability mass function,
<code>pztbinom</code> gives the distribution function,
<code>qztbinom</code> gives the quantile function, and
<code>rztbinom</code> generates random deviates.
</p>
<p>Invalid <code>size</code> or <code>prob</code> will result in return value
<code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rztbinom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}ztbinom</code> use <code>{d,p,q}binom</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>
<p><code>rztbinom</code> uses the simple inversion algorithm suggested by
Peter Dalgaard on the r-help mailing list on 1 May 2005 
(<a href="https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html">https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html</a>).
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dztbinom(1:5, size = 5, prob = 0.4)
dbinom(1:5, 5, 0.4)/pbinom(0, 5, 0.4, lower = FALSE) # same

pztbinom(1, 2, prob = 0)        # point mass at 1

qztbinom(pztbinom(1:10, 10, 0.6), 10, 0.6)

n &lt;- 8; p &lt;- 0.3
x &lt;- 0:n
title &lt;- paste("ZT Binomial(", n, ", ", p,
               ") and Binomial(", n, ", ", p,") PDF",
               sep = "")
plot(x, dztbinom(x, n, p), type = "h", lwd = 2, ylab = "p(x)",
     main = title)
points(x, dbinom(x, n, p), pch = 19, col = "red")
legend("topright", c("ZT binomial probabilities", "Binomial probabilities"),
       col = c("black", "red"), lty = c(1, 0), lwd = 2, pch = c(NA, 19))
</code></pre>

<hr>
<h2 id='ZeroTruncatedGeometric'>The Zero-Truncated Geometric Distribution</h2><span id='topic+ZeroTruncatedGeometric'></span><span id='topic+ZTGeometric'></span><span id='topic+dztgeom'></span><span id='topic+pztgeom'></span><span id='topic+qztgeom'></span><span id='topic+rztgeom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Truncated Geometric distribution with
parameter <code>prob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztgeom(x, prob, log = FALSE)
pztgeom(q, prob, lower.tail = TRUE, log.p = FALSE)
qztgeom(p, prob, lower.tail = TRUE, log.p = FALSE)
rztgeom(n, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroTruncatedGeometric_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_log">log</code>, <code id="ZeroTruncatedGeometric_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedGeometric_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-truncated geometric distribution with <code>prob</code> <code class="reqn">= p</code>
has probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = p (1-p)^{x - 1}</code>
</p>

<p>for <code class="reqn">x = 1, 2, \ldots</code> and <code class="reqn">0 &lt; p &lt; 1</code>, and
<code class="reqn">p(1) = 1</code> when <code class="reqn">p = 1</code>.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = \frac{F(x) - F(0)}{1 - F(0)},</code>
</p>

<p>where <code class="reqn">F(x)</code> is the distribution function of the standard geometric.
</p>
<p>The mean is <code class="reqn">1/p</code> and the variance is <code class="reqn">(1-p)/p^2</code>.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-truncated
geometric is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = 1-p</code> and <code class="reqn">b = 0</code>.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dztgeom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dztgeom</code> gives the (log) probability mass function,
<code>pztgeom</code> gives the (log) distribution function,
<code>qztgeom</code> gives the quantile function, and
<code>rztgeom</code> generates random deviates.
</p>
<p>Invalid <code>prob</code> will result in return value <code>NaN</code>, with a
warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rztgeom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}ztgeom</code> use <code>{d,p,q}geom</code> for all but
the trivial input values and <code class="reqn">p(0)</code>.
</p>
<p><code>rztgeom</code> uses the simple inversion algorithm suggested by
Peter Dalgaard on the r-help mailing list on 1 May 2005 
(<a href="https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html">https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html</a>).
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dgeom">dgeom</a></code> for the geometric distribution.
</p>
<p><code><a href="#topic+dztnbinom">dztnbinom</a></code> for the zero-truncated negative binomial, of
which the zero-truncated geometric is a special case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 1/(1 + 0.5)
dztgeom(c(1, 2, 3), prob = p)
dgeom(c(1, 2, 3), p)/pgeom(0, p, lower = FALSE) # same
dgeom(c(1, 2, 3) - 1, p)                        # same

pztgeom(1, prob = 1)        # point mass at 1

qztgeom(pztgeom(1:10, 0.3), 0.3)
</code></pre>

<hr>
<h2 id='ZeroTruncatedNegativeBinomial'>The Zero-Truncated Negative Binomial Distribution</h2><span id='topic+ZeroTruncatedNegativeBinomial'></span><span id='topic+ZTNegativeBinomial'></span><span id='topic+ZTNegBinomial'></span><span id='topic+dztnbinom'></span><span id='topic+pztnbinom'></span><span id='topic+qztnbinom'></span><span id='topic+rztnbinom'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random
generation for the Zero-Truncated Negative Binomial distribution with
parameters <code>size</code> and <code>prob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztnbinom(x, size, prob, log = FALSE)
pztnbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE)
qztnbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE)
rztnbinom(n, size, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter. Must be positive, need not be integer.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_prob">prob</code></td>
<td>
<p>parameter. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_log">log</code>, <code id="ZeroTruncatedNegativeBinomial_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedNegativeBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-truncated negative binomial distribution with <code>size</code>
<code class="reqn">= r</code> and <code>prob</code> <code class="reqn">= p</code> has probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{\Gamma(x + r) p^r (1 - p)^x}{\Gamma(r) x! (1 - p^r)}</code>
</p>

<p>for <code class="reqn">x = 1, 2, \ldots</code>, <code class="reqn">r \ge 0</code> and <code class="reqn">0 &lt; p &lt; 1</code>, and
<code class="reqn">p(1) = 1</code> when <code class="reqn">p = 1</code>.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = \frac{F(x) - F(0)}{1 - F(0)},</code>
</p>

<p>where <code class="reqn">F(x)</code> is the distribution function of the standard negative
binomial.
</p>
<p>The mean is <code class="reqn">r(1-p)/(p(1-p^r))</code> and the variance is
<code class="reqn">[r(1-p)(1 - (1 + r(1-p))p^r)]/[p(1-p^r)]^2</code>.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-truncated
negative binomial is a member of the <code class="reqn">(a, b, 1)</code> class of
distributions with <code class="reqn">a = 1-p</code> and <code class="reqn">b = (r-1)(1-p)</code>.
</p>
<p>The limiting case <code>size == 0</code> is the
<a href="#topic+Logarithmic">logarithmic</a> distribution with parameter <code>1 -
  prob</code>.
</p>
<p>Unlike the standard negative binomial functions, parametrization
through the mean <code>mu</code> is not supported to avoid ambiguity as
to whether <code>mu</code> is the mean of the underlying negative binomial
or the mean of the zero-truncated distribution.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dztnbinom</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dztnbinom</code> gives the (log) probability mass function,
<code>pztnbinom</code> gives the (log) distribution function,
<code>qztnbinom</code> gives the quantile function, and
<code>rztnbinom</code> generates random deviates.
</p>
<p>Invalid <code>size</code> or <code>prob</code> will result in return value
<code>NaN</code>, with a warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rztnbinom</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}ztnbinom</code> use <code>{d,p,q}nbinom</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>
<p><code>rztnbinom</code> uses the simple inversion algorithm suggested by
Peter Dalgaard on the r-help mailing list on 1 May 2005 
(<a href="https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html">https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html</a>).
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnbinom">dnbinom</a></code> for the negative binomial distribution.
</p>
<p><code><a href="#topic+dztgeom">dztgeom</a></code> for the zero-truncated geometric and
<code><a href="#topic+dlogarithmic">dlogarithmic</a></code> for the logarithmic, which are special
cases of the zero-truncated negative binomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 6.3 of Klugman et al. (2012)
p &lt;- 1/(1 + 0.5)
dztnbinom(c(1, 2, 3), size = 2.5, prob = p)
dnbinom(c(1, 2, 3), 2.5, p)/pnbinom(0, 2.5, p, lower = FALSE) # same

pztnbinom(1, 2, prob = 1)        # point mass at 1
dztnbinom(2, size = 1, 0.25)     # == dztgeom(2, 0.25)
dztnbinom(2, size = 0, 0.25)     # == dlogarithmic(2, 0.75)

qztnbinom(pztnbinom(1:10, 2.5, 0.3), 2.5, 0.3)

x &lt;- rztnbinom(1000, size = 2.5, prob = 0.4)
y &lt;- sort(unique(x))
plot(y, table(x)/length(x), type = "h", lwd = 2,
     pch = 19, col = "black", xlab = "x", ylab = "p(x)",
     main = "Empirical vs theoretical probabilities")
points(y, dztnbinom(y, size = 2.5, prob = 0.4),
       pch = 19, col = "red")
legend("topright", c("empirical", "theoretical"),
       lty = c(1, NA), lwd = 2, pch = c(NA, 19), col = c("black", "red"))
</code></pre>

<hr>
<h2 id='ZeroTruncatedPoisson'>The Zero-Truncated Poisson Distribution</h2><span id='topic+ZeroTruncatedPoisson'></span><span id='topic+ZTPoisson'></span><span id='topic+dztpois'></span><span id='topic+pztpois'></span><span id='topic+qztpois'></span><span id='topic+rztpois'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random
generation for the Zero-Truncated Poisson distribution with parameter
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dztpois(x, lambda, log = FALSE)
pztpois(q, lambda, lower.tail = TRUE, log.p = FALSE)
qztpois(p, lambda, lower.tail = TRUE, log.p = FALSE)
rztpois(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroTruncatedPoisson_+3A_x">x</code></td>
<td>
<p>vector of (strictly positive integer) quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_n">n</code></td>
<td>
<p>number of values to return.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non negative) means.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_log">log</code>, <code id="ZeroTruncatedPoisson_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="ZeroTruncatedPoisson_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-truncated Poisson distribution has probability mass function
</p>
<p style="text-align: center;"><code class="reqn">%
    p(x) = \frac{e^{-/lambda} \lambda^x}{x! (1 - e^{-\lambda})}
    = \frac{\lambda^x}{x! (e^{\lambda} - 1)}</code>
</p>

<p>for <code class="reqn">x = 1, 2, ...</code>, and <code class="reqn">p(1) = 1</code> when <code class="reqn">\lambda = 0</code>.
The cumulative distribution function is
</p>
<p style="text-align: center;"><code class="reqn">P(x) = \frac{F(x) - F(0)}{1 - F(0)},</code>
</p>

<p>where <code class="reqn">F(x)</code> is the distribution function of the standard Poisson.
</p>
<p>The mean is <code class="reqn">\lambda/(1 - e^{-\lambda})^2</code> and the variance is
<code class="reqn">\lambda[1 - (\lambda+1)e^{-\lambda}]/(1 - e^{-\lambda})^2</code>.
</p>
<p>In the terminology of Klugman et al. (2012), the zero-truncated
Poisson is a member of the <code class="reqn">(a, b, 1)</code> class of distributions
with <code class="reqn">a = 0</code> and <code class="reqn">b = \lambda</code>.
</p>
<p>If an element of <code>x</code> is not integer, the result of
<code>dztpois</code> is zero, with a warning.
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that
<code class="reqn">P(x) \ge p</code>, where <code class="reqn">P</code> is the distribution function.
</p>


<h3>Value</h3>

<p><code>dztpois</code> gives the (log) probability mass function,
<code>pztpois</code> gives the (log) distribution function,
<code>qztpois</code> gives the quantile function, and
<code>rztpois</code> generates random deviates.
</p>
<p>Invalid <code>lambda</code> will result in return value <code>NaN</code>, with a
warning.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rztpois</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.
</p>


<h3>Note</h3>

<p>Functions <code>{d,p,q}ztpois</code> use <code>{d,p,q}pois</code> for all
but the trivial input values and <code class="reqn">p(0)</code>.
</p>
<p><code>rztpois</code> uses the simple inversion algorithm suggested by
Peter Dalgaard on the r-help mailing list on 1 May 2005 
(<a href="https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html">https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html</a>).
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the standard Poisson distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dztpois(1:5, lambda = 1)
dpois(1:5, lambda = 1)/ppois(0, 1, lower = FALSE) # same

pztpois(1, lambda = 0)          # point mass at 1

qztpois(pztpois(1:10, 1), 1)

x &lt;- seq(0, 8)
plot(x, dztpois(x, 2), type = "h", lwd = 2, ylab = "p(x)",
     main = "Zero-Truncated Poisson(2) and Poisson(2) PDF")
points(x, dpois(x, 2), pch = 19, col = "red")
legend("topright", c("ZT Poisson probabilities", "Poisson probabilities"),
       col = c("black", "red"), lty = c(1, 0), lwd = 2, pch = c(NA, 19))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
