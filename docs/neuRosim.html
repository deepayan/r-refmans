<!DOCTYPE html><html><head><title>Help for package neuRosim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neuRosim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#neuRosim-package'><p>Functions to Generate fMRI Data Including Activated Data, Noise Data and Resting State Data</p></a></li>
<li><a href='#balloon'><p>Balloon model</p></a></li>
<li><a href='#canonicalHRF'><p>Double-gamma Haemodynamic reponse function</p></a></li>
<li><a href='#gammaHRF'><p>Single Gamma Haemodynamic response function.</p></a></li>
<li><a href='#GaussSmoothKernel'><p>Calculates a discrete Gaussian smoothing kernel (adopted from <span class="pkg">AnalyzeFMRI</span>)</p></a></li>
<li><a href='#lowfreqdrift'><p>Generate low frequency drift</p></a></li>
<li><a href='#physnoise'><p>Generate physiological noise</p></a></li>
<li><a href='#rrice'><p>The Rice Distribution</p></a></li>
<li><a href='#Sim.3D.GRF'><p>Simulate a GRF (adopted from <span class="pkg">AnalyzeFMRI</span>)</p></a></li>
<li><a href='#simprepSpatial'><p>Prepare spatial structure of the data</p></a></li>
<li><a href='#simprepTemporal'><p>Prepare temporal structure of the data</p></a></li>
<li><a href='#simTSfmri'><p>Simulate fMRI time series</p></a></li>
<li><a href='#simTSrestingstate'><p>Simulate fMRI resting state time series</p></a></li>
<li><a href='#simVOLfmri'><p>Simulate 3D or 4D fMRI data</p></a></li>
<li><a href='#spatialnoise'><p>Generate spatially correlated noise</p></a></li>
<li><a href='#specifydesign'><p>Generate design matrix.</p></a></li>
<li><a href='#specifyregion'><p>Generate activation image</p></a></li>
<li><a href='#stimfunction'><p>Generate a stimulus boxcar function.</p></a></li>
<li><a href='#systemnoise'><p>Generate system noise</p></a></li>
<li><a href='#tasknoise'><p>Generate task-related noise</p></a></li>
<li><a href='#temporalnoise'><p>Generate temporally correlated noise</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate fMRI Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), deSolve</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates functional Magnetic Resonance Imaging (fMRI) 
             time series or 4D data. Some high-level 
             functions are created for fast data generation with only 
             a few arguments and a diversity of functions to define 
             activation and noise. For more advanced users it is possible 
             to use the low-level functions and manipulate the arguments.
             See Welvaert et al. (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v044.i10">doi:10.18637/jss.v044.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 12:50:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 09:49:35 UTC; tabelow</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Marijke Welvaert [aut],
  Joke Durnez [ctb],
  Beatrijs Moerkerke [ctb],
  Yves Rosseel [ctb],
  Karsten Tabelow [ctb, cre],
  Geert Verdoolaege [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;</td>
</tr>
</table>
<hr>
<h2 id='neuRosim-package'>Functions to Generate fMRI Data Including Activated Data, Noise Data and Resting State Data
</h2><span id='topic+neuRosim-package'></span><span id='topic+neuRosim'></span>

<h3>Description</h3>

<p>The package allows users to generate fMRI time series or 4D data. Some high-level functions are created for fast data generation with only a few arguments and a diversity of functions to define activation and noise. For more advanced users it is possible to use the low-level functions and manipulate the arguments.
</p>


<h3>Author(s)</h3>

<p>Marijke Welvaert with contributions from Joke Durnez, Beatrijs Moerkerke, Yves Rosseel, Karsten Tabelow, and Geert Verdoolaege
</p>
<p>Maintainer: Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;
</p>


<h3>References</h3>

<p>Welvaert, M., Durnez, J., Moerkerke, B., Verdoolaege, G. and Rosseel, Y. (2011). <span class="pkg">neuRosim</span>: An R Package for Generating fMRI Data. Journal of Statistical Software, 44(10), 1&ndash;18</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate fMRI time series for block design
design &lt;- simprepTemporal(totaltime=200, onsets=seq(1,200,40),
	 durations=20, TR=2, effectsize=1, hrf="double-gamma")
ts &lt;- simTSfmri(design=design, SNR=1, noise="white")
plot(ts, type="l")

## Generate fMRI slice for block design with activation in 2 regions
design &lt;- simprepTemporal(totaltime=200, onsets=seq(1,200,40), 
	durations=20, TR=2, effectsize=1, hrf="double-gamma")
region &lt;- simprepSpatial(regions=2, coord=list(c(32,15),c(57,45)), 
	radius=c(10,7), form="sphere")
out &lt;- simVOLfmri(design=design, image=region, dim=c(64,64), 
	SNR=1, noise="none")
plot(out[32,15,], type="l")

</code></pre>

<hr>
<h2 id='balloon'>Balloon model</h2><span id='topic+balloon'></span>

<h3>Description</h3>

<p>Generates the BOLD signal based on the Balloon model of Buxton et al. (2004).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  balloon(stim, totaltime, acc, par=list(), verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balloon_+3A_stim">stim</code></td>
<td>
<p>Vector representing the presence/absence (1-0 coding) of a stimulus/activation in seconds.</p>
</td></tr>
<tr><td><code id="balloon_+3A_totaltime">totaltime</code></td>
<td>
<p>Total duration of stimulus vector in seconds.</p>
</td></tr>
<tr><td><code id="balloon_+3A_acc">acc</code></td>
<td>
<p>Microtime resolution of stimulus vector in seconds.</p>
</td></tr>
<tr><td><code id="balloon_+3A_par">par</code></td>
<td>
<p>List representing the parameters of the Balloon model. The list should contain the following:
</p>

<dl>
<dt>kappa</dt><dd><p>Inhibitory gain factor</p>
</dd>
<dt>tau1</dt><dd><p>Inhibitory time constant</p>
</dd>
<dt>tauf</dt><dd><p>FWHM of CBF impulse response</p>
</dd>
<dt>taum</dt><dd><p>FWHM of CMRO2 impulse resonse</p>
</dd>
<dt>deltat</dt><dd><p>Delay of CBF relative to CMRO2 response</p>
</dd>
<dt>n</dt><dd><p>Steady-state flow metabolism relation</p>
</dd>
<dt>f1</dt><dd><p>Normalized CBF response to sustained neural activation</p>
</dd>
<dt>tauMTT</dt><dd><p>Transit time through the balloon</p>
</dd>
<dt>tau</dt><dd><p>Viscoelastic time constant</p>
</dd>
<dt>alpha</dt><dd><p>Steady-state flow-volume relation</p>
</dd>
<dt>E0</dt><dd><p>baseline O2 extraction fraction</p>
</dd>
<dt>V0</dt><dd><p>baseline blood volume</p>
</dd>
<dt>a1</dt><dd><p>weight for deoxyHb change</p>
</dd>
<dt>a2</dt><dd><p>weight for blood volume change</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="balloon_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, warnings are displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the provided stimulus boxcar function, a neural activation function is generated that enters the Balloon model to generate a BOLD response. 
The microtime resolution ensures a high-precision generation of the response. More details can be found in Buxton et al. (2004).</p>


<h3>Value</h3>

<p>Vector representing the values of the BOLD signal for the given stimulus vector and microtime resolution.</p>


<h3>Author(s)</h3>

<p>G. Verdoolaege, M. Welvaert
</p>


<h3>References</h3>

<p>Buxton, RB, Uludag, K, Dubowitz, DJ and Liu, TT (2004). Modeling the hemodynamic response to brain activation. NeuroImage, 23, S220-S233.</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonicalHRF">canonicalHRF</a></code>, <code><a href="#topic+gammaHRF">gammaHRF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- rep(rep(0,10), rep(1,10), 5)
T &lt;- 100
it &lt;- 0.1
out &lt;- balloon(s, T, it) 
#takes a couple of seconds due to solving of the differential equations

</code></pre>

<hr>
<h2 id='canonicalHRF'>Double-gamma Haemodynamic reponse function</h2><span id='topic+canonicalHRF'></span>

<h3>Description</h3>

<p>Specifies a double-gamma variate haemodynamic response function for the given time vector and parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  canonicalHRF(x, param = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonicalHRF_+3A_x">x</code></td>
<td>
<p>Time vector in seconds.</p>
</td></tr>
<tr><td><code id="canonicalHRF_+3A_param">param</code></td>
<td>
<p>List of parameters of the haemodynamic response function. The list should contain the following:
</p>

<dl>
<dt>a1</dt><dd><p>Delay of response relative to onset (default: 6)</p>
</dd>
<dt>a2</dt><dd><p>Delay of undershoot relative to onset (default:12)</p>
</dd>
<dt>b1</dt><dd><p>Dispersion of response (default:0.9)</p>
</dd>
<dt>b2</dt><dd><p>Dispersion of undershoot (default:0.9)</p>
</dd>
<dt>c</dt><dd><p>Scale of undershoot (default:0.35)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="canonicalHRF_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, warnings are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector representing the values of the function for the given time vector and parameters.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>References</h3>

<p>[1] Friston, KJ, Fletcher, P, Josephs, O, Holmes, AP, Rugg, MD and Turner, R (1998). Event-related fMRI: Characterising differential responses. NeuroImage, 7, 30-40.
</p>
<p>[2] Glover, GH (1999). Deconvolution of impulse response in event-related BOLD fMRI. NeuroImage, 9, 416-429.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammaHRF">gammaHRF</a></code>, <code><a href="#topic+balloon">balloon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- 1:100
out &lt;- canonicalHRF(t, verbose=FALSE)

</code></pre>

<hr>
<h2 id='gammaHRF'>Single Gamma Haemodynamic response function.</h2><span id='topic+gammaHRF'></span>

<h3>Description</h3>

<p>Specifies a Gamma variate haemodynamic response function for the given time vector and FWHM.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaHRF(x, FWHM = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaHRF_+3A_x">x</code></td>
<td>
<p>Time vector in seconds.</p>
</td></tr>
<tr><td><code id="gammaHRF_+3A_fwhm">FWHM</code></td>
<td>
<p>Full Width Half Maximum of the Gamma variate function.</p>
</td></tr>
<tr><td><code id="gammaHRF_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, warnings are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector representing the values of the function for the given time vector and FWHM.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>References</h3>

<p>Buxton, RB, Uludag, K, Dubowitz, DJ and Liu, TT (2004). Modeling the hemodynamic response to brain activation. NeuroImage, 23, S220-S233.</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonicalHRF">canonicalHRF</a></code>, <code><a href="#topic+balloon">balloon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- 1:100
out &lt;- gammaHRF(t, verbose=FALSE)

</code></pre>

<hr>
<h2 id='GaussSmoothKernel'>Calculates a discrete Gaussian smoothing kernel (adopted from <span class="pkg">AnalyzeFMRI</span>)</h2><span id='topic+GaussSmoothKernel'></span>

<h3>Description</h3>

<p>Calculates a simple, discrete Gaussian smoothing kernel of a specifice size given the covariance matrix of the Gaussian.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSmoothKernel(voxdim=c(1,1,1), ksize=5, sigma=diag(3,3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSmoothKernel_+3A_voxdim">voxdim</code></td>
<td>
<p>The dimensions of each voxel.</p>
</td></tr>
<tr><td><code id="GaussSmoothKernel_+3A_ksize">ksize</code></td>
<td>
<p>The size (in voxels) of the kernel with which to filter the independent field.</p>
</td></tr>
<tr><td><code id="GaussSmoothKernel_+3A_sigma">sigma</code></td>
<td>
<p>The covariance matrix of the Gaussian kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension (ksize,ksize,ksize) containing the smoothing kernel.</p>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sim.3D.GRF">Sim.3D.GRF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- GaussSmoothKernel(voxdim=c(1,1,1), ksize=5, sigma=diag(1,3))

</code></pre>

<hr>
<h2 id='lowfreqdrift'>Generate low frequency drift</h2><span id='topic+lowfreqdrift'></span>

<h3>Description</h3>

<p>Generates a low-frequency drift dataset with specified dimensions and frequency.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowfreqdrift(dim, freq = 128, nscan, TR, template, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowfreqdrift_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions of the image.</p>
</td></tr>
<tr><td><code id="lowfreqdrift_+3A_freq">freq</code></td>
<td>
<p>The frequency of the drift in seconds. </p>
</td></tr>
<tr><td><code id="lowfreqdrift_+3A_nscan">nscan</code></td>
<td>
<p>The number of scans in the dataset.</p>
</td></tr>
<tr><td><code id="lowfreqdrift_+3A_tr">TR</code></td>
<td>
<p>The repetition time in seconds.</p>
</td></tr>
<tr><td><code id="lowfreqdrift_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
<tr><td><code id="lowfreqdrift_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates low-frequency drift based on a basis set of cosine functions. The result is an array with specified dimensions
and frequency.</p>


<h3>Value</h3>

<p>An array containing the drift with dimensions specified in dim.</p>


<h3>Author(s)</h3>

<p>Y. Rosseel, M. Welvaert</p>


<h3>References</h3>

<p>Friston et al. (2007). Statistical Parametric Mapping: The analysis of functional brain images. Academic Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+temporalnoise">temporalnoise</a></code>, <code><a href="#topic+systemnoise">systemnoise</a></code>, <code><a href="#topic+physnoise">physnoise</a></code>, <code><a href="#topic+tasknoise">tasknoise</a></code>, <code><a href="#topic+spatialnoise">spatialnoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
freq &lt;- 80
nscan &lt;- 100
TR &lt;- 2
out &lt;- lowfreqdrift(d, freq, nscan, TR, verbose=FALSE)

</code></pre>

<hr>
<h2 id='physnoise'>Generate physiological noise</h2><span id='topic+physnoise'></span>

<h3>Description</h3>

<p>Generates a physiological noise dataset with specified dimensions and standard deviation. The physiological noise is defined as noise caused by heart beat and respiratory rate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>physnoise(dim, nscan, TR, sigma, freq.heart = 1.17, 
	freq.resp = 0.2, template, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physnoise_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions of the image.</p>
</td></tr>
<tr><td><code id="physnoise_+3A_nscan">nscan</code></td>
<td>
<p>The number of scans in the dataset.</p>
</td></tr>
<tr><td><code id="physnoise_+3A_tr">TR</code></td>
<td>
<p>The repetition time in seconds.</p>
</td></tr>
<tr><td><code id="physnoise_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="physnoise_+3A_freq.heart">freq.heart</code></td>
<td>
<p>The frequency in Hz of the heart beat. </p>
</td></tr>
<tr><td><code id="physnoise_+3A_freq.resp">freq.resp</code></td>
<td>
<p>The frequency in Hz of the respiratory rate. </p>
</td></tr>
<tr><td><code id="physnoise_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
<tr><td><code id="physnoise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates physiological noise. Heart beat and respiratory rate are defined as sine and cosine functions with specified frequencies. Additional Gaussian noise creates variability over voxels. The result is a noise dataset with specified dimensions and desired standard deviation.</p>


<h3>Value</h3>

<p>An array containing the noise with dimensions specified in dim and nscan.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+temporalnoise">temporalnoise</a></code>, <code><a href="#topic+lowfreqdrift">lowfreqdrift</a></code>, <code><a href="#topic+systemnoise">systemnoise</a></code>, <code><a href="#topic+tasknoise">tasknoise</a></code>, <code><a href="#topic+spatialnoise">spatialnoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
sigma &lt;- 5
nscan &lt;- 100
TR &lt;- 2
out &lt;- physnoise(d, nscan, TR, sigma, verbose=FALSE)

</code></pre>

<hr>
<h2 id='rrice'>The Rice Distribution</h2><span id='topic+rrice'></span>

<h3>Description</h3>

<p>Density and random generation for the Rician distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrice(n, vee, sigma) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrice_+3A_n">n</code></td>
<td>
<p>number of observations. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="rrice_+3A_vee">vee</code></td>
<td>
<p>non-centrality parameter of the distribution. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="rrice_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter of the distribution. Must be a positive integer of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <span class="pkg">VGAM</span> for more details on the parameters and the formula of the probability density function.</p>


<h3>Value</h3>

<p>Random deviates for the given number of observations.</p>


<h3>Author(s)</h3>

<p>T.W. Yee</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rrice(n=10,vee=2,sigma=1)
</code></pre>

<hr>
<h2 id='Sim.3D.GRF'>Simulate a GRF (adopted from <span class="pkg">AnalyzeFMRI</span>)</h2><span id='topic+Sim.3D.GRF'></span>

<h3>Description</h3>

<p>Simulates a Gaussian Random Field with specified dimensions and covariance structure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sim.3D.GRF(d, voxdim, sigma, ksize, mask=NULL, type=c("field","max"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sim.3D.GRF_+3A_d">d</code></td>
<td>
<p>A vector specifying the dimensions of a 3D or 4D array.</p>
</td></tr>
<tr><td><code id="Sim.3D.GRF_+3A_voxdim">voxdim</code></td>
<td>
<p>The dimensions of each voxel.</p>
</td></tr>
<tr><td><code id="Sim.3D.GRF_+3A_sigma">sigma</code></td>
<td>
<p>The 3D covariance matrix of the field.</p>
</td></tr>
<tr><td><code id="Sim.3D.GRF_+3A_ksize">ksize</code></td>
<td>
<p>The size (in voxels) of the kernel with which to filter the independent field.</p>
</td></tr>
<tr><td><code id="Sim.3D.GRF_+3A_mask">mask</code></td>
<td>
<p>A 3D mask for the field.</p>
</td></tr>
<tr><td><code id="Sim.3D.GRF_+3A_type">type</code></td>
<td>
<p>If <code>type=="field"</code> then the simulated field together with the maximum of the field is returned.If <code>type=="max"</code> then the maximum of the field is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating a Gaussian r.v at each voxel location and the smoothing the field with a discrete filter to obtain a field with the desired covariance structure.</p>


<h3>Value</h3>

<table>
<tr><td><code>mat</code></td>
<td>
<p>Contains the simulated field if <code>type=="field"</code>, else <code>NULL</code></p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>The maximum value of the simulated field</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussSmoothKernel">GaussSmoothKernel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>     d &lt;- c(64, 64, 21)
     FWHM &lt;- 9
     sigma &lt;- diag(FWHM^2, 3) / (8 * log(2))
     voxdim &lt;- c(2, 2, 4)
     msk &lt;- array(1, dim = d)   
     field &lt;- Sim.3D.GRF(d = d, voxdim = voxdim, sigma = sigma, 
		ksize = 9, mask = msk, type = "max")

</code></pre>

<hr>
<h2 id='simprepSpatial'>Prepare spatial structure of the data</h2><span id='topic+simprepSpatial'></span>

<h3>Description</h3>

<p>Prepare a list defining the necessary parameters to specify the spatial structure of the activation data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simprepSpatial(regions, coord, radius = NULL, 
	form = c("cube", "sphere", "manual"), fading = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simprepSpatial_+3A_regions">regions</code></td>
<td>
<p>Number of activated regions.</p>
</td></tr>
<tr><td><code id="simprepSpatial_+3A_coord">coord</code></td>
<td>
<p>List of coordinates specifying the xyz-coordinates.</p>
</td></tr>
<tr><td><code id="simprepSpatial_+3A_radius">radius</code></td>
<td>
<p>If form=cube or sphere, the distance between the center and the edge, if form=manual, the number of voxels in each region.</p>
</td></tr>
<tr><td><code id="simprepSpatial_+3A_form">form</code></td>
<td>
<p>The form of the activated regions.</p>
</td></tr>
<tr><td><code id="simprepSpatial_+3A_fading">fading</code></td>
<td>
<p>Decay rate between 0 and 1. 0 means no fading, while 1 results in the fastest decay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the necessary arguments to be used in <code><a href="#topic+simVOLfmri">simVOLfmri</a></code>.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+simVOLfmri">simVOLfmri</a></code>, <code><a href="#topic+simprepTemporal">simprepTemporal</a></code>, <code><a href="#topic+specifyregion">specifyregion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- list(c(3,3,3),c(6,6,6))
radius &lt;- c(1,2)
out &lt;- simprepSpatial(2, coord, radius, form="cube", fading=0.2)

</code></pre>

<hr>
<h2 id='simprepTemporal'>Prepare temporal structure of the data</h2><span id='topic+simprepTemporal'></span>

<h3>Description</h3>

<p>Prepare a list defining the necessary parameters to specify the temporal structure of the activation data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simprepTemporal(totaltime, regions = NULL, onsets, durations, 
	TR, effectsize, accuracy=0.1, 
	hrf = c("gamma", "double-gamma", "Balloon"), 
	param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simprepTemporal_+3A_totaltime">totaltime</code></td>
<td>
<p>Duration of the experiment.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_regions">regions</code></td>
<td>
<p>Number of regions. If not specified, it is assumed that all regions have the same design matrix.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_onsets">onsets</code></td>
<td>
<p>List or vector representing the onsets of the stimulus in seconds.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_durations">durations</code></td>
<td>
<p>List or vector representing the durations of the stimulus in seconds.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_tr">TR</code></td>
<td>
<p>Repetition time in seconds.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_effectsize">effectsize</code></td>
<td>
<p>List or number representing the effectsize in each condition.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_accuracy">accuracy</code></td>
<td>
<p>Microtime resolution in seconds.</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_hrf">hrf</code></td>
<td>
<p>Haemodynamic response function (double-gamma is default)</p>
</td></tr>
<tr><td><code id="simprepTemporal_+3A_param">param</code></td>
<td>
<p>Vector, matrix or array representing the parameters of the haemodynamic response function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the necessary arguments to be used in <code><a href="#topic+simVOLfmri">simVOLfmri</a></code> or <code><a href="#topic+simTSfmri">simTSfmri</a></code>.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+simVOLfmri">simVOLfmri</a></code>, <code><a href="#topic+simTSfmri">simTSfmri</a></code>, <code><a href="#topic+simprepSpatial">simprepSpatial</a></code>, <code><a href="#topic+specifyregion">specifyregion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ncond &lt;- 2
os &lt;- list(c(20,60),c(15,35))
d &lt;- list(20, 10)
effect &lt;- list(7,10)
total &lt;- 80
TR &lt;- 2
out &lt;- simprepTemporal(total, onsets=os, durations=d, TR=TR, 
	effectsize=effect, hrf="double-gamma")

</code></pre>

<hr>
<h2 id='simTSfmri'>Simulate fMRI time series</h2><span id='topic+simTSfmri'></span>

<h3>Description</h3>

<p>Simulates an fMRI time series for the specified design and noise type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTSfmri(design = list(), base=0, nscan = NULL, TR = NULL, SNR=NULL,
	 noise = c("none", "white", "temporal", "low-frequency", 
	"physiological", "task-related", "mixture"), type = c("gaussian", "rician"),
	 weights, verbose = TRUE, rho = 0.2, freq.low = 128, freq.heart = 1.17, 
	freq.resp = 0.2, vee=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTSfmri_+3A_design">design</code></td>
<td>
<p>List generated by <code><a href="#topic+simprepTemporal">simprepTemporal</a></code> specifying the design. If not specified, noise time series are generated.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_base">base</code></td>
<td>
<p>Baseline value of the time series.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_nscan">nscan</code></td>
<td>
<p>Number of scans.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_tr">TR</code></td>
<td>
<p>Repetition time in seconds.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_snr">SNR</code></td>
<td>
<p>Signal-to-noise ratio of the time series.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_noise">noise</code></td>
<td>
<p>Type of noise (white is default).</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_type">type</code></td>
<td>
<p>If <code>noise==white</code>, <code>noise==task-related</code> or <code>noise==mixture</code>, type of system noise (gaussian is default).</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_weights">weights</code></td>
<td>
<p>If <code>noise==mixture</code>, vector of weights with 5 elements to specify the fraction of the noise components.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be returned.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_rho">rho</code></td>
<td>
<p>If <code>noise==temporal</code> or <code>noise==mixture</code>, value of autocorrelation coefficients. The length of the vector indicates the order of the autoregressive model.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_freq.low">freq.low</code></td>
<td>
<p>If <code>noise==low-frequency</code> or <code>noise==mixture</code>, frequency of the low-frequency drift in seconds.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_freq.heart">freq.heart</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of heart rate in Hz.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_freq.resp">freq.resp</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of respiratory rate in Hz.</p>
</td></tr>
<tr><td><code id="simTSfmri_+3A_vee">vee</code></td>
<td>
<p>If <code>type=="rician"</code>, non-centrality parameter of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the fMRI time series.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+simVOLfmri">simVOLfmri</a></code>, <code><a href="#topic+simprepTemporal">simprepTemporal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- simprepTemporal(totaltime=200, onsets=seq(1,200,40), 
	durations=20, effectsize=1, TR=2, hrf="double-gamma")
ts &lt;- simTSfmri(design=design, SNR=1, noise="white")
plot(ts, type="l")

</code></pre>

<hr>
<h2 id='simTSrestingstate'>Simulate fMRI resting state time series</h2><span id='topic+simTSrestingstate'></span>

<h3>Description</h3>

<p>Synthesizes a single time series x representing resting state activity. The fluctuation frequencies f are limited to 
a square passband 0.01 Hz &lt;= f &lt;= 0.1 Hz. TR is the repetition time (needed to compute the passband limits), expressed in seconds. 
N is the required number of samples (needs not be a power of 2).</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTSrestingstate(nscan, base=0, TR, SNR=NULL, noise = c("none", "white",
	"temporal", "low-frequency", "physiological", "mixture"), 
	type = c("gaussian", "rician"), weights, verbose = TRUE, rho = 0.2,
	freq.low = 128, freq.heart = 1.17, freq.resp = 0.2, vee=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTSrestingstate_+3A_nscan">nscan</code></td>
<td>
<p>Number of scans.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_base">base</code></td>
<td>
<p>Baseline value of the time series.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_tr">TR</code></td>
<td>
<p>Repetition time in seconds.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_snr">SNR</code></td>
<td>
<p>Signal-to-noise ratio of the time series.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_noise">noise</code></td>
<td>
<p>Type of noise (white is default).</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_type">type</code></td>
<td>
<p>If <code>noise==white</code>, <code>noise==mixture</code>, type of system noise (gaussian is default).</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_weights">weights</code></td>
<td>
<p>If <code>noise==mixture</code>, vector of weights to specify the fraction of the noise components.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be returned.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_rho">rho</code></td>
<td>
<p>If <code>noise==temporal</code> or <code>noise==mixture</code>, value of autocorrelation coefficients. The length of the vector corresponds to the order of the autoregressive model.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_freq.low">freq.low</code></td>
<td>
<p>If <code>noise==low-frequency</code> or <code>noise==mixture</code>, frequency of the low-frequency drift in seconds.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_freq.heart">freq.heart</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of heart rate in Hz.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_freq.resp">freq.resp</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of respiratory rate in Hz.</p>
</td></tr>
<tr><td><code id="simTSrestingstate_+3A_vee">vee</code></td>
<td>
<p>If <code>type==rician</code>, non-centrality parameter of the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the resting state time series</p>


<h3>Author(s)</h3>

<p>J. Durnez, G. Verdoolaege, M. Welvaert</p>


<h3>References</h3>

<p>[1] C.G. Fox, Computers &amp; Geoscience, Vol. 13, pp. 369-374, 1987.
</p>
<p>[2] M. Fukunaga, Magnetic Resonance Imaging, Vol. 24, pp. 979-992, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simTSfmri">simTSfmri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- simTSrestingstate(nscan=50, TR=2, SNR=1, noise="none")
plot(out, type="l")

</code></pre>

<hr>
<h2 id='simVOLfmri'>Simulate 3D or 4D fMRI data</h2><span id='topic+simVOLfmri'></span>

<h3>Description</h3>

<p>Simulates a 3D or 4D fMRI dataset for the specified design and with activation in the specified regions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simVOLfmri(design = list(), image = list(), base=0, dim, nscan = NULL,
	TR = NULL, SNR=NULL, noise = c("none", "white", "temporal", 
	"spatial", "low-frequency", "physiological", "task-related", 
	"mixture"), type = c("gaussian", "rician"), 
	spat = c("corr", "gaussRF", "gammaRF"), weights, verbose = TRUE, 
	rho.temp = 0.2, rho.spat = 0.75, freq.low = 128, 
	freq.heart = 1.17, freq.resp = 0.2, FWHM = 4, gamma.shape = 6, 
	gamma.rate = 1, vee=1, template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simVOLfmri_+3A_design">design</code></td>
<td>
<p>List generated by <code><a href="#topic+simprepTemporal">simprepTemporal</a></code> specifying the design. If not specified, noise images are generated.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_image">image</code></td>
<td>
<p>List generated by <code><a href="#topic+simprepSpatial">simprepSpatial</a></code> specifying the activated regions. If not specified, noise images are generated</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_base">base</code></td>
<td>
<p>Baseline of the data. Should be a single number or an array with the same dimensions as in <code>dim</code>.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_dim">dim</code></td>
<td>
<p>Dimensions of the image space.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_nscan">nscan</code></td>
<td>
<p>Number of scans for noise images.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_tr">TR</code></td>
<td>
<p>Repetition time for noise images.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_snr">SNR</code></td>
<td>
<p>Signal-to-noise ratio.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_noise">noise</code></td>
<td>
<p>Type of noise, default is white.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_type">type</code></td>
<td>
<p>If <code>noise==white</code> or <code>noise==mixture</code>, the type of system noise (default is gaussian).</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_spat">spat</code></td>
<td>
<p>If <code>noise==spatial</code> or <code>noise==mixture</code>, the spatial correlation structure (default is <code>corr</code>).</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_weights">weights</code></td>
<td>
<p>If <code>noise==mixture</code>, weights vector of six elements.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warning should be printed.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_rho.temp">rho.temp</code></td>
<td>
<p>If <code>noise==temporal</code> or <code>noise==mixture</code>, value of autocorrelation coefficients. The length of the vector indicates the order of the autoregressive model.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_rho.spat">rho.spat</code></td>
<td>
<p>If <code>noise==spatial</code> or <code>noise==mixture</code>, and <code>spat==corr</code>, value of the correlation coefficient.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_freq.low">freq.low</code></td>
<td>
<p>If <code>noise==low-frequency</code> or <code>noise==mixture</code>, frequency of the low-frequency drift in seconds.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_freq.heart">freq.heart</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of heart rate in Hz.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_freq.resp">freq.resp</code></td>
<td>
<p>If <code>noise==physiological</code> or <code>noise==mixture</code>, frequency of respiratory rate in Hz.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_fwhm">FWHM</code></td>
<td>
<p>If <code>noise==spatial</code> or <code>noise==mixture</code>, and <code>spat==gaussRF</code> or <code>spat==gammaRF</code>, value of the FWHM of the Gaussian kernel.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_gamma.shape">gamma.shape</code></td>
<td>
<p>If <code>noise==spatial</code> or <code>noise==mixture</code>, and <code>spat==gammaRF</code>, value of the shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_gamma.rate">gamma.rate</code></td>
<td>
<p>If <code>noise==spatial</code> or <code>noise==mixture</code>, and <code>spat==gammaRF</code>, value of the rate parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_vee">vee</code></td>
<td>
<p>If <code>type==rician</code>, non-centrality parameter of the rician distribution.</p>
</td></tr>
<tr><td><code id="simVOLfmri_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D or 4D array specifying the values for each voxel in the data.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+simTSfmri">simTSfmri</a></code>, <code><a href="#topic+simprepTemporal">simprepTemporal</a></code>, <code><a href="#topic+simprepSpatial">simprepSpatial</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>design &lt;- simprepTemporal(totaltime=200, onsets=seq(1,200,40), 
	durations=20, TR=2, effectsize=1, hrf="double-gamma")
region &lt;- simprepSpatial(regions=2, coord=list(c(32,15),c(57,45)), 
	radius=c(10,7), form="sphere", fading=TRUE)
out &lt;- simVOLfmri(design=design, image=region, dim=c(64,64), 
	SNR=1, noise="none")
plot(out[32,15,], type="l")
image(1:64, 1:64, out[,,10], col = grey(0:255/255))

</code></pre>

<hr>
<h2 id='spatialnoise'>Generate spatially correlated noise</h2><span id='topic+spatialnoise'></span>

<h3>Description</h3>

<p>Generates a spatially correlated noise dataset with specified dimensions and standard deviation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialnoise(dim, sigma, nscan, method = c("corr", "gammaRF", "gaussRF"), 
	type=c("gaussian","rician"), rho = 0.75, FWHM = 4, gamma.shape = 6, 
	gamma.rate = 1, vee=1, template, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialnoise_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions of the image.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_nscan">nscan</code></td>
<td>
<p>The number of scans in the dataset.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_method">method</code></td>
<td>
<p>Method specifying the type of spatial correlation. Default is <code>"corr"</code>.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_type">type</code></td>
<td>
<p>Type of distribution if <code>method=="corr"</code>. Default is <code>"gaussian"</code></p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_rho">rho</code></td>
<td>
<p>If <code>method=="corr"</code>, the value of the autocorrelation coefficient. </p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_fwhm">FWHM</code></td>
<td>
<p>If <code>method=="gammaRF"</code> or <code>method=="gaussRF"</code>, the full-width-half-maximum of the Gaussian kernel.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_gamma.shape">gamma.shape</code></td>
<td>
<p>If <code>method=="gammaRF"</code>, the shape parameter of the Gamma distribution.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_gamma.rate">gamma.rate</code></td>
<td>
<p>If <code>method=="gammaRF"</code>, the shape parameter of the Gamma distribution.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_vee">vee</code></td>
<td>
<p>If <code>method=="corr"</code> and <code>type=="rician"</code>, the non-centrality parameter of the rician distribution.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
<tr><td><code id="spatialnoise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates spatially correlated noise. When <code>method=="corr"</code>, AR(1) voxelwise correlations are introduced. 
If <code>method=="gaussRF"</code> of <code>method=="gammaRF"</code>, respectively a Gaussian Random Field or a Gamma Random Field is created. The result is a noise array with specified dimensions and desired standard deviation.
The generation of the random fields is based on the function <code>Sim.3D.GRF</code> from J.L. Marchini in the package <span class="pkg">AnalyzeFMRI</span>.</p>


<h3>Value</h3>

<p>An array containing the noise with dimensions specified in dim and nscan.</p>


<h3>Author(s)</h3>

<p>J. Durnez, B. Moerkerke, M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+temporalnoise">temporalnoise</a></code>, <code><a href="#topic+lowfreqdrift">lowfreqdrift</a></code>, <code><a href="#topic+physnoise">physnoise</a></code>, <code><a href="#topic+tasknoise">tasknoise</a></code>, <code><a href="#topic+systemnoise">systemnoise</a></code>, <code><a href="#topic+Sim.3D.GRF">Sim.3D.GRF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
sigma &lt;- 5
nscan &lt;- 100
rhospat &lt;- 0.7
out &lt;- spatialnoise(d, sigma, nscan, method="corr", rho=rhospat, verbose=FALSE)

</code></pre>

<hr>
<h2 id='specifydesign'>Generate design matrix.</h2><span id='topic+specifydesign'></span>

<h3>Description</h3>

<p>Generates a design matrix to be used as a model for the simulated activation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>specifydesign(onsets, durations, totaltime, TR, effectsize, accuracy=0.1, 
	conv = c("none", "gamma", "double-gamma", "Balloon"), 
	cond.names = NULL, param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specifydesign_+3A_onsets">onsets</code></td>
<td>
<p>List or vector representing the onsets in seconds.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_durations">durations</code></td>
<td>
<p>List or vector representing the durations in seconds.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_totaltime">totaltime</code></td>
<td>
<p>Duration of the experiment in seconds.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_tr">TR</code></td>
<td>
<p>Repetition time in seconds.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_effectsize">effectsize</code></td>
<td>
<p>List or number representing the effectsize in each condition.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_accuracy">accuracy</code></td>
<td>
<p>Microtime resolution in seconds.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_conv">conv</code></td>
<td>
<p>Should the design matrix be convoluted, default is none.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_cond.names">cond.names</code></td>
<td>
<p>Optional names for the conditions.</p>
</td></tr>
<tr><td><code id="specifydesign_+3A_param">param</code></td>
<td>
<p>Parameters of the haemodynamic response function. See <code><a href="#topic+gammaHRF">gammaHRF</a></code> and <code><a href="#topic+canonicalHRF">canonicalHRF</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix specifying the design.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+specifyregion">specifyregion</a></code>,<code><a href="#topic+gammaHRF">gammaHRF</a></code>,<code><a href="#topic+canonicalHRF">canonicalHRF</a></code>,<code><a href="#topic+balloon">balloon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>os &lt;- list(c(20,60),c(15,35))
d &lt;- list(20, 10)
total &lt;- 80
TR &lt;- 2
out &lt;- specifydesign(os, d, total, TR, effectsize=list(2,5), conv="double-gamma")

</code></pre>

<hr>
<h2 id='specifyregion'>Generate activation image</h2><span id='topic+specifyregion'></span>

<h3>Description</h3>

<p>Generates an image with activated regions for specified dimensions. The regions are defined by their center and radius or can be entered manually.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  specifyregion(dim, coord, radius = NULL, 
	form = c("cube", "sphere", "manual"), 
	fading = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specifyregion_+3A_dim">dim</code></td>
<td>
<p>Dimensions of the image space.</p>
</td></tr>
<tr><td><code id="specifyregion_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the activated region, if <code>form=="cube"</code> or <code>form=="sphere"</code>, the coordinates represent the center of the region, if <code>form=="manual"</code>, the coordinates should be in matrix form, where the rows represent the voxels and the columns the x-y-z coordinates.</p>
</td></tr>
<tr><td><code id="specifyregion_+3A_radius">radius</code></td>
<td>
<p>If <code>form=="cube"</code> or <code>form=="sphere"</code>, the distance in voxels from the center of the region to the edge.</p>
</td></tr>
<tr><td><code id="specifyregion_+3A_form">form</code></td>
<td>
<p>The form of the activated region. Default is <code>"cube"</code>.</p>
</td></tr>
<tr><td><code id="specifyregion_+3A_fading">fading</code></td>
<td>
<p>Decay rate between 0 and 1. 0 means no fading, while 1 results in the fastest decay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array representing the activation image with specified regions.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+specifyregion">specifyregion</a></code>,<code><a href="#topic+gammaHRF">gammaHRF</a></code>,<code><a href="#topic+canonicalHRF">canonicalHRF</a></code>,<code><a href="#topic+balloon">balloon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
coord &lt;- c(3,3,3)
radius &lt;- 1
out &lt;- specifyregion(d, coord, radius, form="sphere")

</code></pre>

<hr>
<h2 id='stimfunction'>Generate a stimulus boxcar function.
</h2><span id='topic+stimfunction'></span>

<h3>Description</h3>

<p>Generates a stimulus boxcar vector for the specified time duration and microtime resolution based on the user-defined onsets and durations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stimfunction(totaltime, onsets, durations, accuracy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stimfunction_+3A_totaltime">totaltime</code></td>
<td>
<p>Total time of the design in seconds.</p>
</td></tr>
<tr><td><code id="stimfunction_+3A_onsets">onsets</code></td>
<td>
<p>Vector representing the onsets of the stimulus in seconds.</p>
</td></tr>
<tr><td><code id="stimfunction_+3A_durations">durations</code></td>
<td>
<p>Vector representing the durations of the stimulus in seconds.</p>
</td></tr>
<tr><td><code id="stimfunction_+3A_accuracy">accuracy</code></td>
<td>
<p>Microtime resolution in seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If duration is a single number, it is assumed that all stimulus onsets have the same duration.</p>


<h3>Value</h3>

<p>A vector in microtime resolution specifying the stimulus boxcar function in 1-0 coding.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+specifydesign">specifydesign</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>total &lt;- 100
os &lt;- c(1, 21, 41, 61, 81)
d &lt;- 10
out &lt;- stimfunction(total, os, d, 0.1)

</code></pre>

<hr>
<h2 id='systemnoise'>Generate system noise</h2><span id='topic+systemnoise'></span>

<h3>Description</h3>

<p>Generates a system noise dataset with specified dimensions and standard deviation. The noise can be either Gaussian or Rician distributed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>systemnoise(dim, nscan, type=c("gaussian","rician"), sigma, vee, template, 
		verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="systemnoise_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions of the image.</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_nscan">nscan</code></td>
<td>
<p>The number of scans in the dataset.</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_type">type</code></td>
<td>
<p>Distribution of system noise. Default is gaussian.</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_vee">vee</code></td>
<td>
<p>If <code>type=="rician"</code>, the non-centrality parameter of the distribution .</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
<tr><td><code id="systemnoise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the noise with dimensions specified in dim and nscan.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+temporalnoise">temporalnoise</a></code>, <code><a href="#topic+lowfreqdrift">lowfreqdrift</a></code>, <code><a href="#topic+physnoise">physnoise</a></code>, <code><a href="#topic+tasknoise">tasknoise</a></code>, <code><a href="#topic+spatialnoise">spatialnoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
sigma &lt;- 5
nscan &lt;- 100
out &lt;- systemnoise(d, nscan, type="rician", sigma, verbose=FALSE)

</code></pre>

<hr>
<h2 id='tasknoise'>Generate task-related noise</h2><span id='topic+tasknoise'></span>

<h3>Description</h3>

<p>Generates a Gaussian noise dataset with specified dimensions and standard deviation only when a task is performed or activation is present.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasknoise(act.image, sigma, type=c("gaussian","rician"), vee=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tasknoise_+3A_act.image">act.image</code></td>
<td>
<p>Array defining where and when activation is present.</p>
</td></tr>
<tr><td><code id="tasknoise_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="tasknoise_+3A_type">type</code></td>
<td>
<p>Distribution of task-related noise. Default is gaussian.</p>
</td></tr>
<tr><td><code id="tasknoise_+3A_vee">vee</code></td>
<td>
<p>If <code>type=="rician"</code>, the non-centrality parameter of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates random Gaussian noise for those voxels in the dataset that show activation. The result is a noise array with specified dimensions and desired standard deviation.</p>


<h3>Value</h3>

<p>An array containing the noise.</p>


<h3>Author(s)</h3>

<p>M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+temporalnoise">temporalnoise</a></code>, <code><a href="#topic+lowfreqdrift">lowfreqdrift</a></code>, <code><a href="#topic+physnoise">physnoise</a></code>, <code><a href="#topic+systemnoise">systemnoise</a></code>, <code><a href="#topic+spatialnoise">spatialnoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
sigma &lt;- 5
nscan &lt;- 100
act &lt;- array(rep(0, prod(d)*nscan), dim=c(d,nscan))
act[2:4,2:4,2:4,c(20:30,40:50,60:70)] &lt;- 1
out &lt;- tasknoise(act, sigma)

</code></pre>

<hr>
<h2 id='temporalnoise'>Generate temporally correlated noise</h2><span id='topic+temporalnoise'></span>

<h3>Description</h3>

<p>Generates an autoregressive noise dataset with specified dimensions and standard deviation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporalnoise(dim, nscan, sigma, rho = 0.2, template, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporalnoise_+3A_dim">dim</code></td>
<td>
<p>A vector specifying the dimensions of a 2D or 3D array.</p>
</td></tr>
<tr><td><code id="temporalnoise_+3A_nscan">nscan</code></td>
<td>
<p>The number of scans in the dataset.</p>
</td></tr>
<tr><td><code id="temporalnoise_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="temporalnoise_+3A_rho">rho</code></td>
<td>
<p>The autocorrelation coefficients. The length of the vector determines the order of the autoregressive model.</p>
</td></tr>
<tr><td><code id="temporalnoise_+3A_template">template</code></td>
<td>
<p>An array representing the anatomical structure or mask with dimensions equal to dim.</p>
</td></tr>
<tr><td><code id="temporalnoise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if warnings should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the noise with dimensions specified in dim.</p>


<h3>Author(s)</h3>

<p>J. Durnez, B. Moerkerke, M. Welvaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+systemnoise">systemnoise</a></code>, <code><a href="#topic+lowfreqdrift">lowfreqdrift</a></code>, <code><a href="#topic+physnoise">physnoise</a></code>, <code><a href="#topic+tasknoise">tasknoise</a></code>, <code><a href="#topic+spatialnoise">spatialnoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(10,10,10)
sigma &lt;- 5
nscan &lt;- 100
rho &lt;- c(0.3,-0.7)
out &lt;- temporalnoise(d, nscan, sigma, rho, verbose=FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
