<!DOCTYPE html><html lang="en"><head><title>Help for package hdqr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdqr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.cv.hdqr'><p>Extract Coefficients from a 'cv.hdqr' Object</p></a></li>
<li><a href='#coef.cv.nc.hdqr'><p>Extract Coefficients from a 'cv.nc.hdqr' Object</p></a></li>
<li><a href='#coef.hdqr'><p>Extract Model Coefficients from a 'hdqr' Object</p></a></li>
<li><a href='#coef.nc.hdqr'><p>Extract Model Coefficients from a 'nc.hdqr' Object</p></a></li>
<li><a href='#cv.hdqr'><p>Cross-validation for Selecting the Tuning Parameter in Penalized Quantile Regression</p></a></li>
<li><a href='#cv.nc.hdqr'><p>Cross-validation for Selecting the Tuning Parameter of Nonconvex Penalized Quantile Regression</p></a></li>
<li><a href='#hdqr'><p>Solve the linear quantile regression. The solution path is computed</p>
at a grid of values of tuning parameter <code>lambda</code>.</a></li>
<li><a href='#nc.hdqr'><p>Solve the Penalized Quantile Regression with Nonconvex Penalties</p></a></li>
<li><a href='#predict.cv.hdqr'><p>Make Predictions from a 'cv.hdqr' Object</p></a></li>
<li><a href='#predict.cv.nc.hdqr'><p>Make Predictions from a 'cv.nc.hdqr' Object</p></a></li>
<li><a href='#predict.hdqr'><p>Make Predictions from a 'hdqr' Object</p></a></li>
<li><a href='#predict.nc.hdqr'><p>Make Predictions from a 'nc.hdqr' Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Algorithm for Penalized Quantile Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qian Tang &lt;qian-tang@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an efficient algorithm to fit and tune penalized quantile regression models using the generalized coordinate descent algorithm. Designed to handle high-dimensional datasets effectively, with emphasis on precision and computational efficiency. This package implements the algorithms proposed in Tang, Q., Zhang, Y., &amp; Wang, B. (2022) <a href="https://openreview.net/pdf?id=RvwMTDYTOb">https://openreview.net/pdf?id=RvwMTDYTOb</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-05 21:24:58 UTC; qtang7</td>
</tr>
<tr>
<td>Author:</td>
<td>Qian Tang [aut, cre],
  Yikai Zhang [aut],
  Boxiang Wang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.cv.hdqr'>Extract Coefficients from a 'cv.hdqr' Object</h2><span id='topic+coef.cv.hdqr'></span>

<h3>Description</h3>

<p>Retrieves coefficients from a cross-validated 'hdqr()' model, using the
stored '&quot;hdqr.fit&quot;' object and the optimal 'lambda' value determined during
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.hdqr'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.hdqr_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.hdqr()' object from which coefficients are to be extracted.</p>
</td></tr>
<tr><td><code id="coef.cv.hdqr_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' for which coefficients are desired.
The default is 's = &quot;lambda.1se&quot;', which corresponds to the largest value of 'lambda' such that the
cross-validation error estimate is within one standard error of the minimum. Alternatively,
's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the cross-validation error estimate.
If 's' is numeric, these are taken as the actual values of 'lambda' to use.</p>
</td></tr>
<tr><td><code id="coef.cv.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coefficients at the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.hdqr">cv.hdqr</a></code>, <code><a href="#topic+predict.cv.hdqr">predict.cv.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
cv.fit &lt;- cv.hdqr(x = x, y = y, tau = tau, lam2 = lam2)
coef(cv.fit, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='coef.cv.nc.hdqr'>Extract Coefficients from a 'cv.nc.hdqr' Object</h2><span id='topic+coef.cv.nc.hdqr'></span>

<h3>Description</h3>

<p>Retrieves coefficients at specified values of 'lambda' from a fitted 'cv.nc.hdqr()' model.
Utilizes the stored '&quot;nchdqr.fit&quot;' object and the optimal 'lambda' values determined during
the cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.nc.hdqr'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.nc.hdqr_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.nc.hdqr()' object from which coefficients are to be extracted.</p>
</td></tr>
<tr><td><code id="coef.cv.nc.hdqr_+3A_s">s</code></td>
<td>
<p>Specifies the 'lambda' values at which coefficients are requested.
The default is 's = &quot;lambda.1se&quot;', representing the largest 'lambda' such that the cross-validation
error estimate is within one standard error of the minimum. Alternatively, 's = &quot;lambda.min&quot;'
corresponds to the 'lambda' yielding the minimum cross-validation error. If 's' is numeric, these
values are directly used as the 'lambda' values for coefficient extraction.</p>
</td></tr>
<tr><td><code id="coef.cv.nc.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or matrix of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.nc.hdqr">cv.nc.hdqr</a></code>, <code><a href="#topic+predict.cv.nc.hdqr">predict.cv.nc.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=30))
cv.nc.fit &lt;- cv.nc.hdqr(x = x, y = y, tau = tau, lambda = lambda, lam2 = lam2)
coef(cv.nc.fit, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='coef.hdqr'>Extract Model Coefficients from a 'hdqr' Object</h2><span id='topic+coef.hdqr'></span>

<h3>Description</h3>

<p>Retrieves the coefficients at specified values of 'lambda' from a fitted 'hdqr()' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdqr'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.hdqr_+3A_object">object</code></td>
<td>
<p>Fitted 'hdqr()' object.</p>
</td></tr>
<tr><td><code id="coef.hdqr_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which coefficients are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="coef.hdqr_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;coefficients&quot;' computes the coefficients at the requested 
values for 's'. Type '&quot;nonzero&quot;' returns a list of the indices of the nonzero coefficients for each 
value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="coef.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts coefficients for specified 'lambda' values from a 'hdqr()' object.
If 's', the vector of 'lambda' values, contains values not originally used in the model fitting,
the 'coef' function employs linear interpolation between the closest 'lambda' values from the 
original sequence to estimate coefficients at the new 'lambda' values.
</p>


<h3>Value</h3>

<p>Returns a matrix or vector of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdqr">hdqr</a></code>, <code><a href="#topic+predict.hdqr">predict.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
fit &lt;- hdqr(x = x, y = y, tau = tau, lam2 = lam2)
coefs &lt;- coef(fit, s = fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='coef.nc.hdqr'>Extract Model Coefficients from a 'nc.hdqr' Object</h2><span id='topic+coef.nc.hdqr'></span>

<h3>Description</h3>

<p>Retrieves the coefficients at specified values of 'lambda' from a fitted 'nc.hdqr()' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nc.hdqr'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.nc.hdqr_+3A_object">object</code></td>
<td>
<p>Fitted 'nc.hdqr()' object.</p>
</td></tr>
<tr><td><code id="coef.nc.hdqr_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which coefficients are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="coef.nc.hdqr_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;coefficients&quot;' computes the coefficients at the requested 
values for 's'. Type '&quot;nonzero&quot;' returns a list of the indices of the nonzero coefficients for each 
value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="coef.nc.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts coefficients for specified 'lambda' values from a 'nc.hdqr()' object.
If 's', the vector of 'lambda' values, contains values not originally used in the model fitting,
the 'coef' function employs linear interpolation between the closest 'lambda' values from the 
original sequence to estimate coefficients at the new 'lambda' values.
</p>


<h3>Value</h3>

<p>Returns a matrix or vector of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nc.hdqr">nc.hdqr</a></code>, <code><a href="#topic+predict.nc.hdqr">predict.nc.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=30))
nc.fit &lt;- nc.hdqr(x=x, y=y, tau=tau, lambda=lambda, lam2=lam2, pen="scad")
nc.coefs &lt;- coef(nc.fit, s = nc.fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='cv.hdqr'>Cross-validation for Selecting the Tuning Parameter in Penalized Quantile Regression</h2><span id='topic+cv.hdqr'></span>

<h3>Description</h3>

<p>Performs k-fold cross-validation for <code><a href="#topic+hdqr">hdqr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.hdqr(x, y, lambda = NULL, tau, nfolds = 5L, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.hdqr_+3A_x">x</code></td>
<td>
<p>A numerical matrix with <code class="reqn">n</code> rows (observations) and <code class="reqn">p</code> columns (variables).</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_y">y</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_lambda">lambda</code></td>
<td>
<p>Optional; a user-supplied sequence of <code>lambda</code> values. If <code>NULL</code>, 
<code><a href="#topic+hdqr">hdqr</a></code> selects its own sequence.</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_tau">tau</code></td>
<td>
<p>Quantile level (<code>tau</code>) used in the loss function.</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation. Defaults to 5.</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_foldid">foldid</code></td>
<td>
<p>Optional vector specifying the indices of observations in each fold.
If provided, it overrides <code>nfolds</code>.</p>
</td></tr>
<tr><td><code id="cv.hdqr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+hdqr">hdqr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the average cross-validation error and provides the standard error.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>cv.hdqr</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>Candidate <code>lambda</code> values.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>Mean cross-validation error.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>Standard error of the mean cross-validation error.</p>
</td></tr>
<tr><td><code>cvup</code></td>
<td>
<p>Upper confidence curve: <code>cvm</code> + <code>cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlo</code></td>
<td>
<p>Lower confidence curve: <code>cvm</code> - <code>cvsd</code>.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p><code>lambda</code> achieving the minimum cross-validation error.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>Largest <code>lambda</code> within one standard error of the minimum error.</p>
</td></tr>
<tr><td><code>cv.min</code></td>
<td>
<p>Cross-validation error at <code>lambda.min</code>.</p>
</td></tr>
<tr><td><code>cv.1se</code></td>
<td>
<p>Cross-validation error at <code>lambda.1se</code>.</p>
</td></tr>
<tr><td><code>hdqr.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+hdqr">hdqr</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>Number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
cv.fit &lt;- cv.hdqr(x = x, y = y, tau = tau)
</code></pre>

<hr>
<h2 id='cv.nc.hdqr'>Cross-validation for Selecting the Tuning Parameter of Nonconvex Penalized Quantile Regression</h2><span id='topic+cv.nc.hdqr'></span>

<h3>Description</h3>

<p>Conducts k-fold cross-validation for the 'nc.hdqr()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.nc.hdqr(x, y, lambda = NULL, tau, nfolds = 5L, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.nc.hdqr_+3A_x">x</code></td>
<td>
<p>A numerical matrix with dimensions (<code class="reqn">n</code> rows and <code class="reqn">p</code> columns), where each row represents an observation.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_y">y</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied sequence of <code>lambda</code> values.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_tau">tau</code></td>
<td>
<p>The quantile level (<code>tau</code>) used in the error calculation. Default value is typically 0.5 unless specified.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds in the cross-validation, default is 5.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector that assigns each observation to a specific fold. 
If provided, this parameter overrides <code>nfolds</code>.</p>
</td></tr>
<tr><td><code id="cv.nc.hdqr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+nc.hdqr">nc.hdqr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the average cross-validation error and its standard error across folds. It is primarily used to 
identify the optimal <code>lambda</code> value for fitting nonconvex penalized quantile regression models.
</p>


<h3>Value</h3>

<p>An object of class <code>cv.nc.hdqr</code> is returned,
which is a list with the ingredients of the cross-validated fit.
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean cross-validated error - a vector of length <code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting purposes).</p>
</td></tr>
<tr><td><code>nchdqr.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+nc.hdqr">nc.hdqr</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives minimum cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=10))
cv.nc.fit &lt;- cv.nc.hdqr(y=y, x=x, tau=tau, lambda=lambda, lam2=lam2, pen="scad")
</code></pre>

<hr>
<h2 id='hdqr'>Solve the linear quantile regression. The solution path is computed
at a grid of values of tuning parameter <code>lambda</code>.</h2><span id='topic+hdqr'></span>

<h3>Description</h3>

<p>Solve the linear quantile regression. The solution path is computed
at a grid of values of tuning parameter <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdqr(
  x,
  y,
  tau,
  nlambda = 100,
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lam2 = 0.01,
  hval = 0.125,
  pf = rep(1, nvars),
  pf2 = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = TRUE,
  eps = 1e-08,
  maxit = 1e+06,
  sigma = 0.05,
  is_exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdqr_+3A_x">x</code></td>
<td>
<p>Matrix of predictors, of dimension (nobs * nvars);
each row is an observation.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_y">y</code></td>
<td>
<p>Response variable. The length is <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_tau">tau</code></td>
<td>
<p>The quantile level <code class="reqn">\tau</code>. The value must be
in (0,1). Default is 0.5.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values (default is 100).</p>
</td></tr>
<tr><td><code id="hdqr_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal value
in the <code>lambda</code> sequence, where
<code>min(lambda)</code> = <code>lambda.factor</code> * <code>max(lambda)</code>
and <code>max(lambda)</code> is the smallest value of <code>lambda</code>
for which all coefficients (except the intercept when it is present)
are penalized to zero. The default depends on the relationship
between <code class="reqn">n</code> (the number of rows in the design matrix) and
<code class="reqn">p</code> (the number of predictors). If <code class="reqn">n &lt; p</code>, it defaults to
<code>0.05</code>. If <code class="reqn">n &gt; p</code>, the default is <code>0.001</code>,
closer to zero.  A very small value of <code>lambda.factor</code> will
lead to a saturated fit. The argument takes no effect if there is a
user-supplied <code>lambda</code> sequence.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_lambda">lambda</code></td>
<td>
<p>A user-supplied <code>lambda</code> sequence. Typically,
by leaving this option unspecified, users can have the program
compute its own <code>lambda</code> sequence based on <code>nlambda</code>
and <code>lambda.factor</code>. It is better to supply, if necessary,
a decreasing sequence of <code>lambda</code> values than a single
(small) value. The program will ensure that the user-supplied
<code>lambda</code> sequence is sorted in decreasing order before
fitting the model to take advanage of the warm-start technique.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_lam2">lam2</code></td>
<td>
<p>Regularization parameter <code>lambda2</code> for the
quadratic penalty of the coefficients. Unlike <code>lambda</code>,
only one value of <code>lambda2</code> is used for each fitting process.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_hval">hval</code></td>
<td>
<p>The smoothing index for <code>method='huber'</code>. Default is 0.125.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_pf">pf</code></td>
<td>
<p>L1 penalty factor of length <code class="reqn">p</code> used for the adaptive
LASSO or adaptive elastic net. Separate L1 penalty weights can be
applied to each coefficient to allow different L1 shrinkage.
Can be 0 for some variables (but not all), which imposes no
shrinkage, and results in that variable always being included
in the model. Default is 1 for all variables (and implicitly
infinity for variables in the <code>exclude</code> list).</p>
</td></tr>
<tr><td><code id="hdqr_+3A_pf2">pf2</code></td>
<td>
<p>L2 penalty factor of length <code class="reqn">p</code> used for adaptive
elastic net. Separate L2 penalty weights can be applied to
each coefficient to allow different L2 shrinkage.
Can be 0 for some variables, which imposes no shrinkage.
Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model.
Default is none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_dfmax">dfmax</code></td>
<td>
<p>The maximum number of variables allowed in the model.
Useful for very large <code class="reqn">p</code> when a partial path is desired.
Default is <code class="reqn">p+1</code>.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_pmax">pmax</code></td>
<td>
<p>The maximum number of coefficients allowed ever
to be nonzero along the solution path. For example, once
<code class="reqn">\beta</code> enters the model, no matter how many times it
exits or re-enters the model through the path, it will be
counted only once. Default is <code>min(dfmax*1.2, p)</code>.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization,
prior to fitting the model sequence. The coefficients are
always returned to the original scale. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_eps">eps</code></td>
<td>
<p>Stopping criterion.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterates.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_sigma">sigma</code></td>
<td>
<p>Penalty parameter appearing in the quadratic term
of the augmented Lagrangian function. Must be positive.</p>
</td></tr>
<tr><td><code id="hdqr_+3A_is_exact">is_exact</code></td>
<td>
<p>Exact or approximated solutions. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the objective function in the penalized quantile
regression is
</p>
<p style="text-align: center;"><code class="reqn">1'\rho_{\tau}(y-X\beta-b_0))/N + \lambda_1\cdot|pf_1\circ\beta|_1 +
    0.5*\lambda_2\cdot|\sqrt{pf_2}\circ\beta|^2,</code>
</p>

<p>where <code class="reqn">\rho_{\tau}</code> the quantile or check loss
and the penalty is a combination of weighted L1 and L2 terms and
<code class="reqn">\circ</code> denotes the Hadmamard product.
</p>
<p>For faster computation, if the algorithm is not converging or
running slow, consider increasing <code>eps</code>, increasing
<code>sigma</code>, decreasing <code>nlambda</code>, or increasing
<code>lambda.factor</code> before increasing <code>maxit</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>hdqr</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients,
stored as a sparse matrix (<code>dgCMatrix</code> class,
the standard class for sparse numeric matrices in
the <code>Matrix</code> package.). To convert it into
normal type matrix, use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value
of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>the number of iterations for every lambda value</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
fit &lt;- hdqr(x = x, y = y, tau = tau, lam2 = lam2)
</code></pre>

<hr>
<h2 id='nc.hdqr'>Solve the Penalized Quantile Regression with Nonconvex Penalties</h2><span id='topic+nc.hdqr'></span>

<h3>Description</h3>

<p>This function fits the penalized quantile regression model using nonconvex penalties 
such as SCAD or MCP. It allows for flexible control over the regularization parameters and 
offers advanced options for initializing and optimizing the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc.hdqr(
  x,
  y,
  tau,
  lambda,
  pen = "scad",
  aval = NULL,
  lam2 = 1,
  ini_beta = NULL,
  lla_step = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nc.hdqr_+3A_x">x</code></td>
<td>
<p>Matrix of predictors, with dimensions (nobs * nvars); each row represents an observation.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_y">y</code></td>
<td>
<p>Response variable, with length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_tau">tau</code></td>
<td>
<p>The quantile level <code class="reqn">\tau</code>, which must be in the range (0,1). Default is 0.5.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied sequence of <code>lambda</code> values. If unspecified, the program 
calculates its own sequence based on <code>nlambda</code> and <code>lambda.factor</code>. Supplying a decreasing 
sequence of <code>lambda</code> values is advisable to leverage the warm-start optimization.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_pen">pen</code></td>
<td>
<p>Specifies the type of nonconvex penalty: &quot;SCAD&quot; or &quot;MCP&quot;.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_aval">aval</code></td>
<td>
<p>The parameter value for the SCAD or MCP penalty. Default is 3.7 for SCAD and 2 for MCP.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_lam2">lam2</code></td>
<td>
<p>Regularization parameter <code>lambda2</code> for the quadratic penalty on the coefficients. 
Only one value of <code>lambda2</code> is used per fit.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_ini_beta">ini_beta</code></td>
<td>
<p>Optional initial coefficients to start the fitting process.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_lla_step">lla_step</code></td>
<td>
<p>Number of Local Linear Approximation (LLA) steps. Default is 3.</p>
</td></tr>
<tr><td><code id="nc.hdqr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+hdqr">hdqr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>nc.hdqr</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients,
stored as a sparse matrix (<code>dgCMatrix</code> class,
the standard class for sparse numeric matrices in
the <code>Matrix</code> package.). To convert it into
normal type matrix, use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value
of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>the number of iterations for every lambda value</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr></table>
<p>#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=30))
nc.fit &lt;- nc.hdqr(x=x, y=y, tau=tau, lambda=lambda, lam2=lam2, pen="scad")
</code></pre>

<hr>
<h2 id='predict.cv.hdqr'>Make Predictions from a 'cv.hdqr' Object</h2><span id='topic+predict.cv.hdqr'></span>

<h3>Description</h3>

<p>Generates predictions using a fitted 'cv.hdqr()' object. This function utilizes the
stored 'hdqr.fit' object and an optimal value of 'lambda' determined during the
cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.hdqr'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.hdqr_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.hdqr()' object from which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.hdqr_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.cv.hdqr_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' at which predictions
are desired. The default is 's = &quot;lambda.1se&quot;', representing the largest value of 'lambda'
such that the cross-validation error estimate is within one standard error of the minimum.
Alternatively, 's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the
cross-validation error estimate. If 's' is numeric, these are taken as the actual values
of 'lambda' to use for predictions.</p>
</td></tr>
<tr><td><code id="predict.cv.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix or vector of predicted values corresponding to the specified
'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.hdqr">cv.hdqr</a></code>, <code><a href="#topic+coef.cv.hdqr">coef.cv.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
cv.fit &lt;- cv.hdqr(x = x, y = y, tau = tau, lam2 = lam2)
predict(cv.fit, newx = x[50:60, ], s = "lambda.min")
</code></pre>

<hr>
<h2 id='predict.cv.nc.hdqr'>Make Predictions from a 'cv.nc.hdqr' Object</h2><span id='topic+predict.cv.nc.hdqr'></span>

<h3>Description</h3>

<p>Generates predictions using a fitted 'cv.nc.hdqr()' object. This function utilizes the
stored 'nchdqr.fit' object and an optimal value of 'lambda' determined during the
cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.nc.hdqr'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.nc.hdqr_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.nc.hdqr()' object from which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdqr_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdqr_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' at which predictions
are desired. The default is 's = &quot;lambda.1se&quot;', representing the largest value of 'lambda'
such that the cross-validation error estimate is within one standard error of the minimum.
Alternatively, 's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the
cross-validation error estimate. If 's' is numeric, these are taken as the actual values
of 'lambda' to use for predictions.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix or vector of predicted values corresponding to the specified
'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.nc.hdqr">cv.nc.hdqr</a></code>, <code><a href="#topic+predict.cv.nc.hdqr">predict.cv.nc.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=10))
cv.nc.fit &lt;- cv.nc.hdqr(x = x, y = y, tau = tau, lambda = lambda, lam2 = lam2)
predict(cv.nc.fit, newx = x[50:60, ], s = "lambda.min")
</code></pre>

<hr>
<h2 id='predict.hdqr'>Make Predictions from a 'hdqr' Object</h2><span id='topic+predict.hdqr'></span>

<h3>Description</h3>

<p>Produces fitted values for new predictor data using a fitted 'hdqr()' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdqr'
predict(object, newx, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.hdqr_+3A_object">object</code></td>
<td>
<p>Fitted 'hdqr()' object from which predictions are to be derived.</p>
</td></tr>
<tr><td><code id="predict.hdqr_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.hdqr_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which predictions are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="predict.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates predictions at specified 'lambda' values from a fitted 'hdqr()' object.
It is essential to provide a new matrix of predictor values ('newx') at which these predictions are to be made.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of predicted values corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdqr">hdqr</a></code>, <code><a href="#topic+coef.hdqr">coef.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
fit &lt;- hdqr(x = x, y = y, tau = tau, lam2 = lam2)
preds &lt;- predict(fit, newx = tail(x), s = fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='predict.nc.hdqr'>Make Predictions from a 'nc.hdqr' Object</h2><span id='topic+predict.nc.hdqr'></span>

<h3>Description</h3>

<p>Produces fitted values for new predictor data using a fitted 'nc.hdqr()' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nc.hdqr'
predict(object, newx, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.nc.hdqr_+3A_object">object</code></td>
<td>
<p>Fitted 'nc.hdqr()' object from which predictions are to be derived.</p>
</td></tr>
<tr><td><code id="predict.nc.hdqr_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.nc.hdqr_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which predictions are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="predict.nc.hdqr_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates predictions at specified 'lambda' values from a fitted 'nc.hdqr()' object.
It is essential to provide a new matrix of predictor values ('newx') at which these predictions are to be made.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of predicted values corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nc.hdqr">nc.hdqr</a></code>, <code><a href="#topic+coef.nc.hdqr">coef.nc.hdqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(data = rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p)
beta_star &lt;- c(c(2, 1.5, 0.8, 1, 1.75, 0.75, 0.3), rep(0, (p - 7)))
eps &lt;- rnorm(n, mean = 0, sd = 1)
y &lt;- x %*% beta_star + eps
tau &lt;- 0.5
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=30))
nc.fit &lt;- nc.hdqr(x=x, y=y, tau=tau, lambda=lambda, lam2=lam2, pen="scad")
nc.preds &lt;- predict(nc.fit, newx = tail(x), s = nc.fit$lambda[3:5])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
