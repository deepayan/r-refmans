<!DOCTYPE html><html><head><title>Help for package splus2R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splus2R}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allTrue'><p>Test whether all expressions return TRUE</p></a></li>
<li><a href='#anyMissing'><p>Returns TRUE if missing values are round, otherwise FALSE</p></a></li>
<li><a href='#as.rectangular'><p>Covnert to rectangular object</p></a></li>
<li><a href='#asSeriesData'><p>Convert to a seriesData</p></a></li>
<li><a href='#bits.per.integer'><p> Internal Size of an integer</p></a></li>
<li><a href='#colIds'><p>Column and row summary function</p></a></li>
<li><a href='#deparseText'><p>Deparses input argument</p></a></li>
<li><a href='#do.test'>
<p>Test Functions and Expressions - for automated testing</p></a></li>
<li><a href='#expectStop'><p>Test whether expected stop() or warning() messages are produced.</p></a></li>
<li><a href='#ifelse1'><p>Conditional Data Selection</p></a></li>
<li><a href='#is.inf'><p> Infinite</p></a></li>
<li><a href='#is.missing'><p>Check for missing values</p></a></li>
<li><a href='#is.number'><p> Check Values</p></a></li>
<li><a href='#is.orderable'><p> If a value can be ordered</p></a></li>
<li><a href='#is.rectangular'><p>Checks for object rectangularity</p></a></li>
<li><a href='#isNumericAtomicVector'><p>Tests whether an object is a vector or not</p></a></li>
<li><a href='#lowerCase'><p>Case conversion</p></a></li>
<li><a href='#MC'><p> Make Closure for functions</p></a></li>
<li><a href='#nDotArgs'><p>Determine Number of Arguments to Function</p></a></li>
<li><a href='#numCols'><p>Object dimensions</p></a></li>
<li><a href='#numericSequence'><p>Constructor for numericSequence Class</p></a></li>
<li><a href='#numericSequence-methods'><p>Methods for class signalSeries in package splus2R</p></a></li>
<li><a href='#oldUnclass'><p>Class conversion</p></a></li>
<li><a href='#peaks'><p>Local maxima</p></a></li>
<li><a href='#positions'><p>Positions of signalSeries objects</p></a></li>
<li><a href='#rmvnorm'><p>Multivariate Normal (Gaussian) Distribution</p></a></li>
<li><a href='#seriesData'><p>Access Data Of series Objects</p></a></li>
<li><a href='#seriesDataNew'><p>Creates template for new seriesData object</p></a></li>
<li><a href='#seriesDataValid'><p>Validates the structure of seriesData object</p></a></li>
<li><a href='#showStructure'><p>Describe the structure of an object</p></a></li>
<li><a href='#signalSeries'><p>Constructor function for the signalSeries class</p></a></li>
<li><a href='#signalSeries-methods'><p>Methods for class signalSeries in package splus2R</p></a></li>
<li><a href='#stdev'><p>Standard deviation</p></a></li>
<li><a href='#subscript2d'><p>Uniform Rectangular Data Subscripting Function</p></a></li>
<li><a href='#vecnorm'><p>p-norm of a vector</p></a></li>
<li><a href='#which.na'><p>Determine Which Values are Missing Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Supplemental S-PLUS Functionality in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-5</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Currently there are many functions in S-PLUS that are
  missing in R. To facilitate the conversion of S-PLUS packages to R packages,
  this package provides some missing S-PLUS functionality in R.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/spkaluzny/splus2r">https://github.com/spkaluzny/splus2r</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spkaluzny/splus2r/issues">https://github.com/spkaluzny/splus2r/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>Swrappers.R peaks.R bits.per.integer.R doTest.R muS2RC.R
showStructure.R sigseriesS3.R sigseriesS4.R splus2R_is.R
splus2R_pkg.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 01:59:26 UTC; spk</td>
</tr>
<tr>
<td>Author:</td>
<td>William Constantine [aut],
  Tim Hesterberg [aut],
  Knut Wittkowski [ctb],
  Tingting Song [ctb],
  Bill Dunlap [ctb],
  Stephen Kaluzny [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Kaluzny &lt;spkaluzny@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allTrue'>Test whether all expressions return TRUE</h2><span id='topic+allTrue'></span>

<h3>Description</h3>

<p>This is typically used to combine multiple <code><a href="base.html#topic+all.equal">all.equal</a></code> tests
into a single test, in a test file called by <code><a href="#topic+do.test">do.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTrue(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allTrue_+3A_...">...</code></td>
<td>
<p>Each argument is typically a call to <code>do.test</code> or
another expression that returns a logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is intended for use in test run by <code><a href="#topic+do.test">do.test</a></code>.
A typical test may contain lines that create one or more
objects, followed by commands to check that those objects have
the expected structure and/or that calculations were correct.
By using <code>allTrue</code>, the tests can all be combined into the
same expression that created the objects, so that if an error
occurs it is easier to see where it occured.
</p>


<h3>Value</h3>

<p>if all inputs are <code>TRUE</code> the value is <code>TRUE</code>.
Otherwise a list indicating which arguments did not return
<code>TRUE</code>, containing the actual values.
</p>


<h3>Author(s)</h3>

<p>Tim Hesterberg</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>,
<code><a href="#topic+do.test">do.test</a></code>,
<code><a href="#topic+expectStop">expectStop</a></code>,
<code><a href="#topic+expectWarnings">expectWarnings</a></code>,
<code><a href="base.html#topic+identical">identical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the type of expression that may be found in a test file
# to be run by do.test -- inside {} are lines that create one or
# more objects, followed by multiple tests (inside allTrue) that
# check those objects.
{
  y &lt;- rnorm(30)
  x &lt;- matrix(rnorm(60), ncol=2)
  fit &lt;- lm(y~x)
  allTrue(# are important components included?
          all(is.element(c("coefficients", "residuals", "effects", "rank",
                           "fitted.values", "assign", "df.residual", "call"),
                         names(fit))),
          {
            # do coefficients match the algebraic form?
            # The algebraic form is inaccurate, so allow greater tolerance
            X &lt;- cbind(1, x)
            all.equal(unname(fit$coefficients),
                      drop(solve( t(X) %*% X, t(X) %*% y)),
                      tol = 1e-5)
          },
          # are residuals computed correctly?
          all.equal(fit$residuals, y - X %*% fit$coefficients))
}
# The second test uses 'unname' to remove names and 'drop' to change a
# matrix to a vector, so the test should pass.
# The third test fails because fit$residuals is a vector with names
# while the %*% calculation returns a matrix.
</code></pre>

<hr>
<h2 id='anyMissing'>Returns TRUE if missing values are round, otherwise FALSE</h2><span id='topic+anyMissing'></span>

<h3>Description</h3>

<p>Detection of missing values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>anyMissing(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anyMissing_+3A_x">x</code></td>
<td>
<p>any object (though not all are currently supported).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, TRUE is missing values are detected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.missing">is.missing</a></code>, <code><a href="#topic+which.na">which.na</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>anyMissing(1:5)
anyMissing(c(1, NA, 2))
anyMissing(list(a=1:3, b=NA))
anyMissing(data.frame(a=1:3, b=c(NA, 5:6)))
</code></pre>

<hr>
<h2 id='as.rectangular'>Covnert to rectangular object</h2><span id='topic+as.rectangular'></span>

<h3>Description</h3>

<p>Rectangular data objects include matrices, data frames, and atomic vectors.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rectangular_+3A_x">x</code></td>
<td>
<p>object to be converted to rectangular data.</p>
</td></tr>
<tr><td><code id="as.rectangular_+3A_i">i</code></td>
<td>
<p>first (row) subscript</p>
</td></tr>
<tr><td><code id="as.rectangular_+3A_j">j</code></td>
<td>
<p>second (column) subscript.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.rectangular(x)</code> returns <code>x</code> if <code>x</code> is already rectangular, or <code>as.data.frame(x)</code> if it is not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.rectangular">is.rectangular</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 
as.rectangular(list(a=1:10, b=11:20))
</code></pre>

<hr>
<h2 id='asSeriesData'>Convert to a seriesData</h2><span id='topic+asSeriesData'></span>

<h3>Description</h3>

<p>Essentially just converts data to rectangular form, if possible.</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSeriesData(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asSeriesData_+3A_x">x</code></td>
<td>
<p>input object to coerce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rectangular conversion of input argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>, <code><a href="#topic+seriesData">seriesData</a></code>, <code><a href="#topic+seriesDataNew">seriesDataNew</a></code>, <code><a href="#topic+seriesDataValid">seriesDataValid</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>, <code><a href="#topic+as.data.frame.signalSeries">as.data.frame.signalSeries</a></code>, <code><a href="#topic+as.matrix.signalSeries">as.matrix.signalSeries</a></code>, <code><a href="#topic+cumsum.signalSeries">cumsum.signalSeries</a></code>, <code><a href="#topic+deltat.signalSeries">deltat.signalSeries</a></code>, <code><a href="#topic+diff.signalSeries">diff.signalSeries</a></code>, <code><a href="#topic+plot.signalSeries">plot.signalSeries</a></code>.</p>

<hr>
<h2 id='bits.per.integer'> Internal Size of an integer </h2><span id='topic+bits.per.integer'></span>

<h3>Description</h3>

<p>Reports the size of an integer in bits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bits.per.integer()
</code></pre>


<h3>Details</h3>

<p>Included for S-PLUS compatibility; R currently uses 32-bit integers,
even on 64-bit machines.
</p>


<h3>Author(s)</h3>

<p> Dunlap, W.M., and Taylor, C.F. </p>


<h3>Examples</h3>

<pre><code class='language-R'>bits.per.integer()
</code></pre>

<hr>
<h2 id='colIds'>Column and row summary function</h2><span id='topic+colIds'></span><span id='topic+colMaxs'></span><span id='topic+colMedians'></span><span id='topic+colMins'></span><span id='topic+colRanges'></span><span id='topic+colVars'></span><span id='topic+rowIds'></span><span id='topic+rowMaxs'></span><span id='topic+rowMins'></span><span id='topic+rowRanges'></span>

<h3>Description</h3>

<p>Summarizes the columns or rows of a rectangular object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>colIds(x, do.NULL=TRUE, prefix="col")
colMaxs(x, na.rm = FALSE, dims = 1, n = NULL)
colMedians(x, na.rm=FALSE)
colMins(x, na.rm = FALSE, dims = 1, n = NULL)
colRanges(x, na.rm = FALSE, dims = 1, n = NULL)
colVars(x, na.rm=FALSE, dims = 1, unbiased = TRUE,
        SumSquares = FALSE, weights = NULL, freq = NULL, n = NULL)
rowIds(x, do.NULL=TRUE, prefix="row")
rowMaxs(x, na.rm = FALSE, dims = 1, n = NULL)
rowMins(x, na.rm = FALSE, dims = 1, n = NULL)
rowRanges(x, na.rm = FALSE, dims = 1, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colIds_+3A_x">x</code></td>
<td>
<p>rectangular input object such as a matrix or data.frame.</p>
</td></tr>
<tr><td><code id="colIds_+3A_dims">dims</code></td>
<td>
<p>if <code>x</code> has dimension higher than <code>2</code>,
<code>dims</code> determines what dimensions are summarized.</p>
</td></tr>
<tr><td><code id="colIds_+3A_do.null">do.NULL</code></td>
<td>
<p>logical for rowIds or colIds.</p>
</td></tr>
<tr><td><code id="colIds_+3A_n">n</code></td>
<td>
<p>number of rows; treat <code>x</code> as a matrix with <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="colIds_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, NA values are removed if TRUE.</p>
</td></tr>
<tr><td><code id="colIds_+3A_prefix">prefix</code></td>
<td>
<p>character string preface for column IDs returned by rowIds or colIds.</p>
</td></tr>
<tr><td><code id="colIds_+3A_unbiased">unbiased</code></td>
<td>
<p>logical, unbiased variance estimates returned if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="colIds_+3A_sumsquares">SumSquares</code></td>
<td>
<p>logical, sums of squares are returned if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="colIds_+3A_weights">weights</code>, <code id="colIds_+3A_freq">freq</code></td>
<td>
<p>unsupported, here for backwards compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corresponding summary by row or by column.
</p>


<h3>See Also</h3>

<p>See 'aggregate' package for alternative definitions of colStdevs, colVars, rowStdevs 
and rowVars functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a matrix, add dimensions, and obtain
## various summaries
x &lt;- matrix(sin(1:20), nrow=4)
dimnames(x) &lt;- list(c("a","b","c","d"), paste("col", 1:5))
colIds(x)
colMaxs(x)
colMedians(x)
colMins(x)
colRanges(x)
rowIds(x)
rowMaxs(x)
rowMins(x)
rowRanges(x)
</code></pre>

<hr>
<h2 id='deparseText'>Deparses input argument</h2><span id='topic+deparseText'></span>

<h3>Description</h3>

<p>Deparse the argument into a single string, with at most <code>maxchars</code> characters. New lines are turned into blanks, and truncated
results end in &quot;....&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparseText(expr, maxchars=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deparseText_+3A_expr">expr</code></td>
<td>
<p>any expression.</p>
</td></tr>
<tr><td><code id="deparseText_+3A_maxchars">maxchars</code></td>
<td>
<p>maximum number of characters returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deparsed character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deparseText(args(lm), maxchars=20)
</code></pre>

<hr>
<h2 id='do.test'>
Test Functions and Expressions - for automated testing
</h2><span id='topic+do.test'></span>

<h3>Description</h3>

<p>Expressions are parsed and evaluated from <code>file</code>.
Each expression should evaluate to a logical <code>TRUE</code>.  Otherwise,
<code>do.test()</code> prints the expression and its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.test(file, verbose=FALSE, strict=FALSE, local=FALSE, check)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.test_+3A_file">file</code></td>
<td>

<p>a file or connection containing code to test.
</p>
</td></tr>
<tr><td><code id="do.test_+3A_verbose">verbose</code></td>
<td>

<p>logical flag. If <code>TRUE</code>, all expressions are printed, not just
those that fail.  Regardless of this flag, the value is also printed
for failures.
</p>
</td></tr>
<tr><td><code id="do.test_+3A_strict">strict</code></td>
<td>

<p>logical flag.  If <code>TRUE</code>, any validity
failures cause an error; that is, you get to debug after the first failed
assertion.
</p>
</td></tr>
<tr><td><code id="do.test_+3A_local">local</code></td>
<td>

<p>logical flag controlling where the evaluation
takes place: by default (<code>local=FALSE</code>),
in the environment that called <code>do.test</code>, typically
the global environment, (objects created remain there after
<code>do.test</code> is finished).
<code>local=TRUE</code>, causes <code>do.test</code> to create and work
in a new environment.
</p>
</td></tr>
<tr><td><code id="do.test_+3A_check">check</code></td>
<td>

<p>an unevaluated expression. If <code>check</code>is supplied,
<code>do.test</code>evaluates
this expression (it should be given via <code>Quote()</code>) between each
parse and evaluation.  (This is for when you need to check some global
information.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A test file typically contains a sequence of expressions to test
different aspects of a function or set of functions, including
testing that each input argument is handled appropriately,
error handling,
the output has the expected structure,
correct output under a number of combinations of inputs,
and error handling (warning and stop invoked when appropriate and
with appropriate messages).  Each expression may contain multiple
lines grouped using <code>{}</code>,
where early lines may do computations and the last line
checks for expected results, usually using <code><a href="base.html#topic+all.equal">all.equal</a></code>.
</p>
<p>Some expressions may be included that aren't intended to test anything
by finishing them with <code>TRUE</code>, e.g. to read data:
<code>{read.table("data.txt"); TRUE}</code>
or to remove objects at the end of a test file:
<code>{rm(a, b, x, y); TRUE}</code>.
</p>
<p>We recommend including comments inside expressions to indicate
the purpose of each test; then if errors occur the comments are
printed too.
</p>
<p>To compare just numbers, not names or matrix dimensions, functions
<code><a href="base.html#topic+unname">unname</a></code> and <code><a href="base.html#topic+drop">drop</a></code> are useful.
</p>
<p>To exclude
certain components or attributes from the comparison the function
<code>all.equal.excluding</code> is useful.  This is defined in the examples
below.
</p>
<p>Each test should run silently if everything is working correctly;
there should be nothing printed.  <code><a href="#topic+expectWarnings">expectWarnings</a></code> can
be used to intercept <code><a href="base.html#topic+warning">warning</a></code> statements.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>,
<code><a href="#topic+allTrue">allTrue</a></code>,
<code><a href="base.html#topic+drop">drop</a></code>,
<code><a href="#topic+expectStop">expectStop</a></code>,
<code><a href="#topic+expectWarnings">expectWarnings</a></code>,
<code><a href="base.html#topic+identical">identical</a></code>,
<code><a href="methods.html#topic+Quote">Quote</a></code>,
<code><a href="base.html#topic+unname">unname</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a toy test file, and run it
cat('{all.equal(24/8, 3)}',
    '{all.equal(5, 6)}',      # this one will fail
    'expectWarnings( { # Test subscript replacement ',
    '  x &lt;- data.frame(a=1:3,b=2:4)',
    '  x[,3] &lt;- x',
    '  all.equal(ncol(x), 3)',
    '}, expected = "provided 2 variables to replace 1 var")',
    'expectStop(lm(5), expected = "invalid formula")',
    '{ rm(x) ; TRUE }',       # cleanup at end of test
    sep="\n", file = "testfile.t")
do.test("testfile.t")
## ------- Test file: testfile.t ---------
## {all.equal(5, 6)}
## [1] "Mean relative difference: 0.2"
#
# The test that fails is printed, with the results of the test.
# In R 2.6.1 the subscript replacement test above also fails
# (bug reported 14 Jan 2008), resulting in the additional printout:
## expectWarnings( {
##   x &lt;- data.frame(a=1:3,b=2:4)
##   x[,3] &lt;- x
##   all.equal(ncol(x), 3)
## }, expected = "provided 2 variables to replace 1 var")
## $`Test result`
## [1] "Mean relative  difference: 0.25"

## End(Not run)

# This function is useful in some tests:
all.equal.excluding &lt;- function(x, y, ..., excluding=NULL, attrs=NULL){
  # Like all.equal, but exclude components in `excluding',
  #   and excluding attributes named in `attrs'.
  #
  # `excluding' and `attrs' should be character, names of components 
  #   and attributes.
  # 
  # For example:
  #   all.equal.excluding(obj1, obj2, excluding = c("call", "x"))
  for(i in intersect(names(x), excluding)) x[[i]] &lt;- NULL
  for(i in intersect(names(y), excluding)) y[[i]] &lt;- NULL
  for(i in intersect(names(attributes(x)), attrs)) attr(x,i) &lt;- NULL
  for(i in intersect(names(attributes(y)), attrs)) attr(y,i) &lt;- NULL
  all.equal(x,y, ...)
}
# Test if two objects are the same except for "call" and "x":
data &lt;- data.frame(x = 1:20, y = exp(1:20/20))
fit1 &lt;- lm(y ~ x, data = data, x=TRUE)
fit2 &lt;- update(fit1, x=)
all.equal.excluding(fit1, fit2, excluding = c("call", "x"))
</code></pre>

<hr>
<h2 id='expectStop'>Test whether expected stop() or warning() messages are produced.</h2><span id='topic+expectStop'></span><span id='topic+expectWarnings'></span>

<h3>Description</h3>

<p>These functions are for use in automated testing using <code>do.test</code>,
to test whether function give specified
<code>stop</code> and <code>warning</code> messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectStop(expr, expected = NULL)
expectWarnings(expr, expected)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectStop_+3A_expr">expr</code></td>
<td>
<p> An expression, that should result in a call to <code>stop()</code>
or <code>warning()</code>.</p>
</td></tr>
<tr><td><code id="expectStop_+3A_expected">expected</code></td>
<td>
 <p><code>NULL</code>, or a character string
containing (part of) the message
expected from <code>stop</code>.  For <code>expectWarnings</code> a vector of
character strings containing (parts of) all expected warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expectStop</code> is useful for checking error checking; that a function
stops when it should, and gives the right message.
For example, this may be in a file called by do.test:
</p>
<pre>{
  expectStop(var(1:5, 1:4), "incompatible")
}
</pre>
<p>The function returns <code>TRUE</code> if
</p>

<ul>
<li><p> a stop() occurs, and
</p>
</li>
<li><p> the error message is expected.
</p>
</li></ul>

<p>Otherwise it returns appropriate messages.
</p>
<p><code>expectStop</code> intercepts the error.
Execution continues, and assignments made earlier are committed.
</p>
<p>Similarly, <code>expectWarnings</code> is useful to check that a function
gives appropriate warnings.
For example, this may be in a file called by do.test:
</p>
<pre>
expectWarnings(
  {
    object1 &lt;- (code generating warning messages);
    object2 &lt;- (code generating possibly other warning messages);
    all.equal(object1, object2)
  },
  c("expected warning 1",
    "expected warning 2"))
</pre>
<p>The function returns <code>TRUE</code> if
</p>

<ul>
<li><p> expr evaluates to <code>TRUE</code>; and
</p>
</li>
<li><p> each warning message produced by evaluating expr contains as a
substring an element of expected, and each element of expected
is a substring of at least one of the produced warning messages.
</p>
</li></ul>

<p>Otherwise it returns a list with components describing the test failures.
Normal printing of warning messages is suppressed.
</p>
<p>It is possible to test for warnings and a stop in a single expression,
by nesting calls to the two functions.
</p>


<h3>Value</h3>

<p>If all tests pass, then <code>TRUE</code>.
Otherwise <code>expectStop</code> returns character strings describing the
failure, while <code>expectWarnings</code> returns a list with one or
more of the following components:
</p>
<table>
<tr><td><code>'Test result'</code></td>
<td>
<p>the value (if not <code>TRUE</code>) returned by
evaluating <code>expr</code>.</p>
</td></tr>
<tr><td><code>'Unexpected warnings'</code></td>
<td>
<p>character vector
of actual warning messages that were not listed in <code>expected</code>.</p>
</td></tr>
<tr><td><code>'Warnings expected but not found'</code></td>
<td>
<p>character vector
of messages in <code>expected</code> that were not produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Hesterberg</p>


<h3>See Also</h3>

<p><code><a href="#topic+do.test">do.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Expressions like the following would typically be included in a file
# that is called by do.test

expectStop(lm(5), expected = "invalid formula")

expectStop(cov2cor( matrix(2:1) ),
           expected = "'V' is not a square numeric matrix")

expectWarnings( # Test subscript replacement; should discard extra
                # column and give a warning
  {
    x &lt;- data.frame(a=1:3,b=2:4)
    x[,3] &lt;- x
    all.equal(ncol(x), 3)
  },
  expected = "provided 2 variables to replace 1 var")

# Test for a warning and stop together:
{
  f &lt;- function(x){
    warning("a warning")
    stop("a stop")
  }
  expectStop( expectWarnings( f(3), expected = "a warning"),
              expected = "a stop")
}
# The definition of f and the call to expectStop are included here
# within {} because that is how they would typically be grouped in
# a file that is called by do.test.  Also note that f has been saved
# (the assignment of f is committed, rather than aborted).
</code></pre>

<hr>
<h2 id='ifelse1'>Conditional Data Selection</h2><span id='topic+ifelse1'></span>

<h3>Description</h3>

<p>This is equivalent to <code>{if(test) x else y}</code> . The main
advantage of using this function is better formatting, and a more
natural syntax when the result is being assigned; see examples below.
</p>
<p>With 5 arguments, this is equivalent to <code>{if(test1) x else if(test2) u
else v}</code> (where arguments are given by name, not position).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifelse1(test, x, y, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifelse1_+3A_test">test</code></td>
<td>
<p>logical value; if TRUE return x.</p>
</td></tr>
<tr><td><code id="ifelse1_+3A_x">x</code></td>
<td>
<p>any object; this is returned if test is TRUE.</p>
</td></tr>
<tr><td><code id="ifelse1_+3A_y">y</code></td>
<td>
<p>any object; this is returned if test is FALSE.</p>
</td></tr>
<tr><td><code id="ifelse1_+3A_...">...</code></td>
<td>
<p>there should be 3, 5, 7, etc. arguments to this function; arguments 1, 3, 5, etc. should be logical values; the other arguments (even numbered, and last) are objects that may be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>test</code> should be a scalar logical, and only one of <code>x</code> or
<code>y</code> is evaluated, depending on whether <code>test = TRUE</code> or
<code>test = FALSE</code>, and <code>x</code> and <code>y</code> may be any objects.
In contrast, for
<code>ifelse</code>, test is normally a vector, both <code>x</code> and <code>y</code>
are evaluated, even if
not used, and <code>x</code> and <code>y</code> are vectors the same length as
<code>test</code>.
</p>


<h3>Value</h3>

<p>with three arguments, one of <code>x</code> or <code>y</code>.
With k arguments, one of arguments 2, 4, ..., k-1, k.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ifelse">ifelse</a></code>, <code><a href="base.html#topic+if">if</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ifelse1(TRUE, "cat", "dog")
ifelse1(FALSE, "one", FALSE, "two", "three")
</code></pre>

<hr>
<h2 id='is.inf'> Infinite </h2><span id='topic+is.inf'></span>

<h3>Description</h3>

<p><code>is.inf</code> returns a vector of the same length as the input object, 
indicating which elements are infinite (not missing). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.inf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.inf_+3A_x">x</code></td>
<td>
<p> object to be tested </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls <code><a href="base.html#topic+is.infinite">is.infinite</a></code>.
</p>
<p>This returns a vector of the same length as <code>x</code>; the <code>j</code>th
element is <code>TRUE</code> if <code>x[j]</code> is infinite
(i.e., equal to one of <code>Inf</code> or <code>-Inf</code>). 
This will be <code>FALSE</code> if <code>x</code> is not numeric or complex.
Complex numbers are infinite if either the real and imaginary part is.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.infinite">is.infinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.inf(Inf)
# [1] TRUE
is.inf(NA)
# [1] FALSE
is.inf(1)
# [1] FALSE
</code></pre>

<hr>
<h2 id='is.missing'>Check for missing values</h2><span id='topic+is.missing'></span>

<h3>Description</h3>

<p>Check to see whether the input is either NA or a vector of length 0.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.missing(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.missing_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the input is a vector of length 0; <code>is.na(x)</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anyMissing">anyMissing</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.missing(numeric(0))
is.missing(NA)
is.missing(c(1,2,3,NA,5))
</code></pre>

<hr>
<h2 id='is.number'> Check Values </h2><span id='topic+is.number'></span>

<h3>Description</h3>

<p>Returns a logical vector describing if a numeric elements 
is a number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.number(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.number_+3A_x">x</code></td>
<td>
<p> numeric vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.number</code> is <code>TRUE</code> if the value is numeric or complex
and is not missing (<code>NA</code> or <code>NaN</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.number(32)
# [1] TRUE
is.number(matrix(1:20, nrow=2))
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
# [1,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE  TRUE
# [2,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE  TRUE
is.number(list(matrix(1:20, nrow=2), 1:4))
# [1] TRUE TRUE
is.number('s')
# [1] TRUE
</code></pre>

<hr>
<h2 id='is.orderable'> If a value can be ordered </h2><span id='topic+is.orderable'></span>

<h3>Description</h3>

<p><code>is.orderable(x)</code> returns <code>!is.na()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.orderable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.orderable_+3A_x">x</code></td>
<td>
<p> object to be tested. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> should not be a list; in that case the behavior currently
differs between S-PLUS and R.
</p>


<h3>Value</h3>

<p><code>is.orderable</code> returns a logical vector of the same length
as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.na">is.na</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 4, NA, 0, 5)
is.orderable(x)
# [1]  TRUE  TRUE FALSE  TRUE  TRUE
</code></pre>

<hr>
<h2 id='is.rectangular'>Checks for object rectangularity</h2><span id='topic+is.rectangular'></span>

<h3>Description</h3>

<p>Returns TRUE if the input object is rectangular.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rectangular(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rectangular_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, returns TRUE if input object is rectangular.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.rectangular">as.rectangular</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.rectangular(matrix(1:12, nrow=3))
is.rectangular(list(1:3,2:4))
is.rectangular(as.rectangular(list(1:3,2:4)))
</code></pre>

<hr>
<h2 id='isNumericAtomicVector'>Tests whether an object is a vector or not</h2><span id='topic+isNumericAtomicVector'></span>

<h3>Description</h3>

<p>The <code>is.vector</code> function returns a <code>FALSE</code>
value in some cases where intuitively one might
expect a <code>TRUE</code> value to be returned. For example,
<code>is.vector(z)</code> returns <code>FALSE</code> for each of the
following:
</p>

<dl>
<dt>i</dt><dd><p><code>z &lt;- 1:3;names(z) &lt;- 1:3</code></p>
</dd>
<dt>ii</dt><dd><p><code>z &lt;- matrix(1:3, nrow=1)</code></p>
</dd>
<dt>iii</dt><dd><p><code>z &lt;- matrix(1:3, ncol=1)</code></p>
</dd></dl>

<p>These results are not necessarily incorrect, they are
just one interpretion of the definition of a vector.
Contrarily, the <code>isNumericAtomicVector(z)</code> function returns
<code>TRUE</code> for each of the above examples. Thus,
<code>isNumericAtomicVector</code> expands the basic definition of a
vector to allow matrices containing a single row
or column and named vectors. Also, unlike <code>is.vector</code>,
<code>isNumericAtomicVector</code> returns <code>FALSE</code> for objects of class <code>list</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNumericAtomicVector(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNumericAtomicVector_+3A_x">x</code></td>
<td>
<p>an object of arbitrary class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings containing the result. The length
of this vector is equal to <code>length(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## cases where isNumericAtomicVector returns 
## TRUE 
z &lt;- 1:3;names(z) &lt;- letters[1:3]
isNumericAtomicVector(z)
isNumericAtomicVector(matrix(1:3, nrow=1))
isNumericAtomicVector(matrix(1:3, ncol=1))
isNumericAtomicVector(1:5)
isNumericAtomicVector(letters)

## cases where isNumericAtomicVector returns 
## FALSE 
isNumericAtomicVector(list(1:3))
isNumericAtomicVector(data.frame(1:3,2:4))
isNumericAtomicVector(matrix(1:12, nrow=4))
</code></pre>

<hr>
<h2 id='lowerCase'>Case conversion</h2><span id='topic+lowerCase'></span><span id='topic+upperCase'></span>

<h3>Description</h3>

<p>Convert text to lower or upper case.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowerCase(x)
upperCase(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowerCase_+3A_x">x</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string coerced to the specified case.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+casefold">casefold</a></code>, <code><a href="base.html#topic+tolower">tolower</a></code>, <code><a href="base.html#topic+toupper">toupper</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "A dog and a cat"
lowerCase(x)
upperCase(x)
</code></pre>

<hr>
<h2 id='MC'> Make Closure for functions </h2><span id='topic+MC'></span>

<h3>Description</h3>

<p>MC makes closures for defining functions in a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC(f, env=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_+3A_f">f</code></td>
<td>
<p> function </p>
</td></tr>
<tr><td><code id="MC_+3A_env">env</code></td>
<td>
<p> a list containing functions to be used in f </p>
</td></tr>
</table>


<h3>Details</h3>

<p>MC declares functions to be used in f.  When f is defined inside of
a function, say fun, it cannot call other functions defined in fun.
MC can enclose the functions needed by f and make it possible for f
to call other functions defined in fun.
</p>


<h3>Author(s)</h3>

<p> Knut M. Wittkowski <a href="mailto:kmw@rockefeller.edu">kmw@rockefeller.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- function(x, y) x+y
f2 &lt;- MC(function(x, y) x*y, list(f1=f1))
</code></pre>

<hr>
<h2 id='nDotArgs'>Determine Number of Arguments to Function</h2><span id='topic+nDotArgs'></span>

<h3>Description</h3>

<p>count the number of ... arguments passed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nDotArgs(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nDotArgs_+3A_...">...</code></td>
<td>
<p>... arguments or real arguments in the call to the function which calls <code>nDotArgs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of ... arguments in the call to the
function which calls <code>nDotArgs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nargs">nargs</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>myfun &lt;- function(..., a=4) nDotArgs(...)
myfun()                 ## returns 0 
myfun(1:3,"bear")       ## returns 2 
myfun(a=5, 1:3, "bear") ## returns 2 (excludes a)
</code></pre>

<hr>
<h2 id='numCols'>Object dimensions</h2><span id='topic+numCols'></span><span id='topic+numRows'></span>

<h3>Description</h3>

<p>Returns number of rows or number of columns of rectangular input object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>numCols(x)
numRows(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numCols_+3A_x">x</code></td>
<td>
<p>rectangular object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of rows or columns of the input object.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>,<code><a href="base.html#topic+matrix">matrix</a></code>,<code><a href="base.html#topic+Subscript">Subscript</a></code>,<code><a href="base.html#topic+nrow">nrow</a></code>,<code><a href="base.html#topic+dimnames">dimnames</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:12, nrow=3)
numCols(x)
numRows(x)
</code></pre>

<hr>
<h2 id='numericSequence'>Constructor for numericSequence Class</h2><span id='topic+numericSequence'></span><span id='topic+numericSequence-class'></span>

<h3>Description</h3>

<p>Constructor function for numericSequence objects. At least three of the four
arguments must be supplied, unless the function is called with no arguments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>numericSequence(from, to, by, length.)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numericSequence_+3A_from">from</code></td>
<td>
<p>start of the sequence.</p>
</td></tr>
<tr><td><code id="numericSequence_+3A_to">to</code></td>
<td>
<p>end of the sequence.</p>
</td></tr>
<tr><td><code id="numericSequence_+3A_by">by</code></td>
<td>
<p>increment for the sequence.</p>
</td></tr>
<tr><td><code id="numericSequence_+3A_length.">length.</code></td>
<td>
<p>length of the sequence, a non-negative integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numericSequence object with properties given by the arguments, or the default numericSequence if no arguments are supplied.
</p>


<h3>S3 METHODS</h3>


<dl>
<dt>S4</dt><dd><p>supported S4 methods include: <code>Math</code>, <code>Math2</code>, <code>Ops</code>, <code>Summary</code>, <code>[</code>, <code>[[</code>, <code>duplicated</code>, <code>is.na</code>,
<code>length</code>, <code>match</code>, <code>mean</code>, <code>median</code>, <code>quantile</code>, <code>show</code>, <code>sort</code>,
<code>summary</code>, <code>unique</code>, <code>which.na</code>. There are also <code>[</code> and <code>[[</code> S4 style replacment methods available.</p>
</dd>
<dt>as</dt><dd><p>s4 style conversion methods ala <code>as(x, foo)</code> where <code>foo</code> is one of the following conversion classes:
<code>"character"</code>, <code>"integer"</code>, <code>"numeric"</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+seriesData">seriesData</a></code>, <code><a href="#topic+asSeriesData">asSeriesData</a></code>, <code><a href="#topic+seriesDataNew">seriesDataNew</a></code>, <code><a href="#topic+seriesDataValid">seriesDataValid</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>, <code><a href="#topic+as.data.frame.signalSeries">as.data.frame.signalSeries</a></code>, <code><a href="#topic+as.matrix.signalSeries">as.matrix.signalSeries</a></code>, <code><a href="#topic+cumsum.signalSeries">cumsum.signalSeries</a></code>, <code><a href="#topic+deltat.signalSeries">deltat.signalSeries</a></code>, <code><a href="#topic+diff.signalSeries">diff.signalSeries</a></code>, <code><a href="#topic+plot.signalSeries">plot.signalSeries</a></code>.</p>

<hr>
<h2 id='numericSequence-methods'>Methods for class signalSeries in package splus2R</h2><span id='topic+numericSequence-methods'></span><span id='topic+Math+2CnumericSequence-method'></span><span id='topic+Math2+2CnumericSequence-method'></span><span id='topic+Ops+2CANY+2CnumericSequence-method'></span><span id='topic+Ops+2CnumericSequence+2CANY-method'></span><span id='topic+Summary+2CnumericSequence-method'></span><span id='topic++5B+2CnumericSequence-method'></span><span id='topic++5B+3C-+2CnumericSequence-method'></span><span id='topic++5B+5B+2CnumericSequence-method'></span><span id='topic++5B+5B+3C-+2CnumericSequence-method'></span><span id='topic+coerce+2Cnumeric+2CnumericSequence-method'></span><span id='topic+coerce+2CnumericSequence+2Ccharacter-method'></span><span id='topic+coerce+2CnumericSequence+2Cinteger-method'></span><span id='topic+coerce+2CnumericSequence+2Cnumeric-method'></span><span id='topic+duplicated+2CnumericSequence-method'></span><span id='topic+is.na+2CnumericSequence-method'></span><span id='topic+length+2CnumericSequence-method'></span><span id='topic+match+2CANY+2CnumericSequence-method'></span><span id='topic+match+2CnumericSequence+2CANY-method'></span><span id='topic+mean+2CnumericSequence-method'></span><span id='topic+median+2CnumericSequence-method'></span><span id='topic+quantile+2CnumericSequence-method'></span><span id='topic+rev+2CnumericSequence-method'></span><span id='topic+show+2CnumericSequence-method'></span><span id='topic+sort+2CnumericSequence+2Cmissing-method'></span><span id='topic+sort+2CnumericSequence-method'></span><span id='topic+summary+2CnumericSequence-method'></span><span id='topic+unique+2CnumericSequence+2Cmissing-method'></span><span id='topic+unique+2CnumericSequence-method'></span><span id='topic+which.na+2CnumericSequence-method'></span>

<h3>Description</h3>

<p>Methods for class <code>signalSeries</code> in package <code>splus2R</code></p>


<h3>Details</h3>

<p>Supported (generic) methods include:
</p>

<dl>
<dt>as</dt><dd><p>Target classes: character, integer, numeric.</p>
</dd>
<dt>Math</dt><dd><p>Math functions</p>
</dd>
<dt>Math2</dt><dd><p>Math2 functions</p>
</dd>
<dt>Ops</dt><dd><p>Ops functions</p>
</dd>
<dt>Data access and replacement</dt><dd><p>Single- and double-bracket access and replacement functions</p>
</dd>
<dt>duplicated</dt><dd><p>Find duplciated entries in sequence</p>
</dd>
<dt>is.na</dt><dd><p>Test for NA entries in sequence</p>
</dd>
<dt>length</dt><dd><p>Length of sequence</p>
</dd>
<dt>match</dt><dd><p>Matching functions for sequence</p>
</dd>
<dt>mean</dt><dd><p>Mean of sequence</p>
</dd>
<dt>median</dt><dd><p>Median of sequence</p>
</dd>
<dt>quantile</dt><dd><p>Quantile of sequence</p>
</dd>
<dt>rev</dt><dd><p>Reverse sequence</p>
</dd>
<dt>show</dt><dd><p>Show the sequence</p>
</dd>
<dt>sort</dt><dd><p>Sort the sequence</p>
</dd>
<dt>unique</dt><dd><p>Find unique sequence entries</p>
</dd>
<dt>summary</dt><dd><p>Summarize the sequence</p>
</dd>
<dt>unique</dt><dd><p>Find unique elements of a sequence</p>
</dd>
<dt>which.na</dt><dd><p>Find NA entries in the sequence</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+signalSeries">signalSeries</a></code>.</p>

<hr>
<h2 id='oldUnclass'>Class conversion</h2><span id='topic+oldUnclass'></span>

<h3>Description</h3>

<p>the old-style version of function <code>unclass</code>; it sets <code>oldClass</code> to <code>NULL</code>, rather than <code>class</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>oldUnclass(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oldUnclass_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>unclassed version of input object.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+oldClass">oldClass</a></code>,<code><a href="base.html#topic+unclass">unclass</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldUnclass(matrix(1:10))
</code></pre>

<hr>
<h2 id='peaks'>Local maxima</h2><span id='topic+peaks'></span>

<h3>Description</h3>

<p>Finds the local maxima in a vector, or time series, or in each column of a matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks(x, span=3, strict=TRUE, endbehavior=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_x">x</code></td>
<td>
<p>vector or matrix.</p>
</td></tr>
<tr><td><code id="peaks_+3A_span">span</code></td>
<td>
<p>a peak is defined as an element in a sequence which is greater than all other elements within a window of width span centered at that element. The default value is 3, meaning that a peak is bigger than both of its neighbors. Default: 3.</p>
</td></tr>
<tr><td><code id="peaks_+3A_strict">strict</code></td>
<td>
<p>logical flag: if TRUE, an element must be strictly greater than all other values in its window to be considered a peak. Default: TRUE.</p>
</td></tr>
<tr><td><code id="peaks_+3A_endbehavior">endbehavior</code></td>
<td>

<p>a value of 0, 1 or 2 that determines how peaks are computed within
a <code>halfwidth</code> (= <code>floor(span/2)</code>) of the ends of the sequence.
A value of 0 means no value within <code>halfwidth</code> of the start or end
can be considered a peak.
A value of 1 means maximum values within <code>halfwidth</code> of the start or end
can be considered a peak.
A value of 2 returns <code>NA</code> for the values within <code>halfwidth</code>
of the start or end.
The default is <code>endbehavior=0)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object like <code>x</code> of logical values.
Values that are TRUE correspond to local peaks in the data.
</p>


<h3>Note</h3>

<p>The value of <code>endbehavior</code> acts as follows:
0 is as if the series had runs of <code>halfwidth</code> values of <code>Inf</code>
attached to either end,
1 is as if there were runs of <code>halfwidth</code> values of <code>-Inf</code> attached,
and 2 is as if there were runs of<code>halfwidth</code> values of <code>NA</code> attached.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+max">max</a></code>, <code><a href="base.html#topic+cummax">cummax</a></code>, <code><a href="base.html#topic+pmax">pmax</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.vector(sunspots)
z &lt;- peaks(x, span=51)
plot(x, type="l")
abline(v=which(z), col="red", lty="dashed")
</code></pre>

<hr>
<h2 id='positions'>Positions of signalSeries objects</h2><span id='topic+positions'></span>

<h3>Description</h3>

<p>Access the positions of series objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>positions(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positions_+3A_object">object</code></td>
<td>
<p>an object of class <code>signalSeries</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the positions associated with the input time series: an object of class <code>numericSequence</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seriesData">seriesData</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- signalSeries(1:10, from=pi, by=0.1)
positions(x)
</code></pre>

<hr>
<h2 id='rmvnorm'>Multivariate Normal (Gaussian) Distribution</h2><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>Random generation for the multivariate normal (also called Gaussian) distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm(n, mean=rep(0,d), cov=diag(d), sd, rho, d=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm_+3A_n">n</code></td>
<td>
<p>sample size &ndash; number of random vectors of length d to return (as rows in a matrix).</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_cov">cov</code></td>
<td>
<p>covariance or correlation matrix with d rows and columns.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_d">d</code></td>
<td>
<p>dimension of the multivariate normal.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_mean">mean</code></td>
<td>
<p>vector of length d, or matrix with n rows and d columns.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_rho">rho</code></td>
<td>
<p>scalar, vector, or bdVector of length n, containing correlations for bivariate data. This is ignored if cov is supplied.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_sd">sd</code></td>
<td>
<p>vector of length d, or matrix with n rows and d columns,
containing standard deviations. If supplied, the rows and columns of
cov are multiplied by sd. In particular, if cov is a correlation
matrix and sd is a vector of standard deviations, the result is a
covariance matrix. If sd is a matrix then one row is used for each
observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>random sample ( rmvnorm) for the multivariate normal distribution.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>,<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 5 rows and 2 independent columns 
rmvnorm(5)

## 5 rows and 3 independent columns 
rmvnorm(5, mean=c(9,3,1))

## 2 columns, std. dev. 1, correlation .9 
rmvnorm(5, rho=.9)

## specify variable means and covariance matrix 
rmvnorm(5, mean=c(9,3), cov=matrix(c(4,1,1,2), 2))
</code></pre>

<hr>
<h2 id='seriesData'>Access Data Of series Objects</h2><span id='topic+seriesData'></span><span id='topic++5B+3C-.seriesData'></span><span id='topic+seriesData+3C-'></span>

<h3>Description</h3>

<p>Access the data slot of series objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriesData(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriesData_+3A_object">object</code></td>
<td>
<p>object with which to find data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data slot of object.
</p>


<h3>S3 METHODS</h3>


<dl>
<dt>[&lt;-</dt><dd><p>single level data replacement method.
</p>
<p>Usage: x[1:4] &lt;- 1:4)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>, <code><a href="#topic+asSeriesData">asSeriesData</a></code>, <code><a href="#topic+seriesDataNew">seriesDataNew</a></code>, <code><a href="#topic+seriesDataValid">seriesDataValid</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>, <code><a href="#topic+as.data.frame.signalSeries">as.data.frame.signalSeries</a></code>, <code><a href="#topic+as.matrix.signalSeries">as.matrix.signalSeries</a></code>, <code><a href="#topic+cumsum.signalSeries">cumsum.signalSeries</a></code>, <code><a href="#topic+deltat.signalSeries">deltat.signalSeries</a></code>, <code><a href="#topic+diff.signalSeries">diff.signalSeries</a></code>, <code><a href="#topic+plot.signalSeries">plot.signalSeries</a></code>.</p>

<hr>
<h2 id='seriesDataNew'>Creates template for new seriesData object</h2><span id='topic+seriesDataNew'></span>

<h3>Description</h3>

<p>Creates template for new seriesData object., basically a NULL matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriesDataNew()</code></pre>


<h3>Value</h3>

<p>nULL matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>, <code><a href="#topic+seriesData">seriesData</a></code>, <code><a href="#topic+asSeriesData">asSeriesData</a></code>, <code><a href="#topic+seriesDataValid">seriesDataValid</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>, <code><a href="#topic+as.data.frame.signalSeries">as.data.frame.signalSeries</a></code>, <code><a href="#topic+as.matrix.signalSeries">as.matrix.signalSeries</a></code>, <code><a href="#topic+cumsum.signalSeries">cumsum.signalSeries</a></code>, <code><a href="#topic+deltat.signalSeries">deltat.signalSeries</a></code>, <code><a href="#topic+diff.signalSeries">diff.signalSeries</a></code>, <code><a href="#topic+plot.signalSeries">plot.signalSeries</a></code>.</p>

<hr>
<h2 id='seriesDataValid'>Validates the structure of seriesData object</h2><span id='topic+seriesDataValid'></span>

<h3>Description</h3>

<p>Checks to see if input object is rectangular.</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriesDataValid(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriesDataValid_+3A_object">object</code></td>
<td>
<p>the object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value, TRUE is a valid seriesData object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>, <code><a href="#topic+seriesData">seriesData</a></code>, <code><a href="#topic+asSeriesData">asSeriesData</a></code>, <code><a href="#topic+seriesDataNew">seriesDataNew</a></code>, <code><a href="#topic+signalSeries">signalSeries</a></code>, <code><a href="#topic+as.data.frame.signalSeries">as.data.frame.signalSeries</a></code>, <code><a href="#topic+as.matrix.signalSeries">as.matrix.signalSeries</a></code>, <code><a href="#topic+cumsum.signalSeries">cumsum.signalSeries</a></code>, <code><a href="#topic+deltat.signalSeries">deltat.signalSeries</a></code>, <code><a href="#topic+diff.signalSeries">diff.signalSeries</a></code>, <code><a href="#topic+plot.signalSeries">plot.signalSeries</a></code>.</p>

<hr>
<h2 id='showStructure'>Describe the structure of an object</h2><span id='topic+showStructure'></span>

<h3>Description</h3>

<p>Describe the structure of an object, recursively.</p>


<h3>Usage</h3>

<pre><code class='language-R'>showStructure(x, maxlen = 20, describeAttributes = TRUE,
   short = NULL, prefix = "", attri = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showStructure_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="showStructure_+3A_maxlen">maxlen</code></td>
<td>
<p>integer; if <code>x</code> is a list with more than
<code>maxlen</code> components, only the names are printed.
This may be a vector, in which case the <code>K</code>th element is used
at the <code>K</code>th level of recursion.</p>
</td></tr>
<tr><td><code id="showStructure_+3A_describeattributes">describeAttributes</code></td>
<td>
<p>logical; if <code>FALSE</code> then only the names of
attributes are printed; the structure of the attributes is not shown.</p>
</td></tr>
<tr><td><code id="showStructure_+3A_short">short</code></td>
<td>
<p><code>NULL</code> or logical; this may be used by methods,
to indicate whether to print a shorter description.
It is currently used by <code>bdFrame</code> and <code>bdVector</code> methods
</p>
</td></tr>
<tr><td><code id="showStructure_+3A_prefix">prefix</code></td>
<td>
<p>for internal use in recursive calls.  This is used for
indenting in recursive calls.</p>
</td></tr>
<tr><td><code id="showStructure_+3A_attri">attri</code></td>
<td>
<p>for internal use in recursive calls.  This is <code>TRUE</code>
if the curent object being described is a list of attributes.</p>
</td></tr>
<tr><td><code id="showStructure_+3A_...">...</code></td>
<td>
<p>Additional argument that may be passed to methods;
not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This supports recursive objects, using recursive calls. Each
level of recursion is indented two additional spaces.  List components
are shown with <code>$</code>, slots with <code>@</code>, and attributes with <code>&amp;</code>.</p>


<h3>Value</h3>

<p>This prints a description; it doesn't return anything useful.</p>


<h3>Author(s)</h3>

<p>Tim Hesterberg</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+names">names</a></code>,
<code><a href="utils.html#topic+str">str</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(m=1, n=2)
b &lt;- diag(1:3)
cc &lt;- cbind(a=1:5, b=2:6, c=letters[1:5])
d &lt;- data.frame(cc)
attr(d, "dup.row.names") &lt;- TRUE
e &lt;- ts(1:10, frequency = 4, start = c(1959, 2))
f &lt;- list(a,b=b)
setClass("track", representation(x="numeric", y="numeric"))
g &lt;- new("track", x=1:5, y=1:5)

showStructure(a)
showStructure(b)
showStructure(cc)
showStructure(d)
showStructure(e)
showStructure(f)
showStructure(g)  # prints with @ rather than $
showStructure(list(a=a, b=b))
showStructure(list(cc=cc, d, list(a,e)))
</code></pre>

<hr>
<h2 id='signalSeries'>Constructor function for the signalSeries class</h2><span id='topic+signalSeries'></span><span id='topic+signalSeries-class'></span><span id='topic+as.data.frame.signalSeries'></span><span id='topic+as.matrix.signalSeries'></span><span id='topic+cumsum.signalSeries'></span><span id='topic+deltat.signalSeries'></span><span id='topic+diff.signalSeries'></span><span id='topic+plot.signalSeries'></span>

<h3>Description</h3>

<p>Construct a signalSeries object from positions and data, or return an empty signalSeries object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>signalSeries(data, positions., units, units.position, from=1, by=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signalSeries_+3A_by">by</code></td>
<td>
<p>amount to skip for positions.</p>
</td></tr>
<tr><td><code id="signalSeries_+3A_data">data</code></td>
<td>
<p>variable data, which will be converted to a rectangular object with the as.rectangular function.</p>
</td></tr>
<tr><td><code id="signalSeries_+3A_from">from</code></td>
<td>
<p>starting value of positions.</p>
</td></tr>
<tr><td><code id="signalSeries_+3A_positions.">positions.</code></td>
<td>
<p>numeric or numeric sequence object to use as the time/position values.</p>
</td></tr>
<tr><td><code id="signalSeries_+3A_units">units</code></td>
<td>
<p>units for variable data.</p>
</td></tr>
<tr><td><code id="signalSeries_+3A_units.position">units.position</code></td>
<td>
<p>units for positions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no arguments are supplied, the default (empty)
signalSeries object is returned. Otherwise, a signalSeries object is
created with the given positions and data, and units if they are
supplied. As an alternative to supplying the positions directly, they
can be supplied by giving from and by, in which case the positions are
generated as a numeric sequence with the right length to match the
data.
</p>


<h3>Value</h3>

<p>a <code>signalSeries</code> object with the given data and positions.
</p>


<h3>S3 METHODS</h3>


<dl>
<dt>as</dt><dd><p>s4 style conversion to another class ala as(x, foo) where foo is
any of the following: <code>"character"</code>, <code>"complex"</code>, <code>"data.frame"</code>, <code>"integer"</code>,
<code>"logical"</code>, <code>"matrix"</code>, <code>"numeric"</code>, <code>"vector"</code>.</p>
</dd>
<dt>as.data.frame</dt><dd><p>convert to a <code>data.frame</code>.</p>
</dd>
<dt>as.matrix</dt><dd><p>convert to a matrix.</p>
</dd>
<dt>cumsum</dt><dd><p>cumulative summation over series.</p>
</dd>
<dt>deltat</dt><dd><p>samlig intervals of series.</p>
</dd>
<dt>diff</dt><dd><p>differencing operation applied to the series. Usage: diff(x, ...) where the <code>...</code> are additional arguments
sent directly to the <code>diff</code> function.</p>
</dd>
<dt>plot</dt><dd><p>plots the series.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>.</p>

<hr>
<h2 id='signalSeries-methods'>Methods for class signalSeries in package splus2R</h2><span id='topic+signalSeries-methods'></span><span id='topic+Arith+2CsignalSeries+2CANY-method'></span><span id='topic+Compare+2CsignalSeries+2CANY-method'></span><span id='topic+Logic+2CsignalSeries+2CANY-method'></span><span id='topic+Math+2CsignalSeries-method'></span><span id='topic+Math2+2CsignalSeries-method'></span><span id='topic+Ops+2CsignalSeries+2CANY-method'></span><span id='topic+Summary+2CsignalSeries-method'></span><span id='topic++5B+2CsignalSeries-method'></span><span id='topic+as.numeric+2CsignalSeries-method'></span><span id='topic+as.vector+2CsignalSeries-method'></span><span id='topic+coerce+2Clist+2CsignalSeries-method'></span><span id='topic+coerce+2CsignalSeries+2Cdata.frame-method'></span><span id='topic+coerce+2CsignalSeries+2Ccharacter-method'></span><span id='topic+coerce+2CsignalSeries+2Ccomplex-method'></span><span id='topic+coerce+2CsignalSeries+2Cinteger-method'></span><span id='topic+coerce+2CsignalSeries+2Clogical-method'></span><span id='topic+coerce+2CsignalSeries+2Cmatrix-method'></span><span id='topic+coerce+2CsignalSeries+2Cnumeric-method'></span><span id='topic+coerce+2CsignalSeries+2Cvector-method'></span><span id='topic+dim+2CsignalSeries-method'></span><span id='topic+length+2CsignalSeries-method'></span><span id='topic+mean+2CsignalSeries-method'></span><span id='topic+min+2CsignalSeries-method'></span><span id='topic+ncol+2CsignalSeries-method'></span><span id='topic+plot+2CsignalSeries-method'></span><span id='topic+show+2CsignalSeries-method'></span><span id='topic+sum+2CsignalSeries-method'></span><span id='topic+summary+2CsignalSeries-method'></span>

<h3>Description</h3>

<p>Methods for class <code>signalSeries</code> in package <code>splus2R</code></p>


<h3>Details</h3>

<p>Supported (generic) methods include:
</p>

<dl>
<dt>as</dt><dd><p>Target classes: complex, character, matrix, numeric, logical, integer, vector, and data.frame.
S3 style methods include as.numeric and as.vector.</p>
</dd>
<dt>Arith</dt><dd><p>Arithmetic functions</p>
</dd>
<dt>Compare</dt><dd><p>Comparison functions</p>
</dd>
<dt>Logic</dt><dd><p>Logical functions</p>
</dd>
<dt>Math</dt><dd><p>Math functions</p>
</dd>
<dt>Math2</dt><dd><p>Math2 functions</p>
</dd>
<dt>Ops</dt><dd><p>Ops functions</p>
</dd>
<dt>dim</dt><dd><p>Dimension of series (NULL is returned)</p>
</dd>
<dt>length</dt><dd><p>Length of series</p>
</dd>
<dt>mean</dt><dd><p>Mean of series</p>
</dd>
<dt>min</dt><dd><p>Minimum of series</p>
</dd>
<dt>ncol</dt><dd><p>Number of columns of series (1 is returned)</p>
</dd>
<dt>plot</dt><dd><p>Plot the series</p>
</dd>
<dt>show</dt><dd><p>Display the series</p>
</dd>
<dt>sum</dt><dd><p>Sum the series.</p>
</dd>
<dt>summary</dt><dd><p>Sumamrize the series object</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+numericSequence">numericSequence</a></code>.</p>

<hr>
<h2 id='stdev'>Standard deviation</h2><span id='topic+stdev'></span>

<h3>Description</h3>

<p>Calculates the standard deviation of a series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdev(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdev_+3A_x">x</code></td>
<td>
<p>input series.</p>
</td></tr>
<tr><td><code id="stdev_+3A_...">...</code></td>
<td>
<p>optional arguments sent directly to the <code>colVars</code> function. You can control for example
the removal of NA values prior to analysis via the <code>na.rm</code> argument, and whether or not an unbiased estimate
is returned via the <code>unbiased</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the standard deviation of the input series.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>stdev(c(pi, 1, 3))
</code></pre>

<hr>
<h2 id='subscript2d'>Uniform Rectangular Data Subscripting Function</h2><span id='topic+subscript2d'></span><span id='topic+subscript2dDataFrame'></span><span id='topic+subscript2d.default'></span><span id='topic+subscript2dMatrix'></span>

<h3>Description</h3>

<p>subscript2d is for subscripting matrices and data frames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>subscript2d(x,i,j)
subscript2dMatrix(x,i,j)
subscript2dDataFrame(x,i,j)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subscript2d_+3A_x">x</code></td>
<td>
<p>a matrix or data frame</p>
</td></tr>
<tr><td><code id="subscript2d_+3A_i">i</code></td>
<td>
<p>first (row) subscript.</p>
</td></tr>
<tr><td><code id="subscript2d_+3A_j">j</code></td>
<td>
<p>second (column) subscript.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>subscript2d(x,i,j)</code> is like <code>x[i,j,drop=F]</code>,
except that it allows <code>x[,1]</code> (for example) for atomic vectors as well,
and it always returns an object of the same class as <code>x</code>
(that is, it does not support a drop argument).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
subscript2d(x,3,1)
subscript2d(data.frame(x),3,1)
subscript2d(matrix(x),3,1)
</code></pre>

<hr>
<h2 id='vecnorm'>p-norm of a vector</h2><span id='topic+vecnorm'></span>

<h3>Description</h3>

<p>Computes the p-norm of a vector</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecnorm(x, p=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecnorm_+3A_x">x</code></td>
<td>
<p>the vector whose norm is sought (either numeric or complex).</p>
</td></tr>
<tr><td><code id="vecnorm_+3A_p">p</code></td>
<td>
<p>a number or character string indicating the type of norm desired. Possible values include real number greater or
equal to 1, <code>Inf</code>, or character strings <code>"euclidean"</code> or <code>"maximum"</code>. Default: 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>requested p-norm of input vector.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare 2-norm calculations 
x &lt;- rnorm(100)
sqrt(sum(x*x))
vecnorm(x)

## compare 2-norm of series which sums to Inf. The 
## vecnorm returns a finite value in this case. 
x &lt;- rep(sqrt(.Machine$double.xmax), 4)
sqrt(sum(x*x))
vecnorm(x)

## 1-norm comparison 
sum(abs(x))
vecnorm(x, p=1)

## L-infinity norm comparison 
max(abs(x))
vecnorm(x, p=Inf)
</code></pre>

<hr>
<h2 id='which.na'>Determine Which Values are Missing Values</h2><span id='topic+which.na'></span>

<h3>Description</h3>

<p>Returns an integer vector describing which values in the
input vector, if any, are missing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.na(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.na_+3A_x">x</code></td>
<td>
<p>an R object, which should be of mode <code>"logical"</code>, <code>"numeric"</code>, or <code>"complex"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector describing which values in the
input vector, if any, are missing.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.na">is.na</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A non-zero number divided by zero creates 
## infinity, zero over zero creates a NaN 
weird.values &lt;- c(1/0, -20.9/0, 0/0, NA)

## Produces: 3 4. In this example, the which.na 
## expression and the subscript expression 
## involving is.na should return the same value 
which.na(weird.values)
seq(along=weird.values)[is.na(weird.values)]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
