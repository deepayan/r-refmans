<!DOCTYPE html><html><head><title>Help for package breakfast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {breakfast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#breakfast-package'><p>Breakfast: Methods for Fast Multiple Change-point Detection and Estimation</p></a></li>
<li><a href='#breakfast'><p>Methods for fast multiple change-point detection and estimation</p></a></li>
<li><a href='#dup.merge'><p>Removes duplicates from the candidate set</p></a></li>
<li><a href='#model.ic'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the strengthened Schwarz information criterion</p></a></li>
<li><a href='#model.lp'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning</p></a></li>
<li><a href='#model.sdll'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the Steepest Drop to Low Levels method</p></a></li>
<li><a href='#model.thresh'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence via thresholding</p></a></li>
<li><a href='#plot.breakfast.cpts'><p>Change-points estimated by breakfast</p></a></li>
<li><a href='#print.breakfast.cpts'><p>Change-points estimated by breakfast</p></a></li>
<li><a href='#print.cptmodel'><p>Change-points estimated by solution path generation + model selection methods</p></a></li>
<li><a href='#sol.idetect'><p>Solution path generation via the Isolate-Detect method</p></a></li>
<li><a href='#sol.idetect_seq'><p>Solution path generation using the sequential approach of the Isolate-Detect method</p></a></li>
<li><a href='#sol.not'><p>Solution path generation via the Narrowest-Over-Threshold method</p></a></li>
<li><a href='#sol.tguh'><p>Solution path generation via the Tail-Greedy Unbalanced Haar method</p></a></li>
<li><a href='#sol.wbs'><p>Solution path generation via the Wild Binary Segmentation method</p></a></li>
<li><a href='#sol.wbs2'><p>Solution path generation via the Wild Binary Segmentation 2 method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methods for Fast Multiple Change-Point Detection and Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A developing software suite for multiple change-point detection/estimation (data segmentation) in data sequences.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, Rcpp, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-18 11:37:17 UTC; chen</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Anastasiou [aut],
  Yining Chen [aut, cre],
  Haeran Cho [aut],
  Piotr Fryzlewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yining Chen &lt;y.chen101@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-18 13:45:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='breakfast-package'>Breakfast: Methods for Fast Multiple Change-point Detection and Estimation</h2><span id='topic+breakfast-package'></span>

<h3>Description</h3>

<p>A developing software suite for multiple change-point detection/estimation (data segmentation) in data sequences.
</p>


<h3>Details</h3>

<p>The current version implements the Gaussian mean-shift model, 
in which the data are assumed to be a piecewise-constant signal observed with i.i.d. Gaussian noise. 
Change-point detection in breakfast is carried out in two stages: 
(i) computation of a solution path, and (ii) model selection along the path. 
A variety of solution path and model selection methods are included, which can be accessed individually,
or through <a href="#topic+breakfast">breakfast</a>.
Currently supported solution path methods are: <a href="#topic+sol.idetect">sol.idetect</a>, <a href="#topic+sol.idetect_seq">sol.idetect_seq</a>,
<a href="#topic+sol.wbs">sol.wbs</a>, <a href="#topic+sol.wbs2">sol.wbs2</a>, <a href="#topic+sol.not">sol.not</a> and <a href="#topic+sol.tguh">sol.tguh</a>.
</p>
<p>Currently supported model selection methods are: <a href="#topic+model.ic">model.ic</a>, <a href="#topic+model.lp">model.lp</a>,
<a href="#topic+model.sdll">model.sdll</a> <a href="#topic+model.thresh">model.thresh</a>.
</p>
<p>Check back future versions for more change-point models and further methods.
</p>


<h3>Author(s)</h3>


<ul>
<li> <p><a href="https://www.andreasanastasiou-statistics.com/">Andreas Anastasiou</a>
</p>
</li>
<li> <p><a href="http://personal.lse.ac.uk/cheny100/">Yining Chen</a>
</p>
</li>
<li> <p><a href="https://sites.google.com/view/haeran-cho/">Haeran Cho</a>
</p>
</li>
<li> <p><a href="http://stats.lse.ac.uk/fryzlewicz/">Piotr Fryzlewicz</a>
</p>
</li></ul>

<p>We would like to thank Shakeel Gavioli-Akilagun, Anica Kostic, Shuhan Yang and Christine Yuen for their comments and suggestions that helped improve this package.
</p>


<h3>See Also</h3>

<p><code>browseVignettes(package = "breakfast")</code> contains a detailed comparative simulation study of various methods 
implemented in <a href="#topic+breakfast">breakfast</a> for the Gaussian mean-shift model.
</p>

<hr>
<h2 id='breakfast'>Methods for fast multiple change-point detection and estimation</h2><span id='topic+breakfast'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in a data sequence,
which is modelled as a piecewise-constant function plus i.i.d. Gaussian noise. 
This is carried out via a two-stage procedure combining solution path generation and model selection methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakfast(x, solution.path = NULL, model.selection = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breakfast_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="breakfast_+3A_solution.path">solution.path</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of solution path generating method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each solution path generating method via <code>sol.[method]</code>, see below.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, which are: <code>("idetect", "ic")</code>, <code>("idetect_seq", "thresh")</code>, <code>("not", "ic")</code>, <code>("tguh", "lp")</code>, <code>("wbs", "ic")</code> and <code>("wbs2", "sdll")</code>.
If <code>solution.path</code> is specified but <code>model.selection</code> is not, we return the output from the specified <code>solution.path</code> methods combined with the suggested model selection methods (respectively) as above.
</p>

<ul>
<li><p>&quot;idetect&quot; IDetect, see <a href="#topic+sol.idetect">sol.idetect</a> 
</p>
</li>
<li><p>&quot;idetect_seq&quot; Sequential IDetect, see <a href="#topic+sol.idetect_seq">sol.idetect_seq</a> 
</p>
</li>
<li><p>&quot;not&quot; Narrowest-Over-Threshold, see <a href="#topic+sol.not">sol.not</a>
</p>
</li>
<li><p>&quot;tguh&quot; Tail-Greedy Unbalanced Haar, see <a href="#topic+sol.tguh">sol.tguh</a>
</p>
</li>
<li><p>&quot;wbs&quot; Wild Binary Segmentation, see <a href="#topic+sol.wbs">sol.wbs</a>
</p>
</li>
<li><p>&quot;wbs2&quot; Wild Binary Segmentation 2, see <a href="#topic+sol.wbs2">sol.wbs2</a>
</p>
</li>
<li><p>&quot;all&quot; All of the above 
</p>
</li></ul>
</td></tr>
<tr><td><code id="breakfast_+3A_model.selection">model.selection</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of model selection method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each model selection method via <code>model.[method]</code>, see below.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, which are: <code>("idetect", "ic")</code>, <code>("idetect_seq", "thresh")</code>, <code>("not", "ic")</code>, <code>("tguh", "lp")</code>, <code>("wbs", "ic")</code> and <code>("wbs2", "sdll")</code>.
If <code>model.selection</code> is specified but <code>solution.path</code> is not, we return the output from the specified <code>model.selection</code> methods combined with the suggested solution path methods (respectively) as above.
</p>

<ul>
<li><p>&quot;ic&quot; Strengthened Schwarz information criterion, see <a href="#topic+model.ic">model.ic</a>
</p>
</li>
<li><p>&quot;lp&quot; Localised pruning, see <a href="#topic+model.lp">model.lp</a>
</p>
</li>
<li><p>&quot;sdll&quot; Steepest Drop to Low Levels method, see <a href="#topic+model.sdll">model.sdll</a>
</p>
</li>
<li><p>&quot;thresh&quot; Thresholding, see <a href="#topic+model.thresh">model.thresh</a>
</p>
</li>
<li><p>&quot;all&quot; All of the above 
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the vignette for tips/suggestions/examples of using the breakfast package.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>breakfast.cpts</code>, which contains the following fields:
</p>

<ul>
<li><p>x Input vector <code>x</code>
</p>
</li>
<li><p>cptmodel.list A list containing S3 objects of class <code>cptmodel</code>; each contains the following fields:
</p>

<ul>
<li><p>solution.path The solution path method used
</p>
</li>
<li><p>model.selection The model selection method used to return the final change-point estimators object
</p>
</li>
<li><p>no.of.cpt The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>
</p>
</li>
<li><p>cpts The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals
</p>
</li>
<li><p>est An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2019). Detecting multiple generalized change-points by isolating single ones. <em>arXiv preprint arXiv:1901.10852</em>.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>
<p>H. Cho &amp; C. Kirch (2021) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>arXiv preprint arXiv:1910.12486</em>.
</p>
<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>
<p>P. Fryzlewicz (2020). Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>To appear in Journal of the Korean Statistical Society</em>.
</p>
<p>P. Fryzlewicz (2018). Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46(6B), 3390&ndash;3421.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f)) * .5
breakfast(x)
</code></pre>

<hr>
<h2 id='dup.merge'>Removes duplicates from the candidate set</h2><span id='topic+dup.merge'></span>

<h3>Description</h3>

<p>Removes duplicates from the candidate set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.merge(cands)
</code></pre>

<hr>
<h2 id='model.ic'>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the strengthened Schwarz information criterion</h2><span id='topic+model.ic'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence via the sSIC (strengthened Schwarz information criterion) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.ic(cptpath.object, alpha = 1.01, q.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.ic_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.ic_+3A_alpha">alpha</code></td>
<td>
<p>The parameter associated with the sSIC. The default value is 1.01. Note that the SIC is recovered when alpha = 1.</p>
</td></tr>
<tr><td><code id="model.ic_+3A_q.max">q.max</code></td>
<td>
<p>The maximum number of change-points allowed. If nothing or <code>NULL</code> is provided, the default value of <code>min(100, n/log(n))</code> (rounded to an integer) will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model selection method for algorithms that produce nested solution path is described in 
&quot;Wild binary segmentation for multiple change-point detection&quot;, P. Fryzlewicz (2014), The Annals of Statitics, 42: 2243&ndash;2281.
The corresponding description for those that produce non-nested solution set can be found in 
&quot;Narrowest-over-threshold detection of multiple change points and change-point-like features&quot;, R. Baranowski, Y. Chen and P. Fryzlewicz (2019), Journal of Royal Statistical Society: Series B, 81(3), 649&ndash;672.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"ic"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 100), rep(0, 100)) + rnorm(300)
model.ic(sol.wbs(x))
model.ic(sol.not(x))
</code></pre>

<hr>
<h2 id='model.lp'>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning</h2><span id='topic+model.lp'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning method, which performs a Schwarz criterion-based model selection on the given candidate set in a localised way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.lp(
  cptpath.object,
  min.d = 5,
  penalty = c("log", "polynomial"),
  pen.exp = 1.01,
  do.thr = TRUE,
  th.const = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.lp_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.lp_+3A_min.d">min.d</code></td>
<td>
<p>A number specifying the minimal spacing between change points; <code>min.d = 5</code> by default</p>
</td></tr>
<tr><td><code id="model.lp_+3A_penalty">penalty</code></td>
<td>
<p>A string specifying the type of penalty term to be used in Schwarz criterion; possible values are:
</p>

<ul>
<li><p><code>"log"</code> Use <code>penalty = log(length(x))^pen.exp</code>
</p>
</li>
<li><p><code>"polynomial"</code> Use <code>penalty = length(x)^pen.exp</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="model.lp_+3A_pen.exp">pen.exp</code></td>
<td>
<p>Exponent for the penalty term (see <code>penalty</code>)</p>
</td></tr>
<tr><td><code id="model.lp_+3A_do.thr">do.thr</code></td>
<td>
<p>If <code>do.thr = TRUE</code>, mild threshoding on the CUSUM test statistics is performed after internal standardisation step in order to &quot;pre-prune down&quot; the candidates</p>
</td></tr>
<tr><td><code id="model.lp_+3A_th.const">th.const</code></td>
<td>
<p>A constant multiplied to <code>sqrt(2*log(length(x)))</code> to form a mild threshold; if not supplied, a default value (<code>0.5*</code> a value suggested in Fryzlewicz (2020) is used,
see <code>th.const</code> in <code><a href="#topic+model.sdll">model.sdll</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further information can be found in Cho and Kirch (2021).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"lp"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Cho &amp; C. Kirch (2021) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>arXiv preprint arXiv:1910.12486</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f)) * .5
model.lp(sol.not(x))
</code></pre>

<hr>
<h2 id='model.sdll'>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the Steepest Drop to Low Levels method</h2><span id='topic+model.sdll'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence via the Steepest Drop to Low Levels method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.sdll(
  cptpath.object,
  sigma = stats::mad(diff(cptpath.object$x)/sqrt(2)),
  universal = TRUE,
  th.const = NULL,
  th.const.min.mult = 0.3,
  lambda = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.sdll_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. In particular, SDLL model selection should work well when <code>cptpath.object</code> is an object returned by the <code>sol.wbs2</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_sigma">sigma</code></td>
<td>
<p>An estimate of the standard deviation of the noise in the data <code>cptpath.object$x</code>. Can be a functional of <code>cptpath.object$x</code> or a specific value if known. The default is the Median Absolute Deviation of the vector <code>diff(cptpath.object$x)/sqrt(2)</code>, tuned to the Gaussian distribution. Note that <code>model.sdll</code> works particularly well when the noise is i.i.d. Gaussian.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_universal">universal</code></td>
<td>
<p>If <code>TRUE</code>, then the threshold that decides if there are any change-points is chosen automatically, so that the probability of type-I error (i.e. indicating change-points if there are none) is approximately <code>1 - alpha</code> when the number <code>M</code> of intervals drawn in the <code>sol.wbs2</code> solution path routine is 1000. If <code>FALSE</code>, then <code>th.const</code> must be specified.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_th.const">th.const</code></td>
<td>
<p>Only relevant if <code>universal == FALSE</code>; in that case a numerical value must be provided. Used to create the threshold (applicable to the CUSUM magnitudes stored in <code>cptpath.object</code>) that decides if there are any change-points in the mean vector; that threshold is then <code>th.const * sqrt(2 * log(n)) * sigma</code>, where <code>n</code> is the length of the data vector <code>cptpath.object$x</code>.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_th.const.min.mult">th.const.min.mult</code></td>
<td>
<p>A fractional multiple of the threshold, used to decide the lowest magnitude of CUSUMs from <code>cptpath.object</code> still considered by the SDLL model selection criterion as potentially change-point-carrying.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_lambda">lambda</code></td>
<td>
<p>Only relevant if <code>universal == TRUE</code>; can be set to 0.9 or 0.95. The approximate probability of not detecting any change-points if the truth does not contain any, when the number <code>M</code> of intervals drawn in the <code>sol.wbs2</code> solution path routine is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Steepest Drop to Low Levels method is described in 
&quot;Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection&quot;, P. Fryzlewicz (2020), Journal of the Korean Statistical Society, 49, 1027&ndash;1070.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"sdll"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2020). Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49, 1027&ndash;1070.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f))
model.sdll(sol.wbs2(x))
</code></pre>

<hr>
<h2 id='model.thresh'>Estimating change-points in the piecewise-constant mean of a noisy data sequence via thresholding</h2><span id='topic+model.thresh'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence via thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.thresh(
  cptpath.object,
  sigma = stats::mad(diff(cptpath.object$x)/sqrt(2)),
  th_const = 1.15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.thresh_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>sols.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.thresh_+3A_sigma">sigma</code></td>
<td>
<p>An estimate of the standard deviation of the noise in the data <code>cptpath.object$x</code>. Can be a functional of <code>cptpath.object$x</code> or a specific value if known. The default is the Median Absolute Deviation of the vector <code>diff(cptpath.object$x)/sqrt(2)</code>, tuned to the Gaussian distribution. Note that <code>model.thresh</code> works particularly well when the noise is i.i.d. Gaussian.</p>
</td></tr>
<tr><td><code id="model.thresh_+3A_th_const">th_const</code></td>
<td>
<p>A positive real number with default value equal to 1. It is used to define the threshold for the detection process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"thresh"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f))
model.thresh(sol.idetect_seq(x))
</code></pre>

<hr>
<h2 id='plot.breakfast.cpts'>Change-points estimated by breakfast</h2><span id='topic+plot.breakfast.cpts'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>breakfast.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'breakfast.cpts'
plot(x, display.data = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.breakfast.cpts_+3A_x">x</code></td>
<td>
<p>a <code>breakfast.cpts</code> object</p>
</td></tr>
<tr><td><code id="plot.breakfast.cpts_+3A_display.data">display.data</code></td>
<td>
<p>if <code>display.data = TRUE</code>, change-point estimators are plotted against the data by method.
If <code>display.data = FALSE</code>, only the estimators are plotted; this option is recommended when <code>length(x)</code> is large.</p>
</td></tr>
<tr><td><code id="plot.breakfast.cpts_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
plot(breakfast(x, solution.path = 'all', model.selection = 'all'), display.data = TRUE)
plot(breakfast(x), display.data = FALSE)
</code></pre>

<hr>
<h2 id='print.breakfast.cpts'>Change-points estimated by breakfast</h2><span id='topic+print.breakfast.cpts'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>breakfast.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'breakfast.cpts'
print(x, by = c("method", "estimator"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.breakfast.cpts_+3A_x">x</code></td>
<td>
<p>a <code>breakfast.cpts</code> object</p>
</td></tr>
<tr><td><code id="print.breakfast.cpts_+3A_by">by</code></td>
<td>
<p>if <code>by = 'method'</code>, change-point estimators are printed by method;
if <code>by = 'estimator'</code>, each change-point estimator is printed with the methods that detect it.</p>
</td></tr>
<tr><td><code id="print.breakfast.cpts_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
print(breakfast(x, solution.path = 'all', model.selection = 'all'), by = 'method')
print(breakfast(x), by = 'estimator')
</code></pre>

<hr>
<h2 id='print.cptmodel'>Change-points estimated by solution path generation + model selection methods</h2><span id='topic+print.cptmodel'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>cptmodel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cptmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cptmodel_+3A_x">x</code></td>
<td>
<p>a <code>cptmodel</code> object</p>
</td></tr>
<tr><td><code id="print.cptmodel_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
print(model.ic(sol.idetect(x)))
</code></pre>

<hr>
<h2 id='sol.idetect'>Solution path generation via the Isolate-Detect method</h2><span id='topic+sol.idetect'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Isolate-Detect (ID) method.
It is developed to be used with the sdll and information criterion (ic) model selection rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.idetect(x, thr_ic = 0.9, points = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.idetect_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed.</p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_thr_ic">thr_ic</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is used to create the solution path. The lower the value, the larger the solution path vector.</p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, as described in the Isolate-Detect methodology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Isolate-Detect method and its algorithm is described in 
&quot;Detecting multiple generalized change-points by isolating single ones&quot;, A. Anastasiou &amp; P. Fryzlewicz (2021), Metrika, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;idetect&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2021). Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.idetect(r3)
</code></pre>

<hr>
<h2 id='sol.idetect_seq'>Solution path generation using the sequential approach of the Isolate-Detect method</h2><span id='topic+sol.idetect_seq'></span>

<h3>Description</h3>

<p>This function uses the Isolate-Detect method in its original sequential way in order to create
the solution path. It is developed to be used with the thresholding model selection rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.idetect_seq(x, points = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.idetect_seq_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.idetect_seq_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, as described in the Isolate-Detect methodology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Isolate-Detect method and its algorithm is described in 
&quot;Detecting multiple generalized change-points by isolating single ones&quot;, A. Anastasiou &amp; P. Fryzlewicz (2021), Metrika, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;idetect_seq&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2021). Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.idetect_seq(r3)
</code></pre>

<hr>
<h2 id='sol.not'>Solution path generation via the Narrowest-Over-Threshold method</h2><span id='topic+sol.not'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Narrowest-Over-Threshold (NOT) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.not(x, M = 10000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.not_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.not_+3A_m">M</code></td>
<td>
<p>The maximum number of all data sub-samples at the beginning of the algorithm. The default is
<code>M = 10000</code></p>
</td></tr>
<tr><td><code id="sol.not_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>When drawing the sub-intervals, whether to use a systematic (and fixed) or random scheme. The default is <code>systematic.intervals = TRUE</code></p>
</td></tr>
<tr><td><code id="sol.not_+3A_seed">seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Narrowest-Over-Threshold method and its algorithm is described in 
&quot;Narrowest-over-threshold detection of multiple change points and change-point-like features&quot;, R. Baranowski, Y. Chen and P. Fryzlewicz (2019), Journal of Royal Statistical Society: Series B, 81(3), 649&ndash;672.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>FALSE</code>, i.e., the change-point outputs are not nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code> for each threshold level (in the decreasing order), arranged in the form of a list of lists</p>
</td></tr>
<tr><td><code>solution.set.th</code></td>
<td>
<p>A list that contains threshold levels corresponding to the detections in <code>solution.set</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column resulted from applying NOT to all threshold levels. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows reflect the strength of each detection in decreasing order. To avoid repetition, each possible location would appear at most once in the matrix (with the sub-interval that carries its highest possible strength)</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;not&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>,  <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.not(r3)
</code></pre>

<hr>
<h2 id='sol.tguh'>Solution path generation via the Tail-Greedy Unbalanced Haar method</h2><span id='topic+sol.tguh'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Tail-Greedy Unbalanced Haar method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.tguh(x, p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.tguh_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.tguh_+3A_p">p</code></td>
<td>
<p>Specifies the number of region pairs merged 
in each pass through the data, as the proportion of all remaining region pairs. The default is
<code>p = 0.01</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tail-Greedy Unbalanced Haar decomposition algorithm is described in 
&quot;Tail-greedy bottom-up data decompositions and fast multiple change-point 
detection&quot;, P. Fryzlewicz (2018), The Annals of Statistics, 46, 3390&ndash;3421.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;tguh&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2018). Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46, 3390&ndash;3421.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.tguh(r3)
</code></pre>

<hr>
<h2 id='sol.wbs'>Solution path generation via the Wild Binary Segmentation method</h2><span id='topic+sol.wbs'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Wild Binary Segmentation (WBS) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.wbs(x, M = 10000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.wbs_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_m">M</code></td>
<td>
<p>The maximum number of all data sub-samples at the beginning of the algorithm. The default is
<code>M = 10000</code></p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>When drawing the sub-intervals, whether to use a systematic (and fixed) or random scheme. The default is <code>systematic.intervals = TRUE</code></p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_seed">seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wild Binary Segmentation algorithm is described in 
&quot;Wild binary segmentation for multiple change-point detection&quot;, P. Fryzlewicz (2014), The Annals of Statistics, 42: 2243&ndash;2281.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;wbs&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.wbs(r3)
</code></pre>

<hr>
<h2 id='sol.wbs2'>Solution path generation via the Wild Binary Segmentation 2 method</h2><span id='topic+sol.wbs2'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Wild Binary Segmentation 2 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.wbs2(x, M = 1000, systematic.intervals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.wbs2_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed.</p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_m">M</code></td>
<td>
<p>The maximum number of data sub-samples drawn at each recursive stage of the algorithm. The default is
<code>M = 1000</code>. Setting <code>M = 0</code> executes the standard binary segmentation.</p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>Whether data sub-intervals for CUSUM computation are drawn systematically (TRUE; start- and end-points taken from an approximately equispaced grid) or randomly (FALSE; obtained uniformly with replacement). The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wild Binary Segmentation 2 algorithm is described in 
&quot;Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection&quot;, P. Fryzlewicz (2020), Journal of the Korean Statistical Society, 49, 1027-1070.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr></table>
<p>fmax
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;wbs2&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2020). Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49, 1027-1070.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.wbs2(r3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
