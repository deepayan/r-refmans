<!DOCTYPE html><html><head><title>Help for package breakfast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {breakfast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#breakfast-package'><p>Breakfast: Methods for Fast Multiple Change-point Detection and Estimation</p></a></li>
<li><a href='#breakfast'><p>Methods for fast detection of multiple change-points</p></a></li>
<li><a href='#model.fixednum'><p>Estimate the location of change-points when the number of them is fixed</p></a></li>
<li><a href='#model.gsa'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence with auto-regressive noise via gappy Schwarz algorithm</p></a></li>
<li><a href='#model.ic'><p>Estimating change-points or change-point-type features in the mean of a noisy data sequence via the strengthened Schwarz information criterion</p></a></li>
<li><a href='#model.lp'><p>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning</p></a></li>
<li><a href='#model.sdll'><p>Estimating change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via the Steepest Drop to Low Levels method</p></a></li>
<li><a href='#model.thresh'><p>Estimating change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via thresholding</p></a></li>
<li><a href='#plot.breakfast.cpts'><p>Change-points estimated by the &quot;breakfast&quot; routine</p></a></li>
<li><a href='#print.breakfast.cpts'><p>Change-points estimated by the &quot;breakfast&quot; routine</p></a></li>
<li><a href='#print.cptmodel'><p>Change-points estimated by solution path generation + model selection methods</p></a></li>
<li><a href='#sol.idetect'><p>Solution path generation via the Isolate-Detect method</p></a></li>
<li><a href='#sol.idetect_seq'><p>Solution path generation using the sequential approach of the Isolate-Detect method</p></a></li>
<li><a href='#sol.not'><p>Solution path generation via the Narrowest-Over-Threshold method</p></a></li>
<li><a href='#sol.tguh'><p>Solution path generation via the Tail-Greedy Unbalanced Haar method</p></a></li>
<li><a href='#sol.wbs'><p>Solution path generation via the Wild Binary Segmentation method</p></a></li>
<li><a href='#sol.wbs2'><p>Solution path generation via the Wild Binary Segmentation 2 method</p></a></li>
<li><a href='#sol.wcm'><p>Solution path generation via the Wild Contrast Maximisation method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methods for Fast Multiple Change-Point/Break-Point Detection and
Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A developing software suite for multiple change-point and change-point-type feature detection/estimation (data segmentation) in data sequences.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, Rcpp, ggplot2, splines</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-26 14:47:15 UTC; CHENY100</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Anastasiou [aut],
  Yining Chen [aut, cre],
  Haeran Cho [aut],
  Piotr Fryzlewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yining Chen &lt;y.chen101@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-26 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='breakfast-package'>Breakfast: Methods for Fast Multiple Change-point Detection and Estimation</h2><span id='topic+breakfast-package'></span>

<h3>Description</h3>

<p>A developing software suite for multiple change-point detection/estimation (data segmentation) in data sequences.
</p>


<h3>Details</h3>

<p>The current version implements methods for detecting changes in the data sequence modelled as (i) a piecewise-constant function plus i.i.d. Gaussian noise, 
(ii) a piecewise-constant function plus autoregressive time series,  
(iii) a piecewise-linear and continuous function plus i.i.d. Gaussian noise, and
(iv) a piecewise-linear and discontinuous function plus i.i.d. Gaussian noise.
This is carried out via a two-stage procedure combining solution path generation and model selection methodologies.
Change-point detection in breakfast is carried out in two stages, first the computation of a solution path, followed by a model selection step along the path. 
A variety of solution path and model selection methods are included, which can be accessed individually,
or through <a href="#topic+breakfast">breakfast</a>.
Currently supported solution path methods are: <a href="#topic+sol.idetect">sol.idetect</a>, <a href="#topic+sol.idetect_seq">sol.idetect_seq</a>,
<a href="#topic+sol.wbs">sol.wbs</a>, <a href="#topic+sol.wbs2">sol.wbs2</a>, <a href="#topic+sol.not">sol.not</a>, <a href="#topic+sol.tguh">sol.tguh</a> and <a href="#topic+sol.wcm">sol.wcm</a>.
</p>
<p>Currently supported model selection methods are: <a href="#topic+model.ic">model.ic</a>, <a href="#topic+model.lp">model.lp</a>,
<a href="#topic+model.sdll">model.sdll</a>, <a href="#topic+model.thresh">model.thresh</a> and <a href="#topic+model.gsa">model.gsa</a>.
</p>
<p>Check back future versions for more change-point models and the corresponding methods.
</p>


<h3>Author(s)</h3>


<ul>
<li> <p><a href="https://www.andreasanastasiou-statistics.com/">Andreas Anastasiou</a>
</p>
</li>
<li> <p><a href="http://personal.lse.ac.uk/cheny100/">Yining Chen</a>
</p>
</li>
<li> <p><a href="https://sites.google.com/view/haeran-cho/">Haeran Cho</a>
</p>
</li>
<li> <p><a href="http://stats.lse.ac.uk/fryzlewicz/">Piotr Fryzlewicz</a>
</p>
</li></ul>

<p>We would like to thank Shakeel Gavioli-Akilagun, Anica Kostic, Shuhan Yang and Christine Yuen for their comments and suggestions that helped improve this package.
</p>


<h3>See Also</h3>

<p><code>browseVignettes(package = "breakfast")</code> contains a detailed comparative simulation study of various methods 
implemented in <a href="#topic+breakfast">breakfast</a> for the models (i), (iii) and (iv).
</p>

<hr>
<h2 id='breakfast'>Methods for fast detection of multiple change-points</h2><span id='topic+breakfast'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in a univariate data sequence,
which is modelled as (i) a piecewise-constant function plus i.i.d. Gaussian noise, 
(ii) a piecewise-constant function plus autoregressive time series,  
(iii) a piecewise-linear and continuous function plus i.i.d. Gaussian noise, or
(iv) a piecewise-linear and discontinuous function plus i.i.d. Gaussian noise.
This is carried out via a two-stage procedure combining solution path generation and model selection methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakfast(
  x,
  type = c("const", "lin.cont", "lin.discont"),
  solution.path = NULL,
  model.selection = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breakfast_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="breakfast_+3A_type">type</code></td>
<td>
<p>The type of change-point models fitted to the data; currently supported models are: piecewise constant signals (<code>type = "const"</code>, chosen by default), piecewise linear and continuous signals (<code>type = "lin.cont"</code>) and piecewise linear and discontinuous signals (<code>type = "lin.discont"</code>).</p>
</td></tr>
<tr><td><code id="breakfast_+3A_solution.path">solution.path</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of solution path generating method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each solution path generating method via <code>sol.[method]</code>.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, which depends on <code>type</code> as below:
</p>
<p>When <code>type = "const"</code>: <code>("idetect", "ic")</code>, <code>("idetect_seq", "thresh")</code>, 
<code>("not", "ic")</code>, <code>("tguh", "lp")</code>, <code>("wbs", "ic")</code>, <code>("wbs2", "sdll")</code> and <code>("wcm", "gsa")</code>.
</p>
<p>When <code>type = "lin.cont"</code> or <code>type = "lin.discont"</code>: <code>("idetect_seq", "thresh")</code>, 
<code>("not", "ic")</code> and <code>("idetect", "sdll")</code>.
</p>
<p>If <code>solution.path</code> is specified but <code>model.selection</code> is not, we return the output from the specified <code>solution.path</code> methods combined with the suggested model selection methods (respectively) as above.
</p>

<dl>
<dt>&quot;idetect&quot;</dt><dd><p> IDetect, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+sol.idetect">sol.idetect</a></p>
</dd> 
<dt>&quot;idetect_seq&quot;</dt><dd><p> Sequential IDetect, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+sol.idetect_seq">sol.idetect_seq</a></p>
</dd> 
<dt>&quot;not&quot;</dt><dd><p> Narrowest-Over-Threshold, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+sol.not">sol.not</a></p>
</dd>
<dt>&quot;tguh&quot;</dt><dd><p> Tail-Greedy Unbalanced Haar, supporting <code>type = "const"</code>, see <a href="#topic+sol.tguh">sol.tguh</a></p>
</dd>
<dt>&quot;wbs&quot;</dt><dd><p> Wild Binary Segmentation, supporting <code>type = "const"</code>, see <a href="#topic+sol.wbs">sol.wbs</a></p>
</dd>
<dt>&quot;wbs2&quot;</dt><dd><p> Wild Binary Segmentation 2, supporting <code>type = "const"</code>, see <a href="#topic+sol.wbs2">sol.wbs2</a></p>
</dd>
<dt>&quot;wcm&quot;</dt><dd><p> Wild Contrast Maximisation, supporting <code>type = "const"</code> in combination with <a href="#topic+model.gsa">model.gsa</a> handling model (ii), see <a href="#topic+sol.wcm">sol.wcm</a></p>
</dd>
<dt>&quot;all&quot;</dt><dd><p> All of the above that support the <code>type</code> </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="breakfast_+3A_model.selection">model.selection</code></td>
<td>
<p>A string or a vector of strings containing the name(s) of model selection method(s);
if individual methods are accessed via this option, default tuning parameters are used. 
Alternatively, you can directly access each model selection method via <code>model.[method]</code>.
If both <code>solution.path</code> and <code>model.selection</code> are unspecified, we return the output from the suggested combinations based on their performance, see <code>solution.path</code>.
If <code>model.selection</code> is specified but <code>solution.path</code> is not, we return the output from the specified <code>model.selection</code> methods combined with the suggested solution path methods (respectively).
Not all <code>solution.path</code> methods are supported by all <code>model.selection</code> methods; check the individual functions for more information.
</p>

<dl>
<dt>&quot;ic&quot;</dt><dd><p> Strengthened Schwarz information criterion, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+model.ic">model.ic</a></p>
</dd>
<dt>&quot;lp&quot;</dt><dd><p> Localised pruning, supporting <code>type = "const"</code>, see <a href="#topic+model.lp">model.lp</a></p>
</dd>
<dt>&quot;sdll&quot;</dt><dd><p> Steepest Drop to Low Levels method, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+model.sdll">model.sdll</a></p>
</dd>
<dt>&quot;thresh&quot;</dt><dd><p> Thresholding, supporting <code>type = "const", "lin.cont", "lin.discont"</code>, see <a href="#topic+model.thresh">model.thresh</a></p>
</dd>
<dt>&quot;gsa&quot;</dt><dd><p> gappy Schwarz algorithm, supporting <code>type = "const"</code> in combination with <a href="#topic+sol.wcm">sol.wcm</a> handling model (ii), see <a href="#topic+model.gsa">model.gsa</a></p>
</dd>
<dt>&quot;all&quot;</dt><dd><p> All of the above that support the given <code>type</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Please also take a look at the vignette for tips/suggestions/examples of using the breakfast package.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>breakfast.cpts</code>, which contains the following fields:
</p>

<dl>
<dt>x</dt><dd><p> Input vector <code>x</code></p>
</dd>
<dt>cptmodel.list</dt><dd><p> A list containing S3 objects of class <code>cptmodel</code>; each contains the following fields:</p>
</dd>
</dl>

<dl>
<dt>solution.path</dt><dd><p> The solution path method used</p>
</dd>
<dt>model.selection</dt><dd><p> The model selection method used to return the final change-point estimators object</p>
</dd>
<dt>no.of.cpt</dt><dd><p> The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</dd>
<dt>cpts</dt><dd><p> The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</dd>
<dt>est</dt><dd><p> An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</dd>
</dl>




<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2022) Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, 85(2), 141&ndash;174.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019) Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>
<p>H. Cho &amp; C. Kirch (2022) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>Annals of the Institute of Statistical Mathematics</em>, 74(4), 653&ndash;684.
</p>
<p>H. Cho &amp; P. Fryzlewicz (2024) Multiple change point detection under serial dependence: Wild contrast maximisation and gappy Schwarz algorithm. <em>Journal of Time Series Analysis</em>, 45(3): 479&ndash;494.
</p>
<p>P. Fryzlewicz (2014) Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>
<p>P. Fryzlewicz (2018) Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46(6B), 3390&ndash;3421.
</p>
<p>P. Fryzlewicz (2020) Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49(4), 1027&ndash;1070.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f)) * .5
breakfast(x)
</code></pre>

<hr>
<h2 id='model.fixednum'>Estimate the location of change-points when the number of them is fixed</h2><span id='topic+model.fixednum'></span>

<h3>Description</h3>

<p>Return a solution with the given number of change-points or change-point-type features from the solution path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.fixednum(cptpath.object, fixednum = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.fixednum_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.fixednum_+3A_fixednum">fixednum</code></td>
<td>
<p>The number of change-points or change-point-type features</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model selection method which returns results with a given number of change-points or change-point-type features. If there are 
multiple such elements on the solution path, the one with the smaller residual sum of squares will be returned. On the other hand,
if no such element exists, an empty set (i.e. with no change-points) will be returned.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The model type used, inherited from the given <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point or change-point-type feature estimators object, here its value is <code>"ic"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated features in the mean of the vector <code>cptpath.object$x</code> based on the given <code>type</code> of the model</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated features in the mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean or constant-slope intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the mean of the vector <code>cptpath.object$x</code>; for piecewise-constant signals, the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points; 
for piecewise-linear but discontinuous signals, the values are the estimated linear trend (replicated a suitable number of times) between each pair of consecutive detected change of slopes; 
for piecewise-linear and continuous signals, it is similar to the previous case but with the continuity constraint enforced, which envolves solving a global least squares problem.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+sol.wcm">sol.wcm</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 100), rep(0, 100)) + rnorm(300)
model.fixednum(sol.wbs(x),2)
model.fixednum(sol.not(x),2)
</code></pre>

<hr>
<h2 id='model.gsa'>Estimating change-points in the piecewise-constant mean of a noisy data sequence with auto-regressive noise via gappy Schwarz algorithm</h2><span id='topic+model.gsa'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence with auto-regressive noise via gappy Schwarz algorithm
from a candidate model sequence generated by <code>sol.wcm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.gsa(cptpath.object, p.max = 10, pen = log(length(cptpath.object$x))^1.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.gsa_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.wcm</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.gsa_+3A_p.max">p.max</code></td>
<td>
<p>The maximum AR order. The default is <code>p.max = 10</code>.</p>
</td></tr>
<tr><td><code id="model.gsa_+3A_pen">pen</code></td>
<td>
<p>Penalty used for the Schwarz criterion. <code>log(length(cptpath.object$x))^1.01</code> is used as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the largest to the smallest (i.e. empty) candidate models generated by <code>sol.wcm</code>, 
gappy Schwarz algorithm locally evaluates the Schwarz criterion (SC, under piecewise constant signal + AR(p) noise model, with the AR order p to be determined adaptively) and its modification SC0
on each segment determined by the next smallest candidate model. It selects the larger model as the final model if over each segment, all newly introduced estimators are deemed &lsquo;significant&rsquo; according to SC and SC0; see Cho and Fryzlewicz (2023) for details.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code>, here its value is <code>"wcm"</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"gsa"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Cho &amp; P. Fryzlewicz (2024) Multiple change point detection under serial dependence: Wild contrast maximisation and gappy Schwarz algorithm. <em>Journal of Time Series Analysis</em>, 45(3): 479&ndash;494.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.wcm">sol.wcm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
f &lt;- rep(c(0, 5, 2, 8, 1, -2), c(100, 200, 200, 50, 200, 250))
x &lt;- f + arima.sim(list(ar = c(.75, -.5), ma = c(.8, .7, .6, .5, .4, .3)), n = length(f), sd = 1)
model.gsa(sol.wcm(x))
</code></pre>

<hr>
<h2 id='model.ic'>Estimating change-points or change-point-type features in the mean of a noisy data sequence via the strengthened Schwarz information criterion</h2><span id='topic+model.ic'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points or change-point-type features in the mean of a noisy data sequence via the sSIC (strengthened Schwarz information criterion) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.ic(cptpath.object, alpha = 1.01, q.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.ic_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.ic_+3A_alpha">alpha</code></td>
<td>
<p>The parameter associated with the sSIC. The default value is 1.01. Note that the SIC is recovered when alpha = 1.</p>
</td></tr>
<tr><td><code id="model.ic_+3A_q.max">q.max</code></td>
<td>
<p>The maximum number of features allowed. If nothing or <code>NULL</code> is provided, the default value of <code>min(100, n/log(n))</code> (rounded to an integer) will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model selection method for algorithms that produce nested solution path is described in 
&quot;Wild binary segmentation for multiple change-point detection&quot;, P. Fryzlewicz (2014), The Annals of Statitics, 42: 2243&ndash;2281.
The corresponding description for those that produce non-nested solution set can be found in 
&quot;Narrowest-over-threshold detection of multiple change points and change-point-like features&quot;, R. Baranowski, Y. Chen and P. Fryzlewicz (2019), Journal of Royal Statistical Society: Series B, 81(3), 649&ndash;672.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The model type used, inherited from the given <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point or change-point-type feature estimators object, here its value is <code>"ic"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated features in the mean of the vector <code>cptpath.object$x</code> based on the given <code>type</code> of the model</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated features in the mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean or constant-slope intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the mean of the vector <code>cptpath.object$x</code>; for piecewise-constant signals, the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points; 
for piecewise-linear but discontinuous signals, the values are based on the estimated linear trend between each pair of consecutive detected change of slopes; 
for piecewise-linear and continuous signals, it is similar to the previous case but with the continuity constraint enforced, which envolves solving a global least squares problem.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0, 100), rep(1, 100), rep(0, 100)) + rnorm(300)
model.ic(sol.wbs(x))
model.ic(sol.not(x))
</code></pre>

<hr>
<h2 id='model.lp'>Estimating change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning</h2><span id='topic+model.lp'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant mean of a noisy data sequence via the localised pruning method, which performs a Schwarz criterion-based model selection on the given candidate set in a localised way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.lp(
  cptpath.object,
  min.d = 5,
  penalty = c("log", "polynomial"),
  pen.exp = 1.01,
  do.thr = TRUE,
  th.const = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.lp_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.lp_+3A_min.d">min.d</code></td>
<td>
<p>A number specifying the minimal spacing between change points; <code>min.d = 5</code> by default</p>
</td></tr>
<tr><td><code id="model.lp_+3A_penalty">penalty</code></td>
<td>
<p>A string specifying the type of penalty term to be used in Schwarz criterion; possible values are: 
</p>

<dl>
<dt><code>"log"</code></dt><dd><p>Use <code>penalty = log(length(x))^pen.exp</code></p>
</dd>
<dt><code>"polynomial"</code></dt><dd><p>Use <code>penalty = length(x)^pen.exp</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="model.lp_+3A_pen.exp">pen.exp</code></td>
<td>
<p>Exponent for the penalty term (see <code>penalty</code>)</p>
</td></tr>
<tr><td><code id="model.lp_+3A_do.thr">do.thr</code></td>
<td>
<p>If <code>do.thr = TRUE</code>, mild threshoding on the CUSUM test statistics is performed after internal standardisation step in order to &quot;pre-prune down&quot; the candidates</p>
</td></tr>
<tr><td><code id="model.lp_+3A_th.const">th.const</code></td>
<td>
<p>A constant multiplied to <code>sqrt(2*log(length(x)))</code> to form a mild threshold; if not supplied, a default value (<code>0.5*</code> the value suggested in Fryzlewicz (2020)) is used,
see <code>th.const</code> in <code><a href="#topic+model.sdll">model.sdll</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further information can be found in Cho and Kirch (2022).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"lp"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points in the piecewise-constant mean of the vector <code>cptpath.object$x</code>. These are the end-points of the corresponding constant-mean intervals</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the piecewise-constant mean of the vector <code>cptpath.object$x</code>; the values are the sample means of the data (replicated a suitable number of times) between each pair of consecutive detected change-points</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Cho &amp; C. Kirch (2022) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>Annals of the Institute of Statistical Mathematics</em>, 74(4), 653&ndash;684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f)) * .5
model.lp(sol.not(x))
</code></pre>

<hr>
<h2 id='model.sdll'>Estimating change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via the Steepest Drop to Low Levels method</h2><span id='topic+model.sdll'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via the Steepest Drop to Low Levels method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.sdll(
  cptpath.object,
  sigma = stats::mad(diff(cptpath.object$x)/sqrt(2)),
  universal = TRUE,
  th.const = NULL,
  th.const.min.mult = 0.3,
  lambda = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.sdll_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. The <code>cptpath.object$type</code> variable decides the model type: piecewise-constant (<code>type == "const"</code>),
piecewise-linear and continuous (<code>type == "lin.cont"</code>) or piecewise-linear and discontinuous (<code>type == "lin.discont"</code>). In the piecewise-constant model, SDLL model selection should work well 
when <code>cptpath.object</code> is an object returned by the <code>sol.wbs2</code> routine. In the piecewise-linear model (whether continuous or not), the output of <code>sol.idetect</code> should be supplied as
<code>cptpath.object</code>. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_sigma">sigma</code></td>
<td>
<p>An estimate of the standard deviation of the noise in the data <code>cptpath.object$x</code>. Can be a functional of <code>cptpath.object$x</code> or a specific value if known. 
The default in the piecewise-constant model is the Median Absolute Deviation of the vector <code>diff(cptpath.object$x)/sqrt(2)</code>, tuned to the Gaussian distribution.
In the piecewise-linear models, <code>diff(cptpath.object$x, differences = 2)/sqrt(6)</code> is used by default.
Note that <code>model.sdll</code> works particularly well when the noise is i.i.d. Gaussian.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_universal">universal</code></td>
<td>
<p>If <code>TRUE</code>, then the threshold that decides if there are any change-points is chosen automatically, so that the probability of type-I error (i.e. indicating change-points if there are none) 
is approximately <code>1 - alpha</code>. If <code>FALSE</code>, then <code>th.const</code> must be specified.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_th.const">th.const</code></td>
<td>
<p>Only relevant if <code>universal == FALSE</code>; in that case a numerical value must be provided. Used to create the threshold (applicable to the contrast magnitudes stored in <code>cptpath.object</code>) 
that decides if there are any change-points in the mean vector; that threshold is then <code>th.const * sqrt(2 * log(n)) * sigma</code>, where <code>n</code> is the length of the data vector <code>cptpath.object$x</code>.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_th.const.min.mult">th.const.min.mult</code></td>
<td>
<p>A fractional multiple of the threshold, used to decide the lowest magnitude of contrasts from <code>cptpath.object</code> still considered by the SDLL model selection criterion as potentially change-point-carrying.</p>
</td></tr>
<tr><td><code id="model.sdll_+3A_lambda">lambda</code></td>
<td>
<p>Only relevant if <code>universal == TRUE</code>; can be set to 0.9 or 0.95. The approximate probability of not detecting any change-points if the truth does not contain any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Steepest Drop to Low Levels method is described in 
&quot;Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection&quot;, P. Fryzlewicz (2020), Journal of the Korean Statistical Society, 49, 1027&ndash;1070.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The model type used, inherited from the given <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"sdll"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2020). Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49, 1027&ndash;1070.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f))
model.sdll(sol.wbs2(x))
</code></pre>

<hr>
<h2 id='model.thresh'>Estimating change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via thresholding</h2><span id='topic+model.thresh'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of change-points in the piecewise-constant or piecewise-linear mean of a noisy data sequence via thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.thresh(cptpath.object, sigma = NULL, th.const = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.thresh_+3A_cptpath.object">cptpath.object</code></td>
<td>
<p>A solution-path object, returned by a <code>sol.[name]</code> routine. The <code>cptpath.object$type</code> variable decides the model type: piecewise-constant (<code>type == "const"</code>),
piecewise-linear and continuous (<code>type == "lin.cont"</code>) or piecewise-linear and discontinuous (<code>type == "lin.discont"</code>). In the piecewise-linear model (whether continuous or not), the output of <code>sol.idetect_seq</code> or <code>sol.not</code> should be supplied as
<code>cptpath.object</code>. Note that the field <code>cptpath.object$x</code> contains the input data sequence.</p>
</td></tr>
<tr><td><code id="model.thresh_+3A_sigma">sigma</code></td>
<td>
<p>An estimate of the standard deviation of the noise in the data <code>cptpath.object$x</code>. Can be a functional of <code>cptpath.object$x</code> or a specific value if known.
The default in the piecewise-constant model is the Median Absolute Deviation of the vector <code>diff(cptpath.object$x)/sqrt(2)</code>, tuned to the Gaussian distribution.
In the piecewise-linear models, <code>diff(cptpath.object$x, differences = 2)/sqrt(6)</code> is used by default.
Note that <code>model.thresh</code> works particularly well when the noise is i.i.d. Gaussian.</p>
</td></tr>
<tr><td><code id="model.thresh_+3A_th.const">th.const</code></td>
<td>
<p>A positive real number used to define the threshold for the detection process. The default used in the piecewise-constant model is 1.15, while in the piecewise-linear model, the value is taken equal to 1.4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>cptmodel</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solution.path</code></td>
<td>
<p>The solution path method used to obtain <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The model type used, inherited from the given <code>cptpath.object</code></p>
</td></tr>
<tr><td><code>model.selection</code></td>
<td>
<p>The model selection method used to return the final change-point estimators object, here its value is <code>"thresh"</code></p>
</td></tr>
<tr><td><code>no.of.cpt</code></td>
<td>
<p>The number of estimated change-points</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>The locations of estimated change-points</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>An estimate of the mean of the vector <code>cptpath.object$x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+breakfast">breakfast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 10)
x &lt;- f + rnorm(length(f))
model.thresh(sol.idetect_seq(x))
</code></pre>

<hr>
<h2 id='plot.breakfast.cpts'>Change-points estimated by the &quot;breakfast&quot; routine</h2><span id='topic+plot.breakfast.cpts'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>breakfast.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'breakfast.cpts'
plot(x, display.data = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.breakfast.cpts_+3A_x">x</code></td>
<td>
<p>a <code>breakfast.cpts</code> object</p>
</td></tr>
<tr><td><code id="plot.breakfast.cpts_+3A_display.data">display.data</code></td>
<td>
<p>if <code>display.data = TRUE</code>, change-point estimators are plotted against the data by method.
If <code>display.data = FALSE</code>, only the estimators are plotted; this option is recommended when <code>length(x)</code> is large.</p>
</td></tr>
<tr><td><code id="plot.breakfast.cpts_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
plot(breakfast(x, solution.path = 'all', model.selection = 'all'), display.data = TRUE)
plot(breakfast(x), display.data = FALSE)
</code></pre>

<hr>
<h2 id='print.breakfast.cpts'>Change-points estimated by the &quot;breakfast&quot; routine</h2><span id='topic+print.breakfast.cpts'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>breakfast.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'breakfast.cpts'
print(x, by = c("method", "estimator"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.breakfast.cpts_+3A_x">x</code></td>
<td>
<p>a <code>breakfast.cpts</code> object</p>
</td></tr>
<tr><td><code id="print.breakfast.cpts_+3A_by">by</code></td>
<td>
<p>if <code>by = 'method'</code>, change-point estimators are printed by method;
if <code>by = 'estimator'</code>, each change-point estimator is printed with the methods that detect it.</p>
</td></tr>
<tr><td><code id="print.breakfast.cpts_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
print(breakfast(x, solution.path = 'all', model.selection = 'all'), by = 'method')
print(breakfast(x), by = 'estimator')
</code></pre>

<hr>
<h2 id='print.cptmodel'>Change-points estimated by solution path generation + model selection methods</h2><span id='topic+print.cptmodel'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>cptmodel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cptmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cptmodel_+3A_x">x</code></td>
<td>
<p>a <code>cptmodel</code> object</p>
</td></tr>
<tr><td><code id="print.cptmodel_+3A_...">...</code></td>
<td>
<p>current not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rep(rep(c(0, 1), each = 50), 5)
x &lt;- f + rnorm(length(f)) * .5
print(model.ic(sol.idetect(x)))
</code></pre>

<hr>
<h2 id='sol.idetect'>Solution path generation via the Isolate-Detect method</h2><span id='topic+sol.idetect'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector, or in its linear trend, in the order of importance, via the Isolate-Detect (ID) method.
It is developed to be used with the sdll and information criterion (ic) model selection rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.idetect(
  x,
  type = "const",
  thr_ic_cons = 0.9,
  thr_ic_lin = 1.25,
  points = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.idetect_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed.</p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_type">type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code>, <code>type = "lin.cont"</code>, <code>type = "lin.discont"</code> mean, respectively, that the signal (mean of <code>x</code>) is piecewise constant, 
piecewise linear and continuous, and piecewise linear but not necessarily continuous. If not given, the default is <code>type = "const"</code></p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_thr_ic_cons">thr_ic_cons</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is used to create the solution path for the piecewise-constant model. The lower the value, the longer the solution path.</p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_thr_ic_lin">thr_ic_lin</code></td>
<td>
<p>A positive real number with default value 1.25. Used to create the solution path if <code>type == "lin.cont"</code> or <code>type == "lin.discont"</code></p>
</td></tr>
<tr><td><code id="sol.idetect_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, as described in the Isolate-Detect methodology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Isolate-Detect method and its algorithm is described in 
&quot;Detecting multiple generalized change-points by isolating single ones&quot;, A. Anastasiou &amp; P. Fryzlewicz (2022), Metrika, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The input parameter <code>type</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;idetect&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2022). Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.idetect(r3)
</code></pre>

<hr>
<h2 id='sol.idetect_seq'>Solution path generation using the sequential approach of the Isolate-Detect method</h2><span id='topic+sol.idetect_seq'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector, or in its linear trend, in the order of importance, via the Isolate-Detect (ID) method. 
It is developed to be used with the thresholding model selection rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.idetect_seq(x, type = "const", points = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.idetect_seq_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.idetect_seq_+3A_type">type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code>, <code>type = "lin.cont"</code>, <code>type = "lin.discont"</code> mean, respectively, that the signal (mean of <code>x</code>) is piecewise constant, 
piecewise linear and continuous, and piecewise linear but not necessarily continuous. If not given, the default is <code>type = "const"</code></p>
</td></tr>
<tr><td><code id="sol.idetect_seq_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 4. It defines the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, as described in the Isolate-Detect methodology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Isolate-Detect method and its algorithm is described in 
&quot;Detecting multiple generalized change-points by isolating single ones&quot;, A. Anastasiou &amp; P. Fryzlewicz (2022), Metrika, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The input parameter <code>type</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;idetect_seq&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Anastasiou &amp; P. Fryzlewicz (2022). Detecting multiple generalized change-points by isolating single ones. <em>Metrika</em>, https://doi.org/10.1007/s00184-021-00821-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.idetect_seq(r3)
</code></pre>

<hr>
<h2 id='sol.not'>Solution path generation via the Narrowest-Over-Threshold method</h2><span id='topic+sol.not'></span>

<h3>Description</h3>

<p>This function arranges all possible features (e.g. change in the mean, change in the slope, etc) of the input vector in the order of importance, via the Narrowest-Over-Threshold (NOT) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.not(x, type = "const", M = 10000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.not_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.not_+3A_type">type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code> means the signals are the piecewise constant, <code>type = "lin.cont"</code> means the signals are the piecewise linear and continuous, and <code>type = "lin.discont"</code> means the signals are the piecewise linear but not necessarily continuous. 
If not given, the default is <code>type = "const"</code></p>
</td></tr>
<tr><td><code id="sol.not_+3A_m">M</code></td>
<td>
<p>The maximum number of all data sub-samples at the beginning of the algorithm. The default is
<code>M = 10000</code></p>
</td></tr>
<tr><td><code id="sol.not_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>When drawing the sub-intervals, whether to use a systematic (and fixed) or random scheme. The default is <code>systematic.intervals = TRUE</code></p>
</td></tr>
<tr><td><code id="sol.not_+3A_seed">seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Narrowest-Over-Threshold method and its algorithm is described in 
&quot;Narrowest-over-threshold detection of multiple change points and change-point-like features&quot;, R. Baranowski, Y. Chen and P. Fryzlewicz (2019), Journal of Royal Statistical Society: Series B, 81(3), 649&ndash;672.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>FALSE</code>, i.e., the change-point outputs are not nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code> for each threshold level (in the decreasing order), arranged in the form of a list of lists</p>
</td></tr>
<tr><td><code>solution.set.th</code></td>
<td>
<p>A list that contains threshold levels corresponding to the detections in <code>solution.set</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The model type used, which is given in the input. If not given, the default is <code>type="const"</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column resulted from applying NOT to all threshold levels. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows reflect the strength of each detection in decreasing order. To avoid repetition, each possible location would appear at most once in the matrix (with the sub-interval that carries its highest possible strength)</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;not&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>,  <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.not(r3)
</code></pre>

<hr>
<h2 id='sol.tguh'>Solution path generation via the Tail-Greedy Unbalanced Haar method</h2><span id='topic+sol.tguh'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Tail-Greedy Unbalanced Haar method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.tguh(x, type = "const", p = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.tguh_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.tguh_+3A_type">type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code> means piecewise-constant; this is the only type currently supported in <code>sol.tguh</code></p>
</td></tr>
<tr><td><code id="sol.tguh_+3A_p">p</code></td>
<td>
<p>Specifies the number of region pairs merged 
in each pass through the data, as the proportion of all remaining region pairs. The default is
<code>p = 0.01</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tail-Greedy Unbalanced Haar decomposition algorithm is described in 
&quot;Tail-greedy bottom-up data decompositions and fast multiple change-point 
detection&quot;, P. Fryzlewicz (2018), The Annals of Statistics, 46, 3390&ndash;3421.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Input parameter <code>type</code></p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Input parameter <code>p</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;tguh&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2018). Tail-greedy bottom-up data decompositions and fast multiple change-point detection. <em>The Annals of Statistics</em>, 46, 3390&ndash;3421.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.tguh(r3)
</code></pre>

<hr>
<h2 id='sol.wbs'>Solution path generation via the Wild Binary Segmentation method</h2><span id='topic+sol.wbs'></span>

<h3>Description</h3>

<p>This function arranges all possible change-in-mean features of the input vector in the order of importance, via the Wild Binary Segmentation (WBS) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.wbs(x, type = "const", M = 10000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.wbs_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed</p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_type">type</code></td>
<td>
<p>The model type considered. Currently <code>type = "const"</code> is the only accepted value. This assumes that the mean of the input vector is piecewise-constant.</p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_m">M</code></td>
<td>
<p>The maximum number of all data sub-samples at the beginning of the algorithm. The default is
<code>M = 10000</code></p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>When drawing the sub-intervals, whether to use a systematic (and fixed) or random scheme. The default is <code>systematic.intervals = TRUE</code></p>
</td></tr>
<tr><td><code id="sol.wbs_+3A_seed">seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wild Binary Segmentation algorithm is described in 
&quot;Wild binary segmentation for multiple change-point detection&quot;, P. Fryzlewicz (2014), The Annals of Statistics, 42: 2243&ndash;2281.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The input parameter <code>type</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;wbs&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2014). Wild binary segmentation for multiple change-point detection. <em>The Annals of Statistics</em>, 42(6), 2243&ndash;2281.
</p>
<p>R. Baranowski, Y. Chen &amp; P. Fryzlewicz (2019). Narrowest-over-threshold detection of multiple change points and change-point-like features. <em>Journal of the Royal Statistical Society: Series B</em>, 81(3), 649&ndash;672.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs2">sol.wbs2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.wbs(r3)
</code></pre>

<hr>
<h2 id='sol.wbs2'>Solution path generation via the Wild Binary Segmentation 2 method</h2><span id='topic+sol.wbs2'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Wild Binary Segmentation 2 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.wbs2(x, type = "const", M = 1000, systematic.intervals = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.wbs2_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed.</p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_type">type</code></td>
<td>
<p>The model type considered. <code>type = "const"</code> means piecewise-constant; this is the only type currently supported in <code>sol.wbs2</code></p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_m">M</code></td>
<td>
<p>The maximum number of data sub-samples drawn at each recursive stage of the algorithm. The default is
<code>M = 1000</code>. Setting <code>M = 0</code> executes the standard binary segmentation.</p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_systematic.intervals">systematic.intervals</code></td>
<td>
<p>Whether data sub-intervals for CUSUM computation are drawn systematically (TRUE; start- and end-points taken from an approximately equispaced grid) or randomly (FALSE; obtained uniformly with replacement). The default is TRUE.</p>
</td></tr>
<tr><td><code id="sol.wbs2_+3A_seed">seed</code></td>
<td>
<p>If a random scheme is used, a random seed can be provided so that every time the same sets of random sub-intervals would be drawn. The default is <code>seed = NULL</code>, which means that this option is not set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wild Binary Segmentation 2 algorithm is described in 
&quot;Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection&quot;, P. Fryzlewicz (2020), Journal of the Korean Statistical Society, 49, 1027-1070.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance</p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>Empty list</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Input parameter <code>type</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions length(<code>x</code>) - 1 by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;wbs2&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Fryzlewicz (2020). Detecting possibly frequent change-points: Wild Binary Segmentation 2 and steepest-drop model selection. <em>Journal of the Korean Statistical Society</em>, 49, 1027-1070.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol.idetect">sol.idetect</a></code>, <code><a href="#topic+sol.idetect_seq">sol.idetect_seq</a></code>, <code><a href="#topic+sol.not">sol.not</a></code>, <code><a href="#topic+sol.tguh">sol.tguh</a></code>, <code><a href="#topic+sol.wbs">sol.wbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3 &lt;- rnorm(1000) + c(rep(0,300), rep(2,200), rep(-4,300), rep(0,200))
sol.wbs2(r3)
</code></pre>

<hr>
<h2 id='sol.wcm'>Solution path generation via the Wild Contrast Maximisation method</h2><span id='topic+sol.wcm'></span>

<h3>Description</h3>

<p>This function arranges all possible change-points in the mean of the input vector in the order of importance, via the Wild Binary Segmentation 2 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol.wcm(
  x,
  type = "const",
  M = 100,
  min.d = NULL,
  Q = floor(log(length(x))^1.9),
  max.iter = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sol.wcm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data to be processed.</p>
</td></tr>
<tr><td><code id="sol.wcm_+3A_type">type</code></td>
<td>
<p>The type of change-point models fitted to the data; currently the class of piecewise constant signals (<code>type = "const"</code>) is supported.</p>
</td></tr>
<tr><td><code id="sol.wcm_+3A_m">M</code></td>
<td>
<p>The maximum number of data sub-samples drawn at each recursive stage of the algorithm. The default is <code>M = 100</code>.</p>
</td></tr>
<tr><td><code id="sol.wcm_+3A_min.d">min.d</code></td>
<td>
<p>The minimum distance between candidate change-point estimators; 
if <code>min.d = NULL</code>, it is set to be <code>max(20, 10 + ceiling(log(length(x))^1.1)</code>.</p>
</td></tr>
<tr><td><code id="sol.wcm_+3A_q">Q</code></td>
<td>
<p>The maximum number of allowable change-points. 
The default is <code>Q = floor(log(length(x))^1.9)</code>.</p>
</td></tr>
<tr><td><code id="sol.wcm_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of candidate change-point models considered; if a model with the number of change-point estimators exceeding <code>Q</code> is required to generate the sequence of required candidate models, this argument is ignored. The default is <code>max.iter = 5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wild Contrast Maximisation (WCM) algorithm generates a nested sequence of candidate models by identifying large gaps in the solution path generated by WBS2, which aids the model selection step in the presence of large random fluctuations due to serial dependence. See Cho and Fryzlewicz (2023) for further details.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>cptpath</code>, which contains the following fields: 
</p>
<table>
<tr><td><code>solutions.nested</code></td>
<td>
<p><code>TRUE</code>, i.e., the change-point outputs are nested</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>Locations of possible change-points in the mean of <code>x</code>, arranged in decreasing order of change-point importance; this is not used by <code><a href="#topic+model.gsa">model.gsa</a></code></p>
</td></tr>
<tr><td><code>solution.set</code></td>
<td>
<p>A list of candidate change-point models. Each model contains possible change-points in the mean of <code>x</code>; this is used by <code><a href="#topic+model.gsa">model.gsa</a></code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Input vector <code>x</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the change-point model considered, which has value &quot;const&quot; here</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Input parameter <code>M</code></p>
</td></tr>
<tr><td><code>cands</code></td>
<td>
<p>Matrix of dimensions <code>Q</code> by 4. The first two columns are (start, end)-points of the detection intervals of the corresponding possible change-point location in the third column. The fourth column is a measure of strength of the corresponding possible change-point. The order of the rows is the same as the order returned in <code>solution.path</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used, which has value &quot;wcm&quot; here</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Cho &amp; P. Fryzlewicz (2024) Multiple change point detection under serial dependence: Wild contrast maximisation and gappy Schwarz algorithm. <em>Journal of Time Series Analysis</em>, 45(3): 479&ndash;494.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.gsa">model.gsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
f &lt;- rep(c(0, 5, 2, 8, 1, -2), c(100, 200, 200, 50, 200, 250))
x &lt;- f + arima.sim(list(ar = c(.75, -.5), ma = c(.8, .7, .6, .5, .4, .3)), n = length(f), sd = 1)
sol.wcm(x)$solution.set
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
