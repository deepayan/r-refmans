<!DOCTYPE html><html><head><title>Help for package DTRreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DTRreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chooseM'><p>Adaptive Choice of the Bootstrap Resample Size M</p></a></li>
<li><a href='#confint.DTRreg'><p>Confidence Interval Calculations for DTRs</p></a></li>
<li><a href='#data'><p>Toy Two-Stage Trial Datasets</p></a></li>
<li><a href='#DTRreg'><p>DTR Estimation and Inference via G-estimation, Dynamic WOLS, or Q-learning</p></a></li>
<li><a href='#DWSurv'><p>DTR estimation and inference for time-to-event data using DWSurv</p></a></li>
<li><a href='#plot.DTRreg'><p>Diagnostic Plots for DTR Estimation</p></a></li>
<li><a href='#predict.DTRreg'><p>Optimal Outcome Prediction for DTRs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>DTR Estimation and Inference via G-Estimation, Dynamic WOLS,
Q-Learning, and Dynamic Weighted Survival Modeling (DWSurv)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Wallace, Erica E M Moodie, David A Stephens, Gabrielle Simoneau, Shannon T. Holloway and Juliana Schulz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shannon T. Holloway &lt;shannon.t.holloway@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Dynamic treatment regime estimation and inference via G-estimation, 
  dynamic weighted ordinary least squares (dWOLS) and Q-learning. Inference via 
  bootstrap and recursive sandwich estimation. Estimation and 
  inference for survival outcomes via Dynamic Weighted Survival Modeling (DWSurv). 
  Extension to continuous treatment variables. Wallace et al. (2017) 
  &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i02">doi:10.18637/jss.v080.i02</a>&gt;; Simoneau et al. (2020) 
  &lt;<a href="https://doi.org/10.1080%2F00949655.2020.1793341">doi:10.1080/00949655.2020.1793341</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, nnet, R6, stats, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Collate:</td>
<td>'treatmentClasses.R' 'Ahat.R' 'interactive.R'
'inputProcessing.R' 'utils.R' 'weights.R' 'sandwich.R' 'gest.R'
'dwols.R' 'bootstrapStep.R' 'dtrProcedure.R' 'DTRreg.R'
'DWsurv.R' 'chooseM.R' 'data_generate.R' 's3-methods.R'
'varest.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-23 20:05:47 UTC; 19194</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-23 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chooseM'>Adaptive Choice of the Bootstrap Resample Size M</h2><span id='topic+chooseM'></span>

<h3>Description</h3>

<p>Implementation of a double-bootstrap algorithm for choosing the bootstrap 
resample size <code class="reqn">m</code> in a data-adaptive manner. The function returns the 
resample size to be used to apply the m-out-of-n bootstrap with <a href="#topic+DTRreg">DTRreg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseM(
  outcome,
  blip.mod,
  treat.mod,
  tf.mod,
  data = NULL,
  method = c("gest", "dwols", "qlearn"),
  treat.type = c("bin", "multi", "cont"),
  treat.fam = gaussian(link = "identity"),
  weight = c("abs", "ipw", "cipw", "qpom", "wo", "none", "manual"),
  n.bins = 3L,
  treat.wgt.man = NULL,
  treat.range = NULL,
  missing = c("drop", "ipw"),
  missing.mod = NULL,
  B1 = 500,
  B2 = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseM_+3A_outcome">outcome</code></td>
<td>
<p>The outcome variable. Missing data will result in a stopping
error.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_blip.mod">blip.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
blip function for each stage in order. No dependent variable should be 
specified. Note that this input should include the treatment variable 
ONLY if the blip model is quadratic in treatment. See Details for further 
clarification.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_treat.mod">treat.mod</code></td>
<td>
<p>A list of formula objects specifying the treatment model for
each stage in order. Treatment variable should be included as the dependent
variable. If treatment is binary <code><a href="stats.html#topic+glm">glm</a>(family = binomial)</code>
will be 
used to obtain parameter estimates; if treatment is multi-nomial, 
<code><a href="nnet.html#topic+multinom">multinom</a>()</code> will be used to obtain parameter estimates; and if 
treatment is continuous, <code><a href="stats.html#topic+lm">lm</a>()</code> will be used.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_tf.mod">tf.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
treatment-free model for each stage in order. No dependent variable should 
be specified.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_data">data</code></td>
<td>
<p>A data frame containing all necessary covariates and treatments
contained in the models. Missing data should be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_method">method</code></td>
<td>
<p>The DTR method to be used, choose &quot;dwols&quot; for dynamic WOLS, 
&quot;gest&quot; for G-estimation, or &quot;qlearn&quot; for Q-learning.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_treat.type">treat.type</code></td>
<td>
<p>A character object. Must be one of {&quot;bin&quot;, &quot;multi&quot;, &quot;cont&quot;}
indicating that the treatments at each stage are binary, multinomial,
or continuous, respectively. Each stage must have the same treatment type.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_treat.fam">treat.fam</code></td>
<td>
<p>A character or family object. 
The description of the dose distribution along with the link 
function to be used in the treatment model for computing weights; should be 
specified in a similar format as that used in <code><a href="stats.html#topic+glm">glm</a>()</code>. 
If character object, must be one of {&quot;gaussian&quot;, &quot;Gamma&quot;}, for which
<code><a href="stats.html#topic+gaussian">gaussian</a>(link = "identity")</code> or 
<code><a href="stats.html#topic+Gamma">Gamma</a>(link = "log")</code> 
will be used,
respectively. Input is ignored for <code>treat.type = "bin"</code> and 
<code>treat.type = "multi"</code>.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_weight">weight</code></td>
<td>
<p>The form of the treatment weight. See details.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_n.bins">n.bins</code></td>
<td>
<p>An integer object. The number of bins (levels) to be used for 
categorizing continuous doses. This input is required only when
<code>treat.type = "cont"</code> and <code>weight = "wo"</code> or <code>weight = "qpom"</code>.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_treat.wgt.man">treat.wgt.man</code></td>
<td>
<p>NULL or a list of vectors of known treatment weights can be 
specified to be used instead of hard-coded treatment weight options.
The <code class="reqn">i^{th}</code> element of the list contains the multiplicative weights 
for the <code class="reqn">i^{th}</code> stage. Each vector must be of length <code class="reqn">n</code>, 
the number of participants. Used only for <code>method = "dwols"</code>.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_treat.range">treat.range</code></td>
<td>
<p>For continuous treatments. Specify the maximum/minimum 
value that treatments can be take. If unspecified then the minimum/maximum 
value of observed treatments is used. If you wish to have unrestricted 
treatments set this option to <code>c(-Inf, +Inf)</code>. If each stage has its own
range, provide as a list, the ith element providing the min and max
for the ith stage treatment.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_missing">missing</code></td>
<td>
<p>A character object. Must be one of {&quot;drop&quot;, &quot;ipw&quot;}.
If set to &quot;ipw&quot; and covariate or treatment data are missing then inverse 
probability 
weights are used. The complete case probability is estimated 
via logistic regression. If set to &quot;drop&quot; and data are missing, participants
with missing data are dropped for all stage analyses.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_missing.mod">missing.mod</code></td>
<td>
<p>An optional list of formula objects specifying the model
for the inverse probability of weights for each stage in order.
No dependent variable should be specified. If <code>missing = "ipw"</code> and 
<code>missing.mod = NULL</code>, then the models are assumed to be linear comprising
the full covariate history derived from all of the previous stage models.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_b1">B1</code></td>
<td>
<p>Number of first-level bootstrap resamples.</p>
</td></tr>
<tr><td><code id="chooseM_+3A_b2">B2</code></td>
<td>
<p>Number of second-level bootstrap resamples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The m-out-of-n bootstrap is an adequate tool for constructing valid 
confidence intervals for the first stage parameters in <a href="#topic+DTRreg">DTRreg</a>. The 
resample size <code class="reqn">m</code> is: 
<code class="reqn">m = n^{\frac{1 + \alpha(1-\hat{p})}{1+\alpha}}</code>. The estimated non-regularity level is 
computed by <a href="#topic+DTRreg">DTRreg</a>. The double-bootstrap algorithm is a cross-validation 
tool for choosing the tuning parameter <code class="reqn">\alpha</code> in a data-driven way.
</p>
<p>The current implementation is valid for a two-stage DTR. Moreover, the 
current implementation may be unstable when there are many missing data.
</p>


<h3>Value</h3>

<p>A list with a single element 
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>Resample size for using in the m-out-of-n bootstrap.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabrielle Simoneau
</p>


<h3>References</h3>

<p>Chakraborty, B., Moodie, E. E. M. (2013) <em>Statistical Methods for 
Dynamic Treatment Regimes</em>. New York: Springer.
</p>
<p>Efron B., Tibshirani R. J. (1994) An Introduction to the Bootstrap. 
<em>CRC press</em>.
</p>
<p>Wallace, M. P., Moodie, E. M. (2015) Doubly-Robust Dynamic Treatment 
Regimen Estimation Via Weighted Least Squares. <em>Biometrics</em> 
<b>71</b>(3), 636&ndash;644 (doi:10.1111/biom.12306.)

</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(twoStageCont)

# models to be passed to DTRreg
# blip model
blip.mod &lt;- list(~ X1, ~ X2)
# treatment model (correctly specified)
treat.mod &lt;- list(A1 ~ X1, A2 ~ 1)
# treatment-free model (incorrectly specified)
tf.mod &lt;- list(~ X1, ~ X2)

# perform dWOLS without calculating confidence intervals
mod1 &lt;- DTRreg(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "dwols")
  
# choose m adaptively for that model
## Not run: 
  m &lt;- chooseM(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "dwols",
               B1 = 200, B2 = 200)$m

## End(Not run)
m &lt;- 94
  
# dWOLS with confidence intervals from the m-out-of-n bootstrap
mod2 &lt;- DTRreg(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "dwols",
               var.estim = "bootstrap", 
               bootstrap.controls = list(M = m))
</code></pre>

<hr>
<h2 id='confint.DTRreg'>Confidence Interval Calculations for DTRs</h2><span id='topic+confint.DTRreg'></span>

<h3>Description</h3>

<p>Confidence intervals for parameters, with the option of 
constructing the confidence intervals using the percentile method 
when bootstrap is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DTRreg'
confint(object, parm = NULL, level = 0.95, type = c("se", "percentile"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.DTRreg_+3A_object">object</code></td>
<td>
<p>A model object generated by the function DTRreg.</p>
</td></tr>
<tr><td><code id="confint.DTRreg_+3A_parm">parm</code></td>
<td>
<p>Not available for DTRreg objects.</p>
</td></tr>
<tr><td><code id="confint.DTRreg_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.DTRreg_+3A_type">type</code></td>
<td>
<p>Typical Wald-type confidence interval &quot;se&quot; (default) or 
confidence intervals derived with the percentile method &quot;percentile&quot; 
(bootstrap variance estimates only).</p>
</td></tr>
<tr><td><code id="confint.DTRreg_+3A_...">...</code></td>
<td>
<p>Space for additional arguments (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with columns giving lower and upper confidence limits for each
parameter. These will be labelled as (1-level)/2 and 1 - (1-level)/2 in 
percentage (by default 2.5% and 97.5%).
</p>

<hr>
<h2 id='data'>Toy Two-Stage Trial Datasets</h2><span id='topic+data'></span><span id='topic+twoStageCont'></span><span id='topic+twoStageCens'></span><span id='topic+twoStageSurv'></span>

<h3>Description</h3>

<p>These datasets are provided only to facilitate examples. They are not based 
on or representative of any real-world applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(twoStageCont)

data(twoStageCens)

data(twoStageSurv)
</code></pre>


<h3>Format</h3>

<p>twoStageCont is a dataset generated to mimic a simple two-stage
trial. The data.frame contains 1000 observations with 5 columns: 
</p>

<dl>
<dt>X1</dt><dd><p>The first stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>A1</dt><dd><p>The first stage treatment. A binary variable.</p>
</dd>
<dt>X2</dt><dd><p>The second stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>A2</dt><dd><p>The second stage treatment. A binary variable.</p>
</dd>
<dt>Y</dt><dd><p>The outcome. A continuous variable.</p>
</dd>
</dl>

<p>twoStageCens is a dataset generated to mimic a simple two-stage
trial with right-censoring. The data.frame contains 1000 observations 
with 9 columns: 
</p>

<dl>
<dt>X11</dt><dd><p>A first stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>X12</dt><dd><p>A first stage covariate. A continuous variable = X11^4.</p>
</dd>
<dt>A1</dt><dd><p>The first stage treatment. A binary variable.</p>
</dd>
<dt>T1</dt><dd><p>The time from the beginning of the first stage to the event or to 
stage 2 entry, whichever comes first.</p>
</dd>
<dt>X21</dt><dd><p>A second stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>X22</dt><dd><p>A second stage covariate. A continuous variable = X21^3.</p>
</dd>
<dt>A2</dt><dd><p>The second stage treatment. A binary variable.</p>
</dd>
<dt>T2</dt><dd><p>The time from the beginning of the second stage to the event 
defined only for subjects who enter the second stage.</p>
</dd>
<dt>delta</dt><dd><p>Event indicator.</p>
</dd>
</dl>

<p>Note: For participants who experienced the event during stage 1, i.e., did
not continue to stage 2, the &quot;survival time&quot; is T1. For participants that
entered stage 2, the &quot;survival time&quot; is T1 + T2.
</p>
<p>twoStageSurv is a dataset generated to mimic a simple two-stage
trial without censoring. The data.frame contains 1000 observations 
with 9 columns: 
</p>

<dl>
<dt>X11</dt><dd><p>A first stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>X12</dt><dd><p>A first stage covariate. A continuous variable = X11^4.</p>
</dd>
<dt>A1</dt><dd><p>The first stage treatment. A binary variable.</p>
</dd>
<dt>T1</dt><dd><p>The time from the beginning of the first stage to the event or to 
stage 2 entry, whichever comes first.</p>
</dd>
<dt>X21</dt><dd><p>A second stage covariate. A normally distributed continuous variable.</p>
</dd>
<dt>X22</dt><dd><p>A second stage covariate. A continuous variable = X21^3.</p>
</dd>
<dt>A2</dt><dd><p>The second stage treatment. A binary variable.</p>
</dd>
<dt>T2</dt><dd><p>The time from the beginning of the second stage to the event 
non-zero only for subjects who did not have an event in Stage I.</p>
</dd>
</dl>

<p>Note: The &quot;survival time&quot; is T1 + T2.
</p>

<hr>
<h2 id='DTRreg'>DTR Estimation and Inference via G-estimation, Dynamic WOLS, or Q-learning</h2><span id='topic+DTRreg'></span><span id='topic+print.DTRreg'></span><span id='topic+summary.DTRreg'></span><span id='topic+coef.DTRreg'></span>

<h3>Description</h3>

<p>Dynamic treatment regimen estimation and inference via G-estimation and 
dynamic WOLS.  Estimation of blip model parameters for multi-stage data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTRreg(
  outcome,
  blip.mod,
  treat.mod,
  tf.mod,
  data = NULL,
  method = c("gest", "dwols", "qlearn"),
  interactive = FALSE,
  treat.type = c("bin", "multi", "cont"),
  treat.fam = gaussian(link = "identity"),
  weight = c("abs", "ipw", "cipw", "qpom", "wo", "none", "manual"),
  n.bins = 3L,
  treat.range = NULL,
  treat.wgt.man = NULL,
  var.estim = c("none", "bootstrap", "sandwich"),
  full.cov = FALSE,
  bootstrap.controls = list(B = 100L, M = nrow(data), type = "standard", truncate = 0,
    verbose = FALSE, interrupt = FALSE),
  missing = c("drop", "ipw"),
  missing.mod = NULL,
  dtr = TRUE
)

## S3 method for class 'DTRreg'
print(x, ...)

## S3 method for class 'DTRreg'
summary(object, ...)

## S3 method for class 'DTRreg'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTRreg_+3A_outcome">outcome</code></td>
<td>
<p>The outcome variable. Missing data will result in a stopping
error.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_blip.mod">blip.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
blip function for each stage in order. No dependent variable should be 
specified. Note that this input should include the treatment variable 
ONLY if the blip model is quadratic in treatment. See Details for further 
clarification.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_treat.mod">treat.mod</code></td>
<td>
<p>A list of formula objects specifying the treatment model for
each stage in order. Treatment variable should be included as the dependent
variable. If treatment is binary <code><a href="stats.html#topic+glm">glm</a>(family = binomial)</code>
will be 
used to obtain parameter estimates; if treatment is multi-nomial, 
<code><a href="nnet.html#topic+multinom">multinom</a>()</code> will be used to obtain parameter estimates; and if 
treatment is continuous, <code><a href="stats.html#topic+lm">lm</a>()</code> will be used.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_tf.mod">tf.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
treatment-free model for each stage in order. No dependent variable should 
be specified.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_data">data</code></td>
<td>
<p>A data frame containing all necessary covariates and treatments
contained in the models. Missing data should be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_method">method</code></td>
<td>
<p>The DTR method to be used, choose &quot;dwols&quot; for dynamic WOLS, 
&quot;gest&quot; for G-estimation, or &quot;qlearn&quot; for Q-learning.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_interactive">interactive</code></td>
<td>
<p>If <code>TRUE</code> on-screen prompts will guide the user through 
the specification of blip, treatment, and treatment-free models.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_treat.type">treat.type</code></td>
<td>
<p>A character object. Must be one of {&quot;bin&quot;, &quot;multi&quot;, &quot;cont&quot;}
indicating that the treatments at each stage are binary, multinomial,
or continuous, respectively. Each stage must have the same treatment type.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_treat.fam">treat.fam</code></td>
<td>
<p>A character or family object. 
The description of the dose distribution along with the link 
function to be used in the treatment model for computing weights; should be 
specified in a similar format as that used in <code><a href="stats.html#topic+glm">glm</a>()</code>. 
If character object, must be one of {&quot;gaussian&quot;, &quot;Gamma&quot;}, for which
<code><a href="stats.html#topic+gaussian">gaussian</a>(link = "identity")</code> or 
<code><a href="stats.html#topic+Gamma">Gamma</a>(link = "log")</code> 
will be used,
respectively. Input is ignored for <code>treat.type = "bin"</code> and 
<code>treat.type = "multi"</code>.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_weight">weight</code></td>
<td>
<p>The form of the treatment weight. See details.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_n.bins">n.bins</code></td>
<td>
<p>An integer object. The number of bins (levels) to be used for 
categorizing continuous doses. This input is required only when
<code>treat.type = "cont"</code> and <code>weight = "wo"</code> or <code>weight = "qpom"</code>.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_treat.range">treat.range</code></td>
<td>
<p>For continuous treatments. Specify the maximum/minimum 
value that treatments can be take. If unspecified then the minimum/maximum 
value of observed treatments is used. If you wish to have unrestricted 
treatments set this option to <code>c(-Inf, +Inf)</code>. If each stage has its own
range, provide as a list, the ith element providing the min and max
for the ith stage treatment.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_treat.wgt.man">treat.wgt.man</code></td>
<td>
<p>NULL or a list of vectors of known treatment weights can be 
specified to be used instead of hard-coded treatment weight options.
The <code class="reqn">i^{th}</code> element of the list contains the multiplicative weights 
for the <code class="reqn">i^{th}</code> stage. Each vector must be of length <code class="reqn">n</code>, 
the number of participants. Used only for <code>method = "dwols"</code>.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_var.estim">var.estim</code></td>
<td>
<p>Covariance matrix estimation method, either &quot;bootstrap&quot;
or &quot;sandwich&quot; for sandwich estimation.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_full.cov">full.cov</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the full covariance matrix will be
returned. If <code>FALSE</code>, only the terms pertaining to the blip parameters
are returned.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_bootstrap.controls">bootstrap.controls</code></td>
<td>
<p>A named list specifying control parameters of the
bootstrap if <code>var.estim = "bootstrap"</code>. Available controls are:
</p>

<dl>
<dt>B: </dt><dd><p>The number of bootstrap samples.</p>
</dd> 
<dt>M: </dt><dd><p>The subsample size for m out of n bootstrap.</p>
</dd>
<dt>type: </dt><dd><p>The type of bootstrap. Must be one of {&quot;standard&quot;, 
&quot;empirical&quot;, &quot;normal&quot;}. The last two are parametric bootstraps.</p>
</dd>
<dt>truncate: </dt><dd><p>A number between 0 and 0.5. The lowest and highest 
specified proportion of parameter estimates will be replaced by the
relevant quantiles affording some robustness to extreme values 
when estimating covariance.</p>
</dd>
<dt>verbose: </dt><dd><p>If TRUE, estimated time to completion will be printed 
to the console every ~30 seconds.</p>
</dd>
<dt>interrupt: </dt><dd><p>If TRUE then user will be given the option 
to abort the bootstrap without error if estimated time to completion
exceeds 10 minutes.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="DTRreg_+3A_missing">missing</code></td>
<td>
<p>A character object. Must be one of {&quot;drop&quot;, &quot;ipw&quot;}.
If set to &quot;ipw&quot; and covariate or treatment data are missing then inverse 
probability 
weights are used. The complete case probability is estimated 
via logistic regression. If set to &quot;drop&quot; and data are missing, participants
with missing data are dropped for all stage analyses.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_missing.mod">missing.mod</code></td>
<td>
<p>An optional list of formula objects specifying the model
for the inverse probability of weights for each stage in order.
No dependent variable should be specified. If <code>missing = "ipw"</code> and 
<code>missing.mod = NULL</code>, then the models are assumed to be linear comprising
the full covariate history derived from all of the previous stage models.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_dtr">dtr</code></td>
<td>
<p>A logical object. If <code>TRUE</code>, use the DTR estimation approach, which
estimates the stage pseudo-outcome by adding a regret function. If <code>FALSE</code>,
use an 'effect estimation' approach, which treats the observed outcome
as being equal to an outcome assuming no treatment is received at any
stage, plus a blip component at each stage; each stage pseudo-outcome is 
generated by subtracting a blip function. Note that most of the 
DTR-specific output will either be suppressed or irrelevant.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_x">x</code></td>
<td>
<p>An object of class 'DTRreg'.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="DTRreg_+3A_object">object</code></td>
<td>
<p>An object of class 'DTRreg'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DTRreg()</code> allows the estimation of optimal dynamic treatment regimens 
(DTRs, also known as adaptive treatment strategies) from multi-stage 
trials using G-estimation, dynamic weighted ordinary least squares 
(dWOLS), and genearlized dWOLS. All methods focus on estimating the 
parameters of the blip: a 
model of the difference in expected outcome under the observed treatment 
and some reference treatment (usually a control) at a given stage, assuming
identical histories and optimal treatment thereafter. The reader is 
referred to Chakraborty and Moodie (2013) for a thorough introduction and 
review of DTR methods. The dWOLS method may be used to obtain parameter 
estimates identical to those from Q-learning (by setting <code>weight = "none"</code>).
This option is intended primarily for exploratory purposes; the authors 
note that there is a dedicated R package for Q-learning (qLearn), although 
it is limited to the 2-stage setting; multi-stage settings are available
in R package DynTxRegime.
</p>
<p>This implementation assumes an outcome regression model of the form
E(Y|X=x,A=a) = tf.mod + a blip.mod. That is &ndash; the input <code>blip.mod</code> 
formula should include the treatment variable <em>ONLY</em> if it is quadratic. 
For example, if the full blip model is linear in the treatment variable 
</p>
<p style="text-align: center;"><code class="reqn">\sim a \psi_0 + a x \psi_1,</code>
</p>
<p> then the input
should model should be <code>blip.mod = ~ x</code>. 
If the full blip model is quadratic in the treatment variable
</p>
<p style="text-align: center;"><code class="reqn">\sim a \psi_0 + a^2 \psi_1 + a x \psi_2 + a^2 x \psi_3,</code>
</p>
 <p><code>blip.mod =
  ~ a*x</code>. For continuous treatments, only quadratic blip
functions are supported.
</p>
<p>All methods require the specification of three models for each 
stage of the analysis: a treatment model (conditional mean of the treatment 
variable), a treatment-free model (conditional mean of outcome assuming 
only reference treatments are used), and a blip model. Only the blip model
must be correctly specified (or over-specified), with consistent parameter 
estimates obtainable if at least one of the other two models is correctly 
specified. Note that all of these must be specified as lists of formula 
objects, even if only one stage of treatment is considered.
</p>
<p>Note that as is conventional, it is assumed a larger value of the outcome 
is preferred (which can be easily achieved via transformation of your data 
if necessary).
</p>
<p>When treatment is binary, if confidence intervals are computed (via 
specification of <code>var.estim</code> other than &quot;none&quot;), then DTRreg will calculate 
the proportion of subjects at each stage for whom optimal treatment is 
non-unique. If this proportion exceeds 0.05 a non-regularity warning will 
be displayed, along with the proportion of subjects for whom this is the 
case. Note that this warning is only displayed if a variance estimation 
option is selected.
</p>
<p>Several treatment weight function options have been implemented within the 
package:
</p>
 
<ul>
<li><p> &quot;none&quot;: No treatment weights applied. If <code>method = "dWOLS"</code>, this 
selection results in the implementation of Q-learning, modified 
slightly to use the G-estimation or dWOLS style pseudo-outcome 
(computed using the observed outcome modified by the estimated 
treatment effect) rather than the traditional Q-learning outcome 
(predicted based on model only, rather than observed outcome with 
treatment effect).   
</p>
</li>
<li><p> &quot;ipw&quot;: weights based on the inverse probability of 
treatment. For binary treatments, a logistic regression is used.
For multinomial, a multinomial log-linear model is fit using 
<code><a href="nnet.html#topic+multinom">multinom</a></code>. For continuous treatments, a GLM with the specified 
family and link function provided in the <code>treat.fam</code> argument is used.
</p>
</li>
<li><p> &quot;cipw&quot;: inverse probability of treatment weights as described for
&quot;ipw&quot; and capped at the 99th percentile of the observed weights.
</p>
</li>
<li><p> &quot;qpom&quot;: weights based on the stabilized inverse 
probability of treatment applied to the categorized (into n.bins bins) 
continuous doses or multinomial treatments; probabilities are 
calculated using a proportional odds model.
This weight is appropriate only for continuous and multinomial treatments.
</p>
</li>
<li><p> &quot;wo&quot;: overlap weights for the categorized continuous doses 
or multinomial treatments (Li and Li, 2019).
This weight is appropriate only for continuous treatments.
</p>
</li>
<li><p> &quot;abs&quot;: Absolute difference <code class="reqn">|A - E[A|...]|</code>. 
appropriate only for binary treatments.
</p>
</li>
<li><p> &quot;manual&quot;: User provides weights through input <code>treat.wgt.man</code>.
Manual treatments are only used in dwols.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>DTRreg</code>, a list including elements
</p>
<table>
<tr><td><code>K:</code></td>
<td>
<p>The number of decision points.</p>
</td></tr>
<tr><td><code>beta:</code></td>
<td>
<p>A list. The ith element contains the parameter estimates of
the ith stage treatment-free model.</p>
</td></tr>
<tr><td><code>psi:</code></td>
<td>
<p>A list. The ith element contains the parameter estimates of
the ith stage blip model.</p>
</td></tr>
<tr><td><code>covmat:</code></td>
<td>
<p>A list. The ith element contains covariance matrix of 
the ith stage blip parameter estimates.</p>
</td></tr>
<tr><td><code>nonreg:</code></td>
<td>
<p>Non-regularity estimates.</p>
</td></tr>
<tr><td><code>setup:</code></td>
<td>
<p>A list detailing the input parameter settings used for the
analysis</p>
</td></tr>
</table>

<dl>
<dt>models: </dt><dd><p>A list of the models used for the analysis.</p>
</dd>
<dt>method: </dt><dd><p>The parameter estimation method.</p>
</dd>
<dt>var.estim: </dt><dd><p>The variance esetimation method.</p>
</dd>
<dt>cc.modeled: </dt><dd><p>If TRUE, missing data was modeled. If FALSE, cases
with missing data were removed from the analysis.</p>
</dd>
<dt>tx.weight: </dt><dd><p>The treatment weighting used for the analysis.</p>
</dd>
<dt>tx.type: </dt><dd><p>Treatment was binary, multinomial, or continuous.</p>
</dd>
<dt>n.bins: </dt><dd><p>The number of bins (levels) used for categorizing
continuous doses when <code>tx.weight = "wo"</code> or 
<code>tx.weight = "qpom"</code>.</p>
</dd>
<dt>tx.wgt.man: </dt><dd><p>Any user provided treatment weights.</p>
</dd>
<dt>tx.range: </dt><dd><p>For continuous treatments, the range of allowed
treatment values.</p>
</dd>
<dt>tx.family: </dt><dd><p>The description of the dose distribution along 
with the link function used in the continuous treatment model.</p>
</dd>
<dt>boot.controls: </dt><dd><p>A list of the bootstrap controls.</p>
</dd>
<dt>type: </dt><dd><p>The type of effect. Dynamic treatment regime or treatment
effect.</p>
</dd>
</dl>

<table>
<tr><td><code>training_data:</code></td>
<td>
<p>A list containing the training data.</p>
</td></tr>
</table>

<dl>
<dt>data: </dt><dd><p>The covariates and treatment data.</p>
</dd>
<dt>outcome: </dt><dd><p>The outcome of interest.</p>
</dd>
<dt>A: </dt><dd><p>The treatment variables, possibly recoded to adhere to internal
code requirements.</p>
</dd>
</dl>

<table>
<tr><td><code>analysis:</code></td>
<td>
<p>A list containing the primary results of each stage analysis.</p>
</td></tr>
</table>

<dl>
<dt>n: </dt><dd><p>The number of participants included in the stage analysis.</p>
</dd>
<dt>last.stage: </dt><dd><p>The last stage each participant was included in 
the analysis.</p>
</dd>
<dt>prob.cc: </dt><dd><p>The complete case probabilities.</p>
</dd>
<dt>cc.mod.fitted: </dt><dd><p>The regression objects returned for estimating
the complete case probabilities.</p>
</dd>
<dt>cc.wgt: </dt><dd><p>The complete case weights.</p>
</dd>
<dt>cts: </dt><dd><p>The treatment type at each stage.</p>
</dd>
<dt>tx.mod.fitted: </dt><dd><p>The regression objects returned for estimating
the treatment probabilities.</p>
</dd>
<dt>A.hat: </dt><dd><p>The estimated or provided treatment probabilities.</p>
</dd>
<dt>tx.wgt: </dt><dd><p>The treatment weights.</p>
</dd>
<dt>outcome.fit: </dt><dd><p>The regression objects returned for each stage outcome
regression.</p>
</dd>
<dt>Y: </dt><dd><p>The pseudo-outcomes.</p>
</dd>
<dt>regret: </dt><dd><p>Estimates of the regret for each subject based on observed 
treatment and blip parameter estimates.</p>
</dd>
<dt>opt.treat: </dt><dd><p>Optimal treatment decisions for each subject at each 
stage of treatment.</p>
</dd>
<dt>opt.Y: </dt><dd><p>Predicted optimal outcome under recommended regimen.</p>
</dd>
</dl>

<table>
<tr><td><code>call:</code></td>
<td>
<p>The original function call.</p>
</td></tr>
</table>
<p>The functions <code>coef()</code>, <code>predict()</code> and 
<code>confint()</code> may be used with such 
model objects. The first two have specific help files for their 
implementation, while <code>confint()</code> is used in the same way as 
the standard 
<code><a href="stats.html#topic+confint">confint</a>()</code> command, with the exception of the <code>parm</code> 
option, which is not available.
</p>


<h3>Author(s)</h3>

<p>Michael Wallace
</p>
<p>Shannon T. Holloway
</p>


<h3>References</h3>

<p>Chakraborty, B., Moodie, E. E. M. (2013) <em>Statistical Methods for 
Dynamic Treatment Regimes</em>. New York: Springer.
</p>
<p>Robins, J. M. (2004) <em>Optimal structural nested models for optimal 
sequential decisions</em>. In Proceedings of the Second Seattle Symposium on 
Biostatistics, D. Y. Lin and P. J. Heagerty (eds), 189&ndash;326. New York: 
Springer.
</p>
<p>Wallace, M. P., Moodie, E. E. M. (2015) Doubly-Robust Dynamic Treatment 
Regimen Estimation Via Weighted Least Squares. <em>Biometrics</em> 
<b>71</b>(3), 636&ndash;644 (doi:10.1111/biom.12306.)
</p>
<p>Simoneau, G., Moodie, E. E. M., Nijjar, J. S., and Platt, R. W. (2020)
Finite Sample Variance Estimation for Optimal Dynamic Treatment
Regimes of Survival Outcomes. <em>Statistics in Medicine</em> <b>39</b>,
4466-4479.
</p>
<p>Efron, B., and Tibshirani, R. (1986)
Bootstrap Methods for Standard Errors, Confidence Intervals, and Other 
Measures of Statistical Accuracy <em>Source: Statistical Science</em> <b>1</b>
54-75.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(twoStageCont)

# models to be passed to DTRreg
# blip model
blip.mod &lt;- list(~ X1, ~ X2)
# treatment model (correctly specified)
treat.mod &lt;- list(A1 ~ X1, A2 ~ 1)
# treatment-free model (incorrectly specified)
tf.mod &lt;- list(~ X1, ~ X2)

# perform G-estimation
mod1 &lt;- DTRreg(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "gest")
mod1
</code></pre>

<hr>
<h2 id='DWSurv'>DTR estimation and inference for time-to-event data using DWSurv</h2><span id='topic+DWSurv'></span>

<h3>Description</h3>

<p>Dynamic treatment regimen estimation and inference via dynamic weighted 
survival modeling (DWSurv).  Inference for the blip estimators with single- 
and multi-stage data.
</p>
<p>The function <code>DWSurv()</code> allows estimating an optimal dynamic treatment regime
from multi-stage trials or observational data when the outcome of interest
is survival time subject to right-censoringg. The dynamic weighted survival 
modeling (DWSurv) algorithm is implemented.  The method focuses on 
estimating the parameters of the blip: a model of the difference in 
expected outcome under the observed treatment and some reference treatment 
(usually a control) at a given stage, assuming identical histories and 
optimal treatment thereafter.
</p>
<p>The method requires the specification of four models for each stage of the 
analysis: a treatment model (conditional mean of the treatment variable), 
a censoring model, a treatment-free model (conditional mean of outcome 
assuming only reference treatments are used), and a blip model.  Only the 
blip model must be correctly specified (or over-specified), with consistent 
parameter estimates obtainable if at least one of the treatment-free or the 
treatment and censoring models are correctly specified.  Note that all of 
these must be specified as lists of formula objects, even if only one stage
of treatment is considered.
</p>
<p>Note that as is conventional, it is assumed a larger survival time is 
preferred (which can be easily achieved via transformation of your data if 
necessary).
</p>
<p>Several treatment weight function options have been implemented within the 
package:
</p>
 
<ul>
<li><p> &quot;none&quot;: No treatment weights applied. If <code>method = "dWOLS"</code>, this 
selection results in the implementation of Q-learning, modified 
slightly to use the dWOLS style pseudo-outcome 
(computed using the observed outcome modified by the estimated 
treatment effect) rather than the traditional Q-learning outcome 
(predicted based on model only, rather than observed outcome with 
treatment effect).  
</p>
</li>
<li><p> &quot;ipw&quot;: weights based on the inverse probability of 
treatment. For binary treatments, a logistic regression is used.
For multinomial, a multinomial log-linear model is fit using 
<code><a href="nnet.html#topic+multinom">multinom</a></code>. For continuous treatments, a GLM with the specified 
family and link function provided in the <code>treat.fam</code> argument is used.
</p>
</li>
<li><p> &quot;cipw&quot;: inverse probability of treatment weights as described for
&quot;ipw&quot; and capped at the 99th percentile of the observed weights.
</p>
</li>
<li><p> &quot;qpom&quot;: weights based on the stabilized inverse 
probability of treatment applied to the categorized (into n.bins bins) 
continuous doses or multinomial treatments; probabilities are 
calculated using a proportional odds model.
This weight is appropriate only for continuous and multinomial treatments.
</p>
</li>
<li><p> &quot;wo&quot;: overlap weights for the categorized continuous doses 
or multinomial treatments (Li and Li, 2019).
This weight is appropriate only for continuous treatments.
</p>
</li>
<li><p> &quot;abs&quot;: Absolute difference <code class="reqn">|A - E[A|...]|</code>. 
appropriate only for binary treatments.
</p>
</li>
<li><p> &quot;manual&quot;: User provides treatment weights through input 
<code>treat.wgt.man</code>.
</p>
</li>
<li><p> &quot;manual.with.censor&quot;: User provides combined treatment * censoring
weights through input <code>treat.wgt.man</code>. Note that 'cens.mod' should
be specified with the event indicator on the right-hand side of the 
formula (e.g., <code>~ status</code>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>DWSurv(
  time,
  blip.mod,
  treat.mod,
  tf.mod,
  cens.mod,
  data = NULL,
  method = c("dwols", "qlearn"),
  interactive = FALSE,
  treat.type = c("bin", "multi", "cont"),
  treat.fam = gaussian(link = "identity"),
  weight = c("abs", "ipw", "cipw", "qpom", "wo", "none", "manual", "manual.with.censor"),
  n.bins = 3L,
  treat.range = NULL,
  treat.wgt.man = NULL,
  var.estim = c("none", "bootstrap", "sandwich"),
  bootstrap.controls = list(B = 100L, M = 0L, type = "standard", truncate = 0, verbose =
    FALSE, interrupt = FALSE),
  dtr = TRUE,
  full.cov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DWSurv_+3A_time">time</code></td>
<td>
<p>A list of formula specifying the survival time variable for each 
stage in order. The time variable should be specified on the right hand 
side of the formula. No dependent variable should be specified. The list 
should be as long as the number of stages.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_blip.mod">blip.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
blip function for each stage in order. No dependent variable should be 
specified. Note that this input should include the treatment variable 
ONLY if the blip model is quadratic in treatment. See Details for further 
clarification.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_treat.mod">treat.mod</code></td>
<td>
<p>A list of formula objects specifying the treatment model for
each stage in order. Treatment variable should be included as the dependent
variable. If treatment is binary <code><a href="stats.html#topic+glm">glm</a>(family = binomial)</code>
will be 
used to obtain parameter estimates; if treatment is multi-nomial, 
<code><a href="nnet.html#topic+multinom">multinom</a>()</code> will be used to obtain parameter estimates; and if 
treatment is continuous, <code><a href="stats.html#topic+lm">lm</a>()</code> will be used.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_tf.mod">tf.mod</code></td>
<td>
<p>A list of formula objects specifying covariates of the
treatment-free model for each stage in order. No dependent variable should 
be specified.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_cens.mod">cens.mod</code></td>
<td>
<p>A list of formula objects specifying the censoring
model for each stage in order. The event indicator, which takes value 1 if
an event was observed and 0 otherwise, should be included as the dependent
variable and should be the same across stages. In the absence of censoring
or if censoring weights are provided by the user through 'treat.wgt.man', 
(i.e., <code>weight = 'manual.with.censor'</code>)
one still needs to specify an event indicator on the right-hand
side of the formula and leave the left-hand side empty (see example below).</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_data">data</code></td>
<td>
<p>A data frame containing all necessary covariates and treatments
contained in the models. Missing data should be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_method">method</code></td>
<td>
<p>The DTR method to be used, choose &quot;dwols&quot; for dynamic WOLS, 
or &quot;qlearn&quot; for Q-learning.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_interactive">interactive</code></td>
<td>
<p>If <code>TRUE</code> on-screen prompts will guide the user through 
the specification of blip, treatment, and treatment-free models.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_treat.type">treat.type</code></td>
<td>
<p>A character object. Must be one of {&quot;bin&quot;, &quot;multi&quot;, &quot;cont&quot;}
indicating that the treatments at each stage are binary, multinomial,
or continuous, respectively. Each stage must have the same treatment type.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_treat.fam">treat.fam</code></td>
<td>
<p>A character or family object. 
The description of the dose distribution along with the link 
function to be used in the treatment model for computing weights; should be 
specified in a similar format as that used in <code><a href="stats.html#topic+glm">glm</a>()</code>. 
If character object, must be one of {&quot;gaussian&quot;, &quot;Gamma&quot;}, for which
<code><a href="stats.html#topic+gaussian">gaussian</a>(link = "identity")</code> or 
<code><a href="stats.html#topic+Gamma">Gamma</a>(link = "log")</code> 
will be used,
respectively. Input is ignored for <code>treat.type = "bin"</code> and 
<code>treat.type = "multi"</code>.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_weight">weight</code></td>
<td>
<p>The form of the treatment weight. See details.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_n.bins">n.bins</code></td>
<td>
<p>An integer object. The number of bins (levels) to be used for 
categorizing continuous doses. This input is required only when
<code>treat.type = "cont"</code> and <code>weight = "wo"</code> or <code>weight = "qpom"</code>.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_treat.range">treat.range</code></td>
<td>
<p>For continuous treatments. Specify the maximum/minimum 
value that treatments can be take. If unspecified then the minimum/maximum 
value of observed treatments is used. If you wish to have unrestricted 
treatments set this option to <code>c(-Inf, +Inf)</code>. If each stage has its own
range, provide as a list, the ith element providing the min and max
for the ith stage treatment.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_treat.wgt.man">treat.wgt.man</code></td>
<td>
<p>NULL or a list of vectors of known treatment 
(or treatment * censoring) weights can be 
specified to be used instead of hard-coded treatment weight options.
The <code class="reqn">i^{th}</code> element of the list contains the multiplicative weights 
for the <code class="reqn">i^{th}</code> stage. Each vector must be of length <code class="reqn">n</code>, 
the number of participants. Used only for <code>method = "dwols"</code>. If
providing the treatment * censoring weights, <code>cens.mod = NA</code> must
be used.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_var.estim">var.estim</code></td>
<td>
<p>Covariance matrix estimation method, either &quot;bootstrap&quot;
or &quot;sandwich&quot; for sandwich estimation.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_bootstrap.controls">bootstrap.controls</code></td>
<td>
<p>A named list specifying control parameters of the
bootstrap if <code>var.estim = "bootstrap"</code>. Available controls are:
</p>

<dl>
<dt>B: </dt><dd><p>The number of bootstrap samples.</p>
</dd> 
<dt>M: </dt><dd><p>The subsample size for m out of n bootstrap.</p>
</dd>
<dt>type: </dt><dd><p>The type of bootstrap. Must be one of {&quot;standard&quot;, 
&quot;empirical&quot;, &quot;normal&quot;}. The last two are parametric bootstraps.</p>
</dd>
<dt>truncate: </dt><dd><p>A number between 0 and 0.5. The lowest and highest 
specified proportion of parameter estimates will be replaced by the
relevant quantiles affording some robustness to extreme values 
when estimating covariance.</p>
</dd>
<dt>verbose: </dt><dd><p>If TRUE, estimated time to completion will be printed 
to the console every ~30 seconds.</p>
</dd>
<dt>interrupt: </dt><dd><p>If TRUE then user will be given the option 
to abort the bootstrap without error if estimated time to completion
exceeds 10 minutes.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="DWSurv_+3A_dtr">dtr</code></td>
<td>
<p>A logical object. If <code>TRUE</code>, use the DTR estimation approach, which
estimates the stage pseudo-outcome by adding a regret function. If <code>FALSE</code>,
use an 'effect estimation' approach, which treats the observed outcome
as being equal to an outcome assuming no treatment is received at any
stage, plus a blip component at each stage; each stage pseudo-outcome is 
generated by subtracting a blip function. Note that most of the 
DTR-specific output will either be suppressed or irrelevant.</p>
</td></tr>
<tr><td><code id="DWSurv_+3A_full.cov">full.cov</code></td>
<td>
<p>A logical. If <code>TRUE</code>, the full covariance matrix will be
returned. If <code>FALSE</code>, only the terms pertaining to the blip parameters
are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DWSurv</code>, a list including elements
</p>
<table>
<tr><td><code>K:</code></td>
<td>
<p>The number of decision points.</p>
</td></tr>
<tr><td><code>beta:</code></td>
<td>
<p>A list. The ith element contains the parameter estimates of
the ith stage treatment-free model.</p>
</td></tr>
<tr><td><code>psi:</code></td>
<td>
<p>A list. The ith element contains the parameter estimates of
the ith stage blip model.</p>
</td></tr>
<tr><td><code>covmat:</code></td>
<td>
<p>A list. The ith element contains covariance matrix of 
the ith stage blip parameter estimates.</p>
</td></tr>
<tr><td><code>nonreg:</code></td>
<td>
<p>Non-regularity estimates.</p>
</td></tr>
<tr><td><code>setup:</code></td>
<td>
<p>A list detailing the input parameter settings used for the
analysis</p>
</td></tr>
</table>

<ul>
<li><p> models: A list of the models used for the analysis.
</p>
</li>
<li><p> method: The parameter estimation method.
</p>
</li>
<li><p> var.estim: The variance estimation method.
</p>
</li>
<li><p> cc.modeled: If TRUE, missing data was modeled. If FALSE, cases
with missing data were removed from the analysis.
</p>
</li>
<li><p> tx.weight: The treatment weighting used for the analysis.
</p>
</li>
<li><p> tx.type: Treatment was binary, multinomial, or continuous.
</p>
</li>
<li><p> n.bins: The number of bins (levels) used for categorizing
continuous doses when <code>tx.weight = "wo"</code> or 
<code>tx.weight = "qpom"</code>.
</p>
</li>
<li><p> tx.wgt.man: Any user provided treatment weights.
</p>
</li>
<li><p> tx.range: For continuous treatments, the range of allowed
treatment values.
</p>
</li>
<li><p> tx.family: The description of the dose distribution along 
with the link function used in the continuous treatment model.
</p>
</li>
<li><p> boot.controls: A list of the bootstrap controls.
</p>
</li>
<li><p> type: The type of effect. Dynamic treatment regime or treatment
effect.
</p>
</li></ul>

<table>
<tr><td><code>training_data:</code></td>
<td>
<p>A list containing the training data.</p>
</td></tr>
</table>

<ul>
<li><p> data: The covariates and treatment data.
</p>
</li>
<li><p> outcome: The outcome of interest.
</p>
</li>
<li><p> A: The treatment variables, possibly recoded to adhere to internal
code requirements.
</p>
</li></ul>

<table>
<tr><td><code>analysis:</code></td>
<td>
<p>A list containing the primary results of each stage analysis.</p>
</td></tr>
</table>

<ul>
<li><p> n: The number of participants included in the stage analysis.
</p>
</li>
<li><p> last.stage: The last stage each participant was included in 
the analysis.
</p>
</li>
<li><p> prob.cens: The complete case probabilities.
</p>
</li>
<li><p> cens.mod.fitted: The regression objects returned for estimating
the complete case probabilities.
</p>
</li>
<li><p> cens.wgt: The complete case weights.
</p>
</li>
<li><p> cts: The treatment type at each stage.
</p>
</li>
<li><p> tx.mod.fitted: The regression objects returned for estimating
the treatment probabilities.
</p>
</li>
<li><p> A.hat: The estimated or provided treatment probabilities.
</p>
</li>
<li><p> tx.wgt: The treatment weights.
</p>
</li>
<li><p> outcome.fit: The regression objects returned for each stage outcome
regression.
</p>
</li>
<li><p> Y: The pseudo-outcomes.
</p>
</li>
<li><p> regret: Estimates of the regret for each subject based on observed 
treatment and blip parameter estimates.
</p>
</li>
<li><p> opt.treat: Optimal treatment decisions for each subject at each 
stage of treatment.
</p>
</li>
<li><p> opt.Y: Predicted optimal outcome under recommended regimen.
</p>
</li></ul>

<table>
<tr><td><code>call:</code></td>
<td>
<p>The original function call.</p>
</td></tr>
</table>
<p>The functions <code>coef()</code>, <code>predict()</code> and 
<code>confint()</code> may be used with such 
model objects. The first two have specific help files for their 
implementation, while <code>confint()</code> is used in the same way as 
the standard 
<code><a href="stats.html#topic+confint">confint</a>()</code> command, with the exception of the <code>parm</code> 
option, which is not available.
</p>


<h3>References</h3>

<p>Simoneau, G., Moodie, E. E. M., Wallace, M.P., Platt, R. W. (2020) Optimal 
Dynamic Treatment Regimes with Survival Endpoints: Introducing DWSurv in the 
R package DTRreg. <em>Journal of Statistical Computation and Simulation</em>.
<b>90</b>, 2991-3008. (doi:10.1080/00949655.2020.1793341)
</p>
<p>Simoneau, G., Moodie, E. E. M., Nijjar, J. S., Platt, R. W. (2019) Estimating 
Optimal Dynamic Treatment with Survival Outcomes. <em>Journal of the 
American Statistical Association</em>, <b>115</b>, 1531-1539 
(doi:10.1080/01621459.2019.1629939).
</p>
<p>Wallace, M. P., Moodie, E. E. M., Stephens, D. A. (2017) Dynamic Treatment 
Regimen Estimation via Regression-Based Techniques: Introducing R Package 
DTRreg. <em>Journal of Statistical Software</em> <b>80</b>(2), 1&ndash;20 
(doi:10.18637/jss.v080.i02).
</p>
<p>Simoneau, G., Moodie, E. E. M., Nijjar, J. S., and Platt, R. W. (2020)
Finite Sample Variance Estimation for Optimal Dynamic Treatment
Regimes of Survival Outcomes. <em>Statistics in Medicine</em> <b>39</b>,
4466-4479.
</p>
<p>Efron, B., and Tibshirani, R. (1986)
Bootstrap Methods for Standard Errors, Confidence Intervals, and Other 
Measures of Statistical Accuracy <em>Source: Statistical Science</em> <b>1</b>
54-75.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example single run of a 2-stage DWSurv analysis
data(twoStageCens)
mod &lt;- DWSurv(time = list(~ T1, ~ T2), 
              blip.mod = list(~ X11, ~ X21), 
              treat.mod = list(A1 ~ X11, A2 ~ 1), 
              tf.mod = list(~ X11 + X12, ~ X21 + X22 + X11), 
              cens.mod = list(delta ~ 1, delta ~ X11), 
              var.estim = "sandwich", 
              data = twoStageCens)
mod
  
#### example in the absence of censoring
data(twoStageSurv)
mod_nocensoring &lt;- DWSurv(time = list(~ T1, ~ T2), 
                          blip.mod = list(~ X11, ~ X21), 
                          treat.mod = list(A1 ~ X11, A2 ~ 1), 
                          tf.mod = list(~ X11 + X12, ~ X21 + X22 + X11), 
                          cens.mod = list(~ delta, ~ delta), 
                          var.estim = "sandwich", 
                          data = twoStageSurv)
mod_nocensoring

</code></pre>

<hr>
<h2 id='plot.DTRreg'>Diagnostic Plots for DTR Estimation</h2><span id='topic+plot.DTRreg'></span>

<h3>Description</h3>

<p>Diagnostic plots for assessment of treatment, treatment-free, and blip models 
following DTR estimation using DTRreg or DWSurv.
</p>
<p>DTR estimation using G-estimation and dWOLS requires the specification of 
three models: the treatment, treatment-free, and blip.  The treatment model 
may be assessed via standard diagnostics, whereas the treatment-free and 
blip models may be simultaneously assessed using diagnostic plots 
introduced by Rich et al.  The plot() function first presents diagnostic 
plots that assess the latter, plotting fitted values against residuals and 
covariates following DTR estimation.  If there is any evidence of a 
relationship between the variables in these plots, this is evidence that at 
least one of the blip or treatment-free models is mis-specified.
</p>
<p>Following these plots, the plot() function will present standard diagnostic 
plots for the treatment model.  These are produced directly by the standard 
plot() command applied to the models that were fit.  For example, if 
treatment is binary, the resulting plots are the same as those that are 
generated by the plot() command applied to a glm object for logistic 
regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DTRreg'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DTRreg_+3A_x">x</code></td>
<td>
<p>A model object generated by the functions DTRreg and DWSurv.</p>
</td></tr>
<tr><td><code id="plot.DTRreg_+3A_...">...</code></td>
<td>
<p>Space for additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Wallace
</p>


<h3>References</h3>

<p>Chakraborty, B., Moodie, E. E. M. (2013) <em>Statistical Methods for 
Dynamic Treatment Regimes</em>. New York: Springer.
</p>
<p>Rich B., Moodie E. E. M., Stephens D. A., Platt R. W. (2010) Model 
Checking with Residuals for G-estimation of Optimal Dynamic Treatment 
Regimes. <em>International Journal of Biostatistics</em> <b>6</b>(2), 
Article 12.
</p>
<p>Robins, J. M. (2004) <em>Optimal structural nested models for optimal 
sequential decisions</em>. In Proceedings of the Second Seattle Symposium on 
Biostatistics, D. Y. Lin and P. J. Heagerty (eds), 189-326. 
New York: Springer.
</p>
<p>Wallace, M. P., Moodie, E. M. (2015) Doubly-Robust Dynamic Treatment 
Regimen Estimation Via Weighted Least Squares. <em>Biometrics</em> 
<b>71</b>(3), 636-644 (doi:10.1111/biom.12306.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example single run of a 2-stage g-estimation analysis

set.seed(1)

# expit function
expit &lt;- function(x) { 1.0 / (1.0 + exp(-x)) }

# sample size
n &lt;- 10000

# variables (X = patient information, A = treatment)
X1 &lt;- rnorm(n)
A1 &lt;- rbinom(n, 1, expit(X1))
X2 &lt;- rnorm(n)
A2 &lt;- rbinom(n, 1, expit(X2))

# blip functions
gamma1 &lt;- A1 * (1 + X1)
gamma2 &lt;- A2 * (1 + X2)

# observed outcome: treatment-free outcome plus blip functions
Y &lt;- exp(X1) + exp(X2) + gamma1 + gamma2 + rnorm(n)

# models to be passed to DTRreg
# blip model
blip.mod &lt;- list(~ X1, ~ X2)
# treatment model (correctly specified)
treat.mod &lt;- list(A1 ~ X1, A2 ~ 1)
# treatment-free model (incorrectly specified)
tf.mod &lt;- list(~ X1, ~ X2)

# perform G-estimation
mod1 &lt;- DTRreg(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "gest")
 
# model diagnostics: note treatment-free model is mis-specified
plot(mod1)

</code></pre>

<hr>
<h2 id='predict.DTRreg'>Optimal Outcome Prediction for DTRs</h2><span id='topic+predict.DTRreg'></span>

<h3>Description</h3>

<p>Predicted outcome assuming optimal treatment (according to analysis via 
G-estimation or dWOLS) was followed.  Assumes blip and treatment-free 
models correctly specified.
</p>
<p>This function may be used in a similar fashion to more traditional modeling 
commands (such as lm).  Users are referred to the primary 'DTRreg()' 
and 'DTRSurv()' help command
(and associated literature) for information concerning model specification.
In particular, we note that the predict function assumes that the 
treatment-free model has been correctly specified, as the treatment-free 
parameters are used in the prediction process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DTRreg'
predict(object, newdata, treat.range = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DTRreg_+3A_object">object</code></td>
<td>
<p>A model object generated by the function 'DTRreg()' or 'DWSurv()'.</p>
</td></tr>
<tr><td><code id="predict.DTRreg_+3A_newdata">newdata</code></td>
<td>
<p>A dataset (usually the data analyzed by DTRreg for which 
predicted outcomes are desired.  If a new dataset is provided, variable 
names should correspond to those presented to 'DTRreg()' or 'DWSurv()'.</p>
</td></tr>
<tr><td><code id="predict.DTRreg_+3A_treat.range">treat.range</code></td>
<td>
<p>If treatment is continuous (rather than binary), a 
vectors of the form c(min,max) which specify the minimum and maximum value 
the treatment may take at stage 1.  
If unspecified, this will be inferred from the 
treat.range provided with use of the original DTRreg command.  As such, if 
no treatment range was specified there either, treat.range will be the 
minimum and maximum observed first stage treatment.</p>
</td></tr>
<tr><td><code id="predict.DTRreg_+3A_...">...</code></td>
<td>
<p>Space for additional arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n</code> x 1 matrix of predicted outcome values.
</p>


<h3>Author(s)</h3>

<p>Michael Wallace
</p>


<h3>References</h3>

<p>Chakraborty, B., Moodie, E. E. M. (2013) <em>Statistical Methods for 
Dynamic Treatment Regimes</em>. New York: Springer.
</p>
<p>Robins, J. M. (2004) <em>Optimal structural nested models for optimal 
sequential decisions</em>. In Proceedings of the Second Seattle Symposium on 
Biostatistics, D. Y. Lin and P. J. Heagerty (eds), 189-326. 
New York: Springer.
</p>
<p>Wallace, M. P., Moodie, E. M. (2015) Doubly-Robust Dynamic Treatment Regimen 
Estimation Via Weighted Least Squares. <em>Biometrics</em> <b>71</b>(3), 
636-644 (doi:10.1111/biom.12306.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example single run of a 2-stage g-estimation analysis

set.seed(1)

# expit function
expit &lt;- function(x) { 1.0 / (1.0 + exp(-x)) }

# sample size
n &lt;- 10000

# variables (X = patient information, A = treatment)
X1 &lt;- rnorm(n)
A1 &lt;- rbinom(n, 1, expit(X1))
X2 &lt;- rnorm(n)
A2 &lt;- rbinom(n, 1, expit(X2))

# blip functions
gamma1 &lt;- A1 * (1 + X1)
gamma2 &lt;- A2 * (1 + X2)

# observed outcome: treatment-free outcome plus blip functions
Y &lt;- exp(X1) + exp(X2) + gamma1 + gamma2 + rnorm(n)

# models to be passed to DTRreg
# blip model
blip.mod &lt;- list(~ X1, ~ X2)
# treatment model (correctly specified)
treat.mod &lt;- list(A1 ~ X1, A2 ~ 1)
# treatment-free model (incorrectly specified)
tf.mod &lt;- list(~ X1, ~ X2)

# perform G-estimation
mod1 &lt;- DTRreg(twoStageCont$Y, blip.mod, treat.mod, tf.mod, 
               data = twoStageCont, method = "gest")
  
# predicted Y for optimal treatment
dat &lt;- data.frame(X1, X2, A1, A2)
predict(mod1, newdata = dat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
