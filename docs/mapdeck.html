<!DOCTYPE html><html><head><title>Help for package mapdeck</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapdeck}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe</p></a></li>
<li><a href='#add_animated_arc'><p>Add animated arc</p></a></li>
<li><a href='#add_animated_line'><p>Add Animated line</p></a></li>
<li><a href='#add_arc'><p>Add arc</p></a></li>
<li><a href='#add_bitmap'><p>Add bitmap</p></a></li>
<li><a href='#add_cesium'><p>Add Cesium</p></a></li>
<li><a href='#add_column'><p>Add column</p></a></li>
<li><a href='#add_dependencies'><p>Add Dependencies</p></a></li>
<li><a href='#add_geojson'><p>Add Geojson</p></a></li>
<li><a href='#add_greatcircle'><p>Add greatcircle</p></a></li>
<li><a href='#add_grid'><p>Add Grid</p></a></li>
<li><a href='#add_h3'><p>Add h3</p></a></li>
<li><a href='#add_heatmap'><p>Add Heatmap</p></a></li>
<li><a href='#add_hexagon'><p>Add hexagon</p></a></li>
<li><a href='#add_i3s'><p>Add I3S</p></a></li>
<li><a href='#add_line'><p>Add line</p></a></li>
<li><a href='#add_mesh'><p>Add Mesh</p></a></li>
<li><a href='#add_path'><p>Add Path</p></a></li>
<li><a href='#add_pointcloud'><p>Add Pointcloud</p></a></li>
<li><a href='#add_polygon'><p>Add Polygon</p></a></li>
<li><a href='#add_scatterplot'><p>Add Scatterplot</p></a></li>
<li><a href='#add_screengrid'><p>Add Screengrid</p></a></li>
<li><a href='#add_sf'><p>Add sf</p></a></li>
<li><a href='#add_terrain'><p>Add terrain</p></a></li>
<li><a href='#add_text'><p>Add Text</p></a></li>
<li><a href='#add_title'><p>Add Title</p></a></li>
<li><a href='#add_trips'><p>Add Trips</p></a></li>
<li><a href='#capitals'><p>Capital cities for each country</p></a></li>
<li><a href='#city_trail'><p>city_trail</p></a></li>
<li><a href='#clear_animated_arc'><p>Clear Animated Arc</p></a></li>
<li><a href='#clear_legend'><p>Clear Legend</p></a></li>
<li><a href='#clear_tokens'><p>Clear tokens</p></a></li>
<li><a href='#geojson'><p>Geojson</p></a></li>
<li><a href='#legend_element'><p>Legend Element</p></a></li>
<li><a href='#light_settings'><p>Light Settings</p></a></li>
<li><a href='#mapdeck'><p>mapdeck</p></a></li>
<li><a href='#mapdeck_dependencies'><p>Mapdeck Dependencies</p></a></li>
<li><a href='#mapdeck_dispatch'><p>mapdeck dispatch</p></a></li>
<li><a href='#mapdeck_legend'><p>Mapdeck Legend</p></a></li>
<li><a href='#mapdeck_style'><p>Mapdeck Style</p></a></li>
<li><a href='#mapdeck_tokens'><p>Mapdeck_tokens</p></a></li>
<li><a href='#mapdeck_update'><p>Mapdeck update</p></a></li>
<li><a href='#mapdeck_view'><p>Mapdeck view</p></a></li>
<li><a href='#mapdeck-shiny'><p>Shiny bindings for mapdeck</p></a></li>
<li><a href='#melbourne'><p>Polygons in and around Melbourne</p></a></li>
<li><a href='#melbourne_mesh'><p>Melbourne Mesh</p></a></li>
<li><a href='#road_safety'><p>road_safety</p></a></li>
<li><a href='#roads'><p>Roads in central Melbourne</p></a></li>
<li><a href='#set_token'><p>Set Token</p></a></li>
<li><a href='#update_style'><p>update style</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interactive Maps Using 'Mapbox GL JS' and 'Deck.gl'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a mechanism to plot an interactive map using 'Mapbox GL' 
		(<a href="https://docs.mapbox.com/mapbox-gl-js/api/">https://docs.mapbox.com/mapbox-gl-js/api/</a>), a javascript library for interactive maps,
		and 'Deck.gl' (<a href="https://deck.gl/">https://deck.gl/</a>), a javascript library which uses 'WebGL' for 
		visualising large data sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://symbolixau.github.io/mapdeck/articles/mapdeck.html">https://symbolixau.github.io/mapdeck/articles/mapdeck.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SymbolixAU/mapdeck/issues">https://github.com/SymbolixAU/mapdeck/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++14</td>
</tr>
<tr>
<td>Imports:</td>
<td>colourvalues (&ge; 0.3.9), googlePolylines (&ge; 0.7.2), geojsonsf
(&ge; 2.0.3), htmlwidgets, jsonify (&ge; 1.2.2), magrittr, Rcpp (&ge;
1.0.10), shiny, sfheaders (&ge; 0.4.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, colourvalues (&ge; 0.3.9), geojsonsf (&ge; 2.0.3),
geometries (&ge; 0.2.4), interleave (&ge; 0.1.2), jsonify (&ge;
1.2.2), rapidjsonr, Rcpp (&ge; 1.0.10), sfheaders (&ge; 0.4.4),
spatialwidget (&ge; 0.2.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, googleway, jsonlite, knitr, rmarkdown, spatialwidget,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 02:43:51 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Cooley [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Cooley &lt;dcooley@symbolix.com.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 23:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Uses the pipe operator (<code>%&gt;%</code>) to chain statements. Useful for adding
layers to a <code>mapdeck</code> map
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code>, <code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A mapdeck map and a layer to add to it</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

token &lt;- "your_api_token"
mapdeck(token = token) %&gt;%
add_scatterplot(
  data = capitals
  , lat = "lat"
  , lon = "lon"
  , radius = 100000
  , fill_colour = "country"
  , layer_id = "scatter_layer"
)

</code></pre>

<hr>
<h2 id='add_animated_arc'>Add animated arc</h2><span id='topic+add_animated_arc'></span>

<h3>Description</h3>

<p>The Arc Layer renders raised arcs joining pairs of source and target coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_animated_arc(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  origin,
  destination,
  id = NULL,
  stroke_from = NULL,
  stroke_from_opacity = NULL,
  stroke_to = NULL,
  stroke_to_opacity = NULL,
  stroke_width = NULL,
  frequency = 1,
  animation_speed = 3,
  trail_length = 5,
  tilt = NULL,
  height = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  legend = F,
  legend_options = NULL,
  legend_format = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  update_view = TRUE,
  focus_layer = FALSE,
  transitions = NULL,
  digits = 6,
  brush_radius = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_animated_arc_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_origin">origin</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevation column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_destination">destination</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevatino column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_stroke_from">stroke_from</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the staring stroke colour.
IIf using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_stroke_from_opacity">stroke_from_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_stroke_to">stroke_to</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the ending stroke colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_stroke_to_opacity">stroke_to_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in pixels</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_frequency">frequency</code></td>
<td>
<p>column of <code>data</code>, or a single value indicating the number of
arcs generated in each animation</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_animation_speed">animation_speed</code></td>
<td>
<p>the speed of animation</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_trail_length">trail_length</code></td>
<td>
<p>the length of trail of each arc</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_tilt">tilt</code></td>
<td>
<p>value to tilt the arcs to the side, in degrees [-90, 90]</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_height">height</code></td>
<td>
<p>value to multiply the height.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_animated_arc_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_arc</code> supports POINT sf objects
</p>
<p>MULTIPOINT objects will be treated as single points. That is, if an sf objet
has one row with a MULTIPOINT object consisting of two points, this will
be expanded to two rows of single POINTs.
Therefore, if the origin is a MULTIPOINT of two points, and the destination is
a single POINT, the code will error as there will be an uneven number of rows
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

url &lt;- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
flights &lt;- read.csv(url)
flights$id &lt;- seq_len(nrow(flights))
flights$stroke &lt;- sample(1:3, size = nrow(flights), replace = TRUE)
flights$info &lt;- paste0("&lt;b&gt;",flights$airport1, " - ", flights$airport2, "&lt;/b&gt;")

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
  add_animated_arc(
  data = flights
  , layer_id = "arc_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  , trail_length = 10
  , tooltip = "info"
  , auto_highlight = TRUE
  , legend = TRUE
  , legend_options = list(
    stroke_from = list( title = "Origin airport" ),
    css = "max-height: 100px;")
 )

## faster animation_speed
mapdeck( style = mapdeck_style("dark")) %&gt;%
  add_animated_arc(
  data = flights
  , layer_id = "arc_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  , trail_length = 10
  , animation_speed = 15
  )




</code></pre>

<hr>
<h2 id='add_animated_line'>Add Animated line</h2><span id='topic+add_animated_line'></span>

<h3>Description</h3>

<p>The Line Layer renders raised lines joining pairs of source and target coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_animated_line(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  origin,
  destination,
  id = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  frequency = 1,
  animation_speed = 3,
  trail_length = 5,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_animated_line_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_origin">origin</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevation column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_destination">destination</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevatino column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable or hex colour to use as the ending stroke colour.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the line in metres</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_frequency">frequency</code></td>
<td>
<p>column of <code>data</code>, or a single value indicating the number of
arcs generated in each animation</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_animation_speed">animation_speed</code></td>
<td>
<p>the speed of animation</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_trail_length">trail_length</code></td>
<td>
<p>the length of trail of each arc</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_animated_line_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_line</code> supports POINT sf objects
</p>
<p>MULTIPOINT objects will be treated as single points. That is, if an sf object
has one row with a MULTIPOINT object consisting of two points, this will
be expanded to two rows of single POINTs.
Therefore, if the origin is a MULTIPOINT of two points, and the destination is
a single POINT, the code will error as there will be an uneven number of rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

url &lt;- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
flights &lt;- read.csv(url)
flights$id &lt;- seq_len(nrow(flights))
flights$stroke &lt;- sample(1:3, size = nrow(flights), replace = TRUE)

mapdeck(style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
  add_animated_line(
    data = flights
    , layer_id = "line_layer"
    , origin = c("start_lon", "start_lat")
    , destination = c("end_lon", "end_lat")
    , stroke_colour = "airport1"
    , stroke_width = "stroke"
    , auto_highlight = TRUE
    , trail_length = 1
    , animation_speed = 1
 )

## Using a 2-sfc-column sf object
library(sfheaders)

sf_flights &lt;- sfheaders::sf_point( flights, x = "start_lon", y = "start_lat", keep = TRUE )
destination &lt;- sfheaders::sfc_point( flights, x = "end_lon", y = "end_lat" )

sf_flights$destination &lt;- destination

mapdeck() %&gt;%
 add_animated_line(
   data = sf_flights
   , origin = 'geometry'
   , destination = 'destination'
   , layer_id = 'arcs'
   , stroke_colour = "airport1"
   , trail_length = 1
   , animation_speed = 2
)


</code></pre>

<hr>
<h2 id='add_arc'>Add arc</h2><span id='topic+add_arc'></span>

<h3>Description</h3>

<p>The Arc Layer renders raised arcs joining pairs of source and target coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_arc(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  origin,
  destination,
  id = NULL,
  stroke_from = NULL,
  stroke_from_opacity = NULL,
  stroke_to = NULL,
  stroke_to_opacity = NULL,
  stroke_width = NULL,
  tilt = NULL,
  height = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  legend = F,
  legend_options = NULL,
  legend_format = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  update_view = TRUE,
  focus_layer = FALSE,
  transitions = NULL,
  digits = 6,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_arc_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_arc_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_arc_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_arc_+3A_origin">origin</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevation column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_arc_+3A_destination">destination</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevatino column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_arc_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_stroke_from">stroke_from</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the staring stroke colour.
IIf using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_arc_+3A_stroke_from_opacity">stroke_from_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_arc_+3A_stroke_to">stroke_to</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the ending stroke colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_arc_+3A_stroke_to_opacity">stroke_to_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_arc_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in pixels</p>
</td></tr>
<tr><td><code id="add_arc_+3A_tilt">tilt</code></td>
<td>
<p>value to tilt the arcs to the side, in degrees [-90, 90]</p>
</td></tr>
<tr><td><code id="add_arc_+3A_height">height</code></td>
<td>
<p>value to multiply the height.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_arc_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_arc_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_arc_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_arc_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_arc_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_arc_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_arc_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_arc_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_arc_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_arc_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_arc</code> supports POINT sf objects
</p>
<p>MULTIPOINT objects will be treated as single points. That is, if an sf objet
has one row with a MULTIPOINT object consisting of two points, this will
be expanded to two rows of single POINTs.
Therefore, if the origin is a MULTIPOINT of two points, and the destination is
a single POINT, the code will error as there will be an uneven number of rows
</p>


<h3>data</h3>

<p>If <code>data</code> is a simple feature object, you need to supply the origin and destination
columns, they aren't automatically detected.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for arc
</p>
<p>list(
origin = 0,
destination = 0,
stroke_from = 0,
stroke_to = 0,
stroke_width = 0
)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

url &lt;- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
flights &lt;- read.csv(url)
flights$id &lt;- seq_len(nrow(flights))
flights$stroke &lt;- sample(1:3, size = nrow(flights), replace = TRUE)
flights$info &lt;- paste0("&lt;b&gt;",flights$airport1, " - ", flights$airport2, "&lt;/b&gt;")

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
  add_arc(
  data = flights
  , layer_id = "arc_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  , tooltip = "info"
  , auto_highlight = TRUE
  , legend = TRUE
  , legend_options = list(
    stroke_from = list( title = "Origin airport" ),
    css = "max-height: 100px;")
 )

mapdeck( style = mapdeck_style("dark")) %&gt;%
  add_arc(
  data = flights
  , layer_id = "arc_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  )

## Arcs can have an elevated start &amp; destination
flights$start_elev &lt;- sample(100000:1000000, size = nrow(flights), replace = TRUE )

mapdeck( style = mapdeck_style("dark")) %&gt;%
  add_arc(
  data = flights
  , layer_id = "arc_layer"
  , origin = c("start_lon", "start_lat", "start_elev")
  , destination = c("end_lon", "end_lat", "start_elev")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  )

## Using a 2-sfc-column sf object
library(sfheaders)

sf_flights &lt;- sfheaders::sf_point(
  flights
  , x = "start_lon"
  , y = "start_lat"
  , z = "start_elev"
  , keep = TRUE
  )
destination &lt;- sfheaders::sfc_point(
  flights
  , x = "end_lon"
  , y = "end_lat"
  , z = "start_elev"
  )

sf_flights$destination &lt;- destination

mapdeck(
) %&gt;%
 add_arc(
   data = sf_flights
   , origin = 'geometry'
   , destination = 'destination'
   , layer_id = 'arcs'
   , stroke_from = "airport1"
   , stroke_to = "airport2"
)

## using a brush

mapdeck(
  , style = mapdeck_style("light")
) %&gt;%
 add_arc(
   data = sf_flights
   , origin = 'geometry'
   , destination = 'destination'
   , layer_id = 'arcs'
   , stroke_from = "airport1"
   , stroke_to = "airport2"
   , stroke_width = 4
   , brush_radius = 500000
)





</code></pre>

<hr>
<h2 id='add_bitmap'>Add bitmap</h2><span id='topic+add_bitmap'></span>

<h3>Description</h3>

<p>Adds an image to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_bitmap(
  map,
  image,
  bounds,
  desaturate = 0,
  transparent_colour = "#000000",
  tint_colour = "#FFFFFF",
  layer_id = NULL,
  update_view = TRUE,
  focus_layer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_bitmap_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_image">image</code></td>
<td>
<p>url to an image to use on the map</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_bounds">bounds</code></td>
<td>
<p>coordinates of the bounding box of the image [left, bottom, right, top]</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_desaturate">desaturate</code></td>
<td>
<p>the desatruation of the bitmap, in range [0,1], 0 being the original colour
and 1 being greyscale</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_transparent_colour">transparent_colour</code></td>
<td>
<p>the colour to use for transparent pixels as a hex string</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_tint_colour">tint_colour</code></td>
<td>
<p>the colour to tint the bipmap by, as a hex string</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_bitmap_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

set_token( "MAPBOX_TOKEN" )

mapdeck(location = c(-122.3, 37.8), zoom = 10) %&gt;%
 add_bitmap(
   image = paste0(
   'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
   'website/sf-districts.png')
   , bounds = c(-122.519, 37.7045, -122.355, 37.829)
 )

mapdeck(location = c(-75.9, 40.9), zoom = 4) %&gt;%
  add_bitmap(
    image = 'https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif'
    , bounds = c(-80.425, 37.936, -71.516, 46.437)
  )

mapdeck(location = c(-75.9, 40.9), zoom = 4) %&gt;%
  add_bitmap(
    image = 'https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif'
    , bounds = c(-80.425, 37.936, -71.516, 46.437)
    , tint_colour = "#FF0000"
  )

mapdeck(location = c(-75.9, 40.9), zoom = 4) %&gt;%
  add_bitmap(
    image = 'https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif'
    , bounds = c(-80.425, 37.936, -71.516, 46.437)
    , desaturate = 1
  )



</code></pre>

<hr>
<h2 id='add_cesium'>Add Cesium</h2><span id='topic+add_cesium'></span>

<h3>Description</h3>

<p>Renders 3D tiles data from Cesium ION assets. To use this layer you need a
Cesium ION account <a href="https://cesium.com/learn/cesiumjs-learn/cesiumjs-quickstart/#your-first-app">https://cesium.com/learn/cesiumjs-learn/cesiumjs-quickstart/#your-first-app</a>.
This layer is experimental
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cesium(map, data, point_size = 2, layer_id = NULL, ion_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cesium_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_cesium_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_cesium_+3A_point_size">point_size</code></td>
<td>
<p>size of point in pixels</p>
</td></tr>
<tr><td><code id="add_cesium_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_cesium_+3A_ion_token">ion_token</code></td>
<td>
<p>ion asset token</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## Melbourne point cloud
ion_asset &lt;- 43978
ion_token &lt;- "ION_TOKEN"
tile_data &lt;- paste0("https://assets.ion.cesium.com/",ion_asset,"/tileset.json")

mapdeck(
  location = c(144.95, -37.82)
  , zoom = 14
  , pitch = 60
) %&gt;%
 add_cesium(
   data = tile_data
   , ion_token = ion_token
 )



</code></pre>

<hr>
<h2 id='add_column'>Add column</h2><span id='topic+add_column'></span>

<h3>Description</h3>

<p>The ColumnLayer can be used to render a heatmap of vertical cylinders. It renders
a tesselated regular polygon centered at each given position (a &quot;disk&quot;), and extrude it in 3d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_column(
  map,
  data = get_map_data(map),
  polyline = NULL,
  lon = NULL,
  lat = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  stroke_colour = NULL,
  stroke_opacity = NULL,
  stroke_width = NULL,
  radius = 1000,
  elevation = NULL,
  elevation_scale = 1,
  coverage = 1,
  angle = 0,
  disk_resolution = 20,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_column_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_column_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_column_+3A_polyline">polyline</code></td>
<td>
<p>column of <code>data</code> containing the polylines</p>
</td></tr>
<tr><td><code id="add_column_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_column_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_column_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_column_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_column_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of <code>data</code> or hex colour for the stroke. If used,
<code>elevation</code> is ignored.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_column_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_column_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. If used, <code>elevation</code> is ignored. Default 1.</p>
</td></tr>
<tr><td><code id="add_column_+3A_radius">radius</code></td>
<td>
<p>in metres. Default 1000</p>
</td></tr>
<tr><td><code id="add_column_+3A_elevation">elevation</code></td>
<td>
<p>the height the polygon extrudes from the map. Only available if neither
<code>stroke_colour</code> or <code>stroke_width</code> are supplied. Default 0</p>
</td></tr>
<tr><td><code id="add_column_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>value to scale the elevations of the columns Default 1</p>
</td></tr>
<tr><td><code id="add_column_+3A_coverage">coverage</code></td>
<td>
<p>radius multiplier, in range [0,1]. The radius of the disk is calcualted
by coverage * radius</p>
</td></tr>
<tr><td><code id="add_column_+3A_angle">angle</code></td>
<td>
<p>disk rotation, counter-clockwise, in degrees</p>
</td></tr>
<tr><td><code id="add_column_+3A_disk_resolution">disk_resolution</code></td>
<td>
<p>The number of sides to render the disk as.
The disk is a regular polygon that fits inside the given radius.
A higher resolution will yield a smoother look close-up, but also requires more resources to render.</p>
</td></tr>
<tr><td><code id="add_column_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_column_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_column_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_column_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_column_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_column_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_column_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_column_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_column_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_column_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_column_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_column_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_column_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_column_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_column_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_column_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_column</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )


df &lt;- capitals
df$elev &lt;- sample(50000:500000, size = nrow(df), replace = TRUE)

mapdeck(style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_column(
  data = df
  , lat = "lat"
  , lon = "lon"
  , elevation = "elev"
  , fill_colour = "lon"
  , disk_resolution = 20
  , radius = 100000
  , tooltip = "capital"
)

library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lon", y = "lat" )

sf$elev &lt;- df$elev

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_column(
  data = sf
  , layer_id = "col_layer"
  , elevation = "elev"
  , radius = 100000
  , fill_colour = "country"
)



## End(Not run)

</code></pre>

<hr>
<h2 id='add_dependencies'>Add Dependencies</h2><span id='topic+add_dependencies'></span>

<h3>Description</h3>

<p>Adds the required mapdeck javascript dependencies to a map when not using a mapdeck map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dependencies(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dependencies_+3A_map">map</code></td>
<td>
<p>the map object to which dependencies will be added</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## use with a google map from googleway
library(googleway)

set_key("GOOGLE_MAP_KEY")

google_map() %&gt;%
	add_dependencies() %&gt;%
	add_scatterplot(
		data = capitals
		, lon = "lon"
		, lat = "lat"
		, fill_colour = "country"
		, radius = 10000
	)





</code></pre>

<hr>
<h2 id='add_geojson'>Add Geojson</h2><span id='topic+add_geojson'></span>

<h3>Description</h3>

<p>The GeoJson Layer takes in GeoJson formatted data and renders it as interactive polygons,
lines and points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_geojson(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  stroke_colour = NULL,
  stroke_opacity = NULL,
  stroke_width = NULL,
  dash_size = NULL,
  dash_gap = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  radius = NULL,
  elevation = NULL,
  extruded = FALSE,
  light_settings = list(),
  legend = F,
  legend_options = NULL,
  legend_format = NULL,
  auto_highlight = FALSE,
  tooltip = NULL,
  highlight_colour = "#AAFFFFFF",
  palette = "viridis",
  na_colour = "#808080FF",
  line_width_units = c("meters", "pixels"),
  line_width_scale = 1,
  line_width_min_pixels = 0,
  elevation_scale = 1,
  point_radius_scale = 1,
  point_radius_min_pixels = 1,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_geojson_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. Can be a url to GeoJSON</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>column of an <code>sf</code> object, or field inside a GeoJSON <code>property</code> to use for colour</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>column of an <code>sf</code> object, or field inside a GeoJSON <code>property</code> to use for opacity</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_stroke_width">stroke_width</code></td>
<td>
<p>column of an <code>sf</code> object, or field inside a GeoJSON <code>property</code> to use for width (in meters)</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_dash_size">dash_size</code></td>
<td>
<p>size of each dash, relative to the width of the stroke</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_dash_gap">dash_gap</code></td>
<td>
<p>size of the gap between dashes, relative to the width of the stroke</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of an <code>sf</code> object, or field inside a GeoJSON <code>property</code> to use for colour</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>column of an <code>sf</code> object, or field inside a GeoJSON <code>property</code> to use for opacity</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_radius">radius</code></td>
<td>
<p>radius of points in meters. Default 1. See details</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_elevation">elevation</code></td>
<td>
<p>elevation of polygons. Default 0. See details</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_extruded">extruded</code></td>
<td>
<p>logical indicating if polygons should extrude from the map.
If <code>TRUE</code>, <code>stroke_colour</code> for polygons is ignored</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_light_settings">light_settings</code></td>
<td>
<p>list of light setting parameters. See <a href="#topic+light_settings">light_settings</a></p>
</td></tr>
<tr><td><code id="add_geojson_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.
A legend is only shown if you supply one of the colour arguments (fill or stroke)</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip.
Only works on <code>sf</code> objects.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_line_width_units">line_width_units</code></td>
<td>
<p>The units of the line width, one of 'meters', 'pixels'.
When zooming in and out, meter sizes scale with the base map, and pixel sizes remain the same on screen.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_line_width_scale">line_width_scale</code></td>
<td>
<p>The line width multiplier that multiplied to all lines,
including the LineString and MultiLineString features and also the outline for
Polygon and MultiPolygon features if the stroked attribute is true</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_line_width_min_pixels">line_width_min_pixels</code></td>
<td>
<p>The minimum line width in pixels.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>Elevation multiplier. The final elevation is calculated by
elevationScale * getElevation(d). elevationScale is a handy property to scale
all polygon elevation without updating the data</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_point_radius_scale">point_radius_scale</code></td>
<td>
<p>A global radius multiplier for all points.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_point_radius_min_pixels">point_radius_min_pixels</code></td>
<td>
<p>The minimum radius in pixels.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_geojson_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for geojson
</p>
<p>list(
fill_colour = 0,
stroke_colour = 0,
stroke_width = 0,
elevation = 0,
radius = 0
)
</p>


<h3>Raw Geojson</h3>

<p>If using a GeoJSON string, and you <strong>do not</strong> suppply one of the colouring arguments, the
function will look for these fields inside the <code>properties</code> field of the Geojson
</p>
<p><strong>fill_colour</strong>
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>fillColour
</p>
</li>
<li><p>fill_color
</p>
</li>
<li><p>fillColor
</p>
</li>
<li><p>fill
</p>
</li></ul>

<p><strong>stroke_colour</strong>
</p>

<ul>
<li><p>stroke_colour
</p>
</li>
<li><p>strokeColour
</p>
</li>
<li><p>stroke_color
</p>
</li>
<li><p>strokeColor
</p>
</li>
<li><p>stroke
</p>
</li>
<li><p>line_colour
</p>
</li>
<li><p>lineColour
</p>
</li>
<li><p>line_color
</p>
</li>
<li><p>lineColor
</p>
</li>
<li><p>line
</p>
</li></ul>

<p><strong>stroke_width</strong>
</p>

<ul>
<li><p>stroke_width
</p>
</li>
<li><p>strokeWdith
</p>
</li>
<li><p>line_width
</p>
</li>
<li><p>lineWidth
</p>
</li>
<li><p>width
</p>
</li></ul>


<ul>
<li><p>elevation
</p>
</li>
<li><p>radius
</p>
</li></ul>

<p>These colour values should be valid hex-colour strings.
</p>
<p>If you <strong>do</strong> provide values for the colouring arguments, the function will assume
you want to use specific fields in the geojson for colouring. However, if you only supply a
<code>fill_colour</code> value, the function will not automatically detect the <code>stroke_colour</code>
(and vice versa)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

## Not supplying colouring arguments, the function will try and find them in the GeoJSON
mapdeck(
 , location = c(145, -37.9)
 , zoom = 8
 , style = mapdeck_style("dark")
 , pitch = 35
) %&gt;%
 add_geojson(
   data = geojson
   , auto_highlight = TRUE
 )

## only supplying values to use for fill, the stroke will be default
mapdeck(
 , location = c(145, -37.9)
 , zoom = 8
 , style = mapdeck_style("dark")
 , pitch = 35
) %&gt;%
 add_geojson(
   data = geojson
   , fill_colour = "random"
 )

mapdeck(
 , location = c(145, -37.9)
 , zoom = 8
 , style = mapdeck_style("dark")
 , pitch = 35
) %&gt;%
 add_geojson(
   data = geojson
   , fill_colour = "random"
   , stroke_colour = "random"
 )

mapdeck(
 , location = c(145, -37.9)
 , zoom = 8
 , style = mapdeck_style("dark")
 , pitch = 35
) %&gt;%
 add_geojson(
   data = geojson
   , fill_colour = "random"
   , stroke_colour = "random"
   , elevation = 300
 )

## putting elevation and width values onto raw GeoJSON
library(geojsonsf)
sf &lt;- geojsonsf::geojson_sf( geojson )
sf$width &lt;- sample(1:100, size = nrow(sf), replace = TRUE)
sf$elevation &lt;- sample(100:1000, size = nrow(sf), replace = TRUE)
geo &lt;- geojsonsf::sf_geojson( sf )

mapdeck(
 , location = c(145, -37.9)
 , zoom = 8
 , style = mapdeck_style("dark")
 , pitch = 35
) %&gt;%
 add_geojson(
   data = geo
   , extruded = TRUE ## required to show elevated polygons
 )




</code></pre>

<hr>
<h2 id='add_greatcircle'>Add greatcircle</h2><span id='topic+add_greatcircle'></span>

<h3>Description</h3>

<p>Renders flat arcs along the great circle joining pairs
of source and target points, specified as longitude/latitude coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_greatcircle(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  origin,
  destination,
  id = NULL,
  stroke_from = NULL,
  stroke_from_opacity = NULL,
  stroke_to = NULL,
  stroke_to_opacity = NULL,
  stroke_width = NULL,
  wrap_longitude = FALSE,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  legend = F,
  legend_options = NULL,
  legend_format = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  update_view = TRUE,
  focus_layer = FALSE,
  transitions = NULL,
  digits = 6,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_greatcircle_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_origin">origin</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevation column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_destination">destination</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevatino column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_stroke_from">stroke_from</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the staring stroke colour.
IIf using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_stroke_from_opacity">stroke_from_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_stroke_to">stroke_to</code></td>
<td>
<p>column of <code>data</code> or hex colour to use as the ending stroke colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_stroke_to_opacity">stroke_to_opacity</code></td>
<td>
<p>Either a string specifying the
column of <code>data</code> containing the stroke opacity of each shape, or a value
between 1 and 255 to be applied to all the shapes. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in pixels</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_wrap_longitude">wrap_longitude</code></td>
<td>
<p>logical, whether to automatically wrap longitudes over the
180th antimeridian.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_greatcircle_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_greatcircle</code> supports POINT sf objects
</p>
<p>MULTIPOINT objects will be treated as single points. That is, if an sf objet
has one row with a MULTIPOINT object consisting of two points, this will
be expanded to two rows of single POINTs.
Therefore, if the origin is a MULTIPOINT of two points, and the destination is
a single POINT, the code will error as there will be an uneven number of rows
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
set_token("MAPBOX_TOKEN")

url &lt;- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
flights &lt;- read.csv(url)
flights$id &lt;- seq_len(nrow(flights))
flights$stroke &lt;- sample(1:3, size = nrow(flights), replace = TRUE)
flights$info &lt;- paste0("&lt;b&gt;",flights$airport1, " - ", flights$airport2, "&lt;/b&gt;")

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
  add_greatcircle(
  data = flights
  , layer_id = "greatcircle_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  , tooltip = "info"
  , auto_highlight = TRUE
  , legend = TRUE
  , legend_options = list(
    stroke_from = list( title = "Origin airport" ),
    css = "max-height: 100px;")
 )

mapdeck( style = mapdeck_style("dark")) %&gt;%
  add_greatcircle(
  data = flights
  , layer_id = "greatcircle_layer"
  , origin = c("start_lon", "start_lat")
  , destination = c("end_lon", "end_lat")
  , stroke_from = "airport1"
  , stroke_to = "airport2"
  , stroke_width = "stroke"
  )

## Using a 2-sfc-column sf object
library(sfheaders)

sf_flights &lt;- sfheaders::sf_point( flights, x = "start_lon", y = "start_lat", keep = TRUE )
destination &lt;- sfheaders::sfc_point( flights, x = "end_lon", y = "end_lat" )

sf_flights$destination &lt;- destination

mapdeck() %&gt;%
 add_greatcircle(
   data = sf_flights
   , origin = 'geometry'
   , destination = 'destination'
   , layer_id = 'greatcircles'
   , stroke_from = "airport1"
   , stroke_to = "airport2"
)


</code></pre>

<hr>
<h2 id='add_grid'>Add Grid</h2><span id='topic+add_grid'></span>

<h3>Description</h3>

<p>The Grid Layer renders a grid heatmap based on an array of points.
It takes the constant size all each cell, projects points into cells.
The color and height of the cell is scaled by number of points it contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_grid(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  cell_size = 1000,
  extruded = TRUE,
  elevation = NULL,
  elevation_function = c("sum", "mean", "min", "max"),
  colour = NULL,
  colour_function = c("sum", "mean", "min", "max"),
  elevation_scale = 1,
  colour_range = NULL,
  legend = FALSE,
  legend_options = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  layer_id = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_grid_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_grid_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_grid_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_grid_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_grid_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_grid_+3A_cell_size">cell_size</code></td>
<td>
<p>size of each cell in meters. Default 1000</p>
</td></tr>
<tr><td><code id="add_grid_+3A_extruded">extruded</code></td>
<td>
<p>logical indicating if cells are elevated or not. Default TRUE</p>
</td></tr>
<tr><td><code id="add_grid_+3A_elevation">elevation</code></td>
<td>
<p>the height the polygon extrudes from the map. Only available if neither
<code>stroke_colour</code> or <code>stroke_width</code> are supplied. Default 0</p>
</td></tr>
<tr><td><code id="add_grid_+3A_elevation_function">elevation_function</code></td>
<td>
<p>one of 'min', 'mean', 'max', 'sum'.
IF supplied it specifies how the elevation values are calcualted. Defaults to sum.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_colour">colour</code></td>
<td>
<p>column containing numeric values to colour by.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_colour_function">colour_function</code></td>
<td>
<p>one of 'min', 'mean', 'max', 'sum'.
If supplied it specifies how the colour values are calculated. Defaults to sum.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>elevation multiplier.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_colour_range">colour_range</code></td>
<td>
<p>vector of 6 hex colours</p>
</td></tr>
<tr><td><code id="add_grid_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_grid_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_grid_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_grid_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_grid_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_grid_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_grid_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_grid_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_grid</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>See Also</h3>

<p>add_hexagon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
'examples/3d-heatmap/heatmap-data.csv'
))

df &lt;- df[ !is.na(df$lng ), ]

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_grid(
  data = df
  , lat = "lat"
  , lon = "lng"
  , cell_size = 5000
  , elevation_scale = 50
  , layer_id = "grid_layer"
  , auto_highlight = TRUE
)

## using sf object
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat")

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_grid(
  data = sf
  , cell_size = 5000
  , elevation_scale = 50
  , layer_id = "grid_layer"
  , auto_highlight = TRUE
)

## using colour and elevation functions, and legends
df$val &lt;- sample(1:10, size = nrow(df), replace = TRUE)

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_grid(
	data = df
	, lat = "lat"
	, lon = "lng"
	, layer_id = "hex_layer"
	, elevation_scale = 100
	, legend = TRUE
	, colour_function = "max"
	, colour = "val"
)

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_grid(
	data = df
	, lat = "lat"
	, lon = "lng"
	, layer_id = "hex_layer"
	, elevation_scale = 10
	, legend = TRUE
	, elevation_function = "mean"
	, elevation = "val"
)



</code></pre>

<hr>
<h2 id='add_h3'>Add h3</h2><span id='topic+add_h3'></span>

<h3>Description</h3>

<p>The h3 layer renders hexagons from the H3 geospatial indexing system. To use
this layer you must specify <code>libraries = "h3"</code> within the <code>mapdeck()</code> call. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_h3(
  map,
  data = get_map_data(map),
  hexagon = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  elevation = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  elevation_scale = 1,
  highlight_colour = "#AAFFFFFF",
  light_settings = list(),
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  transitions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_h3_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_h3_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_h3_+3A_hexagon">hexagon</code></td>
<td>
<p>column of <code>data</code> containing the hexagon indexes</p>
</td></tr>
<tr><td><code id="add_h3_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of <code>data</code> or hex colour for the stroke. If used,
<code>elevation</code> is ignored.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_h3_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. If used, <code>elevation</code> is ignored. Default 1.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_h3_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_h3_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_h3_+3A_elevation">elevation</code></td>
<td>
<p>the height the polygon extrudes from the map. Only available if neither
<code>stroke_colour</code> or <code>stroke_width</code> are supplied. Default 0</p>
</td></tr>
<tr><td><code id="add_h3_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_h3_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_h3_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>elevation multiplier.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_light_settings">light_settings</code></td>
<td>
<p>list of light setting parameters. See <a href="#topic+light_settings">light_settings</a></p>
</td></tr>
<tr><td><code id="add_h3_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_h3_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_h3_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_h3_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_h3_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_h3_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_h3_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_h3_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_h3</code> supports a data.frame with a column of h3 indexes
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for h3
</p>
<p>list(
elevation = 0
colour = 0
)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

mapdeck(
 style = mapdeck_style("dark")
 , location = c(0, 51.3)
 , zoom = 10
 , pitch = 60
 , libraries = "h3"
 ) %&gt;%
 add_h3(
   data = road_safety
   , hexagon = "hex"
   , fill_colour = "count"
   , auto_highlight = TRUE
   , legend = TRUE
   , elevation = "count"
   , elevation_scale = 20
   , palette = colourvalues::get_palette("inferno")
   )


## End(Not run)

</code></pre>

<hr>
<h2 id='add_heatmap'>Add Heatmap</h2><span id='topic+add_heatmap'></span>

<h3>Description</h3>

<p>The Heatmap Layer can be used to visualise spatial distribution of data.
It implements Gaussian Kernel Density Estimation to render the heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_heatmap(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  weight = NULL,
  colour_range = NULL,
  radius_pixels = 30,
  intensity = 1,
  threshold = 0.05,
  layer_id = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_heatmap_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_weight">weight</code></td>
<td>
<p>the weight of each value. Default 1</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_colour_range">colour_range</code></td>
<td>
<p>vector of 6 hex colours</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_radius_pixels">radius_pixels</code></td>
<td>
<p>Radius of the circle in pixels, to which the weight of an object is distributed</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_intensity">intensity</code></td>
<td>
<p>Value that is multiplied with the total weight at a pixel to
obtain the final weight. A value larger than 1 biases the output color towards
the higher end of the spectrum, and a value less than 1 biases the output
color towards the lower end of the spectrum</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_threshold">threshold</code></td>
<td>
<p>The HeatmapLayer reduces the opacity of the pixels with relatively
low weight to create a fading effect at the edge.
A larger threshold smoothens the boundaries of color blobs, while making pixels
with low relative weight harder to spot (due to low alpha value).
Threshold is defined as the ratio of the fading weight to the max weight, between 0 and 1.
For example, 0.1 affects all pixels with weight under 10% of the max.</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_heatmap_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_heatmap</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>note</h3>

<p>The current version of this layer is supported only for WebGL2 enabled browswers
So you may find it doesn't render in the RStudio viewer.
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for heatmap
</p>
<p>list(
intensity = 0,
threshold = 0,
radius_pixels = 0
)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
'examples/3d-heatmap/heatmap-data.csv'
))

df &lt;- df[ !is.na(df$lng), ]
df$weight &lt;- sample(1:10, size = nrow(df), replace = TRUE)

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_heatmap(
  data = df
  , lat = "lat"
  , lon = "lng"
  , weight = "weight",
  , layer_id = "heatmap_layer"
)

## as an sf object
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat")

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_heatmap(
  data = sf
  , weight = "weight",
  , layer_id = "heatmap_layer"
)



</code></pre>

<hr>
<h2 id='add_hexagon'>Add hexagon</h2><span id='topic+add_hexagon'></span>

<h3>Description</h3>

<p>The Hexagon Layer renders a hexagon heatmap based on an array of points.
It takes the radius of hexagon bin, projects points into hexagon bins.
The color and height of the hexagon is scaled by number of points it contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_hexagon(
  map,
  data = get_map_data(map),
  polyline = NULL,
  lon = NULL,
  lat = NULL,
  layer_id = NULL,
  radius = 1000,
  elevation = NULL,
  elevation_function = c("sum", "mean", "min", "max"),
  colour = NULL,
  colour_function = c("sum", "mean", "min", "max"),
  legend = FALSE,
  legend_options = NULL,
  elevation_scale = 1,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  colour_range = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_hexagon_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_polyline">polyline</code></td>
<td>
<p>column of <code>data</code> containing the polylines</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_radius">radius</code></td>
<td>
<p>in metres. Default 1000</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_elevation">elevation</code></td>
<td>
<p>column containing the elevation of the value.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_elevation_function">elevation_function</code></td>
<td>
<p>one of 'min', 'mean', 'max', 'sum'.
IF supplied it specifies how the elevation values are calcualted. Defaults to sum.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_colour">colour</code></td>
<td>
<p>column containing numeric values to colour by.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_colour_function">colour_function</code></td>
<td>
<p>one of 'min', 'mean', 'max', 'sum'.
If supplied it specifies how the colour values are calculated. Defaults to sum.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_legend">legend</code></td>
<td>
<p>logical indicating if a legend should be displayed</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>value to scale the elevations of the hexagons. Default 1</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_colour_range">colour_range</code></td>
<td>
<p>vector of 6 hex colours</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_hexagon_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_hexagon</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for hexagon
</p>
<p>list(
elevation = 0
colour = 0
)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/examples/'
, '3d-heatmap/heatmap-data.csv'
))

df &lt;- df[!is.na(df$lng), ]

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_hexagon(
  data = df
  , lat = "lat"
  , lon = "lng"
  , layer_id = "hex_layer"
  , elevation_scale = 100
)

library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat" )

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_hexagon(
  data = sf
  , layer_id = "hex_layer"
  , elevation_scale = 100
)

## Using elevation and colour
df$colour &lt;- rnorm(nrow(df))
df$elevation &lt;- rnorm(nrow(df))

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_hexagon(
  data = df
  , lat = "lat"
  , lon = "lng"
  , layer_id = "hex_layer"
  , elevation_scale = 100
  , elevation = "weight"
  , colour = "colour"
)

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_hexagon(
  data = df
  , lat = "lat"
  , lon = "lng"
  , layer_id = "hex_layer"
  , elevation_scale = 100
  , elevation = "weight"
  , elevation_function = "mean"
  , colour = "colour"
  , colour_function = "mean"
)

## with a legend
df$val &lt;- sample(1:10, size = nrow(df), replace = TRUE)

mapdeck( style = mapdeck_style("dark"), pitch = 45) %&gt;%
add_hexagon(
	data = df
	, lat = "lat"
	, lon = "lng"
	, layer_id = "hex_layer"
	, elevation_scale = 100
	, legend = TRUE
	, legend_options = list( digits = 0 )
	, colour_function = "mean"
	, colour = "val"
)


## End(Not run)

</code></pre>

<hr>
<h2 id='add_i3s'>Add I3S</h2><span id='topic+add_i3s'></span>

<h3>Description</h3>

<p>Adds OGC Indexed 3D Scene (I3S) tiles to the map. This layer is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_i3s(map, data, layer_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_i3s_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_i3s_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_i3s_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## San Francisco buildings
i3s &lt;- paste0(
  'https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/'
  , 'SanFrancisco_Bldgs/SceneServer/layers/0'
  )

mapdeck(
  location = c(-122.41, 37.77)
  , zoom = 16
  , pitch = 60
) %&gt;%
  add_i3s(
    data = i3s
  )


</code></pre>

<hr>
<h2 id='add_line'>Add line</h2><span id='topic+add_line'></span>

<h3>Description</h3>

<p>The Line Layer renders raised lines joining pairs of source and target coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_line(
  map,
  data = get_map_data(map),
  layer_id = NULL,
  origin,
  destination,
  id = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_line_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_line_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_line_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_line_+3A_origin">origin</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevation column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_line_+3A_destination">destination</code></td>
<td>
<p>vector of longitude and latitude columns, and optionally an elevatino column,
or an <code>sfc</code> column</p>
</td></tr>
<tr><td><code id="add_line_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_line_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable or hex colour to use as the ending stroke colour.</p>
</td></tr>
<tr><td><code id="add_line_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the line in metres</p>
</td></tr>
<tr><td><code id="add_line_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_line_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_line_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_line_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_line_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_line_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_line_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_line_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_line_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_line_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_line_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_line_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_line_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_line_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_line_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_line</code> supports POINT sf objects
</p>
<p>MULTIPOINT objects will be treated as single points. That is, if an sf object
has one row with a MULTIPOINT object consisting of two points, this will
be expanded to two rows of single POINTs.
Therefore, if the origin is a MULTIPOINT of two points, and the destination is
a single POINT, the code will error as there will be an uneven number of rows
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for line
</p>
<p>list(
origin = 0,
destination = 0,
stroke_colour = 0,
stroke_width = 0
)
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

url &lt;- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
flights &lt;- read.csv(url)
flights$id &lt;- seq_len(nrow(flights))
flights$stroke &lt;- sample(1:3, size = nrow(flights), replace = TRUE)

mapdeck(style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
  add_line(
    data = flights
    , layer_id = "line_layer"
    , origin = c("start_lon", "start_lat")
    , destination = c("end_lon", "end_lat")
    , stroke_colour = "airport1"
    , stroke_width = "stroke"
    , auto_highlight = TRUE
 )

## Using a 2-sfc-column sf object
library(sfheaders)

sf_flights &lt;- sfheaders::sf_point( flights, x = "start_lon", y = "start_lat", keep = TRUE )
destination &lt;- sfheaders::sfc_point( flights, x = "end_lon", y = "end_lat" )

sf_flights$destination &lt;- destination

mapdeck() %&gt;%
 add_line(
   data = sf_flights
   , origin = 'geometry'
   , destination = 'destination'
   , layer_id = 'arcs'
   , stroke_colour = "airport1"
)


</code></pre>

<hr>
<h2 id='add_mesh'>Add Mesh</h2><span id='topic+add_mesh'></span>

<h3>Description</h3>

<p>Adds polygons to the map from a <code>mesh3d</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mesh(
  map,
  data = get_map_data(map),
  fill_opacity = NULL,
  elevation = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  light_settings = list(),
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_mesh_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_elevation">elevation</code></td>
<td>
<p>the height the polygon extrudes from the map. Only available if neither
<code>stroke_colour</code> or <code>stroke_width</code> are supplied. Default 0</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_light_settings">light_settings</code></td>
<td>
<p>list of light setting parameters. See <a href="#topic+light_settings">light_settings</a></p>
</td></tr>
<tr><td><code id="add_mesh_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_mesh_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_mesh</code> supports mesh3d objects
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## exaggerate the elevation slightly
m &lt;- melbourne_mesh
m$vb[3, ] &lt;- m$vb[3, ] * 50

mapdeck() %&gt;%
 add_mesh(
 data = m
 )



</code></pre>

<hr>
<h2 id='add_path'>Add Path</h2><span id='topic+add_path'></span>

<h3>Description</h3>

<p>The Path Layer takes in lists of coordinate points and renders them as
extruded lines with mitering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_path(
  map,
  data = get_map_data(map),
  polyline = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  dash_size = NULL,
  dash_gap = NULL,
  offset = NULL,
  width_units = c("meters", "common", "pixels"),
  width_min_pixels = NULL,
  width_max_pixels = NULL,
  width_scale = 1,
  tooltip = NULL,
  billboard = FALSE,
  layer_id = NULL,
  id = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_path_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_path_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_path_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_path_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of <code>data</code> or hex colour for the stroke. If used,
<code>elevation</code> is ignored.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_path_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. Default 1.</p>
</td></tr>
<tr><td><code id="add_path_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_path_+3A_dash_size">dash_size</code></td>
<td>
<p>size of each dash, relative to the width of the stroke</p>
</td></tr>
<tr><td><code id="add_path_+3A_dash_gap">dash_gap</code></td>
<td>
<p>size of the gap between dashes, relative to the width of the stroke</p>
</td></tr>
<tr><td><code id="add_path_+3A_offset">offset</code></td>
<td>
<p>The offset to draw each path with, relative to the width of the path.
Negative offset is to the left hand side, and positive offset is to the right hand side.
0 extrudes the path so that it is centered at the specified coordinates.</p>
</td></tr>
<tr><td><code id="add_path_+3A_width_units">width_units</code></td>
<td>
<p>The units of the line width, one of 'meters', 'common' or 'pixels'.
When zooming in and out, meter sizes scale with the base map, and pixel sizes
remain the same on screen.</p>
</td></tr>
<tr><td><code id="add_path_+3A_width_min_pixels">width_min_pixels</code></td>
<td>
<p>The minimum path width in pixels.
This can be used to prevent the path from getting too thin when zoomed out.</p>
</td></tr>
<tr><td><code id="add_path_+3A_width_max_pixels">width_max_pixels</code></td>
<td>
<p>The maximum path width in pixels.
his prop can be used to prevent the path from getting too thick when zoomed in.</p>
</td></tr>
<tr><td><code id="add_path_+3A_width_scale">width_scale</code></td>
<td>
<p>The path width multiplier that multiplied to all paths.</p>
</td></tr>
<tr><td><code id="add_path_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_path_+3A_billboard">billboard</code></td>
<td>
<p>logical indicating if the path always faces the camera (TRUE) or
if it always faces up (FALSE)</p>
</td></tr>
<tr><td><code id="add_path_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_path_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_path_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_path_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_path_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_path_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_path_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_path_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_path_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_path_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_path_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_path_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_path_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_path_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_path_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_path</code> supports LINESTRING and MULTILINESTRING sf objects
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for path
</p>
<p>list(
path = 0,
stroke_colour = 0,
stroke_width = 0
)
</p>


<h3>gradient fill</h3>

<p>If a colour is supplied for each coordinate (see examples), the colour along each segment
of the line is gradient-filled. However, if either <code>dash_gap</code>, <code>dash_size</code> or
<code>offset</code> are supplied the the segment is filled with a solid colour, accoding to the
first point on the segment.
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

mapdeck(
  style = mapdeck_style("dark")
  ) %&gt;%
  add_path(
    data = roads
    , stroke_colour = "RIGHT_LOC"
    , stroke_width = 20
    , layer_id = "path_layer"
    , tooltip = "ROAD_NAME"
    , auto_highlight = TRUE
    , legend = TRUE
  )

## Dashed lines
mapdeck(
  style = mapdeck_style("dark")
  ) %&gt;%
  add_path(
    data = roads
    , stroke_colour = "RIGHT_LOC"
    , layer_id = "path_layer"
    , tooltip = "ROAD_NAME"
    , stroke_width = 1
    , dash_size = 0.5
    , dash_gap = 5
  )

## Different dashes per path

sf &lt;- mapdeck::roads
sf$dash_size &lt;- sample(1:5, size = nrow( sf ), replace = TRUE )
sf$dash_gap &lt;- sample(1:5, size = nrow( sf ), replace = TRUE )

mapdeck(
  style = mapdeck_style("dark")
  ) %&gt;%
  add_path(
    data = sf
    , stroke_colour = "RIGHT_LOC"
    , layer_id = "path_layer"
    , tooltip = "ROAD_NAME"
    , dash_size = "dash_size"
    , dash_gap = "dash_gap"
  )

## Offset lines
sf &lt;- mapdeck::roads
sf$offset &lt;- sample(-10:10, size = nrow( sf ), replace = TRUE )

mapdeck(
  style = mapdeck_style("light")
) %&gt;%
	add_path(
   data = sf
   , stroke_colour = "ROAD_NAME"
   , offset = "offset"
 )

## Multi Coloured line
## You need to supply one colour per coordinate in the sf object
sf_line &lt;- sfheaders::sf_linestring(
  obj = data.frame(
  id = c(1,1,1,1,1,2,2,2,2,2)
  , x = c(0,0,1,1,2,-1,-1,0,0,1)
  , y = c(0,1,1,2,2,0,1,1,2,2)
  , col = c(1,2,3,4,5,5,4,3,2,1)
 )
 , x = "x"
 , y = "y"
 , linestring_id = "id"
 , list_columns = "col"
 , keep = TRUE
)

mapdeck(
 style = mapdeck_style("light")
) %&gt;%
 add_path(
   data = sf_line
   , stroke_colour = "col"
   , stroke_width = 50000
)

## If using dashed lines, colours won't be gradient-filled
mapdeck(
 style = mapdeck_style("light")
) %&gt;%
 add_path(
   data = sf_line
   , stroke_colour = "col"
   , stroke_width = 500
   , dash_size = 10
   , dash_gap = 10
 )




</code></pre>

<hr>
<h2 id='add_pointcloud'>Add Pointcloud</h2><span id='topic+add_pointcloud'></span>

<h3>Description</h3>

<p>The Pointcloud Layer takes in coordinate points and renders them as circles
with a certain radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pointcloud(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  elevation = NULL,
  polyline = NULL,
  radius = 10,
  fill_colour = NULL,
  fill_opacity = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  light_settings = list(),
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pointcloud_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_elevation">elevation</code></td>
<td>
<p>column containing the elevation values. Default 0</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_radius">radius</code></td>
<td>
<p>value in pixels of each point. Default 10.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_light_settings">light_settings</code></td>
<td>
<p>list of light setting parameters. See <a href="#topic+light_settings">light_settings</a></p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_pointcloud_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_pointcloud</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for pointcloud
</p>
<p>list(
position = 0,
fill_colour = 0
)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- capitals
df$z &lt;- sample(10000:10000000, size = nrow(df))

mapdeck(style = mapdeck_style("dark")) %&gt;%
add_pointcloud(
  data = df
  , lon = 'lon'
  , lat = 'lat'
  , elevation = 'z'
  , layer_id = 'point'
  , fill_colour = "country"
  , tooltip = "country"
)

## as an sf object wtih a Z attribute
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lon", y = "lat", z = "z" )

mapdeck(style = mapdeck_style("dark")) %&gt;%
add_pointcloud(
  data = sf
  , layer_id = 'point'
  , fill_colour = "country"
  , tooltip = "country"
  , update_view = FALSE
)



</code></pre>

<hr>
<h2 id='add_polygon'>Add Polygon</h2><span id='topic+add_polygon'></span>

<h3>Description</h3>

<p>The Polygon Layer renders filled and/or stroked polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_polygon(
  map,
  data = get_map_data(map),
  polyline = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  elevation = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  elevation_scale = 1,
  highlight_colour = "#AAFFFFFF",
  light_settings = list(),
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_polygon_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of <code>data</code> or hex colour for the stroke. If used,
<code>elevation</code> is ignored.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_polygon_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. If used, <code>elevation</code> is ignored. Default 1.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_polygon_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_elevation">elevation</code></td>
<td>
<p>the height the polygon extrudes from the map. Only available if neither
<code>stroke_colour</code> or <code>stroke_width</code> are supplied. Default 0</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_elevation_scale">elevation_scale</code></td>
<td>
<p>elevation multiplier.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_light_settings">light_settings</code></td>
<td>
<p>list of light setting parameters. See <a href="#topic+light_settings">light_settings</a></p>
</td></tr>
<tr><td><code id="add_polygon_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_polygon_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_polygon</code> supports POLYGON and MULTIPOLYGON sf objects
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for polygon
</p>
<p>list(
polygon = 0,
fill_colour = 0,
stroke_colour = 0,
stroke_width = 0,
elevation = 0
)
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

library(geojsonsf)

sf &lt;- geojsonsf::geojson_sf("https://symbolixau.github.io/data/geojson/SA2_2016_VIC.json")

mapdeck(
  style = mapdeck_style('dark')
) %&gt;%
  add_polygon(
    data = sf
    , layer = "polygon_layer"
    , fill_colour = "SA2_NAME16"
)

df &lt;- melbourne  ## data.frame with encoded polylnies
df$elevation &lt;- sample(100:5000, size = nrow(df))
df$info &lt;- paste0("&lt;b&gt;SA2 - &lt;/b&gt;&lt;br&gt;",df$SA2_NAME)

mapdeck(
  style = mapdeck_style('dark')
  , location = c(145, -38)
  , zoom = 8
  ) %&gt;%
  add_polygon(
    data = df
    , polyline = "geometry"
    , layer = "polygon_layer"
    , fill_colour = "SA2_NAME"
    , elevation = "elevation"
    , tooltip = 'info'
    , legend = TRUE
  )



</code></pre>

<hr>
<h2 id='add_scatterplot'>Add Scatterplot</h2><span id='topic+add_scatterplot'></span>

<h3>Description</h3>

<p>The Scatterplot Layer takes in coordinate points and renders them as circles
with a certain radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_scatterplot(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  radius = NULL,
  radius_min_pixels = 1,
  radius_max_pixels = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  stroke_colour = NULL,
  stroke_width = NULL,
  stroke_opacity = NULL,
  tooltip = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  layer_id = NULL,
  id = NULL,
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  digits = 6,
  update_view = TRUE,
  focus_layer = FALSE,
  transitions = NULL,
  brush_radius = NULL,
  collision_filter = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_scatterplot_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_radius">radius</code></td>
<td>
<p>in metres. Default 1</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_radius_min_pixels">radius_min_pixels</code></td>
<td>
<p>the minimum radius in pixels. Can prevent circle from
getting too small when zoomed out
small for the given zoom level</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_radius_max_pixels">radius_max_pixels</code></td>
<td>
<p>the maximum radius in pixels. Can prevent the circle from
getting too big when zoomed in</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of <code>data</code> or hex colour for the stroke. If used,
<code>elevation</code> is ignored.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. If used, <code>elevation</code> is ignored. Default 1.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_stroke_opacity">stroke_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_collision_filter">collision_filter</code></td>
<td>
<p>set to 'TRUE' if you want to hide features that overlap
other features. Default is 'FALSE'</p>
</td></tr>
<tr><td><code id="add_scatterplot_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_scatterplot</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for scatterplot
</p>
<p>list(
position = 0,
fill_colour = 0,
radius = 0
)
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_scatterplot(
  data = capitals
  , lat = "lat"
  , lon = "lon"
  , radius = 100000
  , fill_colour = "country"
  , layer_id = "scatter_layer"
  , tooltip = "capital"
)

## using legend options
mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_scatterplot(
  data = capitals
  , lat = "lat"
  , lon = "lon"
  , radius = 100000
  , fill_colour = "lon"
  , stroke_colour = "lat"
  , layer_id = "scatter_layer"
  , tooltip = "capital"
  , legend = TRUE
  , legend_options = list( digits = 5 )
)


df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
'examples/3d-heatmap/heatmap-data.csv'
))

df &lt;- df[ !is.na(df$lng), ]

mapdeck(style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_scatterplot(
  data = df
  , lat = "lat"
  , lon = "lng"
  , layer_id = "scatter_layer"
  , stroke_colour = "lng"
)

## as an sf object
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat")

mapdeck( style = mapdeck_style("dark"), pitch = 45 ) %&gt;%
add_scatterplot(
  data = sf
  , radius = 100
  , fill_colour = "country"
  , layer_id = "scatter_layer"
  , tooltip = "capital"
)



</code></pre>

<hr>
<h2 id='add_screengrid'>Add Screengrid</h2><span id='topic+add_screengrid'></span>

<h3>Description</h3>

<p>The Screen Grid Layer takes in an array of latitude and longitude coordinated points,
aggregates them into histogram bins and renders as a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_screengrid(
  map,
  data = get_map_data(map),
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  weight = NULL,
  aggregation = c("sum", "mean", "min", "max"),
  colour_range = NULL,
  opacity = 0.8,
  cell_size = 50,
  layer_id = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_screengrid_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_weight">weight</code></td>
<td>
<p>the weight of each value. Default 1</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_aggregation">aggregation</code></td>
<td>
<p>one of 'min', 'mean', 'max', 'sum'.
If supplied it specifies how the weights used.</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_colour_range">colour_range</code></td>
<td>
<p>vector of 6 hex colours</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_opacity">opacity</code></td>
<td>
<p>opacity of cells. Value between 0 and 1. Default 0.8</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_cell_size">cell_size</code></td>
<td>
<p>size of grid squares in pixels. Default 50</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_screengrid_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_screengrid</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>data</h3>

<p>If the <code>data</code> is a simple feature object, the geometry column is automatically
detected. If the sf object contains more than one geometry column and you want to use a specific one,
you'll need to set the active geometry using <code>sf::st_geometry( x ) &lt;- "your_column" </code>,
where <code>"your_column"</code> is the name of the column you're activating. See <code>?sf::st_geometry</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

df &lt;- read.csv(paste0(
'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/',
'examples/3d-heatmap/heatmap-data.csv'
))

df &lt;- df[ !is.na(df$lng), ]
df$weight &lt;- sample(1:10, size = nrow(df), replace = TRUE)

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_screengrid(
  data = df
  , lat = "lat"
  , lon = "lng"
  , weight = "weight",
  , layer_id = "screengrid_layer"
  , cell_size = 10
  , opacity = 0.3
)

## as an sf object
library(sfheaders)
sf &lt;- sfheaders::sf_point( df, x = "lng", y = "lat")

mapdeck( style = mapdeck_style('dark'), pitch = 45 ) %&gt;%
add_screengrid(
  data = sf
  , weight = "weight",
  , layer_id = "screengrid_layer"
  , cell_size = 10
  , opacity = 0.3
)



</code></pre>

<hr>
<h2 id='add_sf'>Add sf</h2><span id='topic+add_sf'></span>

<h3>Description</h3>

<p>Adds an sf object to the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_sf(map, data = get_map_data(map), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_sf_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_sf_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_sf_+3A_...">...</code></td>
<td>
<p>other argumetns passed to one of the plotting layers. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotting layer is determined by the type of sf geometries.
</p>

<ul>
<li><p>POINT and MULTIPOINT objects will call <a href="#topic+add_scatterplot">add_scatterplot</a>
</p>
</li>
<li><p>LINESTRING and MULTILINESTRING objects will call <a href="#topic+add_path">add_path</a>
</p>
</li>
<li><p>POLYGON and MULTIPOLYGON objects will call <a href="#topic+add_polygon">add_polygon</a>
</p>
</li>
<li><p>GEOMETRY objects will call <a href="#topic+add_geojson">add_geojson</a>
</p>
</li></ul>


<hr>
<h2 id='add_terrain'>Add terrain</h2><span id='topic+add_terrain'></span>

<h3>Description</h3>

<p>Adds mesh surfaces from height map images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_terrain(
  map,
  layer_id = NULL,
  elevation_data,
  texture = NULL,
  elevation_decoder = c(1, 0, 0, 0),
  bounds = NULL,
  max_error = 4,
  update_view = TRUE,
  focus_layer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_terrain_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_elevation_data">elevation_data</code></td>
<td>
<p>Image URL that encodes height data. When <code>elevation_data</code>
is a URL template, i.e. a string containing '{x}' and '{y}', it loads terrain tiles on demand
and renders a mesh for each tile. If <code>elevation_data</code> is an absolute URL, as ingle mesh is used,
and the <code>bounds</code> argument is required to position it into the world space.</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_texture">texture</code></td>
<td>
<p>Image URL to use as the texture</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_elevation_decoder">elevation_decoder</code></td>
<td>
<p>Four value used to convert a pixel to elevation in metres. The
values correspond to rScale, gScale, bScale, offset. See details</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_bounds">bounds</code></td>
<td>
<p>Four values (<code> c(left, bottom, right, top) </code>. bounds of the
image to fit in x,y coordinates into. <code>left</code> and <code>right</code> referes to the world
longitude/x at the corresponding side of the image. <code>top</code> and <code>bottom</code> refers to
the world latitude/y at the corresponding side of the image. Must be supplied when using
non-tiled <code>elevation_data</code></p>
</td></tr>
<tr><td><code id="add_terrain_+3A_max_error">max_error</code></td>
<td>
<p>Martini error tolerance in metres, smaller number results in more detailed mesh.</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_terrain_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>elevation_decoder</code> contains four values representing
</p>

<ul>
<li><p>rScale - Multiplier of the red channel
</p>
</li>
<li><p>gScale - Multiplier of the green channel
</p>
</li>
<li><p>bScale - Multiplier of the blue channel
</p>
</li>
<li><p>offset - translation of the sum
</p>
</li></ul>

<p>Each colour channel is a number between [0, 255].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set_token( "MAPBOX_TOKEN" )
## Digital elevation model from https://www.usgs.gov/
elevation &lt;- 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain.png'
texture &lt;- 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/terrain-mask.png'
bounds &lt;- c(-122.5233, 37.6493, -122.3566, 37.8159)

mapdeck() %&gt;%
  add_terrain(
    , elevation_data = elevation
    , elevation_decoder = c(1,0,0,0)
    , texture = texture
    , bounds = bounds
    , max_error = 1
  )



</code></pre>

<hr>
<h2 id='add_text'>Add Text</h2><span id='topic+add_text'></span>

<h3>Description</h3>

<p>The Text Layer renders text labels on the map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_text(
  map,
  data = get_map_data(map),
  text,
  lon = NULL,
  lat = NULL,
  polyline = NULL,
  fill_colour = NULL,
  fill_opacity = NULL,
  size = NULL,
  angle = NULL,
  anchor = NULL,
  alignment_baseline = NULL,
  billboard = TRUE,
  font_family = "Monaco, monospace",
  font_weight = "normal",
  tooltip = NULL,
  layer_id = NULL,
  id = NULL,
  auto_highlight = FALSE,
  highlight_colour = "#AAFFFFFF",
  palette = "viridis",
  na_colour = "#808080FF",
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  transitions = NULL,
  brush_radius = NULL,
  collision_filter = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_text_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_text_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="add_text_+3A_text">text</code></td>
<td>
<p>column of <code>data</code> containing the text. The data must be a character.</p>
</td></tr>
<tr><td><code id="add_text_+3A_lon">lon</code></td>
<td>
<p>column containing longitude values</p>
</td></tr>
<tr><td><code id="add_text_+3A_lat">lat</code></td>
<td>
<p>column containing latitude values</p>
</td></tr>
<tr><td><code id="add_text_+3A_polyline">polyline</code></td>
<td>
<p>optional column of <code>data</code> containing the polylines, if using encoded polylines</p>
</td></tr>
<tr><td><code id="add_text_+3A_fill_colour">fill_colour</code></td>
<td>
<p>column of <code>data</code> or hex colour for the fill colour.
If using a hex colour, use either a single value, or a column of hex colours  on <code>data</code></p>
</td></tr>
<tr><td><code id="add_text_+3A_fill_opacity">fill_opacity</code></td>
<td>
<p>Either a string specifying the column of <code>data</code>
containing the opacity of each shape, or a single value in [0,255], or [0, 1),
to be applied to all the shapes. Default 255. If a hex-string is used as the
colour, this argument is ignored and you should include the alpha on the hex string</p>
</td></tr>
<tr><td><code id="add_text_+3A_size">size</code></td>
<td>
<p>column of <code>data</code> containing the size of the text. Default 32</p>
</td></tr>
<tr><td><code id="add_text_+3A_angle">angle</code></td>
<td>
<p>column of <code>data</code> containging the angle of the text. Default 0</p>
</td></tr>
<tr><td><code id="add_text_+3A_anchor">anchor</code></td>
<td>
<p>column of <code>data</code> containing the anchor of the text. One of
'start', 'middle' or 'end'</p>
</td></tr>
<tr><td><code id="add_text_+3A_alignment_baseline">alignment_baseline</code></td>
<td>
<p>column of <code>data</code> containing the alignment. One of
'top', 'center' or 'bottom'</p>
</td></tr>
<tr><td><code id="add_text_+3A_billboard">billboard</code></td>
<td>
<p>logical indicating if the text always faces the camera (TRUE) or
if it always faces up (FALSE)</p>
</td></tr>
<tr><td><code id="add_text_+3A_font_family">font_family</code></td>
<td>
<p>specifies a prioritised list of one or more font family names and/or
generic family names. Follow the specifics for CSS font-family
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-family">https://developer.mozilla.org/en-US/docs/Web/CSS/font-family</a></p>
</td></tr>
<tr><td><code id="add_text_+3A_font_weight">font_weight</code></td>
<td>
<p>specifies the font weight. Follow the specifics for CSS font-weight
<a href="https://htmldog.com/references/css/properties/font-weight/">https://htmldog.com/references/css/properties/font-weight/</a></p>
</td></tr>
<tr><td><code id="add_text_+3A_tooltip">tooltip</code></td>
<td>
<p>variable of <code>data</code> containing text or HTML to render as a tooltip</p>
</td></tr>
<tr><td><code id="add_text_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_text_+3A_id">id</code></td>
<td>
<p>an id value in <code>data</code> to identify layers when interacting in Shiny apps.</p>
</td></tr>
<tr><td><code id="add_text_+3A_auto_highlight">auto_highlight</code></td>
<td>
<p>logical indicating if the shape under the mouse should auto-highlight</p>
</td></tr>
<tr><td><code id="add_text_+3A_highlight_colour">highlight_colour</code></td>
<td>
<p>hex string colour to use for highlighting. Must contain the alpha component.</p>
</td></tr>
<tr><td><code id="add_text_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_text_+3A_na_colour">na_colour</code></td>
<td>
<p>hex string colour to use for NA values</p>
</td></tr>
<tr><td><code id="add_text_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_text_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_text_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_text_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_text_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_text_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_text_+3A_transitions">transitions</code></td>
<td>
<p>list specifying the duration of transitions.</p>
</td></tr>
<tr><td><code id="add_text_+3A_brush_radius">brush_radius</code></td>
<td>
<p>radius of the brush in metres. Default NULL. If supplied,
the arcs will only show if the origin or destination are within the radius of the mouse.
If NULL, all arcs are displayed</p>
</td></tr>
<tr><td><code id="add_text_+3A_collision_filter">collision_filter</code></td>
<td>
<p>set to 'TRUE' if you want to hide features that overlap
other features. Default is 'FALSE'</p>
</td></tr>
<tr><td><code id="add_text_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_text</code> supports POINT and MULTIPOINT sf objects
</p>


<h3>transitions</h3>

<p>The transitions argument lets you specify the time it will take for the shapes to transition
from one state to the next. Only works in an interactive environment (Shiny)
and on WebGL-2 supported browsers and hardware.
</p>
<p>The time is in milliseconds
</p>
<p>Available transitions for text
</p>
<p>list(
position = 0,
fill_colour = 0,
angle = 0,
size = 0
)
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## You need a valid access token from Mapbox
key &lt;- 'abc'
set_token( key )

mapdeck(
  style = mapdeck_style('dark')
) %&gt;%
  add_text(
    data = capitals
    , lon = 'lon'
    , lat = 'lat'
    , fill_colour = 'country'
    , text = 'capital'
    , layer_id = 'text'
  )


</code></pre>

<hr>
<h2 id='add_title'>Add Title</h2><span id='topic+add_title'></span>

<h3>Description</h3>

<p>Adds a title to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_title(map, title, layer_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_title_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_title_+3A_title">title</code></td>
<td>
<p>Either a single string for the title, or a list with a 'title' element,
and an optional 'css' element. See examples</p>
</td></tr>
<tr><td><code id="add_title_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

mapdeck() %&gt;%
  add_title(title = "first title", layer_id = "first") %&gt;%
  add_title(title = list(
      title = "second title",
      css = "background-color: red;"),
    layer_id = "second") %&gt;%
  add_title(title = list(
      title = "Another title",
      css = "background-color: transparent;"),
    layer_id = "third")



</code></pre>

<hr>
<h2 id='add_trips'>Add Trips</h2><span id='topic+add_trips'></span>

<h3>Description</h3>

<p>The Trips Layer takes an sf object with Z (elevation) and M (time) attributes and renders
it as animated trips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_trips(
  map,
  data = get_map_data(map),
  stroke_colour = NULL,
  stroke_width = NULL,
  width_units = c("meters", "pixels"),
  width_min_pixels = NULL,
  width_max_pixels = NULL,
  width_scale = 1,
  opacity = 0.3,
  palette = "viridis",
  trail_length = 180,
  start_time = get_m_range_start(data),
  end_time = get_m_range_end(data),
  animation_speed = 30,
  layer_id = NULL,
  legend = FALSE,
  legend_options = NULL,
  legend_format = NULL,
  update_view = TRUE,
  focus_layer = FALSE,
  digits = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_trips_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="add_trips_+3A_data">data</code></td>
<td>
<p>sf object with XYZM dimensions.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_stroke_colour">stroke_colour</code></td>
<td>
<p>variable of data or hex colour for the stroke.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_stroke_width">stroke_width</code></td>
<td>
<p>width of the stroke in meters. Default 1.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_width_units">width_units</code></td>
<td>
<p>The units of the line width, one of 'meters', 'common' or 'pixels'.
When zooming in and out, meter sizes scale with the base map, and pixel sizes
remain the same on screen.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_width_min_pixels">width_min_pixels</code></td>
<td>
<p>The minimum path width in pixels.
This can be used to prevent the path from getting too thin when zoomed out.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_width_max_pixels">width_max_pixels</code></td>
<td>
<p>The maximum path width in pixels.
his prop can be used to prevent the path from getting too thick when zoomed in.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_width_scale">width_scale</code></td>
<td>
<p>The path width multiplier that multiplied to all paths.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_opacity">opacity</code></td>
<td>
<p>single value in [0,1]</p>
</td></tr>
<tr><td><code id="add_trips_+3A_palette">palette</code></td>
<td>
<p>string or matrix. String will be one of <code>colourvalues::colour_palettes()</code>.
A matrix must have at least 5 rows, and 3 or 4 columns of values between [0, 255],
where the 4th column represents the alpha. You can use a named list to specify a different
palette for different colour options (where available),
e.g. list(fill_colour = &quot;viridis&quot;, stroke_colour = &quot;inferno&quot;)</p>
</td></tr>
<tr><td><code id="add_trips_+3A_trail_length">trail_length</code></td>
<td>
<p>how long it takes for the trail to completely fade out
(in same units as timestamps )</p>
</td></tr>
<tr><td><code id="add_trips_+3A_start_time">start_time</code></td>
<td>
<p>the minimum timestamp</p>
</td></tr>
<tr><td><code id="add_trips_+3A_end_time">end_time</code></td>
<td>
<p>the maximum timestamp</p>
</td></tr>
<tr><td><code id="add_trips_+3A_animation_speed">animation_speed</code></td>
<td>
<p>speed of animation</p>
</td></tr>
<tr><td><code id="add_trips_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
<tr><td><code id="add_trips_+3A_legend">legend</code></td>
<td>
<p>either a logical indiciating if the legend(s) should be displayed, or
a named list indicating which colour attributes should be included in the legend.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_legend_options">legend_options</code></td>
<td>
<p>A list of options for controlling the legend.</p>
</td></tr>
<tr><td><code id="add_trips_+3A_legend_format">legend_format</code></td>
<td>
<p>A list containing functions to apply to legend values. See section legend</p>
</td></tr>
<tr><td><code id="add_trips_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds to include this layer</p>
</td></tr>
<tr><td><code id="add_trips_+3A_focus_layer">focus_layer</code></td>
<td>
<p>logical indicating if the map should update the bounds to only include this layer</p>
</td></tr>
<tr><td><code id="add_trips_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding coordinates</p>
</td></tr>
<tr><td><code id="add_trips_+3A_...">...</code></td>
<td>
<p><code>clear_legend</code> and <code>clear_view</code> arguments passed to 'clear_()' functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_trips</code> supports LINESTRING and MULTILINESTRING sf objects
</p>


<h3>legend</h3>

<p>The <code>legend_options</code> can be used to control the appearance of the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>css - a string of valid <code>css</code> for controlling the appearance of the legend
</p>
</li>
<li><p>title - a string to use for the title of the legend
</p>
</li>
<li><p>digits - number to round the legend values to
</p>
</li></ul>

<p>If the layer allows different fill and stroke colours, you can use different options for each. See examples in <a href="#topic+add_arc">add_arc</a>.
</p>
<p>The <code>legend_format</code> can be used to control the format of the values in the legend.
This should be a named list, where the names are one of
</p>

<ul>
<li><p>fill_colour
</p>
</li>
<li><p>stroke_colour
</p>
</li></ul>

<p>depending on which type of colouring the layer supports.
</p>
<p>The list elements must be functions to apply to the values in the legend.
</p>


<h3>id</h3>

<p>The <code>id</code> is returned to your R session from an interactive shiny environment
by observing layer clicks. This is useful for returning the data.frame row relating to the
cliked shape.
</p>
<p>From within a shiny server you would typically use <code> observeEvent({input$map_arc_click})</code>,
where 'map' is the map_id supplied to <code>mapdeckOutput()</code>, and 'arc' is the layer
you are clicking on
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set_token( "MAPBOX_TOKEN")
sf &lt;- city_trail

mapdeck(
  style = mapdeck_style("dark")
) %&gt;%
 add_trips(
   data = sf
   , animation_speed = 500
   , trail_length = 500
   , stroke_colour = "#FFFFFF"
   , stroke_width = 25
)

## Multi-coloured trips
## requires a colour for each coordiante
## In this example I'm assining the elevation (z) value
## to a new column
df &lt;- sfheaders::sf_to_df( city_trail )
df$colour &lt;- df$z
sf &lt;- sfheaders::sf_linestring(
  obj = df
  , x = "x"
  , y = "y"
  , z = "z"
  , m = "m"
  , keep = TRUE
  , list_column = "colour"
)

mapdeck(
  style = mapdeck_style("light")
) %&gt;%
 add_trips(
   data = sf
   , animation_speed = 1000
   , trail_length = 1000
   , stroke_colour = "colour"
   , stroke_width = 50
   , legend = TRUE
)

## New York Taxi Trips
json &lt;- jsonify::from_json(
  "https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/trips/trips.json"
)

lens &lt;- vapply( json$segments, nrow, 1L )
mat &lt;- do.call( rbind, json$segments )
df &lt;- setNames( as.data.frame( mat ), c("x","y","m") )
idx &lt;- rep( seq_along( lens ), times = lens )
df$vendor &lt;- rep( json$vendor, times = lens )

df$z &lt;- 0 ## z column is required in SF object
df$idx &lt;- idx

## Using the timestamp as a colour
df$timestamp &lt;- df$m

sf_line &lt;- sfheaders::sf_linestring(
  obj = df
  , x = "x"
  , y = "y"
  , z = "z"
  , m = "m"
  , linestring_id = "idx"
  , keep = TRUE
  , list_column = "timestamp"
)

mapdeck(
  style = mapdeck_style("dark")
) %&gt;%
  add_trips(
    data = sf_line
    , stroke_colour = "timestamp"
    , animation_speed = 1000
    , trail_length = 1000
    , palette = colourvalues::get_palette("viridis")[100:256, ]
  )




</code></pre>

<hr>
<h2 id='capitals'>Capital cities for each country</h2><span id='topic+capitals'></span>

<h3>Description</h3>

<p>A data set containing the coordinates of 200 capitical cities in the world
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capitals
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations and 4 variables
</p>

<dl>
<dt>country</dt><dd><p>country name</p>
</dd>
<dt>capital</dt><dd><p>capital name</p>
</dd>
<dt>lat</dt><dd><p>latitude of capital</p>
</dd>
<dt>lon</dt><dd><p>longitude of capital</p>
</dd>
</dl>


<hr>
<h2 id='city_trail'>city_trail</h2><span id='topic+city_trail'></span>

<h3>Description</h3>

<p>An sf object of a cyclist cycling around Melbourne's Capital City Trail
</p>


<h3>Usage</h3>

<pre><code class='language-R'>city_trail
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1 rows and 3 columns.
</p>

<hr>
<h2 id='clear_animated_arc'>Clear Animated Arc</h2><span id='topic+clear_animated_arc'></span><span id='topic+clear_line'></span><span id='topic+clear_arc'></span><span id='topic+clear_bitmap'></span><span id='topic+clear_column'></span><span id='topic+clear_geojson'></span><span id='topic+clear_greatcircle'></span><span id='topic+clear_grid'></span><span id='topic+clear_h3_hexagon'></span><span id='topic+clear_heatmap'></span><span id='topic+clear_hexagon'></span><span id='topic+clear_mesh'></span><span id='topic+clear_path'></span><span id='topic+clear_pointcloud'></span><span id='topic+clear_polygon'></span><span id='topic+clear_scatterplot'></span><span id='topic+clear_screengrid'></span><span id='topic+clear_terrain'></span><span id='topic+clear_text'></span><span id='topic+clear_title'></span><span id='topic+clear_trips'></span>

<h3>Description</h3>

<p>Clears elements from a map
</p>
<p>Clears elements from a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_animated_arc(map, layer_id = NULL, update_view = TRUE)

clear_line(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_arc(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_bitmap(map, layer_id = NULL, update_view = TRUE)

clear_column(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_geojson(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_greatcircle(
  map,
  layer_id = NULL,
  update_view = TRUE,
  clear_legend = TRUE
)

clear_grid(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_h3_hexagon(map, layer_id = NULL)

clear_heatmap(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_hexagon(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_line(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_mesh(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_path(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_pointcloud(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_polygon(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_scatterplot(
  map,
  layer_id = NULL,
  update_view = TRUE,
  clear_legend = TRUE
)

clear_screengrid(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_terrain(map, layer_id = NULL, update_view = TRUE)

clear_text(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)

clear_title(map, layer_id = NULL)

clear_trips(map, layer_id = NULL, update_view = TRUE, clear_legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_animated_arc_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="clear_animated_arc_+3A_layer_id">layer_id</code></td>
<td>
<p>the layer_id of the layer you want to clear</p>
</td></tr>
<tr><td><code id="clear_animated_arc_+3A_update_view">update_view</code></td>
<td>
<p>logical indicating if the map should update the bounds after removing the layer</p>
</td></tr>
<tr><td><code id="clear_animated_arc_+3A_clear_legend">clear_legend</code></td>
<td>
<p>logical indicating if the legend should be removed</p>
</td></tr>
</table>

<hr>
<h2 id='clear_legend'>Clear Legend</h2><span id='topic+clear_legend'></span>

<h3>Description</h3>

<p>Clears the legend for a given layer_id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_legend(map, layer_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_legend_+3A_map">map</code></td>
<td>
<p>the map from which you want to clear the legend.</p>
</td></tr>
<tr><td><code id="clear_legend_+3A_layer_id">layer_id</code></td>
<td>
<p>single value specifying an id for the layer. Use this value to
distinguish between shape layers of the same type. Layers with the same id are likely
to conflict and not plot correctly</p>
</td></tr>
</table>

<hr>
<h2 id='clear_tokens'>Clear tokens</h2><span id='topic+clear_tokens'></span>

<h3>Description</h3>

<p>Clears the access tokens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_tokens()
</code></pre>

<hr>
<h2 id='geojson'>Geojson</h2><span id='topic+geojson'></span>

<h3>Description</h3>

<p>A GeoJSON object of polygons, lines and points in Melbourne
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geojson
</code></pre>


<h3>Format</h3>

<p>a 'json' object
</p>

<hr>
<h2 id='legend_element'>Legend Element</h2><span id='topic+legend_element'></span>

<h3>Description</h3>

<p>Creates a mapdeck legend element for when you want to manually specify a legend (using <a href="#topic+mapdeck_legend">mapdeck_legend</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_element(
  variables,
  colours,
  colour_type = c("fill", "stroke"),
  variable_type = c("category", "gradient"),
  title = "",
  css = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend_element_+3A_variables">variables</code></td>
<td>
<p>variables assigned to colours</p>
</td></tr>
<tr><td><code id="legend_element_+3A_colours">colours</code></td>
<td>
<p>vector of hex colours assigned to variables</p>
</td></tr>
<tr><td><code id="legend_element_+3A_colour_type">colour_type</code></td>
<td>
<p>one of &quot;fill&quot; or &quot;stroke&quot;</p>
</td></tr>
<tr><td><code id="legend_element_+3A_variable_type">variable_type</code></td>
<td>
<p>one of category (discrete) or gradient (continuous)</p>
</td></tr>
<tr><td><code id="legend_element_+3A_title">title</code></td>
<td>
<p>string used as the legend title</p>
</td></tr>
<tr><td><code id="legend_element_+3A_css">css</code></td>
<td>
<p>string of css to control appearance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mapdeck_legend">mapdeck_legend</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
l1 &lt;- legend_element(
	variables = c("a","b")
	, colours = c("#00FF00","#FF0000")
	, colour_type = "fill"
	, variable_type = "category"
	, title = "my title"
)

</code></pre>

<hr>
<h2 id='light_settings'>Light Settings</h2><span id='topic+light_settings'></span>

<h3>Description</h3>

<p>List object containg light settings.
</p>


<h3>Details</h3>

<p>Available in <a href="#topic+add_geojson">add_geojson</a>, <a href="#topic+add_pointcloud">add_pointcloud</a> and <a href="#topic+add_polygon">add_polygon</a>
</p>

<ul>
<li><p>numberOfLights - the number of lights. Maximum of 5
</p>
</li>
<li><p>lightsPosition - vector of x, y, z coordinates. Must be 3x the nubmer of lights
</p>
</li>
<li><p>ambientRatio - the ambient ratio of the lights
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
light &lt;- list(
  lightsPosition = c(-150, 75, 0)
  , numberOfLights = 1
  , ambientRatio = 0.2
)

</code></pre>

<hr>
<h2 id='mapdeck'>mapdeck</h2><span id='topic+mapdeck'></span>

<h3>Description</h3>

<p>mapdeck
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck(
  data = NULL,
  token = get_access_token(api = "mapbox"),
  width = NULL,
  height = NULL,
  padding = 0,
  style = "mapbox://styles/mapbox/streets-v9",
  pitch = 0,
  zoom = 0,
  bearing = 0,
  libraries = NULL,
  max_zoom = 20,
  min_zoom = 0,
  max_pitch = 60,
  min_pitch = 0,
  location = c(0, 0),
  show_view_state = FALSE,
  repeat_view = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_token">token</code></td>
<td>
<p>Mapbox Acess token. Use <code>set_token()</code> or <code>Sys.setenv()</code> to set a global token.
See Access Tokens section for further details.
If left empty layers will still be plotted, but without a Mapbox map.</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_width">width</code></td>
<td>
<p>the width of the map</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_height">height</code></td>
<td>
<p>the height of the map</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_padding">padding</code></td>
<td>
<p>the padding of the map</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_style">style</code></td>
<td>
<p>the style of the map (see <a href="#topic+mapdeck_style">mapdeck_style</a>)</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_pitch">pitch</code></td>
<td>
<p>the pitch angle of the map</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_zoom">zoom</code></td>
<td>
<p>zoom level of the map</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_bearing">bearing</code></td>
<td>
<p>bearing of the map between 0 and 360</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_libraries">libraries</code></td>
<td>
<p>additional libraries required by some layers. Currently
'h3' is required for <a href="#topic+add_h3">add_h3</a>.</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_max_zoom">max_zoom</code></td>
<td>
<p>sets the maximum zoom level</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_min_zoom">min_zoom</code></td>
<td>
<p>sets the minimum zoom level</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_max_pitch">max_pitch</code></td>
<td>
<p>sets the maximum pitch</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_min_pitch">min_pitch</code></td>
<td>
<p>sets the minimum pitch</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_location">location</code></td>
<td>
<p>unnamed vector of lon and lat coordinates (in that order)</p>
</td></tr>
<tr><td><code id="mapdeck_+3A_show_view_state">show_view_state</code></td>
<td>
<p>logical, indicating whether to add the current View State to the map.
When <code>TRUE</code>, the following is added as an overlay to the map
</p>

<ul>
<li><p>width
</p>
</li>
<li><p>height
</p>
</li>
<li><p>latitude &amp; longitude
</p>
</li>
<li><p>zoom
</p>
</li>
<li><p>bearing
</p>
</li>
<li><p>pitch
</p>
</li>
<li><p>altitude
</p>
</li>
<li><p>viewBounds
</p>
</li>
<li><p>interactionState
</p>
</li></ul>
</td></tr>
<tr><td><code id="mapdeck_+3A_repeat_view">repeat_view</code></td>
<td>
<p>Logical indicating if the layers should repeat at low zoom levels</p>
</td></tr>
</table>


<h3>Access Tokens</h3>

<p>If the <code>token</code> argument is not used, the map will search for the token, firstly by
checking if <code>set_token()</code> was used, then it will search environment variables using
<code>Sys.getenv()</code> and the following values, in this order
</p>
<p>c(&quot;MAPBOX_TOKEN&quot;,&quot;MAPBOX_KEY&quot;,&quot;MAPBOX_API_TOKEN&quot;, &quot;MAPBOX_API_KEY&quot;, &quot;MAPBOX&quot;, &quot;MAPDECK&quot;)
</p>
<p>If multiple tokens are found, the first one is used
</p>

<hr>
<h2 id='mapdeck_dependencies'>Mapdeck Dependencies</h2><span id='topic+mapdeck_dependencies'></span>

<h3>Description</h3>

<p>Adds the required mapdeck javascript dependencies to a Shiny UI when you want to use
mapdeck layers, but not with a mapdeck map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_dependencies()
</code></pre>

<hr>
<h2 id='mapdeck_dispatch'>mapdeck dispatch</h2><span id='topic+mapdeck_dispatch'></span><span id='topic+invoke_method'></span>

<h3>Description</h3>

<p>Extension points for plugins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_dispatch(
  map,
  funcName,
  mapdeck = stop(paste(funcName, "requires a map update object")),
  mapdeck_update = stop(paste(funcName, "does not support map update objects"))
)

invoke_method(map, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_dispatch_+3A_map">map</code></td>
<td>
<p>a map object, as returned from <code><a href="#topic+mapdeck">mapdeck</a></code></p>
</td></tr>
<tr><td><code id="mapdeck_dispatch_+3A_funcname">funcName</code></td>
<td>
<p>the name of the function that the user called that caused
this <code>mapdeck_dispatch</code> call; for error message purposes</p>
</td></tr>
<tr><td><code id="mapdeck_dispatch_+3A_mapdeck">mapdeck</code></td>
<td>
<p>an action to be performed if the map is from
<code><a href="#topic+mapdeck">mapdeck</a></code></p>
</td></tr>
<tr><td><code id="mapdeck_dispatch_+3A_mapdeck_update">mapdeck_update</code></td>
<td>
<p>an action to be performed if the map is from
<code><a href="#topic+mapdeck_update">mapdeck_update</a></code></p>
</td></tr>
<tr><td><code id="mapdeck_dispatch_+3A_method">method</code></td>
<td>
<p>the name of the JavaScript method to invoke</p>
</td></tr>
<tr><td><code id="mapdeck_dispatch_+3A_...">...</code></td>
<td>
<p>unnamed arguments to be passed to the JavaScript method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mapdeck_dispatch</code> returns the value of <code>mapdeck</code> or
or an error. <code>invokeMethod</code> returns the
<code>map</code> object that was passed in, possibly modified.
</p>

<hr>
<h2 id='mapdeck_legend'>Mapdeck Legend</h2><span id='topic+mapdeck_legend'></span>

<h3>Description</h3>

<p>Constructs legend elements into the correct JSON format for plotting on the map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_legend(legend_elements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_legend_+3A_legend_elements">legend_elements</code></td>
<td>
<p>vector of legend elements (made from <a href="#topic+legend_element">legend_element</a>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+legend_element">legend_element</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l1 &lt;- legend_element(
	variables = c("a","b")
	, colours = c("#00FF00","#FF0000")
	, colour_type = "fill"
	, variable_type = "category"
	, title = "my title"
)

mapdeck_legend(l1)

</code></pre>

<hr>
<h2 id='mapdeck_style'>Mapdeck Style</h2><span id='topic+mapdeck_style'></span>

<h3>Description</h3>

<p>Various styles available to all Mapbox accounts using a valid access token.
Available styles are listed at
<a href="https://docs.mapbox.com/api/maps/#styles">https://docs.mapbox.com/api/maps/#styles</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_style(
  style = c("dark", "light", "outdoors", "streets", "satellite", "satellite-streets")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_style_+3A_style">style</code></td>
<td>
<p>one of streets, outdoors, light, dark, satellite, satellite-streets</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## You need a valid access token from Mapbox
key &lt;- 'abc'

## set a map style
mapdeck(token = key, style = mapdeck_style("dark"))



</code></pre>

<hr>
<h2 id='mapdeck_tokens'>Mapdeck_tokens</h2><span id='topic+mapdeck_tokens'></span>

<h3>Description</h3>

<p>Retrieves the mapdeck token that has been set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_tokens()
</code></pre>

<hr>
<h2 id='mapdeck_update'>Mapdeck update</h2><span id='topic+mapdeck_update'></span>

<h3>Description</h3>

<p>Update a Mapdeck map in a shiny app. Use this function whenever the map needs
to respond to reactive content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_update(
  data = NULL,
  map_id,
  session = shiny::getDefaultReactiveDomain(),
  deferUntilFlush = TRUE,
  map_type = c("mapdeck_update", "google_map_update")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_update_+3A_data">data</code></td>
<td>
<p>data to be used in the layer. All coordinates are expected to be
EPSG:4326 (WGS 84) coordinate system</p>
</td></tr>
<tr><td><code id="mapdeck_update_+3A_map_id">map_id</code></td>
<td>
<p>string containing the output ID of the map in a shiny application.</p>
</td></tr>
<tr><td><code id="mapdeck_update_+3A_session">session</code></td>
<td>
<p>the Shiny session object to which the map belongs; usually the
default value will suffice.</p>
</td></tr>
<tr><td><code id="mapdeck_update_+3A_deferuntilflush">deferUntilFlush</code></td>
<td>
<p>indicates whether actions performed against this
instance should be carried out right away, or whether they should be held until
after the next time all of the outputs are updated; defaults to TRUE.</p>
</td></tr>
<tr><td><code id="mapdeck_update_+3A_map_type">map_type</code></td>
<td>
<p>either mapdeck_update or google_map_update</p>
</td></tr>
</table>

<hr>
<h2 id='mapdeck_view'>Mapdeck view</h2><span id='topic+mapdeck_view'></span>

<h3>Description</h3>

<p>Changes the view of the of the map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeck_view(
  map,
  location = NULL,
  zoom = NULL,
  pitch = NULL,
  bearing = NULL,
  duration = NULL,
  transition = c("linear", "fly")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck_view_+3A_map">map</code></td>
<td>
<p>a <code>mapdeck</code> map object</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_location">location</code></td>
<td>
<p>unnamed vector of lon and lat coordinates (in that order)</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_zoom">zoom</code></td>
<td>
<p>zoom level of the map</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_pitch">pitch</code></td>
<td>
<p>the pitch angle of the map</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_bearing">bearing</code></td>
<td>
<p>bearing of the map between 0 and 360</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_duration">duration</code></td>
<td>
<p>time in milliseconds of the transition</p>
</td></tr>
<tr><td><code id="mapdeck_view_+3A_transition">transition</code></td>
<td>
<p>type of transition</p>
</td></tr>
</table>

<hr>
<h2 id='mapdeck-shiny'>Shiny bindings for mapdeck</h2><span id='topic+mapdeck-shiny'></span><span id='topic+mapdeckOutput'></span><span id='topic+renderMapdeck'></span>

<h3>Description</h3>

<p>Output and render functions for using mapdeck within Shiny
applications and interactive Rmd documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapdeckOutput(outputId, width = "100%", height = "400px")

renderMapdeck(expr, env = parent.frame(), quoted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapdeck-shiny_+3A_outputid">outputId</code></td>
<td>
<p>output variable to read from</p>
</td></tr>
<tr><td><code id="mapdeck-shiny_+3A_width">width</code>, <code id="mapdeck-shiny_+3A_height">height</code></td>
<td>
<p>Must be a valid CSS unit (like <code>'100%'</code>,
<code>'400px'</code>, <code>'auto'</code>) or a number, which will be coerced to a
string and have <code>'px'</code> appended.</p>
</td></tr>
<tr><td><code id="mapdeck-shiny_+3A_expr">expr</code></td>
<td>
<p>An expression that generates a mapdeck</p>
</td></tr>
<tr><td><code id="mapdeck-shiny_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>.</p>
</td></tr>
<tr><td><code id="mapdeck-shiny_+3A_quoted">quoted</code></td>
<td>
<p>Is <code>expr</code> a quoted expression (with <code>quote()</code>)? This
is useful if you want to save an expression in a variable.</p>
</td></tr>
</table>

<hr>
<h2 id='melbourne'>Polygons in and around Melbourne</h2><span id='topic+melbourne'></span>

<h3>Description</h3>

<p>A data set containing statistical area 2 regions of central (and surrounds) Melbourne.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melbourne
</code></pre>


<h3>Format</h3>

<p>An sfencoded and data frame object with 41 observations and 8 variables.
See library googlePolylines for information on sfencoded objects
</p>

<hr>
<h2 id='melbourne_mesh'>Melbourne Mesh</h2><span id='topic+melbourne_mesh'></span>

<h3>Description</h3>

<p>A mesh3d object of Melbourne
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melbourne_mesh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mesh3d</code> (inherits from <code>shape3d</code>) of length 6.
</p>

<hr>
<h2 id='road_safety'>road_safety</h2><span id='topic+road_safety'></span>

<h3>Description</h3>

<p>A data.frame of counts of traffic accidents in the UK
</p>


<h3>Usage</h3>

<pre><code class='language-R'>road_safety
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 19139 rows and 2 columns.
</p>

<hr>
<h2 id='roads'>Roads in central Melbourne</h2><span id='topic+roads'></span>

<h3>Description</h3>

<p>A simple feature <code>sf</code> object of roads in central Melbourne
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roads
</code></pre>


<h3>Format</h3>

<p>An sf and data frame object with 18286 observations and 16 variables
</p>


<h3>Details</h3>

<p>Obtained from <a href="https://www.data.gov.au">https://www.data.gov.au</a> and distributed under the Creative Commons 4 License
<a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>
</p>

<hr>
<h2 id='set_token'>Set Token</h2><span id='topic+set_token'></span>

<h3>Description</h3>

<p>Sets an access token so it's available for all mapdeck calls. See details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_token(token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_token_+3A_token">token</code></td>
<td>
<p>Mapbox access token</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>set_token</code> to make access tokens available for all the <code>mapdeck()</code>
calls in a session so you don't have to keep specifying the <code>token</code> argument
each time
</p>

<hr>
<h2 id='update_style'>update style</h2><span id='topic+update_style'></span>

<h3>Description</h3>

<p>update style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_style(map, style)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_style_+3A_map">map</code></td>
<td>
<p>a mapdeck map object</p>
</td></tr>
<tr><td><code id="update_style_+3A_style">style</code></td>
<td>
<p>the style of the map (see <a href="#topic+mapdeck_style">mapdeck_style</a>)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
