<!DOCTYPE html><html><head><title>Help for package stacks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stacks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stacks_description'><p>stacks: Tidy Model Stacking</p></a></li>
<li><a href='#add_candidates'><p>Add model definitions to a data stack</p></a></li>
<li><a href='#augment.model_stack'><p>Augment a model stack</p></a></li>
<li><a href='#autoplot.linear_stack'><p>Plot results of a stacked ensemble model.</p></a></li>
<li><a href='#axe_model_stack'><p>Axing a model_stack.</p></a></li>
<li><a href='#blend_predictions'><p>Determine stacking coefficients from a data stack</p></a></li>
<li><a href='#build_linear_predictor'><p>Creates an R expression for a linear predictor from a data frame of terms and</p>
coefficients</a></li>
<li><a href='#collect_parameters'><p>Collect candidate parameters and stacking coefficients</p></a></li>
<li><a href='#control_stack_grid'><p>Control wrappers</p></a></li>
<li><a href='#example_data'><p>Example Objects</p></a></li>
<li><a href='#fit_members'><p>Fit model stack members with non-zero stacking coefficients</p></a></li>
<li><a href='#get_expressions'><p>Obtain prediction equations for all possible values of type</p></a></li>
<li><a href='#predict.data_stack'><p>Predicting with a model stack</p></a></li>
<li><a href='#predict.model_stack'><p>Predicting with a model stack</p></a></li>
<li><a href='#prediction_eqn'><p>Convert one or more linear predictor to a format used for prediction</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#stack_predict'><p>Convert one or more linear predictor to a format used for prediction</p></a></li>
<li><a href='#stacks'><p>Initialize a Stack</p></a></li>
<li><a href='#tree_frogs'><p>Tree frog embryo hatching data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Model Stacking</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Model stacking is an ensemble technique that involves
    training a model to combine the outputs of many diverse statistical
    models, and has been shown to improve predictive performance in a
    variety of settings. 'stacks' implements a grammar for
    'tidymodels'-aligned model stacking.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stacks.tidymodels.org/">https://stacks.tidymodels.org/</a>,
<a href="https://github.com/tidymodels/stacks">https://github.com/tidymodels/stacks</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/stacks/issues">https://github.com/tidymodels/stacks/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>butcher (&ge; 0.1.3), cli, doFuture, dplyr (&ge; 1.1.0), foreach,
future, generics, ggplot2, glmnet, glue, parsnip (&ge; 1.2.0),
purrr (&ge; 1.0.0), recipes (&ge; 1.0.10), rlang (&ge; 1.1.3),
rsample (&ge; 1.2.0), stats, tibble (&ge; 2.1.3), tidyr, tune (&ge;
1.2.0), vctrs (&ge; 0.6.1), workflows (&ge; 1.1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, h2o, kernlab, kknn, knitr, mockr, modeldata, nnet,
ranger, rmarkdown, testthat (&ge; 3.0.0), workflowsets (&ge;
0.1.0), yardstick (&ge; 1.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 17:54:31 UTC; simoncouch</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Couch [aut, cre],
  Max Kuhn [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Couch &lt;simon.couch@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stacks_description'>stacks: Tidy Model Stacking</h2><span id='topic+stacks_description'></span><span id='topic+stacks_package'></span><span id='topic+stacks-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Model stacking is an ensemble technique that involves training a model to combine the outputs of many diverse statistical models, and has been shown to improve predictive performance in a variety of settings. 'stacks' implements a grammar for 'tidymodels'-aligned model stacking.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Simon Couch <a href="mailto:simon.couch@posit.co">simon.couch@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://stacks.tidymodels.org/">https://stacks.tidymodels.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidymodels/stacks">https://github.com/tidymodels/stacks</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/stacks/issues">https://github.com/tidymodels/stacks/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_candidates'>Add model definitions to a data stack</h2><span id='topic+add_candidates'></span>

<h3>Description</h3>

<p><code>add_candidates()</code> collates the assessment set predictions
and additional attributes from the supplied model definition
(i.e. set of &quot;candidates&quot;) to a data stack.
</p>
<p>Behind the scenes, data stack objects are just <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a>s,
where the first column gives the true response values,
and the remaining columns give the assessment set predictions
for each candidate. In the regression setting, there's only
one column per ensemble member. In classification settings,
there are as many columns per candidate ensemble member
as there are levels of the outcome variable.
</p>
<p>To initialize a data stack, use the <code>stacks()</code> function.
Model definitions are appended to a data stack iteratively
using several calls to <code>add_candidates()</code>. Data stacks are
evaluated using the <code><a href="#topic+blend_predictions">blend_predictions()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_candidates(
  data_stack,
  candidates,
  name = deparse(substitute(candidates)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_candidates_+3A_data_stack">data_stack</code></td>
<td>
<p>A <code>data_stack</code> object.</p>
</td></tr>
<tr><td><code id="add_candidates_+3A_candidates">candidates</code></td>
<td>
<p>A (set of) model definition(s) defining candidate model
stack members. Should inherit from <code>tune_results</code> or <code>workflow_set</code>.
</p>

<ul>
<li> <p><code>tune_results</code>: An object outputted from <code><a href="tune.html#topic+tune_grid">tune::tune_grid()</a></code>,
<code><a href="tune.html#topic+tune_bayes">tune::tune_bayes()</a></code>, or <code><a href="tune.html#topic+fit_resamples">tune::fit_resamples()</a></code>.
</p>
</li>
<li> <p><code>workflow_set</code>: An object outputted from <code>workflowsets::workflow_map()</code>.
This approach allows for supplying multiple sets of candidate members
with only one call to <code>add_candidates</code>. See the &quot;Stacking With Workflow Sets&quot;
article on the <a href="https://stacks.tidymodels.org/">package website</a> for example code!
</p>
</li></ul>

<p>Regardless, these results must have been fitted with the <code>control</code> settings
<code style="white-space: pre;">&#8288;save_pred = TRUE, save_workflow = TRUE&#8288;</code>â€”see the <code><a href="#topic+control_stack_grid">control_stack_grid()</a></code>,
<code><a href="#topic+control_stack_bayes">control_stack_bayes()</a></code>, and <code><a href="#topic+control_stack_resamples">control_stack_resamples()</a></code>
documentation for helper functions.</p>
</td></tr>
<tr><td><code id="add_candidates_+3A_name">name</code></td>
<td>
<p>The label for the model definition&mdash;defaults to the name
of the <code>candidates</code> object. Ignored if <code>candidates</code> inherits from
<code>workflow_set</code>.</p>
</td></tr>
<tr><td><code id="add_candidates_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data_stack</code> object&ndash;see <code><a href="#topic+stacks">stacks()</a></code> for more details!
</p>


<h3>Example Data</h3>

<p>This package provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>See <code>?example_data</code> to learn more about these objects, as well as browse
the source code that generated them.
</p>


<h3>See Also</h3>

<p>Other core verbs: 
<code><a href="#topic+blend_predictions">blend_predictions</a>()</code>,
<code><a href="#topic+fit_members">fit_members</a>()</code>,
<code><a href="#topic+stacks">stacks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see the "Example Data" section above for
# clarification on the objects used in these examples!

# put together a data stack using
# tuning results for regression models
reg_st &lt;- 
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_svm) %&gt;%
  add_candidates(reg_res_sp)
  
reg_st
  
# do the same with multinomial classification models
class_st &lt;-
  stacks() %&gt;%
  add_candidates(class_res_nn) %&gt;%
  add_candidates(class_res_rf)
  
class_st
  
# ...or binomial classification models
log_st &lt;-
  stacks() %&gt;%
  add_candidates(log_res_nn) %&gt;%
  add_candidates(log_res_rf)
  
log_st
  
# use custom names for each model:
log_st2 &lt;-
  stacks() %&gt;%
  add_candidates(log_res_nn, name = "neural_network") %&gt;%
  add_candidates(log_res_rf, name = "random_forest")
  
log_st2
  
# these objects would likely then be
# passed to blend_predictions():
log_st2 %&gt;% blend_predictions()

</code></pre>

<hr>
<h2 id='augment.model_stack'>Augment a model stack</h2><span id='topic+augment.model_stack'></span>

<h3>Description</h3>

<p>Augment a model stack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_stack'
augment(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.model_stack_+3A_x">x</code></td>
<td>
<p>A fitted model stack; see <code><a href="#topic+fit_members">fit_members()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.model_stack_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="augment.model_stack_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>predict.model_stack</code>. In
particular, see <code>type</code> and <code>members</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The <code><a href="#topic+collect_parameters">collect_parameters()</a></code> function is analogous to a <code><a href="generics.html#topic+tidy">tidy()</a></code>
method for model stacks.
</p>

<hr>
<h2 id='autoplot.linear_stack'>Plot results of a stacked ensemble model.</h2><span id='topic+autoplot.linear_stack'></span>

<h3>Description</h3>

<p>Plot results of a stacked ensemble model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linear_stack'
autoplot(object, type = "performance", n = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.linear_stack_+3A_object">object</code></td>
<td>
<p>A <code>linear_stack</code> object outputted from <code><a href="#topic+blend_predictions">blend_predictions()</a></code>
or <code><a href="#topic+fit_members">fit_members()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.linear_stack_+3A_type">type</code></td>
<td>
<p>A single character string for plot type with values &quot;performance&quot;,
&quot;members&quot;, or &quot;weights&quot;.</p>
</td></tr>
<tr><td><code id="autoplot.linear_stack_+3A_n">n</code></td>
<td>
<p>An integer for how many members weights to plot when
<code>type = "weights"</code>. With multi-class data, this is the total number of weights
across classes; otherwise this is equal to the number of members.</p>
</td></tr>
<tr><td><code id="autoplot.linear_stack_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &quot;performance&quot; plot shows the relationship between the lasso penalty and the
resampled performance metrics. The latter includes the average number of
ensemble members. This plot can be helpful for understanding what penalty
values are reasonable.
</p>
<p>A &quot;members&quot; plot shows the relationship between the average number of
ensemble members and the performance metrics. Each point is for a different
penalty value.
</p>
<p>Neither of the &quot;performance&quot; or &quot;members&quot; plots are helpful when a single
penalty is used.
</p>
<p>A &quot;weights&quot; plot shows the blending weights for the top ensemble members. The
results are for the final penalty value used to fit the ensemble.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='axe_model_stack'>Axing a model_stack.</h2><span id='topic+axe_model_stack'></span><span id='topic+axe_call.model_stack'></span><span id='topic+axe_ctrl.model_stack'></span><span id='topic+axe_data.model_stack'></span><span id='topic+axe_env.model_stack'></span><span id='topic+axe_fitted.model_stack'></span>

<h3>Description</h3>

<p>Axing a model_stack.
</p>
<p>Remove the call.
</p>
<p>Remove controls used for training.
</p>
<p>Remove the training data.
</p>
<p>Remove environments.
</p>
<p>Remove fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_stack'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'model_stack'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'model_stack'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'model_stack'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'model_stack'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axe_model_stack_+3A_x">x</code></td>
<td>
<p>A model object</p>
</td></tr>
<tr><td><code id="axe_model_stack_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are disabled.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_model_stack_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed model_stack object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# build a regression model stack
st &lt;-
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_sp) %&gt;%
  blend_predictions() %&gt;%
  fit_members()
  
# remove any of the "butcherable"
# elements individually
axe_call(st)
axe_ctrl(st)
axe_data(st)
axe_fitted(st)
axe_env(st)

# or do it all at once!
butchered_st &lt;- butcher(st, verbose = TRUE)

format(object.size(st))
format(object.size(butchered_st))

</code></pre>

<hr>
<h2 id='blend_predictions'>Determine stacking coefficients from a data stack</h2><span id='topic+blend_predictions'></span>

<h3>Description</h3>

<p>Evaluates a data stack by fitting a regularized model on the
assessment predictions from each candidate member to predict
the true outcome.
</p>
<p>This process determines the &quot;stacking coefficients&quot; of the model
stack. The stacking coefficients are used to weight the
predictions from each candidate (represented by a unique column
in the data stack), and are given by the betas of a LASSO model
fitting the true outcome with the predictions given in the
remaining columns of the data stack.
</p>
<p>Candidates with non-zero stacking coefficients are model stack
members, and need to be trained on the full training set (rather
than just the assessment set) with <code><a href="#topic+fit_members">fit_members()</a></code>. This function
is typically used after a number of calls to <code><a href="#topic+add_candidates">add_candidates()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blend_predictions(
  data_stack,
  penalty = 10^(-6:-1),
  mixture = 1,
  non_negative = TRUE,
  metric = NULL,
  control = tune::control_grid(),
  times = 25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blend_predictions_+3A_data_stack">data_stack</code></td>
<td>
<p>A <code>data_stack</code> object</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_penalty">penalty</code></td>
<td>
<p>A numeric vector of proposed values for total amount of
regularization used in member weighting. Higher penalties will generally
result in fewer members being included in the resulting model stack, and
vice versa. The package will tune over a grid formed from the cross
product of the <code>penalty</code> and <code>mixture</code> arguments.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_mixture">mixture</code></td>
<td>
<p>A number between zero and one (inclusive) giving the
proportion of L1 regularization (i.e. lasso) in the model. <code>mixture = 1</code>
indicates a pure lasso model, <code>mixture = 0</code> indicates ridge regression, and
values in <code style="white-space: pre;">&#8288;(0, 1)&#8288;</code> indicate an elastic net. The package will tune over
a grid formed from the cross product of the <code>penalty</code> and <code>mixture</code>
arguments.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_non_negative">non_negative</code></td>
<td>
<p>A logical giving whether to restrict stacking
coefficients to non-negative values. If <code>TRUE</code> (default), 0 is passed as
the <code>lower.limits</code> argument to <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> in fitting the
model on the data stack. Otherwise, <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_metric">metric</code></td>
<td>
<p>A call to <code><a href="yardstick.html#topic+metric_set">yardstick::metric_set()</a></code>. The metric(s) to use in
tuning the lasso penalty on the stacking coefficients. Default values are
determined by <code><a href="tune.html#topic+tune_grid">tune::tune_grid()</a></code> from the outcome class.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_control">control</code></td>
<td>
<p>An object inheriting from <code>control_grid</code> to be passed to
the model determining stacking coefficients. See <code><a href="tune.html#topic+control_grid">tune::control_grid()</a></code>
documentation for details on possible values. Note that any <code>extract</code>
entry will be overwritten internally.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_times">times</code></td>
<td>
<p>Number of bootstrap samples tuned over by the model that
determines stacking coefficients. See <code><a href="rsample.html#topic+bootstraps">rsample::bootstraps()</a></code> to
learn more.</p>
</td></tr>
<tr><td><code id="blend_predictions_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that a regularized linear model is one of many possible
learning algorithms that could be used to fit a stacked ensemble
model. For implementations of additional ensemble learning algorithms, see
<code><a href="h2o.html#topic+h2o.stackedEnsemble">h2o::h2o.stackedEnsemble()</a></code> and <code>SuperLearner::SuperLearner()</code>.
</p>


<h3>Value</h3>

<p>A <code>model_stack</code> objectâ€”while <code>model_stack</code>s largely contain the
same elements as <code>data_stack</code>s, the primary data objects shift from the
assessment set predictions to the member models.
</p>


<h3>Example Data</h3>

<p>This package provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>See <code>?example_data</code> to learn more about these objects, as well as browse
the source code that generated them.
</p>


<h3>See Also</h3>

<p>Other core verbs: 
<code><a href="#topic+add_candidates">add_candidates</a>()</code>,
<code><a href="#topic+fit_members">fit_members</a>()</code>,
<code><a href="#topic+stacks">stacks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see the "Example Data" section above for
# clarification on the objects used in these examples!

# put together a data stack
reg_st &lt;- 
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_svm) %&gt;%
  add_candidates(reg_res_sp)
  
reg_st

# evaluate the data stack
reg_st %&gt;%
  blend_predictions()

# include fewer models by proposing higher penalties
reg_st %&gt;% 
  blend_predictions(penalty = c(.5, 1))

# allow for negative stacking coefficients 
# with the non_negative argument
reg_st %&gt;% 
  blend_predictions(non_negative = FALSE)
  
# use a custom metric in tuning the lasso penalty
library(yardstick)
reg_st %&gt;% 
  blend_predictions(metric = metric_set(rmse))
  
# pass control options for stack blending
reg_st %&gt;% 
  blend_predictions(
    control = tune::control_grid(allow_par = TRUE)
  )
 
# to speed up the stacking process for preliminary
# results, bump down the `times` argument:
reg_st %&gt;% 
  blend_predictions(times = 5)
  
# the process looks the same with 
# multinomial classification models
class_st &lt;-
  stacks() %&gt;%
  add_candidates(class_res_nn) %&gt;%
  add_candidates(class_res_rf) %&gt;%
  blend_predictions()
  
class_st

# ...or binomial classification models
log_st &lt;-
  stacks() %&gt;%
  add_candidates(log_res_nn) %&gt;%
  add_candidates(log_res_rf) %&gt;%
  blend_predictions()
  
log_st

</code></pre>

<hr>
<h2 id='build_linear_predictor'>Creates an R expression for a linear predictor from a data frame of terms and
coefficients</h2><span id='topic+build_linear_predictor'></span><span id='topic+build_linear_predictor._elnet'></span><span id='topic+build_linear_predictor._lognet'></span><span id='topic+build_linear_predictor._multnet'></span>

<h3>Description</h3>

<p>Creates an R expression for a linear predictor from a data frame of terms and
coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_linear_predictor(x, ...)

## S3 method for class ''_elnet''
build_linear_predictor(x, ...)

## S3 method for class ''_lognet''
build_linear_predictor(x, ...)

## S3 method for class ''_multnet''
build_linear_predictor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_linear_predictor_+3A_x">x</code></td>
<td>
<p>An object that uses a <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> model and all numeric predictors.</p>
</td></tr>
<tr><td><code id="build_linear_predictor_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R expression or a list of R expressions, depending on the type of
model being used.
</p>

<hr>
<h2 id='collect_parameters'>Collect candidate parameters and stacking coefficients</h2><span id='topic+collect_parameters'></span><span id='topic+collect_parameters.default'></span><span id='topic+collect_parameters.data_stack'></span><span id='topic+collect_parameters.model_stack'></span>

<h3>Description</h3>

<p>A function to help situate candidates within a stack. Takes in a data
stack or model stack and candidate name and returns a tibble mapping the
candidate/member names to their hyperparameters (and, if a model stack,
to their stacking coefficients as well).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_parameters(stack, candidates, ...)

## Default S3 method:
collect_parameters(stack, candidates, ...)

## S3 method for class 'data_stack'
collect_parameters(stack, candidates, ...)

## S3 method for class 'model_stack'
collect_parameters(stack, candidates, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_parameters_+3A_stack">stack</code></td>
<td>
<p>A <code>data_stack</code> or <code>model_stack</code> object.</p>
</td></tr>
<tr><td><code id="collect_parameters_+3A_candidates">candidates</code></td>
<td>
<p>The name of the candidates to collect parameters on.
This will either be the <code>name</code> argument supplied to <code><a href="#topic+add_candidates">add_candidates()</a></code> or,
if not supplied, the name of the object supplied to the <code>candidates</code>
argument in <code><a href="#topic+add_candidates">add_candidates()</a></code>.</p>
</td></tr>
<tr><td><code id="collect_parameters_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a> with information on member names and hyperparameters.
</p>


<h3>Example Data</h3>

<p>This package provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>See <code>?example_data</code> to learn more about these objects, as well as browse
the source code that generated them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see the "Example Data" section above for
# clarification on the objects used in these examples!

# put together a data stack using
# tuning results for regression models
reg_st &lt;- 
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_svm) %&gt;%
  add_candidates(reg_res_sp, "spline")
  
reg_st
  
# check out the hyperparameters for some of the candidates
collect_parameters(reg_st, "reg_res_svm")

collect_parameters(reg_st, "spline")

# blend the data stack to view the hyperparameters 
# along with the stacking coefficients!
collect_parameters(
  reg_st %&gt;% blend_predictions(), 
  "spline"
)

</code></pre>

<hr>
<h2 id='control_stack_grid'>Control wrappers</h2><span id='topic+control_stack_grid'></span><span id='topic+control_stack_resamples'></span><span id='topic+control_stack_bayes'></span>

<h3>Description</h3>

<p>Supply these light wrappers as the <code>control</code> argument in a
<code><a href="tune.html#topic+tune_grid">tune::tune_grid()</a></code>, <code><a href="tune.html#topic+tune_bayes">tune::tune_bayes()</a></code>, or <code><a href="tune.html#topic+fit_resamples">tune::fit_resamples()</a></code>
call to return the needed elements for use in a data stack.
These functions will return the appropriate control grid to ensure that
assessment set predictions and information on model specifications and
preprocessors, is supplied in the resampling results object!
</p>
<p>To integrate stack settings with your existing control settings, note
that these functions just call the appropriate <code style="white-space: pre;">&#8288;tune::control_*&#8288;</code> function
with the arguments <code style="white-space: pre;">&#8288;save_pred = TRUE, save_workflow = TRUE&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_stack_grid()

control_stack_resamples()

control_stack_bayes()
</code></pre>


<h3>Value</h3>

<p>A <a href="tune.html#topic+control_grid">tune::control_grid</a>, <a href="tune.html#topic+control_bayes">tune::control_bayes</a>,
or <a href="tune.html#topic+control_grid">tune::control_resamples</a> object.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+example_data">example_data</a> for examples of these functions used in context.
</p>

<hr>
<h2 id='example_data'>Example Objects</h2><span id='topic+example_data'></span><span id='topic+reg_res_svm'></span><span id='topic+reg_res_sp'></span><span id='topic+reg_res_lr'></span><span id='topic+reg_folds'></span><span id='topic+class_res_nn'></span><span id='topic+class_res_rf'></span><span id='topic+class_folds'></span><span id='topic+log_res_nn'></span><span id='topic+log_res_rf'></span><span id='topic+tree_frogs_reg_test'></span><span id='topic+tree_frogs_class_test'></span>

<h3>Description</h3>

<p>stacks provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_res_svm

reg_res_sp

reg_res_lr

reg_folds

class_res_nn

class_res_rf

class_folds

log_res_nn

log_res_rf
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tune_results</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>tune_results</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>resample_results</code> (inherits from <code>tune_results</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>vfold_cv</code> (inherits from <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 2 columns.
</p>
<p>An object of class <code>resample_results</code> (inherits from <code>tune_results</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>tune_results</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>vfold_cv</code> (inherits from <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 2 columns.
</p>
<p>An object of class <code>resample_results</code> (inherits from <code>tune_results</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>
<p>An object of class <code>tune_results</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 5 rows and 5 columns.
</p>


<h3>Details</h3>

<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>The source code for generating these objects is given below.
</p>
<div class="sourceCode r"><pre># setup: packages, data, resample, basic recipe ------------------------
library(stacks)
library(tune)
library(rsample)
library(parsnip)
library(workflows)
library(recipes)
library(yardstick)
library(workflowsets)

set.seed(1)

ctrl_grid &lt;- 
  tune::control_grid(
    save_pred = TRUE,
    save_workflow = TRUE
  )

ctrl_res &lt;- 
  tune::control_resamples(
    save_pred = TRUE,
    save_workflow = TRUE
  )

# for regression, predict latency to hatch (excluding NAs)
tree_frogs_reg &lt;- 
  tree_frogs %&gt;% 
  filter(!is.na(latency)) %&gt;%
  select(-clutch, -hatched)

set.seed(1)
tree_frogs_reg_split &lt;- rsample::initial_split(tree_frogs_reg)

set.seed(1)
tree_frogs_reg_train &lt;- rsample::training(tree_frogs_reg_split)

set.seed(1)
tree_frogs_reg_test  &lt;- rsample::testing(tree_frogs_reg_split)

set.seed(1)
reg_folds &lt;- rsample::vfold_cv(tree_frogs_reg_train, v = 5)

tree_frogs_reg_rec &lt;- 
  recipes::recipe(latency ~ ., data = tree_frogs_reg_train) %&gt;%
  recipes::step_dummy(recipes::all_nominal()) %&gt;%
  recipes::step_zv(recipes::all_predictors())

metric &lt;- yardstick::metric_set(yardstick::rmse)

# linear regression ---------------------------------------
lin_reg_spec &lt;-
  parsnip::linear_reg() %&gt;%
  parsnip::set_engine("lm")

reg_wf_lr &lt;- 
  workflows::workflow() %&gt;%
  workflows::add_model(lin_reg_spec) %&gt;%
  workflows::add_recipe(tree_frogs_reg_rec)

set.seed(1)
reg_res_lr &lt;- 
  tune::fit_resamples(
    object = reg_wf_lr,
    resamples = reg_folds,
    metrics = metric,
    control = ctrl_res
  )

# SVM regression ----------------------------------
svm_spec &lt;- 
  parsnip::svm_rbf(
    cost = tune::tune(), 
    rbf_sigma = tune::tune()
  ) %&gt;%
  parsnip::set_engine("kernlab") %&gt;%
  parsnip::set_mode("regression")

reg_wf_svm &lt;- 
  workflows::workflow() %&gt;%
  workflows::add_model(svm_spec) %&gt;%
  workflows::add_recipe(tree_frogs_reg_rec)

set.seed(1)
reg_res_svm &lt;- 
  tune::tune_grid(
    object = reg_wf_svm,
    resamples = reg_folds, 
    grid = 5,
    control = ctrl_grid
  )

# spline regression ---------------------------------------
spline_rec &lt;- 
  tree_frogs_reg_rec %&gt;%
  recipes::step_ns(age, deg_free = tune::tune("age"))

reg_wf_sp &lt;- 
  workflows::workflow() %&gt;%
  workflows::add_model(lin_reg_spec) %&gt;%
  workflows::add_recipe(spline_rec)

set.seed(1)
reg_res_sp &lt;- 
  tune::tune_grid(
    object = reg_wf_sp,
    resamples = reg_folds,
    metrics = metric,
    control = ctrl_grid
  )

# classification - preliminaries -----------------------------------
tree_frogs_class &lt;- 
  tree_frogs %&gt;%
  dplyr::select(-c(clutch, latency))

set.seed(1)
tree_frogs_class_split &lt;- rsample::initial_split(tree_frogs_class)

set.seed(1)
tree_frogs_class_train &lt;- rsample::training(tree_frogs_class_split)

set.seed(1)
tree_frogs_class_test  &lt;- rsample::testing(tree_frogs_class_split)

set.seed(1)
class_folds &lt;- rsample::vfold_cv(tree_frogs_class_train, v = 5)

tree_frogs_class_rec &lt;- 
  recipes::recipe(reflex ~ ., data = tree_frogs_class_train) %&gt;%
  recipes::step_dummy(recipes::all_nominal(), -reflex) %&gt;%
  recipes::step_zv(recipes::all_predictors()) %&gt;%
  recipes::step_normalize(recipes::all_numeric())

# random forest classification --------------------------------------
rand_forest_spec &lt;- 
  parsnip::rand_forest(
    mtry = tune::tune(),
    trees = 500,
    min_n = tune::tune()
  ) %&gt;%
  parsnip::set_mode("classification") %&gt;%
  parsnip::set_engine("ranger")

class_wf_rf &lt;-
  workflows::workflow() %&gt;%
  workflows::add_recipe(tree_frogs_class_rec) %&gt;%
  workflows::add_model(rand_forest_spec)

set.seed(1)
class_res_rf &lt;- 
  tune::tune_grid(
    object = class_wf_rf, 
    resamples = class_folds, 
    grid = 10,
    control = ctrl_grid
  )

# neural network classification -------------------------------------
nnet_spec &lt;-
  mlp(hidden_units = 5, penalty = 0.01, epochs = 100) %&gt;%
  set_mode("classification") %&gt;%
  set_engine("nnet")

class_wf_nn &lt;- 
  workflows::workflow() %&gt;%
  workflows::add_recipe(tree_frogs_class_rec) %&gt;%
  workflows::add_model(nnet_spec)

set.seed(1)
class_res_nn &lt;-
  tune::fit_resamples(
    object = class_wf_nn, 
    resamples = class_folds, 
    control = ctrl_res
  )

# binary classification --------------------------------
tree_frogs_2_class_rec &lt;- 
  recipes::recipe(hatched ~ ., data = tree_frogs_class_train) %&gt;%
  recipes::step_dummy(recipes::all_nominal(), -hatched) %&gt;%
  recipes::step_zv(recipes::all_predictors()) %&gt;%
  recipes::step_normalize(recipes::all_numeric())

set.seed(1)
rand_forest_spec_2 &lt;- 
  parsnip::rand_forest(
    mtry = tune(),
    trees = 500,
    min_n = tune()
  ) %&gt;%
  parsnip::set_mode("classification") %&gt;%
  parsnip::set_engine("ranger")

log_wf_rf &lt;-
  workflows::workflow() %&gt;%
  workflows::add_recipe(tree_frogs_2_class_rec) %&gt;%
  workflows::add_model(rand_forest_spec_2)

set.seed(1)
log_res_rf &lt;- 
  tune::tune_grid(
    object = log_wf_rf, 
    resamples = class_folds, 
    grid = 10,
    control = ctrl_grid
  )

nnet_spec_2 &lt;-
  parsnip::mlp(epochs = 100, hidden_units = 5, penalty = 0.1) %&gt;%
  parsnip::set_mode("classification") %&gt;%
  parsnip::set_engine("nnet", verbose = 0)

log_wf_nn &lt;- 
  workflows::workflow() %&gt;%
  workflows::add_recipe(tree_frogs_2_class_rec) %&gt;%
  workflows::add_model(nnet_spec_2)

set.seed(1)
log_res_nn &lt;-
  tune::fit_resamples(
    object = log_wf_nn, 
    resamples = class_folds, 
    control = ctrl_res
  )
</pre></div>


<h3>Source</h3>

<p>Julie Jung et al. (2020) Multimodal mechanosensing enables treefrog
embryos to escape egg-predators. <a href="https://doi.org/10.1242/jeb.236141">doi:10.1242/jeb.236141</a>
</p>

<hr>
<h2 id='fit_members'>Fit model stack members with non-zero stacking coefficients</h2><span id='topic+fit_members'></span>

<h3>Description</h3>

<p>After evaluating a data stack with <code><a href="#topic+blend_predictions">blend_predictions()</a></code>,
some number of candidates will have nonzero stacking
coefficients. Such candidates are referred to as &quot;members.&quot;
Since members' predictions will ultimately inform the model
stack's predictions, members should be trained on the full
training set using <code>fit_members()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_members(model_stack, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_members_+3A_model_stack">model_stack</code></td>
<td>
<p>A <code>model_stack</code> object outputted by <code><a href="#topic+blend_predictions">blend_predictions()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_members_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To fit members in parallel, please create a plan with the future package.
See the documentation of <code><a href="future.html#topic+plan">future::plan()</a></code> for examples.
</p>


<h3>Value</h3>

<p>A <code>model_stack</code> object with a subclass <code>linear_stack</code>&mdash;this fitted
model contains the necessary components to predict on new data.
</p>


<h3>Example Data</h3>

<p>This package provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>See <code>?example_data</code> to learn more about these objects, as well as browse
the source code that generated them.
</p>


<h3>See Also</h3>

<p>Other core verbs: 
<code><a href="#topic+add_candidates">add_candidates</a>()</code>,
<code><a href="#topic+blend_predictions">blend_predictions</a>()</code>,
<code><a href="#topic+stacks">stacks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# see the "Example Data" section above for
# clarification on the objects used in these examples!

# put together a data stack
reg_st &lt;- 
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_svm) %&gt;%
  add_candidates(reg_res_sp)
  
reg_st

# evaluate the data stack and fit the member models
reg_st %&gt;%
  blend_predictions() %&gt;%
  fit_members()
  
reg_st
  
# do the same with multinomial classification models
class_st &lt;-
  stacks() %&gt;%
  add_candidates(class_res_nn) %&gt;%
  add_candidates(class_res_rf) %&gt;%
  blend_predictions() %&gt;%
  fit_members()
  
class_st
  
# ...or binomial classification models
log_st &lt;-
  stacks() %&gt;%
  add_candidates(log_res_nn) %&gt;%
  add_candidates(log_res_rf) %&gt;%
  blend_predictions() %&gt;%
  fit_members()
  
log_st

</code></pre>

<hr>
<h2 id='get_expressions'>Obtain prediction equations for all possible values of type</h2><span id='topic+get_expressions'></span><span id='topic+get_expressions._multnet'></span><span id='topic+get_expressions._lognet'></span><span id='topic+get_expressions._elnet'></span>

<h3>Description</h3>

<p>Obtain prediction equations for all possible values of type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_expressions(x, ...)

## S3 method for class ''_multnet''
get_expressions(x, ...)

## S3 method for class ''_lognet''
get_expressions(x, ...)

## S3 method for class ''_elnet''
get_expressions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_expressions_+3A_x">x</code></td>
<td>
<p>A <code>parsnip</code> model with the <code>glmnet</code> engine.</p>
</td></tr>
<tr><td><code id="get_expressions_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with prediction equations for each possibel type.
</p>

<hr>
<h2 id='predict.data_stack'>Predicting with a model stack</h2><span id='topic+predict.data_stack'></span>

<h3>Description</h3>

<p>The data stack must be evaluated with <code><a href="#topic+blend_predictions">blend_predictions()</a></code> and its member
models fitted with <code><a href="#topic+fit_members">fit_members()</a></code> to predict on new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data_stack'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.data_stack_+3A_object">object</code></td>
<td>
<p>A data stack.</p>
</td></tr>
<tr><td><code id="predict.data_stack_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.model_stack'>Predicting with a model stack</h2><span id='topic+predict.model_stack'></span>

<h3>Description</h3>

<p>Apply a model stack to create different types of predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_stack'
predict(object, new_data, type = NULL, members = FALSE, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.model_stack_+3A_object">object</code></td>
<td>
<p>A model stack with fitted members outputted from <code><a href="#topic+fit_members">fit_members()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.model_stack_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="predict.model_stack_+3A_type">type</code></td>
<td>
<p>Format of returned predicted valuesâ€”one of &quot;numeric&quot;, &quot;class&quot;,
or &quot;prob&quot;. When NULL, <code>predict()</code> will
choose an appropriate value based on the model's mode.</p>
</td></tr>
<tr><td><code id="predict.model_stack_+3A_members">members</code></td>
<td>
<p>Logical. Whether or not to additionally return the predictions
for each of the ensemble members.</p>
</td></tr>
<tr><td><code id="predict.model_stack_+3A_opts">opts</code></td>
<td>
<p>A list of optional arguments to the underlying predict
function passed on to <a href="parsnip.html#topic+predict.model_fit">parsnip::predict.model_fit</a> for each member.</p>
</td></tr>
<tr><td><code id="predict.model_stack_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Example Data</h3>

<p>This package provides some resampling objects and datasets for use in examples
and vignettes derived from a study on 1212 red-eyed tree frog embryos!
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal
7ish days if they detect potential predator threat. Researchers wanted
to determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos
were treated with gentamicin, a compound that knocks out their lateral
line (a sensory organ.) Researcher Julie Jung and her crew found that
these factors inform whether an embryo hatches prematurely or not!
</p>
<p>Note that the data included with the stacks package is not necessarily
a representative or unbiased subset of the complete dataset, and is
only for demonstrative purposes.
</p>
<p><code>reg_folds</code> and <code>class_folds</code> are <code>rset</code> cross-fold validation objects
from <code>rsample</code>, splitting the training data into for the regression
and classification model objects, respectively. <code>tree_frogs_reg_test</code> and
<code>tree_frogs_class_test</code> are the analogous testing sets.
</p>
<p><code>reg_res_lr</code>, <code>reg_res_svm</code>, and <code>reg_res_sp</code> contain regression tuning results
for a linear regression, support vector machine, and spline model, respectively,
fitting <code>latency</code> (i.e. how long the embryos took to hatch in response
to the jiggle) in the <code>tree_frogs</code> data, using most all of the other
variables as predictors. Note that the data underlying these models is
filtered to include data only from embryos that hatched in response to
the stimulus.
</p>
<p><code>class_res_rf</code> and <code>class_res_nn</code> contain multiclass classification tuning
results for a random forest and neural network classification model,
respectively, fitting <code>reflex</code> (a measure of ear function) in the
data using most all of the other variables as predictors.
</p>
<p><code>log_res_rf</code> and <code>log_res_nn</code>, contain binary classification tuning results
for a random forest and neural network classification model, respectively,
fitting <code>hatched</code> (whether or not the embryos hatched in response
to the stimulus) using most all of the other variables as predictors.
</p>
<p>See <code>?example_data</code> to learn more about these objects, as well as browse
the source code that generated them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# see the "Example Data" section above for
# clarification on the data and tuning results
# objects used in these examples!

data(tree_frogs_reg_test)
data(tree_frogs_class_test)

# build and fit a regression model stack
reg_st &lt;-
  stacks() %&gt;%
  add_candidates(reg_res_lr) %&gt;%
  add_candidates(reg_res_sp) %&gt;%
  blend_predictions() %&gt;%
  fit_members()

reg_st

# predict on the tree frogs testing data
predict(reg_st, tree_frogs_reg_test)

# include the predictions from the members
predict(reg_st, tree_frogs_reg_test, members = TRUE)

# build and fit a classification model stack
class_st &lt;-
  stacks() %&gt;%
  add_candidates(class_res_nn) %&gt;%
  add_candidates(class_res_rf) %&gt;%
  blend_predictions() %&gt;%
  fit_members()
 
class_st

# predict reflex, first as a class, then as
# class probabilities
predict(class_st, tree_frogs_class_test)
predict(class_st, tree_frogs_class_test, type = "prob")

# returning the member predictions as well
predict(
  class_st, 
  tree_frogs_class_test, 
  type = "prob", 
  members = TRUE
)

</code></pre>

<hr>
<h2 id='prediction_eqn'>Convert one or more linear predictor to a format used for prediction</h2><span id='topic+prediction_eqn'></span><span id='topic+prediction_eqn._lognet'></span><span id='topic+prediction_eqn._elnet'></span><span id='topic+prediction_eqn._multnet'></span>

<h3>Description</h3>

<p>Convert one or more linear predictor to a format used for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction_eqn(x, ...)

## S3 method for class ''_lognet''
prediction_eqn(x, type = "class", ...)

## S3 method for class ''_elnet''
prediction_eqn(x, type = "numeric", ...)

## S3 method for class ''_multnet''
prediction_eqn(x, type = "class", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction_eqn_+3A_x">x</code></td>
<td>
<p>An object that uses a <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> model and all numeric predictors.</p>
</td></tr>
<tr><td><code id="prediction_eqn_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="prediction_eqn_+3A_type">type</code></td>
<td>
<p>The prediction type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return type varies, based on the model and prediction type.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+butcher'></span><span id='topic+axe_call'></span><span id='topic+axe_ctrl'></span><span id='topic+axe_data'></span><span id='topic+axe_env'></span><span id='topic+axe_fitted'></span><span id='topic+autoplot'></span><span id='topic+augment'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>butcher</dt><dd><p><code><a href="butcher.html#topic+axe_call">axe_call</a></code>, <code><a href="butcher.html#topic+axe_ctrl">axe_ctrl</a></code>, <code><a href="butcher.html#topic+axe_data">axe_data</a></code>, <code><a href="butcher.html#topic+axe_env">axe_env</a></code>, <code><a href="butcher.html#topic+axe_fitted">axe_fitted</a></code>, <code><a href="butcher.html#topic+butcher">butcher</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='stack_predict'>Convert one or more linear predictor to a format used for prediction</h2><span id='topic+stack_predict'></span><span id='topic+stack_predict.elnet_numeric'></span><span id='topic+stack_predict.lognet_class'></span><span id='topic+stack_predict.lognet_prob'></span><span id='topic+stack_predict.multnet_class'></span><span id='topic+stack_predict.multnet_prob'></span>

<h3>Description</h3>

<p>Convert one or more linear predictor to a format used for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_predict(x, ...)

## S3 method for class 'elnet_numeric'
stack_predict(x, data, ...)

## S3 method for class 'lognet_class'
stack_predict(x, data, ...)

## S3 method for class 'lognet_prob'
stack_predict(x, data, ...)

## S3 method for class 'multnet_class'
stack_predict(x, data, ...)

## S3 method for class 'multnet_prob'
stack_predict(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_predict_+3A_x">x</code></td>
<td>
<p>A set of model expressions generated by <code><a href="#topic+prediction_eqn">prediction_eqn()</a></code>.</p>
</td></tr>
<tr><td><code id="stack_predict_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return type varies, based on the model and prediction type.
</p>

<hr>
<h2 id='stacks'>Initialize a Stack</h2><span id='topic+stacks'></span>

<h3>Description</h3>

<p>The <code>stacks()</code> function initializes a <code>data_stack</code> object. Principally,
<code>data_stack</code>s are tibbles, where the first column gives
the true outcome in the assessment set, and the remaining
columns give the predictions from each candidate ensemble
member. (When the outcome is numeric, thereâ€™s only one column per candidate
member. For classification, there are as many columns per candidate
member as there are levels in the outcome variable minus 1.) They also bring
along a few extra attributes to keep track of model definitions, resamples,
and training data.
</p>
<p>See <code>?stacks_description</code> for more discussion of the package, generally,
and the <code>basics</code> vignette for a detailed walk-through of functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stacks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stacks_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data_stack</code> object.
</p>


<h3>See Also</h3>

<p>Other core verbs: 
<code><a href="#topic+add_candidates">add_candidates</a>()</code>,
<code><a href="#topic+blend_predictions">blend_predictions</a>()</code>,
<code><a href="#topic+fit_members">fit_members</a>()</code>
</p>

<hr>
<h2 id='tree_frogs'>Tree frog embryo hatching data</h2><span id='topic+tree_frogs'></span>

<h3>Description</h3>

<p>A dataset containing experimental results on hatching behavior of
red-eyed tree frog embryos.
</p>
<p>Red-eyed tree frog (RETF) embryos can hatch earlier than their normal 7ish
days if they detect potential predator threat. Researchers wanted to
determine how, and when, these tree frog embryos were able to detect
stimulus from their environment. To do so, they subjected the embryos
at varying developmental stages to &quot;predator stimulus&quot; by jiggling
the embryos with a blunt probe. Beforehand, though some of the embryos were
treated with gentamicin, a compound that knocks out their lateral line
(a sensory organ.) Researcher Julie Jung and her crew found that these
factors inform whether an embryo hatches prematurely or not!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_frogs
</code></pre>


<h3>Format</h3>

<p>A data frame with 1212 rows and 6 variables:
</p>

<dl>
<dt>clutch</dt><dd><p>RETFs lay their eggs in gelatinous &quot;clutches&quot; of 30-40
eggs. Eggs with the same clutch ID are siblings of each other! This
variable is useful in mixed effects models. (Unordered factor.)</p>
</dd>
<dt>treatment</dt><dd><p>The treatment group for the embryo. Either &quot;gentamicin&quot;,
a compound that knocks out the embryos' lateral line, or &quot;control&quot; for
the negative control group (i.e. sensory organs intact). (Character.)</p>
</dd>
<dt>reflex</dt><dd><p>A measure of ear function called the vestibulo-ocular
reflex, categorized into bins. Ear function increases from factor
levels &quot;low&quot;, to &quot;mid&quot;, to &quot;full&quot;. (Ordered factor.)</p>
</dd>
<dt>age</dt><dd><p>Age of the embryo, in seconds, at the time
that the embryo was jiggled. (Numeric, in seconds.)</p>
</dd>
<dt>t_o_d</dt><dd><p>The time of day that the stimulus (i.e. jiggle)
was applied. &quot;morning&quot; is 5 a.m. to noon, &quot;afternoon&quot; is noon to 8 p.m., and
&quot;night&quot; is 8 p.m. to 5 a.m. (Character.)</p>
</dd>
<dt>hatched</dt><dd><p>Whether or not the embryo hatched in response to the
jiggling! Either &quot;yes&quot; or &quot;no&quot;. (Character.)</p>
</dd>
<dt>latency</dt><dd><p>Time elapsed between the stimulus (i.e. jiggling)
and hatching in response to the stimulus, in seconds. Missing values indicate
that the embryo didn't hatch in response to the stimulus. (Numeric,
in seconds.)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note that the data included with the <code>stacks</code> package is not necessarily
a representative or unbiased subset of the complete dataset, and is only
for demonstrative purposes.
</p>


<h3>Source</h3>

<p>Julie Jung et al. (2020) Multimodal mechanosensing enables treefrog
embryos to escape egg-predators. <a href="https://doi.org/10.1242/jeb.236141">doi:10.1242/jeb.236141</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
