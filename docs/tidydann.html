<!DOCTYPE html><html><head><title>Help for package tidydann</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidydann}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#matrix_diagonal'><p>Softening</p></a></li>
<li><a href='#nearest_neighbor_adaptive'><p>Discriminant Adaptive Nearest Neighbor Classification</p></a></li>
<li><a href='#neighborhood'><p>Neighborhood size</p></a></li>
<li><a href='#sphere'><p>Sphere argument to ncoord</p></a></li>
<li><a href='#tunable.nearest_neighbor_adaptive'><p>Declare tunable parameters</p></a></li>
<li><a href='#update.nearest_neighbor_adaptive'><p>Updating a model specification.</p></a></li>
<li><a href='#weighted'><p>Weighted argument to ncoord</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Add the 'dann' Model and the 'sub_dann' Model to the Tidymodels
Ecosystem</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides model specifications, tuning parameters for models in 
    'dann' package. Models based on Hastie (1996) 
    <a href="https://web.stanford.edu/~hastie/Papers/dann_IEEE.pdf">https://web.stanford.edu/~hastie/Papers/dann_IEEE.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), dann (&ge; 1.0.0), recipes, mlbench,
modeldata, workflows, rsample, dplyr, magrittr, tune, scales,
yardstick, rlang</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dials, generics, tibble, parsnip</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 03:52:13 UTC; gmcma</td>
</tr>
<tr>
<td>Author:</td>
<td>Greg McMahan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Greg McMahan &lt;gmcmacran@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='matrix_diagonal'>Softening</h2><span id='topic+matrix_diagonal'></span>

<h3>Description</h3>

<p>Softening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_diagonal(range = c(0, 2), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_diagonal_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the defaults for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the transformed units.</p>
</td></tr>
<tr><td><code id="matrix_diagonal_+3A_trans">trans</code></td>
<td>
<p>A trans object from the scales package, such as
scales::log10_trans() or scales::reciprocal_trans().If not provided, the
default is used which matches the units used in range. If no transformation,
NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Softening parameter. Usually has the least affect on performance.
</p>


<h3>Value</h3>

<p>An S3 class of type quant_param from the dials package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidydann)

matrix_diagonal()
</code></pre>

<hr>
<h2 id='nearest_neighbor_adaptive'>Discriminant Adaptive Nearest Neighbor Classification</h2><span id='topic+nearest_neighbor_adaptive'></span>

<h3>Description</h3>

<p>Discriminant Adaptive Nearest Neighbor Classification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_neighbor_adaptive(
  mode = "classification",
  neighbors = NULL,
  neighborhood = NULL,
  matrix_diagonal = NULL,
  weighted = NULL,
  sphere = NULL,
  num_comp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_neighbor_adaptive_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model. The only
possible value for this model is &quot;classification&quot;.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of data points used for final classification.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The number of data points used to calculate between and
within class covariance.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_matrix_diagonal">matrix_diagonal</code></td>
<td>
<p>Diagonal elements of a diagonal matrix. 1 is the
identity
matrix.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_weighted">weighted</code></td>
<td>
<p>weighted argument to ncoord. See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code> for details.
Only sub_dann engine.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_sphere">sphere</code></td>
<td>
<p>One of &quot;mcd&quot;, &quot;mve&quot;, &quot;classical&quot;, or &quot;none&quot; See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code>
for details. Only sub_dann engine.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_adaptive_+3A_num_comp">num_comp</code></td>
<td>
<p>Dimension of subspace used by dann. See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code> for
details. Only sub_dann engine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discriminant Adaptive Nearest Neighbor (dann) is a variation of k nearest
neighbors where the shape of the neighborhood is data driven. The
neighborhood is elongated along class boundaries and shrunk in the orthogonal
direction.
</p>
<p>This function has engines dann and sub_dann.
</p>


<h3>Value</h3>

<p>An S3 class of type nearest_neighbor_adaptive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(parsnip)
library(tidydann)

data("two_class_dat", package = "modeldata")

model &lt;- nearest_neighbor_adaptive(neighbors = 2) |&gt;
  set_engine("dann") |&gt;
  fit(formula = Class ~ A + B, data = two_class_dat)

model |&gt;
  predict(new_data = two_class_dat)

</code></pre>

<hr>
<h2 id='neighborhood'>Neighborhood size</h2><span id='topic+neighborhood'></span>

<h3>Description</h3>

<p>Number of data points used to calculate the shape of the
neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood(range = c(2L, dials::unknown()), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhood_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the defaults for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the transformed units.</p>
</td></tr>
<tr><td><code id="neighborhood_+3A_trans">trans</code></td>
<td>
<p>A trans object from the scales package, such as
scales::log10_trans() or scales::reciprocal_trans().If not provided, the
default is used which matches the units used in range. If no transformation,
NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use get_n or finalize from dials to finalize.
</p>
<p>If cross validation is done, use get_n_frac with argument frac set to 1/V.
See README for detailed example.
</p>


<h3>Value</h3>

<p>An S3 class of type quant_param from the dials package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dials)
library(tidydann)

data("taxi", package = "modeldata")
neighborhood() |&gt; finalize(taxi)

neighborhood() |&gt; get_n(taxi)
</code></pre>

<hr>
<h2 id='sphere'>Sphere argument to ncoord</h2><span id='topic+sphere'></span>

<h3>Description</h3>

<p>Sphere argument to ncoord
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere(values = c("mcd", "mve", "classical", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_+3A_values">values</code></td>
<td>
<p>A one-element vector containing &quot;mcd&quot;, &quot;mve&quot;, &quot;classical&quot;,
or &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type qual_param from the dials package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidydann)

sphere()
</code></pre>

<hr>
<h2 id='tunable.nearest_neighbor_adaptive'>Declare tunable parameters</h2><span id='topic+tunable.nearest_neighbor_adaptive'></span>

<h3>Description</h3>

<p>Returns information on potential hyper-parameters that can be
optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nearest_neighbor_adaptive'
tunable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tunable.nearest_neighbor_adaptive_+3A_x">x</code></td>
<td>
<p>A model specification of type nearest_neighbor_adaptive
specification.</p>
</td></tr>
<tr><td><code id="tunable.nearest_neighbor_adaptive_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a column for the parameter name, information on the
default method for generating a corresponding parameter object, the source of
the parameter (e.g. &quot;recipe&quot;, etc.), and the component within the source.
</p>

<hr>
<h2 id='update.nearest_neighbor_adaptive'>Updating a model specification.</h2><span id='topic+update.nearest_neighbor_adaptive'></span>

<h3>Description</h3>

<p>If parameters of a model specification need to be modified,
update() can be used in lieu of recreating the object from scratch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nearest_neighbor_adaptive'
update(
  object,
  parameters = NULL,
  neighbors = NULL,
  neighborhood = NULL,
  matrix_diagonal = NULL,
  weighted = NULL,
  sphere = NULL,
  num_comp = NULL,
  fresh = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_object">object</code></td>
<td>
<p>A model specification.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_parameters">parameters</code></td>
<td>
<p>A 1-row tibble or named list with main parameters to
update. Use either parameters or the main arguments directly when updating.
If the main arguments are used, these will supersede the values in
parameters. Also, using engine arguments in this object will result in an
error.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of data points used for final classification.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The number of data points used to calculate between and
within class covariance.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_matrix_diagonal">matrix_diagonal</code></td>
<td>
<p>Diagonal elements of a diagonal matrix. 1 is the
identity
matrix.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_weighted">weighted</code></td>
<td>
<p>weighted argument to ncoord. See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code> for details.
Only sub_dann engine.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_sphere">sphere</code></td>
<td>
<p>One of &quot;mcd&quot;, &quot;mve&quot;, &quot;classical&quot;, or &quot;none&quot; See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code>
for details. Only sub_dann engine.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_num_comp">num_comp</code></td>
<td>
<p>Dimension of subspace used by dann. See <code><a href="fpc.html#topic+ncoord">fpc::ncoord()</a></code> for
details. Only sub_dann engine.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_fresh">fresh</code></td>
<td>
<p>A logical for whether the arguments should be modified in-place
or replaced wholesale.</p>
</td></tr>
<tr><td><code id="update.nearest_neighbor_adaptive_+3A_...">...</code></td>
<td>
<p>Not used for update().</p>
</td></tr>
</table>

<hr>
<h2 id='weighted'>Weighted argument to ncoord</h2><span id='topic+weighted'></span>

<h3>Description</h3>

<p>Weighted argument to ncoord
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted(values = c(FALSE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_+3A_values">values</code></td>
<td>
<p>A one-element vector containing FALSE or TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type qual_param from the dials package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidydann)

weighted()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
