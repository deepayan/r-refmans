<!DOCTYPE html><html lang="en"><head><title>Help for package MPTmultiverse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MPTmultiverse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_results'><p>Check results from MPTmultiverse</p></a></li>
<li><a href='#fit_mpt'><p>Multiverse Analysis for MPT Models</p></a></li>
<li><a href='#get_info'><p>Collect Model Equations and Data per Tree</p></a></li>
<li><a href='#get_pb_output'><p>Parametric Bootstrap for MPT</p></a></li>
<li><a href='#mpt_options'><p>Options Settings for MPT Comparison</p></a></li>
<li><a href='#plot.multiverseMPT'><p>Plot multiverseMPT</p></a></li>
<li><a href='#write_results'><p>Write Results of Multiverse Analysis to csv-Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multiverse Analysis of Multinomial Processing Tree Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-2</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Statistical or cognitive modeling usually requires a number of more or less 
    arbitrary choices creating one specific path through a 'garden of forking paths'. 
    The multiverse approach (Steegen, Tuerlinckx, Gelman, &amp; Vanpaemel, 2016, 
    &lt;<a href="https://doi.org/10.1177%2F1745691616658637">doi:10.1177/1745691616658637</a>&gt;) offers a principled alternative in which results 
    for all possible combinations of reasonable modeling choices are reported. 
    MPTmultiverse performs a multiverse analysis for multinomial processing tree 
    (MPT, Riefer &amp; Batchelder, 1988, &lt;<a href="https://doi.org/10.1037%2F0033-295X.95.3.318">doi:10.1037/0033-295X.95.3.318</a>&gt;) models combining 
    maximum-likelihood/frequentist and Bayesian estimation approaches with 
    different levels of pooling (i.e., data aggregation). For the 
    frequentist approaches, no pooling (with and without parametric or nonparametric 
    bootstrap) and complete pooling are implemented using 
    MPTinR <a href="https://cran.r-project.org/package=MPTinR">https://cran.r-project.org/package=MPTinR</a>. 
    For the Bayesian approaches, no pooling, complete pooling, and three different 
    variants of partial pooling are implemented using 
    TreeBUGS <a href="https://cran.r-project.org/package=TreeBUGS">https://cran.r-project.org/package=TreeBUGS</a>. The main function is 
    fit_mpt() who performs the multiverse analysis in one call.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mpt-network/MPTmultiverse">https://github.com/mpt-network/MPTmultiverse</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mpt-network/MPTmultiverse/issues">https://github.com/mpt-network/MPTmultiverse/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.11.1),</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, magrittr, tidyr, dplyr, tibble, rlang, reshape2,
ggplot2, MPTinR, TreeBUGS (&ge; 1.4.4), runjags, coda, purrr,
readr, limSolve, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-23 15:26:12 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Daniel W. Heck [aut],
  Marius Barth <a href="https://orcid.org/0000-0002-3421-6665"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Frederik Aust <a href="https://orcid.org/0000-0003-4900-788X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Singmann &lt;singmann@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-24 09:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_results'>Check results from MPTmultiverse</h2><span id='topic+check_results'></span><span id='topic+write_check_results'></span><span id='topic+check_set'></span>

<h3>Description</h3>

<p>Set of helper functions that allow checking if model estimation
worked as intended. Depending on the method and function, these functions
return slightly different information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_results(results)

write_check_results(DATA_FILE, results, append = FALSE)

check_set(results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_results_+3A_results">results</code></td>
<td>
<p>An object of class multiverseMPT.</p>
</td></tr>
<tr><td><code id="check_results_+3A_data_file">DATA_FILE</code></td>
<td>
<p>character string. File name to use.</p>
</td></tr>
<tr><td><code id="check_results_+3A_append">append</code></td>
<td>
<p>logical. If <code>TRUE</code>, output will be appended to
<code>DATA_FILE</code>; otherwise, it will overwrite the contents of
<code>DATA_FILE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check_results</code> prints relatively verbose output detailing
diagnostic information for each method to the console. For the frequentist
methods, this is based on either the rank of the observed Fischer (or
Hessian) matrix of the MLE estimate or based on empirical identifiability
(based either on repeated re-runs or the width of the bootstrapped
parameter distribution). For the Bayesian methods, this is convergence
statistics R-hat and number of effective samples.
<code>write_check_results</code> writes the results of <code>check_results</code> to a
specififed file (instead of printing it to the console).
</p>
<p><code>check_set</code> returns a <code>tibble</code> with one row, where each expected
method corresponds to a column with a boolean (<code>TRUE</code>/<code>FALSE</code>)
value. Entries <code>TRUE</code> correspond to no problem and <code>FALSE</code>
correspond to problems. <code>FALSE</code> means the method is either missing
from the results file or (for the Bayesian methods) there are core
parameters for which the convergence criteria defined in
<code>getOption("MPTmultiverse")</code> are not met.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(file = system.file("extdata", "results_bayen_kuhlmann.RData",
                        package = "MPTmultiverse"))
## prints checks to console
check_results(results)

## returns tibble with single row
check_set(results)
</code></pre>

<hr>
<h2 id='fit_mpt'>Multiverse Analysis for MPT Models</h2><span id='topic+fit_mpt'></span>

<h3>Description</h3>

<p>Performs a multiverse analysis for multinomial processing tree (MPT) models
across different levels of pooling (i.e., data aggregation) and across
maximum-likelihood/frequentist and Bayesian estimation approaches. For the
frequentist approaches, no pooling (with and without parametric or
nonparametric bootstrap) and complete pooling  are implemented using
<span class="pkg">MPTinR</span>. For the Bayesian approaches, no pooling, complete pooling, and
three different variants of partial pooling are implemented using
<span class="pkg">TreeBUGS</span>. Requires <code>data</code> on a by-participant level with each row
corresponding to data from one participant (i.e., different response
categories correspond to different columns) and the data can contain a single
between-subjects condition. Model equations need to be passed as a
<code>.eqn</code> model file and category labels (first column in <code>.eqn</code> file)
need to match the column names in <code>data</code>. Results are returned in one
<code>tibble</code> with one row per estimation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mpt(model, dataset, data, id = NULL, condition = NULL, core = NULL, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_mpt_+3A_model">model</code></td>
<td>
<p>A model definition, typically the path to an <code>.eqn</code> model
file containing the model equations. Category names need to match column
names in <code>data</code>.</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_dataset">dataset</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the data set that will
be copied to the results <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data. Column
names need to match category names in <code>model</code> (i.e., different from
<span class="pkg">MPTinR</span> behavior, order of categories is not important, matching is
done via name).</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_id">id</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the column that contains
the subject identifier. If not specified, it is assumed that each row
represents observations from one participant.</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_condition">condition</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the column
specifying a between-subjects factor. If not specified, no between-subjects
comparisons are performed.</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_core">core</code></td>
<td>
<p><code>character</code> vector defining the core parameters of interest,
e.g., <code>core = c("Dn", "Do")</code>. All other parameters are treated as
auxiliary parameters.</p>
</td></tr>
<tr><td><code id="fit_mpt_+3A_method">method</code></td>
<td>
<p><code>character</code> vector specifying which analysis approaches
should be performed (see Description below). Defaults to all available
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is a fancy wrapper for packages <span class="pkg">MPTinR</span> and
<span class="pkg">TreeBUGS</span> applying various frequentist and Bayesian estimation methods
to the same data set with different levels of pooling/aggregation using a
single MPT model and collecting the results in one <code>tibble</code> where each
row corresponds to one estimation method. Note that parameter restrictions
(e.g., equating different parameters or fixing them to a constant) need to
be part of the model (i.e., the <code>.eqn</code> file) and cannot be passed as
an argument.
</p>
<p>The settings for the various methods are specified via function
<code><a href="#topic+mpt_options">mpt_options</a></code>. The default settings use all available cores for
calculating the boostrap distribution as well as independent MCMC chains
and should be appropriate for most situations.
</p>
<p>The data can have a single between-subjects condition (specified via
<code>condition</code>). This condition can have more than two levels. If
specified, the pairwise differences between each level, the standard error
of the differences, and confidence-intervals of the differences are
calculated for each parameter. Please note that <code>condition</code> is
silently converted to <code>character</code> in the output. Thus, a specific
ordering of the <code>factor</code> levels in the output cannot be guaranteed. If
the data has more than one between-subjects condition, these need to be
combined into one condition for this function.
</p>
<p>To include multiple within-subjects conditions, include separate trees and
separate sets of parameters for each within-subjects condition in your
.eqn file.
</p>


<h4>Pooling</h4>

<p>The following pooling levels are provided (not all by all estimation approaches, see below).
</p>

<ul>
<li><p><em>Complete pooling:</em> The traditional analysis approach in the MPT
literature in which data is aggregated across participants within each
between-subjects condition. This approach assumes that there are no
individual-dfferences. Produces one set of model parameters per condition.
</p>
</li>
<li><p><em>No pooling:</em> The model is fitted to the individual-level data in
an independent manner (i.e., no data aggregation). This approach
assumes that there is no similarity across participants and usually
requires considerable amounts of data on the individual-level. Produces
one set of model parameters per participant. Group-level estimates are
based on averaging the individual-level estimates.
</p>
</li>
<li><p><em>Partial pooling:</em> Data is fitted simultaneously to the
individual-level data assuming that the individual-level parameters come
from a group-level distribution. Individual-level parameters are often
treated as random-effects which are nested in the group-level parameters,
which is why this approach is also called hierarchical modeling. This
approach assumes both individual-level differences and similarities.
Produces one set of model parameters per participant plus one set of
group-level parameters. Thus, although partial pooling models usually
have more parameters than the no-pooling approaches, they are usually
less flexible as the hierarchical-structure provides regularization of
the individual-level parameters. 
</p>
</li></ul>




<h4>Implemented Estimation Methods</h4>

<p>Maximum-likelihood estimation with <span class="pkg">MPTinR</span> via
<code><a href="MPTinR.html#topic+fit.mpt">fit.mpt</a></code>:
</p>

<ul>
<li><p><code>"asymptotic_complete"</code>: Asymptotic ML theory, complete
pooling
</p>
</li>
<li><p><code>"asymptotic_no"</code>:  Asymptotic ML theory, no pooling
</p>
</li>
<li><p><code>"pb_no"</code>: Parametric bootstrap, no pooling
</p>
</li>
<li><p><code>"npb_no"</code>: Nonparametric bootstrap, no pooling
</p>
</li></ul>

<p>Bayesian estimation with <span class="pkg">TreeBUGS</span>
</p>

<ul>
<li><p><code>"simple"</code>: Bayesian estimation, no pooling (C++,
<a href="TreeBUGS.html#topic+simpleMPT">simpleMPT</a>)
</p>
</li>
<li><p><code>"simple_pooling"</code>: Bayesian estimation, complete pooling
(C++, <a href="TreeBUGS.html#topic+simpleMPT">simpleMPT</a>)
</p>
</li>
<li><p><code>"trait"</code>: latent-trait model, partial pooling (JAGS,
<a href="TreeBUGS.html#topic+traitMPT">traitMPT</a>)
</p>
</li>
<li><p><code>"trait_uncorrelated"</code>: latent-trait model without
correlation parameters, partial pooling (JAGS,
<a href="TreeBUGS.html#topic+traitMPT">traitMPT</a>)
</p>
</li>
<li><p><code>"beta"</code>: beta-MPT model, partial pooling (JAGS,
<a href="TreeBUGS.html#topic+betaMPT">betaMPT</a>)
</p>
</li>
<li><p><code>"betacpp"</code>: beta-MPT model, partial pooling (C++,
<a href="TreeBUGS.html#topic+betaMPTcpp">betaMPTcpp</a>)
</p>
</li></ul>




<h4>Frequentist/Maximum-Likelihood Methods</h4>

<p>For the <em>complete pooling asymptotic approach</em>, the group-level parameter
estimates and goodness-of-fit statistics are the maximum-likelihood and
G-squared values returned by <code>MPTinR</code>. The parameter differences are
based on these values. for between-subjects comparisons, the standard
errors of the differences are simply the pooled standard error of the
individual parameters; for within-subjects comparisons, the standard errors
of the differences are based on the respective linear transform of the estimated
variance-covariance matrix calculated from the Hessian matrix. The overall fit
(column <code>gof</code>) is based on an additional fit to the completely
aggregated data.
</p>
<p>For the <em>no pooling asymptotic approach</em>, the individual-level
maximum-likelihood estimates are reported in column <code>est_indiv</code> and
<code>gof_indiv</code> and provide the basis for the other results. Whether or
not an individual-level parameter estimate is judged as identifiable
(column <code>identifiable</code>) is based on separate fits with different
random starting values. If, in these separate, fits the same objective
criterion is reached several times (i.e., <code>Log.Likelihood</code> within
.01 of best fit), but the parameter estimate differs (i.e., different
estimates within .01 of each other), then an estimate is flagged as
non-identifiable. If they are the same (i.e., within .01 of each other)
they are marked as identifiable. The group-level parameters are simply
the means of the identifiable individual-level parameters, the SE is the
SE of the mean for these parameter (i.e., SD/sqrt(N), where N excludes
non-identifiable parameters and thise estimated as NA), and the CI is
based on mean and SE. The group-level and overall fit is the sum of the
individual G-squares, sum of individual-level df, and corresponding
chi-square df. The difference between the conditions and corresponding
statistics are based on a t-test comparing the individual-level estimates
(again, after excluding non-identifiable estimates). The CIs of the
difference are based on the SEs (which are derived from a linear model
equivalent to the t-test). Within-subjects comparisons are based on t-tests
for paired observations.
</p>
<p>The individual-level estimates of the <code>bootstrap based no-pooling</code>
approaches are identical to the asymptotic ones. However, the SE is the
SD of the bootstrapped distribution of parameter estimates, the CIs are
the corresponding quantiles of the bootstrapped distribution, and the
p-value is obtained from the bootstrapped G-square distribution.
Identifiability of individual-level parameter estimates is also based on
the bootstrap distribution of estimates. Specifically, we calculate the
range of the CI (i.e., maximum minus minimum CI value) and flag those
parameters as non-identifiable for which the range is larger than
<code>mpt_options()$max_ci_indiv</code>, which defaults to <code>0.99</code>. Thus,
in the default settings we say a parameter is non-identifiable if the
bootstrap based CI extends from 0 to 1. The group-level estimates are the
mean of the identifiable individual-level estimates. The difference
between conditions (as well as within conditions) is calculated in the same manner as for the asymptotic
case using the identifiable individual-level parameter estimates.
</p>



<h4>Bayesian Methods</h4>

<p>The <em>simple approaches</em> fit fixed-effects MPT models.
<code>"simple"</code> uses no pooling and thus assumes independent uniform priors
for the individual-level parameters. Group-level means are
obtained as generated quantities by averaging the posterior samples
across participants. <code>"simple_pooling"</code> aggregates observed
frequencies across participants and assumes a uniform prior for the
group-level parameters.
</p>
<p>The <em>latent-trait approaches</em> transform the individual-level
parameters to a latent probit scale using the inverse cumulative standard
normal distribution. For these probit values, a multivariate normal
distribution is assumed at the group level. Whereas <code>"trait"</code>
estimates the corresponding correlation matrix of the parameters
(reported in the column <code>est_rho</code>), <code>"trait_uncorrelated"</code> does
not estimate this correlation matrix (i.e., parameters can still be
correlated across individuals, but this is not accounted for in the
model).
</p>
<p>For all Bayesian methods, the posterior distribution of the parameters is
summarized by the posterior mean (in the column <code>est</code>), posterior
standard deviation (<code>se</code>), and credbility intervals (<code>ci_*</code>).
For parameter differences (<code>test_between</code> and <code>test_within</code>) and correlations
(<code>est_rho</code>), Bayesian p-values are computed (column <code>p</code>) by
counting the relative proportion of posterior samples that are smaller
than zero. Goodness of fit is tested with the T1 statistic
(observed vs. posterior-predicted average frequencies, <code>focus =
    "mean"</code>) and the T2 statistic (observed vs. posterior-predicted
covariance of frequencies, <code>focus = "cov"</code>).
</p>



<h3>Value</h3>

<p>A <code>tibble</code> with one row per estimation <code>method</code> and the
following columns:
</p>

<ol>
<li> <p><code>model</code>: Name of model file (copied from <code>model</code> argument),
<code>character</code>
</p>
</li>
<li> <p><code>dataset</code>: Name of data set (copied from <code>dataset</code>
argument), <code>character</code>
</p>
</li>
<li> <p><code>pooling</code>: <code>character</code> specifying the level of pooling with
three potential values: <code>c("complete", "no", "partial")</code>
</p>
</li>
<li> <p><code>package</code>: <code>character</code> specifying the package used for
estimation with two potential values: <code>c("MPTinR", "TreeBUGS")</code>
</p>
</li>
<li> <p><code>method</code>: <code>character</code> specifying the method used with the
following potential values: <code>c("asymptotic", "PB/MLE", "NPB/MLE",
  "simple", "trait", "trait_uncorrelated", "beta", "betacpp")</code>
</p>
</li>
<li> <p><code>est_group</code>: Group-level parameter estimates per condition/group.
</p>
</li>
<li> <p><code>est_indiv</code>: Individual-level parameter estimates (if provided
by method).
</p>
</li>
<li> <p><code>est_rho</code>: Estimated correlation of individual-level parameters
on the probit scale (only in <code>method="trait"</code>).
</p>
</li>
<li> <p><code>test_between</code>: Parameter differences between the levels of the
between-subjects condition (if specified).
</p>
</li>
<li> <p><code>test_within</code>: Within-subjects parameter differences.
</p>
</li>
<li> <p><code>gof</code>: Overall goodness of fit across all individuals.
</p>
</li>
<li> <p><code>gof_group</code>: Group-level goodness of fit.
</p>
</li>
<li> <p><code>gof_indiv</code>: Individual-level goodness of fit.
</p>
</li>
<li> <p><code>fungibility</code>:  Posterior correlation of the group-level means
<code>pnorm(mu)</code> (only in <code>method="trait"</code>).
</p>
</li>
<li> <p><code>test_homogeneity</code>: Chi-square based test of participant
homogeneity proposed by Smith and Batchelder (2008). This test is the same
for each estimation method.
</p>
</li>
<li> <p><code>convergence</code>: Convergence information provided by the
respective estimation method. For the asymptotic frequentist methods this
is a <code>tibble</code> with rank of the Fisher matrix, the number of parameters
(which should match the rank of the Fisgher matrix), and the convergence
code provided by the optimization algorithm (which is
<code><a href="stats.html#topic+nlminb">nlminb</a></code>). The boostrap methods contain an additional column,
<code>parameter</code>, that contains the information which (if any) parameters
are empirically non-identifiable based on the bootstrapped distribution of
parameter estimates (see above for exact description). For the Bayesian
methods this is a <code>tibble</code> containing information of the posterior
dsitribution (i.e., mean, quantiles, SD, SE, <code>n.eff</code>, and R-hat) for
each parameter.
</p>
</li>
<li> <p><code>estimation</code>: Time it took for each estimation method and group.
</p>
</li>
<li> <p><code>options</code>: Options used for estimation. Obtained by running
<code><a href="#topic+mpt_options">mpt_options</a>()</code>
</p>
</li></ol>

<p>With the exception of the first five columns (i.e., after <code>method</code>) all
columns are <code>list</code> columns typically holding one <code>tibble</code> per cell.
The simplest way to analyze the results is separately per column using
<code><a href="tidyr.html#topic+nest">unnest</a></code>. Examples for this are given below.
</p>


<h3>References</h3>

<p>Smith, J. B., &amp; Batchelder, W. H. (2008). Assessing individual differences
in categorical data. <em>Psychonomic Bulletin &amp; Review</em>, 15(4), 713-731.
<a href="https://doi.org/10.3758/PBR.15.4.713">https://doi.org/10.3758/PBR.15.4.713</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ------------------------------------------------------------------------------
# MPT model definition &amp; Data

EQN_FILE &lt;- system.file("extdata", "prospective_memory.eqn", package = "MPTmultiverse")
DATA_FILE &lt;- system.file("extdata", "smith_et_al_2011.csv", package = "MPTmultiverse")

### if .csv format uses semicolons ";" (e.g., German format):
# data &lt;- read.csv2(DATA_FILE, fileEncoding = "UTF-8-BOM")
### if .csv format uses commata "," (international format):
data &lt;- read.csv(DATA_FILE, fileEncoding = "UTF-8-BOM")
data &lt;- data[c(1:10, 113:122),]  ## select only subset of data for example
head(data)

COL_CONDITION &lt;- "WM_EX"  # name of the variable encoding group membership

# experimental condition should be labeled meaningfully ----
unique(data[[COL_CONDITION]])

data[[COL_CONDITION]] &lt;- factor(
  data[[COL_CONDITION]]
  , levels = 1:2
  , labels = c("low_WM", "high_WM")
)

# define core parameters:
CORE &lt;- c("C1", "C2")

## Not run: 
op &lt;- mpt_options() 
## to reset default options (which you would want) use:
mpt_options("default")

mpt_options() # to see the settings 
## Note: settings are also saved in the results tibble
  
## without specifying method, all are used per default
fit_all &lt;- fit_mpt(
  model = EQN_FILE
  , dataset = DATA_FILE
  , data = data
  , condition = COL_CONDITION
  , core = CORE
)

mpt_options(op) ## reset options  

## End(Not run)

load(system.file("extdata", "prospective_memory_example.rda", package = "MPTmultiverse"))

# Although we requested all 10 methods, only 9 worked:
fit_all$method
# Jags variant of beta MPT is missing.

# the returned method has a plot method. For example, for the group-level estimates:
plot(fit_all, which = "est")

## Not run: 
### Full analysis of results requires dplyr and tidyr (or just 'tidyverse')
library("dplyr")
library("tidyr")

## first few columns identify model, data, and estimation approach/method
## remaining columns are list columns containing the results for each method
## use unnest to work with each of the results columns
glimpse(fit_all) 

## Let us inspect the group-level estimates
fit_all %&gt;% 
  select(method, pooling, est_group) %&gt;% 
  unnest() 

## which we can plot again
plot(fit_all, which = "est")

## Next we take a look at the GoF
fit_all %&gt;% 
  select(method, pooling, gof_group) %&gt;% 
  unnest() %&gt;% 
  as.data.frame()

# Again, we can plot it as well
plot(fit_all, which = "gof2")  ## use "gof1" for overall GoF

## Finally, we take a look at the differences between conditions
fit_all %&gt;% 
  select(method, pooling, test_between) %&gt;% 
  unnest() 

# and then we plot it
plot(fit_all, which = "test_between")


### Also possible to only use individual methods:
only_asymptotic &lt;- fit_mpt(
  model = EQN_FILE
  , dataset = DATA_FILE
  , data = data
  , condition = COL_CONDITION
  , core = CORE
  , method = "asymptotic_no"
)
only_asymptotic$est_group

bayes_complete &lt;- fit_mpt(
  model = EQN_FILE
  , dataset = DATA_FILE
  , data = data
  , condition = COL_CONDITION
  , core = CORE
  , method = "simple_pooling"
)
bayes_complete$est_group


## End(Not run)
</code></pre>

<hr>
<h2 id='get_info'>Collect Model Equations and Data per Tree</h2><span id='topic+get_info'></span>

<h3>Description</h3>

<p>Helper function that collects model equation and data per tree
for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_info(
  model,
  dataset,
  data,
  id = NULL,
  condition = NULL,
  include_data = FALSE,
  core = NULL,
  autosave = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_info_+3A_model">model</code></td>
<td>
<p>A model definition, typically the path to an <code>.eqn</code> model
file containing the model equations. Category names need to match column
names in <code>data</code>.</p>
</td></tr>
<tr><td><code id="get_info_+3A_dataset">dataset</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the data set that will
be copied to the results <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="get_info_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data. Column
names need to match category names in <code>model</code> (i.e., different from
<span class="pkg">MPTinR</span> behavior, order of categories is not important, matching is
done via name).</p>
</td></tr>
<tr><td><code id="get_info_+3A_id">id</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the column that contains
the subject identifier. If not specified, it is assumed that each row
represents observations from one participant.</p>
</td></tr>
<tr><td><code id="get_info_+3A_condition">condition</code></td>
<td>
<p>scalar <code>character</code> vector. Name of the column
specifying a between-subjects factor. If not specified, no between-subjects
comparisons are performed.</p>
</td></tr>
<tr><td><code id="get_info_+3A_include_data">include_data</code></td>
<td>
<p>If <code>FALSE</code> (the default) the response frequencies
are not part of the output, but only the number of observations per tree.
If <code>TRUE</code>, the full data is part of the output.</p>
</td></tr>
<tr><td><code id="get_info_+3A_core">core</code></td>
<td>
<p><code>character</code> vector defining the core parameters of interest,
e.g., <code>core = c("Dn", "Do")</code>. All other parameters are treated as
auxiliary parameters.</p>
</td></tr>
<tr><td><code id="get_info_+3A_autosave">autosave</code></td>
<td>
<p>If <code>TRUE</code> (the default) the results are automatically
saved in the current working directory in a file with name derived from
both model and data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. If <code>autosave = TRUE</code>, the list is also saved in the
current working directory.
</p>

<hr>
<h2 id='get_pb_output'>Parametric Bootstrap for MPT</h2><span id='topic+get_pb_output'></span>

<h3>Description</h3>

<p>Helper function for creating parametric-bootstrap confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pb_output(i, fit_mptinr, data, model_file, col_freq, MPTINR_OPTIONS)
</code></pre>

<hr>
<h2 id='mpt_options'>Options Settings for MPT Comparison</h2><span id='topic+mpt_options'></span>

<h3>Description</h3>

<p>Set and examine a variety of <em>options</em> which affect the way MPT models
are estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpt_options(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpt_options_+3A_...">...</code></td>
<td>
<p>Named parameters to set. Possible values are:
</p>

<ul>
<li><p><code>bootstrap_samples</code>: Numeric. The number of bootstrap samples to be drawn for the calculation parametric bootstrap confidence intervals.
</p>
</li>
<li><p><code>n.optim</code>: Numeric. The number of optimization runs for the models estimated with maximum-likelihood methods.
</p>
</li>
<li><p><code>n.chains</code>: Numeric. The number of MCMC chains for the Bayesian models.
</p>
</li>
<li><p><code>n.adapt</code>: Numeric. The number of iterations for adaptation.
</p>
</li>
<li><p><code>n.burnin</code>: Numeric. The number of burn-in/warm-up iterations.
</p>
</li>
<li><p><code>n.iter</code>: Numeric. The total number of iterations to be drawn <em>after</em> adaptation (including burnin).
</p>
</li>
<li><p><code>n.thin</code>: Numeric. Thinning interval.
</p>
</li>
<li><p><code>Rhat_max</code>: Numeric. The maximum rhat.
</p>
</li>
<li><p><code>Neff_min</code>: Numeric. The minimum number of effective samples you are willing to accept.
</p>
</li>
<li><p><code>extend_max</code>: Numeric.
</p>
</li>
<li><p><code>n.PPP</code>: Numeric. The number of posterior predictive samples drawn for the calculation of fit statistics T_1 and T_2.
</p>
</li>
<li><p><code>n.CPU</code>: Numeric. The number of CPU cores to use for obtaining the parametric bootstrap dsitribution. Defaults to the number of available cores on your machine.
</p>
</li>
<li><p><code>ci_size</code>: Numeric.
</p>
</li>
<li><p><code>max_ci_indiv</code>: Numeric. Used for excluding individual parameter estimates in the bootstrap approaches. If the range of the CI (i.e., distance between minimum and maximum) is larger than this value, the estimate is excluded from the group-level estimates.
</p>
</li>
<li><p><code>silent_jags</code>: Logical. Whether to suppress JAGS output.
</p>
</li>
<li><p><code>save_models</code>: Logical. Default is <code>FALSE</code> which does not save the individual MCMC samples in <code>.RData</code> files. Instead only summairzes are retained in <code>results</code> object.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Examine options:
mpt_options()

# Set number of MCMC chains to 20:
mpt_options(n.chains = 20)
mpt_options()

</code></pre>

<hr>
<h2 id='plot.multiverseMPT'>Plot multiverseMPT</h2><span id='topic+plot.multiverseMPT'></span>

<h3>Description</h3>

<p>Plot the results from a multiverse MPT analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiverseMPT'
plot(x, which = "est", save = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.multiverseMPT_+3A_x">x</code></td>
<td>
<p>An object of class <code>multiverseMPT</code>.</p>
</td></tr>
<tr><td><code id="plot.multiverseMPT_+3A_which">which</code></td>
<td>
<p>Character. Which information should be plotted? Possible
values are
<code>"est"</code> for parameter estimates,
<code>"test_between"</code> for between-subjects comparisions,
<code>"gof1"</code> for overall goodness-of-fit statistics, and
<code>"gof2"</code> for group-wise goodness-of-fit statistics.</p>
</td></tr>
<tr><td><code id="plot.multiverseMPT_+3A_save">save</code></td>
<td>
<p>Logical. Indicates whether the plot should also be saved as a .pdf file.</p>
</td></tr>
<tr><td><code id="plot.multiverseMPT_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='write_results'>Write Results of Multiverse Analysis to csv-Files</h2><span id='topic+write_results'></span>

<h3>Description</h3>

<p>Exports the results to csv format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_results(results, path = "MPTmultiverse_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_results_+3A_results">results</code></td>
<td>
<p>An object of class multiverseMPT.</p>
</td></tr>
<tr><td><code id="write_results_+3A_path">path</code></td>
<td>
<p>a path where to save the files (e.g., <code>"C:/results/modelX_dataY_"</code>)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
