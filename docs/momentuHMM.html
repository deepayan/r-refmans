<!DOCTYPE html><html><head><title>Help for package momentuHMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {momentuHMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.momentuHMM'><p>AIC</p></a></li>
<li><a href='#AICweights'><p>Calculate Akaike information criterion model weights</p></a></li>
<li><a href='#allProbs'><p>Matrix of all probabilities</p></a></li>
<li><a href='#checkPar0'><p>Check parameter length and order for a <code>fitHMM</code> (or <code>MIfitHMM</code>) model</p></a></li>
<li><a href='#CIbeta'><p>Confidence intervals for working (i.e., beta) parameters</p></a></li>
<li><a href='#circAngles'><p>Convert standard direction angles (in radians relative to the x-axis) to turning angle covariates suitable for circular-circular regression on the angle mean</p></a></li>
<li><a href='#CIreal'><p>Confidence intervals for the natural (i.e., real) parameters</p></a></li>
<li><a href='#crawlMerge'><p>Merge crwData or crwHierData object with additional data streams and/or covariates</p></a></li>
<li><a href='#crawlWrap'><p>Fit and predict tracks for using crawl</p></a></li>
<li><a href='#crwData'><p>Constructor of <code>crwData</code> objects</p></a></li>
<li><a href='#crwHierData'><p>Constructor of <code>crwHierData</code> objects</p></a></li>
<li><a href='#crwHierSim'><p>Constructor of <code>crwHierSim</code> objects</p></a></li>
<li><a href='#crwSim'><p>Constructor of <code>crwSim</code> objects</p></a></li>
<li><a href='#dbern_rcpp'><p>Bernoulli density function</p></a></li>
<li><a href='#dbeta_rcpp'><p>Probability density function of the beta distribution (written in C++)</p></a></li>
<li><a href='#dcat_rcpp'><p>Categorical density function</p></a></li>
<li><a href='#dexp_rcpp'><p>Exponential density function</p></a></li>
<li><a href='#dgamma_rcpp'><p>Gamma density function</p></a></li>
<li><a href='#distAngle'><p>Calculate distance between points y and z and turning angle between points x, y, and z</p></a></li>
<li><a href='#dlnorm_rcpp'><p>Log-normal density function</p></a></li>
<li><a href='#dlogis_rcpp'><p>logistic density function</p></a></li>
<li><a href='#dmvnorm_rcpp'><p>C++ implementation of multivariate Normal probability density function for multiple inputs</p></a></li>
<li><a href='#dnbinom_rcpp'><p>negative binomial density function</p></a></li>
<li><a href='#dnorm_rcpp'><p>Normal density function</p></a></li>
<li><a href='#dpois_rcpp'><p>Poisson density function</p></a></li>
<li><a href='#dt_rcpp'><p>student t density function</p></a></li>
<li><a href='#dvm_rcpp'><p>Von Mises density function</p></a></li>
<li><a href='#dweibull_rcpp'><p>Weibull density function</p></a></li>
<li><a href='#dwrpcauchy_rcpp'><p>Wrapped Cauchy density function</p></a></li>
<li><a href='#exampleData'><p>Example dataset</p></a></li>
<li><a href='#expandPar'><p>Expand vector of free working parameters to vector of all working parameters including any fixed parameters (used in fitHMM.R and nLogLike.R)</p></a></li>
<li><a href='#fitHMM'><p>Fit a multivariate HMM to the data</p></a></li>
<li><a href='#formatHierHMM'><p>Convert hierarchical HMM structure to a conventional HMM</p></a></li>
<li><a href='#getCovNames'><p>Get names of any covariates used in probability distribution parameters</p></a></li>
<li><a href='#getDM_rcpp'><p>Get design matrix</p></a></li>
<li><a href='#getPar'><p>Get starting values from momentuHMM, miHMM, or miSum object returned by fitHMM, MIfitHMM, or MIpool</p></a></li>
<li><a href='#getPar0'><p>Get starting values for new model from existing <code>momentuHMM</code> or <code>momentuHierHMM</code> model fit</p></a></li>
<li><a href='#getParDM'><p>Get starting values on working scale based on design matrix and other parameter constraints</p></a></li>
<li><a href='#getTrProbs'><p>Transition probability matrix</p></a></li>
<li><a href='#HMMfits'><p>Constructor of <code>HMMfits</code> objects</p></a></li>
<li><a href='#is.crwData'><p>Is crwData</p></a></li>
<li><a href='#is.crwHierData'><p>Is crwHierData</p></a></li>
<li><a href='#is.crwHierSim'><p>Is crwHierSim</p></a></li>
<li><a href='#is.crwSim'><p>Is crwSim</p></a></li>
<li><a href='#is.HMMfits'><p>Is HMMfits</p></a></li>
<li><a href='#is.miHMM'><p>Is miHMM</p></a></li>
<li><a href='#is.miSum'><p>Is miSum</p></a></li>
<li><a href='#is.momentuHierHMM'><p>Is momentuHierHMM</p></a></li>
<li><a href='#is.momentuHierHMMData'><p>Is momentuHierHMMData</p></a></li>
<li><a href='#is.momentuHMM'><p>Is momentuHMM</p></a></li>
<li><a href='#is.momentuHMMData'><p>Is momentuHMMData</p></a></li>
<li><a href='#logAlpha'><p>Forward log-probabilities</p></a></li>
<li><a href='#logBeta'><p>Backward log-probabilities</p></a></li>
<li><a href='#MIfitHMM'><p>Fit HMMs to multiple imputation data</p></a></li>
<li><a href='#miHMM'><p>Constructor of <code>miHMM</code> objects</p></a></li>
<li><a href='#MIpool'><p>Calculate pooled parameter estimates and states across multiple imputations</p></a></li>
<li><a href='#miSum'><p>Constructor of <code>miSum</code> objects</p></a></li>
<li><a href='#mixtureProbs'><p>Mixture probabilities</p></a></li>
<li><a href='#momentuHierHMM'><p>Constructor of <code>momentuHierHMM</code> objects</p></a></li>
<li><a href='#momentuHierHMMData'><p>Constructor of <code>momentuHierHMMData</code> objects</p></a></li>
<li><a href='#momentuHMM'><p>Constructor of <code>momentuHMM</code> objects</p></a></li>
<li><a href='#momentuHMMData'><p>Constructor of <code>momentuHMMData</code> objects</p></a></li>
<li><a href='#n2w'><p>Scaling function: natural to working parameters.</p></a></li>
<li><a href='#nLogLike'><p>Negative log-likelihood function</p></a></li>
<li><a href='#nLogLike_rcpp'><p>Negative log-likelihood</p></a></li>
<li><a href='#parDef'><p>Parameters definition</p></a></li>
<li><a href='#plot.crwData'><p>Plot <code>crwData</code></p></a></li>
<li><a href='#plot.miHMM'><p>Plot <code>miHMM</code></p></a></li>
<li><a href='#plot.miSum'><p>Plot <code>miSum</code></p></a></li>
<li><a href='#plot.momentuHMM'><p>Plot <code>momentuHMM</code></p></a></li>
<li><a href='#plot.momentuHMMData'><p>Plot <code>momentuHMMData</code> or <code>momentuHierHMMData</code></p></a></li>
<li><a href='#plotPR'><p>Plot pseudo-residuals</p></a></li>
<li><a href='#plotSat'><p>Plot observations on satellite image</p></a></li>
<li><a href='#plotSpatialCov'><p>Plot observations on raster image</p></a></li>
<li><a href='#plotStates'><p>Plot states</p></a></li>
<li><a href='#plotStationary'><p>Plot stationary state probabilities</p></a></li>
<li><a href='#prepData'><p>Preprocessing of the data streams and covariates</p></a></li>
<li><a href='#print.miHMM'><p>Print <code>miHMM</code></p></a></li>
<li><a href='#print.miSum'><p>Print <code>miSum</code></p></a></li>
<li><a href='#print.momentuHMM'><p>Print <code>momentuHMM</code></p></a></li>
<li><a href='#pseudoRes'><p>Pseudo-residuals</p></a></li>
<li><a href='#randomEffects'><p>Random effects estimation</p></a></li>
<li><a href='#setModelName'><p>Set <code>modelName</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object</p></a></li>
<li><a href='#setStateNames'><p>Set <code>stateNames</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object</p></a></li>
<li><a href='#simData'><p>Simulation tool</p></a></li>
<li><a href='#simObsData'><p>Observation error simulation tool</p></a></li>
<li><a href='#stateProbs'><p>State probabilities</p></a></li>
<li><a href='#stationary'><p>Stationary state probabilities</p></a></li>
<li><a href='#summary.momentuHMMData'><p>Summary <code>momentuHMMData</code></p></a></li>
<li><a href='#timeInStates'><p>Calculate proportion of time steps assigned to each state (i.e. &ldquo;activity budgets&rdquo;)</p></a></li>
<li><a href='#trMatrix_rcpp'><p>Transition probability matrix</p></a></li>
<li><a href='#turnAngle'><p>Turning angle</p></a></li>
<li><a href='#viterbi'><p>Viterbi algorithm</p></a></li>
<li><a href='#w2n'><p>Scaling function: working to natural parameters</p></a></li>
<li><a href='#XBloop_rcpp'><p>Get XB</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Maximum Likelihood Analysis of Animal Movement Behavior Using
Multivariate Hidden Markov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Author:</td>
<td>Brett McClintock, Theo Michelot</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brett McClintock &lt;brett.mcclintock@noaa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extended tools for analyzing telemetry data using generalized hidden Markov models. Features of momentuHMM (pronounced &ldquo;momentum&rdquo;) include data pre-processing and visualization, fitting HMMs to location and auxiliary biotelemetry or environmental data, biased and correlated random walk movement models, hierarchical HMMs, multiple imputation for incorporating location measurement error and missing data, user-specified design matrices and constraints for covariate modelling of parameters, random effects, decoding of the state process, visualization of fitted models, model checking and selection, and simulation. See McClintock and Michelot (2018) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12995">doi:10.1111/2041-210X.12995</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, doParallel, foreach, numDeriv, CircStats, crawl (&ge;
2.2.1), mvtnorm, sp, MASS, Brobdingnag, doRNG, rlang, raster</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, setRNG, splines, splines2 (&ge; 0.2.8), R.rsp,
conicfit, ggplot2, ggmap, lubridate, dplyr, magrittr,
scatterplot3d, BB, expm, matrixcalc, moveHMM, extraDistr,
data.tree (&ge; 1.0.0), geosphere, mitools, doFuture, future,
car, survival, prodlim, nleqslv, qdapRegex</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bmcclintock/momentuHMM">https://github.com/bmcclintock/momentuHMM</a>,
<a href="https://github.com/bmcclintock/momentuHMM/discussions">https://github.com/bmcclintock/momentuHMM/discussions</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bmcclintock/momentuHMM/issues">https://github.com/bmcclintock/momentuHMM/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-18 20:29:24 UTC; brettmcclintock</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-18 20:52:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.momentuHMM'>AIC</h2><span id='topic+AIC.momentuHMM'></span>

<h3>Description</h3>

<p>Akaike information criterion of momentuHMM model(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'momentuHMM'
AIC(object, ..., k = 2, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.momentuHMM_+3A_object">object</code></td>
<td>
<p>A <code>momentuHMM</code> object.</p>
</td></tr>
<tr><td><code id="AIC.momentuHMM_+3A_...">...</code></td>
<td>
<p>Optional additional <code>momentuHMM</code> objects, to compare AICs of the different models. These can be passed as a list using the <code>!!!</code> operator (see <code><a href="rlang.html#topic+quasiquotation">rlang</a></code> and example in <code><a href="#topic+AICweights">AICweights</a></code>).</p>
</td></tr>
<tr><td><code id="AIC.momentuHMM_+3A_k">k</code></td>
<td>
<p>Penalty per parameter. Default: 2 ; for classical AIC.</p>
</td></tr>
<tr><td><code id="AIC.momentuHMM_+3A_n">n</code></td>
<td>
<p>Optional sample size. If specified, the small sample correction AIC is used (i.e., <code>AICc = AIC + kp(p+1)/(n-p-1)</code> where p is the number of parameters).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AIC of the model(s) provided. If several models are provided, the AICs are output
in ascending order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m
AIC(m)

## Not run: 
# HMM specifications
nbStates &lt;- 2
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar0 &lt;- c(mu0,sigma0)
anglePar0 &lt;- c(-pi/2,pi/2,kappa0)
formula &lt;- ~cov1+cov2
                
# example$m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
mod1 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=list(step=stepPar0,angle=anglePar0),
                formula=~1,estAngleMean=list(angle=TRUE))

Par0 &lt;- getPar0(mod1,formula=formula)                 
mod2 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=Par0$Par,beta0=Par0$beta,
                formula=formula,estAngleMean=list(angle=TRUE))
                
AIC(mod1,mod2)

Par0nA &lt;- getPar0(mod1,estAngleMean=list(angle=FALSE))                 
mod3 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=Par0nA$Par,beta0=Par0nA$beta,
                formula=~1)
 
AIC(mod1,mod2,mod3)

# add'l models provided as a list using the !!! operator                              
AIC(mod1, !!!list(mod2,mod3))

## End(Not run)

</code></pre>

<hr>
<h2 id='AICweights'>Calculate Akaike information criterion model weights</h2><span id='topic+AICweights'></span>

<h3>Description</h3>

<p>Calculate Akaike information criterion model weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICweights(..., k = 2, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICweights_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miHMM">miHMM</a></code> objects, to compare AIC weights of the different models. The first object must be a <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miHMM">miHMM</a></code> object, but additional model objects can be passed as a list using the <code>!!!</code> operator (see <code><a href="rlang.html#topic+quasiquotation">rlang</a></code>).</p>
</td></tr>
<tr><td><code id="AICweights_+3A_k">k</code></td>
<td>
<p>Penalty per parameter. Default: 2 ; for classical AIC.</p>
</td></tr>
<tr><td><code id="AICweights_+3A_n">n</code></td>
<td>
<p>Optional sample size. If specified, the small sample correction AIC is used (i.e., <code>AICc = AIC + kp(p+1)/(n-p-1)</code> where p is the number of parameters).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Model objects must all be either of class <code><a href="#topic+momentuHMM">momentuHMM</a></code> or multiple imputation model objects (of class <code><a href="#topic+HMMfits">HMMfits</a></code> and/or <code><a href="#topic+miHMM">miHMM</a></code>).
</p>
</li>
<li><p> AIC is only valid for comparing models fitted to the same data. The data for each model fit must therefore be identical. For multiple imputation model objects, 
respective model fits must have identical data.</p>
</li></ul>



<h3>Value</h3>

<p>The AIC weights of the models. If multiple imputation objects are provided, 
then the mean model weights (and standard deviations) are provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# HMM specifications
nbStates &lt;- 2
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar0 &lt;- c(mu0,sigma0)
anglePar0 &lt;- c(-pi/2,pi/2,kappa0)
formula &lt;- ~cov1+cov2
                
# example$m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
mod1 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=list(step=stepPar0,angle=anglePar0),
                formula=~1,estAngleMean=list(angle=TRUE))

Par0 &lt;- getPar0(mod1,formula=formula)                 
mod2 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=Par0$Par,beta0=Par0$beta,
                formula=formula,estAngleMean=list(angle=TRUE))
                
AICweights(mod1,mod2)

Par0nA &lt;- getPar0(mod1,estAngleMean=list(angle=FALSE))                 
mod3 &lt;- fitHMM(example$m$data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=Par0nA$Par,beta0=Par0nA$beta,
                formula=~1)
 
AICweights(mod1,mod2,mod3)

# add'l models provided as a list using the !!! operator                               
AICweights(mod1, !!!list(mod2,mod3))

## End(Not run)

</code></pre>

<hr>
<h2 id='allProbs'>Matrix of all probabilities</h2><span id='topic+allProbs'></span>

<h3>Description</h3>

<p>Used in functions <code><a href="#topic+viterbi">viterbi</a></code>, <code><a href="#topic+logAlpha">logAlpha</a></code>, <code><a href="#topic+logBeta">logBeta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allProbs(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allProbs_+3A_m">m</code></td>
<td>
<p>Object <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+miSum">miSum</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of all probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
P &lt;- momentuHMM:::allProbs(m=example$m)

## End(Not run)

</code></pre>

<hr>
<h2 id='checkPar0'>Check parameter length and order for a <code><a href="#topic+fitHMM">fitHMM</a></code> (or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>) model</h2><span id='topic+checkPar0'></span><span id='topic+checkPar0.default'></span><span id='topic+checkPar0.hierarchical'></span>

<h3>Description</h3>

<p>Prints parameters with labels based on <code>DM</code>, <code>formula</code>, and/or <code>formulaDelta</code>.  See <code><a href="#topic+fitHMM">fitHMM</a></code> for 
further argument details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPar0(data, ...)

## Default S3 method:
checkPar0(
  data,
  nbStates,
  dist,
  Par0 = NULL,
  beta0 = NULL,
  delta0 = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  formula = ~1,
  formulaDelta = NULL,
  stationary = FALSE,
  mixtures = 1,
  formulaPi = NULL,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  betaRef = NULL,
  deltaCons = NULL,
  stateNames = NULL,
  fixPar = NULL,
  prior = NULL,
  ...
)

## S3 method for class 'hierarchical'
checkPar0(
  data,
  hierStates,
  hierDist,
  Par0 = NULL,
  hierBeta = NULL,
  hierDelta = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  hierFormula = NULL,
  hierFormulaDelta = NULL,
  mixtures = 1,
  formulaPi = NULL,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  deltaCons = NULL,
  fixPar = NULL,
  prior = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPar0_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object, <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object, or a data frame containing the data stream and covariate values</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_par0">Par0</code></td>
<td>
<p>Optional named list containing vectors of state-dependent probability distribution parameters for 
each data stream specified in <code>dist</code>.  If <code>Par0</code> is not provided, then ordered parameter indices are returned.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_beta0">beta0</code></td>
<td>
<p>Optional matrix of regression coefficients for the transition probabilities. If <code>beta0</code> is not provided, then ordered parameter indices are returned.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_delta0">delta0</code></td>
<td>
<p>Optional values or regression coefficients for the initial distribution of the HMM. If <code>delta0</code> is not provided, then ordered parameter indices are returned.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>An optional named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy').</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>An optional named list indicating whether to use circular-linear or circular-circular
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_formuladelta">formulaDelta</code></td>
<td>
<p>Regression formula for the initial distribution.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_formulapi">formulaPi</code></td>
<td>
<p>Regression formula for the mixture distribution probabilities. 
Note that only the covariate values from the first row for each individual ID in <code>data</code> are used (i.e. time-varying covariates cannot be used for the mixture probabilties).</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_betacons">betaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>beta0</code> composed of integers identifying any equality constraints among the t.p.m. parameters.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_betaref">betaRef</code></td>
<td>
<p>Numeric vector of length <code>nbStates</code> indicating the reference elements for the t.p.m. multinomial logit link.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_deltacons">deltaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>delta0</code> composed of integers identifying any equality constraints among the initial distribution working scale parameters. Ignored unless a formula is provided in <code>formulaDelta</code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length nbStates indicating state names.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_fixpar">fixPar</code></td>
<td>
<p>An optional list of vectors indicating parameters which are assumed known prior to fitting the model.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_prior">prior</code></td>
<td>
<p>A function that returns the log-density of the working scale parameter prior distribution(s).</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states ('state').  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams ('dist'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the initial matrix of regression coefficients for the transition probabilities at each level of the hierarchy ('beta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierdelta">hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the initial values for the initial distribution at each level of the hierarchy ('delta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy ('formula'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="checkPar0_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>. Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fitHMM">fitHMM</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- example$m
checkPar0(data=m$data, nbStates=2, dist=m$conditions$dist,
          estAngleMean = m$conditions$estAngleMean,
          formula = m$conditions$formula)

par &lt;- getPar(m)
checkPar0(data=m$data, nbStates=2, dist=m$conditions$dist,
          estAngleMean = m$conditions$estAngleMean,
          formula = m$conditions$formula,
          Par0=par$Par, beta0=par$beta, delta0=par$delta)
          
dummyDat &lt;- data.frame(step=0,angle=0,cov1=0,cov2=0)
checkPar0(data=dummyDat, nbStates=2, dist=m$conditions$dist,
          estAngleMean = m$conditions$estAngleMean,
          formula = m$conditions$formula)

## Not run: 
simDat &lt;- simData(nbStates=2, dist=m$conditions$dist, Par = par$Par,
                  spatialCovs = list(forest=forest),
                  centers = matrix(0,1,2),
                  nbCovs = 2)
checkPar0(data = simDat, nbStates=2, dist=m$conditions$dist,
          formula = ~forest,
          DM = list(step=list(mean=~cov1, sd=~cov2),
                    angle=list(mean=~center1.angle,concentration=~1)),
          estAngleMean=list(angle=TRUE),
          circularAngleMean=list(angle=TRUE))
          
par &lt;- list(step=rnorm(8),angle=rnorm(4))
beta0 &lt;- matrix(rnorm(4),2,2)
delta0 &lt;- c(0.5,0.5)
checkPar0(data = simDat, nbStates=2, dist=m$conditions$dist,
          Par0 = par, beta0 = beta0, delta0 = delta0,
          formula = ~forest,
          DM = list(step=list(mean=~cov1, sd=~cov2),
                    angle=list(mean=~center1.angle,concentration=~1)),
          estAngleMean=list(angle=TRUE),
          circularAngleMean=list(angle=TRUE))                

## End(Not run)
</code></pre>

<hr>
<h2 id='CIbeta'>Confidence intervals for working (i.e., beta) parameters</h2><span id='topic+CIbeta'></span>

<h3>Description</h3>

<p>Computes the standard errors and confidence intervals on the beta (i.e., working) scale of the data stream probability distribution parameters,
as well as for the transition probabilities regression parameters. Working scale depends on the real (i.e., natural) scale of the parameters. For 
non-circular distributions or for circular distributions with <code>estAngleMean</code>=FALSE:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIbeta(m, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIbeta_+3A_m">m</code></td>
<td>
<p>A <code>momentuHMM</code> object</p>
</td></tr>
<tr><td><code id="CIbeta_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals. Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1) if both lower and upper bounds are finite then logit is the working scale;
2) if lower bound is finite and upper bound is infinite then log is the working scale.
</p>
<p>For circular distributions with <code>estAngleMean</code>=TRUE and no constraints imposed by a design matrix (DM) or bounds (userBounds), then the working parameters 
are complex functions of both the angle mean and concentrations/sd natural parameters (in this case, it's probably best just to focus on the real parameter
estimates!).  However, if constraints are imposed by DM or userBounds on circular distribution parameters with <code>estAngleMean</code>=TRUE and <code>circularAngleMean</code>=FALSE:
</p>
<p>1) if the natural bounds are (-pi,pi] then tangent is the working scale, otherwise if both lower and upper bounds are finite then logit is the working scale;
2) if lower bound is finite and upper bound is infinite then log is the working scale.
</p>
<p>When circular-circular regression is specified using <code>circularAngleMean</code>, the working scale 
for the mean turning angle is not as easily interpretable, but the 
link function is atan2(sin(X)*B,1+cos(X)*B), where X are the angle covariates and B the angle coefficients. 
Under this formulation, the reference turning angle is 0 (i.e., movement in the same direction as the previous time step). 
In other words, the mean turning angle is zero when the coefficient(s) B=0.
</p>


<h3>Value</h3>

<p>A list of the following objects:
</p>
<table>
<tr><td><code>...</code></td>
<td>
<p>List(s) of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the working parameters of the data streams</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>List of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the working parameters of the transition probabilities</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

CIbeta(m)

</code></pre>

<hr>
<h2 id='circAngles'>Convert standard direction angles (in radians relative to the x-axis) to turning angle covariates suitable for circular-circular regression on the angle mean</h2><span id='topic+circAngles'></span>

<h3>Description</h3>

<p>This function can be used to convert angular covariates (e.g., ocean currents, wind direction) measured in radians relative to the x-axis to turning angle
covariates sutiable for circular-circular regression in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circAngles(refAngle, data, coordNames = c("x", "y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circAngles_+3A_refangle">refAngle</code></td>
<td>
<p>Numeric vector of standard direction angles (in radians) relative to the x-axis, where 0 = east, pi/2 = north, pi = west, -pi/2 = south</p>
</td></tr>
<tr><td><code id="circAngles_+3A_data">data</code></td>
<td>
<p>data frame containing fields for the x- and y-coordinates (identified by <code>coordNames</code>) and 'ID' (if more than one individual)</p>
</td></tr>
<tr><td><code id="circAngles_+3A_coordnames">coordNames</code></td>
<td>
<p>Names of the columns of coordinates in <code>data</code>. Default: <code>c("x","y")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of turning angles between the movement direction at time step t-1 and <code>refAngle</code> at time t
</p>


<h3>Examples</h3>

<pre><code class='language-R'># extract data from momentuHMM example
data&lt;-example$m$data

# generate fake angle covariates
u &lt;- rnorm(nrow(data)) # horizontal component
v &lt;- rnorm(nrow(data)) # vertical component
refAngle &lt;- atan2(v,u)

# add turning angle covariate to data
data$cov3 &lt;- circAngles(refAngle=refAngle,data=data)

</code></pre>

<hr>
<h2 id='CIreal'>Confidence intervals for the natural (i.e., real) parameters</h2><span id='topic+CIreal'></span><span id='topic+CIreal.default'></span><span id='topic+CIreal.hierarchical'></span>

<h3>Description</h3>

<p>Computes the standard errors and confidence intervals on the real (i.e., natural) scale of the data stream probability distribution parameters,
as well as for the transition probabilities parameters. If covariates are included in the probability distributions or TPM formula, the mean values
of non-factor covariates are used for calculating the natural parameters. For any covariate(s) of class 'factor', then the value(s) from the first observation 
in the data are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIreal(m, alpha = 0.95, covs = NULL, parms = NULL)

## Default S3 method:
CIreal(m, alpha = 0.95, covs = NULL, parms = NULL)

## S3 method for class 'hierarchical'
CIreal(m, alpha = 0.95, covs = NULL, parms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIreal_+3A_m">m</code></td>
<td>
<p>A <code>momentuHMM</code>, <code>momentuHierHMM</code>, <code>miHMM</code>, or <code>miSum</code> object</p>
</td></tr>
<tr><td><code id="CIreal_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals. Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="CIreal_+3A_covs">covs</code></td>
<td>
<p>Data frame consisting of a single row indicating the covariate values to be used in the calculations. By default, no covariates are specified.</p>
</td></tr>
<tr><td><code id="CIreal_+3A_parms">parms</code></td>
<td>
<p>Optional character vector indicating which groups of real parameters to calculate confidence intervals for (e.g., 'step', 'angle', 'gamma', 'delta', etc.). Default: NULL, in which case confidence intervals are calculated for all groups of parameters in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any covariates that are not specified using <code>covs</code>, the means of the covariate(s) are used 
(unless the covariate is a factor, in which case the first factor in the data is used).
</p>


<h3>Value</h3>

<p>A list of the following objects:
</p>
<table>
<tr><td><code>...</code></td>
<td>
<p>List(s) of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the natural parameters of the data streams</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>List of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the transition probabilities</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>List of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the initial state probabilities</p>
</td></tr>
<tr><td><code>hierGamma</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> including a list of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the transition probabilities for each level of the hierarchy (only applies if <code>m</code> is a hierarchical model object)</p>
</td></tr>
<tr><td><code>hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> including a list of estimates ('est'), standard errors ('se'), and confidence intervals ('lower', 'upper') for the initial state probabilities for each level of the hierarchy (only applies if <code>m</code> is a hierarchical model object)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

ci1&lt;-CIreal(m)

# specify 'covs'
ci2&lt;-CIreal(m,covs=data.frame(cov1=mean(m$data$cov1),cov2=mean(m$data$cov2)))

all.equal(ci1,ci2)

</code></pre>

<hr>
<h2 id='crawlMerge'>Merge crwData or crwHierData object with additional data streams and/or covariates</h2><span id='topic+crawlMerge'></span>

<h3>Description</h3>

<p>This function can be used to merge <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> objects (as returned by <code><a href="#topic+crawlWrap">crawlWrap</a></code>) with additional data streams
and/or covariates that are unrelated to location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crawlMerge(crwData, data, Time.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crawlMerge_+3A_crwdata">crwData</code></td>
<td>
<p>A <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object</p>
</td></tr>
<tr><td><code id="crawlMerge_+3A_data">data</code></td>
<td>
<p>A data frame containing required columns <code>ID</code>, <code>Time.name</code>, and, if <code>crwData</code> is hierarchical, <code>level</code>, plus any additional data streams and/or covariates to merge with <code>crwData</code>.</p>
</td></tr>
<tr><td><code id="crawlMerge_+3A_time.name">Time.name</code></td>
<td>
<p>Character string indicating name of the time column to be used for merging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically, the function merges the <code>crwData$crwPredict</code> data frame with <code>data</code>
based on the <code>ID</code>, <code>Time.name</code>, and, if <code>crwData</code> is hierarchical, <code>level</code> columns.  Thus <code>data</code> must contain <code>ID</code>, <code>Time.name</code>, and, if <code>crwData</code> is hierarchical, <code>level</code> columns. 
</p>
<p>Only rows of <code>data</code> with <code>ID</code>, <code>Time.name</code>, and, if <code>crwData</code> is hierarchical, <code>level</code> values that exactly match <code>crwData$crwPredict</code> are merged. Typically, the <code>Time.name</code> column
in <code>data</code> should match predicted times of locations in <code>crwData$crwPredict</code> (i.e. those corresponding to <code>crwData$crwPredict$locType=="p"</code>)
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+crwData">crwData</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# extract simulated obsData from example data
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crwMLE models to obsData and predict locations 
# at default intervals for both individuals
crwOut &lt;- crawlWrap(obsData=obsData,
         theta=c(4,0),fixPar=c(1,1,NA,NA),
         err.model=err.model,attempts=100)
         
# create data frame with fake data stream
data &lt;- data.frame(ID=rep(factor(c(1,2)),times=c(753,652)),
                   time=c(1:753,1:652),
                   fake=rpois(753+652,5))

# merge fake data stream with crwOut
crwOut &lt;- crawlMerge(crwOut,data,"time")

## End(Not run)

</code></pre>

<hr>
<h2 id='crawlWrap'>Fit and predict tracks for using crawl</h2><span id='topic+crawlWrap'></span>

<h3>Description</h3>

<p>Wrapper function for fitting crawl::crwMLE models and predicting locations with crawl::crwPredict for multiple individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crawlWrap(
  obsData,
  timeStep = 1,
  ncores = 1,
  retryFits = 0,
  retrySD = 1,
  retryParallel = FALSE,
  mov.model = ~1,
  err.model = NULL,
  activity = NULL,
  drift = NULL,
  coord = c("x", "y"),
  proj = NULL,
  Time.name = "time",
  time.scale = "hours",
  theta,
  fixPar,
  method = "L-BFGS-B",
  control = NULL,
  constr = NULL,
  prior = NULL,
  need.hess = TRUE,
  initialSANN = list(maxit = 200),
  attempts = 1,
  predTime = NULL,
  fillCols = FALSE,
  coordLevel = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crawlWrap_+3A_obsdata">obsData</code></td>
<td>
<p>data.frame object containing fields for animal ID ('ID'), time of observation (identified by <code>Time.name</code>, must be numeric or POSIXct), 
and observed locations (x- and y- coordinates identified by <code>coord</code>), such as that returned by <code><a href="#topic+simData">simData</a></code> when temporally-irregular observed locations or
measurement error are included. Alternatively, a <code><a href="sp.html#topic+SpatialPoints">SpatialPointsDataFrame</a></code> or <code>sf</code> object will 
also be accepted, in which case the <code>coord</code> values will be taken from the spatial data set and ignored in the arguments.  
Note that <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code> requires that longitude/latitude coordinates be projected to UTM (i.e., easting/northing). For further details see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_timestep">timeStep</code></td>
<td>
<p>Length of the time step at which to predict regular locations from the fitted model. Unless <code>predTime</code> is specified, the sequence of times
is <code>seq(a_i,b_i,timeStep)</code> where a_i and b_i are the times of the first and last observations for individual i. <code>timeStep</code> can be numeric (regardless of
whether <code>obsData[[Time.name]]</code> is numeric or POSIXct) or a character string (if <code>obsData[[Time.name]]</code> is of class POSIXct) containing one of &quot;sec&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;DSTday&quot;, &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot; or &quot;year&quot;. 
This can optionally be preceded by a positive integer and a space, or followed by &quot;s&quot; (e.g., &ldquo;2 hours&rdquo;; see <code><a href="base.html#topic+seq.POSIXt">seq.POSIXt</a></code>). <code>timeStep</code> is not used for individuals for which <code>predTime</code> is specified.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default: 1 (no parallel processing).</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_retryfits">retryFits</code></td>
<td>
<p>Number of times to attempt to achieve convergence and valid (i.e., not NaN) variance estimates after the initial model fit.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_retrysd">retrySD</code></td>
<td>
<p>An optional list of scalars or vectors for each individual indicating the standard deviation to use for normal perturbations of <code>theta</code> when <code>retryFits&gt;0</code> (or <code>attempts&gt;1</code>). 
Instead of a list object, <code>retrySD</code> can also be a scalar or a vector, in which case the same values are used for each each individual.
If a scalar is provided, then the same value is used for each parameter. If a vector is provided, it must be of length <code>length(theta)</code> for the corresponding individual(s). Default: 1, i.e., a standard deviation of 1 is used
for all parameters of all individuals. Ignored unless <code>retryFits&gt;0</code> (or <code>attempts&gt;1</code>).</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_retryparallel">retryParallel</code></td>
<td>
<p>Logical indicating whether or not to perform <code>retryFits</code> attempts for each individual in parallel. Default: FALSE. Ignored unless <code>retryFits&gt;0</code> and <code>ncores&gt;1</code>.
Note that when attempts are done in parallel (i.e. <code>retryParallel=TRUE</code>), the current value for the log-likelihood of each individual and warnings about convergence are not printed to the console.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_mov.model">mov.model</code></td>
<td>
<p>List of mov.model objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one movement model is provided, then the same movement model is used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_err.model">err.model</code></td>
<td>
<p>List of err.model objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one error model is provided, then the same error model is used
for each individual (in which case the names of the <code>err.model</code> components corresponding to easting/longitudinal and northing/latitudinal location error must match <code>coord</code>).</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_activity">activity</code></td>
<td>
<p>List of activity objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one activity covariate is provided, then the same activity covariate is used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_drift">drift</code></td>
<td>
<p>List of drift objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one drift component is provided, then the same drift component is used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_coord">coord</code></td>
<td>
<p>A 2-vector of character values giving the names of the &quot;x&quot; and
&quot;y&quot; coordinates in <code>data</code>. See <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_proj">proj</code></td>
<td>
<p>A list of valid epsg integer codes or proj4string for <code>obsData</code> that does not
inherit either 'sf' or 'sp'. A valid 'crs' list is also accepted. Otherwise, ignored. If only one proj is provided, then the same projection is used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_time.name">Time.name</code></td>
<td>
<p>Character indicating name of the location time column.  See <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_time.scale">time.scale</code></td>
<td>
<p>character. Scale for conversion of POSIX time to numeric for modeling. Defaults to &quot;hours&quot;.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_theta">theta</code></td>
<td>
<p>List of theta objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one theta is provided, then the same starting values are used
for each individual. If theta is not specified, then <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code> default values are used (i.e. each parameter is started at zero).</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_fixpar">fixPar</code></td>
<td>
<p>List of fixPar objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one fixPar is provided, then the same parameters are held fixed to the given value
for each individual. If fixPar is not specified, then no parameters are fixed.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_method">method</code></td>
<td>
<p>Optimization method that is passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_control">control</code></td>
<td>
<p>Control list which is passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_constr">constr</code></td>
<td>
<p>List of constr objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one constr is provided, then the same box constraints for the parameters are used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_prior">prior</code></td>
<td>
<p>List of prior objects (see <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code>) containing an element for each individual. If only one prior is provided, then the same prior is used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_need.hess">need.hess</code></td>
<td>
<p>A logical value which decides whether or not to evaluate
the Hessian for parameter standard errors</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_initialsann">initialSANN</code></td>
<td>
<p>Control list for <code><a href="stats.html#topic+optim">optim</a></code> when simulated
annealing is used for obtaining start values. See details</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_attempts">attempts</code></td>
<td>
<p>The number of times likelihood optimization will be
attempted in cases where the fit does not converge or is otherwise non-valid. Note this is not the same as <code>retryFits</code> because <code>attempts</code> only applies when the current fit clearly does not appear to have converged; <code>retryFits</code> will proceed with additional model fitting attempts regardless of the model output.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_predtime">predTime</code></td>
<td>
<p>List of predTime objects (see <code><a href="crawl.html#topic+crwPredict">crwPredict</a></code>) containing an element for each individual. <code>predTime</code> can 
be specified as an alternative to the automatic sequences generated according to <code>timeStep</code>.  If only one predTime object is provided, then the same prediction times are used
for each individual.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_fillcols">fillCols</code></td>
<td>
<p>Logical indicating whether or not to use the crawl::<code><a href="crawl.html#topic+fillCols">fillCols</a></code> function for filling in missing values in <code>obsData</code> for which
there is a single unique value. Default: FALSE. If the output from <code>crawlWrap</code> is intended for analyses using <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>, 
setting <code>fillCols=TRUE</code> should typically be avoided.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_coordlevel">coordLevel</code></td>
<td>
<p>Character string indicating the level of the hierarchy for the location data. Ignored unless <code>obsData</code> includes a 'level' field.</p>
</td></tr>
<tr><td><code id="crawlWrap_+3A_...">...</code></td>
<td>
<p>Additional arguments that are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Consult <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code> and <code><a href="crawl.html#topic+crwPredict">crwPredict</a></code> for futher details about model fitting and prediction. 
</p>
</li>
<li><p> Note that the names of the list elements corresponding to each individual in <code>mov.model</code>, <code>err.model</code>, <code>activity</code>, <code>drift</code>,
<code>theta</code>, <code>fixPar</code>, <code>constr</code>, <code>prior</code>, and <code>predTime</code> must match the individual IDs in <code>obsData</code>.  If only one element is provided
for any of these arguments, then the same element will be applied to all individuals.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object, i.e. a list of:
</p>
<table>
<tr><td><code>crwFits</code></td>
<td>
<p>A list of <code>crwFit</code> objects returned by crawl::crwMLE. See <code><a href="crawl.html#topic+crwMLE">crwMLE</a></code></p>
</td></tr>
<tr><td><code>crwPredict</code></td>
<td>
<p>A <code>crwPredict</code> data frame with <code>obsData</code> merged with the predicted locations. See <code><a href="crawl.html#topic+crwPredict">crwPredict</a></code>.</p>
</td></tr>
</table>
<p>The <code><a href="#topic+crwData">crwData</a></code> object is used in <code><a href="#topic+MIfitHMM">MIfitHMM</a></code> analyses that account for temporal irregularity or location measurement error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MIfitHMM">MIfitHMM</a></code>, <code><a href="#topic+simData">simData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# extract simulated obsData from example data
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crwMLE models to obsData and predict locations 
# at default intervals for both individuals
crwOut1 &lt;- crawlWrap(obsData=obsData,
         theta=c(4,0),fixPar=c(1,1,NA,NA),
         err.model=err.model,attempts=100)

# Fit the same crwMLE models and predict locations 
# at same intervals but specify for each individual using lists
crwOut2 &lt;- crawlWrap(obsData=obsData,
         theta=list(c(4,0),c(4,0)), fixPar=list(c(1,1,NA,NA),c(1,1,NA,NA)),
         err.model=list(err.model,err.model),
         predTime=list('1'=seq(1,633),'2'=seq(1,686)))

## End(Not run)

</code></pre>

<hr>
<h2 id='crwData'>Constructor of <code>crwData</code> objects</h2><span id='topic+crwData'></span>

<h3>Description</h3>

<p>Constructor of <code>crwData</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crwData(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crwData_+3A_m">m</code></td>
<td>
<p>A list of attributes of crawl output: <code>crwFits</code> (a list of crwFit objects) and <code>crwPredict</code> (a crwPredict object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>crwData</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>

<hr>
<h2 id='crwHierData'>Constructor of <code>crwHierData</code> objects</h2><span id='topic+crwHierData'></span>

<h3>Description</h3>

<p>Constructor of <code>crwHierData</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crwHierData(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crwHierData_+3A_m">m</code></td>
<td>
<p>A list of attributes of crawl output: <code>crwFits</code> (a list of crwFit objects) and <code>crwPredict</code> (a crwPredict object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>crwHierData</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>

<hr>
<h2 id='crwHierSim'>Constructor of <code>crwHierSim</code> objects</h2><span id='topic+crwHierSim'></span>

<h3>Description</h3>

<p>Constructor of <code>crwHierSim</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crwHierSim(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crwHierSim_+3A_m">m</code></td>
<td>
<p>A list of attributes required for multiple imputation data generated from a <code><a href="#topic+crwHierData">crwHierData</a></code> object using <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>: <code>miData</code> (a list of 
<code><a href="#topic+momentuHMMData">momentuHMMData</a></code> objects), and <code>crwSimulator</code> (a list of <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> objects).
</p>
<p><code>crwHierSim</code> objects are returned by <code><a href="#topic+MIfitHMM">MIfitHMM</a></code> when argument <code>miData</code> is a <code><a href="#topic+crwHierData">crwHierData</a></code> object and argument <code>fit=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>crwHierSim</code>.
</p>

<hr>
<h2 id='crwSim'>Constructor of <code>crwSim</code> objects</h2><span id='topic+crwSim'></span>

<h3>Description</h3>

<p>Constructor of <code>crwSim</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crwSim(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crwSim_+3A_m">m</code></td>
<td>
<p>A list of attributes required for multiple imputation data generated from a <code><a href="#topic+crwData">crwData</a></code> object using <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>: <code>miData</code> (a list of 
<code><a href="#topic+momentuHMMData">momentuHMMData</a></code> objects), and <code>crwSimulator</code> (a list of <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> objects).
</p>
<p><code>crwSim</code> objects are returned by <code><a href="#topic+MIfitHMM">MIfitHMM</a></code> when argument <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object and argument <code>fit=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>crwSim</code>.
</p>

<hr>
<h2 id='dbern_rcpp'>Bernoulli density function</h2><span id='topic+dbern_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the Bernoulli distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbern_rcpp(x, prob, foo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbern_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dbern_rcpp_+3A_prob">prob</code></td>
<td>
<p>success probability</p>
</td></tr>
<tr><td><code id="dbern_rcpp_+3A_foo">foo</code></td>
<td>
<p>Unused (for compatibility with template)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dbeta_rcpp'>Probability density function of the beta distribution (written in C++)</h2><span id='topic+dbeta_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the beta distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbeta_rcpp(x, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbeta_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dbeta_rcpp_+3A_shape1">shape1</code></td>
<td>
<p>Shape1</p>
</td></tr>
<tr><td><code id="dbeta_rcpp_+3A_shape2">shape2</code></td>
<td>
<p>Shape2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dcat_rcpp'>Categorical density function</h2><span id='topic+dcat_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the categorical distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcat_rcpp(x, prob, foo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcat_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dcat_rcpp_+3A_prob">prob</code></td>
<td>
<p>success probability</p>
</td></tr>
<tr><td><code id="dcat_rcpp_+3A_foo">foo</code></td>
<td>
<p>Unused (for compatibility with template)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dexp_rcpp'>Exponential density function</h2><span id='topic+dexp_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the exponential distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexp_rcpp(x, rate, foo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dexp_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dexp_rcpp_+3A_rate">rate</code></td>
<td>
<p>Rate</p>
</td></tr>
<tr><td><code id="dexp_rcpp_+3A_foo">foo</code></td>
<td>
<p>Unused (for compatibility with template)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dgamma_rcpp'>Gamma density function</h2><span id='topic+dgamma_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the gamma distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgamma_rcpp(x, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgamma_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dgamma_rcpp_+3A_mu">mu</code></td>
<td>
<p>Mean</p>
</td></tr>
<tr><td><code id="dgamma_rcpp_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='distAngle'>Calculate distance between points y and z and turning angle between points x, y, and z</h2><span id='topic+distAngle'></span>

<h3>Description</h3>

<p>Calculate distance between points y and z and turning angle between points x, y, and z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distAngle(x, y, z, type = "UTM", angleCov = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distAngle_+3A_x">x</code></td>
<td>
<p>location 1</p>
</td></tr>
<tr><td><code id="distAngle_+3A_y">y</code></td>
<td>
<p>location 2</p>
</td></tr>
<tr><td><code id="distAngle_+3A_z">z</code></td>
<td>
<p>location 3</p>
</td></tr>
<tr><td><code id="distAngle_+3A_type">type</code></td>
<td>
<p><code>'UTM'</code> if easting/northing provided (the default), <code>'LL'</code> if longitude/latitude</p>
</td></tr>
<tr><td><code id="distAngle_+3A_anglecov">angleCov</code></td>
<td>
<p>logical indicating to not return NA when x=y or y=z. Default: TRUE (i.e. NA is not returned if x=y or y=z).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in <code><a href="#topic+prepData">prepData</a></code> and <code><a href="#topic+simData">simData</a></code> to get distance and turning angle covariates 
between locations (x1,x2), (y1,y2) and activity center (z1,z2).
</p>
<p>If <code>type='LL'</code> then distance is calculated as great circle distance using <code><a href="sp.html#topic+spDistsN1">spDistsN1</a></code>, and turning angle is calculated based on initial bearings using <code><a href="geosphere.html#topic+bearing">bearing</a></code>.
</p>


<h3>Value</h3>

<p>2-vector with first element the distance between y and z and second element the turning angle
between (x,y) and (y,z).
</p>

<hr>
<h2 id='dlnorm_rcpp'>Log-normal density function</h2><span id='topic+dlnorm_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the log-normal distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlnorm_rcpp(x, meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlnorm_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dlnorm_rcpp_+3A_meanlog">meanlog</code></td>
<td>
<p>Mean of the distribution on the log-scale</p>
</td></tr>
<tr><td><code id="dlnorm_rcpp_+3A_sdlog">sdlog</code></td>
<td>
<p>Standard deviation of the distribution on the log-scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dlogis_rcpp'>logistic density function</h2><span id='topic+dlogis_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the logistic distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogis_rcpp(x, location, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlogis_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dlogis_rcpp_+3A_location">location</code></td>
<td>
<p>mean of the distribution</p>
</td></tr>
<tr><td><code id="dlogis_rcpp_+3A_scale">scale</code></td>
<td>
<p>Dispersion parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dmvnorm_rcpp'>C++ implementation of multivariate Normal probability density function for multiple inputs</h2><span id='topic+dmvnorm_rcpp'></span>

<h3>Description</h3>

<p>C++ implementation of multivariate Normal probability density function for multiple inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm_rcpp(x, mean, varcovM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvnorm_rcpp_+3A_x">x</code></td>
<td>
<p>data matrix of dimension <code>p x n</code>, <code>p</code> being the dimension of the
data and n the number of data points.</p>
</td></tr>
<tr><td><code id="dmvnorm_rcpp_+3A_mean">mean</code></td>
<td>
<p>mean vectors matrix of dimension <code>p x n</code></p>
</td></tr>
<tr><td><code id="dmvnorm_rcpp_+3A_varcovm">varcovM</code></td>
<td>
<p>list of length <code>n</code> of variance-covariance matrices,
each of dimensions <code>p x p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of densities of dimension <code>K x n</code>.
</p>

<hr>
<h2 id='dnbinom_rcpp'>negative binomial density function</h2><span id='topic+dnbinom_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the negative binomial distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnbinom_rcpp(x, mu, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnbinom_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dnbinom_rcpp_+3A_mu">mu</code></td>
<td>
<p>Mean of the distribution</p>
</td></tr>
<tr><td><code id="dnbinom_rcpp_+3A_size">size</code></td>
<td>
<p>Dispersion parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dnorm_rcpp'>Normal density function</h2><span id='topic+dnorm_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the normal distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorm_rcpp(x, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnorm_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dnorm_rcpp_+3A_mean">mean</code></td>
<td>
<p>Mean of the distribution</p>
</td></tr>
<tr><td><code id="dnorm_rcpp_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dpois_rcpp'>Poisson density function</h2><span id='topic+dpois_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the Poisson distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpois_rcpp(x, rate, foo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpois_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dpois_rcpp_+3A_rate">rate</code></td>
<td>
<p>Rate</p>
</td></tr>
<tr><td><code id="dpois_rcpp_+3A_foo">foo</code></td>
<td>
<p>Unused (for compatibility with template)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dt_rcpp'>student t density function</h2><span id='topic+dt_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of non-central student t (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_rcpp(x, df, ncp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dt_rcpp_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="dt_rcpp_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dvm_rcpp'>Von Mises density function</h2><span id='topic+dvm_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the Von Mises distribution, defined as a function
of the modified Bessel function of order 0 (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvm_rcpp(x, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dvm_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dvm_rcpp_+3A_mu">mu</code></td>
<td>
<p>Mean</p>
</td></tr>
<tr><td><code id="dvm_rcpp_+3A_kappa">kappa</code></td>
<td>
<p>Concentration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dweibull_rcpp'>Weibull density function</h2><span id='topic+dweibull_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the Weibull distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dweibull_rcpp(x, shape, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dweibull_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dweibull_rcpp_+3A_shape">shape</code></td>
<td>
<p>Shape</p>
</td></tr>
<tr><td><code id="dweibull_rcpp_+3A_scale">scale</code></td>
<td>
<p>Scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='dwrpcauchy_rcpp'>Wrapped Cauchy density function</h2><span id='topic+dwrpcauchy_rcpp'></span>

<h3>Description</h3>

<p>Probability density function of the wrapped Cauchy distribution (written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwrpcauchy_rcpp(x, mu, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwrpcauchy_rcpp_+3A_x">x</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dwrpcauchy_rcpp_+3A_mu">mu</code></td>
<td>
<p>Mean</p>
</td></tr>
<tr><td><code id="dwrpcauchy_rcpp_+3A_rho">rho</code></td>
<td>
<p>Concentration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of densities
</p>

<hr>
<h2 id='exampleData'>Example dataset</h2><span id='topic+exampleData'></span><span id='topic+example'></span><span id='topic+miExample'></span><span id='topic+forest'></span>

<h3>Description</h3>

<p>These data are used in the examples and tests of
functions to keep them as short as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example

miExample

forest
</code></pre>


<h3>Details</h3>

<p><code>example</code> is a list of the following objects for demonstrating <code><a href="#topic+fitHMM">fitHMM</a></code>:
</p>

<ul>
<li> <p><code>m</code> A <code><a href="#topic+momentuHMM">momentuHMM</a></code> object
</p>
</li>
<li> <p><code>simPar</code> The parameters used to simulate <code>data</code>
</p>
</li>
<li> <p><code>par0</code> The initial parameters in the optimization to fit <code>m</code>
</p>
</li></ul>

<p><code>miExample</code> is a list of the following objects for demonstrating <code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>, and <code><a href="#topic+MIpool">MIpool</a></code>:
</p>

<ul>
<li> <p><code>obsData</code> Simulated observation data with measurement error and temporal irregularity (generated by <code><a href="#topic+simData">simData</a></code>)
</p>
</li>
<li> <p><code>bPar</code> initial parameter estimates for <code>MIfitHMM</code> examples
</p>
</li></ul>

<p><code>forest</code> is a simulated spatial covariate <code><a href="raster.html#topic+raster">raster</a></code> object of the <code>RasterLayer</code> class
</p>

<hr>
<h2 id='expandPar'>Expand vector of free working parameters to vector of all working parameters including any fixed parameters (used in fitHMM.R and nLogLike.R)</h2><span id='topic+expandPar'></span>

<h3>Description</h3>

<p>Expand vector of free working parameters to vector of all working parameters including any fixed parameters (used in fitHMM.R and nLogLike.R)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandPar(
  optPar,
  optInd,
  fixPar,
  wparIndex,
  betaCons,
  deltaCons,
  nbStates,
  nbCovsDelta,
  stationary,
  nbCovs,
  nbRecovs = 0,
  mixtures = 1,
  nbCovsPi = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandPar_+3A_optpar">optPar</code></td>
<td>
<p>vector of free working parameters</p>
</td></tr>
<tr><td><code id="expandPar_+3A_optind">optInd</code></td>
<td>
<p>indices of constrained parameters</p>
</td></tr>
<tr><td><code id="expandPar_+3A_fixpar">fixPar</code></td>
<td>
<p>Vector of working parameters which are assumed known prior to fitting the model (NA indicates parameters is to be estimated)</p>
</td></tr>
<tr><td><code id="expandPar_+3A_wparindex">wparIndex</code></td>
<td>
<p>Vector of indices for the elements of <code>fixPar</code> that are not NA</p>
</td></tr>
<tr><td><code id="expandPar_+3A_betacons">betaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>beta0</code> composed of integers identifying any equality constraints among the t.p.m. parameters.</p>
</td></tr>
<tr><td><code id="expandPar_+3A_deltacons">deltaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>delta0</code> composed of integers identifying any equality constraints among the initial distribution working scale parameters.</p>
</td></tr>
<tr><td><code id="expandPar_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM</p>
</td></tr>
<tr><td><code id="expandPar_+3A_nbcovsdelta">nbCovsDelta</code></td>
<td>
<p>Number of initial distribution covariates</p>
</td></tr>
<tr><td><code id="expandPar_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expandPar_+3A_nbcovs">nbCovs</code></td>
<td>
<p>Number of t.p.m. covariates</p>
</td></tr>
<tr><td><code id="expandPar_+3A_nbrecovs">nbRecovs</code></td>
<td>
<p>Number of recharge covariates</p>
</td></tr>
<tr><td><code id="expandPar_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities</p>
</td></tr>
<tr><td><code id="expandPar_+3A_nbcovspi">nbCovsPi</code></td>
<td>
<p>Number of mixture probability covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of all working parameters including any fixed parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nbStates &lt;- 2
stepDist &lt;- "gamma" # step distribution
angleDist &lt;- "vm" # turning angle distribution

# extract data from momentuHMM example
data &lt;- example$m$data

### 1. fit the model to the simulated data
# define initial values for the parameters
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar &lt;- c(mu0,sigma0) # no zero-inflation, so no zero-mass included
anglePar &lt;- kappa0 # not estimating angle mean, so not included
formula &lt;- ~cov1+cos(cov2)

# constrain cov1 effect to state 1 -&gt; 2 and cov2 effect to state 2 -&gt; 1
fixPar &lt;- list(beta=c(NA,NA,0,NA,0,NA))

m &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar,angle=anglePar),formula=formula,fixPar=fixPar)

# convert free parameter vector (m$mod$wpar) to full set of working parameters (m$mod$estimate)
est &lt;- momentuHMM:::expandPar(m$mod$wpar,m$conditions$optInd,unlist(m$conditions$fixPar),
                              m$conditions$wparIndex,m$conditions$betaCons,m$conditions$deltaCons,
                              nbStates,
                              ncol(m$covsDelta)-1,m$conditions$stationary,nrow(m$mle$beta)-1)

all(est==m$mod$estimate)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitHMM'>Fit a multivariate HMM to the data</h2><span id='topic+fitHMM'></span><span id='topic+fitHMM.momentuHMMData'></span><span id='topic+fitHMM.momentuHierHMMData'></span>

<h3>Description</h3>

<p>Fit a (multivariate) hidden Markov model to the data provided, using numerical optimization of the log-likelihood
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitHMM(data, ...)

## S3 method for class 'momentuHMMData'
fitHMM(
  data,
  nbStates,
  dist,
  Par0,
  beta0 = NULL,
  delta0 = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  formula = ~1,
  formulaDelta = NULL,
  stationary = FALSE,
  mixtures = 1,
  formulaPi = NULL,
  nlmPar = list(),
  fit = TRUE,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  betaRef = NULL,
  deltaCons = NULL,
  mvnCoords = NULL,
  stateNames = NULL,
  knownStates = NULL,
  fixPar = NULL,
  retryFits = 0,
  retrySD = NULL,
  optMethod = "nlm",
  control = list(),
  prior = NULL,
  modelName = NULL,
  ...
)

## S3 method for class 'momentuHierHMMData'
fitHMM(
  data,
  hierStates,
  hierDist,
  Par0,
  hierBeta = NULL,
  hierDelta = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  hierFormula = NULL,
  hierFormulaDelta = NULL,
  mixtures = 1,
  formulaPi = NULL,
  nlmPar = list(),
  fit = TRUE,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  deltaCons = NULL,
  mvnCoords = NULL,
  knownStates = NULL,
  fixPar = NULL,
  retryFits = 0,
  retrySD = NULL,
  optMethod = "nlm",
  control = list(),
  prior = NULL,
  modelName = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitHMM_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> (as returned by <code><a href="#topic+prepData">prepData</a></code> or <code><a href="#topic+simData">simData</a></code>) or a <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> (as returned by <code><a href="#topic+prepData">prepData</a></code> or <code><a href="#topic+simHierData">simHierData</a></code>) object.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams. Currently
supported distributions are 'bern', 'beta', 'cat', exp', 'gamma', 'lnorm', 'logis', 'negbinom', 'norm', 'mvnorm2' (bivariate normal distribution), 'mvnorm3' (trivariate normal distribution),
'pois', 'rw_norm' (normal random walk), 'rw_mvnorm2' (bivariate normal random walk), 'rw_mvnorm3' (trivariate normal random walk), 'vm', 'vmConsensus', 'weibull', and 'wrpcauchy'. For example,
<code>dist=list(step='gamma', angle='vm', dives='pois')</code> indicates 3 data streams ('step', 'angle', and 'dives')
and their respective probability distributions ('gamma', 'vm', and 'pois').  The names of the data streams 
(e.g., 'step', 'angle', 'dives') must match component names in <code>data</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_par0">Par0</code></td>
<td>
<p>A named list containing vectors of initial state-dependent probability distribution parameters for 
each data stream specified in <code>dist</code>. The parameters should be in the order expected by the pdfs of <code>dist</code>, 
and any zero-mass and/or one-mass parameters should be the last (if both are present, then zero-mass parameters must preceed one-mass parameters). 
Note that zero-mass parameters are mandatory if there are zeros in 
data streams with a 'gamma','weibull','exp','lnorm', or 'beta' distribution, and one-mass parameters are mandatory if there are ones in 
data streams with a 'beta' distribution.
For example, for a 2-state model using the Von Mises (vm) distribution for a data stream named 'angle' and 
the zero-inflated gamma distribution for a data stream named 'step', the vector of initial parameters would be something like: 
<code>Par0=list(step=c(mean_1,mean_2,sd_1,sd_2,zeromass_1,zeromass_2), angle=c(mean_1,mean_2,concentration_1,concentration_2))</code>.
</p>
<p>If <code>DM</code> is not specified for a given data stream, then <code>Par0</code> is on the natural (i.e., real) scale of the parameters.  
However, if <code>DM</code> is specified for a given data stream, then <code>Par0</code> must be on the working (i.e., beta) scale of the 
parameters, and the length of <code>Par0</code> must match the number of columns in the design matrix.  See details below.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_beta0">beta0</code></td>
<td>
<p>Initial matrix of regression coefficients for the transition probabilities (more
information in 'Details').
Default: <code>NULL</code>. If not specified, <code>beta0</code> is initialized such that the diagonal elements
of the transition probability matrix are dominant.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_delta0">delta0</code></td>
<td>
<p>Initial value for the initial distribution of the HMM. Default: <code>rep(1/nbStates,nbStates)</code>. If <code>formulaDelta</code> includes a formula, then <code>delta0</code> must be specified
as a k x (<code>nbStates</code>-1) matrix, where k is the number of covariates and the columns correspond to states 2:<code>nbStates</code>. See details below.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>An optional named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy'). For example, <code>estAngleMean=list(angle=TRUE)</code> indicates the angle mean is to be 
estimated for 'angle'.  Default is <code>NULL</code>, which assumes any angle means are fixed to zero and are not to be estimated. 
Any <code>estAngleMean</code> elements corresponding to data streams that do not have angular distributions are ignored.
<code>estAngleMean</code> is also ignored for any 'vmConsensus' data streams (because the angle mean must be estimated in consensus models).</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>An optional named list indicating whether to use circular-linear (FALSE) or circular-circular (TRUE) 
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles.  For example, 
<code>circularAngleMean=list(angle=TRUE)</code> indicates the angle mean is be estimated for 'angle' using circular-circular 
regression.  Whenever circular-circular regression is used for an angular data stream, a corresponding design matrix (<code>DM</code>) 
must be specified for the data stream, and the previous movement direction (i.e., a turning angle of zero) is automatically used 
as the reference angle (i.e., the intercept). Any circular-circular regression covariates in <code>data</code> should therefore be relative to the previous 
direction of movement (instead of standard directions relative to the x-axis; see <code><a href="#topic+prepData">prepData</a></code> and <code><a href="#topic+circAngles">circAngles</a></code>).  See Duchesne et al. (2015) for specifics on the circular-circular regression model 
using previous movement direction as the reference angle. Default is <code>NULL</code>, which assumes circular-linear regression is 
used for any angular distributions for which the mean angle is to be estimated. <code>circularAngleMean</code> elements corresponding to angular data 
streams are ignored unless the corresponding element of <code>estAngleMean</code> is <code>TRUE</code>. Any <code>circularAngleMean</code> elements 
corresponding to data streams that do not have angular distributions are ignored. <code>circularAngleMean</code> is also ignored for any 'vmConsensus' data streams (because the consensus model is a circular-circular regression model).
</p>
<p>Alternatively, <code>circularAngleMean</code> can be specified as a numeric scalar, where the value specifies the coefficient for the reference angle (i.e., directional persistence) term in the circular-circular regression model. For example, setting <code>circularAngleMean</code> to <code>0</code> specifies a 
circular-circular regression model with no directional persistence term (thus specifying a biased random walk instead of a biased correlated random walk). Setting <code>circularAngleMean</code> to 1 is equivalent to setting it to TRUE, i.e., a circular-circular regression model with a coefficient of 1 for the directional persistence reference angle.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates. Default: <code>~1</code> (no covariate effect). In addition to allowing standard functions in R formulas
(e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>), special functions include <code>cosinor(cov,period)</code> for modeling cyclical patterns, spline functions 
(<code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines2.html#topic+bSpline">bSpline</a></code>, <code><a href="splines2.html#topic+cSpline">cSpline</a></code>, <code><a href="splines2.html#topic+iSpline">iSpline</a></code>, and <code><a href="splines2.html#topic+mSpline">mSpline</a></code>),
and state- or parameter-specific formulas (see details).
Any formula terms that are not state- or parameter-specific are included on all of the transition probabilities.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_formuladelta">formulaDelta</code></td>
<td>
<p>Regression formula for the initial distribution. Default for <code>fitHMM.momentuHMMData</code>: <code>NULL</code> (no covariate effects; both <code>delta0</code> and <code>fixPar$delta</code> are specified on the real scale). 
Default for <code>fitHMM.momentuHierHMMData</code>: <code>~1</code> (both <code>delta0</code> and <code>fixPar$delta</code> are specified on the working scale).
Standard functions in R formulas are allowed (e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>). When any formula is provided, then both <code>delta0</code> and <code>fixPar$delta</code> are specified on the working scale.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities  (i.e. discrete random effects *sensu* DeRuiter et al. 2017). Default: <code>mixtures=1</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_formulapi">formulaPi</code></td>
<td>
<p>Regression formula for the mixture distribution probabilities. Default: <code>NULL</code> (no covariate effects; both <code>beta0$pi</code> and <code>fixPar$pi</code> are specified on the real scale). Standard functions in R formulas are allowed (e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>). When any formula is provided, then both <code>beta0$pi</code> and <code>fixPar$pi</code> are specified on the working scale.
Note that only the covariate values from the first row for each individual ID in <code>data</code> are used (i.e. time-varying covariates cannot be used for the mixture probabilities).</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_nlmpar">nlmPar</code></td>
<td>
<p>List of parameters to pass to the optimization function <code><a href="stats.html#topic+nlm">nlm</a></code> (which should be either
<code>print.level</code>, <code>gradtol</code>, <code>stepmax</code>, <code>steptol</code>, <code>iterlim</code>, or <code>hessian</code> &ndash; see <code>nlm</code>'s documentation
for more detail). For <code>print.level</code>, the default value of 0 means that no
printing occurs, a value of 1 means that the first and last iterations of the optimization are
detailed, and a value of 2 means that each iteration of the optimization is detailed. Ignored unless <code>optMethod="nlm"</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_fit">fit</code></td>
<td>
<p><code>TRUE</code> if an HMM should be fitted to the data, <code>FALSE</code> otherwise.
If fit=<code>FALSE</code>, a model is returned with the MLE replaced by the initial parameters given in
input. This option can be used to assess the initial parameters, parameter bounds, etc. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. Each element of <code>DM</code> can either be a named list of linear regression formulas or a &ldquo;pseudo&rdquo; design matrix.  For example, for a 2-state 
model using the gamma distribution for a data stream named 'step', <code>DM=list(step=list(mean=~cov1, sd=~1))</code> specifies the mean 
parameters as a function of the covariate 'cov1' for each state.  This model could equivalently be specified as a 4x6 &ldquo;pseudo&rdquo; design matrix using 
character strings for the covariate: 
<code>DM=list(step=matrix(c(1,0,0,0,'cov1',0,0,0,0,1,0,0,0,'cov1',0,0,0,0,1,0,0,0,0,1),4,6))</code>
where the 4 rows correspond to the state-dependent paramaters (mean_1,mean_2,sd_1,sd_2) and the 6 columns correspond to the regression 
coefficients. 
</p>
<p>Design matrices specified using formulas allow standard functions in R formulas
(e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>).  Special formula functions include <code>cosinor(cov,period)</code> for modeling cyclical patterns, spline functions 
(<code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines2.html#topic+bSpline">bSpline</a></code>, <code><a href="splines2.html#topic+cSpline">cSpline</a></code>, <code><a href="splines2.html#topic+iSpline">iSpline</a></code>, and <code><a href="splines2.html#topic+mSpline">mSpline</a></code>), 
<code>angleFormula(cov,strength,by)</code> for the angle mean of circular-circular regression models, and state-specific formulas (see details). Any formula terms that are not state-specific are included on the parameters for all <code>nbStates</code> states.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream. For each matrix, the first column pertains to the lower bound and the second column the upper bound. For example, for a 2-state model using the wrapped Cauchy ('wrpcauchy') distribution for 
a data stream named 'angle' with <code>estAngleMean$angle=TRUE)</code>, <code>userBounds=list(angle=matrix(c(-pi,-pi,-1,-1,pi,pi,1,1),4,2,dimnames=list(c("mean_1",
"mean_2","concentration_1","concentration_2"))))</code> 
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters. For each matrix, the first column pertains to the lower bound and the second column the upper bound.
For data streams, each element of <code>workBounds</code> should be a k x 2 matrix with the same name of the corresponding element of 
<code>Par0</code>, where k is the number of parameters. For transition probability parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;beta&rdquo;, where k=<code>length(beta0)</code>. For initial distribution parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;delta&rdquo;, where k=<code>length(delta0)</code>.
<code>workBounds</code> is ignored for any given data stream unless <code>DM</code> is also specified.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_betacons">betaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>beta0</code> composed of integers identifying any equality constraints among the t.p.m. parameters. See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_betaref">betaRef</code></td>
<td>
<p>Numeric vector of length <code>nbStates</code> indicating the reference elements for the t.p.m. multinomial logit link. Default: NULL, in which case
the diagonal elements of the t.p.m. are the reference. See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_deltacons">deltaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>delta0</code> composed of integers identifying any equality constraints among the initial distribution working scale parameters. Ignored unless a formula is provided in <code>formulaDelta</code>. See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_mvncoords">mvnCoords</code></td>
<td>
<p>Character string indicating the name of location data that are to be modeled using a multivariate normal distribution. For example, if <code>mu="mvnorm2"</code> was included in <code>dist</code> and (mu.x, mu.y) are location data, 
then <code>mvnCoords="mu"</code> needs to be specified in order for these data to be properly treated as locations in functions such as <code><a href="#topic+plot.momentuHMM">plot.momentuHMM</a></code>, <code><a href="#topic+plot.miSum">plot.miSum</a></code>, <code><a href="#topic+plot.miHMM">plot.miHMM</a></code>, <code><a href="#topic+plotSpatialCov">plotSpatialCov</a></code>, and <code><a href="#topic+MIpool">MIpool</a></code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length nbStates indicating state names.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_knownstates">knownStates</code></td>
<td>
<p>Vector of values of the state process which are known prior to fitting the
model (if any). Default: NULL (states are not known). This should be a vector with length the number
of rows of 'data'; each element should either be an integer (the value of the known states) or NA if
the state is not known.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_fixpar">fixPar</code></td>
<td>
<p>An optional list of vectors indicating parameters which are assumed known prior to fitting the model. Default: NULL 
(no parameters are fixed). For data streams, each element of <code>fixPar</code> should be a vector of the same name and length as the corresponding element of <code>Par0</code>. 
For transition probability parameters, the corresponding element of <code>fixPar</code> must be named &ldquo;beta&rdquo; and have the same dimensions as <code>beta0</code>. 
For initial distribution parameters, the corresponding element of <code>fixPar</code> must be named &ldquo;delta&rdquo; and have the same dimensions as <code>delta0</code>. 
Each parameter should either be numeric (the fixed value of the parameter) or NA if the parameter is to be estimated. Corresponding <code>fixPar</code> parameters must be on the same scale as <code>Par0</code> (e.g. if <code>DM</code> is specified for a given data stream, any fixed parameters for this data stream must be on the working scale), <code>beta0</code>, and <code>delta0</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_retryfits">retryFits</code></td>
<td>
<p>Non-negative integer indicating the number of times to attempt to iteratively fit the model using random perturbations of the current parameter estimates as the 
initial values for likelihood optimization. Normal(0,<code>retrySD</code>^2) perturbations are used on the working scale parameters. Default: 0.  When <code>retryFits&gt;0</code>, the model with the largest log likelihood 
value is returned. Ignored if <code>fit=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_retrysd">retrySD</code></td>
<td>
<p>An optional list of scalars or vectors indicating the standard deviation to use for normal perturbations of each working scale parameter when <code>retryFits&gt;0</code>. For data streams, each element of <code>retrySD</code> should be a vector of the same name and length as the corresponding element of <code>Par0</code> (if a scalar is provided, then this value will be used for all working parameters of the data stream). 
For transition probability parameters, the corresponding element of <code>retrySD</code> must be named &ldquo;beta&rdquo; and have the same dimensions as <code>beta0</code>. 
For initial distribution parameters, the corresponding element of <code>retrySD</code> must be named &ldquo;delta&rdquo; and have the same dimensions as <code>delta0</code> (if <code>delta0</code> is on the working scale) or be of length <code>nbStates-1</code> (if <code>delta0</code> is on the natural scale).
Alternatively <code>retrySD</code> can be a scalar, in which case this value is used for all parameters.
Default: NULL (in which case <code>retrySD</code>=1 for data stream parameters and <code>retrySD</code>=10 for initial distribution and state transition probabilities). Ignored unless <code>retryFits&gt;0</code>.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_optmethod">optMethod</code></td>
<td>
<p>The optimization method to be used.  Can be &ldquo;nlm&rdquo; (the default; see <code><a href="stats.html#topic+nlm">nlm</a></code>), &ldquo;Nelder-Mead&rdquo; (see <code><a href="stats.html#topic+optim">optim</a></code>), or &ldquo;SANN&rdquo; (see <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code> (ignored unless <code>optMethod="Nelder-Mead"</code> or <code>optMethod="SANN"</code>).</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_prior">prior</code></td>
<td>
<p>A function that returns the log-density of the working scale parameter prior distribution(s). See 'Details'.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_modelname">modelName</code></td>
<td>
<p>An optional character string providing a name for the fitted model. If provided, <code>modelName</code> will be returned in <code><a href="#topic+print.momentuHMM">print.momentuHMM</a></code>, <code><a href="#topic+AIC.momentuHMM">AIC.momentuHMM</a></code>, <code><a href="#topic+AICweights">AICweights</a></code>, and other functions.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states ('state').  See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams ('dist'). See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the transition probabilities at each level of the hierarchy ('beta'). See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierdelta">hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the initial distribution at each level of the hierarchy ('delta'). See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy ('formula'). Default: <code>NULL</code> (only hierarchical-level effects, with no covariate effects).
Any formula terms that are not state- or parameter-specific are included on all of the transition probabilities within a given level of the hierarchy. See details.</p>
</td></tr>
<tr><td><code id="fitHMM_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> By default the matrix <code>beta0</code> of regression coefficients for the transition probabilities has
one row for the intercept, plus one row for each covariate, and one column for
each non-diagonal element of the transition probability matrix. For example, in a 3-state
HMM with 2 <code>formula</code> covariates, the matrix <code>beta</code> has three rows (intercept + two covariates)
and six columns (six non-diagonal elements in the 3x3 transition probability matrix -
filled in row-wise).
In a covariate-free model (default), <code>beta0</code> has one row, for the intercept. While the diagonal elements are by default the reference elements, other elements can serve as the reference
using the <code>betaRef</code> argument. For example, in a 3-state model, setting <code>betaRef=c(3,2,3)</code> changes the reference elements to state transition 1 -&gt; 3 for state 1 (instead of 1 -&gt; 1), state
transition 2 -&gt; 2 for state 2 (same as default), and state transition 3 -&gt; 3 for state 3 (same as default).
</p>
</li>
<li><p> When covariates are not included in <code>formulaDelta</code> (i.e. <code>formulaDelta=NULL</code>), then <code>delta0</code> (and <code>fixPar$delta</code>) are specified as a vector of length <code>nbStates</code> that 
sums to 1.  When any formula is specified for <code>formulaDelta</code> (e.g. <code>formulaDelta=~1</code>, <code>formulaDelta=~cov1</code>), then <code>delta0</code>  (and <code>fixPar$delta</code>) must be specified
as a k x (<code>nbStates</code>-1) matrix of working parameters, where k is the number of regression coefficients and the columns correspond to states 2:<code>nbStates</code>. For example, in a 3-state
HMM with <code>formulaDelta=~cov1+cov2</code>, the matrix <code>delta0</code> has three rows (intercept + two covariates)
and 2 columns (corresponding to states 2 and 3). The initial distribution working parameters are transformed to the real scale as <code>exp(covsDelta*Delta)/rowSums(exp(covsDelta*Delta))</code>, where <code>covsDelta</code> is the N x k design matrix, <code>Delta=cbind(rep(0,k),delta0)</code> is a k x <code>nbStates</code> matrix of working parameters,
and <code>N=length(unique(data$ID))</code>.
</p>
</li>
<li><p> The choice of initial parameters (particularly <code>Par0</code> and <code>beta0</code>) is crucial to fit a model. The algorithm might not find
the global optimum of the likelihood function if the initial parameters are poorly chosen.
</p>
</li>
<li><p> If <code>DM</code> is specified for a particular data stream, then the initial values are specified on 
the working (i.e., beta) scale of the parameters. The working scale of each parameter is determined by the link function used.
If a parameter P is bound by (0,Inf) then the working scale is the log(P) scale.  If the parameter bounds are (-pi,pi) then the working 
scale is tan(P/2) unless circular-circular regression is used. Otherwise if the parameter bounds are finite then logit(P) is the working scale. However, when both 
zero- and one-inflation are included, then a multinomial logit link is used because the sum of the zeromass and onemass probability parameters cannot exceed 1.
The function <code><a href="#topic+getParDM">getParDM</a></code> is intended to help with obtaining initial values on the working scale when specifying a design matrix and other 
parameter constraints (see example below). When circular-circular regression is specified using <code>circularAngleMean</code>, the working scale 
for the mean turning angle is not as easily interpretable, but the 
link function is atan2(sin(X)*B,1+cos(X)*B), where X are the angle covariates and B the angle coefficients (see Duchesne et al. 2015). 
Under this formulation, the reference turning angle is 0 (i.e., movement in the same direction as the previous time step). 
In other words, the mean turning angle is zero when the coefficient(s) B=0.
</p>
</li>
<li><p> Circular-circular regression in <code>momentuHMM</code> is designed for turning angles (not bearings) as computed by <code><a href="#topic+simData">simData</a></code> and <code><a href="#topic+prepData">prepData</a></code>. 
Any circular-circular regression angle covariates for time step t should therefore be relative to the previous 
direction of movement for time step t-1.  In other words, circular-circular regression covariates for time step t should be the turning angle
between the direction of movement for time step t-1 and the standard direction of the covariate relative to the x-axis for time step t.  If provided standard directions in radians relative to the x-axis 
(where 0 = east, pi/2 = north, pi = west, and -pi/2 = south), <code><a href="#topic+circAngles">circAngles</a></code> or <code><a href="#topic+prepData">prepData</a></code> can perform this calculation for you.  
</p>
<p>When the circular-circular regression model is used, the special function <code>angleFormula(cov,strength,by)</code> can be used in <code>DM</code> for the mean of angular distributions (i.e. 'vm', 'vmConsensus', and 'wrpcauchy'),
where <code>cov</code> is an angle covariate (e.g. wind direction), <code>strength</code> is an optional positive real covariate (e.g. wind speed), and <code>by</code> is an optional factor variable for individual- or group-level effects (e.g. ID, sex). The <code>strength</code> argument allows angle covariates to be weighted based on their relative strength or importance at time step t as in
Rivest et al. (2016).  In this case, the link function for the mean angle is atan2((Z * sin(X)) %*% B,1+(Z * cos(X)) %*% B), where X are the angle covariates, Z the strength covariates, and B the angle coefficients (see Rivest et al. 2016). 
</p>
</li>
<li><p> State-specific formulas can be specified in <code>DM</code> using special formula functions. These special functions can take
the names <code>paste0("state",1:nbStates)</code> (where the integer indicates the state-specific formula).  For example, 
<code>DM=list(step=list(mean=~cov1+state1(cov2),sd=~cov2+state2(cov1)))</code> includes <code>cov1</code> on the mean parameter for all states, <code>cov2</code>
on the mean parameter for state 1, <code>cov2</code> on the sd parameter for all states, and <code>cov1</code> on the sd parameter for state 2.
</p>
</li>
<li><p> State- and parameter-specific formulas can be specified for transition probabilities in <code>formula</code> using special formula functions.
These special functions can take the names <code>paste0("state",1:nbStates)</code> (where the integer indicates the current state from which transitions occur),
<code>paste0("toState",1:nbStates)</code> (where the integer indicates the state to which transitions occur),
or <code>paste0("betaCol",nbStates*(nbStates-1))</code> (where the integer indicates the column of the <code>beta</code> matrix).  For example with <code>nbStates=3</code>,
<code>formula=~cov1+betaCol1(cov2)+state3(cov3)+toState1(cov4)</code> includes <code>cov1</code> on all transition probability parameters, <code>cov2</code> on the <code>beta</code> column corresponding
to the transition from state 1-&gt;2, <code>cov3</code> on transition probabilities from state 3 (i.e., <code>beta</code> columns corresponding to state transitions 3-&gt;1 and 3-&gt;2),
and <code>cov4</code> on transition probabilities to state 1 (i.e., <code>beta</code> columns corresponding to state transitions 2-&gt;1 and 3-&gt;1).
</p>
</li>
<li> <p><code>betaCons</code> can be used to impose equality constraints among the t.p.m. parameters.  It must be a matrix of the same dimension as <code>beta0</code> and be composed of integers, where each beta parameter is sequentially indexed in a column-wise fashion (see <code><a href="#topic+checkPar0">checkPar0</a></code>). Parameter indices in <code>betaCons</code> must therefore be integers between <code>1</code> and <code>nbStates*(nbStates-1)</code>. 
</p>
<p>Use of <code>betaCons</code> is perhaps best demonstrated by example.  If no constraints are imposed (the default), then <code>betaCons=matrix(1:length(beta0),nrow(beta0),ncol(beta0))</code> such that
each beta parameter is (column-wise) sequentially identified by a unique integer.  Suppose we wish to fit a model with <code>nbStates=3</code> states and a covariate (&lsquo;cov1&rsquo;) on the t.p.m. With no constraints on the t.p.m., we would have
<code>betaCons=matrix(1:(2*(nbStates*(nbStates-1))),nrow=2,ncol=nbStates*(nbStates-1),dimnames=list(c("(Intercept)","cov1"),c("1 -&gt; 2","1 -&gt; 3","2 -&gt; 1","2 -&gt; 3","3 -&gt; 1","3 -&gt; 2")))</code>.  If we then wanted to constrain the t.p.m. such that the covariate effect is identical for transitions from state 1 to states 2 and 3 (and vice versa), we have
<code>betaCons=matrix(c(1,2,3,2,5,6,7,8,9,6,11,12),nrow=2,ncol=nbStates*(nbStates-1),dimnames=list(c("(Intercept)","cov1"),c("1 -&gt; 2","1 -&gt; 3","2 -&gt; 1","2 -&gt; 3","3 -&gt; 1","3 -&gt; 2")))</code>; this results in 10 estimated beta parameters (instead of 12), the &ldquo;cov1&rdquo; effects indexed by a &ldquo;2&rdquo; (&ldquo;1 -&gt; 2&rdquo; and &ldquo;1 -&gt; 3&rdquo;) constrained to be equal, and 
the &ldquo;cov1&rdquo; effects indexed by a &ldquo;6&rdquo; (&ldquo;2 -&gt; 1&rdquo; and &ldquo;3 -&gt; 1&rdquo;) constrained to be equal. 
</p>
<p>Now suppose we instead wish to constrain these sets of state transition probabilities to be equal, i.e., Pr(1 -&gt; 2) = Pr(1 -&gt; 3) and Pr(2 -&gt; 1) = Pr(3 -&gt; 1); then we have <code>betaCons=matrix(c(1,2,1,2,5,6,7,8,5,6,11,12),nrow=2,ncol=nbStates*(nbStates-1),dimnames=list(c("(Intercept)","cov1"),c("1 -&gt; 2","1 -&gt; 3","2 -&gt; 1","2 -&gt; 3","3 -&gt; 1","3 -&gt; 2")))</code>
</p>
</li>
<li><p> Cyclical relationships (e.g., hourly, monthly) may be modeled in <code>DM</code> or <code>formula</code> using the <code>cosinor(x,period)</code> special formula function for covariate <code>x</code>
and sine curve period of time length <code>period</code>. For example, if 
the data are hourly, a 24-hour cycle can be modeled using <code>~cosinor(cov1,24)</code>, where the covariate <code>cov1</code> is a repeating sequential series
of integers indicating the hour of day (<code>0,1,...,23,0,1,...,23,0,1,...</code>) (note that <code>fitHMM</code> will not do this for you, the appropriate covariate must be included in <code>data</code>; see example below). 
The <code>cosinor(x,period)</code> function converts <code>x</code> to 2 covariates <code>cosinorCos(x)=cos(2*pi*x/period)</code> and <code>cosinorSin(x)=sin(2*pi*x/period</code> for inclusion in the model (i.e., 2 additional parameters per state). The amplitude of the sine wave
is thus <code>sqrt(B_cos^2 + B_sin^2)</code>, where <code>B_cos</code> and <code>B_sin</code> are the working parameters correponding to <code>cosinorCos(x)</code> and <code>cosinorSin(x)</code>, respectively (e.g., see Cornelissen 2014).
</p>
</li>
<li><p> Similar to that used in <code><a href="#topic+crawlWrap">crawlWrap</a></code>, the <code>prior</code> argument is a user-specified function that returns the log-density of the working scale parameter prior distribution(s). In addition to including prior information about parameters, one area where priors can be particularly useful is for handling numerical issues that can arise when parameters are near a boundary. 
When parameters are near boundaries, they can wander into the &ldquo;nether regions&rdquo; of the parameter space during optimization. For example, setting <code>prior=function(par) {sum(dnorm(par,0,sd,log=TRUE))}</code> with a reasonably large <code>sd</code> (e.g. 100 or 1000) can help prevent working parameters 
from straying too far along the real line.  Here <code>par</code> is the vector of working scale parameters (as returned by <code>fitHMM</code>, e.g., see <code>example$m$mod$estimate</code>) in the following order: data stream working parameters (in order <code>names(dist)</code>), beta working parameters, and delta working parameters. Instead of specifying the same prior on all parameters, different priors could be specified on different parameters (and not all parameters must have user-specified priors).  For example,
<code>prior=function(par){dnorm(par[3],0,100,log=TRUE)}</code> would only specify a prior for the third working parameter. Note that the <code>prior</code> function must return a scalar on the log scale. See 'harbourSealExample.R' in the &ldquo;vignettes&rdquo; source directory for an example using the <code>prior</code> argument.
</p>
</li></ul>


<ul>
<li> <p><code>fitHMM.momentuHierHMMData</code> is very similar to <code><a href="#topic+fitHMM.momentuHMMData">fitHMM.momentuHMMData</a></code> except that instead of simply specifying the number of states (<code>nbStates</code>), distributions (<code>dist</code>), and a single t.p.m. formula (<code>formula</code>), the <code>hierStates</code> argument specifies the hierarchical nature of the states,
the <code>hierDist</code> argument specifies the hierarchical nature of the data streams, and the <code>hierFormula</code> argument specifies a t.p.m. formula for each level of the hierarchy.  All are specified as 
<code><a href="data.tree.html#topic+Node">Node</a></code> objects from the <code><a href="data.tree.html#topic+data.tree">data.tree</a></code> package.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object, i.e. a list of:
</p>
<table>
<tr><td><code>mle</code></td>
<td>
<p>A named list of the maximum likelihood estimates of the parameters of the model (if the numerical algorithm
has indeed identified the global maximum of the likelihood function). Elements are included for the parameters of each
data strea, as well as <code>beta</code> (transition probabilities regression coefficients - more information
in 'Details'), <code>gamma</code> (transition probabilities on real scale, based on mean covariate values if <code>formula</code>
includes covariates), and <code>delta</code> (initial distribution).</p>
</td></tr>
<tr><td><code>CIreal</code></td>
<td>
<p>Standard errors and 95% confidence intervals on the real (i.e., natural) scale of parameters</p>
</td></tr>
<tr><td><code>CIbeta</code></td>
<td>
<p>Standard errors and 95% confidence intervals on the beta (i.e., working) scale of parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The momentuHMMData or momentuHierHMMData object</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>List object returned by the numerical optimizer <code>nlm</code> or <code>optim</code>. Items in <code>mod</code> include the best set of free working parameters found (<code>wpar</code>), 
the best full set of working parameters including any fixed parameters (<code>estimate</code>), the value of the likelihood at <code>estimate</code> (<code>minimum</code>), 
the estimated variance-covariance matrix at <code>estimate</code> (<code>Sigma</code>), and the elapsed time in seconds for the optimization (<code>elapsedTime</code>).</p>
</td></tr>
<tr><td><code>conditions</code></td>
<td>
<p>Conditions used to fit the model, e.g., <code>bounds</code> (parameter bounds), distributions, <code>zeroInflation</code>,
<code>estAngleMean</code>, <code>stationary</code>, <code>formula</code>, <code>DM</code>, <code>fullDM</code> (full design matrix), etc.</p>
</td></tr>
<tr><td><code>rawCovs</code></td>
<td>
<p>Raw covariate values for transition probabilities, as found in the data (if any). Used in <code><a href="#topic+plot.momentuHMM">plot.momentuHMM</a></code>.</p>
</td></tr>
<tr><td><code>stateNames</code></td>
<td>
<p>The names of the states.</p>
</td></tr>
<tr><td><code>knownStates</code></td>
<td>
<p>Vector of values of the state process which are known.</p>
</td></tr>
<tr><td><code>covsDelta</code></td>
<td>
<p>Design matrix for initial distribution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cornelissen, G. 2014. Cosinor-based rhythmometry. Theoretical Biology and Medical Modelling 11:16.
</p>
<p>Duchesne, T., Fortin, D., Rivest L-P. 2015. Equivalence between step selection functions and 
biased correlated random walks for statistical inference on animal movement. PLoS ONE 10 (4):
e0122947.
</p>
<p>Langrock R., King R., Matthiopoulos J., Thomas L., Fortin D., Morales J.M. 2012.
Flexible and practical modeling of animal telemetry data: hidden Markov models and extensions.
Ecology, 93 (11), 2336-2342.
</p>
<p>Leos-Barajas, V., Gangloff, E.J., Adam, T., Langrock, R., van Beest, F.M., Nabe-Nielsen, J. and Morales, J.M. 2017. 
Multi-scale modeling of animal movement and general behavior data using hidden Markov models with hierarchical structures. 
Journal of Agricultural, Biological and Environmental Statistics, 22 (3), 232-248.
</p>
<p>Maruotti, A., and T. Ryden. 2009. A semiparametric approach to hidden Markov models under longitudinal 
observations. Statistics and Computing 19: 381-393.
</p>
<p>McClintock B.T., King R., Thomas L., Matthiopoulos J., McConnell B.J., Morales J.M. 2012. A general 
discrete-time modeling framework for animal movement using multistate random walks. Ecological 
Monographs, 82 (3), 335-349.
</p>
<p>McClintock B.T., Russell D.J., Matthiopoulos J., King R. 2013. Combining individual animal movement 
and ancillary biotelemetry data to investigate population-level activity budgets. Ecology, 94 (4), 838-849.
</p>
<p>Patterson T.A., Basson M., Bravington M.V., Gunn J.S. 2009.
Classifying movement behaviour in relation to environmental conditions using hidden Markov models.
Journal of Animal Ecology, 78 (6), 1113-1123.
</p>
<p>Rivest, LP, Duchesne, T, Nicosia, A, Fortin, D, 2016. A general angular regression model for the analysis of data on animal movement in ecology. 
Journal of the Royal Statistical Society: Series C (Applied Statistics), 65(3):445-463.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParDM">getParDM</a></code>, <code><a href="#topic+prepData">prepData</a></code>, <code><a href="#topic+simData">simData</a></code>
</p>
<p><code><a href="#topic+simHierData">simHierData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nbStates &lt;- 2
stepDist &lt;- "gamma" # step distribution
angleDist &lt;- "vm" # turning angle distribution

# extract data from momentuHMM example
data &lt;- example$m$data

### 1. fit the model to the simulated data
# define initial values for the parameters
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar &lt;- c(mu0,sigma0) # no zero-inflation, so no zero-mass included
anglePar &lt;- kappa0 # not estimating angle mean, so not included
formula &lt;- ~cov1+cos(cov2)

m &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar,angle=anglePar),formula=formula)

print(m)

## Not run: 
### 2. fit the exact same model to the simulated data using DM formulas
# Get initial values for the parameters on working scale
Par0 &lt;- getParDM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
        Par=list(step=stepPar,angle=anglePar),
        DM=list(step=list(mean=~1,sd=~1),angle=list(concentration=~1)))

mDMf &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
              Par0=Par0,formula=formula,
              DM=list(step=list(mean=~1,sd=~1),angle=list(concentration=~1)))

print(mDMf)

### 3. fit the exact same model to the simulated data using DM matrices
# define DM
DMm &lt;- list(step=diag(4),angle=diag(2))

# user-specified dimnames not required but are recommended
dimnames(DMm$step) &lt;- list(c("mean_1","mean_2","sd_1","sd_2"),
                   c("mean_1:(Intercept)","mean_2:(Intercept)",
                   "sd_1:(Intercept)","sd_2:(Intercept)"))
dimnames(DMm$angle) &lt;- list(c("concentration_1","concentration_2"),
                    c("concentration_1:(Intercept)","concentration_2:(Intercept)"))
                  
mDMm &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
              Par0=Par0,formula=formula,
              DM=DMm)

print(mDMm)

### 4. fit step mean parameter covariate model to the simulated data using DM
stepDMf &lt;- list(mean=~cov1,sd=~1)
Par0 &lt;- getParDM(data,nbStates,list(step=stepDist,angle=angleDist),
                 Par=list(step=stepPar,angle=anglePar),
                 DM=list(step=stepDMf,angle=DMm$angle))
mDMfcov &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
              Par0=Par0,
              formula=formula,
              DM=list(step=stepDMf,angle=DMm$angle))

print(mDMfcov)

### 5. fit the exact same step mean parameter covariate model using DM matrix
stepDMm &lt;- matrix(c(1,0,0,0,"cov1",0,0,0,0,1,0,0,0,"cov1",0,0,
                 0,0,1,0,0,0,0,1),4,6,dimnames=list(c("mean_1","mean_2","sd_1","sd_2"),
                 c("mean_1:(Intercept)","mean_1:cov1","mean_2:(Intercept)","mean_2:cov1",
                 "sd_1:(Intercept)","sd_2:(Intercept)")))
Par0 &lt;- getParDM(data,nbStates,list(step=stepDist,angle=angleDist),
                 Par=list(step=stepPar,angle=anglePar),
                 DM=list(step=stepDMm,angle=DMm$angle))
mDMmcov &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
              Par0=Par0,
              formula=formula,
              DM=list(step=stepDMm,angle=DMm$angle))

print(mDMmcov)

### 6. fit circular-circular angle mean covariate model to the simulated data using DM

# Generate fake circular covariate using circAngles
data$cov3 &lt;- circAngles(refAngle=2*atan(rnorm(nrow(data))),data)

# Fit circular-circular regression model for angle mean
# Note no intercepts are estimated for angle means because these are by default
# the previous movement direction (i.e., a turning angle of zero)
mDMcircf &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                 Par0=list(step=stepPar,angle=c(0,0,Par0$angle)),
                  formula=formula,
                  estAngleMean=list(angle=TRUE),
                  circularAngleMean=list(angle=TRUE),
                  DM=list(angle=list(mean=~cov3,concentration=~1)))
                  
print(mDMcircf)
                  
### 7. fit the exact same circular-circular angle mean model using DM matrices

# Note no intercept terms are included in DM for angle means because the intercept is
# by default the previous movement direction (i.e., a turning angle of zero)
mDMcircm &lt;- fitHMM(data=data,nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                 Par0=list(step=stepPar,angle=c(0,0,Par0$angle)),
                  formula=formula,
                  estAngleMean=list(angle=TRUE),
                  circularAngleMean=list(angle=TRUE),
                  DM=list(angle=matrix(c("cov3",0,0,0,0,"cov3",0,0,0,0,1,0,0,0,0,1),4,4)))
                  
print(mDMcircm)

### 8. Cosinor and state-dependent formulas
nbStates&lt;-2
dist&lt;-list(step="gamma")
Par&lt;-list(step=c(100,1000,50,100))

# include 24-hour cycle on all transition probabilities
# include 12-hour cycle on transitions from state 2
formula=~cosinor(hour24,24)+state2(cosinor(hour12,12))

# specify appropriate covariates
covs&lt;-data.frame(hour24=0:23,hour12=0:11)

beta&lt;-matrix(c(-1.5,1,1,NA,NA,-1.5,-1,-1,1,1),5,2)
# row names for beta not required but can be helpful
rownames(beta)&lt;-c("(Intercept)",
                  "cosinorCos(hour24, 24)",
                  "cosinorSin(hour24, 24)",
                  "cosinorCos(hour12, 12)",
                  "cosinorSin(hour12, 12)")
data.cos&lt;-simData(nbStates=nbStates,dist=dist,Par=Par,
                      beta=beta,formula=formula,covs=covs)    

m.cosinor&lt;-fitHMM(data.cos,nbStates=nbStates,dist=dist,Par0=Par,formula=formula)
m.cosinor    

### 9. Piecewise constant B-spline on step length mean and angle concentration
nObs &lt;- 1000 # length of simulated track
cov &lt;- data.frame(time=1:nObs) # time covariate for splines
dist &lt;- list(step="gamma",angle="vm")
stepDM &lt;- list(mean=~splines2::bSpline(time,df=2,degree=0),sd=~1)
angleDM &lt;- list(mean=~1,concentration=~splines2::bSpline(time,df=2,degree=0))
DM &lt;- list(step=stepDM,angle=angleDM)
Par &lt;- list(step=c(log(1000),1,-1,log(100)),angle=c(0,log(10),2,-5))

data.spline&lt;-simData(obsPerAnimal=nObs,nbStates=1,dist=dist,Par=Par,DM=DM,covs=cov) 

Par0 &lt;- list(step=Par$step,angle=Par$angle[-1])
m.spline&lt;-fitHMM(data.spline,nbStates=1,dist=dist,Par0=Par0,
                 DM=list(step=stepDM,
                         angle=angleDM["concentration"]))  

### 10. Initial state (delta) based on covariate                       
nObs &lt;- 100
dist &lt;- list(step="gamma",angle="vm")
Par &lt;- list(step=c(100,1000,50,100),angle=c(0,0,0.01,0.75))

# create sex covariate
cov &lt;- data.frame(sex=factor(rep(c("F","M"),each=nObs))) # sex covariate
formulaDelta &lt;- ~ sex + 0

# Female begins in state 1, male begins in state 2
delta &lt;- matrix(c(-100,100),2,1,dimnames=list(c("sexF","sexM"),"state 2")) 

data.delta&lt;-simData(nbAnimals=2,obsPerAnimal=nObs,nbStates=2,dist=dist,Par=Par,
                    delta=delta,formulaDelta=formulaDelta,covs=cov) 
       
Par0 &lt;- list(step=Par$step, angle=Par$angle[3:4])   
m.delta &lt;- fitHMM(data.delta, nbStates=2, dist=dist, Par0 = Par0, 
                  formulaDelta=formulaDelta)
                  
### 11. Two mixtures based on covariate                       
nObs &lt;- 100
nbAnimals &lt;- 20
dist &lt;- list(step="gamma",angle="vm")
Par &lt;- list(step=c(100,1000,50,100),angle=c(0,0,0.1,2))

# create sex covariate
cov &lt;- data.frame(sex=factor(rep(c("F","M"),each=nObs*nbAnimals/2)))
formulaPi &lt;- ~ sex + 0

# Females more likely in mixture 1, males more likely in mixture 2
beta &lt;- list(beta=matrix(c(-1.5,-0.5,-1.5,-3),2,2),
             pi=matrix(c(-2,2),2,1,dimnames=list(c("sexF","sexM"),"mix2"))) 

data.mix&lt;-simData(nbAnimals=nbAnimals,obsPerAnimal=nObs,nbStates=2,dist=dist,Par=Par,
                  beta=beta,formulaPi=formulaPi,mixtures=2,covs=cov) 

Par0 &lt;- list(step=Par$step, angle=Par$angle[3:4])   
m.mix &lt;- fitHMM(data.mix, nbStates=2, dist=dist, Par0 = Par0, 
                beta0=beta,formulaPi=formulaPi,mixtures=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='formatHierHMM'>Convert hierarchical HMM structure to a conventional HMM</h2><span id='topic+formatHierHMM'></span>

<h3>Description</h3>

<p>Convert hierarchical HMM structure to a conventional HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatHierHMM(
  data,
  hierStates,
  hierDist,
  hierBeta = NULL,
  hierDelta = NULL,
  hierFormula = NULL,
  hierFormulaDelta = NULL,
  mixtures = 1,
  workBounds = NULL,
  betaCons = NULL,
  deltaCons = NULL,
  fixPar = NULL,
  checkData = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatHierHMM_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object or a data frame containing the data streams and covariates.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states ('state').  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams ('dist'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the transition probabilities at each level of the hierarchy ('beta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierdelta">hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the initial distribution at each level of the hierarchy ('delta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy ('formula'). See <code><a href="#topic+fitHMM">fitHMM</a></code>. Default: <code>NULL</code> (only hierarchical-level effects, with no covariate effects).</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>. Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale).</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities  (i.e. discrete random effects *sensu* DeRuiter et al. 2017). See <code><a href="#topic+fitHMM">fitHMM</a></code>. Default: <code>mixtures=1</code>.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_workbounds">workBounds</code></td>
<td>
<p>A list with elements named <code>'beta'</code> and/or <code>'delta'</code>, where each element is a hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> indicating t.p.m. and initial distribution working parameter bounds ('workBounds') for parameters in <code>hierBeta</code> and <code>hierDelta</code>, respectively.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_betacons">betaCons</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> indicating t.p.m. constraints ('betaCons') among parameters in <code>hierBeta</code> at each level of the hierarchy.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_deltacons">deltaCons</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> indicating initial distribution constraints ('deltaCons') among parameters in <code>hierDelta</code> at each level of the hierarchy.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_fixpar">fixPar</code></td>
<td>
<p>A list with elements named <code>'beta'</code> and/or <code>'delta'</code>, where each element is a hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> indicating t.p.m. and initial distribution parameters in <code>hierBeta</code> and <code>hierDelta</code>, respectively, which are assumed known.</p>
</td></tr>
<tr><td><code id="formatHierHMM_+3A_checkdata">checkData</code></td>
<td>
<p>logical indicating whether or not to check the suitability of <code>data</code> for the specified hierarchy. Ignored unless <code>data</code> is provided. Default: TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arguments needed for specifying a hierarchical HMM as a conventional HMM in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>, including:
</p>
<table>
<tr><td><code>nbStates</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>formulaDelta</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>delta0</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>betaRef</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>betaCons</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>deltaCons</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>fixPar</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>workBounds</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code>stateNames</code></td>
<td>
<p>See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='getCovNames'>Get names of any covariates used in probability distribution parameters</h2><span id='topic+getCovNames'></span>

<h3>Description</h3>

<p>Get names of any covariates used in probability distribution parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovNames(m, p, distname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovNames_+3A_m">m</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code> object</p>
</td></tr>
<tr><td><code id="getCovNames_+3A_p">p</code></td>
<td>
<p>list returned by <code><a href="#topic+parDef">parDef</a></code></p>
</td></tr>
<tr><td><code id="getCovNames_+3A_distname">distname</code></td>
<td>
<p>Name of the data stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>DMterms</code></td>
<td>
<p>Names of all covariates included in the design matrix for the data stream</p>
</td></tr>
<tr><td><code>DMpartems</code></td>
<td>
<p>A list of the names of all covariates for each of the probability distribution parameters</p>
</td></tr>
</table>

<hr>
<h2 id='getDM_rcpp'>Get design matrix</h2><span id='topic+getDM_rcpp'></span>

<h3>Description</h3>

<p>Loop for creating full design matrix (X) from pseudo-design matrix (DM). Written in C++. Used in <code>getDM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDM_rcpp(X, covs, DM, nr, nc, cov, nbObs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDM_rcpp_+3A_x">X</code></td>
<td>
<p>full design matrix</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_covs">covs</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_dm">DM</code></td>
<td>
<p>pseudo design matrix</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_nr">nr</code></td>
<td>
<p>number of rows in design matrix</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_nc">nc</code></td>
<td>
<p>number of column in design matrix</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_cov">cov</code></td>
<td>
<p>covariate names</p>
</td></tr>
<tr><td><code id="getDM_rcpp_+3A_nbobs">nbObs</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>full design matrix (X)
</p>

<hr>
<h2 id='getPar'>Get starting values from momentuHMM, miHMM, or miSum object returned by fitHMM, MIfitHMM, or MIpool</h2><span id='topic+getPar'></span>

<h3>Description</h3>

<p>Get starting values from momentuHMM, miHMM, or miSum object returned by fitHMM, MIfitHMM, or MIpool
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPar(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPar_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter values (Par, beta, delta) that can be used as starting values in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPar0">getPar0</a></code>, <code><a href="#topic+getParDM">getParDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m
Par &lt;- getPar(m)

</code></pre>

<hr>
<h2 id='getPar0'>Get starting values for new model from existing <code>momentuHMM</code> or <code>momentuHierHMM</code> model fit</h2><span id='topic+getPar0'></span><span id='topic+getPar0.default'></span><span id='topic+getPar0.hierarchical'></span>

<h3>Description</h3>

<p>For nested models, this function will extract starting parameter values (i.e., <code>Par0</code> in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>) from an existing <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code>momentuHierHMM</code> model fit based on the provided arguments for the new model. 
Any parameters that are not in common between <code>model</code> and the new model (as specified by the arguments) are set to <code>0</code>. This function is intended to help users incrementally build and fit more complicated models from simpler nested models (and vice versa).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPar0(model, ...)

## Default S3 method:
getPar0(
  model,
  nbStates = length(model$stateNames),
  estAngleMean = model$conditions$estAngleMean,
  circularAngleMean = model$conditions$circularAngleMean,
  formula = model$conditions$formula,
  formulaDelta = model$conditions$formulaDelta,
  stationary = model$conditions$stationary,
  mixtures = model$conditions$mixtures,
  formulaPi = model$conditions$formulaPi,
  DM = model$conditions$DM,
  betaRef = model$conditions$betaRef,
  stateNames = model$stateNames,
  ...
)

## S3 method for class 'hierarchical'
getPar0(
  model,
  hierStates = model$conditions$hierStates,
  estAngleMean = model$conditions$estAngleMean,
  circularAngleMean = model$conditions$circularAngleMean,
  hierFormula = model$conditions$hierFormula,
  hierFormulaDelta = model$conditions$hierFormulaDelta,
  mixtures = model$conditions$mixtures,
  formulaPi = model$conditions$formulaPi,
  DM = model$conditions$DM,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPar0_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object (as returned by <code><a href="#topic+fitHMM">fitHMM</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>, or <code><a href="#topic+MIpool">MIpool</a></code>)</p>
</td></tr>
<tr><td><code id="getPar0_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="getPar0_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states in the new model. Default: <code>nbStates=length(model$stateNames)</code></p>
</td></tr>
<tr><td><code id="getPar0_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>Named list indicating whether or not the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy') are to be estimated in the new model. Default: <code>estAngleMean=model$conditions$estAngleMean</code></p>
</td></tr>
<tr><td><code id="getPar0_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>Named list indicating whether circular-linear or circular-circular 
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles are to be used in the new model.  See <code><a href="#topic+fitHMM">fitHMM</a></code>. Default: <code>circularAngleMean=model$conditions$circularAngleMean</code></p>
</td></tr>
<tr><td><code id="getPar0_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates of the new model (see <code><a href="#topic+fitHMM">fitHMM</a></code>).  Default: <code>formula=model$conditions$formula</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_formuladelta">formulaDelta</code></td>
<td>
<p>Regression formula for the initial distribution covariates of the new model (see <code><a href="#topic+fitHMM">fitHMM</a></code>).  Default: <code>formulaDelta=model$conditions$formulaDelta</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities  (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Default: <code>formula=model$conditions$mixtures</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_formulapi">formulaPi</code></td>
<td>
<p>Regression formula for the mixture distribution probabilities (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Default: <code>formula=model$conditions$formulaPi</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_dm">DM</code></td>
<td>
<p>Named list indicating the design matrices to be used for the probability distribution parameters of each data stream in the new model (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Only parameters with design matrix column names that match those in model$conditions$fullDM are extracted, so care must be taken in naming columns if any elements of <code>DM</code>
are specified as matrices instead of formulas. Default: <code>DM=model$conditions$DM</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_betaref">betaRef</code></td>
<td>
<p>Numeric vector of length <code>nbStates</code> indicating the reference elements for the t.p.m. multinomial logit link. Default: <code>formula=model$conditions$betaRef</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_statenames">stateNames</code></td>
<td>
<p>Character vector of length <code>nbStates</code> indicating the names and order of the states in the new model. Default: <code>stateNames=model$stateNames[1:nbStates]</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Default: <code>hierStates=model$conditions$hierStates</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Default: <code>hierFormula=model$conditions$hierFormula</code>.</p>
</td></tr>
<tr><td><code id="getPar0_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All other <code><a href="#topic+fitHMM">fitHMM</a></code> (or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>) model specifications (e.g., <code>dist</code>, <code>hierDist</code>, <code>userBounds</code>, <code>workBounds</code>, etc.) and <code>data</code> are assumed to be the same 
for <code>model</code> and the new model (as specified by  <code>nbStates</code>, <code>hierStates</code>, <code>estAngleMean</code>, <code>circularAngleMean</code>, <code>formula</code>, <code>hierFormula</code>, <code>formulaDelta</code>, <code>hierFormulaDelta</code>, <code>DM</code>, etc.).
</p>
<p>Note that for hierarchical models, <code>getPar0</code> will return hierarchical data.tree objects (<code>hierBeta</code> and <code>hierDelta</code>) with the default values for <code>fixPar</code>, <code>betaCons</code>, and <code>deltaCons</code>;
if hierarchical t.p.m. or initial distribution parameters are subject to constraints, then these must be set manually on the list object returned by <code>getPar0</code>.
</p>


<h3>Value</h3>

<p>A named list containing starting values suitable for <code>Par0</code> and <code>beta0</code> arguments in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>:
</p>
<table>
<tr><td><code>Par</code></td>
<td>
<p>A list of vectors of state-dependent probability distribution parameters for 
each data stream specified in <code>model$conditions$dist</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Matrix of regression coefficients for the transition probabilities</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Initial distribution of the HMM. Only returned if <code>stateNames</code> has the same membership as the state names for <code>model</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getPar">getPar</a></code>, <code><a href="#topic+getParDM">getParDM</a></code>, <code><a href="#topic+fitHMM">fitHMM</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># model is a momentuHMM object, automatically loaded with the package
model &lt;- example$m
data &lt;- model$data
dist &lt;- model$conditions$dist
nbStates &lt;- length(model$stateNames)
estAngleMean &lt;- model$conditions$estAngleMean

newformula &lt;- ~cov1+cov2
Par0 &lt;- getPar0(model,formula=newformula)

## Not run: 
newModel &lt;- fitHMM(model$data,dist=dist,nbStates=nbStates,
                   Par0=Par0$Par,beta0=Par0$beta,
                   formula=newformula,
                   estAngleMean=estAngleMean)

## End(Not run)

newDM1 &lt;- list(step=list(mean=~cov1,sd=~cov1))
Par0 &lt;- getPar0(model,DM=newDM1)

## Not run: 
newModel1 &lt;- fitHMM(model$data,dist=dist,nbStates=nbStates,
                   Par0=Par0$Par,beta0=Par0$beta,
                   formula=model$conditions$formula,
                   estAngleMean=estAngleMean,
                   DM=newDM1)

## End(Not run)

# same model but specify DM for step using matrices
newDM2 &lt;- list(step=matrix(c(1,0,0,0,
                           "cov1",0,0,0,
                           0,1,0,0,
                           0,"cov1",0,0,
                           0,0,1,0,
                           0,0,"cov1",0,
                           0,0,0,1,
                           0,0,0,"cov1"),nrow=nbStates*2))
                           
# to be extracted, new design matrix column names must match 
# column names of model$conditions$fullDM
colnames(newDM2$step)&lt;-paste0(rep(c("mean_","sd_"),each=2*nbStates),
                      rep(1:nbStates,each=2),
                      rep(c(":(Intercept)",":cov1"),2*nbStates))
Par0 &lt;- getPar0(model,DM=newDM2)
                      
## Not run: 
newModel2 &lt;- fitHMM(model$data,dist=dist,nbStates=nbStates,
                   Par0=Par0$Par,beta0=Par0$beta,
                   formula=model$conditions$formula,
                   estAngleMean=estAngleMean,
                   DM=newDM2)

## End(Not run)

</code></pre>

<hr>
<h2 id='getParDM'>Get starting values on working scale based on design matrix and other parameter constraints</h2><span id='topic+getParDM'></span><span id='topic+getParDM.default'></span><span id='topic+getParDM.hierarchical'></span>

<h3>Description</h3>

<p>Convert starting values on the natural scale of data stream probability distributions to
a feasible set of working scale parameters based on a design matrix and other parameter constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParDM(data, ...)

## Default S3 method:
getParDM(
  data = data.frame(),
  nbStates,
  dist,
  Par,
  zeroInflation = NULL,
  oneInflation = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  ...
)

## S3 method for class 'hierarchical'
getParDM(
  data = data.frame(),
  hierStates,
  hierDist,
  Par,
  zeroInflation = NULL,
  oneInflation = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParDM_+3A_data">data</code></td>
<td>
<p>Optional <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object, <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object, or a data frame containing the covariate values. 
<code>data</code> must be specified if covariates are included in <code>DM</code>.
</p>
<p>If a data frame is provided, then either <code>nbStates</code> and <code>dist</code> must be specified (for a regular HMM) or <code>hierStates</code> and <code>hierDist</code>
must be specified (for a hierarchical HMM).</p>
</td></tr>
<tr><td><code id="getParDM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="getParDM_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams. Currently
supported distributions are 'bern', 'beta', 'exp', 'gamma', 'lnorm', 'norm', 'mvnorm2' (bivariate normal distribution), 'mvnorm3' (trivariate normal distribution),
'pois', 'rw_norm' (normal random walk), 'rw_mvnorm2' (bivariate normal random walk), 'rw_mvnorm3' (trivariate normal random walk), 'vm', 'vmConsensus', 'weibull', and 'wrpcauchy'. For example,
<code>dist=list(step='gamma', angle='vm', dives='pois')</code> indicates 3 data streams ('step', 'angle', and 'dives')
and their respective probability distributions ('gamma', 'vm', and 'pois').</p>
</td></tr>
<tr><td><code id="getParDM_+3A_par">Par</code></td>
<td>
<p>A named list containing vectors of state-dependent probability distribution parameters for 
each data stream specified in <code>dist</code>. The parameters should be on the natural scale,
in the order expected by the pdfs of <code>dist</code>, and any zero-mass parameters should be the last.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_zeroinflation">zeroInflation</code></td>
<td>
<p>A named list of logicals indicating whether the probability distributions of the data streams should be zero-inflated. If <code>zeroInflation</code> is <code>TRUE</code> 
for a given data stream, then values for the zero-mass parameters should be
included in the corresponding element of <code>Par</code>. Ignored if <code>data</code> is a <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_oneinflation">oneInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are one-inflated. If <code>oneInflation</code> is <code>TRUE</code> 
for a given data stream, then values for the one-mass parameters should be
included in the corresponding element of <code>Par</code>. Ignored if <code>data</code> is a <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>An optional named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy'). Any <code>estAngleMean</code> elements corresponding to data streams that do not have angular distributions are ignored.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>An optional named list indicating whether to use circular-linear or circular-circular 
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles.  See <code><a href="#topic+fitHMM">fitHMM</a></code>. <code>circularAngleMean</code> elements corresponding to angular data 
streams are ignored unless the corresponding element of <code>estAngleMean</code> is <code>TRUE</code>. Any <code>circularAngleMean</code> elements 
corresponding to data streams that do not have angular distributions are ignored.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_dm">DM</code></td>
<td>
<p>A named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. Each element of <code>DM</code> can either be a named list of linear regression formulas or a matrix.  For example, for a 2-state 
model using the gamma distribution for a data stream named 'step', <code>DM=list(step=list(mean=~cov1, sd=~1))</code> specifies the mean 
parameters as a function of the covariate 'cov1' for each state.  This model could equivalently be specified as a 4x6 matrix using 
character strings for the covariate: 
<code>DM=list(step=matrix(c(1,0,0,0,'cov1',0,0,0,0,1,0,0,0,'cov1',0,0,0,0,1,0,0,0,0,1),4,6))</code>
where the 4 rows correspond to the state-dependent paramaters (mean_1,mean_2,sd_1,sd_2) and the 6 columns correspond to the regression 
coefficients.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream. For example, for a 2-state model using the wrapped Cauchy ('wrpcauchy') distribution for 
a data stream named 'angle' with <code>estAngleMean$angle=TRUE)</code>, <code>userBounds=list(angle=matrix(c(-pi,-pi,-1,-1,pi,pi,1,1),4,2))</code> 
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters. For each matrix, the first column pertains to the lower bound and the second column the upper bound.
For data streams, each element of <code>workBounds</code> should be a k x 2 matrix with the same name of the corresponding element of 
<code>Par0</code>, where k is the number of parameters. For transition probability parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;beta&rdquo;, where k=<code>length(beta0)</code>. For initial distribution parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;delta&rdquo;, where k=<code>length(delta0)</code>.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states.  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="getParDM_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If design matrix includes non-factor covariates, then natural scale parameters are assumed to correspond to the 
mean value(s) for the covariate(s) (if <code>nrow(data)&gt;1</code>) and <code>getParDM</code> simply returns one possible solution to the 
system of linear equations defined by <code>Par</code>, <code>DM</code>, and any other constraints using singular value decomposition. 
This can be helpful for exploring relationships between the natural and working scale parameters when covariates are included, but <code>getParDM</code>
will not necessarily return &ldquo;good&rdquo; starting values (i.e., <code>Par0</code>) for <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.
</p>


<h3>Value</h3>

<p>A list of parameter values that can be used as starting values (<code>Par0</code>) in <code><a href="#topic+fitHMM">fitHMM</a></code> or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPar">getPar</a></code>, <code><a href="#topic+getPar0">getPar0</a></code>, <code><a href="#topic+fitHMM">fitHMM</a></code>, <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data is a momentuHMMData object, automatically loaded with the package
data &lt;- example$m$data
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
nbStates &lt;- 2
stepPar0 &lt;- c(15,50,10,20) # natural scale mean_1, mean_2, sd_1, sd_2
anglePar0 &lt;- c(0.7,1.5) # natural scale conentration_1, concentration_2

# get working parameters for 'DM' that constrains step length mean_1 &lt; mean_2
stepDM &lt;- matrix(c(1,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1),4,4,
          dimnames=list(NULL,c("mean:(Intercept)","mean_2",
                               "sd_1:(Intercept)","sd_2:(Intercept)")))
stepworkBounds &lt;- matrix(c(-Inf,Inf),4,2,byrow=TRUE,
                         dimnames=list(colnames(stepDM),c("lower","upper")))
stepworkBounds["mean_2","lower"] &lt;- 0 #coefficient for 'mean_2' constrained to be positive
wPar0 &lt;- getParDM(nbStates=2,dist=list(step=stepDist),
                      Par=list(step=stepPar0),
                      DM=list(step=stepDM),workBounds=list(step=stepworkBounds))

## Not run: 
# Fit HMM using wPar0 as initial values for the step data stream
mPar &lt;- fitHMM(data,nbStates=2,dist=list(step=stepDist,angle=angleDist),
               Par0=list(step=wPar0$step,angle=anglePar0),
               DM=list(step=stepDM),workBounds=list(step=stepworkBounds))

## End(Not run)

# get working parameters for 'DM' using 'cov1' and 'cov2' covariates
stepDM2 &lt;- list(mean=~cov1,sd=~cov2)
wPar20 &lt;- getParDM(data,nbStates=2,dist=list(step=stepDist),
                      Par=list(step=stepPar0),
                      DM=list(step=stepDM2))

## Not run: 
# Fit HMM using wPar20 as initial values for the step data stream
mPar2 &lt;- fitHMM(data,nbStates=2,dist=list(step=stepDist,angle=angleDist),
               Par0=list(step=wPar20$step,angle=anglePar0),
               DM=list(step=stepDM2))

## End(Not run)

</code></pre>

<hr>
<h2 id='getTrProbs'>Transition probability matrix</h2><span id='topic+getTrProbs'></span><span id='topic+getTrProbs.default'></span><span id='topic+getTrProbs.hierarchical'></span>

<h3>Description</h3>

<p>Computation of the transition probability matrix for each time step as a function of the covariates and the regression
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrProbs(data, ...)

## Default S3 method:
getTrProbs(
  data,
  nbStates,
  beta,
  workBounds = NULL,
  formula = ~1,
  mixtures = 1,
  betaRef = NULL,
  stateNames = NULL,
  getCI = FALSE,
  covIndex = NULL,
  alpha = 0.95,
  ...
)

## S3 method for class 'hierarchical'
getTrProbs(
  data,
  hierStates,
  hierBeta,
  workBounds = NULL,
  hierFormula = NULL,
  mixtures = 1,
  hierDist,
  getCI = FALSE,
  covIndex = NULL,
  alpha = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTrProbs_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code> object, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object, <code><a href="#topic+miSum">miSum</a></code> object, <code><a href="#topic+miHMM">miHMM</a></code> object, <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object, <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object, or a data frame containing the covariate values. 
</p>
<p>If a data frame is provided, then either <code>nbStates</code> must be specified (for a regular HMM) or <code>hierStates</code> and <code>hierDist</code>
must be specified (for a hierarchical HMM).</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods; most are ignored if <code>data</code> is a <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states. Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_beta">beta</code></td>
<td>
<p>Matrix of regression coefficients for the transition probabilities</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the transition probability parameters ('beta' and, for recharge models, 'g0' and 'theta'). <code>workBounds$beta</code> must be a k x 2 matrix, where k=<code>length(beta)</code>.
The first column pertains to the lower bound and the second column the upper bound. Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates. Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities.  Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_betaref">betaRef</code></td>
<td>
<p>Indices of reference elements for t.p.m. multinomial logit link. Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length nbStates indicating state names. Ignored unless <code>data</code> is a data frame.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_getci">getCI</code></td>
<td>
<p>Logical indicating whether to calculate standard errors and logit-transformed confidence intervals based on fitted <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object. Default: FALSE.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_covindex">covIndex</code></td>
<td>
<p>Integer vector indicating specific rows of the data to be used in the calculations. This can be useful for reducing unnecessarily long computation times (paricularly when <code>getCI=TRUE</code>), e.g., when <code>formula</code> includes factor covariates (such as <code>ID</code>) but no temporal covariates. Ignored if <code>data</code> is not a <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miSum">miSum</a></code>, or <code><a href="#topic+miHMM">miHMM</a></code> object.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>getCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states ('state').  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of regression coefficients for the transition probabilities at each level of the hierarchy, including initial values ('beta'), parameter equality constraints ('betaCons'), fixed parameters ('fixPar'), and working scale bounds ('workBounds'). See details.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy ('formula'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="getTrProbs_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams ('dist'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>mixtures=1</code>, an array of dimension <code>nbStates</code> x <code>nbStates</code> x <code>nrow(data)</code> containing the t.p.m for each observation in <code>data</code>.
If <code>mixtures&gt;1</code>, a list of length <code>mixtures</code>, where each element is an array of dimension <code>nbStates</code> x <code>nbStates</code> x <code>nrow(data)</code> containing the t.p.m for each observation in <code>data</code>.
</p>
<p>If <code>getCI=TRUE</code> then a list of arrays is returned (with elements <code>est</code>, <code>se</code>, <code>lower</code>, and <code>upper</code>).
</p>
<p>If a hierarchical HMM structure is provided, then a hierarchical data structure containing the state transition probabilities for each time step at each level of the hierarchy ('gamma') is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- example$m
trProbs &lt;- getTrProbs(m)

# equivalent
trProbs &lt;- getTrProbs(m$data,nbStates=2,beta=m$mle$beta,formula=m$conditions$formula)

## Not run: 
# calculate SEs and 95% CIs
trProbsSE &lt;- getTrProbs(m, getCI=TRUE)

# plot estimates and CIs for each state transition
par(mfrow=c(2,2))
for(i in 1:2){
  for(j in 1:2){
    plot(trProbsSE$est[i,j,],type="l", 
         ylim=c(0,1), ylab=paste(i,"-&gt;",j))
    arrows(1:dim(trProbsSE$est)[3],
           trProbsSE$lower[i,j,],
           1:dim(trProbsSE$est)[3],
           trProbsSE$upper[i,j,],
           length=0.025, angle=90, code=3, col=gray(.5), lwd=1.3)
  }
}

# limit calculations to first 10 observations
trProbsSE_10 &lt;- getTrProbs(m, getCI=TRUE, covIndex=1:10)

## End(Not run)

</code></pre>

<hr>
<h2 id='HMMfits'>Constructor of <code>HMMfits</code> objects</h2><span id='topic+HMMfits'></span>

<h3>Description</h3>

<p>Constructor of <code>HMMfits</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMMfits(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMMfits_+3A_m">m</code></td>
<td>
<p>A list of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects.
</p>
<p><code>HMMfits</code> objects are returned by <code><a href="#topic+MIfitHMM">MIfitHMM</a></code> when arguments <code>fit=TRUE</code> and <code>poolEstimates=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>HMMfits</code>.
</p>

<hr>
<h2 id='is.crwData'>Is crwData</h2><span id='topic+is.crwData'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+crwData">crwData</a></code>. Used in <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.crwData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.crwData_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+crwData">crwData</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.crwHierData'>Is crwHierData</h2><span id='topic+is.crwHierData'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+crwHierData">crwHierData</a></code>. Used in <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.crwHierData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.crwHierData_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+crwHierData">crwHierData</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.crwHierSim'>Is crwHierSim</h2><span id='topic+is.crwHierSim'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+crwHierSim">crwHierSim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.crwHierSim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.crwHierSim_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+crwHierSim">crwHierSim</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.crwSim'>Is crwSim</h2><span id='topic+is.crwSim'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+crwSim">crwSim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.crwSim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.crwSim_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+crwSim">crwSim</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.HMMfits'>Is HMMfits</h2><span id='topic+is.HMMfits'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+HMMfits">HMMfits</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.HMMfits(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.HMMfits_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+HMMfits">HMMfits</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.miHMM'>Is miHMM</h2><span id='topic+is.miHMM'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+miHMM">miHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.miHMM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.miHMM_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+miHMM">miHMM</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.miSum'>Is miSum</h2><span id='topic+is.miSum'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+miSum">miSum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.miSum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.miSum_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+miSum">miSum</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.momentuHierHMM'>Is momentuHierHMM</h2><span id='topic+is.momentuHierHMM'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>. Used in <code><a href="#topic+CIreal">CIreal</a></code>, <code><a href="#topic+CIbeta">CIbeta</a></code>,
<code><a href="#topic+plotPR">plotPR</a></code>, <code><a href="#topic+plotStates">plotStates</a></code>, <code><a href="#topic+pseudoRes">pseudoRes</a></code>, <code><a href="#topic+stateProbs">stateProbs</a></code>,
and <code><a href="#topic+viterbi">viterbi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.momentuHierHMM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.momentuHierHMM_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.momentuHierHMMData'>Is momentuHierHMMData</h2><span id='topic+is.momentuHierHMMData'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>. Used in <code><a href="#topic+fitHMM">fitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.momentuHierHMMData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.momentuHierHMMData_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.momentuHMM'>Is momentuHMM</h2><span id='topic+is.momentuHMM'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+momentuHMM">momentuHMM</a></code>. Used in <code><a href="#topic+CIreal">CIreal</a></code>, <code><a href="#topic+CIbeta">CIbeta</a></code>,
<code><a href="#topic+plotPR">plotPR</a></code>, <code><a href="#topic+plotStates">plotStates</a></code>, <code><a href="#topic+pseudoRes">pseudoRes</a></code>, <code><a href="#topic+stateProbs">stateProbs</a></code>,
and <code><a href="#topic+viterbi">viterbi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.momentuHMM(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.momentuHMM_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.momentuHMMData'>Is momentuHMMData</h2><span id='topic+is.momentuHMMData'></span>

<h3>Description</h3>

<p>Check that an object is of class <code><a href="#topic+momentuHMMData">momentuHMMData</a></code>. Used in <code><a href="#topic+fitHMM">fitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.momentuHMMData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.momentuHMMData_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is of class <code><a href="#topic+momentuHMMData">momentuHMMData</a></code>, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='logAlpha'>Forward log-probabilities</h2><span id='topic+logAlpha'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+stateProbs">stateProbs</a></code> and <code><a href="#topic+pseudoRes">pseudoRes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logAlpha(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logAlpha_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>model$conditions$mixtures</code> where each element is a matrix of forward log-probabilities for each mixture.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

la &lt;- momentuHMM:::logAlpha(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='logBeta'>Backward log-probabilities</h2><span id='topic+logBeta'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+stateProbs">stateProbs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logBeta(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logBeta_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>model$conditions$mixtures</code> where each element is a matrix of backward log-probabilities for each mixture.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

lb &lt;- momentuHMM:::logBeta(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='MIfitHMM'>Fit HMMs to multiple imputation data</h2><span id='topic+MIfitHMM'></span><span id='topic+MIfitHMM.default'></span><span id='topic+MIfitHMM.hierarchical'></span>

<h3>Description</h3>

<p>Fit a (multivariate) hidden Markov model to multiple imputation data. Multiple imputation is a method for accommodating 
missing data, temporal-irregularity, or location measurement error in hidden Markov models, where pooled parameter estimates reflect uncertainty
attributable to observation error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIfitHMM(miData, ...)

## Default S3 method:
MIfitHMM(
  miData,
  nSims,
  ncores = 1,
  poolEstimates = TRUE,
  alpha = 0.95,
  na.rm = FALSE,
  nbStates,
  dist,
  Par0,
  beta0 = NULL,
  delta0 = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  formula = ~1,
  formulaDelta = NULL,
  stationary = FALSE,
  mixtures = 1,
  formulaPi = NULL,
  nlmPar = NULL,
  fit = TRUE,
  useInitial = FALSE,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  betaRef = NULL,
  deltaCons = NULL,
  mvnCoords = NULL,
  stateNames = NULL,
  knownStates = NULL,
  fixPar = NULL,
  retryFits = 0,
  retrySD = NULL,
  optMethod = "nlm",
  control = list(),
  prior = NULL,
  modelName = NULL,
  covNames = NULL,
  spatialCovs = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  altCoordNames = NULL,
  method = "IS",
  parIS = 1000,
  dfSim = Inf,
  grid.eps = 1,
  crit = 2.5,
  scaleSim = 1,
  quad.ask = FALSE,
  force.quad = TRUE,
  fullPost = TRUE,
  dfPostIS = Inf,
  scalePostIS = 1,
  thetaSamp = NULL,
  ...
)

## S3 method for class 'hierarchical'
MIfitHMM(
  miData,
  nSims,
  ncores = 1,
  poolEstimates = TRUE,
  alpha = 0.95,
  na.rm = FALSE,
  hierStates,
  hierDist,
  Par0,
  hierBeta = NULL,
  hierDelta = NULL,
  estAngleMean = NULL,
  circularAngleMean = NULL,
  hierFormula = NULL,
  hierFormulaDelta = NULL,
  mixtures = 1,
  formulaPi = NULL,
  nlmPar = NULL,
  fit = TRUE,
  useInitial = FALSE,
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaCons = NULL,
  deltaCons = NULL,
  mvnCoords = NULL,
  knownStates = NULL,
  fixPar = NULL,
  retryFits = 0,
  retrySD = NULL,
  optMethod = "nlm",
  control = list(),
  prior = NULL,
  modelName = NULL,
  covNames = NULL,
  spatialCovs = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  altCoordNames = NULL,
  method = "IS",
  parIS = 1000,
  dfSim = Inf,
  grid.eps = 1,
  crit = 2.5,
  scaleSim = 1,
  quad.ask = FALSE,
  force.quad = TRUE,
  fullPost = TRUE,
  dfPostIS = Inf,
  scalePostIS = 1,
  thetaSamp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIfitHMM_+3A_midata">miData</code></td>
<td>
<p>A <code><a href="#topic+crwData">crwData</a></code> object, a <code><a href="#topic+crwHierData">crwHierData</a></code> object, a <code><a href="#topic+crwSim">crwSim</a></code> object, a <code><a href="#topic+crwHierSim">crwHierSim</a></code> object, a list of <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> objects, or a list of <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> objects.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_nsims">nSims</code></td>
<td>
<p>Number of imputations in which to fit the HMM using <code><a href="#topic+fitHMM">fitHMM</a></code>. If <code>miData</code> is a list of <code>momentuHMMData</code> 
objects, <code>nSims</code> cannot exceed the length of <code>miData</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default: 1 (no parallel processing).</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_poolestimates">poolEstimates</code></td>
<td>
<p>Logical indicating whether or not to calculate pooled parameter estimates across the <code>nSims</code> imputations using <code><a href="#topic+MIpool">MIpool</a></code>. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for calculating confidence intervals of pooled estimates when <code>poolEstimates=TRUE</code> (see <code><a href="#topic+MIpool">MIpool</a></code>). Default: 0.95.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether or not to exclude model fits with <code>NA</code> parameter estimates or standard errors from pooling when <code>poolEstimates=TRUE</code> (see <code><a href="#topic+MIpool">MIpool</a></code>). Default: FALSE.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_par0">Par0</code></td>
<td>
<p>A named list containing vectors of initial state-dependent probability distribution parameters for 
each data stream specified in <code>dist</code>. See <code><a href="#topic+fitHMM">fitHMM</a></code>.  <code>Par0</code> may also be a list of length <code>nSims</code>, where each element is a named list containing vectors
of initial state-dependent probability distribution parameters for each imputation. Note that if <code>useInitial=TRUE</code> then <code>Par0</code> is ignored after the first imputation.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_beta0">beta0</code></td>
<td>
<p>Initial matrix of regression coefficients for the transition probabilities. See <code><a href="#topic+fitHMM">fitHMM</a></code>. <code>beta0</code> may also be a list of length <code>nSims</code>, where each element 
is an initial matrix of regression coefficients for the transition probabilities for each imputation.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_delta0">delta0</code></td>
<td>
<p>Initial values for the initial distribution of the HMM. See <code><a href="#topic+fitHMM">fitHMM</a></code>. <code>delta0</code> may also be a list of length <code>nSims</code>, where each element 
is the initial values for the initial distribution of the HMM for each imputation.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>An optional named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>An optional named list indicating whether to use circular-linear or circular-circular
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_formuladelta">formulaDelta</code></td>
<td>
<p>Regression formula for the initial distribution. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities  (i.e. discrete random effects *sensu* DeRuiter et al. 2017). Default: <code>mixtures=1</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_formulapi">formulaPi</code></td>
<td>
<p>Regression formula for the mixture distribution probabilities. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_nlmpar">nlmPar</code></td>
<td>
<p>List of parameters to pass to the optimization function <code><a href="stats.html#topic+nlm">nlm</a></code> (which should be either
<code>print.level</code>, <code>gradtol</code>, <code>stepmax</code>, <code>steptol</code>, <code>iterlim</code>, or <code>hessian</code> &ndash; see <code>nlm</code>'s documentation
for more detail). For <code>print.level</code>, the default value of 0 means that no
printing occurs, a value of 1 means that the first and last iterations of the optimization are
detailed, and a value of 2 means that each iteration of the optimization is detailed. Ignored unless <code>optMethod="nlm"</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_fit">fit</code></td>
<td>
<p><code>TRUE</code> if the HMM should be fitted to the data, <code>FALSE</code> otherwise. See <code><a href="#topic+fitHMM">fitHMM</a></code>. If <code>fit=FALSE</code> and <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code>
object, then <code>MIfitHMM</code> returns a list containing a <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object (if <code>nSims=1</code>) or, if <code>nSims&gt;1</code>, a <code><a href="#topic+crwSim">crwSim</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_useinitial">useInitial</code></td>
<td>
<p>Logical indicating whether or not to use parameter estimates for the first model fit as initial values for all subsequent model fits.
If <code>ncores&gt;1</code> then the first model is fit on a single core and then used as the initial values for all subsequent model fits on each core 
(in this case, the progress of the initial model fit can be followed using the <code>print.level</code> option in <code>nlmPar</code>). Default: FALSE. Ignored if <code>nSims&lt;2</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_betacons">betaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>beta0</code> composed of integers identifying any equality constraints among the t.p.m. parameters. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_betaref">betaRef</code></td>
<td>
<p>Numeric vector of length <code>nbStates</code> indicating the reference elements for the t.p.m. multinomial logit link. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_deltacons">deltaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>delta0</code> composed of integers identifying any equality constraints among the initial distribution working scale parameters. Ignored unless a formula is provided in <code>formulaDelta</code>. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_mvncoords">mvnCoords</code></td>
<td>
<p>Character string indicating the name of location data that are to be modeled using a multivariate normal distribution. For example, if <code>mu="mvnorm2"</code> was included in <code>dist</code> and (mu.x, mu.y) are location data, 
then <code>mvnCoords="mu"</code> needs to be specified in order for these data to be properly treated as locations in functions such as <code><a href="#topic+plot.momentuHMM">plot.momentuHMM</a></code>, <code><a href="#topic+plot.miSum">plot.miSum</a></code>, <code><a href="#topic+plot.miHMM">plot.miHMM</a></code>, <code><a href="#topic+plotSpatialCov">plotSpatialCov</a></code>, and <code><a href="#topic+MIpool">MIpool</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length nbStates indicating state names.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_knownstates">knownStates</code></td>
<td>
<p>Vector of values of the state process which are known prior to fitting the
model (if any). See <code><a href="#topic+fitHMM">fitHMM</a></code>. If <code>miData</code> is a list of <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> objects, then <code>knownStates</code> can alternatively
be a list of vectors containing the known values for the state process for each element of <code>miData</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_fixpar">fixPar</code></td>
<td>
<p>An optional list of vectors indicating parameters which are assumed known prior to fitting the model. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_retryfits">retryFits</code></td>
<td>
<p>Non-negative integer indicating the number of times to attempt to iteratively fit the model using random perturbations of the current parameter estimates as the 
initial values for likelihood optimization.  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_retrysd">retrySD</code></td>
<td>
<p>An optional list of scalars or vectors indicating the standard deviation to use for normal perturbations of each working scale parameter when <code>retryFits&gt;0</code>. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_optmethod">optMethod</code></td>
<td>
<p>The optimization method to be used.  Can be &ldquo;nlm&rdquo; (the default; see <code><a href="stats.html#topic+nlm">nlm</a></code>), &ldquo;Nelder-Mead&rdquo; (see <code><a href="stats.html#topic+optim">optim</a></code>), or &ldquo;SANN&rdquo; (see <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code> (ignored unless <code>optMethod="Nelder-Mead"</code> or <code>optMethod="SANN"</code>).</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_prior">prior</code></td>
<td>
<p>A function that returns the log-density of the working scale parameter prior distribution(s).  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_modelname">modelName</code></td>
<td>
<p>An optional character string providing a name for the fitted model. If provided, <code>modelName</code> will be returned in <code><a href="#topic+print.momentuHMM">print.momentuHMM</a></code>, <code><a href="#topic+AIC.momentuHMM">AIC.momentuHMM</a></code>, <code><a href="#topic+AICweights">AICweights</a></code>, and other functions.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_covnames">covNames</code></td>
<td>
<p>Names of any covariates in <code>miData$crwPredict</code> (if <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object; otherwise 
<code>covNames</code> is ignored). See <code><a href="#topic+prepData">prepData</a></code>. If <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object, any covariate in <code>miData$crwPredict</code> that is used in <code>formula</code>, <code>formulaDelta</code>, <code>formulaPi</code>, or <code>DM</code> must be included in <code>covNames</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_spatialcovs">spatialCovs</code></td>
<td>
<p>List of raster layer(s) for any spatial covariates. See <code><a href="#topic+prepData">prepData</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_centers">centers</code></td>
<td>
<p>2-column matrix providing the x-coordinates (column 1) and y-coordinates (column 2) for any activity centers (e.g., potential 
centers of attraction or repulsion) from which distance and angle covariates will be calculated based on realizations of the position process. 
See <code><a href="#topic+prepData">prepData</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_centroids">centroids</code></td>
<td>
<p>List where each element is a data frame containing the x-coordinates ('x'), y-coordinates ('y'), and times (with user-specified name, e.g., &lsquo;time&rsquo;) for centroids (i.e., dynamic activity centers where the coordinates can change over time)
from which distance and angle covariates will be calculated based on the location data. See <code><a href="#topic+prepData">prepData</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_anglecovs">angleCovs</code></td>
<td>
<p>Character vector indicating the names of any circular-circular regression angular covariates in <code>miData$crwPredict</code> that need conversion from standard direction (in radians relative to the x-axis) to turning angle (relative to previous movement direction) 
See <code><a href="#topic+prepData">prepData</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_altcoordnames">altCoordNames</code></td>
<td>
<p>Character string indicating an alternative name for the returned location data. See <code><a href="#topic+prepData">prepData</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_method">method</code></td>
<td>
<p>Method for obtaining weights for movement parameter samples. See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_paris">parIS</code></td>
<td>
<p>Size of the parameter importance sample. See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_dfsim">dfSim</code></td>
<td>
<p>Degrees of freedom for the t approximation to the parameter posterior. See 'df' argument in <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_grid.eps">grid.eps</code></td>
<td>
<p>Grid size for <code>method="quadrature"</code>. See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_crit">crit</code></td>
<td>
<p>Criterion for deciding &quot;significance&quot; of quadrature points
(difference in log-likelihood). See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_scalesim">scaleSim</code></td>
<td>
<p>Scale multiplier for the covariance matrix of the t approximation. See 'scale' argument in <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. 
Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_quad.ask">quad.ask</code></td>
<td>
<p>Logical, for method='quadrature'. Whether or not the sampler should ask if quadrature sampling should take place. It is used to stop the sampling if the number of likelihood evaluations would be extreme. Default: FALSE. Ignored if <code>ncores&gt;1</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_force.quad">force.quad</code></td>
<td>
<p>A logical indicating whether or not to force the execution 
of the quadrature method for large parameter vectors. See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>. Default: TRUE. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object and <code>method=``quadrature''</code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_fullpost">fullPost</code></td>
<td>
<p>Logical indicating whether to draw parameter values as well to simulate full posterior. See <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_dfpostis">dfPostIS</code></td>
<td>
<p>Degrees of freedom for multivariate t distribution approximation to parameter posterior. See 'df' argument in <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_scalepostis">scalePostIS</code></td>
<td>
<p>Extra scaling factor for t distribution approximation. See 'scale' argument in <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>. Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_thetasamp">thetaSamp</code></td>
<td>
<p>If multiple parameter samples are available in <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> objects,
setting <code>thetaSamp=n</code> will use the nth sample. Defaults to the last. See <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> and <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>. 
Ignored unless <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states.  See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the transition probabilities at each level of the hierarchy ('beta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierdelta">hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the initial distribution at each level of the hierarchy ('delta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="MIfitHMM_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>miData</code> can either be a <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object (as returned by <code><a href="#topic+crawlWrap">crawlWrap</a></code>), a <code><a href="#topic+crwSim">crwSim</a></code> or <code><a href="#topic+crwHierSim">crwHierSim</a></code> object (as returned by <code>MIfitHMM</code> when <code>fit=FALSE</code>), 
or a list of <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> objects (e.g., each element of the list as returned by <code><a href="#topic+prepData">prepData</a></code>). 
</p>
<p>If <code>miData</code> is a <code>crwData</code> (or <code>crwHierData</code>) object, <code>MIfitHMM</code> uses a combination of 
<code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>, <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>, <code><a href="#topic+prepData">prepData</a></code>, and <code><a href="#topic+fitHMM">fitHMM</a></code> to draw <code>nSims</code> realizations of the position process
and fit the specified HMM to each imputation of the data. The vast majority of <code>MIfitHMM</code> arguments are identical to the corresponding arguments from these functions.
</p>
<p>If <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object, <code>nSims</code> determines both the number of realizations of the position process to draw 
(using <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> and <code>crwPostIS</code>) as well as the number of HMM fits.
</p>
<p>If <code>miData</code> is a <code><a href="#topic+crwSim">crwSim</a></code> (or <code><a href="#topic+crwHierSim">crwHierSim</a></code>) object or a list of <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> (or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>) object(s), the specified HMM will simply be fitted to each of the <code>momentuHMMData</code> (or <code>momentuHierHMMData</code>) objects
and all arguments related to <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>, <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>, or <code><a href="#topic+prepData">prepData</a></code> are ignored.
</p>


<h3>Value</h3>

<p>If <code>nSims&gt;1</code>, <code>poolEstimates=TRUE</code>, and <code>fit=TRUE</code>, a <code><a href="#topic+miHMM">miHMM</a></code> object, i.e., a list consisting of:
</p>
<table>
<tr><td><code>miSum</code></td>
<td>
<p><code><a href="#topic+miSum">miSum</a></code> object returned by <code><a href="#topic+MIpool">MIpool</a></code>.</p>
</td></tr>
<tr><td><code>HMMfits</code></td>
<td>
<p>List of length <code>nSims</code> comprised of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects.</p>
</td></tr>
</table>
<p>If <code>poolEstimates=FALSE</code> and <code>fit=TRUE</code>, a list of length <code>nSims</code> consisting of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects is returned. 
</p>
<p>However, if <code>fit=FALSE</code> and <code>miData</code> is a <code><a href="#topic+crwData">crwData</a></code> 
object, then <code>MIfitHMM</code> returns a <code><a href="#topic+crwSim">crwSim</a></code> object, i.e., a list containing <code>miData</code> (a list of 
<code><a href="#topic+momentuHMMData">momentuHMMData</a></code> objects) and <code>crwSimulator</code> (a list of <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code> objects),and most other arguments related to <code><a href="#topic+fitHMM">fitHMM</a></code> are ignored.
</p>


<h3>References</h3>

<p>Hooten M.B., Johnson D.S., McClintock B.T., Morales J.M. 2017. Animal Movement: Statistical Models for Telemetry Data. CRC Press, Boca Raton.
</p>
<p>McClintock B.T. 2017. Incorporating telemetry error into hidden Markov movement models using multiple imputation. Journal of Agricultural, Biological,
and Environmental Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="crawl.html#topic+crwPostIS">crwPostIS</a></code>, <code><a href="crawl.html#topic+crwSimulator">crwSimulator</a></code>, <code><a href="#topic+fitHMM">fitHMM</a></code>, <code><a href="#topic+getParDM">getParDM</a></code>, <code><a href="#topic+MIpool">MIpool</a></code>, <code><a href="#topic+prepData">prepData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Don't run because it takes too long on a single core
## Not run: 
# extract simulated obsData from example data
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# create crwData object by fitting crwMLE models to obsData and predict locations 
# at default intervals for both individuals
crwOut &lt;- crawlWrap(obsData=obsData,
         theta=c(4,0),fixPar=c(1,1,NA,NA),
         err.model=err.model)

# HMM specifications
nbStates &lt;- 2
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar0 &lt;- c(mu0,sigma0)
anglePar0 &lt;- c(-pi/2,pi/2,kappa0)
formula &lt;- ~cov1+cos(cov2)
nbCovs &lt;- 2
beta0 &lt;- matrix(c(rep(-1.5,nbStates*(nbStates-1)),rep(0,nbStates*(nbStates-1)*nbCovs)),
                nrow=nbCovs+1,byrow=TRUE)

# first fit HMM to best predicted position process
bestData&lt;-prepData(crwOut,covNames=c("cov1","cov2"))
bestFit&lt;-fitHMM(bestData,
                nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                Par0=list(step=stepPar0,angle=anglePar0),beta0=beta0,
                formula=formula,estAngleMean=list(angle=TRUE))
            
print(bestFit)

# extract estimates from 'bestFit'
bPar0 &lt;- getPar(bestFit)

# Fit nSims=5 imputations of the position process
miFits&lt;-MIfitHMM(miData=crwOut,nSims=5,
                  nbStates=nbStates,dist=list(step=stepDist,angle=angleDist),
                  Par0=bPar0$Par,beta0=bPar0$beta,delta0=bPar0$delta,
                  formula=formula,estAngleMean=list(angle=TRUE),
                  covNames=c("cov1","cov2"))

# print pooled estimates
print(miFits)

## End(Not run)

</code></pre>

<hr>
<h2 id='miHMM'>Constructor of <code>miHMM</code> objects</h2><span id='topic+miHMM'></span>

<h3>Description</h3>

<p>Constructor of <code>miHMM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miHMM(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miHMM_+3A_m">m</code></td>
<td>
<p>A list with attributes <code>miSum</code> (a <code><a href="#topic+miSum">miSum</a></code> object) and <code>HMMfits</code> (a list of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects).
</p>
<p><code>miHMM</code> objects are returned by <code><a href="#topic+MIfitHMM">MIfitHMM</a></code> when arguments <code>fit=TRUE</code>, <code>nSims&gt;1</code>, and <code>poolEstimates=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>miHMM</code>.
</p>

<hr>
<h2 id='MIpool'>Calculate pooled parameter estimates and states across multiple imputations</h2><span id='topic+MIpool'></span>

<h3>Description</h3>

<p>Calculate pooled parameter estimates and states across multiple imputations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIpool(im, alpha = 0.95, ncores = 1, covs = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MIpool_+3A_im">im</code></td>
<td>
<p>List comprised of <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> objects</p>
</td></tr>
<tr><td><code id="MIpool_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for calculating confidence intervals of pooled estimates (including location error ellipses). Default: 0.95.</p>
</td></tr>
<tr><td><code id="MIpool_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default: 1 (no parallel processing).</p>
</td></tr>
<tr><td><code id="MIpool_+3A_covs">covs</code></td>
<td>
<p>Data frame consisting of a single row indicating the covariate values to be used in the calculation of pooled natural parameters. 
For any covariates that are not specified using <code>covs</code>, the means of the covariate(s) across the imputations are used 
(unless the covariate is a factor, in which case the first factor in the data is used). By default, no covariates are specified.</p>
</td></tr>
<tr><td><code id="MIpool_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether or not to exclude model fits with <code>NA</code> parameter estimates or standard errors from pooling. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pooled estimates, standard errors, and confidence intervals are calculated using standard multiple imputation formulas. Working scale parameters are pooled
using <code><a href="mitools.html#topic+MIcombine">MIcombine</a></code> and t-distributed confidence intervals. Natural scale parameters and normally-distributed confidence intervals are calculated by transforming the pooled working scale parameters 
and, if applicable, are based on covariate means across all imputations (and/or values specified in <code>covs</code>).
</p>
<p>The calculation of pooled error ellipses uses <code><a href="car.html#topic+dataEllipse">dataEllipse</a></code> from the <code>car</code> package. The suggested package <code>car</code> is not automatically imported by <code>momentuHMM</code> and must be installed in order to calculate error ellipses. A warning will be triggered if the <code>car</code> package is required but not installed.
</p>
<p>Note that pooled estimates for <code>timeInStates</code> and <code>stateProbs</code> do not include within-model uncertainty and are based entirely on across-model variability.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+miSum">miSum</a></code> object, i.e., a list comprised of model and pooled parameter summaries, including <code>data</code> (averaged across imputations), <code>conditions</code>, <code>Par</code>, and <code>MIcombine</code> 
(as returned by <code><a href="mitools.html#topic+MIcombine">MIcombine</a></code> for working parameters).
</p>
<p><code>miSum$Par</code> is a list comprised of:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>Pooled estimates for the working parameters</p>
</td></tr>
<tr><td><code>real</code></td>
<td>
<p>Estimates for the natural parameters based on pooled working parameters and covariate means (or <code>covs</code>) across imputations (if applicable)</p>
</td></tr>
<tr><td><code>timeInStates</code></td>
<td>
<p>The proportion of time steps assigned to each state</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>The most freqent state assignment for each time step based on the <code><a href="#topic+viterbi">viterbi</a></code> algorithm for each model fit</p>
</td></tr>
<tr><td><code>stateProbs</code></td>
<td>
<p>Pooled state probability estimates for each time step</p>
</td></tr>
<tr><td><code>mixtureProbs</code></td>
<td>
<p>Pooled mixture probabilities for each individual (only applies if <code>mixtures&gt;1</code>)</p>
</td></tr>
<tr><td><code>hierStateProbs</code></td>
<td>
<p>Pooled state probability estimates for each time step at each level of the hierarchy (only applies if <code>im</code> is comprised of <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> objects)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Extract data and crawl inputs from miExample
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crawl to obsData
crwOut &lt;- crawlWrap(obsData,theta=c(4,0),fixPar=c(1,1,NA,NA),
                    err.model=err.model)
                    
# Fit four imputations
bPar &lt;- miExample$bPar
HMMfits &lt;- MIfitHMM(crwOut,nSims=4,poolEstimates=FALSE,
                   nbStates=2,dist=list(step="gamma",angle="vm"),
                   Par0=bPar$Par,beta0=bPar$beta,
                   formula=~cov1+cos(cov2),
                   estAngleMean=list(angle=TRUE),
                   covNames=c("cov1","cov2"))
                   
# Pool estimates
miSum &lt;- MIpool(HMMfits)
print(miSum)

## End(Not run)
</code></pre>

<hr>
<h2 id='miSum'>Constructor of <code>miSum</code> objects</h2><span id='topic+miSum'></span>

<h3>Description</h3>

<p>Constructor of <code>miSum</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miSum(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miSum_+3A_m">m</code></td>
<td>
<p>A list of attributes required for multiple imputation summaries: <code>data</code> (averaged across imputations), <code>Par</code> (the pooled estimates of
the parameters of the model), <code>conditions</code> (conditions used to fit the model), and <code>MIcombine</code> (as returned by <code><a href="mitools.html#topic+MIcombine">MIcombine</a></code> for
the working parameters).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>miSum</code>.
</p>

<hr>
<h2 id='mixtureProbs'>Mixture probabilities</h2><span id='topic+mixtureProbs'></span>

<h3>Description</h3>

<p>For a fitted model, this function computes the probability of each individual being in a particular mixture
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixtureProbs(m, getCI = FALSE, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixtureProbs_+3A_m">m</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object</p>
</td></tr>
<tr><td><code id="mixtureProbs_+3A_getci">getCI</code></td>
<td>
<p>Logical indicating whether to calculate standard errors and logit-transformed confidence intervals for fitted <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object. Default: FALSE.</p>
</td></tr>
<tr><td><code id="mixtureProbs_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>getCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>getCI=TRUE</code>, it can take a while for large data sets and/or a large number of mixtures because the model likelihood for each individual must be repeatedly evaluated in order to numerically approximate the SEs.
</p>


<h3>Value</h3>

<p>The matrix of individual mixture probabilities, with element [i,j] the probability
of individual i being in mixture j
</p>


<h3>References</h3>

<p>Maruotti, A., and T. Ryden. 2009. A semiparametric approach to hidden Markov models under longitudinal observations. Statistics and Computing 19: 381-393.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nObs &lt;- 100
nbAnimals &lt;- 20
dist &lt;- list(step="gamma",angle="vm")
Par &lt;- list(step=c(100,1000,50,100),angle=c(0,0,0.1,2))

# create sex covariate
cov &lt;- data.frame(sex=factor(rep(c("F","M"),each=nObs*nbAnimals/2)))
formulaPi &lt;- ~ sex + 0

# Females more likely in mixture 1, males more likely in mixture 2
beta &lt;- list(beta=matrix(c(-1.5,-0.5,-1.5,-3),2,2),
             pi=matrix(c(-2,2),2,1,dimnames=list(c("sexF","sexM"),"mix2"))) 

data.mix&lt;-simData(nbAnimals=nbAnimals,obsPerAnimal=nObs,nbStates=2,dist=dist,Par=Par,
                  beta=beta,formulaPi=formulaPi,mixtures=2,covs=cov) 

Par0 &lt;- list(step=Par$step, angle=Par$angle[3:4])   
m.mix &lt;- fitHMM(data.mix, nbStates=2, dist=dist, Par0 = Par0, 
                beta0=beta,formulaPi=formulaPi,mixtures=2)
                
mixProbs &lt;- mixtureProbs(m.mix, getCI=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='momentuHierHMM'>Constructor of <code>momentuHierHMM</code> objects</h2><span id='topic+momentuHierHMM'></span>

<h3>Description</h3>

<p>Constructor of <code>momentuHierHMM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentuHierHMM(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentuHierHMM_+3A_m">m</code></td>
<td>
<p>A list of attributes of the fitted model: <code>mle</code> (the maximum likelihood estimates of
the parameters of the model), <code>data</code> (the <code>fitHMM</code> data), <code>mod</code> (the object
returned by the <code>fitHMM</code> numerical optimizer <code>nlm</code> or <code>optim</code>), <code>conditions</code> (conditions used to fit
the model: <code>hierStates</code>, <code>hierDist</code>, <code>zeroInflation</code>, <code>estAngleMean</code>, <code>circularAngleMean</code>
<code>stationary</code>, <code>formula</code>, <code>userBounds</code>, <code>bounds</code>, <code>workBounds</code>, <code>DM</code>, etc.), 
<code>stateNames</code>, and <code>rawCovs</code> (optional &ndash; only if there are transition probability matrix covariates in the data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>momentuHierHMM</code>.
</p>

<hr>
<h2 id='momentuHierHMMData'>Constructor of <code>momentuHierHMMData</code> objects</h2><span id='topic+momentuHierHMMData'></span>

<h3>Description</h3>

<p>Constructor of <code>momentuHierHMMData</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentuHierHMMData(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentuHierHMMData_+3A_data">data</code></td>
<td>
<p>A dataframe containing: <code>ID</code> (the ID(s) of the observed animal(s)), <code>level</code> (the level of the hierarchy for each observation), and the data streams such as <code>step</code>
(the step lengths, if any), <code>angle</code> (the turning angles, if any), <code>x</code> (either easting or longitude, if any),
<code>y</code> (either norting or latitude, if any), and covariates (if any).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>momentuHierHMMData</code>.
</p>

<hr>
<h2 id='momentuHMM'>Constructor of <code>momentuHMM</code> objects</h2><span id='topic+momentuHMM'></span>

<h3>Description</h3>

<p>Constructor of <code>momentuHMM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentuHMM(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentuHMM_+3A_m">m</code></td>
<td>
<p>A list of attributes of the fitted model: <code>mle</code> (the maximum likelihood estimates of
the parameters of the model), <code>data</code> (the <code>fitHMM</code> data), <code>mod</code> (the object
returned by the <code>fitHMM</code> numerical optimizer <code>nlm</code> or <code>optim</code>), <code>conditions</code> (conditions used to fit
the model: <code>dist</code>, <code>zeroInflation</code>, <code>estAngleMean</code>, <code>circularAngleMean</code>
<code>stationary</code>, <code>formula</code>, <code>userBounds</code>, <code>bounds</code>, <code>workBounds</code>, <code>DM</code>, etc.), 
<code>stateNames</code>, and <code>rawCovs</code> (optional &ndash; only if there are transition probability matrix covariates in the data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>momentuHMM</code>.
</p>

<hr>
<h2 id='momentuHMMData'>Constructor of <code>momentuHMMData</code> objects</h2><span id='topic+momentuHMMData'></span>

<h3>Description</h3>

<p>Constructor of <code>momentuHMMData</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentuHMMData(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentuHMMData_+3A_data">data</code></td>
<td>
<p>A dataframe containing: <code>ID</code> (the ID(s) of the observed animal(s)) and the data streams such as <code>step</code>
(the step lengths, if any), <code>angle</code> (the turning angles, if any), <code>x</code> (either easting or longitude, if any),
<code>y</code> (either norting or latitude, if any), and covariates (if any).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <code>momentuHMMData</code>.
</p>

<hr>
<h2 id='n2w'>Scaling function: natural to working parameters.</h2><span id='topic+n2w'></span>

<h3>Description</h3>

<p>Scales each data stream probability distribution parameter from its natural interval to the set of real numbers, to allow for
unconstrained optimization. Used during the optimization of the log-likelihood. Parameters of
any data streams for which a design matrix is specified are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2w(par, bounds, beta, delta = NULL, nbStates, estAngleMean, DM, Bndind, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n2w_+3A_par">par</code></td>
<td>
<p>Named list of vectors containing the initial parameter values for each data stream.</p>
</td></tr>
<tr><td><code id="n2w_+3A_bounds">bounds</code></td>
<td>
<p>Named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream.</p>
</td></tr>
<tr><td><code id="n2w_+3A_beta">beta</code></td>
<td>
<p>List of regression coefficients for the transition probabilities.</p>
</td></tr>
<tr><td><code id="n2w_+3A_delta">delta</code></td>
<td>
<p>Initial distribution. Default: <code>NULL</code> ; if the initial distribution is not estimated.</p>
</td></tr>
<tr><td><code id="n2w_+3A_nbstates">nbStates</code></td>
<td>
<p>The number of states of the HMM.</p>
</td></tr>
<tr><td><code id="n2w_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>Named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy').</p>
</td></tr>
<tr><td><code id="n2w_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. Each element of <code>DM</code> can either be a named list of linear regression formulas or a matrix.</p>
</td></tr>
<tr><td><code id="n2w_+3A_bndind">Bndind</code></td>
<td>
<p>Named list indicating whether <code>DM</code> is NULL with default parameter bounds for each data stream.</p>
</td></tr>
<tr><td><code id="n2w_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of unconstrained parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m&lt;-example$m
nbStates &lt;- 2
nbCovs &lt;- 2
parSize &lt;- list(step=2,angle=2)
par &lt;- list(step=c(t(m$mle$step)),angle=c(t(m$mle$angle)))
bounds &lt;- m$conditions$bounds
beta &lt;- matrix(rnorm(6),ncol=2,nrow=3)
delta &lt;- c(0.6,0.4)

#working parameters
wpar &lt;- momentuHMM:::n2w(par,bounds,list(beta=beta),log(delta[-1]/delta[1]),nbStates,
m$conditions$estAngleMean,NULL,m$conditions$Bndind,
m$conditions$dist)

#natural parameter
p &lt;-   momentuHMM:::w2n(wpar,bounds,parSize,nbStates,nbCovs,m$conditions$estAngleMean,
m$conditions$circularAngleMean,lapply(m$conditions$dist,function(x) x=="vmConsensus"),
m$conditions$stationary,m$conditions$fullDM,
m$conditions$DMind,1,m$conditions$dist,m$conditions$Bndind,
matrix(1,nrow=length(unique(m$data$ID)),ncol=1),covsDelta=m$covsDelta,
workBounds=m$conditions$workBounds)

## End(Not run)

</code></pre>

<hr>
<h2 id='nLogLike'>Negative log-likelihood function</h2><span id='topic+nLogLike'></span>

<h3>Description</h3>

<p>Negative log-likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nLogLike(
  optPar,
  nbStates,
  formula,
  bounds,
  parSize,
  data,
  dist,
  covs,
  estAngleMean,
  circularAngleMean,
  consensus,
  zeroInflation,
  oneInflation,
  stationary = FALSE,
  fullDM,
  DMind,
  Bndind,
  knownStates,
  fixPar,
  wparIndex,
  nc,
  meanind,
  covsDelta,
  workBounds,
  prior = NULL,
  betaCons = NULL,
  betaRef,
  deltaCons = NULL,
  optInd = NULL,
  recovs = NULL,
  g0covs = NULL,
  mixtures = 1,
  covsPi,
  recharge = NULL,
  aInd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nLogLike_+3A_optpar">optPar</code></td>
<td>
<p>Vector of working parameters.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_bounds">bounds</code></td>
<td>
<p>Named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_parsize">parSize</code></td>
<td>
<p>Named list indicating the number of natural parameters of the data stream probability distributions</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_data">data</code></td>
<td>
<p>An object <code>momentuHMMData</code>.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_dist">dist</code></td>
<td>
<p>Named list indicating the probability distributions of the data streams.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_covs">covs</code></td>
<td>
<p>data frame containing the beta model covariates (if any)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>Named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy').</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>Named list indicating whether to use circular-linear or circular-circular 
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_consensus">consensus</code></td>
<td>
<p>Named list indicating whether to use the circular-circular regression consensus model</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_zeroinflation">zeroInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are zero-inflated.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_oneinflation">oneInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are one-inflated.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_fulldm">fullDM</code></td>
<td>
<p>Named list containing the full (i.e. not shorthand) design matrix for each data stream.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_dmind">DMind</code></td>
<td>
<p>Named list indicating whether <code>fullDM</code> includes individual- and/or temporal-covariates for each data stream
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_bndind">Bndind</code></td>
<td>
<p>Named list indicating whether <code>DM</code> is NULL with default parameter bounds for each data stream.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_knownstates">knownStates</code></td>
<td>
<p>Vector of values of the state process which are known prior to fitting the
model (if any).</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_fixpar">fixPar</code></td>
<td>
<p>Vector of working parameters which are assumed known prior to fitting the model (NA indicates parameters is to be estimated).</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_wparindex">wparIndex</code></td>
<td>
<p>Vector of indices for the elements of <code>fixPar</code> that are not NA.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_nc">nc</code></td>
<td>
<p>indicator for zeros in fullDM</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_meanind">meanind</code></td>
<td>
<p>index for circular-circular regression mean angles with at least one non-zero entry in fullDM</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_covsdelta">covsDelta</code></td>
<td>
<p>data frame containing the delta model covariates (if any)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_workbounds">workBounds</code></td>
<td>
<p>named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_prior">prior</code></td>
<td>
<p>A function that returns the log-density of the working scale parameter prior distribution(s)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_betacons">betaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>beta0</code> composed of integers identifying any equality constraints among the t.p.m. parameters.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_betaref">betaRef</code></td>
<td>
<p>Indices of reference elements for t.p.m. multinomial logit link.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_deltacons">deltaCons</code></td>
<td>
<p>Matrix of the same dimension as <code>delta0</code> composed of integers identifying any equality constraints among the initial distribution working scale parameters.</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_optind">optInd</code></td>
<td>
<p>indices of constrained parameters</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_recovs">recovs</code></td>
<td>
<p>data frame containing the recharge model theta covariates (if any)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_g0covs">g0covs</code></td>
<td>
<p>data frame containing the recharge model g0 covariates (if any)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_covspi">covsPi</code></td>
<td>
<p>data frame containing the pi model covariates</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_recharge">recharge</code></td>
<td>
<p>recharge model specification (only used for hierarchical models)</p>
</td></tr>
<tr><td><code id="nLogLike_+3A_aind">aInd</code></td>
<td>
<p>vector of indices of first observation for each animal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The negative log-likelihood of the parameters given the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# data is a momentuHMMData object (as returned by prepData), automatically loaded with the package
data &lt;- example$m$data
m&lt;-example$m
Par &lt;- getPar(m)
nbStates &lt;- length(m$stateNames)

inputs &lt;- momentuHMM:::checkInputs(nbStates,m$conditions$dist,Par$Par,m$conditions$estAngleMean,
          m$conditions$circularAngleMean,m$conditions$zeroInflation,m$conditions$oneInflation,
          m$conditions$DM,m$conditions$userBounds,
          m$stateNames)

wpar &lt;- momentuHMM:::n2w(Par$Par,m$conditions$bounds,list(beta=Par$beta),
        log(Par$delta[-1]/Par$delta[1]),nbStates,m$conditions$estAngleMean,
        m$conditions$DM,m$conditions$Bndind,
        m$conditions$dist)

l &lt;- momentuHMM:::nLogLike(wpar,nbStates,m$conditions$formula,m$conditions$bounds,
     inputs$p$parSize,data,inputs$dist,model.matrix(m$conditions$formula,data),
     m$conditions$estAngleMean,m$conditions$circularAngleMean,inputs$consensus,
     m$conditions$zeroInflation,m$conditions$oneInflation,m$conditions$stationary,
     m$conditions$fullDM,m$conditions$DMind,
     m$conditions$Bndind,m$knownStates,unlist(m$conditions$fixPar),
     m$conditions$wparIndex,covsDelta=m$covsDelta,workBounds=m$conditions$workBounds,
     betaRef=m$conditions$betaRef,covsPi=m$covsPi)

## End(Not run)

</code></pre>

<hr>
<h2 id='nLogLike_rcpp'>Negative log-likelihood</h2><span id='topic+nLogLike_rcpp'></span>

<h3>Description</h3>

<p>Computation of the negative log-likelihood (forward algorithm - written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nLogLike_rcpp(
  nbStates,
  covs,
  data,
  dataNames,
  dist,
  Par,
  aInd,
  zeroInflation,
  oneInflation,
  stationary,
  knownStates,
  betaRef,
  mixtures
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nLogLike_rcpp_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states,</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_covs">covs</code></td>
<td>
<p>Covariates,</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object of the observations,</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_datanames">dataNames</code></td>
<td>
<p>Character vector containing the names of the data streams,</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_dist">dist</code></td>
<td>
<p>Named list indicating the probability distributions of the data streams.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_par">Par</code></td>
<td>
<p>Named list containing the state-dependent parameters of the data streams, matrix of regression coefficients 
for the transition probabilities ('beta'), and initial distribution ('delta').</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_aind">aInd</code></td>
<td>
<p>Vector of indices of the rows at which the data switches to another animal</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_zeroinflation">zeroInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are zero-inflated.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_oneinflation">oneInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are one-inflated.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_stationary">stationary</code></td>
<td>
<p><code>false</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>true</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>false</code>.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_knownstates">knownStates</code></td>
<td>
<p>Vector of values of the state process which are known prior to fitting the
model (if any). Default: NULL (states are not known). This should be a vector with length the number
of rows of 'data'; each element should either be an integer (the value of the known states) or NA if
the state is not known.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_betaref">betaRef</code></td>
<td>
<p>Indices of reference elements for t.p.m. multinomial logit link.</p>
</td></tr>
<tr><td><code id="nLogLike_rcpp_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood
</p>

<hr>
<h2 id='parDef'>Parameters definition</h2><span id='topic+parDef'></span>

<h3>Description</h3>

<p>Parameters definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parDef(
  dist,
  nbStates,
  estAngleMean,
  zeroInflation,
  oneInflation,
  DM,
  userBounds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parDef_+3A_dist">dist</code></td>
<td>
<p>Named list indicating the probability distributions of the data streams.</p>
</td></tr>
<tr><td><code id="parDef_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states of the HMM.</p>
</td></tr>
<tr><td><code id="parDef_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>Named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy').</p>
</td></tr>
<tr><td><code id="parDef_+3A_zeroinflation">zeroInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams should be zero-inflated.</p>
</td></tr>
<tr><td><code id="parDef_+3A_oneinflation">oneInflation</code></td>
<td>
<p>Named list of logicals indicating whether the probability distributions of the data streams are one-inflated.</p>
</td></tr>
<tr><td><code id="parDef_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. Each element of <code>DM</code> can either be a named list of linear regression formulas or a matrix.</p>
</td></tr>
<tr><td><code id="parDef_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream. For example, for a 2-state model using the wrapped Cauchy ('wrpcauchy') distribution for 
a data stream named 'angle' with <code>estAngleMean$angle=TRUE)</code>, <code>userBounds=list(angle=matrix(c(-pi,-pi,-1,-1,pi,pi,1,1),4,2))</code> 
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>parSize</code></td>
<td>
<p>Named list indicating the number of natural parameters of the data stream probability distributions.</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>Named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream.</p>
</td></tr>
<tr><td><code>parNames</code></td>
<td>
<p>Names of parameters of the probability distribution for each data stream.</p>
</td></tr>
<tr><td><code>Bndind</code></td>
<td>
<p>Named list indicating whether <code>DM</code> is NULL with default parameter bounds for each data stream.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pD&lt;-momentuHMM:::parDef(list(step="gamma",angle="wrpcauchy"),
    nbStates=2,list(step=FALSE,angle=FALSE),list(step=FALSE,angle=FALSE),
    list(step=FALSE,angle=FALSE),NULL,NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.crwData'>Plot <code>crwData</code></h2><span id='topic+plot.crwData'></span><span id='topic+plot.crwHierData'></span>

<h3>Description</h3>

<p>Plot observed locations, error ellipses (if applicable), predicted locations, and prediction intervals from <code><a href="#topic+crwData">crwData</a></code> or <code><a href="#topic+crwHierData">crwHierData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crwData'
plot(
  x,
  animals = NULL,
  compact = FALSE,
  ask = TRUE,
  plotEllipse = TRUE,
  crawlPlot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.crwData_+3A_x">x</code></td>
<td>
<p>An object <code>crwData</code> or <code>crwHierData</code> (as returned by <code><a href="#topic+crawlWrap">crawlWrap</a></code>).</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which information will be plotted.
Default: <code>NULL</code> ; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_compact">compact</code></td>
<td>
<p><code>TRUE</code> for a compact plot (all individuals at once), <code>FALSE</code> otherwise
(default &ndash; one individual at a time). Ignored unless <code>crwPredictPlot=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_plotellipse">plotEllipse</code></td>
<td>
<p>If <code>TRUE</code> (the default) then error ellipses are plotted (if applicable). Ignored unless <code>crwPredictPlot=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_crawlplot">crawlPlot</code></td>
<td>
<p>Logical indicating whether or not to create individual plots using <code><a href="crawl.html#topic+crwPredictPlot">crwPredictPlot</a></code>. See <code><a href="crawl.html#topic+crwPredictPlot">crwPredictPlot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.crwData_+3A_...">...</code></td>
<td>
<p>Further arguments for passing to <code><a href="crawl.html#topic+crwPredictPlot">crwPredictPlot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for error ellipses to be plotted, the names for the semi-major axis, semi-minor axis, and 
orientation in <code>x$crwPredict</code> must respectively be <code>error_semimajor_axis</code>, <code>error_semiminor_axis</code>,     
and <code>error_ellipse_orientation</code>. 
</p>
<p>If the <code>crwData</code> (or <code>crwHierData</code>) object was created using data generated by
<code><a href="#topic+simData">simData</a></code> (or <code><a href="#topic+simHierData">simHierData</a></code>) or <code><a href="#topic+simObsData">simObsData</a></code>, then the true locations (<code>mux</code>,<code>muy</code>) are also plotted.
</p>


<h3>See Also</h3>

<p><code><a href="crawl.html#topic+crwPredictPlot">crwPredictPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# extract simulated obsData from example data
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# create crwData object
crwOut &lt;- crawlWrap(obsData=obsData,
         theta=c(4,0),fixPar=c(1,1,NA,NA),
         err.model=err.model)

plot(crwOut,compact=TRUE,ask=FALSE,plotEllipse=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.miHMM'>Plot <code>miHMM</code></h2><span id='topic+plot.miHMM'></span>

<h3>Description</h3>

<p>For multiple imputation analyses, plot the pooled data stream densities over histograms of the data, probability distribution parameters and transition probabilities
as functions of the covariates, and maps of the animals' tracks colored by the decoded states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miHMM'
plot(
  x,
  animals = NULL,
  covs = NULL,
  ask = TRUE,
  breaks = "Sturges",
  hist.ylim = NULL,
  sepAnimals = FALSE,
  sepStates = FALSE,
  col = NULL,
  cumul = TRUE,
  plotTracks = TRUE,
  plotCI = FALSE,
  alpha = 0.95,
  plotStationary = FALSE,
  plotEllipse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.miHMM_+3A_x">x</code></td>
<td>
<p>Object <code>miHMM</code> (as returned by <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>)</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which information will be plotted.
Default: <code>NULL</code> ; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_covs">covs</code></td>
<td>
<p>Data frame consisting of a single row indicating the covariate values to be used in plots. If none are specified, the means of any covariates appearing in the model are used (unless covariate is a factor, in which case the first factor appearing in the data is used).</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_breaks">breaks</code></td>
<td>
<p>Histogram parameter. See <code>hist</code> documentation.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_hist.ylim">hist.ylim</code></td>
<td>
<p>Parameter <code>ylim</code> for the step length histograms.
See <code>hist</code> documentation. Default: <code>NULL</code> ; the function sets default values.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_sepanimals">sepAnimals</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by individuals in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_sepstates">sepStates</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by states in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_col">col</code></td>
<td>
<p>Vector or colors for the states (one color per state).</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_cumul">cumul</code></td>
<td>
<p>If TRUE, the sum of weighted densities is plotted (default).</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_plottracks">plotTracks</code></td>
<td>
<p>If TRUE, the Viterbi-decoded tracks are plotted (default).</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_plotci">plotCI</code></td>
<td>
<p>Logical indicating whether to include confidence intervals in natural parameter plots (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>plotCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_plotstationary">plotStationary</code></td>
<td>
<p>Logical indicating whether to plot the stationary state probabilities as a function of any covariates (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_plotellipse">plotEllipse</code></td>
<td>
<p>Logical indicating whether to plot error ellipses around imputed location means. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.miHMM_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>graphics::plot</code> and <code>graphics::hist</code> functions. These can currently include <code>asp</code>, <code>cex</code>, <code>cex.axis</code>, <code>cex.lab</code>, <code>cex.legend</code>, <code>cex.main</code>, <code>legend.pos</code>, and <code>lwd</code>. See <code><a href="graphics.html#topic+par">par</a></code>. <code>legend.pos</code> can be a single keyword from the list &ldquo;bottomright&rdquo;, &ldquo;bottom&rdquo;, &ldquo;bottomleft&rdquo;, &ldquo;left&rdquo;, &ldquo;topleft&rdquo;, &ldquo;top&rdquo;, &ldquo;topright&rdquo;, &ldquo;right&rdquo;, and &ldquo;center&rdquo;. Note that <code>asp</code> and <code>cex</code> only apply to plots of animal tracks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state-dependent densities are weighted by the frequency of each state in the most
probable state sequence (decoded with the function <code><a href="#topic+viterbi">viterbi</a></code> for each imputation). For example, if the
most probable state sequence indicates that one third of observations correspond to the first
state, and two thirds to the second state, the plots of the densities in the first state are
weighted by a factor 1/3, and in the second state by a factor 2/3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Extract data from miExample
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crawl to obsData
crwOut &lt;- crawlWrap(obsData,theta=c(4,0),fixPar=c(1,1,NA,NA),
                    err.model=err.model)
                    
# Fit four imputations
bPar &lt;- miExample$bPar
HMMfits &lt;- MIfitHMM(crwOut,nSims=4,poolEstimates=FALSE,
                   nbStates=2,dist=list(step="gamma",angle="vm"),
                   Par0=bPar$Par,beta0=bPar$beta,
                   formula=~cov1+cos(cov2),
                   estAngleMean=list(angle=TRUE),
                   covNames=c("cov1","cov2"))
                   
miHMM &lt;- momentuHMM:::miHMM(list(miSum=MIpool(HMMfits),HMMfits=HMMfits))
plot(miHMM)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.miSum'>Plot <code>miSum</code></h2><span id='topic+plot.miSum'></span>

<h3>Description</h3>

<p>Plot the fitted step and angle densities over histograms of the data, transition probabilities
as functions of the covariates, and maps of the animals' tracks colored by the decoded states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miSum'
plot(
  x,
  animals = NULL,
  covs = NULL,
  ask = TRUE,
  breaks = "Sturges",
  hist.ylim = NULL,
  sepAnimals = FALSE,
  sepStates = FALSE,
  col = NULL,
  cumul = TRUE,
  plotTracks = TRUE,
  plotCI = FALSE,
  alpha = 0.95,
  plotStationary = FALSE,
  plotEllipse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.miSum_+3A_x">x</code></td>
<td>
<p>Object <code>miSum</code> (as return by <code><a href="#topic+MIpool">MIpool</a></code>)</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which information will be plotted.
Default: <code>NULL</code> ; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_covs">covs</code></td>
<td>
<p>Data frame consisting of a single row indicating the covariate values to be used in plots. If none are specified, the means of any covariates appearing in the model are used (unless covariate is a factor, in which case the first factor appearing in the data is used).</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_breaks">breaks</code></td>
<td>
<p>Histogram parameter. See <code>hist</code> documentation.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_hist.ylim">hist.ylim</code></td>
<td>
<p>Parameter <code>ylim</code> for the step length histograms.
See <code>hist</code> documentation. Default: <code>NULL</code> ; the function sets default values.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_sepanimals">sepAnimals</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by individuals in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_sepstates">sepStates</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by states in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_col">col</code></td>
<td>
<p>Vector or colors for the states (one color per state).</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_cumul">cumul</code></td>
<td>
<p>If TRUE, the sum of weighted densities is plotted (default).</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_plottracks">plotTracks</code></td>
<td>
<p>If TRUE, the Viterbi-decoded tracks are plotted (default).</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_plotci">plotCI</code></td>
<td>
<p>Logical indicating whether to include confidence intervals in natural parameter plots (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>plotCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_plotstationary">plotStationary</code></td>
<td>
<p>Logical indicating whether to plot the stationary state probabilities as a function of any covariates (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_plotellipse">plotEllipse</code></td>
<td>
<p>Logical indicating whether to plot error ellipses around imputed location means. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.miSum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>graphics::plot</code> and <code>graphics::hist</code> functions. These can currently include <code>asp</code>, <code>cex</code>, <code>cex.axis</code>, <code>cex.lab</code>, <code>cex.legend</code>, <code>cex.main</code>, <code>legend.pos</code>, and <code>lwd</code>. See <code><a href="graphics.html#topic+par">par</a></code>. <code>legend.pos</code> can be a single keyword from the list &ldquo;bottomright&rdquo;, &ldquo;bottom&rdquo;, &ldquo;bottomleft&rdquo;, &ldquo;left&rdquo;, &ldquo;topleft&rdquo;, &ldquo;top&rdquo;, &ldquo;topright&rdquo;, &ldquo;right&rdquo;, and &ldquo;center&rdquo;. Note that <code>asp</code> and <code>cex</code> only apply to plots of animal tracks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state-dependent densities are weighted by the frequency of each state in the most
probable state sequence (decoded with the function <code><a href="#topic+viterbi">viterbi</a></code> for each imputation). For example, if the
most probable state sequence indicates that one third of observations correspond to the first
state, and two thirds to the second state, the plots of the densities in the first state are
weighted by a factor 1/3, and in the second state by a factor 2/3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Extract data from miExample
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crawl to obsData
crwOut &lt;- crawlWrap(obsData,theta=c(4,0),fixPar=c(1,1,NA,NA),
                    err.model=err.model)
                    
# Fit four imputations
bPar &lt;- miExample$bPar
HMMfits &lt;- MIfitHMM(crwOut,nSims=4,poolEstimates=FALSE,
                   nbStates=2,dist=list(step="gamma",angle="vm"),
                   Par0=bPar$Par,beta0=bPar$beta,
                   formula=~cov1+cos(cov2),
                   estAngleMean=list(angle=TRUE),
                   covNames=c("cov1","cov2"))
                   
# Pool estimates
miSum &lt;- MIpool(HMMfits)
plot(miSum)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.momentuHMM'>Plot <code>momentuHMM</code></h2><span id='topic+plot.momentuHMM'></span>

<h3>Description</h3>

<p>Plot the fitted step and angle densities over histograms of the data, transition probabilities
as functions of the covariates, and maps of the animals' tracks colored by the decoded states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'momentuHMM'
plot(
  x,
  animals = NULL,
  covs = NULL,
  ask = TRUE,
  breaks = "Sturges",
  hist.ylim = NULL,
  sepAnimals = FALSE,
  sepStates = FALSE,
  col = NULL,
  cumul = TRUE,
  plotTracks = TRUE,
  plotCI = FALSE,
  alpha = 0.95,
  plotStationary = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.momentuHMM_+3A_x">x</code></td>
<td>
<p>Object <code>momentuHMM</code></p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which information will be plotted.
Default: <code>NULL</code> ; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_covs">covs</code></td>
<td>
<p>Data frame consisting of a single row indicating the covariate values to be used in plots. 
If none are specified, the means of any covariates appearing in the model are used (unless covariate is a factor, in which case the first factor in the data is used).</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_breaks">breaks</code></td>
<td>
<p>Histogram parameter. See <code>hist</code> documentation.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_hist.ylim">hist.ylim</code></td>
<td>
<p>An optional named list of vectors specifying <code>ylim=c(ymin,ymax)</code> for the data stream histograms.
See <code>hist</code> documentation. Default: <code>NULL</code> ; the function sets default values for all data streams.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_sepanimals">sepAnimals</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by individuals in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_sepstates">sepStates</code></td>
<td>
<p>If <code>TRUE</code>, the data is split by states in the histograms.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_col">col</code></td>
<td>
<p>Vector or colors for the states (one color per state).</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_cumul">cumul</code></td>
<td>
<p>If TRUE, the sum of weighted densities is plotted (default).</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_plottracks">plotTracks</code></td>
<td>
<p>If TRUE, the Viterbi-decoded tracks are plotted (default).</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_plotci">plotCI</code></td>
<td>
<p>Logical indicating whether to include confidence intervals in natural parameter plots (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>plotCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_plotstationary">plotStationary</code></td>
<td>
<p>Logical indicating whether to plot the stationary state probabilities as a function of any covariates (default: FALSE). Ignored unless covariate are included in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="plot.momentuHMM_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>graphics::plot</code> and <code>graphics::hist</code> functions. These can currently include <code>asp</code>, <code>cex</code>, <code>cex.axis</code>, <code>cex.lab</code>, <code>cex.legend</code>, <code>cex.main</code>, <code>legend.pos</code>, and <code>lwd</code>. See <code><a href="graphics.html#topic+par">par</a></code>. <code>legend.pos</code> can be a single keyword from the list &ldquo;bottomright&rdquo;, &ldquo;bottom&rdquo;, &ldquo;bottomleft&rdquo;, &ldquo;left&rdquo;, &ldquo;topleft&rdquo;, &ldquo;top&rdquo;, &ldquo;topright&rdquo;, &ldquo;right&rdquo;, and &ldquo;center&rdquo;. Note that <code>asp</code> and <code>cex</code> only apply to plots of animal tracks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state-dependent densities are weighted by the frequency of each state in the most
probable state sequence (decoded with the function <code><a href="#topic+viterbi">viterbi</a></code>). For example, if the
most probable state sequence indicates that one third of observations correspond to the first
state, and two thirds to the second state, the plots of the densities in the first state are
weighted by a factor 1/3, and in the second state by a factor 2/3.
</p>
<p>Confidence intervals for natural parameters are calculated from the working parameter point and covariance estimates
using finite-difference approximations of the first derivative for the transformation (see <code><a href="numDeriv.html#topic+grad">grad</a></code>).
For example, if <code>dN</code> is the numerical approximation of the first derivative of the transformation <code>N = exp(x_1 * B_1 + x_2 * B_2)</code>
for covariates (x_1, x_2) and working parameters (B_1, B_2), then 
<code>var(N)=dN %*% Sigma %*% dN</code>, where <code>Sigma=cov(B_1,B_2)</code>, and normal confidence intervals can be 
constructed as <code>N +/- qnorm(1-(1-alpha)/2) * se(N)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

plot(m,ask=TRUE,animals=1,breaks=20,plotCI=TRUE)

</code></pre>

<hr>
<h2 id='plot.momentuHMMData'>Plot <code>momentuHMMData</code> or <code>momentuHierHMMData</code></h2><span id='topic+plot.momentuHMMData'></span><span id='topic+plot.momentuHierHMMData'></span>

<h3>Description</h3>

<p>Plot <code>momentuHMMData</code> or <code>momentuHierHMMData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'momentuHMMData'
plot(
  x,
  dataNames = c("step", "angle"),
  animals = NULL,
  compact = FALSE,
  ask = TRUE,
  breaks = "Sturges",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.momentuHMMData_+3A_x">x</code></td>
<td>
<p>An object <code>momentuHMMData</code> or <code>momentuHierHMMData</code></p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_datanames">dataNames</code></td>
<td>
<p>Names of the variables to plot. Default is <code>dataNames=c("step","angle")</code>.</p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which information will be plotted.
Default: <code>NULL</code> ; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_compact">compact</code></td>
<td>
<p><code>TRUE</code> for a compact plot (all individuals at once), <code>FALSE</code> otherwise
(default &ndash; one individual at a time).</p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_breaks">breaks</code></td>
<td>
<p>Histogram parameter. See <code>hist</code> documentation.</p>
</td></tr>
<tr><td><code id="plot.momentuHMMData_+3A_...">...</code></td>
<td>
<p>Currently unused. For compatibility with generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># data is a momentuHMMData object (as returned by prepData), automatically loaded with the package
data &lt;- example$m$data

plot(data,dataNames=c("step","angle","cov1","cov2"),
     compact=TRUE,breaks=20,ask=FALSE)

</code></pre>

<hr>
<h2 id='plotPR'>Plot pseudo-residuals</h2><span id='topic+plotPR'></span>

<h3>Description</h3>

<p>Plots time series, qq-plots (against the standard normal distribution) using <code><a href="car.html#topic+qqPlot">qqPlot</a></code>, and sample
ACF functions of the pseudo-residuals for each data stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPR(m, lag.max = NULL, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPR_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object.</p>
</td></tr>
<tr><td><code id="plotPR_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the acf.  See <code><a href="stats.html#topic+acf">acf</a></code>.</p>
</td></tr>
<tr><td><code id="plotPR_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If some turning angles in the data are equal to pi, the corresponding pseudo-residuals
will not be included. Indeed, given that the turning angles are defined on (-pi,pi], an angle of pi
results in a pseudo-residual of +Inf (check Section 6.2 of reference for more information on the
computation of pseudo-residuals).
</p>
</li>
<li><p> If some data streams are zero-inflated and/or one-inflated, the corresponding pseudo-
residuals are shown as segments, because pseudo-residuals for discrete data are defined as
segments (see Zucchini and MacDonald, 2009, Section 6.2).
</p>
</li>
<li><p> For multiple imputation analyses, if <code>m</code> is a <code><a href="#topic+miHMM">miHMM</a></code> object or a list of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects, then
the pseudo-residuals are individually calculated and plotted for each model fit. Note that pseudo-residuals for <code><a href="#topic+miSum">miSum</a></code> objects (as returned by <code><a href="#topic+MIpool">MIpool</a></code>) are based on pooled parameter 
estimates and the means of the data values across all imputations (and therefore may not be particularly meaningful).
</p>
</li></ul>



<h3>References</h3>

<p>Zucchini, W. and MacDonald, I.L. 2009.
Hidden Markov Models for Time Series: An Introduction Using R.
Chapman &amp; Hall (London).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

plotPR(m)

</code></pre>

<hr>
<h2 id='plotSat'>Plot observations on satellite image</h2><span id='topic+plotSat'></span>

<h3>Description</h3>

<p>Plot tracking data on a satellite map. This function plots coordinates in longitude
and latitude (not UTM), so if <code>data</code> coordinates are not provided in longitude and latitude, then the coordinate reference system must be provided using the <code>projargs</code> argument. This function uses the package <code>ggmap</code>
to fetch a satellite image from Google. An Internet connection is required to use
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSat(
  data,
  zoom = NULL,
  location = NULL,
  segments = TRUE,
  compact = TRUE,
  col = NULL,
  alpha = 1,
  size = 1,
  shape = 16,
  states = NULL,
  animals = NULL,
  ask = TRUE,
  return = FALSE,
  stateNames = NULL,
  projargs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSat_+3A_data">data</code></td>
<td>
<p>Data frame or <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object, with necessary fields 'x' (longitudinal direction) and 'y' (latitudinal direction).  A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object is also permitted, from which the data will be extracted.
If <code>states=NULL</code> and a <code>momentuHMM</code>, <code>miHMM</code>, or <code>miSum</code> object is provided, the decoded states are automatically plotted.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_zoom">zoom</code></td>
<td>
<p>The zoom level, as defined for <code><a href="ggmap.html#topic+get_map">get_map</a></code>. Integer value between
3 (continent) and 21 (building).</p>
</td></tr>
<tr><td><code id="plotSat_+3A_location">location</code></td>
<td>
<p>Location of the center of the map to be plotted (this must be in the same coordinate reference system as <code>data</code>).</p>
</td></tr>
<tr><td><code id="plotSat_+3A_segments">segments</code></td>
<td>
<p><code>TRUE</code> if segments should be plotted between the observations (default),
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_compact">compact</code></td>
<td>
<p><code>FALSE</code> if tracks should be plotted separately, <code>TRUE</code>
otherwise (default).</p>
</td></tr>
<tr><td><code id="plotSat_+3A_col">col</code></td>
<td>
<p>Palette of colours to use for the dots and segments. If not specified, uses default palette.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_alpha">alpha</code></td>
<td>
<p>Transparency argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_size">size</code></td>
<td>
<p>Size argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_shape">shape</code></td>
<td>
<p>Shape argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>. If <code>states</code> is provided, then <code>shape</code> must either be a scalar or a vector of length <code>length(unique(states))</code>.
If <code>states=NULL</code>, then <code>shape</code> must either be a scalar or a vector consisting of a value for each individual to be plotted.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_states">states</code></td>
<td>
<p>A sequence of integers, corresponding to the decoded states for these data
(such that the observations are colored by states).</p>
</td></tr>
<tr><td><code id="plotSat_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals/tracks to be plotted.
Default: <code>NULL</code>; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_return">return</code></td>
<td>
<p>If <code>TRUE</code>, the function returns a ggplot object (which can be edited and
plotted manually). If <code>FALSE</code>, the function automatically plots the map (default).</p>
</td></tr>
<tr><td><code id="plotSat_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length <code>max(states)</code> indicating state names. Ignored unless <code>states</code> is provided.</p>
</td></tr>
<tr><td><code id="plotSat_+3A_projargs">projargs</code></td>
<td>
<p>A character string of PROJ.4 projection arguments indicating the coordinate reference system for <code>data</code> and <code>location</code> coordinates (if not longitude and latitude). A <code><a href="sp.html#topic+CRS-class">CRS</a></code> object is also permitted. If <code>projargs</code> is provided, the coordinates will be internally transformed to longitude and latitude for plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the plot displays the message &quot;Sorry, we have no imagery here&quot;, try a
lower level of zoom.
</p>


<h3>References</h3>

<p>D. Kahle and H. Wickham. ggmap: Spatial Visualization with ggplot2.
The R Journal, 5(1), 144-161.
URL: http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf
</p>

<hr>
<h2 id='plotSpatialCov'>Plot observations on raster image</h2><span id='topic+plotSpatialCov'></span>

<h3>Description</h3>

<p>Plot tracking data over a raster layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialCov(
  data,
  spatialCov,
  segments = TRUE,
  compact = TRUE,
  col = NULL,
  alpha = 1,
  size = 1,
  shape = 16,
  states = NULL,
  animals = NULL,
  ask = TRUE,
  return = FALSE,
  stateNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSpatialCov_+3A_data">data</code></td>
<td>
<p>Data frame or <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> object, with necessary fields 'x' (longitudinal direction) and 'y' (latitudinal direction).  A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object is also permitted, from which the data will be extracted.
If <code>states=NULL</code> and a <code>momentuHMM</code>, <code>miHMM</code>, or <code>miSum</code> object is provided, the decoded states are automatically plotted.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_spatialcov">spatialCov</code></td>
<td>
<p><code><a href="raster.html#topic+raster">raster</a></code> object of the <code>RasterLayer</code> class on which to plot the location data</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_segments">segments</code></td>
<td>
<p><code>TRUE</code> if segments should be plotted between the observations (default),
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_compact">compact</code></td>
<td>
<p><code>FALSE</code> if tracks should be plotted separately, <code>TRUE</code>
otherwise (default).</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_col">col</code></td>
<td>
<p>Palette of colours to use for the dots and segments. If not specified, uses default palette.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_alpha">alpha</code></td>
<td>
<p>Transparency argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_size">size</code></td>
<td>
<p>Size argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_shape">shape</code></td>
<td>
<p>Shape argument for <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>. If <code>states</code> is provided, then <code>shape</code> must either be a scalar or a vector of length <code>length(unique(states))</code>.
If <code>states=NULL</code>, then <code>shape</code> must either be a scalar or a vector consisting of a value for each individual to be plotted.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_states">states</code></td>
<td>
<p>A sequence of integers, corresponding to the decoded states for these data. If
specified, the observations are colored by states.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals/tracks to be plotted.
Default: <code>NULL</code>; all animals are plotted.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_return">return</code></td>
<td>
<p>If <code>TRUE</code>, the function returns a ggplot object (which can be edited and
plotted manually). If <code>FALSE</code>, the function automatically plots the map (default).</p>
</td></tr>
<tr><td><code id="plotSpatialCov_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length <code>max(states)</code> indicating state names. Ignored unless <code>states</code> is provided.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stepDist &lt;- "gamma"
angleDist &lt;- "vm"

# plot simulated data over forest raster automatically loaded with the packge
spatialCov&lt;-list(forest=forest)
data &lt;- simData(nbAnimals=2,nbStates=2,dist=list(step=stepDist,angle=angleDist),
                Par=list(step=c(100,1000,50,100),angle=c(0,0,0.1,5)),
                beta=matrix(c(5,-10,-25,50),nrow=2,ncol=2,byrow=TRUE),
                formula=~forest,spatialCovs=spatialCov,
                obsPerAnimal=225,states=TRUE)

plotSpatialCov(data,forest,states=data$states)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotStates'>Plot states</h2><span id='topic+plotStates'></span>

<h3>Description</h3>

<p>Plot the states and states probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStates(m, animals = NULL, ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStates_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object</p>
</td></tr>
<tr><td><code id="plotStates_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which states will be plotted.</p>
</td></tr>
<tr><td><code id="plotStates_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the execution pauses between each plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

# plot states for first and second animals
plotStates(m,animals=c(1,2))

</code></pre>

<hr>
<h2 id='plotStationary'>Plot stationary state probabilities</h2><span id='topic+plotStationary'></span>

<h3>Description</h3>

<p>Plot stationary state probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStationary(
  model,
  covs = NULL,
  col = NULL,
  plotCI = FALSE,
  alpha = 0.95,
  return = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStationary_+3A_model">model</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_covs">covs</code></td>
<td>
<p>Optional data frame consisting of a single row indicating the covariate values to be used in plots.
If none are specified, the means of any covariates appearing in the model are used (unless covariate is a factor, in which case the first factor in the data is used).</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_col">col</code></td>
<td>
<p>Vector or colors for the states (one color per state).</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_plotci">plotCI</code></td>
<td>
<p>Logical indicating whether to include confidence intervals in plots (default: FALSE)</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals (if <code>plotCI=TRUE</code>). Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_return">return</code></td>
<td>
<p>Logical indicating whether to return a list containing estimates, SEs, CIs, and covariate values used to create the plots for each mixture and state. Ignored if <code>plotCI=FALSE</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotStationary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>graphics::plot</code>. These can currently include <code>cex.axis</code>, <code>cex.lab</code>, <code>cex.legend</code>, <code>cex.main</code>, <code>legend.pos</code>, and <code>lwd</code>. See <code><a href="graphics.html#topic+par">par</a></code>. <code>legend.pos</code> can be a single keyword from the list &ldquo;bottomright&rdquo;, &ldquo;bottom&rdquo;, &ldquo;bottomleft&rdquo;, &ldquo;left&rdquo;, &ldquo;topleft&rdquo;, &ldquo;top&rdquo;, &ldquo;topright&rdquo;, &ldquo;right&rdquo;, and &ldquo;center&rdquo;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

plotStationary(m)

</code></pre>

<hr>
<h2 id='prepData'>Preprocessing of the data streams and covariates</h2><span id='topic+prepData'></span><span id='topic+prepData.default'></span><span id='topic+prepData.hierarchical'></span>

<h3>Description</h3>

<p>Preprocessing of the data streams, including calculation of step length, turning angle, and covariates from location data to be suitable for
analysis using <code><a href="#topic+fitHMM">fitHMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepData(data, ...)

## Default S3 method:
prepData(
  data,
  type = c("UTM", "LL"),
  coordNames = c("x", "y"),
  covNames = NULL,
  spatialCovs = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  altCoordNames = NULL,
  ...
)

## S3 method for class 'hierarchical'
prepData(
  data,
  type = c("UTM", "LL"),
  coordNames = c("x", "y"),
  covNames = NULL,
  spatialCovs = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  altCoordNames = NULL,
  hierLevels,
  coordLevel,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepData_+3A_data">data</code></td>
<td>
<p>Either a data frame of data streams or a <code><a href="#topic+crwData">crwData</a></code> (or <code><a href="#topic+crwHierData">crwHierData</a></code>) object (as returned by <code><a href="#topic+crawlWrap">crawlWrap</a></code>). If <code>data</code> is a data frame, it can optionally include a field <code>ID</code>
(identifiers for the observed individuals), coordinates from which step length ('step') 
and turning angle ('angle') are calculated, and any covariates (with names matching <code>covNames</code> and/or <code>angleCovs</code>). 
If step length and turning angle are to be calculated from coordinates, the <code>coordNames</code> argument 
must identify the names for the x- (longitunal) and y- (latitudinal) coordinates, and, for hierarchical data, the <code>coordLevel</code> argument must identify the level of the hierarchy at which the location data are obtained.
With the exception of <code>ID</code>, <code>coordNames</code>, and, for hierarchical data, <code>level</code>, all variables in <code>data</code> are treated as data streams unless identified
as covariates in <code>covNames</code> and/or <code>angleCovs</code>.</p>
</td></tr>
<tr><td><code id="prepData_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="prepData_+3A_type">type</code></td>
<td>
<p><code>'UTM'</code> if easting/northing provided (the default), <code>'LL'</code> if longitude/latitude. If <code>type='LL'</code> then step lengths are calculated in kilometers and turning angles are based on initial bearings (see <code><a href="#topic+turnAngle">turnAngle</a></code>).
Ignored if <code>data</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="prepData_+3A_coordnames">coordNames</code></td>
<td>
<p>Names of the columns of coordinates in the <code>data</code> data frame. Default: <code>c("x","y")</code>. If <code>coordNames=NULL</code> then step lengths, turning angles, 
and location covariates (i.e., those specified by <code>spatialCovs</code>, <code>centers</code>, and <code>angleCovs</code>) are not calculated. Ignored if <code>data</code> is a <code><a href="#topic+crwData">crwData</a></code> object.</p>
</td></tr>
<tr><td><code id="prepData_+3A_covnames">covNames</code></td>
<td>
<p>Character vector indicating the names of any covariates in <code>data</code> dataframe. Any variables in <code>data</code> (other than <code>ID</code>) that are not identified in 
<code>covNames</code> and/or <code>angleCovs</code> are assumed to be data streams (i.e., missing values will not be accounted for).</p>
</td></tr>
<tr><td><code id="prepData_+3A_spatialcovs">spatialCovs</code></td>
<td>
<p>List of <code><a href="raster.html#topic+raster">raster</a></code> objects for spatio-temporally referenced covariates. Covariates specified by <code>spatialCovs</code> are extracted from the raster 
layer(s) based on the location data (and the z values for a raster <code><a href="raster.html#topic+stack">stack</a></code> 
or <code><a href="raster.html#topic+brick">brick</a></code>) for each time step.  If an element of <code>spatialCovs</code> is a raster <code><a href="raster.html#topic+stack">stack</a></code> or <code><a href="raster.html#topic+brick">brick</a></code>, 
then z values must be set using <code>raster::setZ</code> and <code>data</code> must include column(s) of the corresponding z value(s) for each observation (e.g., 'time').</p>
</td></tr>
<tr><td><code id="prepData_+3A_centers">centers</code></td>
<td>
<p>2-column matrix providing the x-coordinates (column 1) and y-coordinates (column 2) for any activity centers (e.g., potential 
centers of attraction or repulsion) from which distance and angle covariates will be calculated based on the location data. If no row names are provided, then generic names are generated 
for the distance and angle covariates (e.g., 'center1.dist', 'center1.angle', 'center2.dist', 'center2.angle'); otherwise the covariate names are derived from the row names
of <code>centers</code> as <code>paste0(rep(rownames(centers),each=2),c(".dist",".angle"))</code>. As with covariates identified in <code>angleCovs</code>, note that the angle covariates for each activity center are calculated relative to 
the previous movement direction (instead of standard direction relative to the x-axis); this is to allow the mean turning angle to be modelled as a function of these covariates using circular-circular regression in <code><a href="#topic+fitHMM">fitHMM</a></code>
or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="prepData_+3A_centroids">centroids</code></td>
<td>
<p>List where each element is a data frame containing the x-coordinates ('x'), y-coordinates ('y'), and times (with user-specified name, e.g., &lsquo;time&rsquo;) for centroids (i.e., dynamic activity centers where the coordinates can change over time)
from which distance and angle covariates will be calculated based on the location data. If any centroids are specified, then <code>data</code> must include a column indicating the time of each observation, and this column name must match the corresponding user-specified 
name of the time column in <code>centroids</code> (e.g. &lsquo;time&rsquo;). Times can be numeric or POSIXt.  If no list names are provided, then generic names are generated 
for the distance and angle covariates (e.g., 'centroid1.dist', 'centroid1.angle', 'centroid2.dist', 'centroid2.angle'); otherwise the covariate names are derived from the list names
of <code>centroids</code> as <code>paste0(rep(names(centroids),each=2),c(".dist",".angle"))</code>. As with covariates identified in <code>angleCovs</code>, note that the angle covariates for each centroid are calculated relative to 
the previous movement direction (instead of standard direction relative to the x-axis); this is to allow the mean turning angle to be modelled as a function of these covariates using circular-circular regression in <code><a href="#topic+fitHMM">fitHMM</a></code>
or <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="prepData_+3A_anglecovs">angleCovs</code></td>
<td>
<p>Character vector indicating the names of any circular-circular regression angular covariates in <code>data</code> or <code>spatialCovs</code> that need conversion from standard direction (in radians relative to the x-axis) to turning angle (relative to previous movement direction) 
using <code><a href="#topic+circAngles">circAngles</a></code>.</p>
</td></tr>
<tr><td><code id="prepData_+3A_altcoordnames">altCoordNames</code></td>
<td>
<p>Character string indicating an alternative name for the returned location data. If provided, then <code>prepData</code> will return easting (or longitude) coordinate names as <code>paste0(altCoordNames,".x")</code> and northing (or latitude) as <code>paste0(altCoordNames,".y")</code> instead of <code>x</code> and <code>y</code>, respectively. This can be useful for location data that are intended to be modeled using a bivariate normal distribution (see <code><a href="#topic+fitHMM">fitHMM</a></code>). Ignored unless <code>coordNames</code> are provided.</p>
</td></tr>
<tr><td><code id="prepData_+3A_hierlevels">hierLevels</code></td>
<td>
<p>Character vector indicating the levels of the hierarchy and their order, from top (coarsest scale) to bottom (finest scale), that are included in <code>data$level</code>. For example, for a 2-level hierarchy then 
<code>hierLevels=c("1","2i","2")</code> indicates <code>data$level</code> for each observation can be one of three factor levels: &quot;1&quot; (coarse scale), &quot;2i&quot; (initial fine scale), and &quot;2&quot; (fine scale).  Ignored if <code>data</code> is a <code><a href="#topic+crwHierData">crwHierData</a></code> object.</p>
</td></tr>
<tr><td><code id="prepData_+3A_coordlevel">coordLevel</code></td>
<td>
<p>Character string indicating the level of the hierarchy for the location data. If specified, then <code>data</code> must include a 'level' field indicating the level of the hierarchy for each observation.  Ignored if <code>coordNames</code> is <code>NULL</code> or <code>data</code> is a <code><a href="#topic+crwHierData">crwHierData</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>data</code> is a <code><a href="#topic+crwData">crwData</a></code> (or <code><a href="#topic+crwHierData">crwHierData</a></code>) object, the <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> (or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>) object created by <code>prepData</code> includes step lengths and turning angles calculated from the best predicted 
locations (i.e., <code>crwData$crwPredict$mu.x</code> and <code>crwData$crwPredict$mu.y</code>). Prior to using <code>prepData</code>, additional data streams or covariates unrelated to location (including z-values associated with
<code>spatialCovs</code> raster stacks or bricks) can be merged with the <code>crwData</code> (or <code>crwHierData</code>) object using <code><a href="#topic+crawlMerge">crawlMerge</a></code>.
</p>
</li>
<li><p> For hierarchical data, <code>data</code> must include a 'level' field indicating the level of the hierarchy for each observation, and, for location data identified by <code>coordNames</code>, the <code>coordLevel</code> argument must indicate the level of the hierarchy at which the location data are obtained.
</p>
</li></ul>



<h3>Value</h3>

<p>An object <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>, i.e., a dataframe of:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>The ID(s) of the observed animal(s)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Data streams (e.g., 'step', 'angle', etc.)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Either easting or longitude (if <code>coordNames</code> is specified or <code>data</code> is a <code>crwData</code> object)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Either norting or latitude (if <code>coordNames</code> is specified or <code>data</code> is a <code>crwData</code> object)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Covariates (if any)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+crawlMerge">crawlMerge</a></code>, <code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="#topic+crwData">crwData</a></code>
</p>
<p><code><a href="#topic+crwHierData">crwHierData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord1 &lt;- c(1,2,3,4,5,6,7,8,9,10)
coord2 &lt;- c(1,1,1,2,2,2,1,1,1,2)
cov1 &lt;- rnorm(10)

data &lt;- data.frame(coord1=coord1,coord2=coord2,cov1=cov1)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),covNames="cov1")

# include additional data stream named 'omega'
omega &lt;- rbeta(10,1,1)
data &lt;- data.frame(coord1=coord1,coord2=coord2,omega=omega,cov1=cov1)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),covNames="cov1")

# include 'forest' example raster layer as covariate
data &lt;- data.frame(coord1=coord1*1000,coord2=coord2*1000)
spatialCov &lt;- list(forest=forest)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),spatialCovs=spatialCov)

# include 2 activity centers
data &lt;- data.frame(coord1=coord1,coord2=coord2,cov1=cov1)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),covNames="cov1",
              centers=matrix(c(0,10,0,10),2,2,dimnames=list(c("c1","c2"),NULL)))
              
# include centroid
data &lt;- data.frame(coord1=coord1,coord2=coord2,cov1=cov1,time=1:10)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),covNames="cov1",
              centroid=list(centroid=data.frame(x=coord1+rnorm(10),
                                                y=coord2+rnorm(10),
                                                time=1:10)))
              
# Include angle covariate that needs conversion to 
# turning angle relative to previous movement direction
u &lt;- rnorm(10) # horizontal component
v &lt;- rnorm(10) # vertical component
cov2 &lt;- atan2(v,u)
data &lt;- data.frame(coord1=coord1,coord2=coord2,cov1=cov1,cov2=cov2)
d &lt;- prepData(data,coordNames=c("coord1","coord2"),covNames="cov1",
              angleCovs="cov2")

</code></pre>

<hr>
<h2 id='print.miHMM'>Print <code>miHMM</code></h2><span id='topic+print.miHMM'></span>

<h3>Description</h3>

<p>Print <code>miHMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miHMM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.miHMM_+3A_x">x</code></td>
<td>
<p>A <code>miHMM</code> object.</p>
</td></tr>
<tr><td><code id="print.miHMM_+3A_...">...</code></td>
<td>
<p>Currently unused. For compatibility with generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Extract data from miExample
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crawl to obsData
crwOut &lt;- crawlWrap(obsData,theta=c(4,0),fixPar=c(1,1,NA,NA),
                    err.model=err.model)
                    
# Fit four imputations
bPar &lt;- miExample$bPar
HMMfits &lt;- MIfitHMM(crwOut,nSims=4,poolEstimates=FALSE,
                   nbStates=2,dist=list(step="gamma",angle="vm"),
                   Par0=bPar$Par,beta0=bPar$beta,
                   formula=~cov1+cos(cov2),
                   estAngleMean=list(angle=TRUE),
                   covNames=c("cov1","cov2"))
                   
miHMM &lt;- momentuHMM:::miHMM(list(miSum=MIpool(HMMfits),HMMfits=HMMfits))
print(miHMM)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.miSum'>Print <code>miSum</code></h2><span id='topic+print.miSum'></span>

<h3>Description</h3>

<p>Print <code>miSum</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miSum'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.miSum_+3A_x">x</code></td>
<td>
<p>A <code>miSum</code> object.</p>
</td></tr>
<tr><td><code id="print.miSum_+3A_...">...</code></td>
<td>
<p>Currently unused. For compatibility with generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Extract data from miExample
obsData &lt;- miExample$obsData

# error ellipse model
err.model &lt;- list(x= ~ ln.sd.x - 1, y =  ~ ln.sd.y - 1, rho =  ~ error.corr)

# Fit crawl to obsData
crwOut &lt;- crawlWrap(obsData,theta=c(4,0),fixPar=c(1,1,NA,NA),
                    err.model=err.model)
                    
# Fit four imputations
bPar &lt;- miExample$bPar
HMMfits &lt;- MIfitHMM(crwOut,nSims=4,poolEstimates=FALSE,
                   nbStates=2,dist=list(step="gamma",angle="vm"),
                   Par0=bPar$Par,beta0=bPar$beta,
                   formula=~cov1+cos(cov2),
                   estAngleMean=list(angle=TRUE),
                   covNames=c("cov1","cov2"))
                   
# Pool estimates
miSum &lt;- MIpool(HMMfits)
print(miSum)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.momentuHMM'>Print <code>momentuHMM</code></h2><span id='topic+print.momentuHMM'></span><span id='topic+print.momentuHierHMM'></span>

<h3>Description</h3>

<p>Print <code>momentuHMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'momentuHMM'
print(x, ...)

## S3 method for class 'momentuHierHMM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.momentuHMM_+3A_x">x</code></td>
<td>
<p>A <code>momentuHMM</code> object.</p>
</td></tr>
<tr><td><code id="print.momentuHMM_+3A_...">...</code></td>
<td>
<p>Currently unused. For compatibility with generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

print(m)

</code></pre>

<hr>
<h2 id='pseudoRes'>Pseudo-residuals</h2><span id='topic+pseudoRes'></span>

<h3>Description</h3>

<p>The pseudo-residuals of momentuHMM models, as described in Zucchini and McDonad (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoRes(m, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoRes_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object.</p>
</td></tr>
<tr><td><code id="pseudoRes_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some turning angles in the data are equal to pi, the corresponding pseudo-residuals
will not be included. Indeed, given that the turning angles are defined on (-pi,pi], an angle of pi
results in a pseudo-residual of +Inf (check Section 6.2 of reference for more information on the
computation of pseudo-residuals).
</p>
<p>A continuity adjustment (adapted from Harte 2017) is made for discrete probability distributions. When
the data are near the boundary (e.g. 0 for &ldquo;pois&rdquo;; 0 and 1 for &ldquo;bern&rdquo;), then the pseudo residuals can
be a poor indicator of lack of fit.
</p>
<p>For multiple imputation analyses, if <code>m</code> is a <code><a href="#topic+miHMM">miHMM</a></code> object or a list of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects, then
the pseudo-residuals are individually calculated for each model fit. Note that pseudo-residuals for <code><a href="#topic+miSum">miSum</a></code> objects (as returned by <code><a href="#topic+MIpool">MIpool</a></code>) are based on pooled parameter 
estimates and the means of the data values across all imputations (and therefore may not be particularly meaningful).
</p>


<h3>Value</h3>

<p>If <code>m</code> is a <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object, a list of pseudo-residuals for each data stream (e.g., 'stepRes', 'angleRes') is returned. 
If <code>m</code> is a list of <code><a href="#topic+momentuHMM">momentuHMM</a></code> objects, then a list of length <code>length(m)</code> is returned where each element is a list of pseudo-residuals for each data stream.
</p>


<h3>References</h3>

<p>Harte, D. 2017. HiddenMarkov: Hidden Markov Models. R package version 1.8-8.
</p>
<p>Zucchini, W. and MacDonald, I.L. 2009.
Hidden Markov Models for Time Series: An Introduction Using R.
Chapman &amp; Hall (London).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m
res &lt;- pseudoRes(m)
stats::qqnorm(res$stepRes)
stats::qqnorm(res$angleRes)

</code></pre>

<hr>
<h2 id='randomEffects'>Random effects estimation</h2><span id='topic+randomEffects'></span>

<h3>Description</h3>

<p>Approximate individual-level random effects estimation for state transition probabilities based on Burnham &amp; White (2002)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomEffects(
  m,
  Xformula = ~1,
  alpha = 0.95,
  ncores = 1,
  nlmPar = list(),
  fit = TRUE,
  retryFits = 0,
  retrySD = NULL,
  optMethod = "nlm",
  control = list(),
  modelName = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomEffects_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code> object.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_xformula">Xformula</code></td>
<td>
<p>Formula for the design matrix of the random effects model. The default <code>Xformula=~1</code> specifies an intercept-only model with no additional individual covariate effects.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the confidence intervals. Default: 0.95 (i.e. 95% CIs).</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_nlmpar">nlmPar</code></td>
<td>
<p>List of parameters to pass to the optimization function <code><a href="stats.html#topic+nlm">nlm</a></code>. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_fit">fit</code></td>
<td>
<p><code>TRUE</code> if the HMM should be re-fitted at the shrinkage estimates, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_retryfits">retryFits</code></td>
<td>
<p>Non-negative integer indicating the number of times to attempt to iteratively fit the model using random perturbations of the current parameter estimates as the 
initial values for likelihood optimization. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_retrysd">retrySD</code></td>
<td>
<p>An optional list of scalars or vectors indicating the standard deviation to use for normal perturbations of each working scale parameter when <code>retryFits&gt;0</code>. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_optmethod">optMethod</code></td>
<td>
<p>The optimization method to be used. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_control">control</code></td>
<td>
<p>A list of control parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code> (ignored unless <code>optMethod="Nelder-Mead"</code> or <code>optMethod="SANN"</code>).</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_modelname">modelName</code></td>
<td>
<p>An optional character string providing a name for the fitted model. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="randomEffects_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>randomEffects</code> model similar to a <code><a href="#topic+momentuHMM">momentuHMM</a></code> object, but including the additional random effect components:
</p>
<table>
<tr><td><code>varcomp</code></td>
<td>
<p>A list of length <code>nbStates*(nbStates-1)</code> with each element containing the random effect mean coefficient(s) (<code>mu</code>), random effect variance (<code>sigma</code>), 
and logit-scale shrinkage estimates for the state transition probability parameters (<code>ztilde</code>).</p>
</td></tr>
<tr><td><code>traceG</code></td>
<td>
<p>The trace of the projection matrix for each random effect.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Burnham, K.P. and White, G.C. 2002. Evaluation of some random effects methodology applicable to bird ringing data. Journal of Applied Statistics 29: 245-264.
</p>
<p>McClintock, B.T. 2021. Worth the effort? A practical examination of random effects in hidden Markov models for animal telemetry data. Methods in Ecology and Evolution <a href="https://doi.org/10.1111/2041-210X.13619">doi:10.1111/2041-210X.13619</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulated data with normal random effects
# and binary individual covariate 

nbAnimals &lt;- 5 # should be larger for random effects estimation
obsPerAnimal &lt;- 110
indCov &lt;- rbinom(nbAnimals,1,0.5) # individual covariate
betaCov &lt;- c(-0.5,0.5) # covariate effects
mu &lt;- c(-0.1,0.1) # mean for random effects
sigma &lt;- c(0.2,0.4) # sigma for random effects
beta0 &lt;- cbind(rnorm(nbAnimals,mu[1],sigma[1]),
               rnorm(nbAnimals,mu[2],sigma[2]))

reData &lt;- simData(nbAnimals=nbAnimals,obsPerAnimal=obsPerAnimal,nbStates=2,
                  dist=list(step="gamma"),formula=~0+ID+indCov,
                  Par=list(step=c(1,10,1,2)),
                  beta=rbind(beta0,betaCov),
                  covs=data.frame(indCov=rep(indCov,each=obsPerAnimal)))

# fit null model
nullFit &lt;- fitHMM(reData,nbStates=2,
                  dist=list(step="gamma"),
                  Par0=list(step=c(1,10,1,2)))

# fit covariate model
covFit &lt;- fitHMM(reData,nbStates=2,
                 dist=list(step="gamma"),formula=~indCov,
                 Par0=list(step=c(1,10,1,2)),
                 beta0=rbind(mu,betaCov)) 

# fit fixed effects model
fixFit &lt;- fitHMM(reData,nbStates=2,
                 dist=list(step="gamma"),formula=~0+ID,
                 Par0=list(step=c(1,10,1,2)),
                 beta0=beta0)

# fit random effect model
reFit &lt;- randomEffects(fixFit)

# fit random effect model with individual covariate
reCovFit &lt;- randomEffects(fixFit, Xformula=~indCov)

# compare by AICc
AIC(nullFit,covFit,fixFit,reFit,reCovFit, n=nrow(reData))

## End(Not run)
</code></pre>

<hr>
<h2 id='setModelName'>Set <code>modelName</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object</h2><span id='topic+setModelName'></span>

<h3>Description</h3>

<p>Set <code>modelName</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setModelName(model, modelName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setModelName_+3A_model">model</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object</p>
</td></tr>
<tr><td><code id="setModelName_+3A_modelname">modelName</code></td>
<td>
<p>Character string providing a name for the model. See <code><a href="#topic+fitHMM">fitHMM</a></code> and <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>model</code> object with new <code>modelName</code> field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- example$m
mName &lt;- setModelName(m, modelName="example")

</code></pre>

<hr>
<h2 id='setStateNames'>Set <code>stateNames</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object</h2><span id='topic+setStateNames'></span>

<h3>Description</h3>

<p>Set <code>stateNames</code> for a <code>momentuHMM</code>, <code>miHMM</code>, <code>HMMfits</code>, or <code>miSum</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setStateNames(model, stateNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setStateNames_+3A_model">model</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, <code><a href="#topic+HMMfits">HMMfits</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object</p>
</td></tr>
<tr><td><code id="setStateNames_+3A_statenames">stateNames</code></td>
<td>
<p>Character string providing state names for the model. See <code><a href="#topic+fitHMM">fitHMM</a></code> and <code><a href="#topic+MIfitHMM">MIfitHMM</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>model</code> object with new <code>stateNames</code> field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- example$m
mName &lt;- setStateNames(m, stateNames=c("encamped","exploratory"))

</code></pre>

<hr>
<h2 id='simData'>Simulation tool</h2><span id='topic+simData'></span><span id='topic+simHierData'></span>

<h3>Description</h3>

<p>Simulates data from a (multivariate) hidden Markov model. Movement data are assumed to be in Cartesian coordinates (not longitude/latitude) and can be generated with or without observation error attributable to temporal irregularity or location measurement error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simData(
  nbAnimals = 1,
  nbStates = 2,
  dist,
  Par,
  beta = NULL,
  delta = NULL,
  formula = ~1,
  formulaDelta = NULL,
  mixtures = 1,
  formulaPi = NULL,
  covs = NULL,
  nbCovs = 0,
  spatialCovs = NULL,
  zeroInflation = NULL,
  oneInflation = NULL,
  circularAngleMean = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  obsPerAnimal = c(500, 1500),
  initialPosition = c(0, 0),
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  betaRef = NULL,
  mvnCoords = NULL,
  stateNames = NULL,
  model = NULL,
  states = FALSE,
  retrySims = 0,
  lambda = NULL,
  errorEllipse = NULL,
  ncores = 1
)

simHierData(
  nbAnimals = 1,
  hierStates,
  hierDist,
  Par,
  hierBeta = NULL,
  hierDelta = NULL,
  hierFormula = NULL,
  hierFormulaDelta = NULL,
  mixtures = 1,
  formulaPi = NULL,
  covs = NULL,
  nbHierCovs = NULL,
  spatialCovs = NULL,
  zeroInflation = NULL,
  oneInflation = NULL,
  circularAngleMean = NULL,
  centers = NULL,
  centroids = NULL,
  angleCovs = NULL,
  obsPerLevel,
  initialPosition = c(0, 0),
  DM = NULL,
  userBounds = NULL,
  workBounds = NULL,
  mvnCoords = NULL,
  model = NULL,
  states = FALSE,
  retrySims = 0,
  lambda = NULL,
  errorEllipse = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simData_+3A_nbanimals">nbAnimals</code></td>
<td>
<p>Number of observed individuals to simulate.</p>
</td></tr>
<tr><td><code id="simData_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of behavioural states to simulate.</p>
</td></tr>
<tr><td><code id="simData_+3A_dist">dist</code></td>
<td>
<p>A named list indicating the probability distributions of the data streams. Currently
supported distributions are 'bern', 'beta', 'cat', 'exp', 'gamma', 'lnorm', 'logis', 'negbinom', 'norm', 'mvnorm2' (bivariate normal distribution), 'mvnorm3' (trivariate normal distribution),
'pois', 'rw_norm' (normal random walk), 'rw_mvnorm2' (bivariate normal random walk), 'rw_mvnorm3' (trivariate normal random walk), 'vm', 'vmConsensus', 'weibull', and 'wrpcauchy'. For example,
<code>dist=list(step='gamma', angle='vm', dives='pois')</code> indicates 3 data streams ('step', 'angle', and 'dives')
and their respective probability distributions ('gamma', 'vm', and 'pois').</p>
</td></tr>
<tr><td><code id="simData_+3A_par">Par</code></td>
<td>
<p>A named list containing vectors of initial state-dependent probability distribution parameters for 
each data stream specified in <code>dist</code>. The parameters should be in the order expected by the pdfs of <code>dist</code>, 
and any zero-mass and/or one-mass parameters should be the last (if both are present, then zero-mass parameters must preceed one-mass parameters). 
</p>
<p>If <code>DM</code> is not specified for a given data stream, then <code>Par</code> 
is on the natural (i.e., real) scale of the parameters. However, if <code>DM</code> is specified for a given data stream, then 
<code>Par</code> must be on the working (i.e., beta) scale of the parameters, and the length of <code>Par</code> must match the number 
of columns in the design matrix. See details below.</p>
</td></tr>
<tr><td><code id="simData_+3A_beta">beta</code></td>
<td>
<p>Matrix of regression parameters for the transition probabilities (more information
in &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="simData_+3A_delta">delta</code></td>
<td>
<p>Initial value for the initial distribution of the HMM. Default: <code>rep(1/nbStates,nbStates)</code>. If <code>formulaDelta</code> includes a formula, then <code>delta</code> must be specified
as a k x (<code>nbStates</code>-1) matrix, where k is the number of covariates and the columns correspond to states 2:<code>nbStates</code>. See details below.</p>
</td></tr>
<tr><td><code id="simData_+3A_formula">formula</code></td>
<td>
<p>Regression formula for the transition probability covariates. Default: <code>~1</code> (no covariate effect). In addition to allowing standard functions in R formulas
(e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>), special functions include <code>cosinor(cov,period)</code> for modeling cyclical patterns, spline functions 
(<code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines2.html#topic+bSpline">bSpline</a></code>, <code><a href="splines2.html#topic+cSpline">cSpline</a></code>, <code><a href="splines2.html#topic+iSpline">iSpline</a></code>, and <code><a href="splines2.html#topic+mSpline">mSpline</a></code>), 
and state- or parameter-specific formulas (see details).
Any formula terms that are not state- or parameter-specific are included on all of the transition probabilities.</p>
</td></tr>
<tr><td><code id="simData_+3A_formuladelta">formulaDelta</code></td>
<td>
<p>Regression formula for the initial distribution. Default: <code>NULL</code> (no covariate effects and <code>delta</code> is specified on the real scale). Standard functions in R formulas are allowed (e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>). When any formula is provided, then <code>delta</code> must be specified on the working scale.</p>
</td></tr>
<tr><td><code id="simData_+3A_mixtures">mixtures</code></td>
<td>
<p>Number of mixtures for the state transition probabilities  (i.e. discrete random effects *sensu* DeRuiter et al. 2017). Default: <code>mixtures=1</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_formulapi">formulaPi</code></td>
<td>
<p>Regression formula for the mixture distribution probabilities. Default: <code>NULL</code> (no covariate effects; both <code>beta$pi</code> and <code>fixPar$pi</code> are specified on the real scale). Standard functions in R formulas are allowed (e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>). When any formula is provided, then both <code>beta$pi</code> and <code>fixPar$pi</code> are specified on the working scale.
Note that only the covariate values corresponding to the first time step for each individual ID are used (i.e. time-varying covariates cannot be used for the mixture probabilties).</p>
</td></tr>
<tr><td><code id="simData_+3A_covs">covs</code></td>
<td>
<p>Covariate values to include in the simulated data, as a dataframe. The names of any covariates specified by <code>covs</code> can
be included in <code>formula</code> and/or <code>DM</code>. Covariates can also be simulated according to a standard normal distribution, by setting
<code>covs</code> to <code>NULL</code> (the default), and specifying <code>nbCovs&gt;0</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_nbcovs">nbCovs</code></td>
<td>
<p>Number of covariates to simulate (0 by default). Does not need to be specified if
<code>covs</code> is specified. Simulated covariates are provided generic names (e.g., 'cov1' and 'cov2' for <code>nbCovs=2</code>) and can be included in <code>formula</code> and/or <code>DM</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_spatialcovs">spatialCovs</code></td>
<td>
<p>List of <code><a href="raster.html#topic+raster">raster</a></code> objects for spatio-temporally referenced covariates. Covariates specified by <code>spatialCovs</code> are extracted from the raster 
layer(s) based on any simulated location data (and the z values for a raster <code><a href="raster.html#topic+stack">stack</a></code> 
or <code><a href="raster.html#topic+brick">brick</a></code>) for each time step.  If an element of <code>spatialCovs</code> is a raster <code><a href="raster.html#topic+stack">stack</a></code> or <code><a href="raster.html#topic+brick">brick</a></code>, 
then z values must be set using <code>raster::setZ</code> and <code>covs</code> must include column(s) of the corresponding z value(s) for each observation (e.g., 'time').
The names of the raster layer(s) can be included in 
<code>formula</code> and/or <code>DM</code>.  Note that <code>simData</code> usually takes longer to generate simulated data when <code>spatialCovs</code> is specified.</p>
</td></tr>
<tr><td><code id="simData_+3A_zeroinflation">zeroInflation</code></td>
<td>
<p>A named list of logicals indicating whether the probability distributions of the data streams should be zero-inflated. If <code>zeroInflation</code> is <code>TRUE</code> 
for a given data stream, then values for the zero-mass parameters should be
included in the corresponding element of <code>Par</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_oneinflation">oneInflation</code></td>
<td>
<p>A named list of logicals indicating whether the probability distributions of the data streams should be one-inflated. If <code>oneInflation</code> is <code>TRUE</code> 
for a given data stream, then values for the one-mass parameters should be
included in the corresponding element of <code>Par</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>An optional named list indicating whether to use circular-linear (FALSE) or circular-circular (TRUE) 
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles.  For example, 
<code>circularAngleMean=list(angle=TRUE)</code> indicates the angle mean is be estimated for 'angle' using circular-circular 
regression.  Whenever circular-circular regression is used for an angular data stream, a corresponding design matrix (<code>DM</code>) 
must be specified for the data stream, and the previous movement direction (i.e., a turning angle of zero) is automatically used 
as the reference angle (i.e., the intercept). Default is <code>NULL</code>, which assumes circular-linear regression is 
used for any angular distributions. Any <code>circularAngleMean</code> elements 
corresponding to data streams that do not have angular distributions are ignored.
<code>circularAngleMean</code> is also ignored for any 'vmConsensus' data streams (because the consensus model is a circular-circular regression model).
</p>
<p>Alternatively, <code>circularAngleMean</code> can be specified as a numeric scalar, where the value specifies the coefficient for the reference angle (i.e., directional persistence) term in the circular-circular regression model. For example, setting <code>circularAngleMean</code> to <code>0</code> specifies a 
circular-circular regression model with no directional persistence term (thus specifying a biased random walk instead of a biased correlated random walk). Setting <code>circularAngleMean</code> to 1 is equivalent to setting it to TRUE, i.e., a circular-circular regression model with a coefficient of 1 for the directional persistence reference angle.</p>
</td></tr>
<tr><td><code id="simData_+3A_centers">centers</code></td>
<td>
<p>2-column matrix providing the x-coordinates (column 1) and y-coordinates (column 2) for any activity centers (e.g., potential 
centers of attraction or repulsion) from which distance and angle covariates will be calculated based on the simulated location data. These distance and angle 
covariates can be included in <code>formula</code> and <code>DM</code> using the row names of <code>centers</code>.  If no row names are provided, then generic names are generated 
for the distance and angle covariates (e.g., 'center1.dist', 'center1.angle', 'center2.dist', 'center2.angle'); otherwise the covariate names are derived from the row names
of <code>centers</code> as <code>paste0(rep(rownames(centers),each=2),c(".dist",".angle"))</code>. Note that the angle covariates for each activity center are calculated relative to 
the previous movement direction instead of standard directions relative to the x-axis; this is to allow turning angles to be simulated as a function of these covariates using circular-circular regression.</p>
</td></tr>
<tr><td><code id="simData_+3A_centroids">centroids</code></td>
<td>
<p>List where each element is a data frame consisting of at least <code>max(unlist(obsPerAnimal))</code> rows that provides the x-coordinates ('x') and y-coordinates ('y) for centroids (i.e., dynamic activity centers where the coordinates can change for each time step)
from which distance and angle covariates will be calculated based on the simulated location data. These distance and angle 
covariates can be included in <code>formula</code> and <code>DM</code> using the names of <code>centroids</code>.  If no list names are provided, then generic names are generated 
for the distance and angle covariates (e.g., 'centroid1.dist', 'centroid1.angle', 'centroid2.dist', 'centroid2.angle'); otherwise the covariate names are derived from the list names
of <code>centroids</code> as <code>paste0(rep(names(centroids),each=2),c(".dist",".angle"))</code>. Note that the angle covariates for each centroid are calculated relative to 
the previous movement direction instead of standard directions relative to the x-axis; this is to allow turning angles to be simulated as a function of these covariates using circular-circular regression.</p>
</td></tr>
<tr><td><code id="simData_+3A_anglecovs">angleCovs</code></td>
<td>
<p>Character vector indicating the names of any circular-circular regression angular covariates in <code>covs</code> or <code>spatialCovs</code> that need conversion from standard direction (in radians relative to the x-axis) to turning angle (relative to previous movement direction) 
using <code><a href="#topic+circAngles">circAngles</a></code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_obsperanimal">obsPerAnimal</code></td>
<td>
<p>Either the number of observations per animal (if single value) or the bounds of the number of observations per animal (if vector of two values). In the latter case, 
the numbers of obervations generated for each animal are uniformously picked from this interval. Alternatively, <code>obsPerAnimal</code> can be specified as
a list of length <code>nbAnimals</code> with each element providing the number of observations (if single value) or the bounds (if vector of two values) for each individual.
Default: <code>c(500,1500)</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_initialposition">initialPosition</code></td>
<td>
<p>2-vector providing the x- and y-coordinates of the initial position for all animals. Alternatively, <code>initialPosition</code> can be specified as
a list of length <code>nbAnimals</code> with each element a 2-vector providing the x- and y-coordinates of the initial position for each individual.
Default: <code>c(0,0)</code>.  If <code>mvnCoord</code> corresponds to a data stream with &ldquo;mvnorm3&rdquo; or &rdquo;rw_mvnorm3&rdquo; probability distributions, then <code>initialPosition</code> must be composed of 3-vector(s) for the x-, y-, and z-coordinates.</p>
</td></tr>
<tr><td><code id="simData_+3A_dm">DM</code></td>
<td>
<p>An optional named list indicating the design matrices to be used for the probability distribution parameters of each data 
stream. Each element of <code>DM</code> can either be a named list of regression formulas or a &ldquo;pseudo&rdquo; design matrix.  For example, for a 2-state 
model using the gamma distribution for a data stream named 'step', <code>DM=list(step=list(mean=~cov1, sd=~1))</code> specifies the mean 
parameters as a function of the covariate 'cov1' for each state.  This model could equivalently be specified as a 4x6 &ldquo;pseudo&rdquo; design matrix using 
character strings for the covariate: 
<code>DM=list(step=matrix(c(1,0,0,0,'cov1',0,0,0,0,1,0,0,0,'cov1',0,0,0,0,1,0,0,0,0,1),4,6))</code>
where the 4 rows correspond to the state-dependent paramaters (mean_1,mean_2,sd_1,sd_2) and the 6 columns correspond to the regression 
coefficients. 
</p>
<p>Design matrices specified using formulas allow standard functions in R formulas
(e.g., <code>cos(cov)</code>, <code>cov1*cov2</code>, <code>I(cov^2)</code>).  Special formula functions include <code>cosinor(cov,period)</code> for modeling cyclical patterns, spline functions 
(<code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines2.html#topic+bSpline">bSpline</a></code>, <code><a href="splines2.html#topic+cSpline">cSpline</a></code>, <code><a href="splines2.html#topic+iSpline">iSpline</a></code>, and <code><a href="splines2.html#topic+mSpline">mSpline</a></code>), 
<code>angleFormula(cov,strength,by)</code> for the angle mean of circular-circular regression models, and state-specific formulas (see details). Any formula terms that are not state-specific are included on the parameters for all <code>nbStates</code> states.</p>
</td></tr>
<tr><td><code id="simData_+3A_userbounds">userBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream. For example, for a 2-state model using the wrapped Cauchy ('wrpcauchy') distribution for 
a data stream named 'angle' with <code>estAngleMean$angle=TRUE)</code>, <code>userBounds=list(angle=matrix(c(-pi,-pi,-1,-1,pi,pi,1,1),4,2,dimnames=list(c("mean_1",
"mean_2","concentration_1","concentration_2"))))</code> 
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
<tr><td><code id="simData_+3A_workbounds">workBounds</code></td>
<td>
<p>An optional named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters. For each matrix, the first column pertains to the lower bound and the second column the upper bound.
For data streams, each element of <code>workBounds</code> should be a k x 2 matrix with the same name of the corresponding element of 
<code>Par</code>, where k is the number of parameters. For transition probability parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;beta&rdquo;, where k=<code>length(beta)</code>. For initial distribution parameters, the corresponding element of <code>workBounds</code> must be a k x 2 matrix named &ldquo;delta&rdquo;, where k=<code>length(delta)</code>.
<code>workBounds</code> is ignored for any given data stream unless <code>DM</code> is also specified.</p>
</td></tr>
<tr><td><code id="simData_+3A_betaref">betaRef</code></td>
<td>
<p>Numeric vector of length <code>nbStates</code> indicating the reference elements for the t.p.m. multinomial logit link. Default: NULL, in which case
the diagonal elements of the t.p.m. are the reference. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_mvncoords">mvnCoords</code></td>
<td>
<p>Character string indicating the name of location data that are to be simulated using a multivariate normal distribution. For example, if <code>mu="rw_mvnorm2"</code> was included in <code>dist</code> and (mu.x, mu.y) are intended to be location data, then <code>mvnCoords="mu"</code> needs to be specified in order for these data to be treated as such.</p>
</td></tr>
<tr><td><code id="simData_+3A_statenames">stateNames</code></td>
<td>
<p>Optional character vector of length nbStates indicating state names.</p>
</td></tr>
<tr><td><code id="simData_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object. This option can be used to simulate from a fitted model.  Default: NULL.
Note that, if this argument is specified, most other arguments will be ignored &ndash; except for <code>nbAnimals</code>,
<code>obsPerAnimal</code>, <code>states</code>, <code>initialPosition</code>, <code>lambda</code>, <code>errorEllipse</code>, and, if covariate values different from those in the data should be specified, 
<code>covs</code>, <code>spatialCovs</code>, <code>centers</code>, and <code>centroids</code>. It is not appropriate to simulate movement data from a <code>model</code> that was fitted to latitude/longitude data (because <code>simData</code> assumes Cartesian coordinates).</p>
</td></tr>
<tr><td><code id="simData_+3A_states">states</code></td>
<td>
<p><code>TRUE</code> if the simulated states should be returned, <code>FALSE</code> otherwise (default).</p>
</td></tr>
<tr><td><code id="simData_+3A_retrysims">retrySims</code></td>
<td>
<p>Number of times to attempt to simulate data within the spatial extent of <code>spatialCovs</code>. If <code>retrySims=0</code> (the default), an
error is returned if the simulated tracks(s) move beyond the extent(s) of the raster layer(s). Instead of relying on <code>retrySims</code>, in many cases
it might be better to simply expand the extent of the raster layer(s) and/or adjust the step length and turning angle probability distributions. 
Ignored if <code>spatialCovs=NULL</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_lambda">lambda</code></td>
<td>
<p>Observation rate for location data. If <code>NULL</code> (the default), location data are obtained at regular intervals. Otherwise 
<code>lambda</code> is the rate parameter of the exponential distribution for the waiting times between successive location observations, i.e., 
<code>1/lambda</code> is the expected time between successive location observations. Only the 'step' and 'angle' data streams are subject to temporal irregularity;
any other data streams are observed at temporally-regular intervals.  Ignored unless a valid distribution for the 'step' data stream is specified.</p>
</td></tr>
<tr><td><code id="simData_+3A_errorellipse">errorEllipse</code></td>
<td>
<p>List providing the upper bound for the semi-major axis (<code>M</code>; on scale of x- and y-coordinates), semi-minor axis (<code>m</code>; 
on scale of x- and y-coordinates), and orientation (<code>r</code>; in degrees) of location error ellipses. If <code>NULL</code> (the default), no location 
measurement error is simulated. If <code>errorEllipse</code> is specified, then each observed location is subject to bivariate normal errors as described 
in McClintock et al. (2015), where the components of the error ellipse for each location are randomly drawn from <code>runif(1,min(errorEllipse$M),max(errorEllipse$M))</code>, 
<code>runif(1,min(errorEllipse$m),max(errorEllipse$m))</code>, and <code>runif(1,min(errorEllipse$r),max(errorEllipse$r))</code>. If only a single value is provided for any of the 
error ellipse elements, then the corresponding component is fixed to this value for each location. Only the 'step' and 'angle' data streams are subject to location measurement error;
any other data streams are observed without error.  Ignored unless a valid distribution for the 'step' data stream is specified.</p>
</td></tr>
<tr><td><code id="simData_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default: 1 (no parallel processing).</p>
</td></tr>
<tr><td><code id="simData_+3A_hierstates">hierStates</code></td>
<td>
<p>A hierarchical model structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the states ('state').  See details.</p>
</td></tr>
<tr><td><code id="simData_+3A_hierdist">hierDist</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the data streams ('dist'). Currently
supported distributions are 'bern', 'beta', 'exp', 'gamma', 'lnorm', 'norm', 'mvnorm2' (bivariate normal distribution), 'mvnorm3' (trivariate normal distribution),
'pois', 'rw_norm' (normal random walk), 'rw_mvnorm2' (bivariate normal random walk), 'rw_mvnorm3' (trivariate normal random walk), 'vm', 'vmConsensus', 'weibull', and 'wrpcauchy'. See details.</p>
</td></tr>
<tr><td><code id="simData_+3A_hierbeta">hierBeta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the transition probabilities at each level of the hierarchy ('beta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_hierdelta">hierDelta</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the matrix of initial values for the regression coefficients of the initial distribution at each level of the hierarchy ('delta'). See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_hierformula">hierFormula</code></td>
<td>
<p>A hierarchical formula structure for the transition probability covariates for each level of the hierarchy ('formula'). Default: <code>NULL</code> (only hierarchical-level effects, with no covariate effects).
Any formula terms that are not state- or parameter-specific are included on all of the transition probabilities within a given level of the hierarchy. See details.</p>
</td></tr>
<tr><td><code id="simData_+3A_hierformuladelta">hierFormulaDelta</code></td>
<td>
<p>A hierarchical formula structure for the initial distribution covariates for each level of the hierarchy ('formulaDelta'). Default: <code>NULL</code> (no covariate effects and <code>fixPar$delta</code> is specified on the working scale).</p>
</td></tr>
<tr><td><code id="simData_+3A_nbhiercovs">nbHierCovs</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> for the number of covariates ('nbCovs') to simulate for each level of the hierarchy (0 by default). Does not need to be specified if
<code>covs</code> is specified. Simulated covariates are provided generic names (e.g., 'cov1.1' and 'cov1.2' for <code>nbHierCovs$level1$nbCovs=2</code>) and can be included in <code>hierFormula</code> and/or <code>DM</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_obsperlevel">obsPerLevel</code></td>
<td>
<p>A hierarchical data structure <code><a href="data.tree.html#topic+Node">Node</a></code> indicating the number of observations for each level of the hierarchy ('obs'). For each level, the 'obs' field can either be the number of observations per animal (if single value) or the bounds of the number of observations per animal (if vector of two values). In the latter case, 
the numbers of obervations generated per level for each animal are uniformously picked from this interval. Alternatively, <code>obsPerLevel</code> can be specified as
a list of length <code>nbAnimals</code> with each element providing the hierarchical data structure for the number of observations for each level of the hierarchy for each animal, where the 'obs' field can either be the number of observations (if single value) or the bounds of the number of observations (if vector of two values) for each individual.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>simHierData</code> is very similar to <code><a href="#topic+simData">simData</a></code> except that instead of simply specifying the number of states (<code>nbStates</code>), distributions (<code>dist</code>), observations (<code>obsPerAnimal</code>), covariates (<code>nbCovs</code>), and a single t.p.m. formula (<code>formula</code>), the <code>hierStates</code> argument specifies the hierarchical nature of the states,
the <code>hierDist</code> argument specifies the hierarchical nature of the data streams, the <code>obsPerLevel</code> argument specifies the number of observations for each level of the hierarchy, the <code>nbHierCovs</code> argument specifies the number of covariates for each level of the hierarchy, and the <code>hierFormula</code> argument specifies a t.p.m. formula for each level of the hierarchy.
All of the hierarhcial arguments in <code>simHierData</code> are specified as <code><a href="data.tree.html#topic+Node">Node</a></code> objects from the <code><a href="data.tree.html#topic+data.tree">data.tree</a></code> package.
</p>
</li>
<li><p> x- and y-coordinate location data are generated only if valid 'step' and 'angle' data streams are specified.  Vaild distributions for 'step' include 
'gamma', 'weibull', 'exp', and 'lnorm'.  Valid distributions for 'angle' include 'vm' and 'wrpcauchy'.  If only a valid 'step' data stream is specified, then only x-coordinates
are generated.
</p>
</li>
<li><p> If <code>DM</code> is specified for a particular data stream, then the initial values are specified on 
the working (i.e., beta) scale of the parameters. The working scale of each parameter is determined by the link function used.
The function <code><a href="#topic+getParDM">getParDM</a></code> is intended to help with obtaining initial values on the working scale when specifying a design matrix and other 
parameter constraints. 
</p>
</li>
<li><p> Simulated data that are temporally regular (i.e., <code>lambda=NULL</code>) and without location measurement error (i.e., <code>errorEllipse=NULL</code>) are returned
as a <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> (or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>) object suitable for analysis using <code><a href="#topic+fitHMM">fitHMM</a></code>.
</p>
</li>
<li><p> Simulated location data that are temporally-irregular (i.e., <code>lambda&gt;0</code>) and/or with location measurement error (i.e., <code>errorEllipse!=NULL</code>) are returned
as a data frame suitable for analysis using <code><a href="#topic+crawlWrap">crawlWrap</a></code>.
</p>
</li>
<li><p> The matrix <code>beta</code> of regression coefficients for the transition probabilities has
one row for the intercept, plus one row for each covariate, and one column for
each non-diagonal element of the transition probability matrix. For example, in a 3-state
HMM with 2 <code>formula</code> covariates, the matrix <code>beta</code> has three rows (intercept + two covariates)
and six columns (six non-diagonal elements in the 3x3 transition probability matrix -
filled in row-wise).
In a covariate-free model (default), <code>beta</code> has one row, for the intercept.
</p>
</li>
<li><p> State-specific formulas can be specified in <code>DM</code> using special formula functions. These special functions can take
the names <code>paste0("state",1:nbStates)</code> (where the integer indicates the state-specific formula).  For example, 
<code>DM=list(step=list(mean=~cov1+state1(cov2),sd=~cov2+state2(cov1)))</code> includes <code>cov1</code> on the mean parameter for all states, <code>cov2</code>
on the mean parameter for state 1, <code>cov2</code> on the sd parameter for all states, and <code>cov1</code> on the sd parameter for state 2.
</p>
</li>
<li><p> State- and parameter-specific formulas can be specified for transition probabilities in <code>formula</code> using special formula functions.
These special functions can take the names <code>paste0("state",1:nbStates)</code> (where the integer indicates the current state from which transitions occur),
<code>paste0("toState",1:nbStates)</code> (where the integer indicates the state to which transitions occur),
or <code>paste0("betaCol",nbStates*(nbStates-1))</code> (where the integer indicates the column of the <code>beta</code> matrix).  For example with <code>nbStates=3</code>,
<code>formula=~cov1+betaCol1(cov2)+state3(cov3)+toState1(cov4)</code> includes <code>cov1</code> on all transition probability parameters, <code>cov2</code> on the <code>beta</code> column corresponding
to the transition from state 1-&gt;2, <code>cov3</code> on transition probabilities from state 3 (i.e., <code>beta</code> columns corresponding to state transitions 3-&gt;1 and 3-&gt;2),
and <code>cov4</code> on transition probabilities to state 1 (i.e., <code>beta</code> columns corresponding to state transitions 2-&gt;1 and 3-&gt;1).
</p>
</li>
<li><p> Cyclical relationships (e.g., hourly, monthly) may be simulated using the <code>consinor(x,period)</code> special formula function for covariate <code>x</code>
and sine curve period of time length <code>period</code>. For example, if 
the data are hourly, a 24-hour cycle can be simulated using <code>~cosinor(cov1,24)</code>, where the covariate <code>cov1</code> is a repeating series
of integers <code>0,1,...,23,0,1,...,23,0,1,...</code> (note that <code>simData</code> will not do this for you, the appropriate covariate must be specified using the <code>covs</code> argument; see example below). 
The <code>cosinor(x,period)</code> function converts <code>x</code> to 2 covariates
<code>cosinorCos(x)=cos(2*pi*x/period)</code> and <code>consinorSin(x)=sin(2*pi*x/period</code> for inclusion in the model (i.e., 2 additional parameters per state). The amplitude of the sine wave
is thus <code>sqrt(B_cos^2 + B_sin^2)</code>, where <code>B_cos</code> and <code>B_sin</code> are the working parameters correponding to <code>cosinorCos(x)</code> and <code>cosinorSin(x)</code>, respectively (e.g., see Cornelissen 2014).
</p>
<p>When the circular-circular regression model is used, the special function <code>angleFormula(cov,strength,by)</code> can be used in <code>DM</code> for the mean of angular distributions (i.e. 'vm', 'vmConsensus', and 'wrpcauchy'),
where <code>cov</code> is an angle covariate (e.g. wind direction), <code>strength</code> is a positive real covariate (e.g. wind speed), and <code>by</code> is an optional factor variable for individual- or group-level effects (e.g. ID, sex). This allows angle covariates to be weighted based on their strength or importance at time step t as in
Rivest et al. (2016).
</p>
</li></ul>


<ul>
<li><p> If the length of covariate values passed (either through 'covs', or 'model') is not the same
as the number of observations suggested by 'nbAnimals' and 'obsPerAnimal' (or 'obsPerLevel' for <code>simHierData</code>), then the series of
covariates is either shortened (removing last values - if too long) or extended (starting
over from the first values - if too short).
</p>
</li>
<li><p> For <code>simData</code>, when covariates are not included in <code>formulaDelta</code> (i.e. <code>formulaDelta=NULL</code>), then <code>delta</code> is specified as a vector of length <code>nbStates</code> that 
sums to 1.  When covariates are included in <code>formulaDelta</code>, then <code>delta</code> must be specified
as a k x (<code>nbStates</code>-1) matrix of working parameters, where k is the number of regression coefficients and the columns correspond to states 2:<code>nbStates</code>. For example, in a 3-state
HMM with <code>formulaDelta=~cov1+cov2</code>, the matrix <code>delta</code> has three rows (intercept + two covariates)
and 2 columns (corresponding to states 2 and 3). The initial distribution working parameters are transformed to the real scale as <code>exp(covsDelta*Delta)/rowSums(exp(covsDelta*Delta))</code>, where <code>covsDelta</code> is the N x k design matrix, <code>Delta=cbind(rep(0,k),delta)</code> is a k x <code>nbStates</code> matrix of working parameters,
and <code>N=length(unique(data$ID))</code>.
</p>
</li>
<li><p> For <code>simHierData</code>, <code>delta</code> must be specified
as a k x (<code>nbStates</code>-1) matrix of working parameters, where k is the number of regression coefficients and the columns correspond to states 2:<code>nbStates</code>. 
</p>
</li></ul>



<h3>Value</h3>

<p>If the simulated data are temporally regular (i.e., <code>lambda=NULL</code>) with no measurement error (i.e., <code>errorEllipse=NULL</code>), an object <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> (or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code>), 
i.e., a dataframe of:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>The ID(s) of the observed animal(s)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Data streams as specified by <code>dist</code> (or <code>hierDist</code>)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Either easting or longitude (if data streams include valid non-negative distribution for 'step')</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Either norting or latitude (if data streams include valid non-negative distribution for 'step')</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Covariates (if any)</p>
</td></tr>
</table>
<p>If simulated location data are temporally irregular (i.e., <code>lambda&gt;0</code>) and/or include measurement error (i.e., <code>errorEllipse!=NULL</code>), a dataframe of:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Numeric time of each observed (and missing) observation</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>The ID(s) of the observed animal(s)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Either easting or longitude observed location</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Either norting or latitude observed location</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Data streams that are not derived from location (if applicable)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Covariates at temporally-regular true (<code>mux</code>,<code>muy</code>) locations (if any)</p>
</td></tr>
<tr><td><code>mux</code></td>
<td>
<p>Either easting or longitude true location</p>
</td></tr>
<tr><td><code>muy</code></td>
<td>
<p>Either norting or latitude true location</p>
</td></tr>
<tr><td><code>error_semimajor_axis</code></td>
<td>
<p>error ellipse semi-major axis (if applicable)</p>
</td></tr>
<tr><td><code>error_semiminor_axis</code></td>
<td>
<p>error ellipse semi-minor axis (if applicable)</p>
</td></tr>
<tr><td><code>error_ellipse_orientation</code></td>
<td>
<p>error ellipse orientation (if applicable)</p>
</td></tr>
<tr><td><code>ln.sd.x</code></td>
<td>
<p>log of the square root of the x-variance of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
<tr><td><code>ln.sd.y</code></td>
<td>
<p>log of the square root of the y-variance of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
<tr><td><code>error.corr</code></td>
<td>
<p>correlation term of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cornelissen, G. 2014. Cosinor-based rhythmometry. Theoretical Biology and Medical Modelling 11:16.
</p>
<p>McClintock BT, London JM, Cameron MF, Boveng PL. 2015. Modelling animal movement using the Argos satellite telemetry location error ellipse. 
Methods in Ecology and Evolution 6(3):266-277.
</p>
<p>Rivest, LP, Duchesne, T, Nicosia, A, Fortin, D, 2016. A general angular regression model for the analysis of data on animal movement in ecology. 
Journal of the Royal Statistical Society: Series C (Applied Statistics), 65(3):445-463.
</p>
<p>Leos-Barajas, V., Gangloff, E.J., Adam, T., Langrock, R., van Beest, F.M., Nabe-Nielsen, J. and Morales, J.M. 2017. 
Multi-scale modeling of animal movement and general behavior data using hidden Markov models with hierarchical structures. 
Journal of Agricultural, Biological and Environmental Statistics, 22 (3), 232-248.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepData">prepData</a></code>, <code><a href="#topic+simObsData">simObsData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Pass a fitted model to simulate from
# (m is a momentuHMM object - as returned by fitHMM - automatically loaded with the package)
# We keep the default nbAnimals=1.
m &lt;- example$m
obsPerAnimal=c(50,100)
data &lt;- simData(model=m,obsPerAnimal=obsPerAnimal)

## Not run: 
# 2. Pass the parameters of the model to simulate from
stepPar &lt;- c(1,10,1,5,0.2,0.3) # mean_1, mean_2, sd_1, sd_2, zeromass_1, zeromass_2
anglePar &lt;- c(pi,0,0.5,2) # mean_1, mean_2, concentration_1, concentration_2
omegaPar &lt;- c(1,10,10,1) # shape1_1, shape1_2, shape2_1, shape2_2
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
omegaDist &lt;- "beta"
data &lt;- simData(nbAnimals=4,nbStates=2,dist=list(step=stepDist,angle=angleDist,omega=omegaDist),
                Par=list(step=stepPar,angle=anglePar,omega=omegaPar),nbCovs=2,
                zeroInflation=list(step=TRUE),
                obsPerAnimal=obsPerAnimal)

# 3. Include covariates
# (note that it is useless to specify "nbCovs", which are overruled
# by the number of columns of "cov")
cov &lt;- data.frame(temp=log(rnorm(500,20,5)))
stepPar &lt;- c(log(10),0.1,log(100),-0.1,log(5),log(25)) # working scale parameters for step DM
anglePar &lt;- c(pi,0,0.5,2) # mean_1, mean_2, concentration_1, concentration_2
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
data &lt;- simData(nbAnimals=2,nbStates=2,dist=list(step=stepDist,angle=angleDist),
                Par=list(step=stepPar,angle=anglePar),
                DM=list(step=list(mean=~temp,sd=~1)),
                covs=cov,
                obsPerAnimal=obsPerAnimal)
                
# 4. Include example 'forest' spatial covariate raster layer
# nbAnimals and obsPerAnimal kept small to reduce example run time
spatialCov&lt;-list(forest=forest)
data &lt;- simData(nbAnimals=1,nbStates=2,dist=list(step=stepDist,angle=angleDist),
                Par=list(step=c(100,1000,50,100),angle=c(0,0,0.1,5)),
                beta=matrix(c(5,-10,-25,50),nrow=2,ncol=2,byrow=TRUE),
                formula=~forest,spatialCovs=spatialCov,
                obsPerAnimal=250,states=TRUE,
                retrySims=100)
                
# 5. Specify design matrix for 'omega' data stream
# natural scale parameters for step and angle
stepPar &lt;- c(1,10,1,5) # shape_1, shape_2, scale_1, scale_2
anglePar &lt;- c(pi,0,0.5,0.7) # mean_1, mean_2, concentration_1, concentration_2

# working scale parameters for omega DM
omegaPar &lt;- c(log(1),0.1,log(10),-0.1,log(10),-0.1,log(1),0.1)

stepDist &lt;- "weibull"
angleDist &lt;- "wrpcauchy"
omegaDist &lt;- "beta"

data &lt;- simData(nbStates=2,dist=list(step=stepDist,angle=angleDist,omega=omegaDist),
                Par=list(step=stepPar,angle=anglePar,omega=omegaPar),nbCovs=2,
                DM=list(omega=list(shape1=~cov1,shape2=~cov2)),
                obsPerAnimal=obsPerAnimal,states=TRUE)
                
# 6. Include temporal irregularity and location measurement error
lambda &lt;- 2 # expect 2 observations per time step
errorEllipse &lt;- list(M=50,m=25,r=180)
obsData &lt;- simData(model=m,obsPerAnimal=obsPerAnimal,
                   lambda=lambda, errorEllipse=errorEllipse)
                   
# 7. Cosinor and state-dependent formulas
nbStates&lt;-2
dist&lt;-list(step="gamma")
Par&lt;-list(step=c(100,1000,50,100))

# include 24-hour cycle on all transition probabilities
# include 12-hour cycle on transitions from state 2
formula=~cosinor(hour24,24)+state2(cosinor(hour12,12))

# specify appropriate covariates
covs&lt;-data.frame(hour24=0:23,hour12=0:11)

beta&lt;-matrix(c(-1.5,1,1,NA,NA,-1.5,-1,-1,1,1),5,2)
# row names for beta not required but can be helpful
rownames(beta)&lt;-c("(Intercept)",
                  "cosinorCos(hour24, 24)",
                  "cosinorSin(hour24, 24)",
                  "cosinorCos(hour12, 12)",
                  "cosinorSin(hour12, 12)")
data.cos&lt;-simData(nbStates=nbStates,dist=dist,Par=Par,
                  beta=beta,formula=formula,covs=covs)     
                  
# 8. Piecewise constant B-spline on step length mean and angle concentration
nObs &lt;- 1000 # length of simulated track
cov &lt;- data.frame(time=1:nObs) # time covariate for splines
dist &lt;- list(step="gamma",angle="vm")
stepDM &lt;- list(mean=~splines2::bSpline(time,df=2,degree=0),sd=~1)
angleDM &lt;- list(mean=~1,concentration=~splines2::bSpline(time,df=2,degree=0))
DM &lt;- list(step=stepDM,angle=angleDM)
Par &lt;- list(step=c(log(1000),1,-1,log(100)),angle=c(0,log(10),2,-5))

data.spline&lt;-simData(obsPerAnimal=nObs,nbStates=1,dist=dist,Par=Par,DM=DM,covs=cov)        

# 9. Initial state (delta) based on covariate
nObs &lt;- 100
dist &lt;- list(step="gamma",angle="vm")
Par &lt;- list(step=c(100,1000,50,100),angle=c(0,0,0.01,0.75))

# create sex covariate
cov &lt;- data.frame(sex=factor(rep(c("F","M"),each=nObs))) # sex covariate
formulaDelta &lt;- ~ sex + 0

# Female begins in state 1, male begins in state 2
delta &lt;- matrix(c(-100,100),2,1,dimnames=list(c("sexF","sexM"),"state 2")) 

data.delta&lt;-simData(nbAnimals=2,obsPerAnimal=nObs,nbStates=2,dist=dist,Par=Par,
                    delta=delta,formulaDelta=formulaDelta,covs=cov,
                    beta=matrix(-1.5,1,2),states=TRUE)        

## End(Not run)                
</code></pre>

<hr>
<h2 id='simObsData'>Observation error simulation tool</h2><span id='topic+simObsData'></span><span id='topic+simObsData.momentuHMMData'></span><span id='topic+simObsData.momentuHierHMMData'></span>

<h3>Description</h3>

<p>Simulates observed location data subject to temporal irregularity and/or location measurement error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simObsData(data, lambda, errorEllipse, ...)

## S3 method for class 'momentuHMMData'
simObsData(data, lambda, errorEllipse, ...)

## S3 method for class 'momentuHierHMMData'
simObsData(data, lambda, errorEllipse, coordLevel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simObsData_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object with necessary fields 'x' (easting/longitudinal coordinates) and 'y' (northing/latitudinal coordinates)</p>
</td></tr>
<tr><td><code id="simObsData_+3A_lambda">lambda</code></td>
<td>
<p>Observation rate for location data. If <code>NULL</code>, location data are kept at temporally-regular intervals. Otherwise 
<code>lambda</code> is the rate parameter of the exponential distribution for the waiting times between successive location observations, i.e., 
<code>1/lambda</code> is the expected time between successive location observations. Only the 'step' and 'angle' data streams (or multivariate normal data streams identified by <code>mvnCoords</code>) are subject to temporal irregularity;
any other data streams are kept at temporally-regular intervals.  Ignored unless a valid distribution for the 'step' (or 'mvnCoord') data stream has been specified.</p>
</td></tr>
<tr><td><code id="simObsData_+3A_errorellipse">errorEllipse</code></td>
<td>
<p>List providing the bounds for the semi-major axis (<code>M</code>; on scale of x- and y-coordinates), semi-minor axis (<code>m</code>; 
on scale of x- and y-coordinates), and orientation (<code>r</code>; in degrees) of location error ellipses. If <code>NULL</code>, no location 
measurement error is simulated. If <code>errorEllipse</code> is specified, then each observed location is subject to bivariate normal errors as described 
in McClintock et al. (2015), where the components of the error ellipse for each location are randomly drawn from <code>runif(1,min(errorEllipse$M),max(errorEllipse$M))</code>, 
<code>runif(1,min(errorEllipse$m),max(errorEllipse$m))</code>, and <code>runif(1,min(errorEllipse$r),max(errorEllipse$r))</code>. If only a single value is provided for any of the 
error ellipse elements, then the corresponding component is fixed to this value for each location. Only the 'step' and 'angle' data streams are subject to location measurement error;
any other data streams are observed without error.  Ignored unless a valid distribution for the 'step' data stream is specified.</p>
</td></tr>
<tr><td><code id="simObsData_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="simObsData_+3A_coordlevel">coordLevel</code></td>
<td>
<p>Level of the hierarchy in which the location data are obtained</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulated location data that are temporally-irregular (i.e., <code>lambda&gt;0</code>) and/or with location measurement error (i.e., <code>errorEllipse!=NULL</code>) are returned
as a data frame suitable for analysis using <code><a href="#topic+crawlWrap">crawlWrap</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe of:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Numeric time of each observed (and missing) observation</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>The ID(s) of the observed animal(s)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Either easting or longitude observed location</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Either norting or latitude observed location</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Data streams that are not derived from location (if applicable)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Covariates at temporally-regular true (<code>mux</code>,<code>muy</code>) locations (if any)</p>
</td></tr>
<tr><td><code>mux</code></td>
<td>
<p>Either easting or longitude true location</p>
</td></tr>
<tr><td><code>muy</code></td>
<td>
<p>Either norting or latitude true location</p>
</td></tr>
<tr><td><code>error_semimajor_axis</code></td>
<td>
<p>error ellipse semi-major axis (if applicable)</p>
</td></tr>
<tr><td><code>error_semiminor_axis</code></td>
<td>
<p>error ellipse semi-minor axis (if applicable)</p>
</td></tr>
<tr><td><code>error_ellipse_orientation</code></td>
<td>
<p>error ellipse orientation (if applicable)</p>
</td></tr>
<tr><td><code>ln.sd.x</code></td>
<td>
<p>log of the square root of the x-variance of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
<tr><td><code>ln.sd.y</code></td>
<td>
<p>log of the square root of the y-variance of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
<tr><td><code>error.corr</code></td>
<td>
<p>correlation term of bivariate normal error (if applicable; required for error ellipse models in <code><a href="#topic+crawlWrap">crawlWrap</a></code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>McClintock BT, London JM, Cameron MF, Boveng PL. 2015. Modelling animal movement using the Argos satellite telemetry location error ellipse. 
Methods in Ecology and Evolution 6(3):266-277.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crawlWrap">crawlWrap</a></code>, <code><a href="#topic+prepData">prepData</a></code>, <code><a href="#topic+simData">simData</a></code>
</p>
<p><code><a href="#topic+simHierData">simHierData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># extract momentuHMMData example
data &lt;- example$m$data
lambda &lt;- 2 # expect 2 observations per time step
errorEllipse &lt;- list(M=c(0,50),m=c(0,50),r=c(0,180))
obsData1 &lt;- simObsData(data,lambda=lambda,errorEllipse=errorEllipse)

errorEllipse &lt;- list(M=50,m=50,r=180)
obsData2 &lt;- simObsData(data,lambda=lambda,errorEllipse=errorEllipse)

</code></pre>

<hr>
<h2 id='stateProbs'>State probabilities</h2><span id='topic+stateProbs'></span>

<h3>Description</h3>

<p>For a given model, computes the probability of the process being in the different states
at each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateProbs(m, hierarchical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stateProbs_+3A_m">m</code></td>
<td>
<p>A <code>momentuHMM</code> or <code>momentuHierHMM</code> object.</p>
</td></tr>
<tr><td><code id="stateProbs_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Logical indicating whether or not to return a list of state probabilities for each level of a hierarchical HMM. Ignored unless <code>m</code> is a <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of state probabilities, with element [i,j] the probability
of being in state j in observation i.
</p>


<h3>References</h3>

<p>Zucchini, W. and MacDonald, I.L. 2009.
Hidden Markov Models for Time Series: An Introduction Using R.
Chapman &amp; Hall (London).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

sp &lt;- stateProbs(m)

</code></pre>

<hr>
<h2 id='stationary'>Stationary state probabilities</h2><span id='topic+stationary'></span>

<h3>Description</h3>

<p>Calculates the stationary probabilities of each state based on
covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary(model, covs, covIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stationary_+3A_model">model</code></td>
<td>
<p><code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+miSum">miSum</a></code> object</p>
</td></tr>
<tr><td><code id="stationary_+3A_covs">covs</code></td>
<td>
<p>Either a data frame or a design matrix of covariates. If <code>covs</code> is not provided, then the stationary probabilties are calculated based on the covariate data for each time step.</p>
</td></tr>
<tr><td><code id="stationary_+3A_covindex">covIndex</code></td>
<td>
<p>Integer vector indicating specific rows of the data to be used in the calculations. This can be useful for reducing unnecessarily long computation times, e.g., when <code>formula</code> includes factor covariates (such as <code>ID</code>) but no temporal covariates. Ignored unless <code>covs</code> is missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>model$conditions$mixtures</code> where each element is a matrix of stationary state probabilities for each mixture. For each matrix, each row corresponds to
a row of covs, and each column corresponds to a state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

# data frame of covariates
stationary(m, covs = data.frame(cov1 = 0, cov2 = 0))

# design matrix (each column corresponds to row of m$mle$beta)
stationary(m, covs = matrix(c(1,0,cos(0)),1,3))

# get stationary distribution for first 3 observations
stationary(m, covIndex = c(1,2,3))

</code></pre>

<hr>
<h2 id='summary.momentuHMMData'>Summary <code>momentuHMMData</code></h2><span id='topic+summary.momentuHMMData'></span><span id='topic+summary.momentuHierHMMData'></span>

<h3>Description</h3>

<p>Summary <code>momentuHMMData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'momentuHMMData'
summary(object, dataNames = c("step", "angle"), animals = NULL, ...)

## S3 method for class 'momentuHierHMMData'
summary(object, dataNames = c("step", "angle", "level"), animals = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.momentuHMMData_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+momentuHMMData">momentuHMMData</a></code> or <code><a href="#topic+momentuHierHMMData">momentuHierHMMData</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.momentuHMMData_+3A_datanames">dataNames</code></td>
<td>
<p>Names of the variables to summarize. Default is <code>dataNames=c("step","angle")</code>.</p>
</td></tr>
<tr><td><code id="summary.momentuHMMData_+3A_animals">animals</code></td>
<td>
<p>Vector of indices or IDs of animals for which data will be summarized.
Default: <code>NULL</code> ; data for all animals are summarized.</p>
</td></tr>
<tr><td><code id="summary.momentuHMMData_+3A_...">...</code></td>
<td>
<p>Currently unused. For compatibility with generic method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># data is a momentuHMMData object (as returned by prepData), automatically loaded with the package
data &lt;- example$m$data

summary(data,dataNames=c("step","angle","cov1","cov2"))

</code></pre>

<hr>
<h2 id='timeInStates'>Calculate proportion of time steps assigned to each state (i.e. &ldquo;activity budgets&rdquo;)</h2><span id='topic+timeInStates'></span><span id='topic+timeInStates.momentuHMM'></span><span id='topic+timeInStates.HMMfits'></span><span id='topic+timeInStates.miHMM'></span>

<h3>Description</h3>

<p>Calculate proportion of time steps assigned to each state (i.e. &ldquo;activity budgets&rdquo;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeInStates(m, by = NULL, alpha = 0.95, ncores = 1)

## S3 method for class 'momentuHMM'
timeInStates(m, by = NULL, alpha = 0.95, ncores = 1)

## S3 method for class 'HMMfits'
timeInStates(m, by = NULL, alpha = 0.95, ncores = 1)

## S3 method for class 'miHMM'
timeInStates(m, by = NULL, alpha = 0.95, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeInStates_+3A_m">m</code></td>
<td>
<p>A <code><a href="#topic+momentuHMM">momentuHMM</a></code>, <code><a href="#topic+miHMM">miHMM</a></code>, or <code><a href="#topic+HMMfits">HMMfits</a></code> object.</p>
</td></tr>
<tr><td><code id="timeInStates_+3A_by">by</code></td>
<td>
<p>A character vector indicating any groupings by which to calculate the proportions, such as individual (&ldquo;ID&rdquo;) or group-level (e.g. sex or age class) covariates. Default is <code>NULL</code> (no groupings are used).</p>
</td></tr>
<tr><td><code id="timeInStates_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for calculating confidence intervals of pooled estimates. Default: 0.95. Ignored unless <code>m</code> is a <code><a href="#topic+miHMM">miHMM</a></code> or <code><a href="#topic+HMMfits">HMMfits</a></code> object.</p>
</td></tr>
<tr><td><code id="timeInStates_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default: 1 (no parallel processing). Ignored unless <code>m</code> is a <code><a href="#topic+miHMM">miHMM</a></code> or <code><a href="#topic+HMMfits">HMMfits</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>m</code> is a <code><a href="#topic+momentuHMM">momentuHMM</a></code> object, a data frame containing the estimated activity budgets for each state (grouped according to <code>by</code>).  If <code>m</code> is a <code><a href="#topic+miHMM">miHMM</a></code> or <code><a href="#topic+HMMfits">HMMfits</a></code> object, a list containing the activity budget
estimates, standard errors, lower bounds, and upper bounds across all imputations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m
timeInStates(m)
timeInStates(m, by = "ID")

</code></pre>

<hr>
<h2 id='trMatrix_rcpp'>Transition probability matrix</h2><span id='topic+trMatrix_rcpp'></span>

<h3>Description</h3>

<p>Computation of the transition probability matrix, as a function of the covariates and the regression
parameters. Written in C++. Used in <code><a href="#topic+viterbi">viterbi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trMatrix_rcpp(nbStates, beta, covs, betaRef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trMatrix_rcpp_+3A_nbstates">nbStates</code></td>
<td>
<p>Number of states</p>
</td></tr>
<tr><td><code id="trMatrix_rcpp_+3A_beta">beta</code></td>
<td>
<p>Matrix of regression parameters</p>
</td></tr>
<tr><td><code id="trMatrix_rcpp_+3A_covs">covs</code></td>
<td>
<p>Matrix of covariate values</p>
</td></tr>
<tr><td><code id="trMatrix_rcpp_+3A_betaref">betaRef</code></td>
<td>
<p>Indices of reference elements for t.p.m. multinomial logit link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three dimensional array <code>trMat</code>, such that <code>trMat[,,t]</code> is the transition matrix at
time t.
</p>

<hr>
<h2 id='turnAngle'>Turning angle</h2><span id='topic+turnAngle'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+prepData">prepData</a></code> and <code><a href="#topic+simData">simData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnAngle(x, y, z, type = "UTM", angleCov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turnAngle_+3A_x">x</code></td>
<td>
<p>First point</p>
</td></tr>
<tr><td><code id="turnAngle_+3A_y">y</code></td>
<td>
<p>Second point</p>
</td></tr>
<tr><td><code id="turnAngle_+3A_z">z</code></td>
<td>
<p>Third point</p>
</td></tr>
<tr><td><code id="turnAngle_+3A_type">type</code></td>
<td>
<p><code>'UTM'</code> if easting/northing provided (the default), <code>'LL'</code> if longitude/latitude. If <code>type='LL'</code> then the <code><a href="geosphere.html#topic+geosphere">geosphere</a></code> package must be installed.</p>
</td></tr>
<tr><td><code id="turnAngle_+3A_anglecov">angleCov</code></td>
<td>
<p>logical indicating to not return NA when x=y or y=z. Default: FALSE (i.e. NA is returned if x=y or y=z).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The angle between vectors (x,y) and (y,z).  
</p>
<p>If <code>type='LL'</code> then turning angle is calculated based on initial bearings using <code><a href="geosphere.html#topic+bearing">bearing</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- c(0,0)
y &lt;- c(4,6)
z &lt;- c(10,7)
momentuHMM:::turnAngle(x,y,z)

## End(Not run)
</code></pre>

<hr>
<h2 id='viterbi'>Viterbi algorithm</h2><span id='topic+viterbi'></span>

<h3>Description</h3>

<p>For a given model, reconstructs the most probable states sequence,
using the Viterbi algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi(m, hierarchical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi_+3A_m">m</code></td>
<td>
<p>An object <code><a href="#topic+momentuHMM">momentuHMM</a></code> or <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code></p>
</td></tr>
<tr><td><code id="viterbi_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Logical indicating whether or not to return a list of Viterbi-decoded states for each level of a hierarchical HMM. Ignored unless <code>m</code> is a <code><a href="#topic+momentuHierHMM">momentuHierHMM</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sequence of most probable states. If <code>hierarchical</code> is <code>TRUE</code>, then a list of the most probable states for each level of the hierarchy is returned.
</p>


<h3>References</h3>

<p>Zucchini, W. and MacDonald, I.L. 2009.
Hidden Markov Models for Time Series: An Introduction Using R.
Chapman &amp; Hall (London).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># m is a momentuHMM object (as returned by fitHMM), automatically loaded with the package
m &lt;- example$m

# reconstruction of states sequence
states &lt;- viterbi(m)

</code></pre>

<hr>
<h2 id='w2n'>Scaling function: working to natural parameters</h2><span id='topic+w2n'></span>

<h3>Description</h3>

<p>Scales each parameter from the set of real numbers, back to its natural interval.
Used during the optimization of the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w2n(
  wpar,
  bounds,
  parSize,
  nbStates,
  nbCovs,
  estAngleMean,
  circularAngleMean,
  consensus,
  stationary,
  fullDM,
  DMind,
  nbObs,
  dist,
  Bndind,
  nc,
  meanind,
  covsDelta,
  workBounds,
  covsPi
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w2n_+3A_wpar">wpar</code></td>
<td>
<p>Vector of working parameters.</p>
</td></tr>
<tr><td><code id="w2n_+3A_bounds">bounds</code></td>
<td>
<p>Named list of 2-column matrices specifying bounds on the natural (i.e, real) scale of the probability 
distribution parameters for each data stream.</p>
</td></tr>
<tr><td><code id="w2n_+3A_parsize">parSize</code></td>
<td>
<p>Named list indicating the number of natural parameters of the data stream probability distributions</p>
</td></tr>
<tr><td><code id="w2n_+3A_nbstates">nbStates</code></td>
<td>
<p>The number of states of the HMM.</p>
</td></tr>
<tr><td><code id="w2n_+3A_nbcovs">nbCovs</code></td>
<td>
<p>The number of beta covariates.</p>
</td></tr>
<tr><td><code id="w2n_+3A_estanglemean">estAngleMean</code></td>
<td>
<p>Named list indicating whether or not to estimate the angle mean for data streams with angular 
distributions ('vm' and 'wrpcauchy').</p>
</td></tr>
<tr><td><code id="w2n_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>Named list indicating whether to use circular-linear or circular-circular
regression on the mean of circular distributions ('vm' and 'wrpcauchy') for turning angles. See <code><a href="#topic+fitHMM">fitHMM</a></code>.</p>
</td></tr>
<tr><td><code id="w2n_+3A_consensus">consensus</code></td>
<td>
<p>Named list indicating whether to use the circular-circular regression consensus model</p>
</td></tr>
<tr><td><code id="w2n_+3A_stationary">stationary</code></td>
<td>
<p><code>FALSE</code> if there are time-varying covariates in <code>formula</code> or any covariates in <code>formulaDelta</code>. If <code>TRUE</code>, the initial distribution is considered
equal to the stationary distribution. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="w2n_+3A_fulldm">fullDM</code></td>
<td>
<p>Named list containing the full (i.e. not shorthand) design matrix for each data stream.</p>
</td></tr>
<tr><td><code id="w2n_+3A_dmind">DMind</code></td>
<td>
<p>Named list indicating whether <code>fullDM</code> includes individual- and/or temporal-covariates for each data stream
specifies (-1,1) bounds for the concentration parameters instead of the default [0,1) bounds.</p>
</td></tr>
<tr><td><code id="w2n_+3A_nbobs">nbObs</code></td>
<td>
<p>Number of observations in the data.</p>
</td></tr>
<tr><td><code id="w2n_+3A_dist">dist</code></td>
<td>
<p>Named list indicating the probability distributions of the data streams.</p>
</td></tr>
<tr><td><code id="w2n_+3A_bndind">Bndind</code></td>
<td>
<p>Named list indicating whether <code>DM</code> is NULL with default parameter bounds for each data stream.</p>
</td></tr>
<tr><td><code id="w2n_+3A_nc">nc</code></td>
<td>
<p>indicator for zeros in fullDM</p>
</td></tr>
<tr><td><code id="w2n_+3A_meanind">meanind</code></td>
<td>
<p>index for circular-circular regression mean angles with at least one non-zero entry in fullDM</p>
</td></tr>
<tr><td><code id="w2n_+3A_covsdelta">covsDelta</code></td>
<td>
<p>data frame containing the delta model covariates</p>
</td></tr>
<tr><td><code id="w2n_+3A_workbounds">workBounds</code></td>
<td>
<p>named list of 2-column matrices specifying bounds on the working scale of the probability distribution, transition probability, and initial distribution parameters</p>
</td></tr>
<tr><td><code id="w2n_+3A_covspi">covsPi</code></td>
<td>
<p>data frame containing the pi model covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>...</code></td>
<td>
<p>Matrices containing the natural parameters for each data stream (e.g., 'step', 'angle', etc.)</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Matrix of regression coefficients of the transition probabilities</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Initial distribution</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m&lt;-example$m
nbStates &lt;- 2
nbCovs &lt;- 2
parSize &lt;- list(step=2,angle=2)
par &lt;- list(step=c(t(m$mle$step)),angle=c(t(m$mle$angle)))
bounds &lt;- m$conditions$bounds
beta &lt;- matrix(rnorm(6),ncol=2,nrow=3)
delta &lt;- c(0.6,0.4)

#working parameters
wpar &lt;- momentuHMM:::n2w(par,bounds,list(beta=beta),log(delta[-1]/delta[1]),nbStates,
m$conditions$estAngleMean,NULL,m$conditions$Bndind,
m$conditions$dist)

#natural parameter
p &lt;-   momentuHMM:::w2n(wpar,bounds,parSize,nbStates,nbCovs,m$conditions$estAngleMean,
m$conditions$circularAngleMean,lapply(m$conditions$dist,function(x) x=="vmConsensus"),
m$conditions$stationary,m$conditions$fullDM,
m$conditions$DMind,1,m$conditions$dist,m$conditions$Bndind,
matrix(1,nrow=length(unique(m$data$ID)),ncol=1),covsDelta=m$covsDelta,
workBounds=m$conditions$workBounds)

## End(Not run)


</code></pre>

<hr>
<h2 id='XBloop_rcpp'>Get XB</h2><span id='topic+XBloop_rcpp'></span>

<h3>Description</h3>

<p>Loop for computation of design matrix (X) times the working scale parameters (B). Written in C++. Used in <code><a href="#topic+w2n">w2n</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XBloop_rcpp(
  DM,
  Xvec,
  nbObs,
  nr,
  nc,
  circularAngleMean,
  consensus,
  rindex,
  cindex,
  nbStates,
  refCoeff = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XBloop_rcpp_+3A_dm">DM</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_xvec">Xvec</code></td>
<td>
<p>working parameters</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_nbobs">nbObs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_nr">nr</code></td>
<td>
<p>number of rows in design matrix</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_nc">nc</code></td>
<td>
<p>number of column in design matrix</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_circularanglemean">circularAngleMean</code></td>
<td>
<p>indicator for whether or not circular-circular regression model</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_consensus">consensus</code></td>
<td>
<p>indicator for whether or not circular-circular regression consensus model</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_rindex">rindex</code></td>
<td>
<p>row index for design matrix</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_cindex">cindex</code></td>
<td>
<p>column index for design matrix</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_nbstates">nbStates</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="XBloop_rcpp_+3A_refcoeff">refCoeff</code></td>
<td>
<p>intercept coefficient for circular-circular regression model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XB matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
