<!DOCTYPE html><html><head><title>Help for package Boom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Boom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.segments'>
<p>Function to add horizontal line segments to an existing plot</p></a></li>
<li><a href='#ar1.coefficient.prior'><p>Normal prior for an AR1 coefficient</p></a></li>
<li><a href='#beta.prior'><p>Beta prior for a binomial proportion</p></a></li>
<li><a href='#Boom-package'>
<p>Boom</p></a></li>
<li><a href='#boxplot.mcmc.matrix'>
<p>Plot the distribution of a matrix</p></a></li>
<li><a href='#boxplot.true'>
<p>Compare Boxplots to True Values</p></a></li>
<li><a href='#check'>
<p>Check MCMC Output</p></a></li>
<li><a href='#check.data'><p>Checking data formats</p></a></li>
<li><a href='#circles'><p>Draw Circles</p></a></li>
<li><a href='#compare.den'>
<p>Compare several density estimates.</p></a></li>
<li><a href='#compare.dynamic.distributions'>
<p>Compare Dynamic Distributions</p></a></li>
<li><a href='#compare.many.densities'>
<p>Compare several density estimates.</p></a></li>
<li><a href='#compare.many.ts'>
<p>Compares several density estimates.</p></a></li>
<li><a href='#compare.vector.distribution'><p>Boxplots to compare distributions of vectors</p></a></li>
<li><a href='#diff.double.model'><p>DiffDoubleModel</p></a></li>
<li><a href='#dirichlet-distribution'><p>The Dirichlet Distribution</p></a></li>
<li><a href='#dirichlet.prior'><p>Dirichlet prior for a multinomial distribution</p></a></li>
<li><a href='#discrete-uniform-prior'><p>Discrete prior distributions</p></a></li>
<li><a href='#dmvn'><p>Multivariate Normal Density</p></a></li>
<li><a href='#double.model'><p>Prior distributions for a real valued scalar</p></a></li>
<li><a href='#external.legend'>
<p>Add an external legend to an array of plots.</p></a></li>
<li><a href='#gamma.prior'><p>Gamma prior distribution</p></a></li>
<li><a href='#GenerateFactorData'><p>Generate a data frame of all factor data</p></a></li>
<li><a href='#histabunch'>
<p>A Bunch of Histograms</p></a></li>
<li><a href='#inverse-wishart'><p>Inverse Wishart Distribution</p></a></li>
<li><a href='#invgamma'><p>Inverse Gamma Distribution</p></a></li>
<li><a href='#is.even'>
<p>Check whether a number is even or odd.</p></a></li>
<li><a href='#lmgamma'><p>Log Multivariate Gamma Function</p></a></li>
<li><a href='#log.integrated.gaussian.likelihood'><p>Log Integrated Gaussian Likelihood</p></a></li>
<li><a href='#lognormal.prior'><p>Lognormal Prior Distribution</p></a></li>
<li><a href='#markov.prior'><p>Prior for a Markov chain</p></a></li>
<li><a href='#match_data_frame'><p>MatchDataFrame</p></a></li>
<li><a href='#mscan'><p>Scan a Matrix</p></a></li>
<li><a href='#mvn.diagonal.prior'><p>diagonal MVN prior</p></a></li>
<li><a href='#mvn.independent.sigma.prior'><p>Independence prior for the MVN</p></a></li>
<li><a href='#mvn.prior'><p>Multivariate normal prior</p></a></li>
<li><a href='#MvnGivenSigmaMatrixPrior'><p>Conditional Multivaraite Normal Prior Given Variance</p></a></li>
<li><a href='#normal.inverse.gamma.prior'><p>Normal inverse gamma prior</p></a></li>
<li><a href='#normal.inverse.wishart.prior'><p>Normal inverse Wishart prior</p></a></li>
<li><a href='#normal.prior'><p>Normal (scalar Gaussian) prior distribution</p></a></li>
<li><a href='#pairs.density'>
<p>Pairs plot for posterior distributions.</p></a></li>
<li><a href='#plot.density.contours'>
<p>Contour plot of a bivariate density.</p></a></li>
<li><a href='#plot.dynamic.distribution'>
<p>Plots the pointwise evolution of a distribution over an index set.</p></a></li>
<li><a href='#plot.macf'>
<p>Plots individual autocorrelation functions for many-valued time series</p></a></li>
<li><a href='#plot.many.ts'>
<p>Multiple time series plots</p></a></li>
<li><a href='#regression.coefficient.conjugate.prior'><p>Regression Coefficient Conjugate Prior</p></a></li>
<li><a href='#replist'>
<p>Repeated Lists of Objects</p></a></li>
<li><a href='#rmvn'><p>Multivariate Normal Simulation</p></a></li>
<li><a href='#rvectorfunction'><p>RVectorFunction</p></a></li>
<li><a href='#scaled.matrix.normal.prior'><p>Scaled Matrix-Normal Prior</p></a></li>
<li><a href='#sd.prior'><p>Prior for a standard deviation or variance</p></a></li>
<li><a href='#sufstat.Rd'><p>Sufficient Statistics</p></a></li>
<li><a href='#suggest.burn.log.likelihood'><p>Suggest MCMC Burn-in from Log Likelihood</p></a></li>
<li><a href='#thin'>
<p>Thin the rows of a matrix</p></a></li>
<li><a href='#thin.matrix'><p>Thin a Matrix</p></a></li>
<li><a href='#TimeSeriesBoxplot'>
<p>Time Series Boxplots</p></a></li>
<li><a href='#ToString'><p>Convert to Character String</p></a></li>
<li><a href='#traceproduct'><p>Trace of the Product of Two Matrices</p></a></li>
<li><a href='#uniform.prior'><p>Uniform prior distribution</p></a></li>
<li><a href='#wishart'><p>Wishart Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Object Oriented Modeling</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven L. Scott is the sole author and creator of the BOOM project.
   Some code in the BOOM libraries has been modified from other open source
   projects.  These include Cephes (obtained from Netlib, written by Stephen
   L. Moshier), NEWUOA (M.J.D Powell, obtained from Powell's web site), and a
   modified version of the R math libraries (R core development team).  Original
   copyright notices have been maintained in all source files.  In these cases,
   copyright claimed by Steven L. Scott is limited to modifications made to the
   original code.  Google claims copyright for code written while Steven
   L. Scott was employed at Google from 2008 - 2018, but BOOM is not an
   officially supported Google project.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steven L. Scott &lt;steve.the.bayesian@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A C++ library for Bayesian modeling, with an emphasis on Markov
   chain Monte Carlo.  Although boom contains a few R utilities (mainly plotting
   functions), its primary purpose is to install the BOOM C++ library on your
   system so that other packages can link against it.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU Make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-03 20:56:29 UTC; steve</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-03 22:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.segments'>
Function to add horizontal line segments to an existing plot
</h2><span id='topic+add.segments'></span><span id='topic+AddSegments'></span>

<h3>Description</h3>

<p>Adds horizontal line segments to an existing plot.  The segments are
centered at <code>x</code> with height <code>y</code>.  The <code>x</code> values are
assumed to be equally spaced, so that <code>diff(x)</code> is a constant
'<code>dx</code>'.  The line segments go from <code>x +/- half.width.factor
   *dx</code>, so if <code>half.width.factor=.5</code> there will be no gaps between
segments.  The default is to leave a small gap.
</p>
<p>This function was originally used to add reference lines to
side-by-side boxplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddSegments(x, y, half.width.factor = 0.45, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.segments_+3A_x">x</code></td>
<td>

<p>A numeric vector giving the midpoints of the line segments.
</p>
</td></tr>
<tr><td><code id="add.segments_+3A_y">y</code></td>
<td>

<p>A numeric vector of the same length as <code>x</code> giving the vertical
position of the line segments
</p>
</td></tr>
<tr><td><code id="add.segments_+3A_half.width.factor">half.width.factor</code></td>
<td>

<p>See 'description' above.
</p>
</td></tr>
<tr><td><code id="add.segments_+3A_...">...</code></td>
<td>

<p>graphical parameters controlling the type of lines used in the line segments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot.true">boxplot.true</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100)
y &lt;- rnorm(100, 1)
boxplot(list(x=x,y=y))
AddSegments(1:2, c(0, 1))  ## add segments to the boxplot

</code></pre>

<hr>
<h2 id='ar1.coefficient.prior'>Normal prior for an AR1 coefficient</h2><span id='topic+Ar1CoefficientPrior'></span>

<h3>Description</h3>

<p>A (possibly truncated) Gaussian prior on the autoregression
coefficient in an AR1 model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ar1CoefficientPrior(mu = 0, sigma = 1, force.stationary = TRUE,
    force.positive = FALSE, initial.value = mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1.coefficient.prior_+3A_mu">mu</code></td>
<td>
<p>The mean of the prior distribution.</p>
</td></tr>
<tr><td><code id="ar1.coefficient.prior_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the prior distribution.</p>
</td></tr>
<tr><td><code id="ar1.coefficient.prior_+3A_force.stationary">force.stationary</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the prior
support for the AR1 coefficient will be truncated to (-1, 1).</p>
</td></tr>
<tr><td><code id="ar1.coefficient.prior_+3A_force.positive">force.positive</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the prior for the
AR1 coefficient will be truncated so that zero support is given to
values less than zero.</p>
</td></tr>
<tr><td><code id="ar1.coefficient.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value of the parameter being modeled
in the MCMC algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>Ar1CoefficientPrior()</code> syntax is preferred, as it
more closely matches R's syntax for other constructors.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='beta.prior'>Beta prior for a binomial proportion</h2><span id='topic+BetaPrior'></span>

<h3>Description</h3>

<p>Specifies beta prior distribution for a binomial
probability parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BetaPrior(a = 1, b = 1, mean = NULL, sample.size = NULL,
            initial.value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.prior_+3A_a">a</code></td>
<td>
<p>A positive real number interpretable as a prior success count.</p>
</td></tr>
<tr><td><code id="beta.prior_+3A_b">b</code></td>
<td>
<p>A positive real number interpretable as a prior failure
count.</p>
</td></tr>
<tr><td><code id="beta.prior_+3A_mean">mean</code></td>
<td>
<p>A positive real number representing <code>a/(a+b)</code>.</p>
</td></tr>
<tr><td><code id="beta.prior_+3A_sample.size">sample.size</code></td>
<td>
<p>A positive real number representing <code>a+b</code>.</p>
</td></tr>
<tr><td><code id="beta.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>An initial value to be used for the variable
being modeled.  If <code>NULL</code> then the mean of the distribution
will be used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution should be specified either with <code>a</code> and
<code>b</code>, or with <code>mean</code> and <code>sample.size</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='Boom-package'>
Boom
</h2><span id='topic+Boom-package'></span><span id='topic+Boom'></span>

<h3>Description</h3>

<p> The Boom package provides access to the C++ BOOM library
for Bayesian computation.  </p>


<h3>Details</h3>



<h4>Installation note for Linux users</h4>

<p>If you are installing Boom using <code><a href="utils.html#topic+install.packages">install.packages</a></code> on a
Linux machine (and thus compiling yourself) you will almost certainly
want to set the <code>Ncpus</code> argument to a large number.  Windows and
Mac users can ignore this advice.
</p>

<p>The main purpose of the Boom package is not to be used directly, but
to provide the BOOM C++ library for other packages to link against.
The Boom package provides additional utility code for C++ authors to
use when writing R packages with C++ internals.  These are described
in <code>.../inst/include/r_interface/boom_r_tools.hpp</code> among the
package's include files.
</p>
<p>Boom provides a collection of R functions and objects to help users
format data in the manner expected by the underlying C++ code.
Standard distributions that are commonly used as Bayesian priors can
be specified using <code><a href="#topic+BetaPrior">BetaPrior</a></code>, <code><a href="#topic+GammaPrior">GammaPrior</a></code>,
etc.
</p>
<p>Boom provides a set of utilities helpful when writing unit tests for
Bayesian models.  See <code><a href="#topic+CheckMcmcMatrix">CheckMcmcMatrix</a></code> and
<code><a href="#topic+CheckMcmcVector">CheckMcmcVector</a></code> for MCMC output, and functions like
<code><a href="#topic+check.probability.distribution">check.probability.distribution</a></code> for checking function
inputs
</p>
<p>Boom provides a collection of useful plots (using base R graphics)
that have proven useful for summarizing MCMC output.  See
<code><a href="#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code>, <code><a href="#topic+PlotManyTs">PlotManyTs</a></code>,
<code><a href="#topic+BoxplotTrue">BoxplotTrue</a></code>, and other code in the index with
<code>Plot</code> in the title.
</p>


<h3>See Also</h3>

<p>Please see the following pacakges
</p>

<ul>
<li> <p><code>bsts</code>
</p>
</li>
<li> <p><code>CausalImpact</code>
</p>
</li></ul>


<hr>
<h2 id='boxplot.mcmc.matrix'>
Plot the distribution of a matrix
</h2><span id='topic+boxplot.mcmc.matrix'></span><span id='topic+BoxplotMcmcMatrix'></span>

<h3>Description</h3>

<p>Plot the marginal distribution of each element in the Monte Carlo
distribution of a matrix (e.g. a variance matrix or
transition probability matrix).  Rows and columns in the boxplots
correspond to rows and columns in the matrix being plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BoxplotMcmcMatrix(X, ylim = range(X), col.names,
                    row.names, truth, colors = NULL,
                    las = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.mcmc.matrix_+3A_x">X</code></td>
<td>

<p>3 dimensional array.  The first dimension is the Monte Carlo index
(e.g. MCMC iteration).  The second and third dimensions are the row
and column of the matrix being plotted.  E.g. <code>X[i,j,k]</code> is Monte
Carlo draw <code>i</code> of matrix element <code>j,k</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_ylim">ylim</code></td>
<td>

<p>2-vector giving the lower and upper limits of the vertical axis.
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_col.names">col.names</code></td>
<td>

<p>(optional) character vector giving the names of matrix columns
(third dimension of <code>X</code>).
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_row.names">row.names</code></td>
<td>

<p>(optional) character vector giving the names of matrix rows
(second dimension of <code>X</code>).
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_truth">truth</code></td>
<td>

<p>(optional) scalar or matrix giving the values of reference lines to
be plotted on each boxplot.  If a scalar then the same value will be
used for each boxplot.  If a matrix then the rows and columns of the
matrix correspond to the second and third dimension of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_colors">colors</code></td>
<td>

<p>A vector of colors to use for the boxplots.  Each row uses the same
color scheme.
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_las">las</code></td>
<td>
<p>Controls the orientation of axis labels.  See the <code>las</code>
section in the help page for <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="boxplot.mcmc.matrix_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effect, which is to draw a set of side-by-side
boxplots on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot.true">boxplot.true</a></code>,
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- array(rnorm(1000 * 3 * 4), dim=c(1000, 3, 4))
  dimnames(X)[[2]] &lt;- paste("row", 1:3)
  dimnames(X)[[3]] &lt;- paste("col", 1:4)
  BoxplotMcmcMatrix(X)

  truth &lt;- 0
  BoxplotMcmcMatrix(X, truth=truth)

  truth &lt;- matrix(rnorm(12), ncol=4)
  BoxplotMcmcMatrix(X, truth=truth)
</code></pre>

<hr>
<h2 id='boxplot.true'>
Compare Boxplots to True Values
</h2><span id='topic+boxplot.true'></span><span id='topic+BoxplotTrue'></span>

<h3>Description</h3>

<p>Plots side-by-side boxplots of the columns of the matrix <code>x</code>.
Each boxplot can have its own reference line (<code>truth</code>) and
standard error lines <code>se.truth</code>, if desired.  This function was
originally written to display MCMC output, where the reference lines
were true values used to test an MCMC simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxplotTrue(x, truth = NULL, vnames = NULL, center = FALSE,
            se.truth = NULL, color = "white", truth.color = "black",
            ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.true_+3A_x">x</code></td>
<td>

<p>The matrix whose columns are to be plotted.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_truth">truth</code></td>
<td>

<p>(optional) A vector of reference values with length equal to <code>ncol(x)</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_vnames">vnames</code></td>
<td>

<p>(optional) character vector giving the column names of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_center">center</code></td>
<td>

<p>(optional) logical.  If <code>truth</code> is supplied then
<code>center=TRUE</code> will center each column of <code>x</code> around
<code>truth</code> to show the variation around the reference line.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_se.truth">se.truth</code></td>
<td>

<p>(optional) numeric vector of length <code>ncol(x)</code>.  If <code>truth</code>
is supplied then additional reference lines will be drawn at
<code>truth +/- 2*se.truth</code>.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_color">color</code></td>
<td>

<p>(optional) vector of colors for each boxplot.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_truth.color">truth.color</code></td>
<td>

<p>A color (or vector of colors) to use for the segments representing
true values.
</p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the vertical axis.  If <code>NULL</code> then the
axis will be scaled to fit <code>x</code>, <code>truth</code>, and <code>truth + 
      c(2, -2) * se.truth</code></p>
</td></tr>
<tr><td><code id="boxplot.true_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for its side effect
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot.matrix">boxplot.matrix</a></code>,
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- t(matrix(rnorm(5000, 1:5, 1:5), nrow=5))
BoxplotTrue(x, truth=1:5, se.truth=1:5, col=rainbow(5), vnames =
  c("EJ", "TK", "JT", "OtherEJ", "TJ") )
</code></pre>

<hr>
<h2 id='check'>
Check MCMC Output
</h2><span id='topic+CheckMcmcMatrix'></span><span id='topic+CheckMcmcVector'></span><span id='topic+McmcMatrixReport'></span>

<h3>Description</h3>

<p>Verify that MCMC output covers expected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckMcmcMatrix(draws, truth, confidence = .95,
                control.multiple.comparisons = TRUE,
                burn = 0)

CheckMcmcVector(draws, truth, confidence = .95, burn = 0)

McmcMatrixReport(draws, truth, confidence = .95, burn = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_draws">draws</code></td>
<td>
<p>The array of MCMC draws to check.  This must be a matrix
for CheckMcmcMatrix and a vector for CheckMcmcVector.  </p>
</td></tr>
<tr><td><code id="check_+3A_truth">truth</code></td>
<td>
<p> The vector of true values that must be covered by
<code>draws</code> in order for the check to succeed.</p>
</td></tr>
<tr><td><code id="check_+3A_confidence">confidence</code></td>
<td>
<p> Specifies the probability width of the intervals
used to determine whether <code>draws</code> covers <code>truth</code>.
Central intervals are used, not HPD intervals.
</p>
</td></tr>
<tr><td><code id="check_+3A_control.multiple.comparisons">control.multiple.comparisons</code></td>
<td>
<p> If FALSE then every interval must
cover its corresponding true value.  Otherwise a fraction of
intervals (given by <code>confidence</code>) must cover.</p>
</td></tr>
<tr><td><code id="check_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to discard as burn-in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CheckMcmcVector</code> checks a vector of draws corresponding to a
scalar random variable.  <code>CheckMcmcMatrix</code> checks a matrix of
draws corresponding to a vector of random variables.  In either case
the check is made by constructing a central confidence interval
(obtained by removing half of <code>1 - confidence</code> from the upper and
lower tails of the distribution).
</p>
<p>If a single variable is being checked with CheckMcmcVector then the
check passes if and only if the interval covers the true value.
</p>
<p>If multiple values are being checked with CheckMcmcMatrix then the
user has control over how strict to make the check.  If
<code>control.multiple.comparisons</code> is FALSE then the check passes if
and only if all intervals cover true values.  Otherwise a fraction of
intervals must cover.  The fraction is the lower bound of the binomial
confidence interval for the coverage rate under the hypothesis that
the true coverage rate is <code>confidence</code>.
</p>


<h3>Value</h3>

<p><code>CheckMcmcVector</code> and <code>CheckMcmcMatrix</code> return <code>TRUE</code>
if the check passes, and <code>FALSE</code> if it does not.
</p>
<p><code>McmcMatrixReport</code> returns a string that can be put in the
<code>info</code> field of an <code><a href="testthat.html#topic+expect_true">expect_true</a></code>
expression, to give useful information about a failed test case.  The
return value is a textual representation of a three column matrix.
Each row matches a variable in <code>draws</code>, and gives the lower and
upper bounds for the credible interval used to check the values.  The
final column lists the true values that are supposed to be inside the
credible intervals.  The value is returned as a character string that
is expected to be fed to <code>cat()</code> or <code>print()</code> so that it
will render correctly in R CMD CHECK output.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ndraws &lt;- 100
draws &lt;- rnorm(ndraws, 0, 1)
CheckMcmcVector(draws, 0)  ## Returns TRUE
CheckMcmcVector(draws, 17)  ## Returns FALSE

draws &lt;- matrix(nrow = ndraws, ncol = 5)
for (i in 1:5) {
  draws[, i] &lt;- rnorm(ndraws, i, 1)
}  
CheckMcmcMatrix(draws, truth = 1:5)  ## Returns TRUE
CheckMcmcMatrix(draws, truth = 5:1)  ## Returns FALSE

</code></pre>

<hr>
<h2 id='check.data'>Checking data formats</h2><span id='topic+check.data'></span><span id='topic+check.scalar.probability'></span><span id='topic+check.positive.scalar'></span><span id='topic+check.nonnegative.scalar'></span><span id='topic+check.probability.distribution'></span><span id='topic+check.scalar.integer'></span><span id='topic+check.scalar.boolean'></span>

<h3>Description</h3>

<p>Checks that data matches a concept</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.scalar.probability(x)
check.positive.scalar(x)
check.nonnegative.scalar(x)
check.probability.distribution(x)
check.scalar.integer(x)
check.scalar.boolean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.data_+3A_x">x</code></td>
<td>
<p>An object to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> If the object does not match the concept being checked,
<code><a href="base.html#topic+stop">stop</a></code> is called.  Otherwise <code>TRUE</code> is returned.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='circles'>Draw Circles</h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>Draw circles on the current graphics device.</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles(center, radius, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles_+3A_center">center</code></td>
<td>
<p>A two-column matrix giving the coordinates of the circle center.
If a single circle is to be drawn then a 2-element vector can be passed
instead.</p>
</td></tr>
<tr><td><code id="circles_+3A_radius">radius</code></td>
<td>
<p>The radii of the circles.  A scalar value will be
repeated if <code>center</code> is a matrix with more than one row.  </p>
</td></tr>
<tr><td><code id="circles_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to 'segments'.  See
<code><a href="graphics.html#topic+par">par</a></code> for options controlling line type, line width,
color, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Draws circles on the current graphics device.  This is a
low-level plotting function similar to <code><a href="graphics.html#topic+points">points</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+segments">segments</a></code>, etc.  </p>


<h3>Value</h3>

<p>Returns invisible <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(1:10, type = "n")
  circles(cbind(c(2, 3, 4), c(4, 5,6 )), radius = c(.3, .4, .5))
</code></pre>

<hr>
<h2 id='compare.den'>
Compare several density estimates.
</h2><span id='topic+compare.den'></span><span id='topic+CompareDen'></span><span id='topic+compare.densities'></span><span id='topic+CompareDensities'></span>

<h3>Description</h3>

<p>Produces multiple density plots on a single axis, to compare the
columns of a matrix or the elements of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareDensities(x,
                 legend.text = NULL,
                 legend.location = "topright",
                 legend.title = NULL,
                 xlim = NULL,
                 ylim = NULL,
                 xlab = "parameter",
                 ylab = "density",
                 main = "",
                 lty = NULL,
                 col = "black",
                 axes = TRUE,
                 na.rm = TRUE,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.den_+3A_x">x</code></td>
<td>
<p> matrix or list of numeric vectors.  A density plot is
produced for each column of the matrix or element of the list.  </p>
</td></tr>
<tr><td><code id="compare.den_+3A_legend.text">legend.text</code></td>
<td>
<p> (optional) character vector giving names of each
density plot.  </p>
</td></tr>
<tr><td><code id="compare.den_+3A_legend.location">legend.location</code></td>
<td>
<p>Entry that can be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.  </p>
</td></tr>
<tr><td><code id="compare.den_+3A_legend.title">legend.title</code></td>
<td>
<p> The legend title.  </p>
</td></tr>
<tr><td><code id="compare.den_+3A_xlim">xlim</code></td>
<td>
<p> (optional) horizonal range of the plotting region.  If
omitted the region will be sized to fit all the observations in
<code>x</code>. </p>
</td></tr>
<tr><td><code id="compare.den_+3A_ylim">ylim</code></td>
<td>
<p> (optional) vertical range of the plotting region.  If
omitted the region will be sized to fit all empirical density plots.
</p>
</td></tr>
<tr><td><code id="compare.den_+3A_xlab">xlab</code></td>
<td>
<p> label to be placed on the horizontal axis </p>
</td></tr>
<tr><td><code id="compare.den_+3A_ylab">ylab</code></td>
<td>
<p> label to be placed on the vertical axis </p>
</td></tr>
<tr><td><code id="compare.den_+3A_main">main</code></td>
<td>
<p> main title for the plot </p>
</td></tr>
<tr><td><code id="compare.den_+3A_lty">lty</code></td>
<td>
<p>The line types to use for the different densities.  See
<code><a href="graphics.html#topic+par">par</a></code>.  If <code>NULL</code> then a different line type will
be used for each density.</p>
</td></tr>
<tr><td><code id="compare.den_+3A_col">col</code></td>
<td>
<p> vector of colors for the densities to be plotted.  </p>
</td></tr>
<tr><td><code id="compare.den_+3A_axes">axes</code></td>
<td>
<p>Logical.  Should axes and a box be drawn around the
figure?</p>
</td></tr>
<tr><td><code id="compare.den_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical value indicating whether <code>NA</code>'s should be
removed.</p>
</td></tr>
<tr><td><code id="compare.den_+3A_...">...</code></td>
<td>
<p> Other graphical parameters passed to
<code><a href="stats.html#topic+plot.density">plot.density</a></code>, and <code><a href="graphics.html#topic+lines">lines</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effect, which is to produce multiple density plots
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- t(matrix(rnorm(5000, 1:5, 1:5), nrow=5))
CompareDensities(x, legend.text=c("EJ", "TK", "JT", "OtherEJ", "TJ"),
                 col=rainbow(5), lwd=2)
</code></pre>

<hr>
<h2 id='compare.dynamic.distributions'>
Compare Dynamic Distributions
</h2><span id='topic+CompareDynamicDistributions'></span>

<h3>Description</h3>

<p>Produce a plot showing several stacked dynamic distributions over the same
horizontal axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareDynamicDistributions(
    list.of.curves,
    timestamps,
    style = c("dynamic", "boxplot"),
    xlab = "Time",
    ylab = "",
    frame.labels = rep("", length(list.of.curves)),
    main = "",
    actuals = NULL,
    col.actuals = "blue",
    pch.actuals = 1,
    cex.actuals = 1,
    vertical.cuts = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.dynamic.distributions_+3A_list.of.curves">list.of.curves</code></td>
<td>
<p>A list of matrices, all having the same number of
columns.  Each matrix represents a distribution of curves, with
rows corresponding to individual curves, and columns to time
points.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_timestamps">timestamps</code></td>
<td>
<p>A vector of time stamps, with length matching the
number of columns in each element of list.of.curves.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_style">style</code></td>
<td>
<p>Should the curves be represented using a dynamic
distribution plot, or boxplots.  Boxplots are better for small
numbers of time points.  Dynamic distribution plots are better for
large numbers of time points.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_ylab">ylab</code></td>
<td>
<p>Label for the (outer) vertical axis.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_frame.labels">frame.labels</code></td>
<td>
<p>Labels for the vertical axis of each subplot. The
length must match the number of plot.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_actuals">actuals</code></td>
<td>
<p>If non-<code>NULL</code>, actuals should be a numeric vector
giving the actual &quot;true&quot; value at each time point.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_col.actuals">col.actuals</code></td>
<td>
<p>Color to use for the actuals.  See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_pch.actuals">pch.actuals</code></td>
<td>
<p>Plotting character(s) to use for the actuals.  See
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_cex.actuals">cex.actuals</code></td>
<td>
<p>Scale factor for actuals.  See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_vertical.cuts">vertical.cuts</code></td>
<td>
<p>If non-<code>NULL</code> then this must be a vector of
the same type as <code>timestamps</code> with length matching the number
of plots.  A vertical line will be drawn at this location for each
plot.  Entries with the value <code>NA</code> signal that no vertical
line should be drawn for that entry.</p>
</td></tr>
<tr><td><code id="compare.dynamic.distributions_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to
<code><a href="#topic+PlotDynamicDistribution">PlotDynamicDistribution</a></code> or
<code><a href="#topic+TimeSeriesBoxplot">TimeSeriesBoxplot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>

<hr>
<h2 id='compare.many.densities'>
Compare several density estimates.
</h2><span id='topic+compare.many.densities'></span><span id='topic+CompareManyDensities'></span>

<h3>Description</h3>

<p>Produce a plot that compares the kernel density estimates for
each element in a series of Monte Carlo draws of a vector or
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareManyDensities(list.of.arrays,
                     style = c("density", "box"),
                     main = "",
                     color = NULL,
                     gap = 0,
                     burn = 0,
                     suppress.labels = FALSE,
                     x.same.scale = TRUE,
                     y.same.scale = FALSE,
                     xlim = NULL,
                     ylim = NULL,
                     legend.location = c("top", "right"),
                     legend.cex = 1,
                     reflines = NULL,
                     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.many.densities_+3A_list.of.arrays">list.of.arrays</code></td>
<td>
<p>A list of arrays representing the MCMC draws of
the vector or matrix in question.  Each list element represents a
different group.  The first index in each list list element
represents the Monte Carlo draw number (or iteration).  The
remaining indices represent the variables to be plotted.  If the
first list element has variable names assigned to its indices,
these will be used to label the plots.  </p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_style">style</code></td>
<td>
<p>The style of plot to use for comparing distributions.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_color">color</code></td>
<td>
<p>A vector of colors to be used for representing the groups.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_gap">gap</code></td>
<td>
<p>The gap (in lines) between plots.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_burn">burn</code></td>
<td>
<p>The number of MCMC iterations to be discarded as burn-in.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_suppress.labels">suppress.labels</code></td>
<td>
<p>Logical.  If <code>FALSE</code> then the dimnames (if
any) of the first element in <code>list.of.arrays</code> will be used
to annotate the plot.  If <code>TRUE</code> then no labels will be
used. </p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_x.same.scale">x.same.scale</code></td>
<td>
<p>Logical indicating whether the same horizontal scale
should be used for all the plots.  </p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_y.same.scale">y.same.scale</code></td>
<td>
<p>Logical indicating whether the same vertical scale
should be used for all the plots.  This argument is ignored if
<code>style == "box"</code>.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_xlim">xlim</code></td>
<td>
<p>Either <code>NULL</code>, or a pair of numbers giving limits for
the horizontal axis.  If <code>xlim</code> is set then the same xlim
values will be used for all plots and the <code>x.same.scale</code>
argument will be ignored.  </p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_ylim">ylim</code></td>
<td>
<p>Either <code>NULL</code>, or a pair of numbers giving limits for
the vertical axis.  If <code>ylim</code> is set then the same ylim
values will be used for all plots and the <code>y.same.scale</code>
argument will be ignored.  This argument is ignored if
<code>style == "box".</code></p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_legend.location">legend.location</code></td>
<td>
<p>The location of the legend, either on top or
at the right.  It can also be <code>NULL</code> in which case no legend
will appear.  The legend names will be taken from
names(list.of.arrays).  If it does not have names, then no
legend will be produced.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_legend.cex">legend.cex</code></td>
<td>
<p>The relative scale factor to use for the legend
text.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_reflines">reflines</code></td>
<td>
<p>This can be <code>NULL</code>, in which case no reference
lines are drawn, it can be a single real number in which case a
reference line will be drawn at that value in each panel, or it can
be a vector with length equal to the number of panels, in which case
a reference line will be drawn at each panel-specific value.</p>
</td></tr>
<tr><td><code id="compare.many.densities_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="#topic+CompareDen">CompareDen</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="#topic+CompareManyTs">CompareManyTs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
dimnames(x) &lt;- list(NULL, c("Larry", "Moe", "Curly"), c("Larry", "Eric", "Sergey"))
y &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
z &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
data &lt;- list(x = x, y = y, z = z)
CompareManyDensities(data, color = c("red", "blue", "green"))
CompareManyDensities(data, style = "box")

x &lt;- matrix(rnorm(5000), nrow = 1000)
colnames(x) &lt;- c("Larry", "Moe", "Curly", "Shemp", "???")
y &lt;- matrix(rnorm(5000), nrow = 1000)
z &lt;- matrix(rnorm(5000), nrow = 1000)
data &lt;- list(x = x, y = y, z = z)
CompareManyDensities(data, color = c("red", "blue", "green"))
CompareManyDensities(data, style = "box")
</code></pre>

<hr>
<h2 id='compare.many.ts'>
Compares several density estimates.
</h2><span id='topic+compare.many.ts'></span><span id='topic+CompareManyTs'></span>

<h3>Description</h3>

<p>Produce a plot that compares the kernel density estimates for
each element in a series of Monte Carlo draws of a vector or
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareManyTs(list.of.ts, burn = 0, type = "l", gap = 0,
              boxes = TRUE, thin = 1, labels = NULL,
              same.scale = TRUE, ylim = NULL, refline = NULL,
              color = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.many.ts_+3A_list.of.ts">list.of.ts</code></td>
<td>
<p>A list of time series matrices, data.frames or
3-dimensional arrays, all of the same size.  The list elements
correspond to groups.  The first index of the array in each list
element corresponds to time.  The subsequent indices correspond to
variables to be plotted.  </p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_burn">burn</code></td>
<td>
<p>The number of initial observations to be discarded as
burn-in (when plotting MCMC output). </p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_type">type</code></td>
<td>
<p>The plotting type to use when plotting the time series.  See
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_gap">gap</code></td>
<td>
<p>The amount of space to put between plots.</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_boxes">boxes</code></td>
<td>
<p>Logical.  Should boxes be drawn around the plots?</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_thin">thin</code></td>
<td>
<p>Plot every thin'th observation.  This can reduce the
amount of time it takes to make the plot if there are many long
time series.
</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_labels">labels</code></td>
<td>
<p>A character vector to use as labels for individual plots.</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical.  If TRUE then all plots are shown on the
same verical scale, and vertical axes are drawn.  If FALSE
then each plot gets its own scale.
</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_ylim">ylim</code></td>
<td>
<p>The scale of the vertical axis.  If non-NULL then
same.scale will be set to TRUE.
</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_refline">refline</code></td>
<td>
<p>The scalar value at which a thin dotted horizontal
line should be plotted in each panel.  This is useful for
highlighting zero, for example.
</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_color">color</code></td>
<td>
<p>A vector of colors to use for the plots.</p>
</td></tr>
<tr><td><code id="compare.many.ts_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to 'plot' and 'axis'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotManyTs">PlotManyTs</a></code>, <code><a href="#topic+CompareManyDensities">CompareManyDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
dimnames(x) &lt;- list(NULL, c("Larry", "Moe", "Curly"), c("Larry", "Eric", "Sergey"))
y &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
z &lt;- array(rnorm(9000), dim = c(1000, 3, 3))
data &lt;- list(x = x, y = y, z = z)
CompareManyTs(data, color = c("red", "blue", "green"))

x &lt;- matrix(rnorm(5000), nrow = 1000)
colnames(x) &lt;- c("Larry", "Moe", "Curly", "Shemp", "???")
y &lt;- matrix(rnorm(5000), nrow = 1000)
z &lt;- matrix(rnorm(5000), nrow = 1000)
data &lt;- list(x = x, y = y, z = z)
CompareManyTs(data, color = c("red", "blue", "green"))
</code></pre>

<hr>
<h2 id='compare.vector.distribution'>Boxplots to compare distributions of vectors</h2><span id='topic+CompareVectorBoxplots'></span><span id='topic+compare.vector.boxplots'></span>

<h3>Description</h3>

<p>Uses boxplots to compare distributions of vectors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareVectorBoxplots(draws, main = NULL, colors = NULL, burn = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.vector.distribution_+3A_draws">draws</code></td>
<td>
<p>A list of MCMC draws.  Each list element is a matrix with
rows corresponding to MCMC iterations and columns to variables.  The
matrices can have different numbers of rows, but should have the same
numbers of columns.</p>
</td></tr>
<tr><td><code id="compare.vector.distribution_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="compare.vector.distribution_+3A_colors">colors</code></td>
<td>
<p>Colors to use for the boxplots.  The length must match
the number entries in <code>draws</code>.</p>
</td></tr>
<tr><td><code id="compare.vector.distribution_+3A_burn">burn</code></td>
<td>
<p>The number of initial MCMC iterations to discard before
making the plot.</p>
</td></tr>
<tr><td><code id="compare.vector.distribution_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates side-by-side boxplots with the dimensions of each
vector gropued together.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(300, mean = 1:3, sd = .4), ncol = 3, byrow = TRUE)
y &lt;- matrix(rnorm(600, mean = 3:1, sd = .2), ncol = 3, byrow = TRUE)
CompareVectorBoxplots(list(x = x, y = y), colors = c("red", "blue"))

</code></pre>

<hr>
<h2 id='diff.double.model'>DiffDoubleModel</h2><span id='topic+DiffDoubleModel'></span>

<h3>Description</h3>

<p>A 'DiffDoubleModel' is tag given to a probability
distribution that measures a real-valued scalar outcome, and whose log
density is twice differentiable with respect to the random variable.
The tag is a signal to underlying C++ code that the object being
passed is one of a subset of understood distributions.  Presently
that subset includes the following distributions.
</p>

<ul>
<li><p><code><a href="#topic+SdPrior">SdPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+NormalPrior">NormalPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+BetaPrior">BetaPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+UniformPrior">UniformPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+GammaPrior">GammaPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+TruncatedGammaPrior">TruncatedGammaPrior</a></code>
</p>
</li>
<li><p><code><a href="#topic+LognormalPrior">LognormalPrior</a></code>
</p>
</li></ul>

<p>Clearly this list is non-exhaustive, and other distributions may be
added in the future.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='dirichlet-distribution'>The Dirichlet Distribution</h2><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density and random generation for the Dirichlet distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(probabilities, nu, logscale = FALSE)
rdirichlet(n, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet-distribution_+3A_probabilities">probabilities</code></td>
<td>
<p>A vector representing a discrete probability
distribution, or a matrix where each row is a discrete probability
distribution.  Zero probabilities are not allowed.</p>
</td></tr>
<tr><td><code id="dirichlet-distribution_+3A_nu">nu</code></td>
<td>
<p>The parameters of the Dirichlet distribution.  This can be a
vector of positive numbers, interpretable as prior counts, of length
matching the dimension of probabilities.  If <code>probabilities</code> is
a matrix (or if <code>n &gt; 1</code>) then <code>nu</code> can also be a matrix of
the same dimension, in which case each row of <code>nu</code> is used to
evaluate the corresponding row of <code>probabilities</code>.</p>
</td></tr>
<tr><td><code id="dirichlet-distribution_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  If TRUE then return the density on the log
scale.  Otherwise return the density on the raw scale.</p>
</td></tr>
<tr><td><code id="dirichlet-distribution_+3A_n">n</code></td>
<td>
<p>The number of desired draws.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dirichlet distribution is a generalization of the beta
distribution.  Whereas beta distribution is a model for probabilities,
the Dirichlet distribution is a model for discrete distributions with
several possible outcome values.
</p>
<p>Let <code class="reqn">\pi</code> denote a discrete probability distribution (a vector
of positive numbers summing to 1), and let <code class="reqn">\nu</code> be a vector
of positive numbers (the parameters of the Dirichlet distribution),
which can be thought of as prior counts.  Then the density of the
Dirichlet distribution can be written
</p>
<p style="text-align: center;"><code class="reqn">f(\pi) = \frac{\Gamma(\sum_i\nu_i)}{\prod_i \Gamma(\nu_i)}
    \prod_i \pi_i^{\nu_i-1}.</code>
</p>



<h3>Value</h3>

<p><code>ddirichlet</code> returns a vector of density values, with one
entry per row in <code>probabilities</code>.  <code>rdirichlet</code> returns a
matrix (if <code>n &gt; 1</code>) or a vector (if <code>n==1</code>) containing the
draws from the Dirichlet distribution with the specified parameters.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='dirichlet.prior'>Dirichlet prior for a multinomial distribution</h2><span id='topic+DirichletPrior'></span>

<h3>Description</h3>

<p>Specifies Dirichlet prior for a discrete probability
distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'> DirichletPrior(prior.counts, initial.value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet.prior_+3A_prior.counts">prior.counts</code></td>
<td>
<p>A vector of positive numbers representing prior counts.</p>
</td></tr>
<tr><td><code id="dirichlet.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value in the MCMC algorithm of the
distribution being modeled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='discrete-uniform-prior'>Discrete prior distributions</h2><span id='topic+DiscreteUniformPrior'></span><span id='topic+PointMassPrior'></span><span id='topic+PoissonPrior'></span>

<h3>Description</h3>

<p>Prior distributions over a discrete quantities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointMassPrior(location)
PoissonPrior(mean, lower.limit = 0, upper.limit = Inf)
DiscreteUniformPrior(lower.limit, upper.limit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete-uniform-prior_+3A_location">location</code></td>
<td>
<p>The location of the point mass.</p>
</td></tr>
<tr><td><code id="discrete-uniform-prior_+3A_mean">mean</code></td>
<td>
<p>The mean of the Poisson distribution.</p>
</td></tr>
<tr><td><code id="discrete-uniform-prior_+3A_lower.limit">lower.limit</code></td>
<td>
<p>The smallest value within the support of the
distribution.  The prior probability for numbers less than
<code>lower.limit</code> is zero. </p>
</td></tr>
<tr><td><code id="discrete-uniform-prior_+3A_upper.limit">upper.limit</code></td>
<td>
<p>The largest value within the support of the
distribution.  The prior probability for numbers greater than
<code>upper.limit</code> is zero. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Each function returns a prior object whose class is the same as
the function name.  All of these inherit from &quot;DiscreteUniformPrior&quot;
and from &quot;Prior&quot;.
</p>
<p>The <code>PoissonPrior</code> assumes a potentially truncated Poisson
distribution with the given mean.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Specify an exact number of trees in a Bart model (see the BoomBart
## package).

ntrees &lt;- PointMassPrior(200)

## Uniform prior between 50 and 100 trees, including the endpoints.
ntrees &lt;- DiscreteUniformPrior(50, 100)

## Truncated Poisson prior, with a mean of 20, a lower endpoint of 1,
## and an upper endpoint of 50.
ntrees &lt;- PoissonPrior(20, 1, 50)

</code></pre>

<hr>
<h2 id='dmvn'>Multivariate Normal Density</h2><span id='topic+dmvn'></span>

<h3>Description</h3>

<p>Evaluate the multivariate normal density.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvn(y, mu, sigma, siginv = NULL, ldsi = NULL, logscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvn_+3A_y">y</code></td>
<td>
<p>A numeric vector or matrix containing the data whose density
is desired.</p>
</td></tr>
<tr><td><code id="dmvn_+3A_mu">mu</code></td>
<td>
<p>The mean of the distribution.  A vector.</p>
</td></tr>
<tr><td><code id="dmvn_+3A_sigma">sigma</code></td>
<td>
<p>The variance matrix of the distribution.  A matrix.</p>
</td></tr>
<tr><td><code id="dmvn_+3A_siginv">siginv</code></td>
<td>
<p>The inverse of <code>sigma</code>, or <code>NULL</code>.  If
<code>siginv</code> is non-<code>NULL</code> then <code>sigma</code> will not be
used.</p>
</td></tr>
<tr><td><code id="dmvn_+3A_ldsi">ldsi</code></td>
<td>
<p>The log determinant of <code>siginv</code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dmvn_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the density is returned
on the log scale.  Otherwise the density is returned on the density
scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the density of each row of <code>y</code>.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='double.model'>Prior distributions for a real valued scalar</h2><span id='topic+DoubleModel'></span><span id='topic+double.model'></span>

<h3>Description</h3>

<p>A <code>DoubleModel</code> is a class of prior distributions for
real valued scalar parameters.  A <code>DoubleModel</code> is sometimes used
by a probability model that does not have a conjugate prior.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BetaPrior">BetaPrior</a></code>,
<code><a href="#topic+GammaPrior">GammaPrior</a></code>,
<code><a href="#topic+LognormalPrior">LognormalPrior</a></code>,
<code><a href="#topic+NormalPrior">NormalPrior</a></code>,
<code><a href="#topic+SdPrior">SdPrior</a></code>,
<code><a href="#topic+TruncatedGammaPrior">TruncatedGammaPrior</a></code>,
and <code><a href="#topic+UniformPrior">UniformPrior</a></code>.
</p>

<hr>
<h2 id='external.legend'>
Add an external legend to an array of plots.
</h2><span id='topic+AddExternalLegend'></span><span id='topic+ExternalLegendLayout'></span>

<h3>Description</h3>

<p><code>ExternalLegendLayout</code> sets up a plotting region to plot a
regular grid of points, with an optional legend on the top or right of
the grid.
</p>
<p><code>AddExternalLegend</code> adds a legend to a grid of plots that was set
up using <code>ExternalLegendLayout</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExternalLegendLayout(nrow,
                     ncol,
                     legend.labels,
                     legend.location = c("top", "right"),
                     outer.margin.lines = rep(4, 4),
                     gap.between.plots = rep(0, 4),
                     legend.cex = 1,
                     x.axis = TRUE,
                     y.axis = TRUE)

AddExternalLegend(legend.labels,
                  legend.location = c("top", "right"),
                  legend.cex =1,
                  bty = "n",
                  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="external.legend_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows in the array of plots.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns in the array of plots.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_legend.labels">legend.labels</code></td>
<td>
<p>The labels to be used in the legend.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_legend.location">legend.location</code></td>
<td>
<p>Specifies whether the legend should appear on
the top or the right hand side.  It can also be <code>NULL</code>,
indicating that no legend is desired.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_outer.margin.lines">outer.margin.lines</code></td>
<td>
<p>A vector of length four giving the number of
lines of text desired for the outer margins of the plot.  See the
<code>oma</code> argument of <code><a href="graphics.html#topic+par">par</a></code>.  This can also be
specified as a single number, to be repeated 4 times.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_gap.between.plots">gap.between.plots</code></td>
<td>
<p>A vector of length 4 giving the number of
lines of text to leave between grid panels.  See the <code>mar</code>
argument of <code><a href="graphics.html#topic+par">par</a></code>.  This can also be specified as a
single number, to be repeated 4 times.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_legend.cex">legend.cex</code></td>
<td>
<p>The scale factor that will be used for legend text.
This must match the scale factor used in add.external.legend.</p>
</td></tr>
<tr><td><code id="external.legend_+3A_x.axis">x.axis</code></td>
<td>
<p>Will any plots have a horizontal axis?</p>
</td></tr>
<tr><td><code id="external.legend_+3A_y.axis">y.axis</code></td>
<td>
<p>Will any plots have a vertical axis?</p>
</td></tr>
<tr><td><code id="external.legend_+3A_bty">bty</code></td>
<td>
<p>Type of box to draw around the legend.  Can be &quot;n&quot; (for no
box) or &quot;o&quot; for a box.  See <code><a href="graphics.html#topic+legend">legend</a></code>.  </p>
</td></tr>
<tr><td><code id="external.legend_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ExternalLegendLayout</code> returns the original graphical
parameters, intended for use with <code><a href="base.html#topic+on.exit">on.exit</a></code>.
</p>
<p><code>AddExternalLegend</code> returns invisible <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+legend">legend</a></code> <code><a href="graphics.html#topic+layout">layout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example.plot &lt;- function() {
  x &lt;- rnorm(100)
  y &lt;- rnorm(100)
  scale &lt;- range(x, y)
  opar &lt;- ExternalLegendLayout(nrow = 2,
                               ncol = 2,
                               legend.labels = c("foo", "bar"))
  on.exit({par(opar); layout(1)})
  hist(x, xlim = scale, axes = FALSE, main = "")
  mtext("X", side = 3, line = 1)
  box()
  plot(x, y, xlim = scale, ylim = scale, axes = FALSE)
  box()
  axis(3)
  axis(4)
  plot(y, x, xlim = scale, ylim = scale, axes = FALSE, pch = 2, col = 2)
  box()
  axis(1)
  axis(2)
  hist(y, xlim = scale, axes = FALSE, main = "")
  mtext("Y", side = 1, line = 1)
  box()
  AddExternalLegend(legend.labels = c("foo", "bar"),
                    pch = 1:2,
                    col = 1:2,
                    legend.cex = 1.5)
}

## Now call example.plot().
example.plot()

## Because of the call to on.exit(), in example.plot,
## the original plot layout is restored.
hist(1:10)
</code></pre>

<hr>
<h2 id='gamma.prior'>Gamma prior distribution</h2><span id='topic+GammaPrior'></span><span id='topic+TruncatedGammaPrior'></span>

<h3>Description</h3>

<p>Specifies gamma prior distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GammaPrior(a = NULL, b = NULL, prior.mean = NULL, initial.value = NULL)
  TruncatedGammaPrior(a = NULL, b = NULL, prior.mean = NULL,
                      initial.value = NULL,
                      lower.truncation.point = 0,
                      upper.truncation.point = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma.prior_+3A_a">a</code></td>
<td>
<p>The shape parameter in the Gamma(a, b) distribution.</p>
</td></tr>
<tr><td><code id="gamma.prior_+3A_b">b</code></td>
<td>
<p>The scale paramter in the Gamma(a, b) distribution.</p>
</td></tr>
<tr><td><code id="gamma.prior_+3A_prior.mean">prior.mean</code></td>
<td>
<p>The mean the Gamma(a, b) distribution, which is a/b.</p>
</td></tr>
<tr><td><code id="gamma.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value in the MCMC algorithm of the
variable being modeled.</p>
</td></tr>
<tr><td><code id="gamma.prior_+3A_lower.truncation.point">lower.truncation.point</code></td>
<td>
<p>The lower limit of support for the
truncated gamma distribution.</p>
</td></tr>
<tr><td><code id="gamma.prior_+3A_upper.truncation.point">upper.truncation.point</code></td>
<td>
<p>The upper limit of support for the
truncated gamma distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the Gamma(a, b) distribution is a/b and the variance is
a/b^2.  If <code>prior.mean</code> is not <code>NULL</code>, then one of either
<code>a</code> or <code>b</code> must be non-<code>NULL</code> as well.
</p>
<p>GammaPrior is the conjugate prior for a Poisson mean or an exponential
rate.  For a Poisson mean <code>a</code> corresponds to a prior sum of
observations and <code>b</code> to a prior number of observations.  For an
exponential rate the roles are reversed <code>a</code> represents a number
of observations and <code>b</code> the sum of the observed durations.  The
gamma distribution is a generally useful for parameters that must be
positive.
</p>
<p>The gamma distribution is the conjugate prior for the reciprocal of a
Guassian variance, but <code><a href="#topic+SdPrior">SdPrior</a></code> should usually be used in
that case.
</p>
<p>A TruncatedGammaPrior is a GammaPrior with support truncated to the
interval <code>(lower.truncation.point, upper.truncation.point)</code>.
</p>
<p>If an object specifically needs a <code>GammaPrior</code> you typically
cannot pass a <code>TruncatedGammaPrior</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='GenerateFactorData'>Generate a data frame of all factor data</h2><span id='topic+GenerateFactorData'></span>

<h3>Description</h3>

<p> This function is mainly intended for example code and unit
testing.  It generates a <code>data.frame</code> containing all factor data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GenerateFactorData(factor.levels.list, sample.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateFactorData_+3A_factor.levels.list">factor.levels.list</code></td>
<td>
<p>A list of character vectors giving factor
level names.  The names attribute of this list becomes the set of
variables names for the return data frame.</p>
</td></tr>
<tr><td><code id="GenerateFactorData_+3A_sample.size">sample.size</code></td>
<td>
<p>The desired number of rows in the returned data frame.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  foo &lt;- GenerateFactorData(list(a = c("foo", "bar", "baz"),
                                 b = c("larry", "moe", "curly", "shemp")),
                            50)

  head(foo)
#     a     b
# 1 bar curly
# 2 foo curly
# 3 bar   moe
# 4 bar   moe
# 5 baz curly
# 6 bar curly

</code></pre>

<hr>
<h2 id='histabunch'>
A Bunch of Histograms
</h2><span id='topic+histabunch'></span>

<h3>Description</h3>

<p>Plot a bunch of histograms describing the marginal distributions the
columns in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histabunch(x, gap = 1, same.scale = FALSE, boxes = FALSE,
           min.continuous = 12, max.factor = 40,
           vertical.axes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histabunch_+3A_x">x</code></td>
<td>
<p>A matrix or data frame containing the variables to be plotted.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_gap">gap</code></td>
<td>
<p>The gap between the plots, measured in lines of text.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical. Indicates whether the histograms
should all be plotted on the same scale.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_boxes">boxes</code></td>
<td>
<p>Logical. Indicates whether boxes should be drawn
around the histograms.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_min.continuous">min.continuous</code></td>
<td>
<p>Numeric variables with more than <code>min.continuous</code>
unique values will be plotted as continuous.  Otherwise they will
be treated as factors.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_max.factor">max.factor</code></td>
<td>
<p>Factors with more than <code>max.factor</code> levels will
be beautified (ha!) by combining their remaining levels into an
&quot;other&quot; category.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_vertical.axes">vertical.axes</code></td>
<td>
<p>Logical value indicating whether the histograms
should be given vertical &quot;Y&quot; axes.</p>
</td></tr>
<tr><td><code id="histabunch_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to hist (for numeric variables) or
barplot (for factors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effect, which is to produce multiple histograms
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code> <code><a href="graphics.html#topic+barplot">barplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(airquality)
  histabunch(airquality)
</code></pre>

<hr>
<h2 id='inverse-wishart'>Inverse Wishart Distribution</h2><span id='topic+dInverseWishart'></span><span id='topic+InverseWishartPrior'></span>

<h3>Description</h3>

<p>Density for the inverse Wishart distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dInverseWishart(Sigma, sum.of.squares, nu, logscale = FALSE,
                log.det.sumsq = log(det(sum.of.squares)))

InverseWishartPrior(variance.guess, variance.guess.weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse-wishart_+3A_sigma">Sigma</code></td>
<td>
<p>Argument (random variable) for the inverse Wishart
distribution.  A positive definite matrix.</p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_nu">nu</code></td>
<td>
<p>The &quot;degrees of freedom&quot; parameter of the inverse Wishart
distribution.  The distribution is only defined for <code>nu &gt;=
      nrow(Sigma) - 1</code>. </p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_sum.of.squares">sum.of.squares</code></td>
<td>
<p>A positive definite matrix.  Typically this is
the sum of squares that is the sufficient statistic for the
inverse Wishart distribution.</p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the density is returned
on the log scale.  Otherwise the density is returned on the density
scale.</p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_log.det.sumsq">log.det.sumsq</code></td>
<td>
<p>The log determinant of <code>sum.of.squares</code>.  If
this function is to be called many times then precomputing the log
determinant can save considerable compute time. </p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_variance.guess">variance.guess</code></td>
<td>
<p>A prior guess at the value of the variance
matrix the prior is modeling.</p>
</td></tr>
<tr><td><code id="inverse-wishart_+3A_variance.guess.weight">variance.guess.weight</code></td>
<td>
<p>A positive scalar indicating the number
of observations worth of weight to place on <code>variance.guess</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse Wishart distribution has density function
</p>
<p style="text-align: center;"><code class="reqn"> \frac{|Sigma|^{-\frac{\nu + p + 1}{2}} \exp(-tr(\Sigma^{-1}S) / 2)}{
      2^{\frac{\nu p}{2}}|\Sigma|^{\frac{\nu}{2}}\Gamma_p(\nu / 2)}%
  </code>
</p>



<h3>Value</h3>

<p><code>dInverseWishart</code> returns the scalar density (or log density) at
the specified value.  This function is not vectorized, so only one
random variable (matrix) can be evaluated at a time.
</p>
<p><code>InverseWishartPrior</code> returns a list that encodes the parameters
of the distribution in a format expected by underlying C++ code.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dWishart">dWishart</a></code>,
<code><a href="#topic+rWishart">rWishart</a></code>,
<code><a href="#topic+NormalInverseWishartPrior">NormalInverseWishartPrior</a></code>
</p>

<hr>
<h2 id='invgamma'>Inverse Gamma Distribution</h2><span id='topic+rinvgamma'></span><span id='topic+pinvgamma'></span><span id='topic+qinvgamma'></span><span id='topic+dinvgamma'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and
random draws from the inverse gamma distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, shape, rate, logscale = FALSE)
pinvgamma(x, shape, rate, lower.tail = TRUE, logscale = FALSE)
qinvgamma(p, shape, rate, lower.tail = TRUE, logscale = FALSE)
rinvgamma(n, shape, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invgamma_+3A_x">x</code></td>
<td>
<p>A vector of deviates where the density or distribution
function is to be evaluated.</p>
</td></tr>
<tr><td><code id="invgamma_+3A_p">p</code></td>
<td>
<p>A vector of probabilities representing CDF values (if
<code>lower.tail == TRUE</code>) or survivor function values (if
<code>lower.tail == FALSE</code>) from the inverse gamma distribution.  </p>
</td></tr>
<tr><td><code id="invgamma_+3A_n">n</code></td>
<td>
<p>The desired number of draws from the inverse gamma distribution.</p>
</td></tr>
<tr><td><code id="invgamma_+3A_shape">shape</code></td>
<td>
<p>The shape parameter.</p>
</td></tr>
<tr><td><code id="invgamma_+3A_rate">rate</code></td>
<td>
<p>The 'rate' parameter.  NOTE: The term 'rate' is used to
match the corresponding parameter in <code><a href="stats.html#topic+rgamma">rgamma</a></code>. Much
of the rest of the world calls this the 'scale' parameter.</p>
</td></tr>
<tr><td><code id="invgamma_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then probabilities or density
values are interpreted on the log scale.  Otherwise the scale is the
probability or probability density scale.</p>
</td></tr>
<tr><td><code id="invgamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical.  If TRUE then cumulative probabilities are
measured from zero, as in a CDF.  If FALSE then cumulative are
measured from infinity, as in a survivor function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>rinvgamma</code> returns draws from the distribution.
</p>
</li>
<li><p><code>dinvgamma</code> returns the density function.
</p>
</li>
<li><p><code>pinvgamma</code> returns the cumulative distribution function
(or survivor function, if <code>lower.tail == FALSE</code>).
</p>
</li>
<li><p><code>qinvgamma</code> returns quantiles from the distribution.
<code>qinvgamma</code> and <code>pinvgamma</code> are inverse functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='is.even'>
Check whether a number is even or odd.
</h2><span id='topic+is.even'></span><span id='topic+is.odd'></span><span id='topic+IsEven'></span><span id='topic+IsOdd'></span>

<h3>Description</h3>

<p>Check whether a number is even or odd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsEven(x)
IsOdd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.even_+3A_x">x</code></td>
<td>
<p> An integer or vector of integers. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether the argument is even (or odd).
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IsEven(2) ## TRUE
IsOdd(2)  ## FALSE
</code></pre>

<hr>
<h2 id='lmgamma'>Log Multivariate Gamma Function</h2><span id='topic+lmgamma'></span>

<h3>Description</h3>

<p>Returns the log of the multivariate gamma function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmgamma(y, dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmgamma_+3A_y">y</code></td>
<td>
<p>The function argument, which must be a positive scalar.</p>
</td></tr>
<tr><td><code id="lmgamma_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the multivariate gamma function,
which must be an integer &gt;= 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate gamma function is
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_p(y) = \pi^{p(p-1)/4} \prod_{j =1}^p \Gamma(y + (1-j)/2).</code>
</p>

<p>The multivariate gamma function shows up as part of the normalizing
constant for the Wishart and inverse Wishart distributions.
</p>


<h3>Value</h3>

<p> Returns the log of the multivariate gamma function.  Note that
this function is not vectorized.  Both <code>y</code> and <code>dimension</code>
must be scalars, and the return value is a scalar.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='log.integrated.gaussian.likelihood'>Log Integrated Gaussian Likelihood</h2><span id='topic+LogIntegratedGaussianLikelihood'></span>

<h3>Description</h3>

<p>Compute the log of the integrated Gaussian likelihood,
where the model paramaters are integrated out with respect to a
normal-inverse gamma prior.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogIntegratedGaussianLikelihood(suf, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log.integrated.gaussian.likelihood_+3A_suf">suf</code></td>
<td>
<p>A <code><a href="#topic+GaussianSuf">GaussianSuf</a></code> object describing the data.</p>
</td></tr>
<tr><td><code id="log.integrated.gaussian.likelihood_+3A_prior">prior</code></td>
<td>
<p>A <code><a href="#topic+NormalInverseGammaPrior">NormalInverseGammaPrior</a> describing the
  prior distribution.</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar giving the log integrated likelihood.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prior &lt;- NormalInverseGammaPrior(10, 2, sqrt(2), 1)
y &lt;- c(7.8949, 9.17438, 8.38808, 5.52521)
suf &lt;- GaussianSuf(y)
loglike &lt;- LogIntegratedGaussianLikelihood(suf, prior)
# -9.73975

</code></pre>

<hr>
<h2 id='lognormal.prior'>Lognormal Prior Distribution</h2><span id='topic+LognormalPrior'></span>

<h3>Description</h3>

<p>Specifies a lognormal prior distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LognormalPrior(mu = 0.0, sigma = 1.0, initial.value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lognormal.prior_+3A_mu">mu</code></td>
<td>
<p>mean of the corresponding normal distribution.</p>
</td></tr>
<tr><td><code id="lognormal.prior_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the corresponding normal
distribution.  WARNING: If something looks strange in your
program, look out for SD != Variance errors.</p>
</td></tr>
<tr><td><code id="lognormal.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>Initial value of the variable to be modeled
(e.g. in an MCMC algorithm).  If <code>NULL</code> then the prior mean will
be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A lognormal distribution, where log(y) ~ N(mu, sigma).  The mean
of this distribution is exp(mu + 0.5 * sigma^2), so don't only
focus on the mean parameter here.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>
<p><a href="https://en.wikipedia.org/wiki/Log-normal_distribution">https://en.wikipedia.org/wiki/Log-normal_distribution</a>
</p>

<hr>
<h2 id='markov.prior'>Prior for a Markov chain</h2><span id='topic+MarkovPrior'></span>

<h3>Description</h3>

<p>The conjugate prior distribution for the parameters of a
homogeneous Markov chain.  The rows in the transition probability
matrix modeled with independent Dirichlet priors.  The distribution of
the initial state is modeled with its own independent Dirichlet
prior.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarkovPrior(prior.transition.counts = NULL,
            prior.initial.state.counts = NULL,
            state.space.size = NULL,
            uniform.prior.value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markov.prior_+3A_prior.transition.counts">prior.transition.counts</code></td>
<td>
<p>A matrix of the same dimension as the
transition probability matrix being modeled.  Entry (i, j) represents
the &quot;prior count&quot; of transitions from state <code>i</code> to state <code>j</code>.</p>
</td></tr>
<tr><td><code id="markov.prior_+3A_prior.initial.state.counts">prior.initial.state.counts</code></td>
<td>
<p>A vector of positive numbers
representing prior counts of initial states.</p>
</td></tr>
<tr><td><code id="markov.prior_+3A_state.space.size">state.space.size</code></td>
<td>
<p>If both prior.transition.counts and
prior.initial.state.counts are missing, then they will be filled
with an object of dimension state.space.size where all entries are
set to <code>uniform.prior.value</code>.</p>
</td></tr>
<tr><td><code id="markov.prior_+3A_uniform.prior.value">uniform.prior.value</code></td>
<td>
<p>The default value to use for entries of
<code>prior.transition.counts</code> and
<code>prior.initial.state.counts</code>, when they are not supplied by the
user.</p>
</td></tr>  </table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='match_data_frame'>MatchDataFrame</h2><span id='topic+MatchDataFrame'></span>

<h3>Description</h3>

<p>Given two data frames with the same data, but with rows and
columns in potentially different orders, produce a pair of
permutations such that data2[row.permutation, column.permutation]
matches data1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchDataFrame(data.to.match, data.to.permute)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_data_frame_+3A_data.to.match">data.to.match</code></td>
<td>
<p>The data frame to be matched.</p>
</td></tr>
<tr><td><code id="match_data_frame_+3A_data.to.permute">data.to.permute</code></td>
<td>
<p>The data frame to be permuted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two elements.
</p>
<table>
<tr><td><code>column.permutation</code></td>
<td>
<p>A vector of indices such that the columns of
<code>data2[, column.permutation]</code> match the columns of
<code>data1</code>.  The matching is based on column names.</p>
</td></tr>
<tr><td><code>row.permutation</code></td>
<td>
<p>A vector of indices such that the rows of
<code>data2[row.permutation, column.permutation]</code> match the rows of
<code>data1</code>.  The matching is done by converting rows to strings,
and matching the strings.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x1 &lt;- data.frame(larry = rnorm(10), moe = 1:10, curly = rpois(10, 2))
 x2 &lt;- x1[c(1:5, 10:6), c(3, 1, 2)]

 m &lt;- MatchDataFrame(x1, x2)
 x2[m$row.permutation, m$column.permutation] == x1  ## all TRUE
</code></pre>

<hr>
<h2 id='mscan'>Scan a Matrix</h2><span id='topic+mscan'></span>

<h3>Description</h3>

<p>Quickly scan a matrix from a file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mscan(fname, nc = 0, header = FALSE, burn = 0, thin = 0, nlines = 0L,
        sep = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mscan_+3A_fname">fname</code></td>
<td>
<p>The name of the file from which to scan the data.</p>
</td></tr>
<tr><td><code id="mscan_+3A_nc">nc</code></td>
<td>
<p>The number of columns in the matrix to be read.  If zero then the
number of columns will be determined by the number of columns in the
first line of the file.</p>
</td></tr>
<tr><td><code id="mscan_+3A_header">header</code></td>
<td>
<p>logical indicating whether the file contains a header row.</p>
</td></tr>
<tr><td><code id="mscan_+3A_burn">burn</code></td>
<td>
<p>An integer giving the number of initial lines of the matrix to discard.</p>
</td></tr>
<tr><td><code id="mscan_+3A_thin">thin</code></td>
<td>
<p>An integer.  If thin &gt; 1 then keep every thin\'th line.  This is
useful for reading in very large files of MCMC output, for example.</p>
</td></tr>
<tr><td><code id="mscan_+3A_nlines">nlines</code></td>
<td>
<p>If positive, the number of data lines to scan from the data file
(e.g. for an MCMC algorithm that is only partway done).  Otherwise the
entire file will be read.</p>
</td></tr>
<tr><td><code id="mscan_+3A_sep">sep</code></td>
<td>
<p> Field separator in the data file.</p>
</td></tr>
<tr><td><code id="mscan_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to 'scan'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="utils.html#topic+read.table">read.table</a></code>, but scanning a
matrix of homogeneous data is much faster because there is much less
format deduction.
</p>


<h3>Value</h3>

<p>The matrix stored in the data file.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filename &lt;- file.path(tempdir(), "example.data")
cat("foo bar baz", "1 2 3", "4 5 6", file = filename, sep = "\n")
m &lt;- mscan(filename, header = TRUE)
m
##      foo bar baz
## [1,]   1   2   3
## [2,]   4   5   6
</code></pre>

<hr>
<h2 id='mvn.diagonal.prior'>diagonal MVN prior</h2><span id='topic+MvnDiagonalPrior'></span>

<h3>Description</h3>

<p>A multivariate normal prior distribution formed by the
product of independent normal margins.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MvnDiagonalPrior(mean.vector, sd.vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.diagonal.prior_+3A_mean.vector">mean.vector</code></td>
<td>
<p>A vector giving the mean of the prior distribution.</p>
</td></tr>
<tr><td><code id="mvn.diagonal.prior_+3A_sd.vector">sd.vector</code></td>
<td>
<p>The standard deviations of the components in the
distribution.  I.e. the square root of the diagonal of the variance
matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='mvn.independent.sigma.prior'>Independence prior for the MVN</h2><span id='topic+MvnIndependentSigmaPrior'></span>

<h3>Description</h3>

<p> A prior for the parameters of the multivariate normal
distribution that assumes Sigma to be a diagonal matrix with elements
modeled by independent inverse Gamma priors.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>MvnIndependentSigmaPrior(mvn.prior, sd.prior.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.independent.sigma.prior_+3A_mvn.prior">mvn.prior</code></td>
<td>
<p>An object of class <code><a href="#topic+MvnPrior">MvnPrior</a></code> that is the
prior distribution for the multivariate normal mean parameter.</p>
</td></tr>
<tr><td><code id="mvn.independent.sigma.prior_+3A_sd.prior.list">sd.prior.list</code></td>
<td>
<p>A list of <code><a href="#topic+SdPrior">SdPrior</a></code> objects modeling
the diagonal elements of the multivariate normal variance matrix.  The
off-diagonal elements are assumed to be zero.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='mvn.prior'>Multivariate normal prior</h2><span id='topic+MvnPrior'></span>

<h3>Description</h3>

<p>A multivariate normal prior distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MvnPrior(mean, variance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.prior_+3A_mean">mean</code></td>
<td>
<p>A vector giving the mean of the prior distribution.</p>
</td></tr>
<tr><td><code id="mvn.prior_+3A_variance">variance</code></td>
<td>
<p>A symmetric positive definite matrix giving the
variance of the prior distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='MvnGivenSigmaMatrixPrior'>Conditional Multivaraite Normal Prior Given Variance</h2><span id='topic+MvnGivenSigmaMatrixPrior'></span>

<h3>Description</h3>

<p>A multivaraite normal prior distribution, typically used as
the prior distribution for the mean of multivaraite normal data.  The
variance of this distribution is proportional to another parameter
&quot;Sigma&quot; that exists elsewhere.  Usually &quot;Sigma&quot; is the variance of the
data.
</p>
<p>This distribution is the &quot;normal&quot; part of a &quot;normal-inverse Wishart&quot;
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MvnGivenSigmaMatrixPrior(mean, sample.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MvnGivenSigmaMatrixPrior_+3A_mean">mean</code></td>
<td>
<p>A vector giving the mean of the prior distribution.</p>
</td></tr>
<tr><td><code id="MvnGivenSigmaMatrixPrior_+3A_sample.size">sample.size</code></td>
<td>
<p>A positive scalar.  The variance of the
distribution is <code>Sigma / sample.size</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='normal.inverse.gamma.prior'>Normal inverse gamma prior</h2><span id='topic+NormalInverseGammaPrior'></span>

<h3>Description</h3>

<p>The NormalInverseGammaPrior is the conjugate prior for the
mean and variance of the scalar normal distribution.  The model says
that
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sigma^2} \sim Gamma(df / 2, ss/2)  \mu|\sigma \sim
  N(\mu_0, \sigma^2/\kappa)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>NormalInverseGammaPrior(mu.guess, mu.guess.weight = .01,
       sigma.guess, sigma.guess.weight = 1, ...)

</code></pre>


<h3>Arguments</h3>

 <table>
<tr><td><code id="normal.inverse.gamma.prior_+3A_mu.guess">mu.guess</code></td>
<td>
<p>The mean of the prior distribution.  This is
<code class="reqn">\mu_0</code> in the description above.</p>
</td></tr>
<tr><td><code id="normal.inverse.gamma.prior_+3A_mu.guess.weight">mu.guess.weight</code></td>
<td>
<p>The number of observations worth of weight
assigned to <code>mu.guess</code>.  This is <code class="reqn">\kappa</code> in the
description above.</p>
</td></tr>
<tr><td><code id="normal.inverse.gamma.prior_+3A_sigma.guess">sigma.guess</code></td>
<td>
<p>A prior estimate at the value of <code>sigma</code>.
This is <code class="reqn">\sqrt{ss/df}</code>.</p>
</td></tr>
<tr><td><code id="normal.inverse.gamma.prior_+3A_sigma.guess.weight">sigma.guess.weight</code></td>
<td>
<p>The number of observations worth of weight
assigned to <code>sigma.guess</code>.  This is <code class="reqn">df</code>.</p>
</td></tr>
<tr><td><code id="normal.inverse.gamma.prior_+3A_...">...</code></td>
<td>
<p>blah</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='normal.inverse.wishart.prior'>Normal inverse Wishart prior</h2><span id='topic+NormalInverseWishartPrior'></span>

<h3>Description</h3>

<p>The NormalInverseWishartPrior is the conjugate prior for the
mean and variance of the multivariate normal distribution.  The model says
that
</p>
<p style="text-align: center;"><code class="reqn">\Sigma^{-1} \sim Wishart(\nu, S)  \mu|\sigma \sim N(\mu_0, \Sigma/\kappa)</code>
</p>

<p>The <code class="reqn">Wishart(S, \nu)</code> distribution is parameterized by <code>S</code>,
the <em>inverse</em> of the sum of squares matrix, and the scalar
degrees of freedom parameter <code>nu</code>.
</p>
<p>The distribution is improper if <code class="reqn">\nu &lt; dim(S)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalInverseWishartPrior(mean.guess,
                          mean.guess.weight = .01,
                          variance.guess,
                          variance.guess.weight = nrow(variance.guess) + 1)
</code></pre>


<h3>Arguments</h3>

 <table>
<tr><td><code id="normal.inverse.wishart.prior_+3A_mean.guess">mean.guess</code></td>
<td>
<p>The mean of the prior distribution.  This is
<code class="reqn">\mu_0</code> in the description above.</p>
</td></tr>
<tr><td><code id="normal.inverse.wishart.prior_+3A_mean.guess.weight">mean.guess.weight</code></td>
<td>
<p>The number of observations worth of weight
assigned to <code>mean.guess</code>.  This is <code class="reqn">\kappa</code> in the
description above.</p>
</td></tr>
<tr><td><code id="normal.inverse.wishart.prior_+3A_variance.guess">variance.guess</code></td>
<td>
<p>A prior estimate at the value of <code class="reqn">\Sigma</code>.
This is <code class="reqn">S^{-1}/\nu</code> in the notation above.</p>
</td></tr>
<tr><td><code id="normal.inverse.wishart.prior_+3A_variance.guess.weight">variance.guess.weight</code></td>
<td>
<p>The number of observations worth of weight
assigned to <code>variance.guess</code>.  This is <code class="reqn">df</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='normal.prior'>Normal (scalar Gaussian) prior distribution</h2><span id='topic+NormalPrior'></span>

<h3>Description</h3>

<p>Specifies a scalar Gaussian prior distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalPrior(mu, sigma, initial.value = mu, fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal.prior_+3A_mu">mu</code></td>
<td>
<p>The mean of the prior distribution.</p>
</td></tr>
<tr><td><code id="normal.prior_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the prior distribution.</p>
</td></tr>
<tr><td><code id="normal.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value of the parameter being modeled
in the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="normal.prior_+3A_fixed">fixed</code></td>
<td>
<p>Should the deviate modeled by this distribution be fixed
at its initial value?  (Used for debugging in some code.  Not
universally respected.)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='pairs.density'>
Pairs plot for posterior distributions.
</h2><span id='topic+PairsDensity'></span>

<h3>Description</h3>

<p>A pairs plot showing the posterior distribution of the given list of
Monte Carlo draws.  Plots above the diagonal show the posterior
distribution on a scale just wide enough to fit the plots.  The
diagonal shows a marginal density plot, and the subdiagonal shows the
distribution with all plots on a common scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairsDensity(draws,
             nlevels = 20,
             lty = NULL,
             color = NULL,
             subset = NULL,
             labels,
             legend.location = "top",
             legend.cex = 1,
             label.cex = 1,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.density_+3A_draws">draws</code></td>
<td>
<p>Either a matrix or a list of matrices.  If a list is
provided then each list element is plotted as a separate set of
contours, and all matrices must have the same number of columns
(though the number of rows can differ).</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of contour levels to plot.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_lty">lty</code></td>
<td>
<p>The line types to use for the different elements in
<code>draws</code>.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_color">color</code></td>
<td>
<p>The color to use for different elements in <code>draws</code>.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_subset">subset</code></td>
<td>
<p>If draws is a list, then this can be a numerical vector.
If draws has names, then subset can be a character vector naming
which elements to include.  If <code>NULL</code> then all elements of
<code>draws</code> are plotted.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_labels">labels</code></td>
<td>
<p>If <code>labels</code> is missing and the first element of
draws has non-<code>NULL</code> <code>colnames</code> then these will be used to
label the pairs plot.  If a character vector of length
<code>ncol(draws[[1]])</code> then this character vector will be used in
place of the colnames.  If <code>NULL</code> then no labels will be used.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_legend.location">legend.location</code></td>
<td>
<p>Either <code>"top"</code>, or <code>"right"</code>
specifying the location for the legend, or <code>NULL</code>, indicating
that no legend is desired.  if draws is a matrix or a singleton list
then no legend is produced.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_legend.cex">legend.cex</code></td>
<td>
<p>Scale factor to use for the legend labels.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_label.cex">label.cex</code></td>
<td>
<p>Scale factor to use for the row and column labels.</p>
</td></tr>
<tr><td><code id="pairs.density_+3A_...">...</code></td>
<td>
<p>Extra arguments (graphical parameters), passed to
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+PlotDensityContours">PlotDensityContours</a></code>,
<code><a href="graphics.html#topic+axis">axis</a></code>, and <code><a href="#topic+AddExternalLegend">AddExternalLegend</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="#topic+CompareDensities">CompareDensities</a></code>, <code><a href="#topic+CompareManyDensities">CompareManyDensities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## You can see the pairs plot for a single set of draws.
y &lt;- matrix(rnorm(5000, mean = 1:5), ncol = 5, byrow = TRUE)
PairsDensity(y)

## You can also compare two or more sets of draws.
z &lt;- matrix(rnorm(2500, mean = 2:6), ncol = 5, byrow = TRUE)
PairsDensity(list("first set" = y, "second set" = z))

</code></pre>

<hr>
<h2 id='plot.density.contours'>
Contour plot of a bivariate density.
</h2><span id='topic+PlotDensityContours'></span>

<h3>Description</h3>

<p>Contour plot of one ore more bivariate densities.  This function was
originally created to implement PairsDensity, but might be useful on
its own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDensityContours(draws,
                    x.index = 1,
                    y.index = 2,
                    xlim = NULL,
                    ylim = NULL,
                    nlevels = 20,
                    subset = NULL,
                    color = NULL,
                    lty = NULL,
                    axes = TRUE,
                    ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.density.contours_+3A_draws">draws</code></td>
<td>
<p>Either a matrix or a list of matrices.  If a list is
provided then each list element is plotted as a separate set of
contours, and all matrices must have the same number of columns
(though the number of rows can differ).</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_x.index">x.index</code></td>
<td>
<p>The index of the parameter to plot on the
horizonal axis.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_y.index">y.index</code></td>
<td>
<p>The index of the beta coefficient to plot on the
vertical axis.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_xlim">xlim</code></td>
<td>
<p>Limits on the horizontal axis.  If NULL then the plot is
just wide enough to fit the contours.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_ylim">ylim</code></td>
<td>
<p>Limits on the vertical axis.  If NULL then the plot is
just tall enough to fit the contours.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of contour levels to plot.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_subset">subset</code></td>
<td>
<p>If draws is a list, then this can be a numerical vector.
If draws has names, then subset can be a character vector naming
which elements to include.  If <code>NULL</code> then all elements of
<code>draws</code> are plotted.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_color">color</code></td>
<td>
<p>The color to use for different elemetns in <code>draws</code>.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_lty">lty</code></td>
<td>
<p>The line types to use for the different elements in
<code>draws</code>.</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_axes">axes</code></td>
<td>
<p>Logical. Should x and y axies be drawn?</p>
</td></tr>
<tr><td><code id="plot.density.contours_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="MASS.html#topic+kde2d">kde2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## You can see the pairs plot for a single set of draws.
y &lt;- matrix(rnorm(5000, mean = 1:5), ncol = 5, byrow = TRUE)
PlotDensityContours(y, 3, 1)

## You can also compare two or more sets of draws.
z &lt;- matrix(rnorm(2500, mean = 2:6), ncol = 5, byrow = TRUE)
PlotDensityContours(list("first set" = y, "second set" = z), 3, 1)
</code></pre>

<hr>
<h2 id='plot.dynamic.distribution'>
Plots the pointwise evolution of a distribution over an index set.
</h2><span id='topic+PlotDynamicDistribution'></span>

<h3>Description</h3>

<p> Produces an dynamic distribution plot where gray scale
shading is used to show the evolution of a distribution over an index
set.  This function is particularly useful when the index set is too
large to do side-by-side boxplots.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDynamicDistribution(curves,
                        timestamps = NULL,
                        quantile.step=.01,
                        xlim = NULL,
                        xlab = "Time",
                        ylim = range(curves, na.rm = TRUE),
                        ylab = "distribution",
                        add = FALSE,
                        axes = TRUE,
                        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dynamic.distribution_+3A_curves">curves</code></td>
<td>
<p> A matrix where each row represents a curve (e.g. a
simulation of a time series from a posterior distribution) and
columns represent different points in the index set.  For example, a
long time series would be a wide matrix.  </p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_timestamps">timestamps</code></td>
<td>
<p> An optional vector of &quot;time stamps&quot; that
<code>curves</code> will be plotted against.  The length of
<code>timestamps</code> must match the number of columns in <code>curves</code>.
If <code>timestamps</code> is <code>NULL</code> then the function attempts to
extract time stamps from the <code>colnames(curves)</code>.  If no
appropriate time stamps can be found then the positive integers will
be used as time stamps.</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_quantile.step">quantile.step</code></td>
<td>
<p>Each color step in the plot corresponds to this
difference in quantiles.  Smaller values make prettier plots, but
the plots take longer to produce.</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_xlim">xlim</code></td>
<td>
<p>The x limits (x1, x2) of the plot.  Note that <code> x1 &gt;
    x2 </code> is allowed and leads to a &quot;reversed axis&quot;.</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horzontal axis. </p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_ylim">ylim</code></td>
<td>
<p>The y limits (y1, y2) of the plot.  Note that <code> y1 &gt;
    y2 </code> is allowed and leads to a &quot;reversed axis&quot;.</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis. </p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_add">add</code></td>
<td>
<p>Logical.  If true then add the plot to the current plot.
Otherwise a fresh plot will be created.</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_axes">axes</code></td>
<td>
<p>Logical.  Should axes be added to the plot?</p>
</td></tr>
<tr><td><code id="plot.dynamic.distribution_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to <code><a href="graphics.html#topic+plot">plot</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function works by passing many calls to
<code><a href="graphics.html#topic+polygon">polygon</a></code>.  Each polygon is associated with a quantile
level, with darker shading near the median. </p>


<h3>Value</h3>

<p> This function is called for its side effect, which is to produce
a plot on the current graphics device.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- t(matrix(rnorm(1000 * 100, 1:100, 1:100), nrow=100))
  ## x has 1000 rows, and 100 columns.  Column i is N(i, i^2) noise.

  PlotDynamicDistribution(x)
  time &lt;- as.Date("2010-01-01", format = "%Y-%m-%d") + (0:99 - 50)*7
  PlotDynamicDistribution(x, time)
</code></pre>

<hr>
<h2 id='plot.macf'>
Plots individual autocorrelation functions for many-valued time series
</h2><span id='topic+plot.macf'></span><span id='topic+PlotMacf'></span>

<h3>Description</h3>

<p>Produces individual autocorrelation functions for many-valued time
series such as those produced by highly multivariate MCMC output.
Cross-correlations such as those produced by <code><a href="stats.html#topic+acf">acf</a></code> are not shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMacf(x, lag.max = 40, gap = 0.5, main = NULL, boxes = TRUE,
         xlab = "lag", ylab = "ACF", type = "h")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.macf_+3A_x">x</code></td>
<td>

<p>matrix or 3-way array of MCMC output (or other time series).  The
first dimension represents discrete time.
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_lag.max">lag.max</code></td>
<td>

<p>maximum lag to use when computing ACF's.
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_gap">gap</code></td>
<td>

<p>non-negative scalar. gap between plots
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_main">main</code></td>
<td>

<p>character.  main title for the plot
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_boxes">boxes</code></td>
<td>

<p>logical.  Should boxes be drawn around the plots
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_xlab">xlab</code></td>
<td>

<p>character label for horizontal axis.
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_ylab">ylab</code></td>
<td>

<p>character label for vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.macf_+3A_type">type</code></td>
<td>

<p>type of line plot to show.  Defaults to &quot;h&quot;.  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> for other options.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effect
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>,
<code><a href="#topic+plot.many.ts">plot.many.ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(1000), ncol=10)
PlotMacf(x)
</code></pre>

<hr>
<h2 id='plot.many.ts'>
Multiple time series plots
</h2><span id='topic+plot.many.ts'></span><span id='topic+PlotManyTs'></span>

<h3>Description</h3>

<p>Plots many time series plots on the same graphical device.  Each plot
gets its own frame.  Scales can be adjusted to see variation in each
plot (each plot gets its own scale), or variation between plots
(common scale).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotManyTs(x, type = "l", gap = 0, boxes = TRUE, truth = NULL,
           thin = 1, labs, same.scale = TRUE, ylim = NULL,
           refline = NULL, color = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.many.ts_+3A_x">x</code></td>
<td>
<p>Matrix, data frame, list, or 3-dimensional array to be plotted. </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_type">type</code></td>
<td>
<p> type of line plots to produce.  See
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> for other options.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_gap">gap</code></td>
<td>
<p>Number of lines of space to put between plots.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_boxes">boxes</code></td>
<td>
<p>Logical indicating whether boxes should be drawn around
each plot.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_truth">truth</code></td>
<td>
<p>A vector or matrix of reference values to be added to
each plot as a horizontal line.  The dimension should match
<code>dim(x)[-1]</code> </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_thin">thin</code></td>
<td>
<p>Frequency of observations to plot.  E.g. <code>thin=10</code>
means plot every 10'th observation.  Thinning can speed things up
when plotting large amounts MCMC output.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_labs">labs</code></td>
<td>
<p>Optional character vector giving the title (e.g. variable
name) for each plot.  If <code>labs</code> is missing then column names or
dimnames will be used to label the plots.  If <code>labs</code> is
<code>NULL</code> then no labels will be used. </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical indicating whether plots should be drawn
with a common vertical axis, which is displayed on alternating rows
of the plot.  If <code>FALSE</code> then the vertical axis of each plot is
scaled to the range of data in that plot, but no tick marks are
displayed. </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_ylim">ylim</code></td>
<td>
<p>Scale of the vertical axis.  If non-NULL then same.scale
is set to <code>TRUE</code> and the supplied scale is used for all plots.
</p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_refline">refline</code></td>
<td>
<p> a vector or scalar value to use as a reference line.
This is a supplement to the <code>truth</code> argument.  It can be useful
when comparing true values (used in a simulation), estimated values
(e.g. point estimates of parameters) and MCMC output.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_color">color</code></td>
<td>
<p> Vector of colors to use in the plots.  </p>
</td></tr>
<tr><td><code id="plot.many.ts_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> and
<code><a href="graphics.html#topic+axis">axis</a></code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code> (for plotting a small number of time series)
<code><a href="#topic+plot.macf">plot.macf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(1000), ncol = 10)
PlotManyTs(x)
PlotManyTs(x, same = FALSE)

</code></pre>

<hr>
<h2 id='regression.coefficient.conjugate.prior'>Regression Coefficient Conjugate Prior</h2><span id='topic+RegressionCoefficientConjugatePrior'></span>

<h3>Description</h3>

<p>A conjugate prior for regression coefficients, conditional
on residual variance, and sample size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RegressionCoefficientConjugatePrior(
    mean,
    sample.size,
    additional.prior.precision = numeric(0),
    diagonal.weight = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression.coefficient.conjugate.prior_+3A_mean">mean</code></td>
<td>
<p>The mean of the prior distribution, denoted 'b' below.
See Details.</p>
</td></tr>
<tr><td><code id="regression.coefficient.conjugate.prior_+3A_sample.size">sample.size</code></td>
<td>
<p> The value denoted <code class="reqn">\kappa</code> below.
This can be interpreted as a number of observations worth of weight
to be assigned to <code>mean</code> in the posterior distribution. </p>
</td></tr>
<tr><td><code id="regression.coefficient.conjugate.prior_+3A_additional.prior.precision">additional.prior.precision</code></td>
<td>
<p> A vector of non-negative numbers
representing the diagonal matrix <code class="reqn">\Lambda^{-1}</code>
below.  Positive values for <code>additional.prior.precision</code> will
ensure the distribution is proper even if the regression model has
no data.  If all columns of the design matrix have positive variance
then <code>additional.prior.precision</code> can safely be set to zero.  A
zero-length numeric vector is a slightly more efficient equivalent
to a vector of all zeros.</p>
</td></tr>
<tr><td><code id="regression.coefficient.conjugate.prior_+3A_diagonal.weight">diagonal.weight</code></td>
<td>
<p>The weight given to the diagonal when XTX is
averaged with its diagonal.  The purpose of <code>diagonal.weight</code>
is to keep the prior distribution proper even if X is less than full
rank.  If the design matrix is full rank then <code>diagonal.weight</code>
can be set to zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A conditional prior for the coefficients (beta) in a linear regression
model.  The prior is conditional on the residual variance
<code class="reqn">\sigma^2</code>, the sample size n, and the design matrix X.
The prior is
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sigma^2, X \sim %
    N(b, \sigma^2 (\Lambda^{-1} + V</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">V^{-1} = \frac{\kappa}{n} ((1 - w) X^TX + w diag(X^TX)) .</code>
</p>

<p>The prior distribution also depends on the cross product matrix
XTX and the sample size n, which are not arguments to this
function.  It is expected that the underlying C++ code will get
those quantities elsewhere (presumably from the regression
modeled by this prior).
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='replist'>
Repeated Lists of Objects
</h2><span id='topic+RepList'></span>

<h3>Description</h3>

<p>Produces repeated copies of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RepList(object, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replist_+3A_object">object</code></td>
<td>
<p> The object to be replicated. </p>
</td></tr>
<tr><td><code id="replist_+3A_times">times</code></td>
<td>
<p>The desired number of replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing <code>times</code> copies of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  alist &lt;- list(x = "foo", y = 12, z = c(1:3))
  three.copies &lt;- RepList(alist, 3)
</code></pre>

<hr>
<h2 id='rmvn'>Multivariate Normal Simulation</h2><span id='topic+rmvn'></span>

<h3>Description</h3>

<p>Simulate draws from the multivariate normal distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvn(n = 1, mu, sigma = diag(rep(1., length(mu))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvn_+3A_n">n</code></td>
<td>
<p>The desired number of draws.</p>
</td></tr>
<tr><td><code id="rmvn_+3A_mu">mu</code></td>
<td>
<p>The mean of the distribution.  A vector.</p>
</td></tr>
<tr><td><code id="rmvn_+3A_sigma">sigma</code></td>
<td>
<p>The variance matrix of the distribution.  A matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>mu</code> and <code>sigma</code> are the same for all <code>n</code>
draws.  This function cannot handle separate parameters for each draw
the way <code><a href="stats.html#topic+rnorm">rnorm</a></code> and similar functions for scalar random
variables can.
</p>


<h3>Value</h3>

<p> If <code>n == 1</code> the return value is a vector.  Otherwise it is
a matrix with <code>n</code> rows and <code>length(mu)</code> columns.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- rnorm(1, 1:3)
## y1 is a vector
y2 &lt;- rnorm(10, 1:3)
## y2 is a matrix
</code></pre>

<hr>
<h2 id='rvectorfunction'>RVectorFunction</h2><span id='topic+RVectorFunction'></span>

<h3>Description</h3>

<p>A wrapper for passing R functions to C++ code.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RVectorFunction(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvectorfunction_+3A_f">f</code></td>
<td>
<p>A scalar-valued function of a vector-valued argument.  The
function can depend on other arguments as long as the vector valued
argument appears in the first position.  </p>
</td></tr>
<tr><td><code id="rvectorfunction_+3A_...">...</code></td>
<td>
<p>Optional, named, extra arguments to be passed to f.
These arguments are fixed at the time this object is created.
For the purpose of evaluating f, these arguments do not update.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The Boom library can handle the output of this function as a
C++ function object.  Note that evaluating R functions in C is no
faster than evaluating them in R, but a wrapper like this is useful
for interacting with C and C++ libraries that expect to operate on C
and C++ functions.  </p>


<h3>Value</h3>

<p>A list containing the information needed to evaluate the function f in
C++ code.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='scaled.matrix.normal.prior'>Scaled Matrix-Normal Prior</h2><span id='topic+ScaledMatrixNormalPrior'></span>

<h3>Description</h3>

<p> A matrix-normal prior distribution, intended as the
conjugate prior for the regression coefficients in a multivariate
linear regression.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaledMatrixNormalPrior(mean, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaled.matrix.normal.prior_+3A_mean">mean</code></td>
<td>
<p>A matrix giving the mean of the distributions</p>
</td></tr>
<tr><td><code id="scaled.matrix.normal.prior_+3A_nu">nu</code></td>
<td>
<p>A scale factor affecting the variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix normal distribution is a 3-parameter distribution MN(mu,
Omega, V), where mu is the mean.  A deviate from the distribution is a
matrix B, where Cov(B[i, j], B[k, m]) = Omega[i, k] * Sigma[j, m].  If
b = Vec(B) is the vector obtained by stacking columns of B, then b is
multivariate normal with mean Vec(mu) and covariance matrix
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \otimes Omega</code>
</p>
<p> (the kronecker
product).
</p>
<p>This prior distribution assumes the underlying C++ code knows where to
find the predictor (X) matrix in the regression, and the residual
variance matrix Sigma.  The assumed prior distribution is
B ~ MN(mu, X'X / nu, Sigma).
</p>
<p>Like most other priors in Boom, this function merely encodes
information expected by the underlying C++ code, ensuring correct
names and formatting.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='sd.prior'>Prior for a standard deviation or variance</h2><span id='topic+SdPrior'></span>

<h3>Description</h3>

<p>Specifies an inverse Gamma prior for a variance parameter,
but inputs are defined in terms of a standard deviation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SdPrior(sigma.guess, sample.size = .01, initial.value = sigma.guess,
          fixed = FALSE, upper.limit = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.prior_+3A_sigma.guess">sigma.guess</code></td>
<td>
<p>A prior guess at the value of the standard deviation.</p>
</td></tr>
<tr><td><code id="sd.prior_+3A_sample.size">sample.size</code></td>
<td>
<p>The weight given to <code>sigma.guess</code>.
Interpretable as a prior observation count.</p>
</td></tr>
<tr><td><code id="sd.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value of the paramter in the MCMC
algorithm.</p>
</td></tr>
<tr><td><code id="sd.prior_+3A_fixed">fixed</code></td>
<td>
<p>Logical.  Some algorithms allow you to fix sigma at a
particular value.  If <code>TRUE</code> then sigma will remain fixed at
<code>initial.value</code>, if supported.</p>
</td></tr>
<tr><td><code id="sd.prior_+3A_upper.limit">upper.limit</code></td>
<td>
<p>If positive, this is the upper limit on possible
values of the standard deviation parameter.  Otherwise the upper
limit is assumed infinite.  Not supported by all MCMC algorithms.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='sufstat.Rd'>Sufficient Statistics</h2><span id='topic+RegressionSuf'></span><span id='topic+GaussianSuf'></span>

<h3>Description</h3>

<p>Sufficient statistics for various models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RegressionSuf(X = NULL,
                y = NULL,
                xtx = crossprod(X),
                xty = crossprod(X, y),
                yty = sum(y^2),
                n = length(y),
                xbar = colMeans(X),
                ybar = mean(y))

  GaussianSuf(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sufstat.Rd_+3A_x">X</code></td>
<td>
<p>The predictor matrix for a regression problem.</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_y">y</code></td>
<td>
<p>The data, or the regression response variable.</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_xtx">xtx</code></td>
<td>
<p>The cross product of the design matrix. &quot;X transpose X.&quot;</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_xty">xty</code></td>
<td>
<p>The cross product of the design matrix with the response
vector. &quot;X transpose y.&quot;</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_yty">yty</code></td>
<td>
<p>The sum of the squares of the response vector.
&quot;y transpose y.&quot;</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_n">n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_xbar">xbar</code></td>
<td>
<p>A vector giving the average of each column in the
predictor matrix.</p>
</td></tr>
<tr><td><code id="sufstat.Rd_+3A_ybar">ybar</code></td>
<td>
<p>The (scalar) mean of the response variable y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The returned value is a function containing the sufficient
statistics for a regression model.  Arguments are checked to ensure
they have legal values.  List names match the names expected by
underlying C++ code.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  X &lt;- cbind(1, matrix(rnorm(3 * 100), ncol = 3))
  y &lt;- rnorm(100)

  ## Sufficient statistics can be computed from raw data, if it is
  ## available.
  suf1 &lt;- RegressionSuf(X, y)

  ## The individual components can also be computed elsewhere, and
  ## provided as arguments.  If n is very large, this can be a
  ## substantial coomputational savings.
  suf2 &lt;- RegressionSuf(xtx = crossprod(X),
                        xty = crossprod(X, y),
                        yty = sum(y^2),
                        n = 100,
                        xbar = colMeans(X))

</code></pre>

<hr>
<h2 id='suggest.burn.log.likelihood'>Suggest MCMC Burn-in from Log Likelihood</h2><span id='topic+SuggestBurnLogLikelihood'></span>

<h3>Description</h3>

<p> Suggests a burn-in period for an MCMC chain based on the
log likelihood values simulated in the final few iterations of the
chain.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  SuggestBurnLogLikelihood(log.likelihood, fraction = .10, quantile = .9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggest.burn.log.likelihood_+3A_log.likelihood">log.likelihood</code></td>
<td>
<p>A numeric vector giving the log likelihood
values for each MCMC iteration.</p>
</td></tr>
<tr><td><code id="suggest.burn.log.likelihood_+3A_fraction">fraction</code></td>
<td>
<p>The fraction of the chain that should be used to
determine the log likelihood lower bound.  The default setting looks
in the final 25% of the MCMC run.  Must be an number less than 1.
If <code>fraction &lt;= 0</code> then a 0 burn-in is returned.</p>
</td></tr>
<tr><td><code id="suggest.burn.log.likelihood_+3A_quantile">quantile</code></td>
<td>
<p>The quantile of the values in the final fraction that
must be exceeded before the burn-in period is declared over.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Looks at the last <code>fraction</code> of the <code>log.likelihood</code>
sequence and finds a specified quantile to use as a threshold.
Returns the first iteration where <code>log.likelihood</code> exceeds this
threshold.  </p>


<h3>Value</h3>

<p>Returns a suggested number of iterations to discard.  This can be
0 if <code>fraction == 0</code>, which is viewed as a signal that no burn-in
is desired.</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='thin'>
Thin the rows of a matrix
</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p>Systematic sampling of every <code>thin</code>'th row of a matrix or vector.
Useful for culling MCMC output or denoising a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(x, thin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_+3A_x">x</code></td>
<td>

<p>The array to be thinned.  The first dimension is the one sampled over.
</p>
</td></tr>
<tr><td><code id="thin_+3A_thin">thin</code></td>
<td>

<p>The frequency of observations to keep.  With <code>thin=10</code> you will
keep every 10th observation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The thinned vector, matrix, or array is returned.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100)
thin(x, 10)
# returns a 10 vector

y &lt;- matrix(rnorm(200), ncol=2)
thin(y, 10)
# returns a 10 by 2 matrix

</code></pre>

<hr>
<h2 id='thin.matrix'>Thin a Matrix</h2><span id='topic+ThinMatrix'></span>

<h3>Description</h3>

<p>Return discard all but every k'th row of a matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThinMatrix(mat, thin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin.matrix_+3A_mat">mat</code></td>
<td>
<p>The matrix to be thinned.</p>
</td></tr>
<tr><td><code id="thin.matrix_+3A_thin">thin</code></td>
<td>
<p>The distance between kepts lines from mat.  The larger the number
the fewer lines are kept.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bigger the value of <code>thin</code> the more thinning that gets done.
For example, <code>thin = 10</code> will keep every 10 lines from <code>mat</code>.
</p>


<h3>Value</h3>

<p>The matrix mat, after discarding all but every <code>thin</code> lines.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:100, ncol = 2)
ThinMatrix(m, thin = 10)
##      [,1] [,2]
## [1,]   10   60
## [2,]   20   70
## [3,]   30   80
## [4,]   40   90
## [5,]   50  100
</code></pre>

<hr>
<h2 id='TimeSeriesBoxplot'>
Time Series Boxplots
</h2><span id='topic+TimeSeriesBoxplot'></span>

<h3>Description</h3>

<p>Creates a series of boxplots showing the evolution of a distribution
over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  TimeSeriesBoxplot(x, time, ylim = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeSeriesBoxplot_+3A_x">x</code></td>
<td>
<p> A matrix where each row represents a curve (e.g. a
simulation of a time series from a posterior distribution) and
columns represent time.  A long time series would be a wide matrix. </p>
</td></tr>
<tr><td><code id="TimeSeriesBoxplot_+3A_time">time</code></td>
<td>
<p>A vector of class <code><a href="base.html#topic+Date">Date</a></code> with lenght matching
the number of columns in <code>x</code>.</p>
</td></tr>
<tr><td><code id="TimeSeriesBoxplot_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="TimeSeriesBoxplot_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code> then add boxplots to current plot.</p>
</td></tr>
<tr><td><code id="TimeSeriesBoxplot_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to <code><a href="graphics.html#topic+boxplot">boxplot</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Called for its side effect, which is to produce a plot on the
current graphics device.  </p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- t(matrix(rnorm(1000 * 100, 1:100, 1:100), nrow=100))
  ## x has 1000 rows, and 100 columns.  Column i is N(i, i^2) noise.
  time &lt;- as.Date("2010-01-01", format = "%Y-%m-%d") + (0:99 - 50)*7
  TimeSeriesBoxplot(x, time)
</code></pre>

<hr>
<h2 id='ToString'>Convert to Character String</h2><span id='topic+ToString'></span><span id='topic+ToString.default'></span><span id='topic+ToString.table'></span>

<h3>Description</h3>

<p>Convert an object to a character string, suitable for
including in error messages.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ToString(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ToString_+3A_object">object</code></td>
<td>
<p>An object to be printed to a string.</p>
</td></tr>
<tr><td><code id="ToString_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string (a character vector of length 1) containing the printed value
of the object.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- matrix(1:6, ncol = 2)
  printed.matrix &lt;- ToString(m)

  y &lt;- c(1, 2, 3, 3, 3, 3, 3, 3)
  tab &lt;- table(y)
  printed.table &lt;- ToString(tab)
</code></pre>

<hr>
<h2 id='traceproduct'>Trace of the Product of Two Matrices</h2><span id='topic+TraceProduct'></span>

<h3>Description</h3>

<p>Returns the trace of the product of two matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TraceProduct(A, B, b.is.symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceproduct_+3A_a">A</code></td>
<td>
<p>The first matrix in the product.</p>
</td></tr>
<tr><td><code id="traceproduct_+3A_b">B</code></td>
<td>
<p>The second matrix in the product.</p>
</td></tr>
<tr><td><code id="traceproduct_+3A_b.is.symmetric">b.is.symmetric</code></td>
<td>
<p>Logical.  A <code>TRUE</code> value indicates that
<code>B</code> is a symmetric matrix.  A slight computational savings is
possible if <code>B</code> is symmetric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a number equivalent to <code>sum(diag(A %*% B))</code>.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

<hr>
<h2 id='uniform.prior'>Uniform prior distribution </h2><span id='topic+UniformPrior'></span>

<h3>Description</h3>

<p>Specifies a uniform prior distribution on a real-valued
scalar parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  UniformPrior(lo = 0, hi = 1, initial.value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform.prior_+3A_lo">lo</code></td>
<td>
<p>The lower limit of support.</p>
</td></tr>
<tr><td><code id="uniform.prior_+3A_hi">hi</code></td>
<td>
<p>The upper limit of support.</p>
</td></tr>
<tr><td><code id="uniform.prior_+3A_initial.value">initial.value</code></td>
<td>
<p>The initial value of the parameter in question to
use in the MCMC algorithm.  If <code>NULL</code> then the mean <code>(lo +
      hi)/2</code> is used.</p>
</td></tr>  </table>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>


<h3>References</h3>

<p>Gelman, Carlin, Stern, Rubin (2003), &quot;Bayesian Data Analysis&quot;, Chapman
and Hall.
</p>

<hr>
<h2 id='wishart'>Wishart Distribution</h2><span id='topic+dWishart'></span><span id='topic+rWishart'></span>

<h3>Description</h3>

<p>Density and random generation for the Wishart distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWishart(W, Sigma, nu, logscale = FALSE)
rWishart(nu, scale.matrix, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wishart_+3A_w">W</code></td>
<td>
<p>Argument (random variable) for the Wishart density.  A
symmetric positive definite matrix.</p>
</td></tr>
<tr><td><code id="wishart_+3A_sigma">Sigma</code></td>
<td>
<p>Scale or &quot;variance&quot; parameter of the Wishart
distribution.  See the &quot;details&quot; section below.</p>
</td></tr>
<tr><td><code id="wishart_+3A_nu">nu</code></td>
<td>
<p>The &quot;degrees of freedom&quot; parameter of the Wishart
distribution.  The distribution is only defined for <code>nu &gt;=
      nrow(W) - 1</code>. </p>
</td></tr>
<tr><td><code id="wishart_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the density is returned
on the log scale.  Otherwise the density is returned on the density
scale.</p>
</td></tr>
<tr><td><code id="wishart_+3A_scale.matrix">scale.matrix</code></td>
<td>
<p>For the Wishart distribution the
<code>scale.matrix</code> parameter means the same thing as the
<code>Sigma</code> parameter in <code>dWishart</code>.  It is the variance
parameter of the generating multivariate normal distribution.
</p>
<p>If simulating from the inverse Wishart, <code>scale.matrix</code> is the
INVERSE of the &quot;sum of squares&quot; matrix portion of the multivariate
normal sufficient statistics.
</p>
</td></tr>
<tr><td><code id="wishart_+3A_inverse">inverse</code></td>
<td>
<p>Logical.  If TRUE then simulate from the inverse
Wishart distribution.  If FALSE then simulate from the Wishart
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nu</code> is an integer then a <code class="reqn">W(\Sigma, \nu)</code>
random variable can be thought of as the sum of <code>nu</code> outer
products: <code class="reqn">y_iy_i^T</code>, where <code class="reqn">y_i</code> is a zero-mean
multivariate normal with variance matrix <code>Sigma</code>.
</p>
<p>The Wishart distribution is
</p>
<p style="text-align: center;"><code class="reqn"> \frac{|W|^{\frac{\nu - p - 1}{2}} \exp(-tr(\Sigma^{-1}W) / 2)}{
      2^{\frac{\nu p}{2}}|\Sigma|^{\frac{\nu}{2}}\Gamma_p(\nu / 2)}%
  </code>
</p>

<p>where <code>p == nrow(W)</code> and <code class="reqn">\Gamma_p(\nu)</code> is the
multivariate gamma function (see <code><a href="#topic+lmgamma">lmgamma</a></code>).
</p>


<h3>Value</h3>

<p><code>dWishart</code> returns the density of the Wishart distribution.  It
is not vectorized, so only one random variable (matrix) can be
evaluated at a time.
</p>
<p><code>rWishart</code> returns one or more draws from the Wishart or inverse
Wishart distributions.  If <code>n &gt; 0</code> the result is a 3-way array.
Unlike the <code><a href="stats.html#topic+rWishart">rWishart</a></code> function from the stats
package, the first index corresponds to draws.  This is in keeping
with the convention of other models from the Boom package.
</p>


<h3>Author(s)</h3>

<p>Steven L. Scott <a href="mailto:steve.the.bayesian@gmail.com">steve.the.bayesian@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
