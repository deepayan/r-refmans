<!DOCTYPE html><html><head><title>Help for package zlib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zlib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compress'><p>Single-step compression of raw data</p></a></li>
<li><a href='#compress_chunk'><p>Compress a Chunk of Data</p></a></li>
<li><a href='#compressobj'><p>Create a Compression Object</p></a></li>
<li><a href='#create_compressor'><p>Create a new compressor object</p></a></li>
<li><a href='#create_decompressor'><p>Create a new decompressor object</p></a></li>
<li><a href='#decompress'><p>Single-step decompression of raw data</p></a></li>
<li><a href='#decompress_chunk'><p>Decompress a chunk of data</p></a></li>
<li><a href='#decompressobj'><p>Create a new decompressor object</p></a></li>
<li><a href='#flush_compressor_buffer'><p>Flush the internal buffer of the compressor object.</p></a></li>
<li><a href='#flush_decompressor_buffer'><p>Flush the internal buffer of the decompressor object.</p></a></li>
<li><a href='#publicEval'><p>Evaluate Expression with Public and Private Environments</p></a></li>
<li><a href='#validate_gzip_file'><p>Validate if a File is a Valid Gzip File</p></a></li>
<li><a href='#zlib'><p>zlib</p></a></li>
<li><a href='#zlib_constants'><p>Retrieve zlib Constants</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compression and Decompression</td>
</tr>
<tr>
<td>Author:</td>
<td>Semjon Geist [aut, cre]</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sgeist-ionos/R-zlib">https://github.com/sgeist-ionos/R-zlib</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sgeist-ionos/R-zlib/issues">https://github.com/sgeist-ionos/R-zlib/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>The 'zlib' package for R aims to offer an R-based equivalent of 'Python's' built-in 'zlib' module for data compression and decompression. This package provides a suite of functions for working with 'zlib' compression, including utilities for compressing and decompressing data streams, manipulating compressed files, and working with 'gzip', 'zlib', and 'deflate' formats.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 14:40:04 UTC; sgeist</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Semjon Geist &lt;mail@semjon-geist.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compress'>Single-step compression of raw data</h2><span id='topic+compress'></span>

<h3>Description</h3>

<p>Compresses the provided raw data in a single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress(
  data,
  level = -1,
  method = zlib$DEFLATED,
  wbits = zlib$MAX_WBITS,
  memLevel = zlib$DEF_MEM_LEVEL,
  strategy = zlib$Z_DEFAULT_STRATEGY,
  zdict = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_+3A_data">data</code></td>
<td>
<p>Raw data to be compressed.</p>
</td></tr>
<tr><td><code id="compress_+3A_level">level</code></td>
<td>
<p>Compression level, default is -1.</p>
</td></tr>
<tr><td><code id="compress_+3A_method">method</code></td>
<td>
<p>Compression method, default is <code>zlib$DEFLATED</code>.</p>
</td></tr>
<tr><td><code id="compress_+3A_wbits">wbits</code></td>
<td>
<p>Window bits, default is <code>zlib$MAX_WBITS</code>.</p>
</td></tr>
<tr><td><code id="compress_+3A_memlevel">memLevel</code></td>
<td>
<p>Memory level, default is <code>zlib$DEF_MEM_LEVEL</code>.</p>
</td></tr>
<tr><td><code id="compress_+3A_strategy">strategy</code></td>
<td>
<p>Compression strategy, default is <code>zlib$Z_DEFAULT_STRATEGY</code>.</p>
</td></tr>
<tr><td><code id="compress_+3A_zdict">zdict</code></td>
<td>
<p>Optional predefined compression dictionary as a raw vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>compress</code> function simplifies the compression process by encapsulating
the creation of a compression object, compressing the data, and flushing the buffer
all within a single call. This is particularly useful for scenarios where the user
wants to quickly compress data without dealing with the intricacies of compression
objects and buffer management. The function leverages the <code>compressobj</code> function
to handle the underlying compression mechanics.
</p>


<h3>Value</h3>

<p>A raw vector containing the compressed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compressed_data &lt;- compress(charToRaw("some data"))

</code></pre>

<hr>
<h2 id='compress_chunk'>Compress a Chunk of Data</h2><span id='topic+compress_chunk'></span>

<h3>Description</h3>

<p>Compresses a given chunk of raw binary data using a pre-existing compressor object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_chunk(compressorPtr, input_chunk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_chunk_+3A_compressorptr">compressorPtr</code></td>
<td>
<p>An external pointer to an existing compressor object.
This object is usually initialized by calling a different function like <code>create_compressor()</code>.</p>
</td></tr>
<tr><td><code id="compress_chunk_+3A_input_chunk">input_chunk</code></td>
<td>
<p>A raw vector containing the uncompressed data that needs to be compressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily designed for use with a compressor object created by <code>create_compressor()</code>.
It takes a chunk of raw data and compresses it, returning a raw vector of the compressed data.
</p>


<h3>Value</h3>

<p>A raw vector containing the compressed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new compressor object for zlib -&gt; wbts = 15
zlib_compressor &lt;- create_compressor(wbits=31)
compressed_data &lt;- compress_chunk(zlib_compressor, charToRaw("Hello, World"))
compressed_data &lt;- c(compressed_data, flush_compressor_buffer(zlib_compressor))
decompressed_data &lt;- memDecompress(compressed_data, type = "gzip")
cat(rawToChar(decompressed_data))
</code></pre>

<hr>
<h2 id='compressobj'>Create a Compression Object</h2><span id='topic+compressobj'></span>

<h3>Description</h3>

<p><code>compressobj</code> initializes a new compression object with specified parameters
and methods. The function makes use of <code>publicEval</code> to manage scope and encapsulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compressobj(
             level = -1,
             method = zlib$DEFLATED,
             wbits = zlib$MAX_WBITS,
             memLevel = zlib$DEF_MEM_LEVEL,
             strategy = zlib$Z_DEFAULT_STRATEGY,
             zdict = NULL
         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compressobj_+3A_level">level</code></td>
<td>
<p>Compression level, default is -1.</p>
</td></tr>
<tr><td><code id="compressobj_+3A_method">method</code></td>
<td>
<p>Compression method, default is <code>zlib$DEFLATED</code>.</p>
</td></tr>
<tr><td><code id="compressobj_+3A_wbits">wbits</code></td>
<td>
<p>Window bits, default is <code>zlib$MAX_WBITS</code>.</p>
</td></tr>
<tr><td><code id="compressobj_+3A_memlevel">memLevel</code></td>
<td>
<p>Memory level, default is <code>zlib$DEF_MEM_LEVEL</code>.</p>
</td></tr>
<tr><td><code id="compressobj_+3A_strategy">strategy</code></td>
<td>
<p>Compression strategy, default is <code>zlib$Z_DEFAULT_STRATEGY</code>.</p>
</td></tr>
<tr><td><code id="compressobj_+3A_zdict">zdict</code></td>
<td>
<p>Optional predefined compression dictionary as a raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an environment containing the public methods <code>compress</code> and <code>flush</code>.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>compress(data)</code>: Compresses a chunk of data.
</p>
</li>
<li> <p><code>flush()</code>: Flushes the compression buffer.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>compressor &lt;- compressobj(level = 6)
compressed_data &lt;- compressor$compress(charToRaw("some data"))
compressed_data &lt;- c(compressed_data, compressor$flush())

</code></pre>

<hr>
<h2 id='create_compressor'>Create a new compressor object</h2><span id='topic+create_compressor'></span>

<h3>Description</h3>

<p>Initialize a new compressor object for zlib-based compression with specified settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_compressor(
  level = -1L,
  method = 8L,
  wbits = 15L,
  memLevel = 8L,
  strategy = 0L,
  zdict = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_compressor_+3A_level">level</code></td>
<td>
<p>Compression level, integer between 0 and 9, or -1 for default.</p>
</td></tr>
<tr><td><code id="create_compressor_+3A_method">method</code></td>
<td>
<p>Compression method.</p>
</td></tr>
<tr><td><code id="create_compressor_+3A_wbits">wbits</code></td>
<td>
<p>Window size bits.</p>
</td></tr>
<tr><td><code id="create_compressor_+3A_memlevel">memLevel</code></td>
<td>
<p>Memory level for internal compression state.</p>
</td></tr>
<tr><td><code id="create_compressor_+3A_strategy">strategy</code></td>
<td>
<p>Compression strategy.</p>
</td></tr>
<tr><td><code id="create_compressor_+3A_zdict">zdict</code></td>
<td>
<p>Optional predefined compression dictionary as a raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SEXP pointer to the new compressor object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compressor &lt;- create_compressor(level = 6, memLevel = 8)
</code></pre>

<hr>
<h2 id='create_decompressor'>Create a new decompressor object</h2><span id='topic+create_decompressor'></span>

<h3>Description</h3>

<p>Initialize a new decompressor object for zlib-based decompression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_decompressor(wbits = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_decompressor_+3A_wbits">wbits</code></td>
<td>
<p>The window size bits parameter. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SEXP pointer to the new decompressor object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decompressor &lt;- create_decompressor()
</code></pre>

<hr>
<h2 id='decompress'>Single-step decompression of raw data</h2><span id='topic+decompress'></span>

<h3>Description</h3>

<p>Decompresses the provided compressed raw data in a single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompress(data, wbits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompress_+3A_data">data</code></td>
<td>
<p>Compressed raw data to be decompressed.</p>
</td></tr>
<tr><td><code id="decompress_+3A_wbits">wbits</code></td>
<td>
<p>The window size bits parameter. Default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>decompress</code> function offers a streamlined approach to decompressing
raw data. By abstracting the creation of a decompression object, decompressing
the data, and flushing the buffer into one function call, it provides a hassle-free
way to retrieve original data from its compressed form. This function is designed
to work seamlessly with data compressed using the <code>compress</code> function or
any other zlib-based compression method.
</p>


<h3>Value</h3>

<p>A raw vector containing the decompressed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>original_data &lt;- charToRaw("some data")
compressed_data &lt;- compress(original_data)
decompressed_data &lt;- decompress(compressed_data)

</code></pre>

<hr>
<h2 id='decompress_chunk'>Decompress a chunk of data</h2><span id='topic+decompress_chunk'></span>

<h3>Description</h3>

<p>Perform chunk-wise decompression on a given raw vector using a decompressor object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompress_chunk(decompressorPtr, input_chunk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompress_chunk_+3A_decompressorptr">decompressorPtr</code></td>
<td>
<p>An external pointer to an initialized decompressor object.</p>
</td></tr>
<tr><td><code id="decompress_chunk_+3A_input_chunk">input_chunk</code></td>
<td>
<p>A raw vector containing the compressed data chunk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raw vector containing the decompressed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rawToChar(decompress_chunk(create_decompressor(), memCompress(charToRaw("Hello, World"))))
</code></pre>

<hr>
<h2 id='decompressobj'>Create a new decompressor object</h2><span id='topic+decompressobj'></span>

<h3>Description</h3>

<p>Initializes a new decompressor object for zlib-based decompression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompressobj(wbits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompressobj_+3A_wbits">wbits</code></td>
<td>
<p>The window size bits parameter. Default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned decompressor object has methods for performing chunk-wise
decompression on compressed data using the zlib library.
</p>


<h3>Value</h3>

<p>A decompressor object with methods for decompression.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>decompress(data)</code>: Compresses a chunk of data.
</p>
</li>
<li> <p><code>flush()</code>: Flushes the compression buffer.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>compressor &lt;- zlib$compressobj(zlib$Z_DEFAULT_COMPRESSION, zlib$DEFLATED, zlib$MAX_WBITS + 16)
compressed_data &lt;- compressor$compress(charToRaw("some data"))
compressed_data &lt;- c(compressed_data, compressor$flush())
decompressor &lt;- decompressobj(zlib$MAX_WBITS + 16)
decompressed_data &lt;- c(decompressor$decompress(compressed_data), decompressor$flush())

</code></pre>

<hr>
<h2 id='flush_compressor_buffer'>Flush the internal buffer of the compressor object.</h2><span id='topic+flush_compressor_buffer'></span>

<h3>Description</h3>

<p>This function flushes the internal buffer according to the specified mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flush_compressor_buffer(compressorPtr, mode = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flush_compressor_buffer_+3A_compressorptr">compressorPtr</code></td>
<td>
<p>A SEXP pointer to an existing compressor object.</p>
</td></tr>
<tr><td><code id="flush_compressor_buffer_+3A_mode">mode</code></td>
<td>
<p>A compression flush mode. Default is Z_FINISH.
Available modes are Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_BLOCK, and Z_FINISH.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raw vector containing the flushed output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compressor &lt;- create_compressor()
# ... (some compression actions)
flushed_data &lt;- flush_compressor_buffer(compressor)
</code></pre>

<hr>
<h2 id='flush_decompressor_buffer'>Flush the internal buffer of the decompressor object.</h2><span id='topic+flush_decompressor_buffer'></span>

<h3>Description</h3>

<p>This function processes all pending input and returns the remaining uncompressed output.
The function uses the provided initial buffer size and dynamically expands it as necessary
to ensure all remaining data is decompressed. After calling this function, the
decompress_chunk() method cannot be called again on the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flush_decompressor_buffer(decompressorPtr, length = 256L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flush_decompressor_buffer_+3A_decompressorptr">decompressorPtr</code></td>
<td>
<p>A SEXP pointer to an existing decompressor object.</p>
</td></tr>
<tr><td><code id="flush_decompressor_buffer_+3A_length">length</code></td>
<td>
<p>An optional parameter that sets the initial size of the output buffer. Default is 256.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raw vector containing the remaining uncompressed output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decompressor &lt;- create_decompressor()
# ... (some decompression actions)
flushed_data &lt;- flush_decompressor_buffer(decompressor)
</code></pre>

<hr>
<h2 id='publicEval'>Evaluate Expression with Public and Private Environments</h2><span id='topic+publicEval'></span>

<h3>Description</h3>

<p><code>publicEval</code> creates an environment hierarchy consisting of
public, self, and private environments. The expression <code>expr</code> is
evaluated within these nested environments, allowing for controlled
variable scope and encapsulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publicEval(expr, parentEnv = parent.frame(), name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="publicEval_+3A_expr">expr</code></td>
<td>
<p>An expression to evaluate within the constructed environment hierarchy.</p>
</td></tr>
<tr><td><code id="publicEval_+3A_parentenv">parentEnv</code></td>
<td>
<p>The parent environment for the new 'public' environment. Default is the parent frame.</p>
</td></tr>
<tr><td><code id="publicEval_+3A_name">name</code></td>
<td>
<p>Optional name attribute to set for the public environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an invisible reference to the public environment.
</p>


<h3>Environments</h3>


<ul>
<li><p> Public: Variables in this environment are externally accessible.
</p>
</li>
<li><p> Self: Inherits from Public and also contains Private and Public as children.
</p>
</li>
<li><p> Private: Variables are encapsulated and are not externally accessible.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>publicEnv &lt;- publicEval({
  private$hidden_var &lt;- "I am hidden"
  public_var &lt;- "I am public"
}, parentEnv = parent.frame(), name = "MyEnvironment")

print(exists("public_var", envir = publicEnv))  # Should return TRUE
print(exists("hidden_var", envir = publicEnv))  # Should return FALSE

</code></pre>

<hr>
<h2 id='validate_gzip_file'>Validate if a File is a Valid Gzip File</h2><span id='topic+validate_gzip_file'></span>

<h3>Description</h3>

<p>This function takes a file path as input and checks if it's a valid gzip-compressed file.
It reads the file in chunks and tries to decompress it using the zlib library.
If any step fails, the function returns <code>FALSE</code>. Otherwise, it returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_gzip_file(file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_gzip_file_+3A_file_path">file_path</code></td>
<td>
<p>A string representing the path of the file to validate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value indicating whether the file is a valid gzip file.
<code>TRUE</code> if the file is valid, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_gzip_file("path/to/your/file.gz")
</code></pre>

<hr>
<h2 id='zlib'>zlib</h2><span id='topic+zlib'></span><span id='topic+.onLoad'></span>

<h3>Description</h3>

<p>What My Package Offers
</p>
<p>This package provides several key features:
</p>

<dl>
<dt><strong>Robustness:</strong></dt><dd><p>Built to handle even corrupted or incomplete gzip data efficiently without causing system failures.</p>
</dd>
<dt>Demonstration:</dt><dd>
<pre>
  compressed_data &lt;- memCompress(charToRaw(paste0(rep("This is an example string. It contains more than just 'hello, world!'", 1000), collapse = ", ")))
  decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS)
  rawToChar(c(decompressor$decompress(compressed_data[1:300]), decompressor$flush()))  # Still working
  </pre></dd>
<dt><strong>Compliance:</strong></dt><dd><p>Strict adherence to the GZIP File Format Specification, ensuring compatibility across systems.</p>
</dd>
<dt>Demonstration:</dt><dd>
<pre>
  compressor &lt;- zlib$compressobj(zlib$Z_DEFAULT_COMPRESSION, zlib$DEFLATED, zlib$MAX_WBITS + 16)
  c(compressor$compress(charToRaw("Hello World")), compressor$flush())  # Correct 31 wbits (or custom wbits you provide)
  # [1] 1f 8b 08 00 00 00 00 00 00 03 f3 48 cd c9 c9 57 08 cf 2f ca 49 01 00 56 b1 17 4a 0b 00 00 00
  </pre></dd>
<dt><strong>Flexibility:</strong></dt><dd><p>Ability to manage Gzip streams from REST APIs without the need for temporary files or other workarounds.</p>
</dd>
<dt>Demonstration:</dt><dd>
<pre>
    # Byte-Range Request and decompression in chunks

    # Initialize the decompressor
    decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS + 16)

    # Define the URL and initial byte ranges
    url &lt;- "https://example.com/api/data.gz"
    range_start &lt;- 0
    range_increment &lt;- 5000  # Adjust based on desired chunk size

    # Placeholder for the decompressed content
    decompressed_content &lt;- character(0)

    # Loop to make multiple requests and decompress chunk by chunk
    for (i in 1:5) {  # Adjust the loop count based on the number of chunks you want to retrieve
      range_end &lt;- range_start + range_increment

      # Make a byte-range request
      response &lt;- httr::GET(url, httr::add_headers(`Range` = paste0("bytes=", range_start, "-", range_end)))

      # Check if the request was successful
      if (httr::http_type(response) != "application/octet-stream" || httr::http_status(response)$category != "Success") {
        stop("Failed to retrieve data.")
      }

      # Decompress the received chunk
      compressed_data &lt;- httr::content(response, "raw")
      decompressed_chunk &lt;- decompressor$decompress(compressed_data)
      decompressed_content &lt;- c(decompressed_content, rawToChar(decompressed_chunk))

      # Update the byte range for the next request
      range_start &lt;- range_end + 1
    }

    # Flush the decompressor after all chunks have been processed
    final_data &lt;- decompressor$flush()
    decompressed_content &lt;- c(decompressed_content, rawToChar(final_data))
  </pre></dd>
</dl>

<p>In summary, while R’s built-in methods could someday catch up in functionality, the zlib package for now fills an important gap by providing a more robust and flexible way to handle compression and decompression tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onLoad(libname, pkgname)
</code></pre>


<h3>Details</h3>

<p>The following 'zlib' enrivonment is generated by the .onLoad Behavior for R packages.
</p>
<p>The .onLoad function is automatically called when the package is loaded using
<code>library()</code> or <code>require()</code>. It initializes the an environment,
which can be reached from anywhere and is unique (i.e. cannot be ovwerwritten),
including defining a variety of constants / methods related to the zlib compression
library.
</p>
<p>Specifically, the function assigns a new environment named &quot;zlib&quot; containing
constants such as <code>DEFLATED</code>, <code>DEF_BUF_SIZE</code>, <code>MAX_WBITS</code>,
and various flush and compression strategies like <code>Z_FINISH</code>,
<code>Z_BEST_COMPRESSION</code>, etc.
</p>


<h3>Value</h3>

<p>No return value, called for side effect. An environment containing the zlib constants created onLoad.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>compressobj(...)</code>: Create a compression object.
</p>
</li>
<li> <p><code>decompressobj(...)</code>: Create a decompression object.
</p>
</li>
<li> <p><code>compress(data, ...)</code>: Compress data in a single step.
</p>
</li>
<li> <p><code>decompress(data, ...)</code>: Decompress data in a single step.
</p>
</li></ul>



<h3>Constants</h3>


<ul>
<li> <p><code>DEFLATED</code>: The compression method, set to 8.
</p>
</li>
<li> <p><code>DEF_BUF_SIZE</code>: The default buffer size, set to 16384.
</p>
</li>
<li> <p><code>DEF_MEM_LEVEL</code>: Default memory level, set to 8.
</p>
</li>
<li> <p><code>MAX_WBITS</code>: Maximum size of the history buffer, set to 15.
</p>
</li>
<li> <p><code>Z_BEST_COMPRESSION</code>: Best compression level, set to 9.
</p>
</li>
<li> <p><code>Z_BEST_SPEED</code>: Best speed for compression, set to 1.
</p>
</li>
<li> <p><code>Z_BLOCK</code>: Block compression mode, set to 5.
</p>
</li>
<li> <p><code>Z_DEFAULT_COMPRESSION</code>: Default compression level, set to -1.
</p>
</li>
<li> <p><code>Z_DEFAULT_STRATEGY</code>: Default compression strategy, set to 0.
</p>
</li>
<li> <p><code>Z_FILTERED</code>: Filtered compression mode, set to 1.
</p>
</li>
<li> <p><code>Z_FINISH</code>: Finish compression mode, set to 4.
</p>
</li>
<li> <p><code>Z_FULL_FLUSH</code>: Full flush mode, set to 3.
</p>
</li>
<li> <p><code>Z_HUFFMAN_ONLY</code>: Huffman-only compression mode, set to 2.
</p>
</li>
<li> <p><code>Z_NO_COMPRESSION</code>: No compression, set to 0.
</p>
</li>
<li> <p><code>Z_NO_FLUSH</code>: No flush mode, set to 0.
</p>
</li>
<li> <p><code>Z_PARTIAL_FLUSH</code>: Partial flush mode, set to 1.
</p>
</li>
<li> <p><code>Z_RLE</code>: Run-length encoding compression mode, set to 3.
</p>
</li>
<li> <p><code>Z_SYNC_FLUSH</code>: Synchronized flush mode, set to 2.
</p>
</li>
<li> <p><code>Z_TREES</code>: Tree block compression mode, set to 6.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+publicEval">publicEval()</a></code> for the method used to set up the public environment.
</p>
<p><code><a href="#topic+zlib_constants">zlib_constants()</a></code> for the method used to set up the constants in the environment. https://www.zlib.net/manual.html#Constants
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the package
library(zlib)
# Create a temporary file
temp_file &lt;- tempfile(fileext = ".txt")

# Generate example data and write to the temp file
example_data &lt;- "This is an example string. It contains more than just 'hello, world!'"
writeBin(charToRaw(example_data), temp_file)

# Read data from the temp file into a raw vector
file_con &lt;- file(temp_file, "rb")
raw_data &lt;- readBin(file_con, "raw", file.info(temp_file)$size)
close(file_con)
# Create a Compressor object gzip
compressor &lt;- zlib$compressobj(zlib$Z_DEFAULT_COMPRESSION, zlib$DEFLATED, zlib$MAX_WBITS + 16)

# Initialize variables for chunked compression
chunk_size &lt;- 1024
compressed_data &lt;- raw(0)

# Compress the data in chunks
for (i in seq(1, length(raw_data), by = chunk_size)) {
   chunk &lt;- raw_data[i:min(i + chunk_size - 1, length(raw_data))]
   compressed_chunk &lt;- compressor$compress(chunk)
   compressed_data &lt;- c(compressed_data, compressed_chunk)
}

# Flush the compressor buffer
compressed_data &lt;- c(compressed_data, compressor$flush())


# Create a Decompressor object for gzip
decompressor &lt;- zlib$decompressobj(zlib$MAX_WBITS + 16)

# Initialize variable for decompressed data
decompressed_data &lt;- raw(0)

# Decompress the data in chunks
for (i in seq(1, length(compressed_data), by = chunk_size)) {
  chunk &lt;- compressed_data[i:min(i + chunk_size - 1, length(compressed_data))]
  decompressed_chunk &lt;- decompressor$decompress(chunk)
  decompressed_data &lt;- c(decompressed_data, decompressed_chunk)
}

# Flush the decompressor buffer
decompressed_data &lt;- c(decompressed_data, decompressor$flush())

# Comporess / Decompress data in a single step

original_data &lt;- charToRaw("some data")
compressed_data &lt;- zlib$compress(original_data,
                                 zlib$Z_DEFAULT_COMPRESSION,
                                 zlib$DEFLATED,
                                 zlib$MAX_WBITS + 16)
decompressed_data &lt;- zlib$decompress(compressed_data, zlib$MAX_WBITS + 16)

</code></pre>

<hr>
<h2 id='zlib_constants'>Retrieve zlib Constants</h2><span id='topic+zlib_constants'></span>

<h3>Description</h3>

<p>This function returns a list of constants from the zlib C library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zlib_constants()
</code></pre>


<h3>Details</h3>

<p>The constants are defined as follows:
</p>

<ul>
<li> <p><code>DEFLATED</code>: The compression method, set to 8.
</p>
</li>
<li> <p><code>DEF_BUF_SIZE</code>: The default buffer size, set to 16384.
</p>
</li>
<li> <p><code>DEF_MEM_LEVEL</code>: Default memory level, set to 8.
</p>
</li>
<li> <p><code>MAX_WBITS</code>: Maximum size of the history buffer, set to 15.
</p>
</li>
<li> <p><code>Z_BEST_COMPRESSION</code>: Best compression level, set to 9.
</p>
</li>
<li> <p><code>Z_BEST_SPEED</code>: Best speed for compression, set to 1.
</p>
</li>
<li> <p><code>Z_BLOCK</code>: Block compression mode, set to 5.
</p>
</li>
<li> <p><code>Z_DEFAULT_COMPRESSION</code>: Default compression level, set to -1.
</p>
</li>
<li> <p><code>Z_DEFAULT_STRATEGY</code>: Default compression strategy, set to 0.
</p>
</li>
<li> <p><code>Z_FILTERED</code>: Filtered compression mode, set to 1.
</p>
</li>
<li> <p><code>Z_FINISH</code>: Finish compression mode, set to 4.
</p>
</li>
<li> <p><code>Z_FULL_FLUSH</code>: Full flush mode, set to 3.
</p>
</li>
<li> <p><code>Z_HUFFMAN_ONLY</code>: Huffman-only compression mode, set to 2.
</p>
</li>
<li> <p><code>Z_NO_COMPRESSION</code>: No compression, set to 0.
</p>
</li>
<li> <p><code>Z_NO_FLUSH</code>: No flush mode, set to 0.
</p>
</li>
<li> <p><code>Z_PARTIAL_FLUSH</code>: Partial flush mode, set to 1.
</p>
</li>
<li> <p><code>Z_RLE</code>: Run-length encoding compression mode, set to 3.
</p>
</li>
<li> <p><code>Z_SYNC_FLUSH</code>: Synchronized flush mode, set to 2.
</p>
</li>
<li> <p><code>Z_TREES</code>: Tree block compression mode, set to 6.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list of zlib constants.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constants &lt;- zlib_constants()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
