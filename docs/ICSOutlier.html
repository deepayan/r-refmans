<!DOCTYPE html><html lang="en"><head><title>Help for package ICSOutlier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICSOutlier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ICSOutlier-package'><p>Outlier Detection Using Invariant Coordinate Selection</p></a></li>
<li><a href='#comp_norm_test'><p>Selection of Nonnormal Invariant Components Using Marginal Normality Tests</p></a></li>
<li><a href='#comp_simu_test'><p>Selection of Nonnormal Invariant Components Using Simulations</p></a></li>
<li><a href='#comp.norm.test'><p>Selection of Nonnormal Invariant Components Using Marginal Normality Tests</p></a></li>
<li><a href='#comp.simu.test'>
<p>Selection of Nonnormal Invariant Components Using Simulations</p></a></li>
<li><a href='#dist_simu_test'><p>Cut-Off Values Using Simulations for the Detection of Extreme ICS Distances</p></a></li>
<li><a href='#dist.simu.test'>
<p>Cut-Off Values Using Simulations for the Detection of Extreme ICS Distances</p></a></li>
<li><a href='#HTP'>
<p>Production Measurements of High-Tech Parts - Full Rank Case</p></a></li>
<li><a href='#HTP2'><p>Production Measurements of High-Tech Parts - Singular Case</p></a></li>
<li><a href='#HTP3'><p>Production Measurements of High-Tech Parts - Nearly Singular Case</p></a></li>
<li><a href='#ics_distances'><p>Squared ICS Distances for Invariant Coordinates</p></a></li>
<li><a href='#ICS_outlier'><p>Outlier Detection Using ICS</p></a></li>
<li><a href='#ics.distances'>
<p>Squared ICS Distances for Invariant Coordinates</p></a></li>
<li><a href='#ics.outlier'>
<p>Outlier Detection Using ICS</p></a></li>
<li><a href='#icsOut-class'><p>Class icsOut</p></a></li>
<li><a href='#plot.ICS_Out'><p>Distances Plot for an 'ICS_Out' Object</p></a></li>
<li><a href='#plot.icsOut'><p>Distances Plot for an icsOut Object</p></a></li>
<li><a href='#print.ICS_Out'><p>Vector of Outlier Indicators</p></a></li>
<li><a href='#print.icsOut'><p>Vector of Outlier Indicators</p></a></li>
<li><a href='#summary.ICS_Out'><p>Summary of an 'ICS_Out' Object</p>
</p>
<p>Summarizes an 'ICS_Out' object in an informative way.</p></a></li>
<li><a href='#summary.icsOut'><p>Summarize a icsOut object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Outlier Detection Using Invariant Coordinate Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aurore Archimbaud <a href="https://orcid.org/0000-0002-6511-9091"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Anne Ruiz-Gazen <a href="https://orcid.org/0000-0001-8970-8061"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods, ICS (&ge; 1.4-0), moments</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, mvtnorm, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ICSClust, REPPlab, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate outlier detection is performed using invariant coordinates where the package offers different methods to choose the appropriate components. ICS is a general multivariate technique with many applications in multivariate analysis. ICSOutlier offers a selection of functions for automated detection of outliers in the data based on a fitted ICS object or by specifying the dataset and the scatters of interest. The current implementation targets data sets with only a small percentage of outliers. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 11:13:06 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 15:10:02 UTC</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
</table>
<hr>
<h2 id='ICSOutlier-package'>Outlier Detection Using Invariant Coordinate Selection</h2><span id='topic+ICSOutlier-package'></span><span id='topic+ICSOutlier'></span>

<h3>Description</h3>

<p>Multivariate outlier detection is performed using invariant coordinates where the package offers different methods to choose the appropriate components. ICS is a general multivariate technique with many applications in multivariate analysis. ICSOutlier offers a selection of functions for automated detection of outliers in the data based on a fitted ICS object or by specifying the dataset and the scatters of interest. The current implementation targets data sets with only a small percentage of outliers. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ICSOutlier</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Outlier Detection Using Invariant Coordinate Selection</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-13</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@gmail.com",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Aurore", "Archimbaud", 
             email = "aurore.archimbaud@live.fr", 
             role = "aut",
             comment = c(ORCID = "0000-0002-6511-9091")),
      person("Anne", "Ruiz-Gazen", 
             email = "anne.ruiz-gazen@tse-fr.eu",
             role = "aut", 
             comment = c(ORCID = "0000-0001-8970-8061")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
  Aurore Archimbaud [aut] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
  Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), methods, ICS (&gt;= 1.4-0), moments</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> graphics, grDevices, mvtnorm, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> ICSClust,
REPPlab,
testthat (&gt;= 3.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Multivariate outlier detection is performed using invariant coordinates where the package offers different methods to choose the appropriate components. ICS is a general multivariate technique with many applications in multivariate analysis. ICSOutlier offers a selection of functions for automated detection of outliers in the data based on a fitted ICS object or by specifying the dataset and the scatters of interest. The current implementation targets data sets with only a small percentage of outliers. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2023-09-18 08:47:44 UTC; admin</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2023-09-18 09:30:08 UTC</td>
</tr>
<tr>
 <td style="text-align: left;">
Config/testthat/edition: </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
HTP                     Production Measurements of High-Tech Parts -
                        Full Rank Case
HTP2                    Production Measurements of High-Tech Parts -
                        Singular Case
HTP3                    Production Measurements of High-Tech Parts -
                        Nearly Singular Case
ICSOutlier-package      Outlier Detection Using Invariant Coordinate
                        Selection
ICS_outlier             Outlier Detection Using ICS
comp.norm.test          Selection of Nonnormal Invariant Components
                        Using Marginal Normality Tests
comp.simu.test          Selection of Nonnormal Invariant Components
                        Using Simulations
comp_norm_test          Selection of Nonnormal Invariant Components
                        Using Marginal Normality Tests
comp_simu_test          Selection of Nonnormal Invariant Components
                        Using Simulations
dist.simu.test          Cut-Off Values Using Simulations for the
                        Detection of Extreme ICS Distances
dist_simu_test          Cut-Off Values Using Simulations for the
                        Detection of Extreme ICS Distances
ics.distances           Squared ICS Distances for Invariant Coordinates
ics.outlier             Outlier Detection Using ICS
icsOut-class            Class icsOut
ics_distances           Squared ICS Distances for Invariant Coordinates
plot.ICS_Out            Distances Plot for an 'ICS_Out' Object
plot.icsOut             Distances Plot for an icsOut Object
print.ICS_Out           Vector of Outlier Indicators
print.icsOut            Vector of Outlier Indicators
summary.ICS_Out         Summary of an 'ICS_Out' Object Summarizes an
                        'ICS_Out' object in an informative way.
summary.icsOut          Summarize a icsOut object
</pre>


<h3>Author(s)</h3>

<p>Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
  Aurore Archimbaud [aut] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
  Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)
</p>
<p>Maintainer: Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>
<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICSOutlier: Unsupervised Outlier Detection for Low-Dimensional Contamination Structure. The R Journal, 10:234-250.  <a href="https://doi.org/10.32614/RJ-2018-034">doi:10.32614/RJ-2018-034</a>.
</p>

<hr>
<h2 id='comp_norm_test'>Selection of Nonnormal Invariant Components Using Marginal Normality Tests</h2><span id='topic+comp_norm_test'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates that are non normal using univariate normality tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_norm_test(
  object,
  test = "agostino.test",
  type = "smallprop",
  level = 0.05,
  adjust = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_norm_test_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code> where both <code>S1</code> and <code>S2</code> are specified as functions.
The sample size and the dimension of interest are also obtained from the object.</p>
</td></tr>
<tr><td><code id="comp_norm_test_+3A_test">test</code></td>
<td>
<p>name of the normality test to be used. Possibilites are <code>"jarque.test"</code>,
<code>"anscombe.test"</code>, <code>"bonett.test"</code>, <code>"agostino.test"</code>, <code>"shapiro.test"</code>.
Default is <code>"agostino.test"</code>.</p>
</td></tr>
<tr><td><code id="comp_norm_test_+3A_type">type</code></td>
<td>
<p>currently the only option is <code>"smallprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="comp_norm_test_+3A_level">level</code></td>
<td>
<p>the initial level used to make a decision based on the test p-values. See details.</p>
</td></tr>
<tr><td><code id="comp_norm_test_+3A_adjust">adjust</code></td>
<td>
<p>logical. If <code>TRUE</code>, the quantiles levels are adjusted. Default is <code>TRUE</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the only available <code>type</code> is <code>"smallprop"</code> which detects which of the components follow a univariately normal distribution. It starts from the first component and stops when a component is detected as gaussian. Five tests for univariate normality are available. See <a href="ICSClust.html#topic+normal_crit">normal_crit()</a> function for more general cases.
</p>
<p>If <code>adjust = FALSE</code> all tests are performed at the same <code>level</code>. This leads however often to too many components. Therefore some multiple testing adjustments might be useful. The current default adjusts the level for the jth component as <code>level</code>/j.
</p>
<p>Note that the function is seldomly called directly by the user but internally by <code><a href="#topic+ICS_outlier">ICS_outlier()</a></code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>index</code>:  integer vector indicating the indices of the selected components.
</p>
</li>
<li> <p><code>test</code>: string with the name of the normality test used.
</p>
</li>
<li> <p><code>criterion</code>: vector of the p-values from the marginal normality tests for each component.
</p>
</li>
<li> <p><code>levels</code>: vector of the levels used for the decision for each component.
</p>
</li>
<li> <p><code>adjust</code>: logical. <code>TRUE</code> if adjusted.
</p>
</li>
<li> <p><code>type</code>: <code>type</code> used
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>


<h3>See Also</h3>

<p><a href="ICS.html#topic+ICS-S3">ICS()</a>, <code><a href="#topic+comp_simu_test">comp_simu_test()</a></code>, <a href="moments.html#topic+jarque.test">jarque.test()</a>,
<a href="moments.html#topic+anscombe.test">anscombe.test()</a>, <a href="moments.html#topic+bonett.test">bonett.test()</a>, <a href="moments.html#topic+agostino.test">bonett.test()</a>,
<a href="stats.html#topic+shapiro.test">shapiro.test()</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Z &lt;- rmvnorm(1000, rep(0, 6))
# Add 20 outliers on the first component
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
pairs(Z)
icsZ &lt;- ICS(Z)
# The shift located outliers can be displayed in one dimension
comp_norm_test(icsZ)
# Only one invariant component is non normal and selected.
comp_norm_test(icsZ, test = "bonett.test")

# Example with no outlier
Z0 &lt;- rmvnorm(1000, rep(0, 6))
pairs(Z0)
icsZ0 &lt;-ICS(Z0)
# Should select no component
comp_norm_test(icsZ0, level = 0.01)$index

</code></pre>

<hr>
<h2 id='comp_simu_test'>Selection of Nonnormal Invariant Components Using Simulations</h2><span id='topic+comp_simu_test'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates that are nonnormal using simulations under a standard multivariate normal model for a specific data setup and scatter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_simu_test(
  object,
  S1 = NULL,
  S2 = NULL,
  S1_args = list(),
  S2_args = list(),
  m = 10000,
  type = "smallprop",
  level = 0.05,
  adjust = TRUE,
  n_cores = NULL,
  iseed = NULL,
  pkg = "ICSOutlier",
  q_type = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_simu_test_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code> where both <code>S1</code> and <code>S2</code> are specified as functions.
The sample size and the dimension of interest are also obtained from the object.
It is also natural to expect that the invariant coordinate are centered.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_s1">S1</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_s2">S2</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_s1_args">S1_args</code></td>
<td>
<p>a list containing additional arguments for <code>S1</code>.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_s2_args">S2_args</code></td>
<td>
<p>a list containing additional arguments for <code>S2</code>.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_m">m</code></td>
<td>
<p>number of simulations. Note that since extreme quantiles are of interest <code>m</code> should be large.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_type">type</code></td>
<td>
<p>currently the only type option is <code>"smallprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_level">level</code></td>
<td>
<p>the initial level used to make a decision. The cut-off values are the (1-<code>level</code>)th quantile of the eigenvalues obtained from simulations. See details.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_adjust">adjust</code></td>
<td>
<p>logical. If <code>TRUE</code>, the quantiles levels are adjusted. Default is <code>TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot; and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_q_type">q_type</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="comp_simu_test_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on simulations it detects which of the components follow a univariately normal distribution. More precisely it identifies the observed eigenvalues larger than the ones coming
from normal distributed data. <code>m</code> standard normal data sets are simulated using the same data size and scatters as specified in the <code>"ICS"</code> object.
The cut-off values are determined based on a quantile of these simulated eigenvalues.
</p>
<p>As the eigenvalues, aka generalized kurtosis values, of ICS are ordered it is natural to perform the comparison in a specific order depending on the purpose.
Currently the only available <code>type</code> is <code>"smallprop"</code> so starting with the first component, the observed eigenvalues are successively compared to these cut-off values. The precedure stops when an eigenvalue is below the corresponding cut-off, so when a normal component is detected.
</p>
<p>If <code>adjust = FALSE</code> all eigenvalues are compared to the same (<code>1-level</code>)th level of the quantile. This leads however often to too many selected components.
Therefore some multiple testing adjustment might be useful. The current default adjusts the quantile for the jth component as <code>1-level</code>/j.
</p>
<p>Note that depending on the data size and scatters used this can take a while and so it is more efficient to parallelize computations.
Note also that the function is seldomly called directly by the user but internally by <code><a href="#topic+ICS_outlier">ICS_outlier()</a></code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>index</code>:  integer vector indicating the indices of the selected components.
</p>
</li>
<li> <p><code>test</code>: string <code>"simulation"</code>.
</p>
</li>
<li> <p><code>criterion</code>: vector of the cut-off values for all the eigenvalues.
</p>
</li>
<li> <p><code>levels</code>: vector of the levels used for the decision for each component.
</p>
</li>
<li> <p><code>adjust</code>: logical. <code>TRUE</code> if adjusted.
</p>
</li>
<li> <p><code>type</code>: <code>type</code> used
</p>
</li>
<li> <p><code>m</code>: number of iterations <code>m</code> used in the simulations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>


<h3>See Also</h3>

<p><a href="ICS.html#topic+ICS-S3">ICS()</a>, <code><a href="#topic+comp_norm_test">comp_norm_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a real analysis use larger values for m and more cores if available
set.seed(123)
Z &lt;- rmvnorm(1000, rep(0, 6))
# Add 20 outliers on the first component
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
pairs(Z)
icsZ &lt;- ICS(Z)
# For demo purpose only small m value, should select the first component
comp_simu_test(icsZ, S1 = ICS_cov, S2= ICS_cov4, m = 400, n_cores = 1)

## Not run: 
 # For using two cores
  # For demo purpose only small m value, should select the first component
  comp_simu_test(icsZ, S1 = ICS_cov, S2 = ICS_cov4, m = 500, n_cores = 2, iseed = 123)
  # For using several cores and for using a scatter function from a different package
  # Using the parallel package to detect automatically the number of cores
  library(parallel)
  # ICS with MCD estimates and the usual estimates
  library(ICSClust)
        icsZmcd &lt;- ICS(Z, S1 = ICS_mcd_raw, S2 = ICS_cov, S1_args = list(alpha = 0.75))
        # For demo purpose only small m value, should select the first component
        comp_simu_test(icsZmcd, S1 = ICS_mcd_raw, S2 = ICS_cov, 
        S1_args = list(alpha = 0.75, location = TRUE),
         m = 500, ncores = detectCores()-1, 
                    pkg = c("ICSOutlier", "ICSClust"), iseed = 123)
 
## End(Not run)
 # Example with no outlier
 Z0 &lt;- rmvnorm(1000, rep(0, 6))
 pairs(Z0)
 icsZ0 &lt;- ICS(Z0)
 # Should select no component
 comp_simu_test(icsZ0,S1 = ICS_cov, S2 = ICS_cov4, m = 400, level = 0.01, n_cores = 1)
</code></pre>

<hr>
<h2 id='comp.norm.test'>Selection of Nonnormal Invariant Components Using Marginal Normality Tests</h2><span id='topic+comp.norm.test'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates that are non normal using univariate normality tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.norm.test(object, test = "agostino.test", type = "smallprop", level = 0.05, 
  adjust = TRUE)
</code></pre>


<h3>Arguments</h3>

    
<table role = "presentation">
<tr><td><code id="comp.norm.test_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code> where both <code>S1</code> and <code>S2</code> are specified as functions. The sample size and the dimension of interest
are also obtained from the object.</p>
</td></tr>
<tr><td><code id="comp.norm.test_+3A_test">test</code></td>
<td>
<p>name of the normality test to be used. Possibilites are <code>"jarque.test"</code>, 
<code>"anscombe.test"</code>, <code>"bonett.test"</code>, <code>"agostino.test"</code>, <code>"shapiro.test"</code>.
Default is <code>"agostino.test"</code>.</p>
</td></tr>
<tr><td><code id="comp.norm.test_+3A_type">type</code></td>
<td>
<p>currently the only option is <code>"smallprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="comp.norm.test_+3A_level">level</code></td>
<td>
<p>the initial level used to make a decision based on the test p-values. See details.</p>
</td></tr>
<tr><td><code id="comp.norm.test_+3A_adjust">adjust</code></td>
<td>
<p>logical. If <code>TRUE</code>, the quantiles levels are adjusted. Default is <code>TRUE</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the only available <code>type</code> is <code>"smallprop"</code> which detects which of the components follow a univariately normal distribution. It starts 
from the first component and stops when a component is detected as gaussian. Five tests for univariate normality are available.
</p>
<p>If <code>adjust = FALSE</code> all tests are performed at the same <code>level</code>. This leads however often to too many components.
Therefore some multiple testing adjustments might be useful. The current default adjusts the level for the jth component as   
<code>level</code>/j.
</p>
<p>Note that the function is seldomly called directly by the user but internally by <code><a href="#topic+ics.outlier">ics.outlier</a></code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>index</code></td>
<td>
<p>integer vector indicating the indices of the selected components.</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>string with the name of the normality test used.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>vector of the p-values from the marginal normality tests for each component.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>vector of the levels used for the decision for each component.</p>
</td></tr>
<tr><td><code>adjust</code></td>
<td>
<p>logical. <code>TRUE</code> if adjusted.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p><code>type</code> used.</p>
</td></tr>

</table>


<h3>Note</h3>

<p>Function <code><a href="#topic+comp.norm.test">comp.norm.test</a></code> reached the end of its lifecycle, please use <code><a href="#topic+comp_norm_test">comp_norm_test</a></code> instead. In future versions, <code><a href="#topic+comp.norm.test">comp.norm.test</a></code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  &lt;https://doi.org/10.1016/j.csda.2018.06.011&gt;.</cite>   
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ics2">ics2</a></code>, <code><a href="#topic+comp.simu.test">comp.simu.test</a></code>, <code><a href="moments.html#topic+jarque.test">jarque.test</a></code>, <code><a href="moments.html#topic+anscombe.test">anscombe.test</a></code>,
<code><a href="moments.html#topic+bonett.test">bonett.test</a></code>, <code><a href="moments.html#topic+agostino.test">agostino.test</a></code>, 
<code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rmvnorm(1000, rep(0, 6))
# Add 20 outliers on the first component
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
pairs(Z)
icsZ &lt;- ics2(Z)
# The shift located outliers can be displayed in one dimension
comp.norm.test(icsZ)
# Only one invariant component is non normal and selected.
comp.norm.test(icsZ, test = "bo")

# Example with no outlier
Z0 &lt;- rmvnorm(1000, rep(0, 6))
pairs(Z0)
icsZ0 &lt;- ics2(Z0)
# Should select no component
comp.norm.test(icsZ0, level = 0.01)$index

</code></pre>

<hr>
<h2 id='comp.simu.test'>
Selection of Nonnormal Invariant Components Using Simulations
</h2><span id='topic+comp.simu.test'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates that are nonnormal using simulations under a standard multivariate normal model for a specific data setup and scatter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.simu.test(object, m = 10000, type = "smallprop", level = 0.05, 
  adjust = TRUE, ncores = NULL, iseed = NULL, pkg = "ICSOutlier", 
  qtype = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp.simu.test_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code> where both <code>S1</code> and <code>S2</code> are specified as functions. The sample size and the dimension of interest
are also obtained from the object.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_m">m</code></td>
<td>
<p>number of simulations. Note that since extreme quantiles are of interest <code>m</code> should be large. </p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_type">type</code></td>
<td>
<p>currently the only type option is <code>"smallprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_level">level</code></td>
<td>
<p>the initial level used to make a decision. The cut-off values are the (1-<code>level</code>)th quantile of the eigenvalues obtained from simulations. See details.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_adjust">adjust</code></td>
<td>
<p>logical. If <code>TRUE</code>, the quantiles levels are adjusted. Default is <code>TRUE</code>. See details. </p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot;
and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_qtype">qtype</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="comp.simu.test_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on simulations it detects which of the components follow a univariately normal distribution. More precisely it identifies the observed eigenvalues larger than the ones coming
from normal distributed data. <code>m</code> standard normal data sets are simulated using the same data size and scatters as specified in the <code>ics2</code> object.
The cut-off values are determined based on a quantile of these simulated eigenvalues. 
</p>
<p>As the eigenvalues, aka generalized kurtosis values, of ICS are ordered it is natural to perform the comparison in a specific order depending on the purpose. 
Currently the only available <code>type</code> is <code>"smallprop"</code> so starting with the first component, the observed eigenvalues are successively compared to
these cut-off values. The precedure stops when an eigenvalue is below the corresponding cut-off, so when a normal component is detected.
</p>
<p>If <code>adjust = FALSE</code> all eigenvalues are compared to the same (<code>1-level</code>)th level of the quantile. This leads however often to too many selected components. 
Therefore some multiple testing adjustment might be useful. The current default adjusts the quantile for the jth component as <code>1-level</code>/j. 
</p>
<p>Note that depending on the data size and scatters used this can take a while and so it is more efficient to parallelize computations.
Note also that the function is seldomly called directly by the user but internally by <code><a href="#topic+ics.outlier">ics.outlier</a></code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>index</code></td>
<td>
<p>integer vector indicating the indices of the selected components.</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>string <code>"simulation"</code>.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>vector of the cut-off values for all the eigenvalues.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>vector of the levels used to derive the cut-offs for each component.</p>
</td></tr>
<tr><td><code>adjust</code></td>
<td>
<p>logical. <code>TRUE</code> if adjusted.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p><code>type</code> used.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of iterations <code>m</code> used in the simulations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> reached the end of its lifecycle, please use <code>comp_simu_test()</code> instead. In future versions, <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  &lt;https://doi.org/10.1016/j.csda.2018.06.011&gt;.</cite>   
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ics2">ics2</a></code>, <code><a href="#topic+comp.norm.test">comp.norm.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a real analysis use larger values for m and more cores if available

set.seed(123)
Z &lt;- rmvnorm(1000, rep(0, 6))
# Add 20 outliers on the first component
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
pairs(Z)
icsZ &lt;- ics2(Z)
# For demo purpose only small m value, should select the first component
comp.simu.test(icsZ, m = 400, ncores = 1)

## Not run: 
# For using two cores
# For demo purpose only small m value, should select the first component
comp.simu.test(icsZ, m = 500, ncores = 2, iseed = 123)
  
# For using several cores and for using a scatter function from a different package
# Using the parallel package to detect automatically the number of cores
library(parallel)
# ICS with MCD estimates and the usual estimates
# Need to create a wrapper for the CovMcd function to return first the location estimate
# and the scatter estimate secondly.
library(rrcov)
myMCD &lt;- function(x,...){
  mcd &lt;- CovMcd(x,...)
  return(list(location = mcd@center, scatter = mcd@cov))
}
icsZmcd &lt;- ics2(Z, S1 = myMCD, S2 = MeanCov, S1args = list(alpha = 0.75))
# For demo purpose only small m value, should select the first component
comp.simu.test(icsZmcd, m = 500, ncores = detectCores()-1, 
               pkg = c("ICSOutlier", "rrcov"), iseed = 123)

## End(Not run)

# Example with no outlier
Z0 &lt;- rmvnorm(1000, rep(0, 6))
pairs(Z0)
icsZ0 &lt;- ics2(Z0)
#Should select no component
comp.simu.test(icsZ0, m = 400, level = 0.01, ncores = 1)
</code></pre>

<hr>
<h2 id='dist_simu_test'>Cut-Off Values Using Simulations for the Detection of Extreme ICS Distances</h2><span id='topic+dist_simu_test'></span>

<h3>Description</h3>

<p>Computes the cut-off values for the identification of the outliers based on the squared ICS distances. It uses simulations under a multivariate standard normal model for a specific data setup and scatters combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_simu_test(
  object,
  S1 = NULL,
  S2 = NULL,
  S1_args = list(),
  S2_args = list(),
  index,
  m = 10000,
  level = 0.025,
  n_cores = NULL,
  iseed = NULL,
  pkg = "ICSOutlier",
  q_type = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_simu_test_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code> where both <code>S1</code> and <code>S2</code> are specified as functions.
The sample size and the dimension of interest are also obtained from the object.
The invariant coordinate are required to be centered.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_s1">S1</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_s2">S2</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_s1_args">S1_args</code></td>
<td>
<p>a list containing additional arguments for <code>S1</code>.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_s2_args">S2_args</code></td>
<td>
<p>a list containing additional arguments for <code>S2</code>.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_index">index</code></td>
<td>
<p>integer vector specifying which components are used to compute the  <code><a href="#topic+ics_distances">ics_distances()</a></code>.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_m">m</code></td>
<td>
<p>number of simulations. Note that extreme quantiles are of interest and hence <code>m</code> should be large.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_level">level</code></td>
<td>
<p>the (1-<code>level</code>(s))th quantile(s) used to choose the cut-off value(s). Usually just one number between 0 and 1. However a vector is also possible.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot; and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_q_type">q_type</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="dist_simu_test_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts basically the dimension of the data from the <code>"ICS"</code> object and simulates <code>m</code> times, from a multivariate standard normal distribution, the squared ICS distances with the components specified in <code>index</code>. The resulting value is then the mean of the <code>m</code> correponding quantiles of these distances  at level 1-<code>level</code>.
</p>
<p>Note that depending on the data size and scatters used this can take a while and so it is more efficient to parallelize computations.
</p>
<p>Note that the function is seldomly called directly by the user but internally by <code><a href="#topic+ICS_outlier">ICS_outlier()</a></code>.
</p>


<h3>Value</h3>

<p>A vector with the values of the (1-<code>level</code>)th quantile.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>


<h3>See Also</h3>

<p><a href="ICS.html#topic+ICS-S3">ICS()</a>, <code><a href="#topic+ics_distances">ics_distances()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a real analysis use larger values for m and more cores if available

Z &lt;- rmvnorm(1000, rep(0, 6))
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
A &lt;- matrix(rnorm(36), ncol = 6)
X &lt;- tcrossprod(Z, A)

pairs(X)
icsX &lt;- ICS(X, center = TRUE)

icsX.dist.1 &lt;- ics_distances(icsX, index = 1)
CutOff &lt;- dist_simu_test(icsX, S1 = ICS_cov, S2= ICS_cov4,
                        index = 1, m = 500, ncores = 1)

# check if outliers are above the cut-off value
plot(icsX.dist.1, col = rep(2:1, c(20, 980)))
abline(h = CutOff)


library(REPPlab)
data(ReliabilityData)
# The observations 414 and 512 are suspected to be outliers
icsReliability &lt;- ICS(ReliabilityData, center = TRUE)
# Choice of the number of components with the screeplot: 2
screeplot(icsReliability)
# Computation of the distances with the first 2 components
ics.dist.scree &lt;- ics_distances(icsReliability, index = 1:2)
# Computation of the cut-off of the distances 
CutOff &lt;- dist_simu_test(icsReliability, S1 = ICS_cov, S2= ICS_cov4,
                         index = 1:2, m = 50, level = 0.02, ncores = 1)
# Identification of the outliers based on the cut-off value
plot(ics.dist.scree)
abline(h = CutOff)
outliers &lt;- which(ics.dist.scree &gt;= CutOff)
text(outliers, ics.dist.scree[outliers], outliers, pos = 2, cex = 0.9)

## Not run: 
    # For using three cores
    # For demo purpose only small m value, should select the first #' component
    dist_simu_test(icsReliability, S1 = ICS_cov, S2= ICS_cov4,
                   index = 1:2, m = 500, level = 0.02, n_cores = 3, iseed #' = 123)
    
    # For using several cores and for using a scatter function from a different package
    # Using the parallel package to detect automatically the number of cores
    library(parallel)
    # ICS with Cauchy estimates
    library(ICSClust)
    icsReliabilityMLC &lt;- ICS(ReliabilityData, S1 = ICS_mlc, 
                            S1_args = list(location = TRUE),
                                 S2 = ICS_cov, center = TRUE)
    # Computation of the cut-off of the distances. For demo purpose only small m value.
    dist_simu_test(icsReliabilityMLC,  S1 = ICS_mlc,  S1_args = list(location = TRUE), 
    S2 = ICS_cov, index = 1:2, m = 500, level = 0.02, 
    n_cores = detectCores()-1,  pkg = c("ICSOutlier","ICSClust"), iseed = 123)

## End(Not run)
</code></pre>

<hr>
<h2 id='dist.simu.test'>
Cut-Off Values Using Simulations for the Detection of Extreme ICS Distances
</h2><span id='topic+dist.simu.test'></span>

<h3>Description</h3>

<p>Computes the cut-off values for the identification of the outliers based on the squared ICS distances.
It uses simulations under a multivariate standard normal model for a specific data setup and scatters combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.simu.test(object, index, m = 10000, level = 0.025, ncores = NULL, 
               iseed = NULL, pkg = "ICSOutlier", qtype = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.simu.test_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code> where both <code>S1</code> and <code>S2</code> are specified as functions. The sample size and the dimension of interest
are also obtained from the object.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_index">index</code></td>
<td>
<p>integer vector specifiying which components are used to compute the 
<code><a href="#topic+ics.distances">ics.distances</a></code>.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_m">m</code></td>
<td>
<p>number of simulations. Note that extreme quantiles are of interest and hence <code>m</code> should be large. </p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_level">level</code></td>
<td>
<p>the (1-<code>level</code>(s))th quantile(s) used to choose the cut-off value(s). Usually just one number between 0 and 1. However a vector is
also possible.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot;
and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_qtype">qtype</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="dist.simu.test_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts basically the dimension of the data from the <code>ics2</code> object and simulates <code>m</code> times, from a multivariate standard normal distribution,
the squared ICS distances with the components specified in <code>index</code>. The resulting value is then the mean of the <code>m</code> correponding quantiles of these distances 
at level 1-<code>level</code>.
</p>
<p>Note that depending on the data size and scatters used this can take a while and so it is more efficient to parallelize computations.
</p>
<p>Note that the function is seldomly called directly by the user but internally by <code><a href="#topic+ics.outlier">ics.outlier</a></code>.
</p>


<h3>Value</h3>

<p>A vector with the values of the (1-<code>level</code>)th quantile.
</p>


<h3>Note</h3>

<p>Function <code><a href="#topic+dist.simu.test">dist.simu.test</a></code> reached the end of its lifecycle, please use <code><a href="#topic+dist_simu_test">dist_simu_test</a></code> instead. In future versions, <code><a href="#topic+dist.simu.test">dist.simu.test</a></code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  &lt;https://doi.org/10.1016/j.csda.2018.06.011&gt;.</cite>   
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ics2">ics2</a></code>, <code><a href="#topic+ics.distances">ics.distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a real analysis use larger values for m and more cores if available

Z &lt;- rmvnorm(1000, rep(0, 6))
Z[1:20, 1] &lt;- Z[1:20, 1] + 10
A &lt;- matrix(rnorm(36), ncol = 6)
X &lt;- tcrossprod(Z, A)

pairs(X)
icsX &lt;- ics2(X)

icsX.dist.1 &lt;- ics.distances(icsX, index = 1)
CutOff &lt;- dist.simu.test(icsX, 1, m = 500, ncores = 1)

# check if outliers are above the cut-off value
plot(icsX.dist.1, col = rep(2:1, c(20, 980)))
abline(h = CutOff)


library(REPPlab)
data(ReliabilityData)
# The observations 414 and 512 are suspected to be outliers
icsReliability &lt;- ics2(ReliabilityData, S1 = MeanCov, S2 = Mean3Cov4)
# Choice of the number of components with the screeplot: 2
screeplot(icsReliability)
# Computation of the distances with the first 2 components
ics.dist.scree &lt;- ics.distances(icsReliability, index = 1:2)
# Computation of the cut-off of the distances 
CutOff &lt;- dist.simu.test(icsReliability, 1:2, m = 50, level = 0.02, ncores = 1)
# Identification of the outliers based on the cut-off value
plot(ics.dist.scree)
abline(h = CutOff)
outliers &lt;- which(ics.dist.scree &gt;= CutOff)
text(outliers, ics.dist.scree[outliers], outliers, pos = 2, cex = 0.9)

## Not run: 
# For using three cores
# For demo purpose only small m value, should select the first component
dist.simu.test(icsReliability, 1:2, m = 500, level = 0.02, ncores = 3, iseed = 123)
  
# For using several cores and for using a scatter function from a different package
# Using the parallel package to detect automatically the number of cores
library(parallel)
# ICS with Multivariate Median and Tyler's Shape Matrix and the usual estimates
library(ICSNP)
icsReliabilityHRMest &lt;- ics2(ReliabilityData, S1 = HR.Mest, S2 = MeanCov, 
                             S1args = list(maxiter = 1000))
# Computation of the cut-off of the distances. For demo purpose only small m value.
dist.simu.test(icsReliabilityHRMest,  1:2, m = 500, level = 0.02, ncores = detectCores()-1, 
               pkg = c("ICSOutlier","ICSNP"), iseed = 123)

## End(Not run)
</code></pre>

<hr>
<h2 id='HTP'>
Production Measurements of High-Tech Parts - Full Rank Case
</h2><span id='topic+HTP'></span>

<h3>Description</h3>

<p>The <code>HTP</code> data set contains 902 high-tech parts designed for consumer products characterized by 88 tests. These tests are performed to ensure a high quality 
of the production. All these 902 parts were considered functional and have been sold.  However the two parts 581 and 619 
showed defects in use and were returned to the manufacturer by the customer. Therefore these two can be considered as outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HTP")</code></pre>


<h3>Format</h3>

<p>A data frame with 902 observations and 88 numeric variables V.1 - V.88.
</p>


<h3>Source</h3>

<p>Anonymized data from a nondisclosed manufacturer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HTP data: the observations 581 and 619 are considered as outliers
data(HTP)
outliers &lt;- c(581, 619)
boxplot(HTP)


# Outlier detection using ICS
icsHTP &lt;- ics2(HTP)
# Selection of components based on a Normality Test, for demo purpose only small mDist value,
# but as extreme quantiles are of interest mDist should be much larger.
# Also more cores could be used if available.
icsOutlierDA &lt;- ics.outlier(icsHTP, test = "agostino.test", level.test = 0.05,
                            level.dist = 0.02, mDist = 50, ncores = 1)
icsOutlierDA
summary(icsOutlierDA)
plot(icsOutlierDA)
text(outliers, icsOutlierDA@ics.distances[outliers], outliers, pos = 2, cex = 0.9, col = 2)

## Not run: 
# Selection of components based on simulations
# This might take a while to run (around 30 minutes)
icsOutlierPA &lt;- ics.outlier(icsHTP, method = "simulation", level.dist = 0.02,
level.test = 0.05, mEig = 10000, mDist = 10000)
icsOutlierPA
summary(icsOutlierPA)
plot(icsOutlierPA)
text(outliers, icsOutlierPA@ics.distances[outliers], outliers, pos = 2, cex = 0.9, col = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='HTP2'>Production Measurements of High-Tech Parts - Singular Case</h2><span id='topic+HTP2'></span>

<h3>Description</h3>

<p>The <code>HTP2</code> data set contains 457 high-tech parts designed for consumer
products characterized by 149 tests.
These tests are performed to ensure a high quality of the production.
All these 457 parts were considered functional and have been sold.
However the part 28 showed defects in use and was
returned to the manufacturer by the customer. Therefore this part
can be considered as outlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HTP2")
</code></pre>


<h3>Format</h3>

<p>A data frame with 457 rows and 149 variables V.1 - V.149, presenting
some collinearity issues.
</p>


<h3>Source</h3>

<p>Anonymized data from a nondisclosed manufacturer.
</p>


<h3>References</h3>

<p>Archimbaud, A., Drmac, Z., Nordhausen, K., Radojcic, U. and Ruiz-Gazen, A.
(2023) Numerical Considerations and a New Implementation for Invariant
Coordinate Selection. <em>SIAM Journal on Mathematics of Data Science</em>,
<b>5</b>(1), 97&ndash;121. <a href="https://doi.org/10.1137/22M1498759">doi:10.1137/22M1498759</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HTP2 data: the observation 28 is considered as an outlier
data("HTP2")
outliers &lt;- c(28)
boxplot(HTP2, horizontal = TRUE)
# Outlier detection using ICS
library(ICS)
## Not run: 
out &lt;- ICS_outlier(HTP2, ICS_algorithm = "QR",
                   method = "norm_test",
                   test = "agostino.test", level_test = 0.05,
                   level_dist = 0.01, n_dist = 50)

# Here there is a singularity issue. One solution is to first reduce the 
# dimension. To ensure higher numerical stability of the subsequent methods
# we suggest to permute the data and to use the QR decomposition instead of
# the regular SVD decomposition.
Xt &lt;- HTP2
# Normalization by the mean 
Xt.c &lt;- sweep(HTP2, 2, colMeans(HTP2), "-")

# Permutation by rows 
# decreasing by infinity norm:  absolute maximum
norm_inf &lt;- apply(Xt.c, 1, function(x) max(abs(x)))
order_rows &lt;- order(norm_inf, decreasing = TRUE)
Xt_row_per &lt;- Xt.c[order_rows,]

# QR decomposition of Xt with column pivoting from LAPACK 
qr_Xt &lt;- qr(1/sqrt(nrow(Xt.c)-1)*Xt_row_per, LAPACK = TRUE)

# Estimation of rank q 
# R is nxp, but with only zero for rows &gt; p
# the diag of R is already in decreasing order and is a good approximation
# of the rank of X.c. To decide on which singular values are zero we use
# a relative criteria based on previous values.
# R should be pxp
R &lt;- qr.R(qr_Xt)
r_all &lt;- abs(diag(R))
r_ratios &lt;- r_all[2:length(r_all)]/r_all[1:(length(r_all)-1)]
q &lt;- which(r_ratios &lt; max(dim(Xt.c)) *.Machine$double.eps)[1]
q &lt;- ifelse(is.na(q), length(r_all), q)

# Q should be nxp but we are only interested in nxq
Q1 &lt;- qr.Q(qr_Xt)[,1:q]

# QR decomposition of Rt 
R_q &lt;- R[1:q, ]
qr_R &lt;- qr(t(R_q), LAPACK = TRUE)
Tau &lt;- qr.Q(qr_R)[1:q, ]
Omega1 &lt;- qr.R(qr_R)[1:q, 1:q]

# New X tilde 
# permutation matrices
# permutation of rows
Pi2 &lt;- data.frame(model.matrix(~ . -1, data = data.frame(row=as.character(order_rows))))
Pi2 &lt;- Pi2[,order(as.numeric(substr(colnames(Pi2), start = 4, stop = nchar(colnames(Pi2)))))]
colnames(Pi2) &lt;- rownames(Xt)

# permutation of cols
Pi3 &lt;- data.frame(model.matrix(~ . -1, data = data.frame(col=as.character( qr_R$pivot))))
Pi3 &lt;- t(Pi3[,order(as.numeric(substr(colnames(Pi3), start = 4, stop = nchar(colnames(Pi3)))))])

X_tilde &lt;- sqrt(nrow(Xt)-1)* Tau %*% t(Pi3) %*% t(Q1)

Xt_tilde &lt;- t(Pi2) %*% t(X_tilde)

# Run ICS_outlier
out &lt;- ICS_outlier(Xt_tilde, ICS_algorithm = "QR",
method = "norm_test",
test = "agostino.test", level_test = 0.01,
level_dist = 0.01, n_dist = 50)

summary(out)
plot(out)
text(outliers, out$ics_distances[outliers], outliers, pos = 2, cex = 0.9, col = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='HTP3'>Production Measurements of High-Tech Parts - Nearly Singular Case</h2><span id='topic+HTP3'></span>

<h3>Description</h3>

<p>The <code>HTP3</code> data set contains 371 high-tech parts designed for consumer
products characterized by 33 tests.
These tests are performed to ensure a high quality of the production.
All these 371 parts were considered functional and have been sold.
However the part 32 showed defects in use and was
returned to the manufacturer by the customer. Therefore this part
can be considered as outlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HTP3")
</code></pre>


<h3>Format</h3>

<p>A data frame with 371 rows and 33 variables V.1 - V.33,
presenting some approximate collinearity issues which may cause
some numerical inaccuracies.
</p>


<h3>Source</h3>

<p>Anonymized data from a nondisclosed manufacturer.
</p>


<h3>References</h3>

<p>Archimbaud, A., Drmac, Z., Nordhausen, K., Radojcic, U. and Ruiz-Gazen, A.
(2023) Numerical Considerations and a New Implementation for Invariant
Coordinate Selection. <em>SIAM Journal on Mathematics of Data Science</em>,
<b>5</b>(1), 97&ndash;121. <a href="https://doi.org/10.1137/22M1498759">doi:10.1137/22M1498759</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HTP3 data: the observation 32 is considered as an outlier
data("HTP3")
outliers &lt;- c(32)
boxplot(HTP3)

# Outlier detection using ICS
library(ICS)
out &lt;- ICS_outlier(HTP3, ICS_algorithm = "QR",
                   method = "norm_test",
                   test = "agostino.test", level_test = 0.05,
                   level_dist = 0.01, n_dist = 50)

summary(out)
plot(out)
text(outliers, out$ics_distances[outliers], outliers, pos = 2, cex = 0.9, col = 2)

</code></pre>

<hr>
<h2 id='ics_distances'>Squared ICS Distances for Invariant Coordinates</h2><span id='topic+ics_distances'></span>

<h3>Description</h3>

<p>Squared ICS Distances for Invariant Coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics_distances(object, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics_distances_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code> where both <code>S1</code> and <code>S2</code> are specified as functions.</p>
</td></tr>
<tr><td><code id="ics_distances_+3A_index">index</code></td>
<td>
<p>vector of integers indicating the indices of the components to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For outlier detection, the squared ICS distances can be used as a measure of outlierness. Denote as <code class="reqn">Z</code> the invariant coordinates centered with the location estimate specified in <code>S1</code> (for details see <a href="ICS.html#topic+ICS-S3">ICS()</a>). Let <code class="reqn">Z_k</code> be the <code class="reqn">k</code> components of <code class="reqn">Z</code> selected by <code>index</code>, then the ICS distance of the observation <code class="reqn">i</code>  is defined as:     </p>
<p style="text-align: center;"><code class="reqn">ICSD^2(x_i,k) = || Z_k||^2.</code>
</p>

<p>Note that if all components are selected, the ICS distances are equivalent to the Mahalanobis distances computed with respect of the first scatter and associated location specified in <code>S1</code>.
</p>


<h3>Value</h3>

<p>A numeric vector containing the squared ICS distances.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>


<h3>See Also</h3>

<p><a href="ICS.html#topic+ICS-S3">ICS()</a>, <code><a href="stats.html#topic+mahalanobis">mahalanobis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rmvnorm(1000, rep(0, 6))
Z[1:20, 1] &lt;- Z[1:20, 1] + 5
A &lt;- matrix(rnorm(36), ncol = 6)
X &lt;- tcrossprod(Z, A)

pairs(X)
icsX &lt;- ICS(X, center = TRUE)

icsX.dist.all &lt;- ics_distances(icsX, index = 1:6)
maha &lt;- mahalanobis(X, center = colMeans(X), cov = cov(X))
# in this case the distances should be the same
plot(icsX.dist.all, maha)
all.equal(icsX.dist.all, maha)

icsX.dist.first &lt;- ics_distances(icsX, index = 1)
plot(icsX.dist.first)
</code></pre>

<hr>
<h2 id='ICS_outlier'>Outlier Detection Using ICS</h2><span id='topic+ICS_outlier'></span>

<h3>Description</h3>

<p>In a multivariate framework outlier(s) are detected using ICS. The function performs <a href="ICS.html#topic+ICS-S3">ICS()</a> and decides automatically about the number of invariant components to use to search for the outliers and the number of outliers detected on these components. Currently the function is restricted to the case of searching outliers only on the first components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_outlier(
  X,
  S1 = ICS_cov,
  S2 = ICS_cov4,
  S1_args = list(),
  S2_args = list(),
  ICS_algorithm = c("whiten", "standard", "QR"),
  method = "norm_test",
  test = "agostino.test",
  n_eig = 10000,
  level_test = 0.05,
  adjust = TRUE,
  level_dist = 0.025,
  n_dist = 10000,
  type = "smallprop",
  n_cores = NULL,
  iseed = NULL,
  pkg = "ICSOutlier",
  q_type = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICS_outlier_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame containing the data to be
transformed.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_s1">S1</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_s2">S2</code></td>
<td>
<p>an object of class <code>"ICS_scatter"</code> or a function that
contains the location vector and scatter matrix as <code>location</code> and <code>scatter</code> components.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_s1_args">S1_args</code></td>
<td>
<p>a list containing additional arguments for <code>S1</code>.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_s2_args">S2_args</code></td>
<td>
<p>a list containing additional arguments for <code>S2</code>.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_ics_algorithm">ICS_algorithm</code></td>
<td>
<p>a character string specifying with which algorithm
the invariant coordinate system is computed. Possible values are
<code>"whiten"</code>, <code>"standard"</code> or <code>"QR"</code>.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_method">method</code></td>
<td>
<p>name of the method used to select the ICS components involved to compute ICS distances. Options are <code>"norm_test"</code> and <code>"simulation"</code>. Depending on the method either <code><a href="#topic+comp_norm_test">comp_norm_test</a></code> or <code><a href="#topic+comp_simu_test">comp_simu_test</a></code> are used.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_test">test</code></td>
<td>
<p>name of the marginal normality test to use if <code>method = "norm_test"</code>. Possibilities are <code>"jarque.test"</code>, <code>"anscombe.test"</code>, <code>"bonett.test"</code>, <code>"agostino.test"</code>, <code>"shapiro.test"</code>.Default is <code>"agostino.test"</code>.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_n_eig">n_eig</code></td>
<td>
<p>number of simulations performed to derive the cut-off values for selecting the ICS components. Only if <code>method = "simulation"</code>. See <code><a href="#topic+comp_simu_test">comp_simu_test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_level_test">level_test</code></td>
<td>
<p>for the <code><a href="#topic+comp_norm_test">comp_norm_test</a></code> or <code><a href="#topic+comp_simu_test">comp_simu_test</a></code> functions. The initial level for selecting the invariant coordinates.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_adjust">adjust</code></td>
<td>
<p>logical. For selecting the invariant coordinates, the level of the test can be adjusted for each component to deal with multiple testing. See <code><a href="#topic+comp_norm_test">comp_norm_test</a></code> and <code><a href="#topic+comp_simu_test">comp_simu_test</a></code> for details. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_level_dist">level_dist</code></td>
<td>
<p><code>level</code> for the <code><a href="#topic+dist_simu_test">dist_simu_test</a></code> function.  The (1-<code>level</code>)th quantile used to determine the cut-off value for the ICS distances.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_n_dist">n_dist</code></td>
<td>
<p>number of simulations performed to derive the cut-off value for the ICS distances. See <code><a href="#topic+dist_simu_test">dist_simu_test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_type">type</code></td>
<td>
<p>currently the only option is <code>"smallprop"</code> which means that only the first ICS components can be selected. See  <code><a href="#topic+comp_norm_test">comp_norm_test</a></code> or <code><a href="#topic+comp_simu_test">comp_simu_test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores to be used in <code><a href="#topic+dist_simu_test">dist_simu_test</a></code> and <code><a href="#topic+comp_simu_test">comp_simu_test</a></code>. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot; and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_q_type">q_type</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="ICS_outlier_+3A_...">...</code></td>
<td>
<p>passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ICS method has attractive properties for outlier detection in the case of a small proportion of outliers. As for PCA three steps have to be performed:(i) select the components most useful for the detection, (ii) compute distances as outlierness measures for all observation and finally (iii) label outliers using some cut-off value.
</p>
<p>This function performs these three steps automatically:
</p>

<ul>
<li><p> For choosing the components of interest two methods are proposed: <code>"norm_test"</code> based on some marginal normality tests (see details in <code><a href="#topic+comp_norm_test">comp_norm_test</a></code>) or <code>"simulation"</code> based on a parallel analysis (see details in <code><a href="#topic+comp_simu_test">comp_simu_test</a></code>). These two approaches lie on the intrinsic property of ICS in case of a small proportion of outliers with the choice of S1 &quot;more robust&quot; than S2, which ensures to find outliers on the first components. Indeed  when using <code>S1 = ICS_cov</code> and <code>S2 = ICS_cov4</code>, the Invariant Coordinates are ordered according to their classical Pearson kurtosis values in decreasing order. The information to find the outliers should be then contained in the first k non-normal directions.
</p>
</li>
<li><p> Then the ICS distances are computed as the Euclidean distances on the selected k centered components <code class="reqn">Z_k</code>.
</p>
</li>
<li><p> Finally the outliers are identified based on a cut-off derived from simulations. If the distance of an observation exceeds the expectation under the normal model, this observation is labeled as outlier (see details in <code><a href="#topic+dist_simu_test">dist_simu_test</a></code>).
</p>
</li></ul>

<p>As a rule of thumb, the percentage of contamination should be limited to 10% in case of a mixture of gaussian distributions and using the default combination of locations and scatters for ICS.
</p>


<h3>Value</h3>

<p>An object of S3-class 'ICS_Out' which contains:
</p>

<ul>
<li> <p><code>outliers</code>:  A vector containing ones for outliers and zeros for non outliers.
</p>
</li>
<li> <p><code>ics_distances</code>:  A numeric vector containing the squared ICS distances.
</p>
</li>
<li> <p><code>ics_dist_cutoff</code>:  The cut-off for the distances to decide if an observation is outlying or not.
</p>
</li>
<li> <p><code>level_dist</code>:  The level for deciding upon the cut-off value for the ICS distances.
</p>
</li>
<li> <p><code>level_test</code>:  The initial level for selecting the invariant coordinates.
</p>
</li>
<li> <p><code>method</code>: Name of the method used to decide upon the number of ICS components.
</p>
</li>
<li> <p><code>index</code>: Vector giving the indices of the ICS components selected.
</p>
</li>
<li> <p><code>test</code>:  The name of the normality test as specified in the function call.
</p>
</li>
<li> <p><code>criterion</code>:  Vector giving the marginal levels for the components selection.
</p>
</li>
<li> <p><code>adjust</code>:  Wether the initial level used to decide upon the number of components has been adjusted for multiple testing or not.
</p>
</li>
<li> <p><code>type</code>:  Currently always the string <code>"smallprop"</code>.
</p>
</li>
<li> <p><code>n_dist</code>: Number of simulations performed to decide upon the cut-off for the ICS distances.
</p>
</li>
<li> <p><code>n_eig</code>:  Number of simulations performed for selecting the ICS components based on simulations.
</p>
</li>
<li> <p><code>S1_label</code>:  Name of S1.
</p>
</li>
<li> <p><code>S2_label </code>: Name of S2.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  <a href="https://doi.org/10.1016/j.csda.2018.06.011">doi:10.1016/j.csda.2018.06.011</a>.
</p>


<h3>See Also</h3>

<p><a href="ICS.html#topic+ICS-S3">ICS()</a>, <code><a href="#topic+comp_norm_test">comp_norm_test()</a></code>, <code><a href="#topic+comp_simu_test">comp_simu_test()</a></code>,
<code><a href="#topic+dist_simu_test">dist_simu_test()</a></code> and
<a href="#topic+print.ICS_Out">print()</a>, <a href="#topic+plot.ICS_Out">plot()</a>, <a href="#topic+summary.ICS_Out">summary()</a> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ReliabilityData example: the observations 414 and 512 are suspected to be outliers  
library(REPPlab)
data(ReliabilityData)
# For demo purpose only small mDist value, but as extreme quantiles
# are of interest mDist should be much larger. Also number of cores used
# should be larger if available
icsOutlierDA &lt;- ICS_outlier(ReliabilityData, S1 = ICS_tM, S2 = ICS_cov, 
level_dist = 0.01, n_dist = 50, n_cores = 1)
icsOutlierDA
summary(icsOutlierDA)
plot(icsOutlierDA)

## Not run: 
  # For using several cores and for using a scatter function from a different package
  # Using the parallel package to detect automatically the number of cores
  library(parallel)
  # ICS with MCD estimates and the usual estimates
  # Need to create a wrapper for the CovMcd function to return first the location estimate
  # and the scatter estimate secondly.
  data(HTP)
 library(ICSClust)
  # For demo purpose only small m value, should select the first seven components
  icsOutlier &lt;- ICS_outlier(HTP, S1 = ICS_mcd_rwt, S2 = ICS_cov,
                            S1_args = list(location = TRUE, alpha = 0.75),
                            n_eig = 50, level_test = 0.05, adjust = TRUE,
                            level_dist = 0.025, n_dist = 50,
                            n_cores =  detectCores()-1, iseed = 123,
                            pkg = c("ICSOutlier", "ICSClust"))
  icsOutlier

## End(Not run)

# Exemple of no direction and hence also no outlier
set.seed(123)
X = rmvnorm(500, rep(0, 2), diag(rep(0.1,2)))
icsOutlierJB &lt;- ICS_outlier(X, test = "jarque.test", level_dist = 0.01,
                            level_test = 0.01, n_dist = 100, n_cores = 1)
summary(icsOutlierJB)
plot(icsOutlierJB)
rm(.Random.seed)

# Example of no outlier
set.seed(123)
X = matrix(rweibull(1000, 4, 4), 500, 2)
X = apply(X,2, function(x){ifelse(x&lt;5 &amp; x&gt;2, x, runif(sum(!(x&lt;5 &amp; x&gt;2)), 5, 5.5))})
icsOutlierAG &lt;- ICS_outlier(X, test = "anscombe.test", level_dist = 0.01,
                            level_test = 0.05, n_dist = 100, n_cores = 1)
summary(icsOutlierAG)
plot(icsOutlierAG)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='ics.distances'>
Squared ICS Distances for Invariant Coordinates
</h2><span id='topic+ics.distances'></span>

<h3>Description</h3>

<p>Computes the squared ICS distances, defined as the Euclidian distances of the selected centered components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics.distances(object, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics.distances_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code> where both <code>S1</code> and <code>S2</code> are specified as functions.</p>
</td></tr>
<tr><td><code id="ics.distances_+3A_index">index</code></td>
<td>
<p>vector of integers indicating the indices of the components to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For outlier detection, the squared ICS distances can be used as a measure of outlierness. Denote as <code class="reqn">Z</code>
the invariant coordinates centered with the location estimate specified in <code>S1</code> (for details see <code><a href="ICS.html#topic+ics2">ics2</a></code>).
Let <code class="reqn">Z_k</code> be the <code class="reqn">k</code> components of <code class="reqn">Z</code> selected by <code>index</code>, then the ICS distance of the observation <code class="reqn">i</code> 
is defined as: 
</p>
<p style="text-align: center;"><code class="reqn">ICSD^2(x_i,k) = || Z_k||^2.</code>
</p>

<p>Note that if all components are selected, the ICS distances are equivalent to the Mahlanobis distances computed with
respect of the first scatter and associated location specified in <code>S1</code>. 
</p>


<h3>Value</h3>

<p>A numeric vector containing the squared ICS distances.
</p>


<h3>Note</h3>

<p>Function <code>ics.distances()</code> reached the end of its lifecycle, please use <code><a href="#topic+ics_distances">ics_distances</a></code> instead. In future versions, <code>ics_distances()</code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  &lt;https://doi.org/10.1016/j.csda.2018.06.011&gt;.</cite>   
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ics2">ics2</a></code>, <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- rmvnorm(1000, rep(0, 6))
Z[1:20, 1] &lt;- Z[1:20, 1] + 5
A &lt;- matrix(rnorm(36), ncol = 6)
X &lt;- tcrossprod(Z, A)

pairs(X)
icsX &lt;- ics2(X)

icsX.dist.all &lt;- ics.distances(icsX, index = 1:6)
maha &lt;- mahalanobis(X, center = colMeans(X), cov = cov(X))
# in this case the distances should be the same
plot(icsX.dist.all, maha)
all.equal(icsX.dist.all, maha)

icsX.dist.first &lt;- ics.distances(icsX, index = 1)
plot(icsX.dist.first)



</code></pre>

<hr>
<h2 id='ics.outlier'>
Outlier Detection Using ICS
</h2><span id='topic+ics.outlier'></span>

<h3>Description</h3>

<p>In a multivariate framework outlier(s) are detected using ICS. The function works on an object of class <code><a href="ICS.html#topic+ics2">ics2</a></code>
and decides automatically about the number of invariant components to use to search for the outliers and the number of outliers
detected on these components. Currently the function is restricted to the case of searching outliers only on the first components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics.outlier(object, method = "norm.test", test = "agostino.test", mEig = 10000,
  level.test = 0.05, adjust = TRUE, level.dist = 0.025, mDist = 10000,
  type = "smallprop", ncores = NULL, iseed = NULL, pkg = "ICSOutlier", 
  qtype = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ics.outlier_+3A_object">object</code></td>
<td>
<p>object of class <code>ics2</code> where both <code>S1</code> and <code>S2</code> are specified as functions.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_method">method</code></td>
<td>
<p>name of the method used to select the ICS components involved to compute ICS distances. Options are 
<code>"norm.test"</code> and <code>"simulation"</code>. Depending on the method either <code><a href="#topic+comp.norm.test">comp.norm.test</a></code> or <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> are used.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_test">test</code></td>
<td>
<p>name of the marginal normality test to use if <code>method = "norm.test"</code>. Possibilities are 
<code>"jarque.test"</code>, <code>"anscombe.test"</code>, <code>"bonett.test"</code>, <code>"agostino.test"</code>, <code>"shapiro.test"</code>.
Default is <code>"agostino.test"</code>.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_meig">mEig</code></td>
<td>
<p>number of simulations performed to derive the cut-off values for selecting the ICS components. Only if <code>method = "simulation"</code>.
See <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_level.test">level.test</code></td>
<td>
<p><code>level</code> for the <code><a href="#topic+comp.norm.test">comp.norm.test</a></code> or <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> functions. The inital level for selecting the invariant coordinates.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_adjust">adjust</code></td>
<td>
<p>logical. For selecting the invariant coordinates, the level of the test can be adjusted for each component to deal with multiple testing. See <code><a href="#topic+comp.norm.test">comp.norm.test</a></code> and <code><a href="#topic+comp.simu.test">comp.simu.test</a></code>
for details. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_level.dist">level.dist</code></td>
<td>
<p><code>level</code> for the <code><a href="#topic+dist.simu.test">dist.simu.test</a></code> function.  The (1-<code>level</code>)th quantile used to determine the cut-off value for the ICS distances.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_mdist">mDist</code></td>
<td>
<p>number of simulations performed to derive the cut-off value for the ICS distances.
See <code><a href="#topic+dist.simu.test">dist.simu.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_type">type</code></td>
<td>
<p>currently the only option is <code>"smallprop"</code> which means that only the first ICS components can be selected. See  <code><a href="#topic+comp.norm.test">comp.norm.test</a></code>
or <code><a href="#topic+comp.simu.test">comp.simu.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to be used in <code><a href="#topic+dist.simu.test">dist.simu.test</a></code> and <code><a href="#topic+comp.simu.test">comp.simu.test</a></code>. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <a href="parallel.html#topic+makeCluster">makeCluster</a> with <code>type = "PSOCK"</code> is used.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_iseed">iseed</code></td>
<td>
<p>If parallel computation is used the seed passed on to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>. Default is NULL which means no fixed seed is used.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_pkg">pkg</code></td>
<td>
<p>When using parallel computing, a character vector listing all the packages which need to be loaded on the different cores via <code><a href="base.html#topic+require">require</a></code>. Must be at least &quot;ICSOutlier&quot;
and must contain the packages needed to compute the scatter matrices.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_qtype">qtype</code></td>
<td>
<p>specifies the quantile algorithm used in <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="ics.outlier_+3A_...">...</code></td>
<td>
<p>passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ICS method has attractive properties for outlier detection in the case of a small proportion of outliers. As for PCA three steps have to be performed:
(i) select the components most useful for the detection, (ii) compute distances as outlierness measures for all observation and finally (iii) label outliers using some cut-off value.
</p>
<p>This function performs these three steps automatically:
</p>

<dl>
<dt>(i)</dt><dd><p>For choosing the components of interest two methods are proposed: <code>"norm.test"</code> based on some marginal normality tests (see details in <code><a href="#topic+comp.norm.test">comp.norm.test</a></code>)
or <code>"simulation"</code> based on a parallel analysis (see details in <code><a href="#topic+comp.simu.test">comp.simu.test</a></code>). These two approaches lie on the intrinsic property of ICS in case of a small proportion 
of outliers with the choice of S1 &quot;more robust&quot; than S2, which ensures to find outliers on the first components. Indeed  when using <code>S1 = MeanCov</code> and <code>S2 = Mean3Cov4</code>, 
the Invariant Coordinates are ordered according to their classical Pearson kurtosis values in decreasing order. The information to find the outliers should be then contained in the first
k nonnormal directions.</p>
</dd>
<dt>(ii)</dt><dd><p>Then the ICS distances are computed as the Euclidian distances on the selected k centered components <code class="reqn">Z_k</code>. </p>
</dd>
<dt>(iii)</dt><dd><p>Finally the outliers are identified based on a cut-off derived from simulations. If the distance of an observation exceeds the expectation under the normal model, 
this observation is labeled as outlier (see details in <code><a href="#topic+dist.simu.test">dist.simu.test</a></code>).</p>
</dd>
</dl>

<p>As a rule of thumb, the percentage of contamination should be limited to 10% in case of a mixture of gaussian distributions and using the default combination of locations and scatters for ICS.
</p>


<h3>Value</h3>

<p>an object of class <code>icsOut</code>
</p>


<h3>Note</h3>

<p>Function <code><a href="#topic+ics.outlier">ics.outlier</a></code> reached the end of its lifecycle, please use <code><a href="#topic+ICS_outlier">ICS_outlier</a></code> instead. In future versions, <code><a href="#topic+ics.outlier">ics.outlier</a></code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICS for multivariate outlier detection with application to quality control. Computational Statistics &amp; Data Analysis, 128:184-199. ISSN 0167-9473.  &lt;https://doi.org/10.1016/j.csda.2018.06.011&gt;.</cite>   
</p>
<p><cite>Archimbaud, A., Nordhausen, K. and Ruiz-Gazen, A. (2018), ICSOutlier: Unsupervised Outlier Detection for Low-Dimensional Contamination Structure. The R Journal, 10:234-250.  &lt;doi:10.32614/RJ-2018-034&gt;.</cite>   
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ics2">ics2</a></code>, <code><a href="#topic+comp.norm.test">comp.norm.test</a></code>, <code><a href="#topic+comp.simu.test">comp.simu.test</a></code>, <code><a href="#topic+dist.simu.test">dist.simu.test</a></code>,
<code><a href="#topic+icsOut-class">icsOut-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ReliabilityData example: the observations 414 and 512 are suspected to be outliers  
library(REPPlab)
data(ReliabilityData)
icsReliabilityData &lt;- ics2(ReliabilityData, S1 = tM, S2 = MeanCov)
# For demo purpose only small mDist value, but as extreme quantiles 
# are of interest mDist should be much larger. Also number of cores used
# should be larger if available
icsOutlierDA &lt;- ics.outlier(icsReliabilityData, level.dist = 0.01, mDist = 50, ncores = 1)
icsOutlierDA
summary(icsOutlierDA)
plot(icsOutlierDA)

## Not run: 
# For using several cores and for using a scatter function from a different package
# Using the parallel package to detect automatically the number of cores
library(parallel)
# ICS with MCD estimates and the usual estimates
# Need to create a wrapper for the CovMcd function to return first the location estimate
# and the scatter estimate secondly.
data(HTP)
library(rrcov)
myMCD &lt;- function(x,...){
  mcd &lt;- CovMcd(x,...)
  return(list(location = mcd@center, scatter = mcd@cov))
}
icsHTP &lt;- ics2(HTP, S1 = myMCD, S2 = MeanCov, S1args = list(alpha = 0.75))
# For demo purpose only small m value, should select the first seven components
icsOutlier &lt;- ics.outlier(icsHTP, mEig = 50, level.test = 0.05, adjust = TRUE, 
                          level.dist = 0.025, mDist = 50,
                          ncores =  detectCores()-1, iseed = 123, 
                          pkg = c("ICSOutlier", "rrcov"))
icsOutlier

## End(Not run)
  
# Exemple of no direction and hence also no outlier
set.seed(123)
X = rmvnorm(500, rep(0, 2), diag(rep(0.1,2)))
icsX &lt;- ics2(X)
icsOutlierJB &lt;- ics.outlier(icsX, test = "jarque", level.dist = 0.01, 
				level.test = 0.01, mDist = 100, ncores = 1)
summary(icsOutlierJB)
plot(icsOutlierJB)
rm(.Random.seed)

     

# Example of no outlier
set.seed(123)
X = matrix(rweibull(1000, 4, 4), 500, 2)
X = apply(X,2, function(x){ifelse(x&lt;5 &amp; x&gt;2, x, runif(sum(!(x&lt;5 &amp; x&gt;2)), 5, 5.5))}) 
icsX &lt;- ics2(X)
icsOutlierAG &lt;- ics.outlier(icsX, test = "anscombe", level.dist = 0.01, 
				level.test = 0.05, mDist = 100, ncores = 1)
summary(icsOutlierAG)
plot(icsOutlierAG)
rm(.Random.seed)
  

</code></pre>

<hr>
<h2 id='icsOut-class'>Class icsOut</h2><span id='topic+icsOut-class'></span>

<h3>Description</h3>

<p>A S4 class to store results from performing outlier detection in an ICS context.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("icsOut", ...)</code>. But usually objects are created by the function <code><a href="#topic+ics.outlier">ics.outlier</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>outliers</code>:</dt><dd><p>Object of class <code>"integer"</code>. A vector containing ones for outliers and zeros for non outliers.</p>
</dd>
<dt><code>ics.distances</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector giving the squared ICS distances of the observations from the invariant coordinates centered with the location estimate specified in <code>S1</code>.</p>
</dd>
<dt><code>ics.dist.cutoff</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The cut-off for the distances to decide if an observation is outlying or not.</p>
</dd>
<dt><code>level.dist</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The level for deciding upon the cut-off value for the ICS distances.</p>
</dd>
<dt><code>level.test</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The inital level for selecting the invariant coordinates.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of the method used to decide upon the number of ICS components.</p>
</dd>
<dt><code>index</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector giving the indices of the ICS components selected.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>Object of class <code>"character"</code>. The name of the normality test as specified in the function call.</p>
</dd>
<dt><code>criterion</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector giving the marginal levels for the components selection.</p>
</dd>
<dt><code>adjust</code>:</dt><dd><p>Object of class <code>"logical"</code>. Wether the initial level used to decide upon the number of components has been adjusted for multiple testing or not.</p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>. Currently always the string <code>"smallprop"</code>.</p>
</dd>
<dt><code>mDist</code>:</dt><dd><p>Object of class <code>"integer"</code>. Number of simulations performed to decide upon the cut-off for the ICS distances.</p>
</dd>
<dt><code>mEig</code>:</dt><dd><p>Object of class <code>"integer"</code>. Number of simulations performed for selecting the ICS components based on simulations.</p>
</dd>
<dt><code>S1name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of S1 in the original ics2 object.</p>
</dd>
<dt><code>S2name</code>:</dt><dd><p>Object of class <code>"character"</code>. Name of S2 in the original ics2 object.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>For this class the following generic functions are available: <code><a href="#topic+print.icsOut">print.icsOut</a></code>, <code><a href="#topic+summary.icsOut">summary.icsOut</a></code> and <code><a href="ICS.html#topic+plot.ics">plot.ics</a></code>
</p>


<h3>Note</h3>

<p>In case no extractor function for the slots exists, the component can be extracted the usual way using '@'. This S4 class is created by  <code><a href="#topic+ics.outlier">ics.outlier</a></code> that reached the end of its lifecycle, please use  <code><a href="#topic+ICS_outlier">ICS_outlier</a></code> instead for which an object of class S3 is returned. In future versions,  <code><a href="#topic+ics.outlier">ics.outlier</a></code> will be deprecated and eventually removed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+ics.outlier">ics.outlier</a></code></p>

<hr>
<h2 id='plot.ICS_Out'>Distances Plot for an 'ICS_Out' Object</h2><span id='topic+plot.ICS_Out'></span>

<h3>Description</h3>

<p>Distances plot for an 'ICS_Out' object visualizing the separation of the outliers from the good data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS_Out'
plot(
  x,
  pch.out = 16,
  pch.good = 4,
  col.out = 1,
  col.good = grey(0.5),
  col.cut = 1,
  lwd.cut = 1,
  lty.cut = 1,
  xlab = "Observation Number",
  ylab = "ICS distances",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ICS_Out_+3A_x">x</code></td>
<td>
<p>object of class <code>"ICS_Out"</code>.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_pch.out">pch.out</code></td>
<td>
<p>plotting symbol for the outliers.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_pch.good">pch.good</code></td>
<td>
<p>plotting symbol for the 'good' data points.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_col.out">col.out</code></td>
<td>
<p>color for the outliers.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_col.good">col.good</code></td>
<td>
<p>color for the 'good' data points.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_col.cut">col.cut</code></td>
<td>
<p>color for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_lwd.cut">lwd.cut</code></td>
<td>
<p>lwd value for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_lty.cut">lty.cut</code></td>
<td>
<p>lty value for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_xlab">xlab</code></td>
<td>
<p>default x-axis label.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_ylab">ylab</code></td>
<td>
<p>default y-axis label.</p>
</td></tr>
<tr><td><code id="plot.ICS_Out_+3A_...">...</code></td>
<td>
<p>other arguments for <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the figure the IC distances are plotted versus their index. The cut-off value for distances is given as a horizontal line and all observations above the line are considered as outliers.
</p>


<h3>Value</h3>

<p>A plot is displayed.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>

<hr>
<h2 id='plot.icsOut'>Distances Plot for an icsOut Object</h2><span id='topic+plot-icsOut'></span><span id='topic+plot.icsOut'></span><span id='topic+plot-method'></span><span id='topic+plot+2CicsOut+2Cmissing-method'></span>

<h3>Description</h3>

<p>Distances plot for an icsOut object visualizing the separation of the outliers from the good data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'icsOut,missing'
plot(x, pch.out = 16, pch.good = 4, col.out = 1, col.good = grey(0.5), 
     col.cut = 1, lwd.cut = 1, lty.cut = 1, xlab = "Observation Number", 
     ylab = "ICS distances", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.icsOut_+3A_x">x</code></td>
<td>
<p>object of class <code>icsOut</code>.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_pch.out">pch.out</code></td>
<td>
<p>ploting symbol for the outliers.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_pch.good">pch.good</code></td>
<td>
<p>plotting symbol for the &lsquo;good&rsquo; data points.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_col.out">col.out</code></td>
<td>
<p>color for the outliers.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_col.good">col.good</code></td>
<td>
<p>color for the &lsquo;good&rsquo; data points.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_col.cut">col.cut</code></td>
<td>
<p>color for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_lwd.cut">lwd.cut</code></td>
<td>
<p>lwd value for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_lty.cut">lty.cut</code></td>
<td>
<p>lty value for cut-off line.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_xlab">xlab</code></td>
<td>
<p>default x-axis label.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_ylab">ylab</code></td>
<td>
<p>default y-axis label.</p>
</td></tr>
<tr><td><code id="plot.icsOut_+3A_...">...</code></td>
<td>
<p>other arguments for <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the figure the IC distances are plotted versus their index. The cut-off value for distances is given as a horizontal line
and all observations above the line are considered as outliers.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+icsOut-class">icsOut-class</a></code> and <code><a href="#topic+ics.outlier">ics.outlier</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    Z &lt;- rmvnorm(1000, rep(0, 6))
    Z[1:20, 1] &lt;- Z[1:20, 1] + 10
    A &lt;- matrix(rnorm(36), ncol = 6)
    X &lt;- tcrossprod(Z, A)
    icsX &lt;- ics2(X)
    # For demonstation purposes mDist is small, should be larger for real data analysis
    icsXoutliers &lt;- ics.outlier(icsX, mDist = 500)
    plot(icsXoutliers, col.out = 2)
</code></pre>

<hr>
<h2 id='print.ICS_Out'>Vector of Outlier Indicators</h2><span id='topic+print.ICS_Out'></span>

<h3>Description</h3>

<p>Short statement about how many components are selected for the outlier detection and how many outliers are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS_Out'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ICS_Out_+3A_x">x</code></td>
<td>
<p>object object of class <code>"ICS_Out"</code>.</p>
</td></tr>
<tr><td><code id="print.ICS_Out_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The supplied object of class <code>"ICS_Out_summary"</code> is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>

<hr>
<h2 id='print.icsOut'>Vector of Outlier Indicators</h2><span id='topic+print.icsOut'></span><span id='topic+show+2CicsOut-method'></span>

<h3>Description</h3>

<p>Short statement about how many components are selected for the outlier detection and how many outliers are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'icsOut'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.icsOut_+3A_object">object</code></td>
<td>
<p>object of class <code>icsOut</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+icsOut-class">icsOut-class</a></code> and <code><a href="#topic+ics.outlier">ics.outlier</a></code></p>

<hr>
<h2 id='summary.ICS_Out'>Summary of an 'ICS_Out' Object
Summarizes an 'ICS_Out' object in an informative way.</h2><span id='topic+summary.ICS_Out'></span>

<h3>Description</h3>

<p>Summary of an 'ICS_Out' Object
</p>
<p>Summarizes an 'ICS_Out' object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICS_Out'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ICS_Out_+3A_object">object</code></td>
<td>
<p>object object of class <code>"ICS_Out"</code>.</p>
</td></tr>
<tr><td><code id="summary.ICS_Out_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+summary">summary()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICS_Out_summary"</code> with the following components:
</p>

<ul>
<li> <p><code>comps</code>: Vector giving the indices of the ICS components selected.
</p>
</li>
<li> <p><code>method</code>: Name of the method used to decide upon the number of ICS components.
</p>
</li>
<li> <p><code>test</code>: he name of the normality test as specified in the function call.
</p>
</li>
<li> <p><code>S1_label</code>:  Name of S1.
</p>
</li>
<li> <p><code>S2_label</code>:  Name of S2.
</p>
</li>
<li> <p><code>level_test</code>: The level for deciding upon the cut-off value for the ICS distances.
</p>
</li>
<li> <p><code>level_dist</code>: The initial level for selecting the invariant coordinates.
</p>
</li>
<li> <p><code>nb_outliers</code>: the number of observations identified as outliers.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen
</p>

<hr>
<h2 id='summary.icsOut'>Summarize a icsOut object</h2><span id='topic+summary.icsOut'></span><span id='topic+summary+2CicsOut-method'></span>

<h3>Description</h3>

<p>Summarizes and prints an <code>icsOut</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'icsOut'
summary(object, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.icsOut_+3A_object">object</code></td>
<td>
<p>object of class <code>icsOut</code>.</p>
</td></tr>
<tr><td><code id="summary.icsOut_+3A_digits">digits</code></td>
<td>
<p> number of digits for the numeric output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aurore Archimbaud and Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+icsOut-class">icsOut-class</a></code> and <code><a href="#topic+ics.outlier">ics.outlier</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
