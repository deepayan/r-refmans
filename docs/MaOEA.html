<!DOCTYPE html><html><head><title>Help for package MaOEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MaOEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdaptiveNormalization'><p>Objective space normalization.</p></a></li>
<li><a href='#cmaes_gen'><p>Generator for cmaes_gen class.</p></a></li>
<li><a href='#compute_R2HV'><p>Modified powered tchebyscheff R2-indicator designed to approximate HV</p></a></li>
<li><a href='#compute_R2HVC'><p>Modified tchebyscheff R2-indicator contribution designed to approximate HV</p></a></li>
<li><a href='#compute_R2mtch'><p>Modified tchebyscheff R2-indicator</p></a></li>
<li><a href='#createWeights'><p>Das and Dennis's structured weight generation, normal boundary intersection (NBI).</p></a></li>
<li><a href='#createWeightsSobol'><p>Sobol sequence weights</p></a></li>
<li><a href='#DTLZ1'><p>The DTLZ1 test function.</p></a></li>
<li><a href='#DTLZ2'><p>The DTLZ2 test function.</p></a></li>
<li><a href='#DTLZ3'><p>The DTLZ3 test function.</p></a></li>
<li><a href='#DTLZ4'><p>The DTLZ4 test function.</p></a></li>
<li><a href='#EvaluateIndividual'><p>Evaluate objective values of a single individual</p></a></li>
<li><a href='#EvaluatePopulation'><p>Evaluate objective value of a set of individuals</p></a></li>
<li><a href='#GetHVContribution'><p>Get HV contribution of all points.</p></a></li>
<li><a href='#GetHypervolume'><p>Compute hypervolume</p></a></li>
<li><a href='#GetIGD'><p>Get IGD value</p></a></li>
<li><a href='#GetLeastContribution'><p>Get least HV contribution</p></a></li>
<li><a href='#GetLeastContributor'><p>Get least HV contributor</p></a></li>
<li><a href='#InitializePopulationLHS'><p>Initialize population with Latin Hypercube Sampling</p></a></li>
<li><a href='#install_python_dependencies'><p>Install python modules required by MaOEA: numpy and PyGMO</p></a></li>
<li><a href='#load_python_dependencies'><p>Install python modules required by MaOEA: numpy and PyGMO</p></a></li>
<li><a href='#MaOEA-package'><p>Many-Objective Evolutionary Algorithm</p></a></li>
<li><a href='#MOCMAES'><p>Multi-Objective CMA-ES</p></a></li>
<li><a href='#Normalize'><p>Objective space normalization.</p></a></li>
<li><a href='#NSGA3'><p>Elitist Non-dominated Sorting Genetic Algorithm version III</p></a></li>
<li><a href='#optimMaOEA'><p>Elitist Non-dominated Sorting Genetic Algorithm version III</p></a></li>
<li><a href='#SMOCMAES'><p>Steady-state Multi-Objective CMA-ES</p></a></li>
<li><a href='#SMSEMOA'><p>S-Metric Selection EMOA</p></a></li>
<li><a href='#WFG1'><p>The WFG1 test function.</p></a></li>
<li><a href='#WFG2'><p>The WFG2 test function.</p></a></li>
<li><a href='#WFG4'><p>The WFG4 test function.</p></a></li>
<li><a href='#WFG5'><p>The WFG5 test function.</p></a></li>
<li><a href='#WFG6'><p>The WFG6 test function.</p></a></li>
<li><a href='#WFG7'><p>The WFG7 test function.</p></a></li>
<li><a href='#WFG8'><p>The WFG8 test function.</p></a></li>
<li><a href='#WFG9'><p>The WFG9 test function.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Many Objective Evolutionary Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dani Irawan &lt;irawan_dani@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of evolutionary algorithms to solve many-objective optimization. 
    Hybridization between the algorithms are also facilitated. Available algorithms are:
    'SMS-EMOA' &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2006.08.008">doi:10.1016/j.ejor.2006.08.008</a>&gt;
    'NSGA-III' &lt;<a href="https://doi.org/10.1109%2FTEVC.2013.2281535">doi:10.1109/TEVC.2013.2281535</a>&gt;
    'MO-CMA-ES' &lt;<a href="https://doi.org/10.1145%2F1830483.1830573">doi:10.1145/1830483.1830573</a>&gt;
    The following many-objective benchmark problems are also provided: 
    'DTLZ1'-'DTLZ4' from Deb, et al. (2001) &lt;<a href="https://doi.org/10.1007%2F1-84628-137-7_6">doi:10.1007/1-84628-137-7_6</a>&gt; and
    'WFG4'-'WFG9' from Huband, et al. (2005) &lt;<a href="https://doi.org/10.1109%2FTEVC.2005.861417">doi:10.1109/TEVC.2005.861417</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dots26/MaOEA/issues">https://github.com/dots26/MaOEA/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dots26/MaOEA">https://github.com/dots26/MaOEA</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate, nsga2R, lhs, nnet, stringr, randtoolbox, e1071,
MASS,gtools, stats, utils, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python 3.x with following modules: PyGMO, NumPy,
and cloudpickle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-15 01:27:01 UTC; irawan</td>
</tr>
<tr>
<td>Author:</td>
<td>Dani Irawan <a href="https://orcid.org/0000-0002-4213-941X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-31 09:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdaptiveNormalization'>Objective space normalization.</h2><span id='topic+AdaptiveNormalization'></span>

<h3>Description</h3>

<p>Normalize the objectives to 0-1. The origin is the ideal point. (1,...,1) is not the nadir point.
The normalization is done by using adaptive normalization used in NSGA-III.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptiveNormalization(objectiveValue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptiveNormalization_+3A_objectivevalue">objectiveValue</code></td>
<td>
<p>Set of objective vectors to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
<code>normalizedObjective</code> The normalized values
<code>idealPoint</code> The ideal point corresponding to the origin
<code>nadirPoint</code> The location of nadir point in the normalized Space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nObj &lt;- 5
nIndividual &lt;- 100
nVar &lt;- 10
population &lt;- InitializePopulationLHS(nIndividual,nVar,FALSE)
objective &lt;- matrix(,nrow=nObj,ncol=nIndividual)
for(individual in 1:nIndividual){
   objective[,individual] &lt;- WFG4(population[,individual],nObj)
}
AdaptiveNormalization(objective)
</code></pre>

<hr>
<h2 id='cmaes_gen'>Generator for cmaes_gen class.</h2><span id='topic+cmaes_gen'></span>

<h3>Description</h3>

<p>Create a list with cmaes_gen class. Basically, the function transform the population into a class that is accepted by the MOCMAES and SMOCMAES function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmaes_gen(
  population,
  ps_target = (1/(5 + (1/2)^0.5)),
  stepSize = 0.5,
  evoPath = rep(0, nrow(population)),
  covarianceMatrix = diag(nrow(population))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmaes_gen_+3A_population">population</code></td>
<td>
<p>The number of objective functions. A scalar value.</p>
</td></tr>
<tr><td><code id="cmaes_gen_+3A_ps_target">ps_target</code></td>
<td>
<p>The target success rate. Used to initialize cmaes_gen$averageSuccessRate.</p>
</td></tr>
<tr><td><code id="cmaes_gen_+3A_stepsize">stepSize</code></td>
<td>
<p>The initial step size.</p>
</td></tr>
<tr><td><code id="cmaes_gen_+3A_evopath">evoPath</code></td>
<td>
<p>A vector of numbers indicating evolution path of each variable.</p>
</td></tr>
<tr><td><code id="cmaes_gen_+3A_covariancematrix">covarianceMatrix</code></td>
<td>
<p>Covariance matrix of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of cmaes_gen class. It can be used as MO-CMA-ES parent. It is a 5 tuple: x (the design point, length = number of variable),averageSuccessRate (scalar),stepSize (scalar), evoPath (evolution path, vector, length = number of variable ),covarianceMatrix (square matrix with ncol = nrow = number of variable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
crossoverProbability &lt;- 1
ps_target &lt;- 1 / (5 + ( 1 / 2  )^0.5 )
pop &lt;- matrix(stats::runif(nIndividual*nVar), nrow = nVar) # create the population
a_list &lt;- cmaes_gen(pop)
control &lt;- list(successProbTarget=ps_target,crossoverProbability=crossoverProbability)
 
# run a generation of MO-CMA-ES with standard WFG8 test function.
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
newGeneration &lt;- MOCMAES(a_list,nObjective,WFG8,control,nObjective)

</code></pre>

<hr>
<h2 id='compute_R2HV'>Modified powered tchebyscheff R2-indicator designed to approximate HV</h2><span id='topic+compute_R2HV'></span>

<h3>Description</h3>

<p>Compute the R2-HV from Shang et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_R2HV(dataPoints, reference, weights = NULL, nPoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_R2HV_+3A_datapoints">dataPoints</code></td>
<td>
<p>The Points coordinate. Each column contains a single point (column major).</p>
</td></tr>
<tr><td><code id="compute_R2HV_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing R2-mtch (similar as reference for HV)</p>
</td></tr>
<tr><td><code id="compute_R2HV_+3A_weights">weights</code></td>
<td>
<p>The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences.</p>
</td></tr>
<tr><td><code id="compute_R2HV_+3A_npoints">nPoints</code></td>
<td>
<p>Used only when no weights are supplied. An input for the weight generator (sobol sequences). This defines how many points are created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return the powered R2-indicator of the set.
</p>


<h3>References</h3>

<p>Ke Shang, Hisao Ishibuchi, Min-Ling Zhang, and Yiping Liu. 2018. A new R2 indicator for better hypervolume approximation. In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '18), Hernan Aguirre (Ed.). ACM, New York, NY, USA, 745-752. DOI: https://doi.org/10.1145/3205455.3205543
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nPointToSample &lt;- 100
nObjective &lt;- 3
points &lt;- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
ranks &lt;- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
points &lt;- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
nPoints &lt;- ncol(points) # check how many points are on the non-dominated front
reference &lt;- rep(2,nObjective)

compute_R2HV(points,reference)
</code></pre>

<hr>
<h2 id='compute_R2HVC'>Modified tchebyscheff R2-indicator contribution designed to approximate HV</h2><span id='topic+compute_R2HVC'></span>

<h3>Description</h3>

<p>Compute the R2-HVC from Shang et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_R2HVC(
  dataPoints,
  reference,
  weights = NULL,
  alpha = 1,
  nWeight = 300,
  indexOfInterest = 1:ncol(dataPoints)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_R2HVC_+3A_datapoints">dataPoints</code></td>
<td>
<p>The Points coordinate. Each column contains a single point (column major).</p>
</td></tr>
<tr><td><code id="compute_R2HVC_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing R2-mtch (similar as reference for HV)</p>
</td></tr>
<tr><td><code id="compute_R2HVC_+3A_weights">weights</code></td>
<td>
<p>The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences</p>
</td></tr>
<tr><td><code id="compute_R2HVC_+3A_alpha">alpha</code></td>
<td>
<p>Power factor on the gmtch and g*2tch utility functions.</p>
</td></tr>
<tr><td><code id="compute_R2HVC_+3A_nweight">nWeight</code></td>
<td>
<p>Used only when no weights are supplied. The number of weights generated by sobol sequence.</p>
</td></tr>
<tr><td><code id="compute_R2HVC_+3A_indexofinterest">indexOfInterest</code></td>
<td>
<p>individuals to be evaluated. The R2 values will only be reported/returned for these individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return R2-indicator contribution of each point.
</p>


<h3>References</h3>

<p>K. Shang, H. Ishibuchi and X. Ni, &quot;R2-based Hypervolume Contribution Approximation,&quot; in IEEE Transactions on Evolutionary Computation. doi: 10.1109/TEVC.2019.2909271
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nPointToSample &lt;- 100
nObjective &lt;- 3
points &lt;- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
ranks &lt;- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
points &lt;- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
nPoints &lt;- ncol(points) # check how many points are on the non-dominated front
reference &lt;- rep(2,nObjective)

compute_R2HVC(points,reference)
</code></pre>

<hr>
<h2 id='compute_R2mtch'>Modified tchebyscheff R2-indicator</h2><span id='topic+compute_R2mtch'></span>

<h3>Description</h3>

<p>Compute the R2-mtch indicator from Shang et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_R2mtch(dataPoints, reference, weights = NULL, nWeight = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_R2mtch_+3A_datapoints">dataPoints</code></td>
<td>
<p>The Points coordinate. Each column contains a single point (column major).</p>
</td></tr>
<tr><td><code id="compute_R2mtch_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing R2-mtch (similar as reference for HV)</p>
</td></tr>
<tr><td><code id="compute_R2mtch_+3A_weights">weights</code></td>
<td>
<p>The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences.</p>
</td></tr>
<tr><td><code id="compute_R2mtch_+3A_nweight">nWeight</code></td>
<td>
<p>Used only when no weights are supplied. An input for the sobol weight generation. This defines how many points to be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return the R2-indicator of the set.
</p>


<h3>References</h3>

<p>Ke Shang, Hisao Ishibuchi, Min-Ling Zhang, and Yiping Liu. 2018. A new R2 indicator for better hypervolume approximation. In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '18), Hernan Aguirre (Ed.). ACM, New York, NY, USA, 745-752. DOI: https://doi.org/10.1145/3205455.3205543
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nPointToSample &lt;- 100
nObjective &lt;- 3
points &lt;- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
ranks &lt;- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
points &lt;- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
nPoints &lt;- ncol(points) # check how many points are on the non-dominated front
reference &lt;- rep(2,nObjective)

compute_R2mtch(points,reference)
</code></pre>

<hr>
<h2 id='createWeights'>Das and Dennis's structured weight generation, normal boundary intersection (NBI).</h2><span id='topic+createWeights'></span>

<h3>Description</h3>

<p>Generate a set of weights following Das and Dennis's method. Each column returned is a weight vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWeights(nDim, axisDivision = nDim + 2, noZero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWeights_+3A_ndim">nDim</code></td>
<td>
<p>The dimensionality of the problem. In EA, usually this is used in the objective space, hence nDim = nObjective</p>
</td></tr>
<tr><td><code id="createWeights_+3A_axisdivision">axisDivision</code></td>
<td>
<p>Used only when no weights are supplied. An input for the structured weight distribution. This defines how many division are created in each axis.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_nozero">noZero</code></td>
<td>
<p>Default to false. If set to TRUE, reference vector containing zero, e.g. (1,0,0) will be removed. Used to generate weight in modified tch method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return a set of weight vectors.
</p>


<h3>References</h3>

<p>Indraneel Das and J. E. Dennis. 1998. Normal-Boundary Intersection: A New Method for Generating the Pareto Surface in Nonlinear Multicriteria Optimization Problems. SIAM Journal on Optimization 1998 8:3, 631-657.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nObjective &lt;- 3
axisDiv &lt;- 6

createWeights(nObjective,axisDiv)
</code></pre>

<hr>
<h2 id='createWeightsSobol'>Sobol sequence weights</h2><span id='topic+createWeightsSobol'></span>

<h3>Description</h3>

<p>Generate a set of weights following Sobol sequence generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWeightsSobol(nWeights, nDim, seed = 4177)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWeightsSobol_+3A_nweights">nWeights</code></td>
<td>
<p>Number of weights to generate.</p>
</td></tr>
<tr><td><code id="createWeightsSobol_+3A_ndim">nDim</code></td>
<td>
<p>The dimensionality of the problem. In EA, usually this is used in the objective space, hence nDim = nObjective</p>
</td></tr>
<tr><td><code id="createWeightsSobol_+3A_seed">seed</code></td>
<td>
<p>Seed for scrambling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function return a set of weight vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nObjective &lt;- 3
nPoint &lt;- 1000

createWeightsSobol(nPoint,nObjective)
</code></pre>

<hr>
<h2 id='DTLZ1'>The DTLZ1 test function.</h2><span id='topic+DTLZ1'></span>

<h3>Description</h3>

<p>The DTLZ1 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTLZ1(individual, nObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTLZ1_+3A_individual">individual</code></td>
<td>
<p>The vector of individual (or matrix of population) to be evaluated.</p>
</td></tr>
<tr><td><code id="DTLZ1_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective x population size, containing the objective values for each individual.
</p>


<h3>References</h3>

<p>Deb,  K.,  Thiele,  L.,  Laumanns,  M.,  Zitzler,  E.:  Scalable  Multi-Objective  Optimization Test Problems. In: Congress on Evolutionary Computation (CEC). pp. 825–830. IEEE Press, Piscataway, NJ (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- stats::runif(14)
nObj &lt;- 4
DTLZ1(individual,nObj)
</code></pre>

<hr>
<h2 id='DTLZ2'>The DTLZ2 test function.</h2><span id='topic+DTLZ2'></span>

<h3>Description</h3>

<p>The DTLZ2 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTLZ2(individual, nObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTLZ2_+3A_individual">individual</code></td>
<td>
<p>The vector of individual (or matrix of population) to be evaluated.</p>
</td></tr>
<tr><td><code id="DTLZ2_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective x population size, containing the objective values for each individual.
</p>


<h3>References</h3>

<p>Deb,  K.,  Thiele,  L.,  Laumanns,  M.,  Zitzler,  E.:  Scalable  Multi-Objective  Optimization Test Problems. In: Congress on Evolutionary Computation (CEC). pp. 825–830. IEEE Press, Piscataway, NJ (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- stats::runif(14)
nObj &lt;- 4
DTLZ2(individual,nObj)
</code></pre>

<hr>
<h2 id='DTLZ3'>The DTLZ3 test function.</h2><span id='topic+DTLZ3'></span>

<h3>Description</h3>

<p>The DTLZ3 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTLZ3(individual, nObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTLZ3_+3A_individual">individual</code></td>
<td>
<p>The vector of individual (or matrix of population) to be evaluated.</p>
</td></tr>
<tr><td><code id="DTLZ3_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective x population size, containing the objective values for each individual.
</p>


<h3>References</h3>

<p>Deb,  K.,  Thiele,  L.,  Laumanns,  M.,  Zitzler,  E.:  Scalable  Multi-Objective  Optimization Test Problems. In: Congress on Evolutionary Computation (CEC). pp. 825–830. IEEE Press, Piscataway, NJ (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- stats::runif(14)
nObj &lt;- 4
DTLZ3(individual,nObj)
</code></pre>

<hr>
<h2 id='DTLZ4'>The DTLZ4 test function.</h2><span id='topic+DTLZ4'></span>

<h3>Description</h3>

<p>The DTLZ4 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTLZ4(individual, nObj, alpha = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTLZ4_+3A_individual">individual</code></td>
<td>
<p>The vector of individual (or matrix of population) to be evaluated.</p>
</td></tr>
<tr><td><code id="DTLZ4_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="DTLZ4_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value of DTLZ4 function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective x population size, containing the objective values for each individual.
</p>


<h3>References</h3>

<p>Deb,  K.,  Thiele,  L.,  Laumanns,  M.,  Zitzler,  E.:  Scalable  Multi-Objective  Optimization Test Problems. In: Congress on Evolutionary Computation (CEC). pp. 825–830. IEEE Press, Piscataway, NJ (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- stats::runif(14)
nObj &lt;- 4
DTLZ4(individual,nObj)
</code></pre>

<hr>
<h2 id='EvaluateIndividual'>Evaluate objective values of a single individual</h2><span id='topic+EvaluateIndividual'></span>

<h3>Description</h3>

<p>Evaluate individual with the specified test function. Non-feasible solution are given Inf as objective values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvaluateIndividual(individual, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvaluateIndividual_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated</p>
</td></tr>
<tr><td><code id="EvaluateIndividual_+3A_fun">fun</code></td>
<td>
<p>A string containing which problem is being solved. Currently available DTLZ1-DTLZ4, WFG4-WFG9.</p>
</td></tr>
<tr><td><code id="EvaluateIndividual_+3A_...">...</code></td>
<td>
<p>Further parameters used by <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- stats::runif(8)
EvaluateIndividual(individual,WFG4,3) # the 3 is passed to WFG4 nObj
</code></pre>

<hr>
<h2 id='EvaluatePopulation'>Evaluate objective value of a set of individuals</h2><span id='topic+EvaluatePopulation'></span>

<h3>Description</h3>

<p>Evaluate a population with the specified test function. Non-feasible solution are given Inf as objective values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvaluatePopulation(pop, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvaluatePopulation_+3A_pop">pop</code></td>
<td>
<p>The population to be evaluated</p>
</td></tr>
<tr><td><code id="EvaluatePopulation_+3A_fun">fun</code></td>
<td>
<p>A string containing which problem is being solved. Currently available in the package: DTLZ1-DTLZ4, WFG4-WFG9.</p>
</td></tr>
<tr><td><code id="EvaluatePopulation_+3A_...">...</code></td>
<td>
<p>Further parameters used by <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- matrix(runif(8*50),nrow=8) # 8 variables, 50 individuals
EvaluatePopulation(pop,WFG4,3) # the 3 is passed to WFG4 nObj
</code></pre>

<hr>
<h2 id='GetHVContribution'>Get HV contribution of all points.</h2><span id='topic+GetHVContribution'></span>

<h3>Description</h3>

<p>Get the hypervolume (HV) contribution of the population. Dominated front will give 0 contribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHVContribution(
  populationObjective,
  reference = NULL,
  method = "exact",
  ref_multiplier = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHVContribution_+3A_populationobjective">populationObjective</code></td>
<td>
<p>The objective value of the corresponding individual</p>
</td></tr>
<tr><td><code id="GetHVContribution_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing HV</p>
</td></tr>
<tr><td><code id="GetHVContribution_+3A_method">method</code></td>
<td>
<p>the HV computation method. Currently ignored and uses the WFG exact method.</p>
</td></tr>
<tr><td><code id="GetHVContribution_+3A_ref_multiplier">ref_multiplier</code></td>
<td>
<p>Multiplier to the nadir point for dynamic reference point location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length ncol(populationObjective)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nObjective &lt;- 5 # the number of objectives
nPoint &lt;- 10 # the number of points that will form the hypervolume
objective &lt;- matrix(stats::runif(nObjective*nPoint), nrow = nObjective, ncol = nPoint)
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
GetHypervolume(objective,,"exact") # no reference supplied

reference &lt;- rep(2,nObjective) # create a reference point at (2,2,2,2,2)
if(py_module_ready) # prevent error on testing the example
GetHVContribution(objective,reference)

</code></pre>

<hr>
<h2 id='GetHypervolume'>Compute hypervolume</h2><span id='topic+GetHypervolume'></span>

<h3>Description</h3>

<p>Compute the hypervolume formed by the points w.r.t. a reference point. If no reference is supplied, use the nadir point*(1.1,...,1.1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHypervolume(
  objective,
  reference = NULL,
  method = "exact",
  ref_multiplier = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHypervolume_+3A_objective">objective</code></td>
<td>
<p>The set of points in the objective space (The objective values). A single column should contain one point, so the size would be numberOfObjective x nPoint, e.g. in 5 objective problem, it is 5 x n.</p>
</td></tr>
<tr><td><code id="GetHypervolume_+3A_reference">reference</code></td>
<td>
<p>The reference point for HV computation. A column vector.</p>
</td></tr>
<tr><td><code id="GetHypervolume_+3A_method">method</code></td>
<td>
<p>Exact using WFG method or approximate HV using the method by Bringmann and Friedrich. Default to &quot;exact&quot;.</p>
</td></tr>
<tr><td><code id="GetHypervolume_+3A_ref_multiplier">ref_multiplier</code></td>
<td>
<p>Multiplier to the nadir point for dynamic reference point location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hypervolume size, a scalar value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nObjective &lt;- 5 # the number of objectives
nPoint &lt;- 10 # the number of points that will form the hypervolume
objective &lt;- matrix(stats::runif(nObjective*nPoint), nrow = nObjective, ncol = nPoint)
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
GetHypervolume(objective,,"exact") # no reference supplied

reference &lt;- rep(2,nObjective) # create a reference point at (2,2,2,2,2)
if(py_module_ready) # prevent error on testing the example
GetHypervolume(objective,reference,"exact") # using reference point

</code></pre>

<hr>
<h2 id='GetIGD'>Get IGD value</h2><span id='topic+GetIGD'></span>

<h3>Description</h3>

<p>Get Inverted Generational Distance (IGD) value of the population objective w.r.t. a matrix of reference set (each row contain 1 point).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetIGD(populationObjective, referenceSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetIGD_+3A_populationobjective">populationObjective</code></td>
<td>
<p>The objective value of the corresponding individual</p>
</td></tr>
<tr><td><code id="GetIGD_+3A_referenceset">referenceSet</code></td>
<td>
<p>The reference points for computing IGD</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The IGD metric. A Scalar value.
</p>

<hr>
<h2 id='GetLeastContribution'>Get least HV contribution</h2><span id='topic+GetLeastContribution'></span>

<h3>Description</h3>

<p>Get the hypervolume (HV) contribution of the individual with least HV contribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLeastContribution(
  populationObjective,
  reference = NULL,
  method = "exact",
  ref_multiplier = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLeastContribution_+3A_populationobjective">populationObjective</code></td>
<td>
<p>The objective value of the corresponding individual</p>
</td></tr>
<tr><td><code id="GetLeastContribution_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing HV</p>
</td></tr>
<tr><td><code id="GetLeastContribution_+3A_method">method</code></td>
<td>
<p>the HV computation method</p>
</td></tr>
<tr><td><code id="GetLeastContribution_+3A_ref_multiplier">ref_multiplier</code></td>
<td>
<p>Multiplier to the nadir point for dynamic reference point location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The HV contribution value of the least contributor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
nObjective &lt;- 5 # the number of objectives
nPoint &lt;- 10 # the number of points that will form the hypervolume
objective &lt;- matrix(stats::runif(nObjective*nPoint), nrow = nObjective, ncol = nPoint)
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
GetHypervolume(objective,,"exact") # no reference supplied

reference &lt;- rep(2,nObjective) # create a reference point at (2,2,2,2,2)
if(py_module_ready) # prevent error on testing the example
GetLeastContribution(objective,reference,"exact")

</code></pre>

<hr>
<h2 id='GetLeastContributor'>Get least HV contributor</h2><span id='topic+GetLeastContributor'></span>

<h3>Description</h3>

<p>Get index of the individual with least hypervolume (HV) contribution. For the contribution itself, use GetLeastContribution()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLeastContributor(
  populationObjective,
  reference = NULL,
  method = "exact",
  hypervolumeMethodParam = list(),
  ref_multiplier = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLeastContributor_+3A_populationobjective">populationObjective</code></td>
<td>
<p>The objective value of the corresponding individual</p>
</td></tr>
<tr><td><code id="GetLeastContributor_+3A_reference">reference</code></td>
<td>
<p>The reference point for computing HV</p>
</td></tr>
<tr><td><code id="GetLeastContributor_+3A_method">method</code></td>
<td>
<p>the HV computation method</p>
</td></tr>
<tr><td><code id="GetLeastContributor_+3A_hypervolumemethodparam">hypervolumeMethodParam</code></td>
<td>
<p>A list of parameters to be passed to the hypervolumeMethod</p>
</td></tr>
<tr><td><code id="GetLeastContributor_+3A_ref_multiplier">ref_multiplier</code></td>
<td>
<p>Multiplier to the nadir point for dynamic reference point location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the least contributor, an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nObjective &lt;- 5 # the number of objectives
nPoint &lt;- 10 # the number of points that will form the hypervolume
objective &lt;- matrix(stats::runif(nObjective*nPoint), nrow = nObjective, ncol = nPoint)
# run a generation of MO-CMA-ES with standard WFG8 test function.
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
GetHypervolume(objective,,"exact") # no reference supplied

reference &lt;- rep(2,nObjective) # create a reference point at (2,2,2,2,2)
if(py_module_ready) # prevent error on testing the example
GetLeastContributor(objective,reference,"exact")

</code></pre>

<hr>
<h2 id='InitializePopulationLHS'>Initialize population with Latin Hypercube Sampling</h2><span id='topic+InitializePopulationLHS'></span>

<h3>Description</h3>

<p>Create initial sample using Latin Hypercube Sampling (LHS) method. The variables will be ranged between 0-1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitializePopulationLHS(
  numberOfIndividuals,
  chromosomeLength,
  minVal = 0,
  maxVal = 1,
  samplingMethod = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitializePopulationLHS_+3A_numberofindividuals">numberOfIndividuals</code></td>
<td>
<p>The number of individual in the population (ncol). Integer &gt; 0.</p>
</td></tr>
<tr><td><code id="InitializePopulationLHS_+3A_chromosomelength">chromosomeLength</code></td>
<td>
<p>The number of variables per individual (nrow)</p>
</td></tr>
<tr><td><code id="InitializePopulationLHS_+3A_minval">minVal</code></td>
<td>
<p>Minimum value of the resulting sample</p>
</td></tr>
<tr><td><code id="InitializePopulationLHS_+3A_maxval">maxVal</code></td>
<td>
<p>Maximum value of the resulting sample</p>
</td></tr>
<tr><td><code id="InitializePopulationLHS_+3A_samplingmethod">samplingMethod</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size chromosomeLength x nIndividual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nVar &lt;- 14
nIndividual &lt;- 100
InitializePopulationLHS(nIndividual,nVar,FALSE)
</code></pre>

<hr>
<h2 id='install_python_dependencies'>Install python modules required by MaOEA: numpy and PyGMO</h2><span id='topic+install_python_dependencies'></span>

<h3>Description</h3>

<p>Install the required python package via conda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_python_dependencies(conda = "auto", envname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_python_dependencies_+3A_conda">conda</code></td>
<td>
<p>Default: auto</p>
</td></tr>
<tr><td><code id="install_python_dependencies_+3A_envname">envname</code></td>
<td>
<p>Python virtual environment where the modules will be installed, default to 'r-reticulate'</p>
</td></tr>
<tr><td><code id="install_python_dependencies_+3A_...">...</code></td>
<td>
<p>Further argument to pass to reticulate::py_install</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 if dependencies installed and loaded successfully, 1 if fails.
</p>

<hr>
<h2 id='load_python_dependencies'>Install python modules required by MaOEA: numpy and PyGMO</h2><span id='topic+load_python_dependencies'></span>

<h3>Description</h3>

<p>Import the required python package if it fails onLoad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_python_dependencies()
</code></pre>


<h3>Value</h3>

<p>0 if dependencies loaded successfully, 1 if fails.
</p>

<hr>
<h2 id='MaOEA-package'>Many-Objective Evolutionary Algorithm</h2><span id='topic+MaOEA-package'></span><span id='topic+MaOEA'></span>

<h3>Description</h3>

<p>MaOEA contains several algorithms for solving many-objective optimization problems.
The algorithms are provided as a sequence of operators used in a single iteration.
For example, the SMSEMOA function calls the recombination (SBX) and mutation operator (polynomial mutation) to produce 1 offspring, and perform the S-metric selection.
The function then returns a list containing the population and population objective after the procedure is conducted once.
The purpose of only doing a single iteration is to support users if they wish to formulate hybrid algorithms.
</p>


<h3>Details</h3>

<p>Alternatively, users can use the optimMaOEA function to solve an optimization problem with their chosen algorithm.
This function is a simple wrapper to call the algorithms listed above for several iterations.
Using this function, users can simply supply the initial population, objective function, the chosen algorithm, and the number of iterations. If number of iteration is not supplied, then only a single iteration is conducted.
</p>
<p>Note: This package uses column-major ordering, i.e. an individual should be contained in a single column, each row represents different variable.
All optimization variable should be scaled to 0-1.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MaOEA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-07-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Acknowledgments</h3>

<p>This work is funded by the European Commission's H2020 programme through
the UTOPIAE  Marie  Curie  Innovative  Training Network, H2020-MSCA-ITN-2016,
under Grant Agreement No. 722734 as well as  through the Twinning project SYNERGY
under Grant Agreement No. 692286.
</p>


<h3>Maintainer</h3>

<p>Dani Irawan <a href="mailto:irawan_dani@yahoo.com">irawan_dani@yahoo.com</a>
</p>


<h3>Author(s)</h3>

<p>Dani Irawan <a href="mailto:irawan_dani@yahoo.com">irawan_dani@yahoo.com</a>
</p>


<h3>See Also</h3>

<p>Main interface function is <code><a href="#topic+optimMaOEA">optimMaOEA</a></code>.
</p>

<hr>
<h2 id='MOCMAES'>Multi-Objective CMA-ES</h2><span id='topic+MOCMAES'></span>

<h3>Description</h3>

<p>Do an iteration of population based Multi-Objective Covariance Matrix Adaptation Evolution Strategy (MO-CMA-ES). The variation is using simulated binary crossover (SBX) and mutation following the CMA. The original MO-CMA-ES does not use crossover, to do this simply set crossoverProbability to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOCMAES(parent, nObjective, fun, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOCMAES_+3A_parent">parent</code></td>
<td>
<p>The parent generation, an object of class cmaes_gen. The MO-CMA-ES parent is a 5 tuple: x (the design point, length = number of variable),averageSuccessRate (scalar),stepSize (scalar), evoPath (evolution path, vector, length = number of variable ),covarianceMatrix (square matrix with ncol = nrow = number of variable). The parent is then should be a vector of lists (see example).</p>
</td></tr>
<tr><td><code id="MOCMAES_+3A_nobjective">nObjective</code></td>
<td>
<p>The number of objective functions. A scalar value.</p>
</td></tr>
<tr><td><code id="MOCMAES_+3A_fun">fun</code></td>
<td>
<p>Objective function being solved.</p>
</td></tr>
<tr><td><code id="MOCMAES_+3A_control">control</code></td>
<td>
<p>List of parameters for CMA-ES. Available control are as follows:
<code>successProbTarget</code> Target success probability
<code>successProbThreshold</code> The threshold for success probability. If the average success probability is higher than this value, the success rate growth is slowed.
<code>crossoverProbability</code> The probability of doing crossover. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1.
<code>crossoverDistribution</code> The distribution index for SBX. Larger index makes the distribution sharper around each parent.</p>
</td></tr>
<tr><td><code id="MOCMAES_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list for the next generation. It contains list$new_generation (class: cmaes_gen), list$population (basically a copy of list$new_generation[[]]$x), and list$populationObjective
</p>


<h3>References</h3>

<p>Voß, T., Hansen, N., Igel, C.: Improved step size adaptation for the MO-CMA-ES. In: Genetic and Evolutionary Computation (GECCO). pp. 487–494. ACM, New York, NY (2010)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
crossoverProbability &lt;- 1
ps_target &lt;- 1 / (5 + ( 1 / 2  )^0.5 )
pop &lt;- matrix(stats::runif(nIndividual*nVar), nrow = nVar) # create the population
a_list &lt;- cmaes_gen(pop)
control &lt;- list(successProbTarget=ps_target,crossoverProbability=crossoverProbability)

# run a generation of MO-CMA-ES with standard WFG8 test function.
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
newGeneration &lt;- MOCMAES(a_list,nObjective,WFG8,control,nObjective)

</code></pre>

<hr>
<h2 id='Normalize'>Objective space normalization.</h2><span id='topic+Normalize'></span>

<h3>Description</h3>

<p>Normalize the objectives AND reference (combined) to 0-1. The origin is the ideal point. (1,...,1) is the nadir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(objectiveValue, referencePoints = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalize_+3A_objectivevalue">objectiveValue</code></td>
<td>
<p>Set of objective vectors to normalize</p>
</td></tr>
<tr><td><code id="Normalize_+3A_referencepoints">referencePoints</code></td>
<td>
<p>Set of reference points to transform following the objective vector normalization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
<code>normalizedObjective</code> The normalized values
<code>idealPoint</code> The ideal point corresponding to the origin
<code>transformedReference</code> The location of reference points in the normalized Space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nObj &lt;- 5
nVar &lt;- 10
nIndividual &lt;- 100
population &lt;- InitializePopulationLHS(nIndividual,nVar,FALSE)
objective &lt;- matrix(,nrow=nObj,ncol=nIndividual)
for(individual in 1:nIndividual){
   objective[,individual] &lt;- WFG4(population[,individual],nObj)
}
Normalize(objective)
</code></pre>

<hr>
<h2 id='NSGA3'>Elitist Non-dominated Sorting Genetic Algorithm version III</h2><span id='topic+NSGA3'></span>

<h3>Description</h3>

<p>Do an iteration of Elitist Non-dominated Sorting Genetic Algorithm version III (NSGA-III). THe variation is using SBX and polynomial mutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSGA3(population, fun, nObjective, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSGA3_+3A_population">population</code></td>
<td>
<p>The parent generation. One individual per column. nrow = number of variable, ncol = number of individuals in the population.</p>
</td></tr>
<tr><td><code id="NSGA3_+3A_fun">fun</code></td>
<td>
<p>Objective function being solved. Currently available in the package DTLZ1-DTLZ4, WFG4-WFG9.</p>
</td></tr>
<tr><td><code id="NSGA3_+3A_nobjective">nObjective</code></td>
<td>
<p>The number of objective functions. A scalar value. Needed to generate weight vectors.</p>
</td></tr>
<tr><td><code id="NSGA3_+3A_control">control</code></td>
<td>
<p>A list, containing the following:
<code>weightVector</code> NSGA-III require a set of reference points defined a priori. The reference can be any point. If not supplied, 5*nObjective points are generated from a sobol sequence. Column major: nrow = nObjective, ncol = number of reference points
<code>crossoverProbability</code> The probability of doing crossover. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1.
<code>mutationProbability</code> The probability of doing mutation. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1
<code>mutationDistribution</code> The distribution index for polynomial mutation. Larger index makes the distribution sharper around the parent.
<code>crossoverDistribution</code> The distribution index for SBX. Larger index makes the distribution sharper around each parent.</p>
</td></tr>
<tr><td><code id="NSGA3_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>#' @return Returns a list for the next generation
<code>population</code> The new generation design points. Column major.
<code>populationObjective</code> The new generation's objective values. Column major.
</p>


<h3>References</h3>

<p>Deb, K., Jain, H.: An evolutionary many-objective optimization algorithm using
reference-point-based  nondominated  sorting  approach,  part  I:  Solving  problems with box constraints.
Trans. Evol. Comp. 18 (4), 577–601 (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
#control for NSGA3
ctrl &lt;- list(crossoverProbability = 1,
             mutationProbability = 1/nVar)
#Initial population
population &lt;- matrix(runif(nIndividual*nVar), nrow = nVar)

# run a generation of NSGA-III with standard WFG8 test function.
NSGA3(population, WFG8,nObjective,ctrl,nObjective)
</code></pre>

<hr>
<h2 id='optimMaOEA'>Elitist Non-dominated Sorting Genetic Algorithm version III</h2><span id='topic+optimMaOEA'></span>

<h3>Description</h3>

<p>Main interface for the many-objective optimization evolutionary algorithm (MaOEA) package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimMaOEA(
  x = NULL,
  fun,
  solver = NSGA3,
  nObjective,
  nGeneration = 1,
  nVar = nrow(x),
  populationSize = ncol(x),
  seed = 2000,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimMaOEA_+3A_x">x</code></td>
<td>
<p>The initial population. If not supplied, will be generated using LHS. Column major, each column contain one entry.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_fun">fun</code></td>
<td>
<p>Objective function being solved.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_solver">solver</code></td>
<td>
<p>Function name of the solver. Currently available: SMSEMOA, MOCMAES, SMOCMAES, and NSGA3.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_nobjective">nObjective</code></td>
<td>
<p>The number of objective functions. A scalar value.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_ngeneration">nGeneration</code></td>
<td>
<p>Optional, the number of generation the solver should run.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables, will be used if <code>x</code> is not given.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_populationsize">populationSize</code></td>
<td>
<p>Number of individuals in the population, will be used if <code>x</code> is not given.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_seed">seed</code></td>
<td>
<p>random number seed for reproduction of code</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_control">control</code></td>
<td>
<p>A list, containing the following:
<code>weightVectorSet</code> A set of weight vector for the optimizer. The weight vector can be any point in the objective space. If not supplied, 5*nObjective points are generated from a sobol sequence. Size: nrow = nObjective,ncol = number of weight vectors
<code>crossoverProbability</code> The probability of doing crossover. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1.
<code>mutationProbability</code> The probability of doing mutation. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1
<code>WFGScaling</code> The use of scaling factor in WFG. Will be ignored in DTLZ problems. Without the scaling, the Pareto front would be on the all-positive portion of hypersphere with radius 1.
<code>mutationDistribution</code> The distribution index for polynomial mutation. Larger index makes the distribution sharper around the parent.
<code>crossoverDistribution</code> The distribution index for SBX. Larger index makes the distribution sharper around each parent.</p>
</td></tr>
<tr><td><code id="optimMaOEA_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list for the next generation
<code>population</code> The new generation design points.
<code>populationObjective</code> The new generation's objective values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
#control for NSGA3
ctrl &lt;- list(crossoverProbability = 1,
             mutationProbability = 1/nVar)
#Initial population can be supplied, like below but for this example, we skip it
#population &lt;- matrix(runif(nIndividual*nVar), nrow = nVar)

numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready){ # prevent error on testing the example
# Hybrid NSGA-III and SMSEMOA example
# 2 calls for nObjective. 1 for optimMaOEA, 1 for WFG8
# generate initial population and run 10 gen. NSGA-III with standard WFG8 test function.
newPop &lt;- optimMaOEA( , WFG8,NSGA3,nObjective,10,nVar,nIndividual,,ctrl,nObjective)$x

# run 5 generations of SMSEMOA with standard WFG8 test function starting with newPop.
result &lt;- optimMaOEA( newPop, WFG8,SMSEMOA,nObjective,5,,,1000,ctrl,nObjective)
finalPop &lt;- result$x
finalObjective &lt;- result$y
}

</code></pre>

<hr>
<h2 id='SMOCMAES'>Steady-state Multi-Objective CMA-ES</h2><span id='topic+SMOCMAES'></span>

<h3>Description</h3>

<p>Do an iteration of population based steady state Multi-Objective Covariance Matrix Adaptation Evolution Strategy (MO-CMA-ES). The variation is using simulated binary crossover (SBX) and mutation following the CMA. The original MO-CMA-ES does not use crossover, to do this simply set crossoverProbability to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMOCMAES(parent, nObjective, fun, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMOCMAES_+3A_parent">parent</code></td>
<td>
<p>The parent generation, an object of class cmaes_gen. The MO-CMA-ES parent is a 5 tuple: x (the design point, length = number of variable),averageSuccessRate (scalar),stepSize (scalar), evoPath (evolution path, vector, length = number of variable ),covarianceMatrix (square matrix with ncol = nrow = number of variable). The parent is then should be a vector of lists (see example).</p>
</td></tr>
<tr><td><code id="SMOCMAES_+3A_nobjective">nObjective</code></td>
<td>
<p>The number of objective functions. A scalar value.</p>
</td></tr>
<tr><td><code id="SMOCMAES_+3A_fun">fun</code></td>
<td>
<p>Objective function being solved.</p>
</td></tr>
<tr><td><code id="SMOCMAES_+3A_control">control</code></td>
<td>
<p>List of parameters for CMA-ES. Available control are as follows:
<code>successProbTarget</code> Target success probability
<code>successProbThreshold</code> The threshold for success probability. If the average success probability is higher than this value, the success rate growth is slowed.
<code>crossoverProbability</code> The probability of doing crossover. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1.
<code>crossoverDistribution</code> The distribution index for SBX. Larger index makes the distribution sharper around each parent.</p>
</td></tr>
<tr><td><code id="SMOCMAES_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list for the next generation. It contains list$new_generation (class: cmaes_gen), list$population (basically a copy of list$new_generation[[]]$x), and list$populationObjective
</p>


<h3>References</h3>

<p>Voß, T., Hansen, N., Igel, C.: Improved step size adaptation for the MO-CMA-ES. In: Genetic and Evolutionary Computation (GECCO). pp. 487–494. ACM, New York, NY (2010)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
crossoverProbability &lt;- 1
ps_target &lt;- 1 / (5 + ( 1 / 2  ) )
pop &lt;- matrix(stats::runif(nIndividual*nVar), nrow = nVar) # create the population
a_list &lt;- cmaes_gen(pop)
control &lt;- list(successProbTarget=ps_target,crossoverProbability=crossoverProbability)
# run a generation of SMO-CMA-ES with standard WFG8 test function.
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
newGeneration &lt;- SMOCMAES(a_list,nObjective,WFG8,control,nObjective)

</code></pre>

<hr>
<h2 id='SMSEMOA'>S-Metric Selection EMOA</h2><span id='topic+SMSEMOA'></span>

<h3>Description</h3>

<p>Do an iteration of  S-Metric Selection (SMS)-EMOA. The variation used is simulated binary crossover (SBX) and polynomial mutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMSEMOA(population, fun, nObjective, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMSEMOA_+3A_population">population</code></td>
<td>
<p>The parent generation. One individual per column.</p>
</td></tr>
<tr><td><code id="SMSEMOA_+3A_fun">fun</code></td>
<td>
<p>Objective function being solved. Currently available in the package DTLZ1-DTLZ4, WFG4-WFG9.</p>
</td></tr>
<tr><td><code id="SMSEMOA_+3A_nobjective">nObjective</code></td>
<td>
<p>Number of objective. Ignored as of version 0.6.1; number of row from fun is used instead.</p>
</td></tr>
<tr><td><code id="SMSEMOA_+3A_control">control</code></td>
<td>
<p>(list) Options to control the SMS-EMOA:
<code>mutationProbability</code> The probability of doing mutation. Should be between 0-1. Negative value will behave like a zero, and values larger than 1 will behave like 1. Default to 1
<code>mutationDistribution</code> The distribution index for polynomial mutation. Larger index makes the distribution sharper around the parent.
<code>crossoverDistribution</code> The distribution index for SBX. Larger index makes the distribution sharper around each parent.
<code>referencePoint</code> The reference point for HV computation on normalized objective space, i.e. (1,...,1) is the nadir point. If not supplied, the ref_multiplier is used instead.
<code>ref_multiplier</code> In case that a reference point is not supplied, the reference is set as a multiply of the current nadir. Default to 1.1.
<code>lbound</code> A vector containing the lower bound for each gene
<code>ubound</code> A vector containing the upper bound for each gene
<code>scaleinput</code> Whether the input should be scaled to 0-1.</p>
</td></tr>
<tr><td><code id="SMSEMOA_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list for the next generation
<code>population</code> The new generation. Column major, each row contain 1 set of objectives.
<code>successfulOffspring</code> Binary, 1 if the offspring is kept in the new generation. Used in some adaptive schemes.
<code>populationObjective</code> The new generation's objective values.
</p>


<h3>References</h3>

<p>Beume,  N.,  Naujoks,  B.,  Emmerich,  M.:  SMS-EMOA:  Multiobjective  selection
based on dominated hypervolume. Eur. J. Oper. Res. 181 (3), 1653 – 1669 (2007)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
nVar &lt;- 14
nObjective &lt;- 5
nIndividual &lt;- 100
crossoverProbability &lt;- 1
mutationProbability &lt;- 1/nVar
population &lt;- matrix(runif(nIndividual*nVar), nrow = nVar)

# run a generation of SMS-EMOA with standard WFG6 test function.
numpyready &lt;- reticulate::py_module_available('numpy')
pygmoready &lt;- reticulate::py_module_available('pygmo')
py_module_ready &lt;- numpyready &amp;&amp; pygmoready
if(py_module_ready) # prevent error on testing the example
SMSEMOA(population,WFG6,nObjective,list(crossoverProbability = crossoverProbability,
                                          mutationProbability = mutationProbability),nObjective)

</code></pre>

<hr>
<h2 id='WFG1'>The WFG1 test function.</h2><span id='topic+WFG1'></span>

<h3>Description</h3>

<p>The WFG1 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG1(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG1_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG1_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG1_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG1(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG2'>The WFG2 test function.</h2><span id='topic+WFG2'></span>

<h3>Description</h3>

<p>The WFG2 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG2(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG2_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG2_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG2_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG2(individual,nObj)

</code></pre>

<hr>
<h2 id='WFG4'>The WFG4 test function.</h2><span id='topic+WFG4'></span>

<h3>Description</h3>

<p>The WFG4 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG4(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG4_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG4_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG4_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG4(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG5'>The WFG5 test function.</h2><span id='topic+WFG5'></span>

<h3>Description</h3>

<p>The WFG5 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG5(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG5_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG5_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG5_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG5(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG6'>The WFG6 test function.</h2><span id='topic+WFG6'></span>

<h3>Description</h3>

<p>The WFG6 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG6(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG6_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG6_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG6_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG6(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG7'>The WFG7 test function.</h2><span id='topic+WFG7'></span>

<h3>Description</h3>

<p>The WFG7 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG7(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG7_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG7_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG7_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG7(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG8'>The WFG8 test function.</h2><span id='topic+WFG8'></span>

<h3>Description</h3>

<p>The WFG8 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG8(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG8_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG8_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG8_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG8(individual,nObj)
</code></pre>

<hr>
<h2 id='WFG9'>The WFG9 test function.</h2><span id='topic+WFG9'></span>

<h3>Description</h3>

<p>The WFG9 test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WFG9(individual, nObj, k = nObj - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WFG9_+3A_individual">individual</code></td>
<td>
<p>The individual to be evaluated, the search space should be in [0-2i] for variable number i. Can accept multiple individualm each in different column.</p>
</td></tr>
<tr><td><code id="WFG9_+3A_nobj">nObj</code></td>
<td>
<p>The number of objective</p>
</td></tr>
<tr><td><code id="WFG9_+3A_k">k</code></td>
<td>
<p>Number of distance related parameters. The reference suggests a positive integer multiplied by (nObj-1). Default to nObj-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size nObjective, containing the objective values.
</p>


<h3>References</h3>

<p>Huband, S., Hingston, P., Barone, L., While, L.: A review of multiobjective test problems and a scalable test problem toolkit. Trans. Evol. Comp 10 (5), 477–506 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individual &lt;- runif(14)
nObj &lt;- 4
WFG9(individual,nObj)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
