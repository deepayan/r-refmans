<!DOCTYPE html><html><head><title>Help for package scapGNN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scapGNN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ATAC_net'><p>Results of ConNetGNN() for scATAC-seq data from SNARE-seq dataset</p></a></li>
<li><a href='#BIC_LTMG'><p>BIC_LTMG</p></a></li>
<li><a href='#BIC_ZIMG'><p>BIC_ZIMG</p></a></li>
<li><a href='#ConNetGNN'><p>Construct association networks for gene-gene, cell-cell, and gene-cell based on graph neural network (GNN)</p></a></li>
<li><a href='#ConNetGNN_data'><p>The results of ConNetGNN() function</p></a></li>
<li><a href='#cpGModule'><p>Identify cell phenotype activated gene module</p></a></li>
<li><a href='#create_scapGNN_env'><p>Create the create_scapGNN_env environment on miniconda</p></a></li>
<li><a href='#Fit_LTMG'><p>Fitting function for Left-truncated mixed Gaussian</p></a></li>
<li><a href='#Global_Zcut'><p>Global_Zcut</p></a></li>
<li><a href='#H9_0h_cpGM_data'><p>Cell-activated gene modules under the 0-hour phenotype</p></a></li>
<li><a href='#H9_24h_cpGM_data'><p>Cell-activated gene modules under the 24-hour phenotype</p></a></li>
<li><a href='#H9_36h_cpGM_data'><p>Cell-activated gene modules under the 36-hour phenotype</p></a></li>
<li><a href='#Hv_exp'><p>Single-cell gene expression profiles</p></a></li>
<li><a href='#instPyModule'><p>Install the pyhton module through the reticulate R package</p></a></li>
<li><a href='#InteNet'><p>Integrate network data from single-cell RNA-seq and ATAC-seq</p></a></li>
<li><a href='#isLoaded'><p>The internal functions of the <code>scapGNN</code> package</p></a></li>
<li><a href='#load_path_data'><p>load pathway or gene set's gmt file</p></a></li>
<li><a href='#LTMG'><p>Left-truncated mixed Gaussian</p></a></li>
<li><a href='#LTMG-class'><p>An S4 class to represent the input data for LTMG.</p></a></li>
<li><a href='#plotCCNetwork'><p>Visualize cell cluster association network graph</p></a></li>
<li><a href='#plotGANetwork'><p>Visualize gene association network graph of a gene module or pathway at the specified cell phenotype</p></a></li>
<li><a href='#plotMulPhenGM'><p>Visualize gene association network graph for activated gene modules under multiple cell phenotypes</p></a></li>
<li><a href='#Preprocessing'><p>Data preprocessing</p></a></li>
<li><a href='#Pure_CDF'><p>Pure_CDF</p></a></li>
<li><a href='#RNA_ATAC_IntNet'><p>Results of InteNet() for integrating scRNA-seq and scATAC-seq data.</p></a></li>
<li><a href='#RNA_net'><p>Results of ConNetGNN() for scRNA-seq data from SNARE-seq dataset</p></a></li>
<li><a href='#RunLTMG'><p>Run Left-truncated mixed Gaussian</p></a></li>
<li><a href='#RWR'><p>Function that performs a random Walk with restart (RWR) on a given graph</p></a></li>
<li><a href='#scPathway'><p>Infer pathway activation score matrix at single-cell resolution</p></a></li>
<li><a href='#scPathway_data'><p>Single cell pathway activity matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Neural Network-Based Framework for Single Cell Active
Pathways and Gene Modules Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-8-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Xudong Han [aut, cre, cph],
  Xujiang Guo [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xudong Han &lt;hanxd1217@163.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It is a single cell active pathway analysis tool based on the graph neural network (F. Scarselli (2009) &lt;<a href="https://doi.org/10.1109%2FTNN.2008.2005605">doi:10.1109/TNN.2008.2005605</a>&gt;; Thomas N. Kipf (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1609.02907">doi:10.48550/arXiv.1609.02907</a>&gt;) to construct the gene-cell association network, infer pathway activity scores from different single cell modalities data, integrate multiple modality data on the same cells into one pathway activity score matrix, identify cell phenotype activated gene modules and parse association networks of gene modules under multiple cell phenotype. In addition, abundant visualization programs are provided to display the results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>ActivePathways, AdaptGauss, coop, igraph, mixtools,
reticulate, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 02:43:48 UTC; 12859</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ATAC_net'>Results of ConNetGNN() for scATAC-seq data from SNARE-seq dataset</h2><span id='topic+ATAC_net'></span>

<h3>Description</h3>

<p>A list to store the gene association network of scATAC-seq data.
Case data from the SNARE-seq dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATAC_net
</code></pre>


<h3>Format</h3>

<p>a list of three adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ATAC_net)
</code></pre>

<hr>
<h2 id='BIC_LTMG'>BIC_LTMG</h2><span id='topic+BIC_LTMG'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_LTMG(y, rrr, Zcut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_LTMG_+3A_y">y</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="BIC_LTMG_+3A_rrr">rrr</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="BIC_LTMG_+3A_zcut">Zcut</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC_LTMG
</p>

<hr>
<h2 id='BIC_ZIMG'>BIC_ZIMG</h2><span id='topic+BIC_ZIMG'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_ZIMG(y, rrr, Zcut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_ZIMG_+3A_y">y</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="BIC_ZIMG_+3A_rrr">rrr</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="BIC_ZIMG_+3A_zcut">Zcut</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC_ZIMG
</p>

<hr>
<h2 id='ConNetGNN'>Construct association networks for gene-gene, cell-cell, and gene-cell based on graph neural network (GNN)</h2><span id='topic+ConNetGNN'></span>

<h3>Description</h3>

<p>This function implements a graph neural network with two autoencoders. 1. AutoEncoder (AE) based on deep neural network:
Infer latent associations between genes and cells. 2. Graph AutoEncoder (GAE) based on graph convolutional neural network: Construct
association networks for gene-gene, cell-cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConNetGNN(
  Prep_data,
  python.path = NULL,
  miniconda.path = NULL,
  AE.epochs = 1000,
  AE.learning.rate = 0.001,
  AE.reg.alpha = 0.5,
  use.VGAE = TRUE,
  GAE.epochs = 300,
  GAE.learning.rate = 0.01,
  GAE_val_ratio = 0.05,
  parallel = FALSE,
  seed = 125,
  GPU.use = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConNetGNN_+3A_prep_data">Prep_data</code></td>
<td>
<p>The input data is the result from the <code>Preprocessing</code> function.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_python.path">python.path</code></td>
<td>
<p>The path to a Python binary. If python.path=&quot;default&quot;, the program will use the current system path to python.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_miniconda.path">miniconda.path</code></td>
<td>
<p>The path in which miniconda will be installed. If the <code>python.path</code> is NULL and conda or miniconda is not installed in the system, the program will automatically install miniconda according to the path specified by <code>miniconda.path</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_ae.epochs">AE.epochs</code></td>
<td>
<p>The number of epoch for the deep neural network (AE). Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_ae.learning.rate">AE.learning.rate</code></td>
<td>
<p>Initial learning rate of AE. Default: <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_ae.reg.alpha">AE.reg.alpha</code></td>
<td>
<p>The LTMG regularized intensity. Default: <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_use.vgae">use.VGAE</code></td>
<td>
<p>Whether to use Variational Graph AutoEncoder (VGAE). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_gae.epochs">GAE.epochs</code></td>
<td>
<p>The number of epoch for the GAE. Default: <code>300</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_gae.learning.rate">GAE.learning.rate</code></td>
<td>
<p>Initial learning rate of GAE. Default: <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_gae_val_ratio">GAE_val_ratio</code></td>
<td>
<p>For GAE, the proportion of edges that are extracted as the validation set. Default: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_parallel">parallel</code></td>
<td>
<p>Whether to use multiple processors to run GAE. Default: <code>FALSE</code> When <code>parallel=TRUE</code> (default), tow processors will be used to run GAE.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_gpu.use">GPU.use</code></td>
<td>
<p>Whether to use GPU for GNN modules. Default: <code>FALSE</code>. If GPU.use=TRUE, CUDA needs to be installed.</p>
</td></tr>
<tr><td><code id="ConNetGNN_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ConNetGNN
</p>
<p>The <code>ConNetGNN</code> function establishes a graph neural network (GNN) framework to mine latent relationships between genes and cells and within themselves.
This framework mainly includes two capabilities: </p>

<ul>
<li><p> 1.Deep neural network-based AutoEncoder inferring associations between genes and cells and generating gene features and cell features for the GAE.
</p>
</li>
<li><p> 2.The GAE takes the gene feature and cell feature as the node features of the initial gene correlation network and cell correlation network,
and constructs the gene association network and cell association network through the graph convolution process.
</p>
</li></ul>

<p>The GNN is implemented based on <code>pytorch</code>, so an appropriate python environment is required:
</p>

<ul>
<li><p> python &gt;=3.9.7
</p>
</li>
<li><p> pytorch &gt;=1.10.0
</p>
</li>
<li><p> sklearn &gt;=0.0
</p>
</li>
<li><p> scipy &gt;=1.7.3
</p>
</li>
<li><p> numpy &gt;=1.19.5
</p>
</li></ul>

<p>If the user has already configured the python environment, the path of the python binary file can be directly entered into <code>python.path</code>.
If the parameter <code>python.path</code> is NULL, the program will build a miniconda environment called <code>scapGNN_env</code> and configure python.
We also provide environment files for conda: <code>/inst/extdata/scapGNN_env.yaml</code>. Users can install it with the command: <code>conda env create -f scapGNN_env.yaml</code>.
</p>


<h3>Value</h3>

<p>A list:
</p>

<dl>
<dt>cell_network</dt><dd><p>Constructed cell association network.</p>
</dd>
<dt>gene_network</dt><dd><p>Constructed gene association network.</p>
</dd>
<dt>cell_gene_network</dt><dd><p>Constructed gene-cell association network.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>require(coop)
require(reticulate)
require(parallel)
# Data preprocessing
data("Hv_exp")
Hv_exp &lt;- Hv_exp[,1:20]
Hv_exp &lt;- Hv_exp[which(rowSums(Hv_exp) &gt; 0),]
Prep_data &lt;- Preprocessing(Hv_exp[1:10,])

## Not run: 
# Specify the python path
ConNetGNN_data &lt;- ConNetGNN(Prep_data,python.path="../miniconda3/envs/scapGNN_env/python.exe")

## End(Not run)

</code></pre>

<hr>
<h2 id='ConNetGNN_data'>The results of ConNetGNN() function</h2><span id='topic+ConNetGNN_data'></span>

<h3>Description</h3>

<p>Results of ConNetGNN() function with Hv_exp as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConNetGNN_data
</code></pre>


<h3>Format</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ConNetGNN_data)
</code></pre>

<hr>
<h2 id='cpGModule'>Identify cell phenotype activated gene module</h2><span id='topic+cpGModule'></span>

<h3>Description</h3>

<p>Mining activated gene modules in specific cell phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpGModule(
  network.data,
  cellset,
  nperm = 100,
  cut.pvalue = 0.01,
  cut.fdr = 0.05,
  parallel.cores = 2,
  rwr.gamma = 0.7,
  normal_dist = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpGModule_+3A_network.data">network.data</code></td>
<td>
<p>Network data constructed by the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_cellset">cellset</code></td>
<td>
<p>A vector of cell id. The specified cell set, which will be used as the restart set.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_nperm">nperm</code></td>
<td>
<p>Number of random permutations. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_cut.pvalue">cut.pvalue</code></td>
<td>
<p>The threshold of P-value, and genes below this threshold are regarded as gene modules activated by the cell set. Default: <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_cut.fdr">cut.fdr</code></td>
<td>
<p>The threshold of false discovery rate (FDR), and genes below this threshold are regarded as gene modules activated by the cell set. Default: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Number of processors to use when doing the calculations in parallel (default: <code>2</code>). If <code>parallel.cores=0</code>, then it will use all available core processors unless we set this argument with a smaller number.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_rwr.gamma">rwr.gamma</code></td>
<td>
<p>Restart parameter. Default: <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_normal_dist">normal_dist</code></td>
<td>
<p>Whether to use pnorm to calculate P values. Default: <code>TRUE</code>.Note that if normal_dist is FALSE, we need to increase nperm (we recommend 100).</p>
</td></tr>
<tr><td><code id="cpGModule_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cpGModule
</p>
<p>The <code>cpGModule</code> function takes a user-defined cell set as a restart set to automatically
identify activated gene modules. A perturbation analysis was used to calculate a significant P-value for each gene.
The <code>Benjamini &amp; Hochberg (BH)</code> method was used to adjust the P-value to obtain the FDR.
Genes with a significance level less than the set threshold are considered as cell phenotype activated gene modules.
</p>


<h3>Value</h3>

<p>A data frame contains four columns:
</p>

<dl>
<dt>Genes</dt><dd><p>Gene ID.</p>
</dd>
<dt>AS</dt><dd><p>Activity score.</p>
</dd>
<dt>Pvalue</dt><dd><p>Significant P-value.</p>
</dd>
<dt>FDR</dt><dd><p>False discovery rate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>require(parallel)
require(stats)

# Load the result of the ConNetGNN function.
data(ConNetGNN_data)
data(Hv_exp)

# Construct the cell set corresponding to 0h.
index&lt;-grep("0h",colnames(Hv_exp))
cellset&lt;-colnames(Hv_exp)[index]
cpGModule_data&lt;-cpGModule(ConNetGNN_data,cellset,nperm=10,parallel.cores=1)
</code></pre>

<hr>
<h2 id='create_scapGNN_env'>Create the create_scapGNN_env environment on miniconda</h2><span id='topic+create_scapGNN_env'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_scapGNN_env()
</code></pre>


<h3>Details</h3>

<p>create_scapGNN_env
</p>

<hr>
<h2 id='Fit_LTMG'>Fitting function for Left-truncated mixed Gaussian</h2><span id='topic+Fit_LTMG'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fit_LTMG(x, n, q, k, err = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fit_LTMG_+3A_x">x</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="Fit_LTMG_+3A_n">n</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="Fit_LTMG_+3A_q">q</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="Fit_LTMG_+3A_k">k</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="Fit_LTMG_+3A_err">err</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit_LTMG
</p>

<hr>
<h2 id='Global_Zcut'>Global_Zcut</h2><span id='topic+Global_Zcut'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Global_Zcut(MAT, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Global_Zcut_+3A_mat">MAT</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="Global_Zcut_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Global_Zcut
</p>

<hr>
<h2 id='H9_0h_cpGM_data'>Cell-activated gene modules under the 0-hour phenotype</h2><span id='topic+H9_0h_cpGM_data'></span>

<h3>Description</h3>

<p>Results of cpGModule() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H9_0h_cpGM_data
</code></pre>


<h3>Format</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H9_0h_cpGM_data)
</code></pre>

<hr>
<h2 id='H9_24h_cpGM_data'>Cell-activated gene modules under the 24-hour phenotype</h2><span id='topic+H9_24h_cpGM_data'></span>

<h3>Description</h3>

<p>Results of cpGModule() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H9_24h_cpGM_data
</code></pre>


<h3>Format</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H9_24h_cpGM_data)
</code></pre>

<hr>
<h2 id='H9_36h_cpGM_data'>Cell-activated gene modules under the 36-hour phenotype</h2><span id='topic+H9_36h_cpGM_data'></span>

<h3>Description</h3>

<p>Results of cpGModule() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H9_36h_cpGM_data
</code></pre>


<h3>Format</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H9_36h_cpGM_data)
</code></pre>

<hr>
<h2 id='Hv_exp'>Single-cell gene expression profiles</h2><span id='topic+Hv_exp'></span>

<h3>Description</h3>

<p>A log-transformed gene-cell matrix containing highly variable features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hv_exp
</code></pre>


<h3>Format</h3>

<p>a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hv_exp)
</code></pre>

<hr>
<h2 id='instPyModule'>Install the pyhton module through the reticulate R package</h2><span id='topic+instPyModule'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instPyModule(module)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instPyModule_+3A_module">module</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>instPyModule
</p>

<hr>
<h2 id='InteNet'>Integrate network data from single-cell RNA-seq and ATAC-seq</h2><span id='topic+InteNet'></span>

<h3>Description</h3>

<p>For the SNARE-seq dataset, a droplet-based method to simultaneously profile gene expression and chromatin accessibility in each of thousands of single nuclei,
the <code>InteNet</code> function can integrate network data of scRNA-seq data and scATAC-seq data (results of the <code>ConNetGNN</code> function) to into a gene-cell network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InteNet(RNA_net, ATAC_net, parallel.cores = 2, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InteNet_+3A_rna_net">RNA_net</code></td>
<td>
<p>Network data for RNA datasets. Produced by the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="InteNet_+3A_atac_net">ATAC_net</code></td>
<td>
<p>Network data for ATAC datasets. Produced by the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="InteNet_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Number of processors to use when doing the calculations in parallel (default: <code>2</code>). If <code>parallel.cores=0</code>, then it will use all available core processors unless we set this argument with a smaller number.</p>
</td></tr>
<tr><td><code id="InteNet_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>InteNet
</p>
<p>The scATAC-seq dataset needs to be converted into a gene activity matrix according to the process of <code>Signac</code>(<code>https://satijalab.org/signac/articles/snareseq.html</code>).
The subsequent process is consistent with the scRNA-seq dataset. The <code>InteNet</code> function then integrates the network data of RNA-seq data and ATAC-seq data into a gene-cell network.
With integrated network data as input, <code>scPathway</code> and <code>cpGModule</code> functions will infer pathway activity score matrix and gene modules supported by single-cell multi-omics.
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ActivePathways)
require(parallel)
data(RNA_net)
data(ATAC_net)
## Not run: 
RNA_ATAC_IntNet&lt;-InteNet(RNA_net,ATAC_net,parallel.cores=1)

## End(Not run)

# View data
data(RNA_ATAC_IntNet)
summary(RNA_ATAC_IntNet)
</code></pre>

<hr>
<h2 id='isLoaded'>The internal functions of the <code>scapGNN</code> package</h2><span id='topic+isLoaded'></span>

<h3>Description</h3>

<p>Determine if the package is loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLoaded(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLoaded_+3A_name">name</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>isLoaded
</p>

<hr>
<h2 id='load_path_data'>load pathway or gene set's gmt file</h2><span id='topic+load_path_data'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>
<p>file format:
1. first index: pathway's name or ID.
2. second index: pathway's url or others, it dosen't matter.
3. third to all: gene symbols in pathway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_path_data(gmt_file_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_path_data_+3A_gmt_file_path">gmt_file_path</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>load_path_data
</p>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='LTMG'>Left-truncated mixed Gaussian</h2><span id='topic+LTMG'></span>

<h3>Description</h3>

<p>Functional implementation of Left-truncated mixed Gaussian. The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTMG(VEC, Zcut_G, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTMG_+3A_vec">VEC</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="LTMG_+3A_zcut_g">Zcut_G</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
<tr><td><code id="LTMG_+3A_k">k</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LTMG
</p>

<hr>
<h2 id='LTMG-class'>An S4 class to represent the input data for LTMG.</h2><span id='topic+LTMG-class'></span>

<h3>Description</h3>

<p>An S4 class to represent the input data for LTMG.
</p>


<h3>Slots</h3>


<dl>
<dt><code>InputData</code></dt><dd><p>Input data for LTMG.</p>
</dd>
<dt><code>OrdinalMatrix</code></dt><dd><p>LTMG output data.</p>
</dd>
</dl>

<hr>
<h2 id='plotCCNetwork'>Visualize cell cluster association network graph</h2><span id='topic+plotCCNetwork'></span>

<h3>Description</h3>

<p>The <code>plotCCNetwork</code> function takes cells belonging to the same phenotype as a cluster.
When cell phenotypes are not provided, the <code>plotCCNetwork</code> functions identify cell clusters based on edge betweenness.
Cell interactions between cell clusters are merged into one edge by mean.
The thickness of the edge indicates the strength of interaction between cell clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCCNetwork(
  network.data,
  cell_id = NULL,
  cell_cluster = FALSE,
  cluster_method = "louvain",
  vertex.colors = NULL,
  vertex.size = 10,
  vertex.label.cex = 0.8,
  vertex.label.dist = 1,
  vertex.label.color = "black",
  edge.width = 5,
  margin = 0,
  layout = layout_with_lgl,
  legend.cex = 1.5,
  legend.pt.cex = 3,
  proportion = 1,
  plotgraph = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCCNetwork_+3A_network.data">network.data</code></td>
<td>
<p>The input network data is the result from the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_cell_id">cell_id</code></td>
<td>
<p>A vector of cell phenotype.Methods include louvain (default), leading eigen and edge betweenness.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_cell_cluster">cell_cluster</code></td>
<td>
<p>A binary value. Whether to automatically identify cell clusters based on edge betweenness. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_cluster_method">cluster_method</code></td>
<td>
<p>Community structure detection method</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_vertex.colors">vertex.colors</code></td>
<td>
<p>The fill color of the vertex. The number of colors should match the number of cell phenotypes. If <code>NULL (default)</code>, the system will automatically assign colors.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_vertex.size">vertex.size</code></td>
<td>
<p>The size of the vertex. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>The font size for vertex labels. Default: <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>The distance of the label from the center of the vertex. If it is 0 then the label is centered on the vertex. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>The color of the labels. Default: <code>black</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_edge.width">edge.width</code></td>
<td>
<p>The width of the edge. This does not affect the relative size of the edge weights. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_margin">margin</code></td>
<td>
<p>The amount of empty space below, over, at the left and right of the plot, it is a numeric
vector of length four. Usually values between 0 and 0.5 are meaningful, but negative values
are also possible, that will make the plot zoom in to a part of the graph. If it is shorter than
four then it is recycled. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_layout">layout</code></td>
<td>
<p>Either a function or a numeric matrix. It specifies how the vertices will be placed on the plot. For details, please refer to the <code>igraph</code>Package. Default: <code>layout_with_lgl</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_legend.cex">legend.cex</code></td>
<td>
<p>The font size of legend. Default: <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_legend.pt.cex">legend.pt.cex</code></td>
<td>
<p>Expansion factor(s) for the points. Default: <code>3</code>.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_proportion">proportion</code></td>
<td>
<p>This parameter specifies what percentage of edges to display (edges are sorted by their weight in descending order). Default: <code>1</code>, all edges are used.</p>
</td></tr>
<tr><td><code id="plotCCNetwork_+3A_plotgraph">plotgraph</code></td>
<td>
<p>Whether to draw the picture. Default: <code>TRUE</code>. If <code>FALSE</code>, the image will not be displayed but the network data will be returned in the igraph data format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotCCNetwork
</p>


<h3>Value</h3>

<p>Graph or network data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(igraph)
require(graphics)

data(ConNetGNN_data)

# Construct the cell phenotype vector.
cell_id&lt;-colnames(ConNetGNN_data[["cell_network"]])
temp&lt;-unlist(strsplit(cell_id,"_"))
cell_phen&lt;-temp[seq(2,length(temp)-1,by=3)]
names(cell_id)&lt;-cell_phen
head(cell_id)
plotCCNetwork(ConNetGNN_data,cell_id,edge.width=10)
</code></pre>

<hr>
<h2 id='plotGANetwork'>Visualize gene association network graph of a gene module or pathway at the specified cell phenotype</h2><span id='topic+plotGANetwork'></span>

<h3>Description</h3>

<p>Based on the gene set input by the user, <code>plotGANetwork</code> functional draws the gene association network in the specified cell phenotype.
The node size in the network reflects the activation strength of the gene. The thickness of the edge indicates the strength of interaction between genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGANetwork(
  network.data,
  cellset,
  geneset,
  rwr.gamma = 0.7,
  vertex.colors = NULL,
  vertex.size = 10,
  vertex.label.cex = 0.8,
  vertex.label.dist = 1,
  vertex.label.color = "black",
  edge.width = 5,
  margin = 0,
  layout = layout_as_star,
  main = NULL,
  plotgraph = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGANetwork_+3A_network.data">network.data</code></td>
<td>
<p>Network data constructed by the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_cellset">cellset</code></td>
<td>
<p>A vector of cell id. A cell set corresponding to the specified cell phenotype.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_geneset">geneset</code></td>
<td>
<p>A vector of gene id. A gene module or pathway.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_rwr.gamma">rwr.gamma</code></td>
<td>
<p>Restart parameter. Default: <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_vertex.colors">vertex.colors</code></td>
<td>
<p>The fill color of the vertex. The number of colors should match the number of cell phenotypes. If <code>NULL (default)</code>, the system will automatically assign colors.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_vertex.size">vertex.size</code></td>
<td>
<p>The size of the vertex. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>The font size for vertex labels. Default: <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>The distance of the label from the center of the vertex. If it is 0 then the label is centered on the vertex. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>The color of the labels. Default: <code>black</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_edge.width">edge.width</code></td>
<td>
<p>The width of the edge. This does not affect the relative size of the edge weights. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_margin">margin</code></td>
<td>
<p>The amount of empty space below, over, at the left and right of the plot, it is a numeric
vector of length four. Usually values between 0 and 0.5 are meaningful, but negative values
are also possible, that will make the plot zoom in to a part of the graph. If it is shorter than
four then it is recycled. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_layout">layout</code></td>
<td>
<p>Either a function or a numeric matrix. It specifies how the vertices will be placed on the plot. For details, please refer to the <code>igraph</code>Package. Default: <code>layout_as_star</code>.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="plotGANetwork_+3A_plotgraph">plotgraph</code></td>
<td>
<p>Whether to draw the picture. Default: <code>TRUE</code>. If <code>FALSE</code>, the image will not be displayed but the network data will be returned in the igraph data format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotGANetwork
</p>


<h3>Value</h3>

<p>A graph or list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(igraph)

# Load the result of the ConNetGNN function.
data(ConNetGNN_data)

data("Hv_exp")
index&lt;-grep("0h",colnames(Hv_exp))
cellset&lt;-colnames(Hv_exp)[index]
pathways&lt;-load_path_data(system.file("extdata", "KEGG_human.gmt", package = "scapGNN"))
geneset&lt;-pathways[[which(names(pathways)=="Tight junction [PATH:hsa04530]")]]
plotGANetwork(ConNetGNN_data,cellset,geneset,main = "Tight junction [PATH:hsa04530]")

</code></pre>

<hr>
<h2 id='plotMulPhenGM'>Visualize gene association network graph for activated gene modules under multiple cell phenotypes</h2><span id='topic+plotMulPhenGM'></span>

<h3>Description</h3>

<p>For multiple cell phenotypes, the <code>plotMulPhenGM</code> function will display the activated gene modules for each phenotype and show the connection and status of genes in different cell phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMulPhenGM(
  data.list,
  network.data,
  vertex.colors = NULL,
  vertex.size = 10,
  vertex.label.cex = 0.8,
  vertex.label.dist = 1,
  vertex.label.color = "black",
  edge.width = 5,
  margin = 0,
  layout = layout_with_lgl,
  legend.position = "bottomright",
  legend.cex = 1.5,
  legend.pt.cex = 3,
  plotgraph = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMulPhenGM_+3A_data.list">data.list</code></td>
<td>
<p>a list. Each element represents the <code>cpGModule</code> function result of a cell phenotype and the names of the lists are the corresponding cell phenotype.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_network.data">network.data</code></td>
<td>
<p>Network data constructed by the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_vertex.colors">vertex.colors</code></td>
<td>
<p>The fill color of the vertex. The number of colors should match the number of cell phenotypes. If <code>NULL (default)</code>, the system will automatically assign colors.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_vertex.size">vertex.size</code></td>
<td>
<p>The size of the vertex. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>The font size for vertex labels. Default: <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>The distance of the label from the center of the vertex. If it is 0 then the label is centered on the vertex. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>The color of the labels. Default: <code>black</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_edge.width">edge.width</code></td>
<td>
<p>The width of the edge. This does not affect the relative size of the edge weights. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_margin">margin</code></td>
<td>
<p>The amount of empty space below, over, at the left and right of the plot, it is a numeric
vector of length four. Usually values between 0 and 0.5 are meaningful, but negative values
are also possible, that will make the plot zoom in to a part of the graph. If it is shorter than
four then it is recycled. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_layout">layout</code></td>
<td>
<p>Either a function or a numeric matrix. It specifies how the vertices will be placed on the plot. For details, please refer to the <code>igraph</code> Package. Default: <code>layout_with_lgl</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_legend.position">legend.position</code></td>
<td>
<p>This places the legend on the inside of the plot frame at the given location. See the <code>legend()</code> function for details.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_legend.cex">legend.cex</code></td>
<td>
<p>The font size of legend. Default: <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_legend.pt.cex">legend.pt.cex</code></td>
<td>
<p>Expansion factor(s) for the points. Default: <code>3</code>.</p>
</td></tr>
<tr><td><code id="plotMulPhenGM_+3A_plotgraph">plotgraph</code></td>
<td>
<p>Whether to draw the picture. Default: <code>TRUE</code>. If <code>FALSE</code>, the image will not be displayed but the network data will be returned in the igraph data format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotMulPhenGM
</p>
<p>If a gene is significantly activated in more than one cell phenotype, we call it a co-activated gene. These co-activated genes are shown on the sector diagram.
Each interval of the sector diagram represents the activation strength of the gene in this cell phenotype relative to other cell phenotypes.
</p>


<h3>Value</h3>

<p>A graph or list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(igraph)
require(grDevices)
# Load the result of the ConNetGNN function.
data(ConNetGNN_data)
# Obtain cpGModule results for each cell phenotype.
data(H9_0h_cpGM_data)
data(H9_24h_cpGM_data)
data(H9_36h_cpGM_data)
data.list&lt;-list(H9_0h=H9_0h_cpGM_data,H9_24h=H9_24h_cpGM_data,H9_36h=H9_36h_cpGM_data)
plotMulPhenGM(data.list,ConNetGNN_data)

</code></pre>

<hr>
<h2 id='Preprocessing'>Data preprocessing</h2><span id='topic+Preprocessing'></span>

<h3>Description</h3>

<p>This function is to prepare data for the <code>ConNetGNN</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Preprocessing(data, parallel.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Preprocessing_+3A_data">data</code></td>
<td>
<p>The input data should be a data frame or a matrix where the rows are genes and the columns are cells. The <code>seurat</code> object are also accepted.</p>
</td></tr>
<tr><td><code id="Preprocessing_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Number of processors to use when doing the calculations in parallel (default: <code>2</code>). If <code>parallel.cores=0</code>, then it will use all available core processors unless we set this argument with a smaller number.</p>
</td></tr>
<tr><td><code id="Preprocessing_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preprocessing
</p>
<p>The function is able to interface with the <code>seurat</code> framework. The process of <code>seurat</code> data processing refers to <code>Examples</code>.
The input data should be containing hypervariable genes and log-transformed. Left-truncated mixed Gaussian (LTMG) modeling to calculate gene
regulatory signal matrix. Positively correlated gene-gene and cell-cell are used as the initial gene correlation matrix and cell correlation matrix.
</p>


<h3>Value</h3>

<p>A list:
</p>

<dl>
<dt>orig_dara</dt><dd><p>User-submitted raw data, rows are highly variable genes and columns are cells.</p>
</dd>
<dt>cell_features</dt><dd><p>Cell feature matrix.</p>
</dd>
<dt>gene_features</dt><dd><p>Gene feature matrix.</p>
</dd>
<dt>ltmg_matrix</dt><dd><p>Gene regulatory signal matrix for LTMG.</p>
</dd>
<dt>cell_adj</dt><dd><p>The adjacency matrix of the cell correlation network.</p>
</dd>
<dt>gene_adj</dt><dd><p>The adjacency matrix of the gene correlation network.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load dependent packages.
# require(coop)

# Seurat data processing.
# require(Seurat)

# Load the PBMC dataset (Case data for seurat)
# pbmc.data &lt;- Read10X(data.dir = "../data/pbmc3k/filtered_gene_bc_matrices/hg19/")

# Our recommended data filtering is that only genes expressed as non-zero in more than
# 1% of cells, and cells expressed as non-zero in more than 1% of genes are kept.
# In addition, users can also filter mitochondrial genes according to their own needs.
# pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = "case",
#                                     min.cells = 3, min.features = 200)
# pbmc[["percent.mt"]] &lt;- PercentageFeatureSet(pbmc, pattern = "^MT-")
# pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5)

# Normalizing the data.
# pbmc &lt;- NormalizeData(pbmc, normalization.method = "LogNormalize")

# Identification of highly variable features.
# pbmc &lt;- FindVariableFeatures(pbmc, selection.method = 'vst', nfeatures = 2000)

# Run Preprocessing.
# Prep_data &lt;- Preprocessing(pbmc)



# Users can also directly input data
# in data frame or matrix format
# containing highly variable genes.
data("Hv_exp")
Hv_exp &lt;- Hv_exp[,1:20]
Hv_exp &lt;- Hv_exp[which(rowSums(Hv_exp) &gt; 0),]
Prep_data &lt;- Preprocessing(Hv_exp[1:10,])
</code></pre>

<hr>
<h2 id='Pure_CDF'>Pure_CDF</h2><span id='topic+Pure_CDF'></span>

<h3>Description</h3>

<p>The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pure_CDF(Vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pure_CDF_+3A_vec">Vec</code></td>
<td>
<p>Internal parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pure_CDF
</p>

<hr>
<h2 id='RNA_ATAC_IntNet'>Results of InteNet() for integrating scRNA-seq and scATAC-seq data.</h2><span id='topic+RNA_ATAC_IntNet'></span>

<h3>Description</h3>

<p>An integrated network of scRNA-seq and scATAC-seq data from SNARE-seq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RNA_ATAC_IntNet
</code></pre>


<h3>Format</h3>

<p>a list of three adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RNA_ATAC_IntNet)
</code></pre>

<hr>
<h2 id='RNA_net'>Results of ConNetGNN() for scRNA-seq data from SNARE-seq dataset</h2><span id='topic+RNA_net'></span>

<h3>Description</h3>

<p>A list to store the gene association network of scRNA-seq data.
Case data from the SNARE-seq dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RNA_net
</code></pre>


<h3>Format</h3>

<p>a list of three adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RNA_net)
</code></pre>

<hr>
<h2 id='RunLTMG'>Run Left-truncated mixed Gaussian</h2><span id='topic+RunLTMG'></span><span id='topic+.RunLTMG'></span><span id='topic+RunLTMG+2CLTMG-method'></span>

<h3>Description</h3>

<p>Functional implementation of Left-truncated mixed Gaussian. The internal functions of the <code>scapGNN</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.RunLTMG(object, Gene_use = NULL, k = 5, verbose, seed = 123)

RunLTMG(object, Gene_use = NULL, k = 5, verbose, seed = 123)

## S4 method for signature 'LTMG'
RunLTMG(object, Gene_use = NULL, k = 5, verbose, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunLTMG_+3A_object">object</code></td>
<td>
<p>A LTMG object</p>
</td></tr>
<tr><td><code id="RunLTMG_+3A_gene_use">Gene_use</code></td>
<td>
<p>using X numebr of top variant gene. input a number, recommend 2000.</p>
</td></tr>
<tr><td><code id="RunLTMG_+3A_k">k</code></td>
<td>
<p>Constant, defaults <code>5</code>.</p>
</td></tr>
<tr><td><code id="RunLTMG_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step.</p>
</td></tr>
<tr><td><code id="RunLTMG_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RunLTMG
</p>
<p>For more information, please refer to: <code>DOI: 10.1093/nar/gkz655</code> and <code>https://github.com/zy26/LTMGSCA</code>.
</p>


<h3>Value</h3>

<p>A list contains raw input data and LTMG results.
</p>

<hr>
<h2 id='RWR'>Function that performs a random Walk with restart (RWR) on a given graph</h2><span id='topic+RWR'></span>

<h3>Description</h3>

<p>Function that performs a random Walk with restart (RWR) on a given graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RWR(W, ind.positives, gamma = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RWR_+3A_w">W</code></td>
<td>
<p>: adjacency matrix of the graph</p>
</td></tr>
<tr><td><code id="RWR_+3A_ind.positives">ind.positives</code></td>
<td>
<p>: indices of the &quot;core&quot; positive examples of the graph. They represent to the indices of W corresponding to the positive examples</p>
</td></tr>
<tr><td><code id="RWR_+3A_gamma">gamma</code></td>
<td>
<p>: restart parameter (def: 0.6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements:
- p : the probability at the steady state
- ind.positives : indices of the &quot;core&quot; positive examples of the graph (it is equal to the same
input parameter
- n.iter : number of performed iterations
</p>
<p>a vector
</p>

<hr>
<h2 id='scPathway'>Infer pathway activation score matrix at single-cell resolution</h2><span id='topic+scPathway'></span>

<h3>Description</h3>

<p>Calculate pathway activity score of single-cell by random walk with restart (RWR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scPathway(
  network.data,
  gmt.path = NULL,
  pathway.min = 10,
  pathway.max = 500,
  nperm = 50,
  parallel.cores = 2,
  rwr.gamma = 0.7,
  normal_dist = TRUE,
  seed = 1217,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scPathway_+3A_network.data">network.data</code></td>
<td>
<p>The input network data is the result from the <code>ConNetGNN</code> function.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_gmt.path">gmt.path</code></td>
<td>
<p>Pathway database in <code>GMT</code> format.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_pathway.min">pathway.min</code></td>
<td>
<p>Minimum size (in genes) for pathway to be considered. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_pathway.max">pathway.max</code></td>
<td>
<p>Maximum size (in genes) for database gene sets to be considered. Default: <code>500</code>.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_nperm">nperm</code></td>
<td>
<p>Number of random permutations. Default: <code>50</code>. We recommend the setting of 100.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Number of processors to use when doing the calculations in parallel (default: <code>2</code>). If <code>parallel.cores=0</code>, then it will use all available core processors unless we set this argument with a smaller number.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_rwr.gamma">rwr.gamma</code></td>
<td>
<p>Restart parameter. Default: <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_normal_dist">normal_dist</code></td>
<td>
<p>Whether to use pnorm to calculate P values. Default: <code>TRUE</code>.Note that if normal_dist is FALSE, we need to increase nperm (we recommend 100).</p>
</td></tr>
<tr><td><code id="scPathway_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed.</p>
</td></tr>
<tr><td><code id="scPathway_+3A_verbose">verbose</code></td>
<td>
<p>Gives information about each step. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>scPathway
</p>
<p>The <code>scPathway</code> function integrates the results of ConNetGNN into a gene-cell association network.
The genes included in each pathway are used as a restart set in the gene-cell association network to calculate the strength of its association with each cell through <code>RWR</code>.
Perturbation analysis was performed to remove noise effects in the network and to obtain the final single-cell pathway activity score matrix.
</p>


<h3>Value</h3>

<p>A matrix of single-cell pathway activity score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(parallel)
require(utils)
# Load the result of the ConNetGNN function.
data(ConNetGNN_data)
kegg.path&lt;-system.file("extdata", "KEGG_human.gmt", package = "scapGNN")
# We recommend the use of a compiler.
# The compiler package can be used to speed up the operation.
# library(compiler)
# scPathway&lt;- cmpfun(scPathway)
scPathway_data&lt;-scPathway(ConNetGNN_data,gmt.path=kegg.path,
                          pathway.min=25,nperm=2,parallel.cores=1)

</code></pre>

<hr>
<h2 id='scPathway_data'>Single cell pathway activity matrix</h2><span id='topic+scPathway_data'></span>

<h3>Description</h3>

<p>Results of scPathway() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scPathway_data
</code></pre>


<h3>Format</h3>

<p>a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scPathway_data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
