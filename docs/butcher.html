<!DOCTYPE html><html lang="en"><head><title>Help for package butcher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {butcher}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#butcher-package'><p>Reduce the Size of Modeling Objects</p></a></li>
<li><a href='#axe_call'><p>Axe a call.</p></a></li>
<li><a href='#axe_ctrl'><p>Axe controls.</p></a></li>
<li><a href='#axe_data'><p>Axe data.</p></a></li>
<li><a href='#axe_env'><p>Axe an environment.</p></a></li>
<li><a href='#axe_fitted'><p>Axe fitted values.</p></a></li>
<li><a href='#axe-bart'><p>Axing a bart model.</p></a></li>
<li><a href='#axe-C5.0'><p>Axing a C5.0.</p></a></li>
<li><a href='#axe-coxph'><p>Axing a coxph.</p></a></li>
<li><a href='#axe-earth'><p>Axing an earth object.</p></a></li>
<li><a href='#axe-elnet'><p>Axing an elnet.</p></a></li>
<li><a href='#axe-flexsurvreg'><p>Axing an flexsurvreg.</p></a></li>
<li><a href='#axe-formula'><p>Axing formulas.</p></a></li>
<li><a href='#axe-function'><p>Axing functions.</p></a></li>
<li><a href='#axe-gam'><p>Axing a gam.</p></a></li>
<li><a href='#axe-gausspr'><p>Axing a gausspr.</p></a></li>
<li><a href='#axe-glm'><p>Axing a glm.</p></a></li>
<li><a href='#axe-glmnet'><p>Axing a glmnet.</p></a></li>
<li><a href='#axe-ipred'><p>Axing a bagged tree.</p></a></li>
<li><a href='#axe-kknn'><p>Axing an kknn.</p></a></li>
<li><a href='#axe-KMeansCluster'><p>Axing a KMeansCluster.</p></a></li>
<li><a href='#axe-kproto'><p>Axing a kproto.</p></a></li>
<li><a href='#axe-ksvm'><p>Axing a ksvm object.</p></a></li>
<li><a href='#axe-lm'><p>Axing an lm.</p></a></li>
<li><a href='#axe-mass'><p>Axing a MASS discriminant analysis object.</p></a></li>
<li><a href='#axe-mda'><p>Axing a mda.</p></a></li>
<li><a href='#axe-model_fit'><p>Axing an model_fit.</p></a></li>
<li><a href='#axe-multnet'><p>Axing an multnet.</p></a></li>
<li><a href='#axe-NaiveBayes'><p>Axing a NaiveBayes.</p></a></li>
<li><a href='#axe-nnet'><p>Axing a nnet.</p></a></li>
<li><a href='#axe-pls'><p>Axing mixOmics models</p></a></li>
<li><a href='#axe-randomForest'><p>Axing an randomForest.</p></a></li>
<li><a href='#axe-ranger'><p>Axing an ranger.</p></a></li>
<li><a href='#axe-rda'><p>Axing an rda.</p></a></li>
<li><a href='#axe-recipe'><p>Axing a recipe object.</p></a></li>
<li><a href='#axe-rpart'><p>Axing a rpart.</p></a></li>
<li><a href='#axe-sclass'><p>Axing a sclass object.</p></a></li>
<li><a href='#axe-spark'><p>Axing a spark object.</p></a></li>
<li><a href='#axe-survreg'><p>Axing an survreg.</p></a></li>
<li><a href='#axe-survreg.penal'><p>Axing an survreg.penal</p></a></li>
<li><a href='#axe-terms'><p>Axing for terms inputs.</p></a></li>
<li><a href='#axe-train'><p>Axing a train object.</p></a></li>
<li><a href='#axe-train.recipe'><p>Axing a train.recipe object.</p></a></li>
<li><a href='#axe-xgb.Booster'><p>Axing a xgb.Booster.</p></a></li>
<li><a href='#axe-xrf'><p>Axing a xrf.</p></a></li>
<li><a href='#butcher'><p>Butcher an object.</p></a></li>
<li><a href='#butcher_example'><p>Get path to model object example.</p></a></li>
<li><a href='#locate'><p>Locate part of an object.</p></a></li>
<li><a href='#new_model_butcher'><p>New axe functions for a modeling object.</p></a></li>
<li><a href='#ui'><p>Console Messages</p></a></li>
<li><a href='#weigh'><p>Weigh the object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Model Butcher</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of S3 generics to axe components of fitted
    model objects and help reduce the size of model objects saved to disk.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://butcher.tidymodels.org/">https://butcher.tidymodels.org/</a>,
<a href="https://github.com/tidymodels/butcher">https://github.com/tidymodels/butcher</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/butcher/issues">https://github.com/tidymodels/butcher/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.3.0), lobstr (&ge; 1.1.2), methods, purrr (&ge; 0.3.4),
rlang (&ge; 1.0.2), tibble (&ge; 3.1.7), utils, vctrs (&ge; 0.4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>C50, caret, ClusterR, clustMixType, covr, dbarts, ddalpha,
dplyr, e1071, earth, flexsurv, fs, ipred, kernlab, kknn, klaR,
knitr, MASS, mda, mgcv, modeldata, nnet, parsnip (&ge; 0.1.6),
pkgload, pls, QSARdata, randomForest, ranger, RANN, recipes (&ge;
0.2.0), rmarkdown, rpart, rsample, RSpectra, sparklyr, survival
(&ge; 3.2-10), testthat (&ge; 3.0.0), TH.data, usethis (&ge; 1.5.0),
xgboost (&ge; 1.3.2.1), xrf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>bioc::mixOmics</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-18 20:25:51 UTC; juliasilge</td>
</tr>
<tr>
<td>Author:</td>
<td>Joyce Cahoon <a href="https://orcid.org/0000-0001-7217-4702"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Davis Vaughan [aut],
  Max Kuhn [aut],
  Alex Hayes [aut],
  Julia Silge <a href="https://orcid.org/0000-0002-3671-836X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julia Silge &lt;julia.silge@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='butcher-package'>Reduce the Size of Modeling Objects</h2><span id='topic+butcher-package'></span>

<h3>Description</h3>

<p>Reduce the size of modeling objects after fitting. These parsed-down
versions of the original modeling object have been tested to work with their
respective <code>predict</code> functions. Future iterations of this package
should support additional analysis functions outside of just <code>predict</code>.
</p>
<p>This package provides five S3 generics:
</p>

<ul>
<li> <p><code><a href="#topic+axe_call">axe_call</a></code> To remove the call object.
</p>
</li>
<li> <p><code><a href="#topic+axe_ctrl">axe_ctrl</a></code> To remove controls associated with training.
</p>
</li>
<li> <p><code><a href="#topic+axe_data">axe_data</a></code> To remove the original data.
</p>
</li>
<li> <p><code><a href="#topic+axe_env">axe_env</a></code> To remove inherited environments.
</p>
</li>
<li> <p><code><a href="#topic+axe_fitted">axe_fitted</a></code> To remove fitted values.
</p>
</li></ul>

<p>These specific attributes of the model objects are chosen as they are
often not required for downstream data analysis functions to work and
are often the heaviest components of the fitted object. By calling
the wrapper function <code>butcher</code>, all the sub-axe functions listed above
are executed on the model object, returning a butchered model object that has
an additional <code>butcher</code> class assignment. If only a specific <code>axe_</code>
function is called, the axed model object will also have the same addition
of a <code>butcher</code> class assignment.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Julia Silge <a href="mailto:julia.silge@posit.co">julia.silge@posit.co</a> (<a href="https://orcid.org/0000-0002-3671-836X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Joyce Cahoon <a href="mailto:joyceyu48@gmail.com">joyceyu48@gmail.com</a> (<a href="https://orcid.org/0000-0001-7217-4702">ORCID</a>)
</p>
</li>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
</li>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a>
</p>
</li>
<li><p> Alex Hayes <a href="mailto:alexpghayes@gmail.com">alexpghayes@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://butcher.tidymodels.org/">https://butcher.tidymodels.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidymodels/butcher">https://github.com/tidymodels/butcher</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/butcher/issues">https://github.com/tidymodels/butcher/issues</a>
</p>
</li></ul>


<hr>
<h2 id='axe_call'>Axe a call.</h2><span id='topic+axe_call'></span>

<h3>Description</h3>

<p>Replace the call object attached to modeling objects with a placeholder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axe_call(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe_call_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe_call_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_call_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model object without call attribute.
</p>


<h3>Methods</h3>

<p>See the following help topics for more details about individual methods:
</p>
<p><code>butcher</code></p>
<ul>
<li><p><code><a href="#topic+axe-C5.0">axe-C5.0</a></code>: <code>C5.0</code></p>
</li>
<li><p><code><a href="#topic+axe-KMeansCluster">axe-KMeansCluster</a></code>: <code>KMeansCluster</code></p>
</li>
<li><p><code><a href="#topic+axe-NaiveBayes">axe-NaiveBayes</a></code>: <code>NaiveBayes</code></p>
</li>
<li><p><code><a href="#topic+axe-bart">axe-bart</a></code>: <code>bart</code></p>
</li>
<li><p><code><a href="#topic+axe-earth">axe-earth</a></code>: <code>earth</code></p>
</li>
<li><p><code><a href="#topic+axe-elnet">axe-elnet</a></code>: <code>elnet</code></p>
</li>
<li><p><code><a href="#topic+axe-flexsurvreg">axe-flexsurvreg</a></code>: <code>flexsurvreg</code></p>
</li>
<li><p><code><a href="#topic+axe-gam">axe-gam</a></code>: <code>gam</code></p>
</li>
<li><p><code><a href="#topic+axe-gausspr">axe-gausspr</a></code>: <code>gausspr</code></p>
</li>
<li><p><code><a href="#topic+axe-glm">axe-glm</a></code>: <code>glm</code></p>
</li>
<li><p><code><a href="#topic+axe-glmnet">axe-glmnet</a></code>: <code>glmnet</code></p>
</li>
<li><p><code><a href="#topic+axe-ipred">axe-ipred</a></code>: <code>classbagg</code>, <code>regbagg</code>, <code>survbagg</code></p>
</li>
<li><p><code><a href="#topic+axe-kknn">axe-kknn</a></code>: <code>kknn</code></p>
</li>
<li><p><code><a href="#topic+axe-ksvm">axe-ksvm</a></code>: <code>ksvm</code></p>
</li>
<li><p><code><a href="#topic+axe-lm">axe-lm</a></code>: <code>lm</code></p>
</li>
<li><p><code><a href="#topic+axe-mda">axe-mda</a></code>: <code>fda</code>, <code>mda</code></p>
</li>
<li><p><code><a href="#topic+axe-model_fit">axe-model_fit</a></code>: <code>model_fit</code></p>
</li>
<li><p><code><a href="#topic+axe-multnet">axe-multnet</a></code>: <code>multnet</code></p>
</li>
<li><p><code><a href="#topic+axe-nnet">axe-nnet</a></code>: <code>nnet</code></p>
</li>
<li><p><code><a href="#topic+axe-pls">axe-pls</a></code>: <code>mixo_pls</code>, <code>mixo_spls</code></p>
</li>
<li><p><code><a href="#topic+axe-randomForest">axe-randomForest</a></code>: <code>randomForest</code></p>
</li>
<li><p><code><a href="#topic+axe-ranger">axe-ranger</a></code>: <code>ranger</code></p>
</li>
<li><p><code><a href="#topic+axe-rda">axe-rda</a></code>: <code>rda</code></p>
</li>
<li><p><code><a href="#topic+axe-rpart">axe-rpart</a></code>: <code>rpart</code></p>
</li>
<li><p><code><a href="#topic+axe-sclass">axe-sclass</a></code>: <code>sclass</code></p>
</li>
<li><p><code><a href="#topic+axe-spark">axe-spark</a></code>: <code>ml_model</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg">axe-survreg</a></code>: <code>survreg</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg.penal">axe-survreg.penal</a></code>: <code>survreg.penal</code></p>
</li>
<li><p><code><a href="#topic+axe-train">axe-train</a></code>: <code>train</code></p>
</li>
<li><p><code><a href="#topic+axe-train.recipe">axe-train.recipe</a></code>: <code>train.recipe</code></p>
</li>
<li><p><code><a href="#topic+axe-xgb.Booster">axe-xgb.Booster</a></code>: <code>xgb.Booster</code></p>
</li>
<li><p><code><a href="#topic+axe-xrf">axe-xrf</a></code>: <code>xrf</code></p>
</li></ul>


<hr>
<h2 id='axe_ctrl'>Axe controls.</h2><span id='topic+axe_ctrl'></span>

<h3>Description</h3>

<p>Remove the controls from training attached to modeling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axe_ctrl(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe_ctrl_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe_ctrl_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_ctrl_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model object without control tuning parameters from training.
</p>


<h3>Methods</h3>

<p>See the following help topics for more details about individual methods:
</p>
<p><code>butcher</code></p>
<ul>
<li><p><code><a href="#topic+axe-C5.0">axe-C5.0</a></code>: <code>C5.0</code></p>
</li>
<li><p><code><a href="#topic+axe-gam">axe-gam</a></code>: <code>gam</code></p>
</li>
<li><p><code><a href="#topic+axe-ipred">axe-ipred</a></code>: <code>classbagg</code>, <code>regbagg</code>, <code>survbagg</code></p>
</li>
<li><p><code><a href="#topic+axe-model_fit">axe-model_fit</a></code>: <code>model_fit</code></p>
</li>
<li><p><code><a href="#topic+axe-randomForest">axe-randomForest</a></code>: <code>randomForest</code></p>
</li>
<li><p><code><a href="#topic+axe-rpart">axe-rpart</a></code>: <code>rpart</code></p>
</li>
<li><p><code><a href="#topic+axe-spark">axe-spark</a></code>: <code>ml_model</code></p>
</li>
<li><p><code><a href="#topic+axe-train">axe-train</a></code>: <code>train</code></p>
</li>
<li><p><code><a href="#topic+axe-train.recipe">axe-train.recipe</a></code>: <code>train.recipe</code></p>
</li></ul>


<hr>
<h2 id='axe_data'>Axe data.</h2><span id='topic+axe_data'></span>

<h3>Description</h3>

<p>Remove the training data attached to modeling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axe_data(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe_data_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe_data_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_data_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model object without the training data
</p>


<h3>Methods</h3>

<p>See the following help topics for more details about individual methods:
</p>
<p><code>butcher</code></p>
<ul>
<li><p><code><a href="#topic+axe-NaiveBayes">axe-NaiveBayes</a></code>: <code>NaiveBayes</code></p>
</li>
<li><p><code><a href="#topic+axe-coxph">axe-coxph</a></code>: <code>coxph</code></p>
</li>
<li><p><code><a href="#topic+axe-earth">axe-earth</a></code>: <code>earth</code></p>
</li>
<li><p><code><a href="#topic+axe-gam">axe-gam</a></code>: <code>gam</code></p>
</li>
<li><p><code><a href="#topic+axe-gausspr">axe-gausspr</a></code>: <code>gausspr</code></p>
</li>
<li><p><code><a href="#topic+axe-glm">axe-glm</a></code>: <code>glm</code></p>
</li>
<li><p><code><a href="#topic+axe-ipred">axe-ipred</a></code>: <code>classbagg</code>, <code>regbagg</code>, <code>survbagg</code></p>
</li>
<li><p><code><a href="#topic+axe-kproto">axe-kproto</a></code>: <code>kproto</code></p>
</li>
<li><p><code><a href="#topic+axe-ksvm">axe-ksvm</a></code>: <code>ksvm</code></p>
</li>
<li><p><code><a href="#topic+axe-model_fit">axe-model_fit</a></code>: <code>model_fit</code></p>
</li>
<li><p><code><a href="#topic+axe-pls">axe-pls</a></code>: <code>mixo_pls</code>, <code>mixo_spls</code></p>
</li>
<li><p><code><a href="#topic+axe-rpart">axe-rpart</a></code>: <code>rpart</code></p>
</li>
<li><p><code><a href="#topic+axe-spark">axe-spark</a></code>: <code>ml_model</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg">axe-survreg</a></code>: <code>survreg</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg.penal">axe-survreg.penal</a></code>: <code>survreg.penal</code></p>
</li>
<li><p><code><a href="#topic+axe-train">axe-train</a></code>: <code>train</code></p>
</li>
<li><p><code><a href="#topic+axe-train.recipe">axe-train.recipe</a></code>: <code>train.recipe</code></p>
</li></ul>


<hr>
<h2 id='axe_env'>Axe an environment.</h2><span id='topic+axe_env'></span>

<h3>Description</h3>

<p>Remove the environment(s) attached to modeling objects as they are
not required in the downstream analysis pipeline. If found,
the environment is replaced with <code>rlang::base_env()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe_env_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe_env_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_env_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model object with empty environments.
</p>


<h3>Methods</h3>

<p>See the following help topics for more details about individual methods:
</p>
<p><code>butcher</code></p>
<ul>
<li><p><code><a href="#topic+axe-coxph">axe-coxph</a></code>: <code>coxph</code></p>
</li>
<li><p><code><a href="#topic+axe-flexsurvreg">axe-flexsurvreg</a></code>: <code>flexsurvreg</code></p>
</li>
<li><p><code><a href="#topic+axe-formula">axe-formula</a></code>: <code>formula</code></p>
</li>
<li><p><code><a href="#topic+axe-function">axe-function</a></code>: <code>function</code></p>
</li>
<li><p><code><a href="#topic+axe-gam">axe-gam</a></code>: <code>gam</code></p>
</li>
<li><p><code><a href="#topic+axe-gausspr">axe-gausspr</a></code>: <code>gausspr</code></p>
</li>
<li><p><code><a href="#topic+axe-glm">axe-glm</a></code>: <code>glm</code></p>
</li>
<li><p><code><a href="#topic+axe-ipred">axe-ipred</a></code>: <code>classbagg</code>, <code>regbagg</code>, <code>survbagg</code></p>
</li>
<li><p><code><a href="#topic+axe-kknn">axe-kknn</a></code>: <code>kknn</code></p>
</li>
<li><p><code><a href="#topic+axe-lm">axe-lm</a></code>: <code>lm</code></p>
</li>
<li><p><code><a href="#topic+axe-mass">axe-mass</a></code>: <code>lda</code>, <code>qda</code></p>
</li>
<li><p><code><a href="#topic+axe-mda">axe-mda</a></code>: <code>fda</code>, <code>mda</code></p>
</li>
<li><p><code><a href="#topic+axe-model_fit">axe-model_fit</a></code>: <code>model_fit</code></p>
</li>
<li><p><code><a href="#topic+axe-nnet">axe-nnet</a></code>: <code>nnet</code></p>
</li>
<li><p><code><a href="#topic+axe-randomForest">axe-randomForest</a></code>: <code>randomForest</code></p>
</li>
<li><p><code><a href="#topic+axe-rda">axe-rda</a></code>: <code>rda</code></p>
</li>
<li><p><code><a href="#topic+axe-recipe">axe-recipe</a></code>: <code>quosure</code>, <code>recipe</code>, <code>step</code>, <code>step_arrange</code>, <code>step_bagimpute</code>, <code>step_filter</code>, <code>step_geodist</code>, <code>step_impute_bag</code>, <code>step_impute_knn</code>, <code>step_interact</code>, <code>step_knnimpute</code>, <code>step_mutate</code>, <code>step_ratio</code>, <code>step_slice</code></p>
</li>
<li><p><code><a href="#topic+axe-rpart">axe-rpart</a></code>: <code>rpart</code></p>
</li>
<li><p><code><a href="#topic+axe-sclass">axe-sclass</a></code>: <code>sclass</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg">axe-survreg</a></code>: <code>survreg</code></p>
</li>
<li><p><code><a href="#topic+axe-survreg.penal">axe-survreg.penal</a></code>: <code>survreg.penal</code></p>
</li>
<li><p><code><a href="#topic+axe-terms">axe-terms</a></code>: <code>terms</code></p>
</li>
<li><p><code><a href="#topic+axe-train">axe-train</a></code>: <code>train</code></p>
</li>
<li><p><code><a href="#topic+axe-train.recipe">axe-train.recipe</a></code>: <code>train.recipe</code></p>
</li>
<li><p><code><a href="#topic+axe-xgb.Booster">axe-xgb.Booster</a></code>: <code>xgb.Booster</code></p>
</li>
<li><p><code><a href="#topic+axe-xrf">axe-xrf</a></code>: <code>xrf</code></p>
</li></ul>


<hr>
<h2 id='axe_fitted'>Axe fitted values.</h2><span id='topic+axe_fitted'></span>

<h3>Description</h3>

<p>Remove the fitted values attached to modeling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe_fitted_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe_fitted_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe_fitted_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model object without the fitted values.
</p>


<h3>Methods</h3>

<p>See the following help topics for more details about individual methods:
</p>
<p><code>butcher</code></p>
<ul>
<li><p><code><a href="#topic+axe-C5.0">axe-C5.0</a></code>: <code>C5.0</code></p>
</li>
<li><p><code><a href="#topic+axe-KMeansCluster">axe-KMeansCluster</a></code>: <code>KMeansCluster</code></p>
</li>
<li><p><code><a href="#topic+axe-bart">axe-bart</a></code>: <code>bart</code></p>
</li>
<li><p><code><a href="#topic+axe-earth">axe-earth</a></code>: <code>earth</code></p>
</li>
<li><p><code><a href="#topic+axe-gam">axe-gam</a></code>: <code>gam</code></p>
</li>
<li><p><code><a href="#topic+axe-gausspr">axe-gausspr</a></code>: <code>gausspr</code></p>
</li>
<li><p><code><a href="#topic+axe-glm">axe-glm</a></code>: <code>glm</code></p>
</li>
<li><p><code><a href="#topic+axe-kknn">axe-kknn</a></code>: <code>kknn</code></p>
</li>
<li><p><code><a href="#topic+axe-kproto">axe-kproto</a></code>: <code>kproto</code></p>
</li>
<li><p><code><a href="#topic+axe-ksvm">axe-ksvm</a></code>: <code>ksvm</code></p>
</li>
<li><p><code><a href="#topic+axe-lm">axe-lm</a></code>: <code>lm</code></p>
</li>
<li><p><code><a href="#topic+axe-mda">axe-mda</a></code>: <code>fda</code>, <code>mda</code></p>
</li>
<li><p><code><a href="#topic+axe-model_fit">axe-model_fit</a></code>: <code>model_fit</code></p>
</li>
<li><p><code><a href="#topic+axe-nnet">axe-nnet</a></code>: <code>nnet</code></p>
</li>
<li><p><code><a href="#topic+axe-pls">axe-pls</a></code>: <code>mixo_pls</code>, <code>mixo_spls</code></p>
</li>
<li><p><code><a href="#topic+axe-ranger">axe-ranger</a></code>: <code>ranger</code></p>
</li>
<li><p><code><a href="#topic+axe-recipe">axe-recipe</a></code>: <code>recipe</code></p>
</li>
<li><p><code><a href="#topic+axe-spark">axe-spark</a></code>: <code>ml_model</code></p>
</li>
<li><p><code><a href="#topic+axe-train">axe-train</a></code>: <code>train</code></p>
</li>
<li><p><code><a href="#topic+axe-train.recipe">axe-train.recipe</a></code>: <code>train.recipe</code></p>
</li></ul>


<hr>
<h2 id='axe-bart'>Axing a bart model.</h2><span id='topic+axe-bart'></span><span id='topic+axe_call.bart'></span><span id='topic+axe_fitted.bart'></span>

<h3>Description</h3>

<p>Axing a bart model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bart'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'bart'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-bart_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-bart_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-bart_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed bart object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dbarts)
x &lt;- dbarts::bart(mtcars[,2:5], mtcars[,1], verbose = FALSE, keeptrees = TRUE)
res &lt;- butcher(x, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-C5.0'>Axing a C5.0.</h2><span id='topic+axe-C5.0'></span><span id='topic+axe_call.C5.0'></span><span id='topic+axe_ctrl.C5.0'></span><span id='topic+axe_fitted.C5.0'></span>

<h3>Description</h3>

<p>C5.0 objects are created from the <code>C50</code> package, which provides an
interface to the C5.0 classification model. The models that can be
generated include basic tree-based models as well as rule-based models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'C5.0'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'C5.0'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'C5.0'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-C5.0_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-C5.0_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-C5.0_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed C5.0 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)
library(rpart)

# Load data
set.seed(1234)
split &lt;- initial_split(kyphosis, prop = 9/10)
spine_train &lt;- training(split)

# Create model and fit
c5_fit &lt;- decision_tree(mode = "classification") %&gt;%
  set_engine("C5.0") %&gt;%
  fit(Kyphosis ~ ., data = spine_train)

out &lt;- butcher(c5_fit, verbose = TRUE)

# Try another model from parsnip
c5_fit2 &lt;- boost_tree(mode = "classification", trees = 100) %&gt;%
  set_engine("C5.0") %&gt;%
  fit(Kyphosis ~ ., data = spine_train)
out &lt;- butcher(c5_fit2, verbose = TRUE)

# Create model object from original library
library(C50)
library(modeldata)
data(mlc_churn)
c5_fit3 &lt;- C5.0(x = mlc_churn[, -20], y = mlc_churn$churn)
out &lt;- butcher(c5_fit3, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-coxph'>Axing a coxph.</h2><span id='topic+axe-coxph'></span><span id='topic+axe_env.coxph'></span><span id='topic+axe_data.coxph'></span>

<h3>Description</h3>

<p>Axing a coxph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'coxph'
axe_data(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-coxph_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-coxph_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-coxph_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> model is unique in how it uses environments in
its components, and butchering such an object can behave in surprising ways
in any environment other than the
<a href="https://adv-r.hadley.nz/environments.html#important-environments">global environment</a>
(such as when wrapped in a function). We do not recommend that you use
<code>butcher()</code> with a <code>coxph</code> object anywhere other than the global environment.
</p>
<p>Do this:
</p>
<div class="sourceCode r"><pre>my_coxph_func &lt;- function(df) {
    coxph(Surv(time, status) ~ x + strata(covar), df)
}
## in global environment only:
butcher(my_coxph_func(df))
</pre></div>
<p>Do <em>not</em> do this:
</p>
<div class="sourceCode r"><pre>my_coxph_func &lt;- function(df) {
    res &lt;- coxph(Surv(time, status) ~ x + strata(covar), df)
    ## no:
    butcher(res)
}

## will not work correctly:
my_coxph_func(df)
</pre></div>


<h3>Value</h3>

<p>Axed coxph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

example_data &lt;-
  tibble::tibble(
    time = rpois(1000, 2) + 1,
    status = rbinom(1000, 1, .5),
    x = rpois(1000, .5),
    covar = rbinom(1000, 1, .5)
  )

example_data

make_big_model &lt;- function() {
  boop &lt;- runif(1e6)
  coxph(Surv(time, status) ~ x + strata(covar), example_data)
}

res &lt;- make_big_model()

weigh(res)
weigh(butcher(res))

</code></pre>

<hr>
<h2 id='axe-earth'>Axing an earth object.</h2><span id='topic+axe-earth'></span><span id='topic+axe_call.earth'></span><span id='topic+axe_data.earth'></span><span id='topic+axe_fitted.earth'></span>

<h3>Description</h3>

<p>earth objects are created from the <span class="pkg">earth</span> package, which
is leveraged to do multivariate adaptive regression splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'earth'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'earth'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'earth'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-earth_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-earth_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-earth_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed earth object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)

# Create model and fit
earth_fit &lt;- mars(mode = "regression") %&gt;%
  set_engine("earth") %&gt;%
  fit(Volume ~ ., data = trees)

out &lt;- butcher(earth_fit, verbose = TRUE)

# Another earth model object
suppressWarnings(suppressMessages(library(earth)))
earth_mod &lt;- earth(Volume ~ ., data = trees)
out &lt;- butcher(earth_mod, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-elnet'>Axing an elnet.</h2><span id='topic+axe-elnet'></span><span id='topic+axe_call.elnet'></span>

<h3>Description</h3>

<p>elnet objects are created from the <span class="pkg">glmnet</span> package, leveraged
to fit generalized linear models via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elnet'
axe_call(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-elnet_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-elnet_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-elnet_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)

# Load data
split &lt;- initial_split(mtcars, prop = 9/10)
car_train &lt;- training(split)

# Create model and fit
elnet_fit &lt;- linear_reg(mixture = 0, penalty = 0.1) %&gt;%
  set_engine("glmnet") %&gt;%
  fit_xy(x = car_train[, 2:11], y = car_train[, 1, drop = FALSE])

out &lt;- butcher(elnet_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-flexsurvreg'>Axing an flexsurvreg.</h2><span id='topic+axe-flexsurvreg'></span><span id='topic+axe_call.flexsurvreg'></span><span id='topic+axe_env.flexsurvreg'></span>

<h3>Description</h3>

<p>flexsurvreg objects are created from the <span class="pkg">flexsurv</span> package. They
differ from survreg in that the fitted models are not limited to certain
parametric distributions. Users can define their own distribution, or
leverage distributions like the generalized gamma, generalized F, and
the Royston-Parmar spline model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flexsurvreg'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'flexsurvreg'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-flexsurvreg_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-flexsurvreg_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-flexsurvreg_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed flexsurvreg object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(flexsurv)

# Create model and fit
flexsurvreg_fit &lt;- surv_reg(mode = "regression", dist = "gengamma") %&gt;%
  set_engine("flexsurv") %&gt;%
  fit(Surv(Tstart, Tstop, status) ~ trans, data = bosms3)

out &lt;- butcher(flexsurvreg_fit, verbose = TRUE)

# Another flexsurvreg model object
wrapped_flexsurvreg &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- flexsurvreg(Surv(futime, fustat) ~ 1,
                     data = ovarian, dist = "weibull")
  return(fit)
}

out &lt;- butcher(wrapped_flexsurvreg(), verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-formula'>Axing formulas.</h2><span id='topic+axe-formula'></span><span id='topic+axe_env.formula'></span>

<h3>Description</h3>

<p>formulas might capture an environment from the modeling development
process that carries objects that will not be used for any post-
estimation activities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-formula_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-formula_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-formula_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed formula object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wrapped_formula &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  ex &lt;- as.formula(paste("y ~", paste(LETTERS, collapse = "+")))
  return(ex)
}

lobstr::obj_size(wrapped_formula())
lobstr::obj_size(butcher(wrapped_formula()))

wrapped_quosure &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  out &lt;- rlang::quo(x)
  return(out)
}
lobstr::obj_size(wrapped_quosure())
lobstr::obj_size(butcher(wrapped_quosure))

</code></pre>

<hr>
<h2 id='axe-function'>Axing functions.</h2><span id='topic+axe-function'></span><span id='topic+axe_env.function'></span>

<h3>Description</h3>

<p>Functions stored in model objects often have heavy environments
and bytecode attached. To avoid breaking any post-estimation functions
on the model object, the <code>butchered_function</code> class is not
appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-function_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-function_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-function_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(caret)

data(iris)
train_data &lt;- iris[, 1:4]
train_classes &lt;- iris[, 5]

train_fit &lt;- train(train_data, train_classes,
                   method = "knn",
                   preProcess = c("center", "scale"),
                   tuneLength = 10,
                   trControl = trainControl(method = "cv"))

out &lt;- axe_env(train_fit$modelInfo$prob, verbose = TRUE)
out &lt;- axe_env(train_fit$modelInfo$levels, verbose = TRUE)
out &lt;- axe_env(train_fit$modelInfo$predict, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-gam'>Axing a gam.</h2><span id='topic+axe-gam'></span><span id='topic+axe_call.gam'></span><span id='topic+axe_ctrl.gam'></span><span id='topic+axe_data.gam'></span><span id='topic+axe_env.gam'></span><span id='topic+axe_fitted.gam'></span>

<h3>Description</h3>

<p>gam objects are created from the <span class="pkg">mgcv</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'gam'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'gam'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'gam'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'gam'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-gam_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-gam_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-gam_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed gam object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

cars_gam &lt;- mgcv::gam(mpg ~ s(disp, k = 3) + s(wt), data = mtcars)
cleaned_gam &lt;- butcher(cars_gam, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-gausspr'>Axing a gausspr.</h2><span id='topic+axe-gausspr'></span><span id='topic+axe_call.gausspr'></span><span id='topic+axe_data.gausspr'></span><span id='topic+axe_env.gausspr'></span><span id='topic+axe_fitted.gausspr'></span>

<h3>Description</h3>

<p>gausspr objects are created from <span class="pkg">kernlab</span> package, which
provides a means to do classification, regression, clustering,
novelty detection, quantile regression and dimensionality
reduction. Since fitted model objects from <span class="pkg">kernlab</span> are S4,
the <code>butcher_gausspr</code> class is not appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gausspr'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'gausspr'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'gausspr'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'gausspr'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-gausspr_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-gausspr_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-gausspr_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed gausspr object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kernlab)

test &lt;- gausspr(Species ~ ., data = iris, var = 2)

out &lt;- butcher(test, verbose = TRUE)

# Example with simulated regression data
x &lt;- seq(-20, 20, 0.1)
y &lt;- sin(x)/x + rnorm(401, sd = 0.03)
test2 &lt;- gausspr(x, y)
out &lt;- butcher(test2, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-glm'>Axing a glm.</h2><span id='topic+axe-glm'></span><span id='topic+axe_call.glm'></span><span id='topic+axe_data.glm'></span><span id='topic+axe_env.glm'></span><span id='topic+axe_fitted.glm'></span>

<h3>Description</h3>

<p>glm objects are created from the base <span class="pkg">stats</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'glm'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'glm'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'glm'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-glm_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-glm_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-glm_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed glm object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cars_glm &lt;- glm(mpg ~ ., data = mtcars)
cleaned_glm &lt;- butcher(cars_glm, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-glmnet'>Axing a glmnet.</h2><span id='topic+axe-glmnet'></span><span id='topic+axe_call.glmnet'></span>

<h3>Description</h3>

<p>glmnet objects are created from the <span class="pkg">glmnet</span> package, leveraged
to fit generalized linear models via penalized maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmnet'
axe_call(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-glmnet_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-glmnet_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-glmnet_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed glmnet object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(parsnip)

# Wrap a parsnip glmnet model
wrapped_parsnip_glmnet &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  model &lt;- logistic_reg(penalty = 10, mixture = 0.1) %&gt;%
    set_engine("glmnet") %&gt;%
    fit(as.factor(vs) ~ ., data = mtcars)
  return(model$fit)
}

out &lt;- butcher(wrapped_parsnip_glmnet(), verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-ipred'>Axing a bagged tree.</h2><span id='topic+axe-ipred'></span><span id='topic+axe-regbagg'></span><span id='topic+axe-classbagg'></span><span id='topic+axe-survbagg'></span><span id='topic+axe_call.regbagg'></span><span id='topic+axe_call.classbagg'></span><span id='topic+axe_call.survbagg'></span><span id='topic+axe_ctrl.regbagg'></span><span id='topic+axe_ctrl.classbagg'></span><span id='topic+axe_ctrl.survbagg'></span><span id='topic+axe_data.regbagg'></span><span id='topic+axe_data.classbagg'></span><span id='topic+axe_data.survbagg'></span><span id='topic+axe_env.regbagg'></span><span id='topic+axe_env.classbagg'></span><span id='topic+axe_env.survbagg'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;*_bagg&#8288;</code> objects are created from the <span class="pkg">ipred</span> package, which
is used for bagging classification, regression and survival trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regbagg'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'classbagg'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'survbagg'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'regbagg'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'classbagg'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'survbagg'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'regbagg'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'classbagg'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'survbagg'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'regbagg'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'classbagg'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'survbagg'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-ipred_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-ipred_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-ipred_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed <code style="white-space: pre;">&#8288;*_bagg&#8288;</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ipred)

fit_mod &lt;- function() {
  boop &lt;- runif(1e6)
  bagging(y ~ x, data.frame(y = rnorm(1e4), x = rnorm(1e4)))
}

mod_fit &lt;- fit_mod()
mod_res &lt;- butcher(mod_fit)

weigh(mod_fit)
weigh(mod_res)

</code></pre>

<hr>
<h2 id='axe-kknn'>Axing an kknn.</h2><span id='topic+axe-kknn'></span><span id='topic+axe_call.kknn'></span><span id='topic+axe_env.kknn'></span><span id='topic+axe_fitted.kknn'></span>

<h3>Description</h3>

<p>kknn objects are created from the <span class="pkg">kknn</span> package, which is
utilized to do weighted k-Nearest Neighbors for classification,
regression and clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kknn'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'kknn'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'kknn'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-kknn_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-kknn_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-kknn_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed kknn object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)
library(rpart)
library(kknn)

# Load data
set.seed(1234)
split &lt;- initial_split(kyphosis, prop = 9/10)
spine_train &lt;- training(split)

# Create model and fit
kknn_fit &lt;- nearest_neighbor(mode = "classification",
                             neighbors = 3,
                             weight_func = "gaussian",
                             dist_power = 2) %&gt;%
  set_engine("kknn") %&gt;%
  fit(Kyphosis ~ ., data = spine_train)

out &lt;- butcher(kknn_fit, verbose = TRUE)


# Another kknn model object
m &lt;- dim(iris)[1]
val &lt;- sample(1:m,
              size = round(m/3),
              replace = FALSE,
              prob = rep(1/m, m))
iris.learn &lt;- iris[-val,]
iris.valid &lt;- iris[val,]
kknn_fit &lt;- kknn(Species ~ .,
                 iris.learn,
                 iris.valid,
                 distance = 1,
                 kernel = "triangular")
out &lt;- butcher(kknn_fit, verbose = TRUE)


</code></pre>

<hr>
<h2 id='axe-KMeansCluster'>Axing a KMeansCluster.</h2><span id='topic+axe-KMeansCluster'></span><span id='topic+axe_call.KMeansCluster'></span><span id='topic+axe_fitted.KMeansCluster'></span>

<h3>Description</h3>

<p>Axing a KMeansCluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KMeansCluster'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'KMeansCluster'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-KMeansCluster_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-KMeansCluster_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-KMeansCluster_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed KMeansCluster object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ClusterR)
data(dietary_survey_IBS)
dat &lt;- scale(dietary_survey_IBS[, -ncol(dietary_survey_IBS)])
km &lt;- KMeans_rcpp(dat, clusters = 2, num_init = 5)
out &lt;- butcher(km, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-kproto'>Axing a kproto.</h2><span id='topic+axe-kproto'></span><span id='topic+axe_data.kproto'></span><span id='topic+axe_fitted.kproto'></span>

<h3>Description</h3>

<p>Axing a kproto.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kproto'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'kproto'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-kproto_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-kproto_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-kproto_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed kproto object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(clustMixType)

kproto_fit &lt;- kproto(
  ToothGrowth,
  k = 2,
  lambda = lambdaest(ToothGrowth),
  verbose = FALSE
)

out &lt;- butcher(kproto_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-ksvm'>Axing a ksvm object.</h2><span id='topic+axe-ksvm'></span><span id='topic+axe_call.ksvm'></span><span id='topic+axe_data.ksvm'></span><span id='topic+axe_fitted.ksvm'></span>

<h3>Description</h3>

<p>ksvm objects are created from <span class="pkg">kernlab</span> package, which provides
a means to do classification, regression, clustering, novelty
detection, quantile regression and dimensionality reduction. Since
fitted model objects from <span class="pkg">kernlab</span> are S4, the <code>butcher_ksvm</code>
class is not appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ksvm'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'ksvm'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'ksvm'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-ksvm_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-ksvm_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-ksvm_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed ksvm object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(kernlab)

# Load data
data(spam)

# Create model and fit
ksvm_class &lt;- svm_poly(mode = "classification") %&gt;%
  set_engine("kernlab") %&gt;%
  fit(type ~ ., data = spam)

out &lt;- butcher(ksvm_class, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-lm'>Axing an lm.</h2><span id='topic+axe-lm'></span><span id='topic+axe_call.lm'></span><span id='topic+axe_env.lm'></span><span id='topic+axe_fitted.lm'></span>

<h3>Description</h3>

<p>lm objects are created from the base <span class="pkg">stats</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'lm'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'lm'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-lm_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-lm_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-lm_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed lm object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)

# Load data
split &lt;- initial_split(mtcars, prop = 9/10)
car_train &lt;- training(split)

# Create model and fit
lm_fit &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  fit(mpg ~ ., data = car_train)

out &lt;- butcher(lm_fit, verbose = TRUE)

# Another lm object
wrapped_lm &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- lm(mpg ~ ., data = mtcars)
  return(fit)
}

# Remove junk
cleaned_lm &lt;- axe_env(wrapped_lm(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_lm)

# Compare environment in terms component
lobstr::obj_size(attr(wrapped_lm()$terms, ".Environment"))
lobstr::obj_size(attr(cleaned_lm$terms, ".Environment"))

</code></pre>

<hr>
<h2 id='axe-mass'>Axing a MASS discriminant analysis object.</h2><span id='topic+axe-mass'></span><span id='topic+axe-lda'></span><span id='topic+axe-qda'></span><span id='topic+axe_env.lda'></span><span id='topic+axe_env.qda'></span>

<h3>Description</h3>

<p>lda and qda objects are created from the <span class="pkg">MASS</span> package, leveraged to
carry out linear discriminant analysis and quadratic discriminant
analysis, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lda'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'qda'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-mass_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-mass_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-mass_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed lda or qda object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)

fit_da &lt;- function(fit_fn) {
  boop &lt;- runif(1e6)
  fit_fn(y ~ x, data.frame(y = rep(letters[1:4], 10000), x = rnorm(40000)))
}

lda_fit &lt;- fit_da(lda)
qda_fit &lt;- fit_da(qda)

lda_fit_b &lt;- butcher(lda_fit)
qda_fit_b &lt;- butcher(qda_fit)

weigh(lda_fit)
weigh(lda_fit_b)

weigh(qda_fit)
weigh(qda_fit_b)

</code></pre>

<hr>
<h2 id='axe-mda'>Axing a mda.</h2><span id='topic+axe-mda'></span><span id='topic+axe_call.mda'></span><span id='topic+axe_call.fda'></span><span id='topic+axe_env.mda'></span><span id='topic+axe_env.fda'></span><span id='topic+axe_fitted.mda'></span><span id='topic+axe_fitted.fda'></span>

<h3>Description</h3>

<p>mda and fda objects are created from the <span class="pkg">mda</span> package, leveraged to
carry out mixture discriminant analysis and flexible discriminat analysis,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mda'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'fda'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'mda'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'fda'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'mda'
axe_fitted(x, verbose = FALSE, ...)

## S3 method for class 'fda'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-mda_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-mda_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-mda_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed mda object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mda)

mtcars$cyl &lt;- as.factor(mtcars$cyl)

fit &lt;- mda(cyl ~ ., data = mtcars)
out &lt;- butcher(fit, verbose = TRUE)

fit2 &lt;- fda(cyl ~ ., data = mtcars)
out2 &lt;- butcher(fit2, verbose = TRUE)

# Another mda object
data(glass)
wrapped_mda &lt;- function(fit_fn) {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- fit_fn(Type ~ ., data = glass)
  return(fit)
}

lobstr::obj_size(wrapped_mda(mda))
lobstr::obj_size(butcher(wrapped_mda(mda)))

lobstr::obj_size(wrapped_mda(fda))
lobstr::obj_size(butcher(wrapped_mda(fda)))

</code></pre>

<hr>
<h2 id='axe-model_fit'>Axing an model_fit.</h2><span id='topic+axe-model_fit'></span><span id='topic+axe_call.model_fit'></span><span id='topic+axe_ctrl.model_fit'></span><span id='topic+axe_data.model_fit'></span><span id='topic+axe_env.model_fit'></span><span id='topic+axe_fitted.model_fit'></span>

<h3>Description</h3>

<p>model_fit objects are created from the <code>parsnip</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model_fit'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'model_fit'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'model_fit'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'model_fit'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'model_fit'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-model_fit_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-model_fit_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-model_fit_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed model_fit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(parsnip)
library(rpart)

# Create model and fit
lm_fit &lt;- linear_reg() %&gt;%
  set_engine("lm") %&gt;%
  fit(mpg ~ ., data = mtcars)

out &lt;- butcher(lm_fit, verbose = TRUE)

# Another parsnip model
rpart_fit &lt;- decision_tree(mode = "regression") %&gt;%
  set_engine("rpart") %&gt;%
  fit(mpg ~ ., data = mtcars, minsplit = 5, cp = 0.1)

out &lt;- butcher(rpart_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-multnet'>Axing an multnet.</h2><span id='topic+axe-multnet'></span><span id='topic+axe_call.multnet'></span>

<h3>Description</h3>

<p>multnet objects are created from carrying out multinomial regression
in the <span class="pkg">glmnet</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multnet'
axe_call(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-multnet_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-multnet_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-multnet_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed multnet object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)

# Load data
set.seed(1234)
predictrs &lt;- matrix(rnorm(100*20), ncol = 20)
colnames(predictrs) &lt;- paste0("a", seq_len(ncol(predictrs)))
response &lt;- as.factor(sample(1:4, 100, replace = TRUE))

# Create model and fit
multnet_fit &lt;- multinom_reg(penalty = 0.1) %&gt;%
  set_engine("glmnet") %&gt;%
  fit_xy(x = predictrs, y = response)

out &lt;- butcher(multnet_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-NaiveBayes'>Axing a NaiveBayes.</h2><span id='topic+axe-NaiveBayes'></span><span id='topic+axe_call.NaiveBayes'></span><span id='topic+axe_data.NaiveBayes'></span>

<h3>Description</h3>

<p>NaiveBayes objects are created from the <span class="pkg">klaR</span> package, leveraged to
fit a Naive Bayes Classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NaiveBayes'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'NaiveBayes'
axe_data(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-NaiveBayes_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-NaiveBayes_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-NaiveBayes_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed NaiveBayes object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(klaR)

fit_mod &lt;- function() {
  boop &lt;- runif(1e6)
  NaiveBayes(
    y ~ x,
    data = data.frame(y = as.factor(rep(letters[1:4], 1e4)), x = rnorm(4e4))
  )
}

mod_fit &lt;- fit_mod()
mod_res &lt;- butcher(mod_fit)

weigh(mod_fit)
weigh(mod_res)


</code></pre>

<hr>
<h2 id='axe-nnet'>Axing a nnet.</h2><span id='topic+axe-nnet'></span><span id='topic+axe_call.nnet'></span><span id='topic+axe_env.nnet'></span><span id='topic+axe_fitted.nnet'></span>

<h3>Description</h3>

<p>nnet objects are created from the <span class="pkg">nnet</span> package, leveraged to
fit multilayer perceptron models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnet'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'nnet'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'nnet'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-nnet_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-nnet_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-nnet_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed nnet object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(nnet)

# Create and fit model
nnet_fit &lt;- mlp("classification", hidden_units = 2) %&gt;%
  set_engine("nnet") %&gt;%
  fit(Species ~ ., data = iris)

out &lt;- butcher(nnet_fit, verbose = TRUE)

# Another nnet object
targets &lt;- class.ind(c(rep("setosa", 50),
                       rep("versicolor", 50),
                       rep("virginica", 50)))

fit &lt;- nnet(iris[,1:4],
            targets,
            size = 2,
            rang = 0.1,
            decay = 5e-4,
            maxit = 20)

out &lt;- butcher(fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-pls'>Axing mixOmics models</h2><span id='topic+axe-pls'></span><span id='topic+axe-mixo_pls'></span><span id='topic+axe_call.mixo_pls'></span><span id='topic+axe_call.mixo_spls'></span><span id='topic+axe_data.mixo_pls'></span><span id='topic+axe_data.mixo_spls'></span><span id='topic+axe_fitted.mixo_pls'></span><span id='topic+axe_fitted.mixo_spls'></span>

<h3>Description</h3>

<p><code>mixo_pls</code> (via <code>pls()</code>), <code>mixo_spls</code> (via <code>spls()</code>), and <code>mixo_plsda</code>
(via <code>plsda()</code>) objects are created with the mixOmics package,
leveraged to fit partial least squares models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixo_pls'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'mixo_spls'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'mixo_pls'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'mixo_spls'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'mixo_pls'
axe_fitted(x, verbose = FALSE, ...)

## S3 method for class 'mixo_spls'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-pls_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-pls_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-pls_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixOmics package is not available on CRAN, but can be installed
from the Bioconductor repository via <code>remotes::install_bioc("mixOmics")</code>.
</p>


<h3>Value</h3>

<p>Axed <code>mixo_pls</code>, <code>mixo_spls</code>, or <code>mixo_plsda</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(butcher)
do.call(library, list(package = "mixOmics"))

# pls ------------------------------------------------------------------
fit_mod &lt;- function() {
  boop &lt;- runif(1e6)
  pls(matrix(rnorm(2e4), ncol = 2), rnorm(1e4), mode = "classic")
}

mod_fit &lt;- fit_mod()
mod_res &lt;- butcher(mod_fit)

weigh(mod_fit)
weigh(mod_res)

new_data &lt;- matrix(1:2, ncol = 2)
colnames(new_data) &lt;- c("X1", "X2")
predict(mod_fit, new_data)
predict(mod_res, new_data)

</code></pre>

<hr>
<h2 id='axe-randomForest'>Axing an randomForest.</h2><span id='topic+axe-randomForest'></span><span id='topic+axe_call.randomForest'></span><span id='topic+axe_ctrl.randomForest'></span><span id='topic+axe_env.randomForest'></span>

<h3>Description</h3>

<p>randomForest objects are created from the <code>randomForest</code>
package, which is used to train random forests based on Breiman's
2001 work. The package supports ensembles of classification and
regression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'randomForest'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'randomForest'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'randomForest'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-randomForest_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-randomForest_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-randomForest_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed randomForest object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)
library(randomForest)
data(kyphosis, package = "rpart")

# Load data
set.seed(1234)
split &lt;- initial_split(kyphosis, prop = 9/10)
spine_train &lt;- training(split)

# Create model and fit
randomForest_fit &lt;- rand_forest(mode = "classification",
                                mtry = 2,
                                trees = 2,
                                min_n = 3) %&gt;%
  set_engine("randomForest") %&gt;%
  fit_xy(x = spine_train[,2:4], y = spine_train$Kyphosis)

out &lt;- butcher(randomForest_fit, verbose = TRUE)

# Another randomForest object
wrapped_rf &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  randomForest_fit &lt;- randomForest(mpg ~ ., data = mtcars)
  return(randomForest_fit)
}

# Remove junk
cleaned_rf &lt;- axe_env(wrapped_rf(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_rf)

</code></pre>

<hr>
<h2 id='axe-ranger'>Axing an ranger.</h2><span id='topic+axe-ranger'></span><span id='topic+axe_call.ranger'></span><span id='topic+axe_fitted.ranger'></span>

<h3>Description</h3>

<p>ranger objects are created from the <span class="pkg">ranger</span> package, which is
used as a means to quickly train random forests. The package supports
ensembles of classification, regression, survival and probability
prediction trees. Given the reliance of post processing functions on
the model object, like <code>importance_pvalues</code> and <code>treeInfo</code>,
on the first class listed, the <code>butcher_ranger</code> class is not
appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranger'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'ranger'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-ranger_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-ranger_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-ranger_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed ranger object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)
library(ranger)

# Load data
set.seed(1234)
split &lt;- initial_split(iris, prop = 9/10)
iris_train &lt;- training(split)

# Create model and fit
ranger_fit &lt;- rand_forest(mode = "classification",
                          mtry = 2,
                          trees = 20,
                          min_n = 3) %&gt;%
  set_engine("ranger") %&gt;%
  fit(Species ~ ., data = iris_train)

out &lt;- butcher(ranger_fit, verbose = TRUE)

# Another ranger object
wrapped_ranger &lt;- function() {
  n &lt;- 100
  p &lt;- 400
  dat &lt;- data.frame(y = factor(rbinom(n, 1, .5)), replicate(p, runif(n)))
  fit &lt;- ranger(y ~ ., dat, importance = "impurity_corrected")
  return(fit)
}

cleaned_ranger &lt;- axe_fitted(wrapped_ranger(), verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-rda'>Axing an rda.</h2><span id='topic+axe-rda'></span><span id='topic+axe-klaR'></span><span id='topic+axe_call.rda'></span><span id='topic+axe_env.rda'></span>

<h3>Description</h3>

<p>rda objects are created from the <span class="pkg">klaR</span> package, leveraged to
carry out regularized discriminant analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rda'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'rda'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-rda_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-rda_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-rda_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed rda object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(klaR)

fit_mod &lt;- function() {
  boop &lt;- runif(1e6)
  rda(
    y ~ x,
    data = data.frame(y = rep(letters[1:4], 1e4), x = rnorm(4e4)),
    gamma = 0.05,
    lambda = 0.2
  )
}

mod_fit &lt;- fit_mod()
mod_res &lt;- butcher(mod_fit)

weigh(mod_fit)
weigh(mod_res)


</code></pre>

<hr>
<h2 id='axe-recipe'>Axing a recipe object.</h2><span id='topic+axe-recipe'></span><span id='topic+axe_env.recipe'></span><span id='topic+axe_env.step'></span><span id='topic+axe_env.step_arrange'></span><span id='topic+axe_env.step_filter'></span><span id='topic+axe_env.step_mutate'></span><span id='topic+axe_env.step_slice'></span><span id='topic+axe_env.step_impute_bag'></span><span id='topic+axe_env.step_bagimpute'></span><span id='topic+axe_env.step_impute_knn'></span><span id='topic+axe_env.step_knnimpute'></span><span id='topic+axe_env.step_geodist'></span><span id='topic+axe_env.step_interact'></span><span id='topic+axe_env.step_ratio'></span><span id='topic+axe_env.quosure'></span><span id='topic+axe_fitted.recipe'></span>

<h3>Description</h3>

<p>recipe objects are created from the <span class="pkg">recipes</span> package, which is
leveraged for its set of data pre-processing tools. These recipes work
by sequentially defining each pre-processing step. The implementation
of each step, however, results its own class so we bundle all the axe
methods related to recipe objects in general here. Note that the
butchered class is only added to the recipe as a whole, and not to each
pre-processing step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recipe'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'step'
axe_env(x, ...)

## S3 method for class 'step_arrange'
axe_env(x, ...)

## S3 method for class 'step_filter'
axe_env(x, ...)

## S3 method for class 'step_mutate'
axe_env(x, ...)

## S3 method for class 'step_slice'
axe_env(x, ...)

## S3 method for class 'step_impute_bag'
axe_env(x, ...)

## S3 method for class 'step_bagimpute'
axe_env(x, ...)

## S3 method for class 'step_impute_knn'
axe_env(x, ...)

## S3 method for class 'step_knnimpute'
axe_env(x, ...)

## S3 method for class 'step_geodist'
axe_env(x, ...)

## S3 method for class 'step_interact'
axe_env(x, ...)

## S3 method for class 'step_ratio'
axe_env(x, ...)

## S3 method for class 'quosure'
axe_env(x, ...)

## S3 method for class 'recipe'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-recipe_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-recipe_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-recipe_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed recipe object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training",]
rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
              data = biomass_tr) %&gt;%
  step_center(all_predictors()) %&gt;%
  step_scale(all_predictors()) %&gt;%
  step_spatialsign(all_predictors())

out &lt;- butcher(rec, verbose = TRUE)

# Another recipe object
wrapped_recipes &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  return(
    recipe(mpg ~ cyl, data = mtcars) %&gt;%
      step_center(all_predictors()) %&gt;%
      step_scale(all_predictors()) %&gt;%
      prep()
  )
}

# Remove junk in environment
cleaned1 &lt;- axe_env(wrapped_recipes(), verbose = TRUE)
# Replace prepared training data with zero-row slice
cleaned2 &lt;- axe_fitted(wrapped_recipes(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned1)
lobstr::obj_size(cleaned2)

</code></pre>

<hr>
<h2 id='axe-rpart'>Axing a rpart.</h2><span id='topic+axe-rpart'></span><span id='topic+axe_call.rpart'></span><span id='topic+axe_ctrl.rpart'></span><span id='topic+axe_data.rpart'></span><span id='topic+axe_env.rpart'></span>

<h3>Description</h3>

<p>rpart objects are created from the <span class="pkg">rpart</span> package, which
is used for recursive partitioning for classification, regression and
survival trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpart'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'rpart'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'rpart'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'rpart'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-rpart_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-rpart_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-rpart_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed rpart object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(rsample)
library(rpart)

# Load data
set.seed(1234)
split &lt;- initial_split(mtcars, prop = 9/10)
car_train &lt;- training(split)

# Create model and fit
rpart_fit &lt;- decision_tree(mode = "regression") %&gt;%
  set_engine("rpart") %&gt;%
  fit(mpg ~ ., data = car_train, minsplit = 5, cp = 0.1)

out &lt;- butcher(rpart_fit, verbose = TRUE)

# Another rpart object
wrapped_rpart &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- rpart(Kyphosis ~ Age + Number + Start,
               data = kyphosis,
               x = TRUE, y = TRUE)
  return(fit)
}

# Remove junk
cleaned_rpart &lt;- axe_env(wrapped_rpart(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_rpart)

</code></pre>

<hr>
<h2 id='axe-sclass'>Axing a sclass object.</h2><span id='topic+axe-sclass'></span><span id='topic+axe_call.sclass'></span><span id='topic+axe_env.sclass'></span>

<h3>Description</h3>

<p>sclass objects are byproducts of classbagg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sclass'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'sclass'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-sclass_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-sclass_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-sclass_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed sclass object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(ipred)
library(rpart)
library(MASS)

# Load data
data("GlaucomaM", package = "TH.data")

classbagg_fit &lt;- bagging(Class ~ ., data = GlaucomaM, coob = TRUE)

out &lt;- butcher(classbagg_fit$mtrees[[1]], verbose = TRUE)

# Another classbagg object
wrapped_classbagg &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- bagging(Species ~ .,
                 data = iris,
                 nbagg = 10,
                 coob = TRUE)
  return(fit)
}

# Remove junk
cleaned_classbagg &lt;- butcher(wrapped_classbagg(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_classbagg)

</code></pre>

<hr>
<h2 id='axe-spark'>Axing a spark object.</h2><span id='topic+axe-spark'></span><span id='topic+axe_call.ml_model'></span><span id='topic+axe_ctrl.ml_model'></span><span id='topic+axe_data.ml_model'></span><span id='topic+axe_fitted.ml_model'></span>

<h3>Description</h3>

<p>spark objects are created from the <span class="pkg">sparklyr</span> package,
a <span class="rlang"><b>R</b></span> interface for Apache Spark. The axe methods available
for spark objects are designed such that interoperability
is maintained. In other words, for a multilingual machine
learning team, butchered spark objects instantiated from
<span class="pkg">sparklyr</span> can still be serialized to disk, work in
Python, be deployed on Scala, etc. It is also worth noting
here that spark objects created from <span class="pkg">sparklyr</span> have a
lot of metadata attached to it, including but not limited
to the formula, dataset, model, index labels, etc. The
axe functions provided are for parsing down the model
object both prior saving to disk, or loading from disk.
Traditional <span class="rlang"><b>R</b></span> save functions are not available for these
objects, so functionality is provided in <code>sparklyr::ml_save</code>.
This function gives the user the option to keep either the
<code>pipeline_model</code> or the <code>pipeline</code>, so both of these
objects are retained from butchering, yet removal of one or the
other might be conducive to freeing up memory on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ml_model'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'ml_model'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'ml_model'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'ml_model'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-spark_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-spark_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-spark_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed spark object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sparklyr)

sc &lt;- spark_connect(master = "local")

iris_tbls &lt;- sdf_copy_to(sc, iris, overwrite = TRUE) %&gt;%
  sdf_random_split(train = 2/3, validation = 2/3, seed = 2018)

train &lt;- iris_tbls$train
spark_fit &lt;- ml_logistic_regression(train, Species ~ .)

out &lt;- butcher(spark_fit, verbose = TRUE)

spark_disconnect(sc)

</code></pre>

<hr>
<h2 id='axe-survreg'>Axing an survreg.</h2><span id='topic+axe-survreg'></span><span id='topic+axe_call.survreg'></span><span id='topic+axe_data.survreg'></span><span id='topic+axe_env.survreg'></span>

<h3>Description</h3>

<p>survreg objects are created from the <span class="pkg">survival</span> package. They
are returned from the <code>survreg</code> function, representing fitted
parametric survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'survreg'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'survreg'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-survreg_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-survreg_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-survreg_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed survreg object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(survival)

# Create model and fit
survreg_fit &lt;- surv_reg(mode = "regression", dist = "weibull") %&gt;%
  set_engine("survival") %&gt;%
  fit(Surv(futime, fustat) ~ 1, data = ovarian)

out &lt;- butcher(survreg_fit, verbose = TRUE)

# Another survreg object
wrapped_survreg &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- survreg(Surv(time, status) ~ ph.ecog + age + strata(sex),
                 data = lung)
  return(fit)
}

# Remove junk
cleaned_survreg &lt;- butcher(wrapped_survreg(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_survreg)

</code></pre>

<hr>
<h2 id='axe-survreg.penal'>Axing an survreg.penal</h2><span id='topic+axe-survreg.penal'></span><span id='topic+axe_call.survreg.penal'></span><span id='topic+axe_data.survreg.penal'></span><span id='topic+axe_env.survreg.penal'></span>

<h3>Description</h3>

<p>survreg.penal objects are created from the <span class="pkg">survival</span> package. They
are returned from the <code>survreg</code> function, representing fitted
parametric survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg.penal'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'survreg.penal'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'survreg.penal'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-survreg.penal_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-survreg.penal_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-survreg.penal_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed survreg object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(parsnip)
library(survival)

# Create model and fit
survreg_fit &lt;- surv_reg(mode = "regression", dist = "weibull") %&gt;%
  set_engine("survival") %&gt;%
  fit(Surv(time, status) ~ rx, data = rats)

out &lt;- butcher(survreg_fit, verbose = TRUE)

# Another survreg.penal object
wrapped_survreg.penal &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- survreg(Surv(time, status) ~ rx,
                 data = rats, subset = (sex == "f"))
  return(fit)
}

# Remove junk
cleaned_sp &lt;- axe_env(wrapped_survreg.penal(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_sp)

</code></pre>

<hr>
<h2 id='axe-terms'>Axing for terms inputs.</h2><span id='topic+axe-terms'></span><span id='topic+axe_env.terms'></span>

<h3>Description</h3>

<p>Generics related to axing objects of the term class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'terms'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-terms_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-terms_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-terms_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed terms object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using lm
wrapped_lm &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- lm(mpg ~ ., data = mtcars)
  return(fit)
}

# Remove junk
cleaned_lm &lt;- axe_env(wrapped_lm(), verbose = TRUE)

# Check size
lobstr::obj_size(cleaned_lm)

# Compare environment in terms component
lobstr::obj_size(attr(wrapped_lm()$terms, ".Environment"))
lobstr::obj_size(attr(cleaned_lm$terms, ".Environment"))

# Using rpart
library(rpart)

wrapped_rpart &lt;- function() {
  some_junk_in_environment &lt;- runif(1e6)
  fit &lt;- rpart(Kyphosis ~ Age + Number + Start,
               data = kyphosis,
               x = TRUE,
               y = TRUE)
  return(fit)
}

lobstr::obj_size(wrapped_rpart())
lobstr::obj_size(axe_env(wrapped_rpart()))

</code></pre>

<hr>
<h2 id='axe-train'>Axing a train object.</h2><span id='topic+axe-train'></span><span id='topic+axe_call.train'></span><span id='topic+axe_ctrl.train'></span><span id='topic+axe_data.train'></span><span id='topic+axe_env.train'></span><span id='topic+axe_fitted.train'></span>

<h3>Description</h3>

<p>train objects are created from the <span class="pkg">caret</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'train'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'train'
axe_ctrl(x, verbose = FALSE, ...)

## S3 method for class 'train'
axe_data(x, verbose = FALSE, ...)

## S3 method for class 'train'
axe_env(x, verbose = FALSE, ...)

## S3 method for class 'train'
axe_fitted(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-train_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-train_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-train_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed train object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load libraries
library(caret)

data(iris)
train_data &lt;- iris[, 1:4]
train_classes &lt;- iris[, 5]

train_fit &lt;- train(train_data, train_classes,
                   method = "knn",
                   preProcess = c("center", "scale"),
                   tuneLength = 10,
                   trControl = trainControl(method = "cv"))

out &lt;- butcher(train_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-train.recipe'>Axing a train.recipe object.</h2><span id='topic+axe-train.recipe'></span><span id='topic+axe_call.train.recipe'></span><span id='topic+axe_ctrl.train.recipe'></span><span id='topic+axe_data.train.recipe'></span><span id='topic+axe_env.train.recipe'></span><span id='topic+axe_fitted.train.recipe'></span>

<h3>Description</h3>

<p>train.recipe objects are slightly different from train objects
created from the <code>caret</code> package in that it also includes
instructions from a <code>recipe</code> for data pre-processing. Axing
functions specific to train.recipe are thus included as additional
steps are required to remove parts of train.recipe objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'train.recipe'
axe_call(x, ...)

## S3 method for class 'train.recipe'
axe_ctrl(x, ...)

## S3 method for class 'train.recipe'
axe_data(x, ...)

## S3 method for class 'train.recipe'
axe_env(x, ...)

## S3 method for class 'train.recipe'
axe_fitted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-train.recipe_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-train.recipe_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed train.recipe object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(caret)
data(biomass, package = "modeldata")

data(biomass)
recipe &lt;- biomass %&gt;%
  recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur) %&gt;%
  step_center(all_predictors()) %&gt;%
  step_scale(all_predictors()) %&gt;%
  step_spatialsign(all_predictors())

train.recipe_fit &lt;- train(recipe, biomass,
                          method = "svmRadial",
                          metric = "RMSE")

out &lt;- butcher(train.recipe_fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-xgb.Booster'>Axing a xgb.Booster.</h2><span id='topic+axe-xgb.Booster'></span><span id='topic+axe_call.xgb.Booster'></span><span id='topic+axe_env.xgb.Booster'></span>

<h3>Description</h3>

<p>xgb.Booster objects are created from the <span class="pkg">xgboost</span> package,
which provides efficient and scalable implementations of gradient
boosted decision trees. Given the reliance of post processing
functions on the model object, like <code>xgb.Booster.complete</code>,
on the first class listed, the <code>butcher_xgb.Booster</code> class is
not appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xgb.Booster'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'xgb.Booster'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-xgb.Booster_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-xgb.Booster_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-xgb.Booster_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed xgb.Booster object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xgboost)
library(parsnip)

data(agaricus.train)
bst &lt;- xgboost(data = agaricus.train$data,
               label = agaricus.train$label,
               eta = 1,
               nthread = 2,
               nrounds = 2,
               eval_metric = "logloss",
               objective = "binary:logistic",
               verbose = 0)

out &lt;- butcher(bst, verbose = TRUE)

# Another xgboost model
fit &lt;- boost_tree(mode = "classification", trees = 20) %&gt;%
  set_engine("xgboost", eval_metric = "mlogloss") %&gt;%
  fit(Species ~ ., data = iris)

out &lt;- butcher(fit, verbose = TRUE)

</code></pre>

<hr>
<h2 id='axe-xrf'>Axing a xrf.</h2><span id='topic+axe-xrf'></span><span id='topic+axe_call.xrf'></span><span id='topic+axe_env.xrf'></span>

<h3>Description</h3>

<p>Axing a xrf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xrf'
axe_call(x, verbose = FALSE, ...)

## S3 method for class 'xrf'
axe_env(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axe-xrf_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="axe-xrf_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="axe-xrf_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed xrf object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xrf)

xrf_big &lt;- function() {
  boop &lt;- runif(1e6)
  xrf(
    mpg ~ .,
    mtcars,
    xgb_control = list(nrounds = 2, max_depth = 2),
    family = 'gaussian'
  )
}

heavy_m &lt;- xrf_big()

m &lt;- butcher(heavy_m, verbose = TRUE)

weigh(heavy_m)
weigh(m)

</code></pre>

<hr>
<h2 id='butcher'>Butcher an object.</h2><span id='topic+butcher'></span>

<h3>Description</h3>

<p>Reduce the size of a model object so that it takes up less memory on
disk. Currently, the model object is stripped down to the point that
only the minimal components necessary for the <code>predict</code> function
to work remain. Future adjustments to this function will be needed to
avoid removal of model fit components to ensure it works with other
downstream functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butcher(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="butcher_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="butcher_+3A_verbose">verbose</code></td>
<td>
<p>Print information each time an axe method is executed.
Notes how much memory is released and what functions are
disabled. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="butcher_+3A_...">...</code></td>
<td>
<p>Any additional arguments related to axing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Axed model object with new butcher subclass assignment.
</p>

<hr>
<h2 id='butcher_example'>Get path to model object example.</h2><span id='topic+butcher_example'></span>

<h3>Description</h3>

<p>butcher comes bundled with some example files in its <code>inst/extdata</code>
directory. This function was copied from readxl and placed here to
make the instantiated model objects easy to access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butcher_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="butcher_example_+3A_path">path</code></td>
<td>
<p>Name of file. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>

<hr>
<h2 id='locate'>Locate part of an object.</h2><span id='topic+locate'></span>

<h3>Description</h3>

<p>Locate where a specific component of a object might exist within
the model object itself. This function is restricted in that only
items that can be axed can be found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate(x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="locate_+3A_name">name</code></td>
<td>
<p>A name associated with model component of interest.
This defaults to NULL. Possible components include: <code>env</code>,
<code>call</code>, <code>data</code>, <code>ctrl</code>, and <code>fitted</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Location of specific component in a model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm_fit &lt;- lm(mpg ~ ., data = mtcars)
locate(lm_fit, name = "env")
locate(lm_fit, name = "call")
</code></pre>

<hr>
<h2 id='new_model_butcher'>New axe functions for a modeling object.</h2><span id='topic+new_model_butcher'></span>

<h3>Description</h3>

<p><code>new_model_butcher()</code> will instantiate the following to help
us develop new axe functions around removing parts of a new
modeling object:
</p>

<ul>
<li><p> Add modeling package to <code>Suggests</code>
</p>
</li>
<li><p> Generate and populate an axe file under <code>R/</code>
</p>
</li>
<li><p> Generate and populate an test file under <code>testthat/</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>new_model_butcher(model_class, package_name, open = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_model_butcher_+3A_model_class">model_class</code></td>
<td>
<p>A string that captures the class name of
the new model object.</p>
</td></tr>
<tr><td><code id="new_model_butcher_+3A_package_name">package_name</code></td>
<td>
<p>A string that captures the package name
from which the new model is made.</p>
</td></tr>
<tr><td><code id="new_model_butcher_+3A_open">open</code></td>
<td>
<p>Check if user is in interactive mode, and if so,
opens the new files for editing.</p>
</td></tr>
</table>

<hr>
<h2 id='ui'>Console Messages</h2><span id='topic+ui'></span><span id='topic+memory_released'></span><span id='topic+assess_object'></span>

<h3>Description</h3>

<p>These console messages are created such that the user is
aware of the effects of removing specific components from
the model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memory_released(og, butchered)

assess_object(og, butchered)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ui_+3A_og">og</code></td>
<td>
<p>Original model object.</p>
</td></tr>
<tr><td><code id="ui_+3A_butchered">butchered</code></td>
<td>
<p>Butchered model object.</p>
</td></tr>
</table>

<hr>
<h2 id='weigh'>Weigh the object.</h2><span id='topic+weigh'></span>

<h3>Description</h3>

<p>Evaluate the size of each element contained in a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weigh(x, threshold = 0, units = "MB", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weigh_+3A_x">x</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="weigh_+3A_threshold">threshold</code></td>
<td>
<p>The minimum threshold desired for model component
size to display.</p>
</td></tr>
<tr><td><code id="weigh_+3A_units">units</code></td>
<td>
<p>The units in which to display the size of each component
within the model object of interest. Defaults to <code>MB</code>. Other
options include <code>KB</code> and <code>GB</code>.</p>
</td></tr>
<tr><td><code id="weigh_+3A_...">...</code></td>
<td>
<p>Any additional arguments for weighing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble with weights of object components in decreasing magnitude.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_x &lt;- matrix(runif(1e+6), ncol = 2)
simulate_y &lt;- runif(dim(simulate_x)[1])
lm_out &lt;- lm(simulate_y ~ simulate_x)
weigh(lm_out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
