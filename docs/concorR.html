<!DOCTYPE html><html><head><title>Help for package concorR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {concorR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#concor'><p>Find CONCOR partition for a graph</p></a></li>
<li><a href='#concor_igraph_apply'><p>Find CONCOR partition and add to a list of <span class="pkg">igraph</span> objects</p></a></li>
<li><a href='#concor_make_igraph'><p>Find CONCOR partition and create a list of <span class="pkg">igraph</span> objects</p></a></li>
<li><a href='#concor1'><p>Find +1/-1 convergence points of an input matrix</p></a></li>
<li><a href='#concorR'><p>The concorR Package</p></a></li>
<li><a href='#krack_advice'>
<p>Krackhardt High-Tech Managers data</p></a></li>
<li><a href='#make_blk'><p>Make <code>blockmodel</code> objects using CONCOR partition</p></a></li>
<li><a href='#make_reduced'><p>Run CONCOR and output reduced adjacency matrices</p></a></li>
<li><a href='#make_reduced_igraph'><p>Build an <code>igraph</code> object for a reduced network</p></a></li>
<li><a href='#plot_blk'><p>Plot a blockmodel</p></a></li>
<li><a href='#plot_reduced'><p>Plot a reduced network</p></a></li>
<li><a href='#plot_socio'><p>Plot sociogram colored by CONCOR partition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>CONCOR and Supplemental Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the CONCOR (CONvergence of iterated CORrelations) 
    algorithm and a series of supplemental functions for easy running, 
    plotting, and blockmodeling. The CONCOR algorithm is used on social network
    data to identify network positions based off a definition of structural 
    equivalence; see Breiger, Boorman, and Arabie (1975) 
    &lt;<a href="https://doi.org/10.1016%2F0022-2496%2875%2990028-0">doi:10.1016/0022-2496(75)90028-0</a>&gt; and Wasserman and Faust's book Social 
    Network Analysis: Methods and Applications (1994). This version allows 
    multiple relationships for the same set of nodes and uses both incoming and
    outgoing ties to find positions.</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, sna, stats, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ATraxLab/concorR">https://github.com/ATraxLab/concorR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ATraxLab/concorR/issues">https://github.com/ATraxLab/concorR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-25 20:14:37 UTC; w039alt</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyme Suda [aut],
  Adrienne Traxler <a href="https://orcid.org/0000-0003-2725-0686"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre],
  Carter Butts [ctb] (Author of sna::plot.blockmodel(), adapted for
    plot_blk())</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrienne Traxler &lt;adrienne.traxler@wright.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-25 20:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='concor'>Find CONCOR partition for a graph</h2><span id='topic+concor'></span>

<h3>Description</h3>

<p>Use the CONCOR (CONvergence of iterated CORrelations) algorithm to identify roles within
social network data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concor(m_list, nsplit = 1, self_ties = FALSE, cutoff = .9999999, max_iter = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concor_+3A_m_list">m_list</code></td>
<td>
<p>A list of adjacency matrices. Matrices must be square, of the same
dimensions, and have row/column names (node names). Each matrix represents a different
relationship of the same nodes. If there is only one relationship of interest,
<code>m_list</code> is a list of that single matrix.</p>
</td></tr>
<tr><td><code id="concor_+3A_nsplit">nsplit</code></td>
<td>
<p>The number of times the input matrices will be partitioned. Each split
divides a partition in two, resulting in 2^<code>nsplit</code> roles identified.</p>
</td></tr>
<tr><td><code id="concor_+3A_self_ties">self_ties</code></td>
<td>
<p>A Boolean representing whether self-ties can be present in the data.
<code>TRUE</code> allows for self-ties; <code>FALSE</code> does not.</p>
</td></tr>
<tr><td><code id="concor_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff point of the iterated correlations. Both this and
<code>max_iter</code> can be lowered slightly to improve speed.</p>
</td></tr>
<tr><td><code id="concor_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of times the correlation will be run for a split.
Both this and <code>cutoff</code> can be lowered slightly to improve speed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version works for multiple relationships, assuming they all are for the same data
(same size of input matrices), and can be used with isolates present. It requires further
testing on weighted networks (but appears to successfully split such networks). It will
attempt to split the network <code>nsplit</code> times, causing there to be 2^<code>nsplit</code>
partitions, plus one for isolated nodes (if they exist), unless a structurally equivalent
node group or singular node group is present. If the algorithm attempts to split such a
node group the function will ignore that group and continue to split all other blocks
until specified. If a higher number of splits, <code>nsplit</code>, are requested than are
possible to apply to the specified data (due to structurally equivalent node groups being
present or all blocks being singular nodes) the code will warn the user that split
<code>nsplit</code> was the same as split <code>i</code>, the final possible split, and stop.
</p>


<h3>Value</h3>

<p>A data frame with two columns: <code>block</code> is the block or role identified by CONCOR,
and <code>vertex</code> is the node names.
</p>


<h3>References</h3>

<p>R. L. Breiger, S. A. Boorman, P. Arabie, An algorithm for clustering relational data with
applications to social network analysis and comparison with multidimensional scaling.
<em>J. of Mathematical Psychology</em>. <strong>12</strong>, 328 (1975).
doi: <a href="https://doi.org/10.1016/0022-2496(75)90028-0">10.1016/0022-2496(75)90028-0</a>
</p>
<p>S. Wasserman and K. Faust, <em>Social Network Analysis: Methods and Applications</em>
(Cambridge University Press, 1994).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(a) &lt;- c("a", "b", "c", "d")
colnames(a) &lt;- c("a", "b", "c", "d")

concor(list(a))
</code></pre>

<hr>
<h2 id='concor_igraph_apply'>Find CONCOR partition and add to a list of <span class="pkg">igraph</span> objects</h2><span id='topic+concor_igraph_apply'></span>

<h3>Description</h3>

<p>Takes a list of <span class="pkg">igraph</span> objects, runs <code>concor</code> until the desired number of
splits, and adds the final split to each object as a vertex attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concor_igraph_apply(igraph_list, nsplit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concor_igraph_apply_+3A_igraph_list">igraph_list</code></td>
<td>
<p>The list of <span class="pkg">igraph</span> objects for use in <code>concor</code>.</p>
</td></tr>
<tr><td><code id="concor_igraph_apply_+3A_nsplit">nsplit</code></td>
<td>
<p>Number of times to split each network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for a common task: Running <code><a href="#topic+concor">concor</a></code> on one or more
<span class="pkg">igraph</span> objects and adding the resulting partition to each object as a vertex
attribute. If multiple <span class="pkg">igraph</span> objects are included in the input list, they should
be multiple relations for the same nodes.
</p>
<p>If all of the input graphs are weighted, edge weights will be used by <code>concor</code>.
</p>


<h3>Value</h3>

<p>Returns a list of <span class="pkg">igraph</span> objects, each with a vertex attribute <code>csplitn</code>
(where <code>n</code> is <code>nsplit</code>) that contains the block assignment obtained from
<code>concor</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concor">concor</a></code>, <code><a href="#topic+concor_make_igraph">concor_make_igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(a) &lt;- c("a", "b", "c", "d")
colnames(a) &lt;- c("a", "b", "c", "d")
a.igraph &lt;- igraph::graph_from_adjacency_matrix(a)
concor_igraph_apply(list(a.igraph))

b &lt;- matrix(c(0, 0, 0, 4, 1, 0, 3, 0, 2, 1, 0, 1, 1, 0, 2, 0), ncol = 4)
rownames(b) &lt;- c("a", "b", "c", "d")
colnames(b) &lt;- c("a", "b", "c", "d")
b.igraph &lt;- igraph::graph_from_adjacency_matrix(b, weighted = "weight")
concor_igraph_apply(list(b.igraph))

concor_igraph_apply(list(a.igraph, b.igraph))
</code></pre>

<hr>
<h2 id='concor_make_igraph'>Find CONCOR partition and create a list of <span class="pkg">igraph</span> objects</h2><span id='topic+concor_make_igraph'></span>

<h3>Description</h3>

<p>Run <code>concor</code> on a list of adjacency matrices and create a list of <span class="pkg">igraph</span>
objects with a specific CONCOR split added as a vertex attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concor_make_igraph(adj_list, nsplit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concor_make_igraph_+3A_adj_list">adj_list</code></td>
<td>
<p>A list of adjacency matrices, each representing a different relation
for the same nodes.</p>
</td></tr>
<tr><td><code id="concor_make_igraph_+3A_nsplit">nsplit</code></td>
<td>
<p>The total number of splits CONCOR will (attempt to) perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for a common task: Running <code><a href="#topic+concor">concor</a></code> on one or more
adjacency matrices, then saving the networks as <span class="pkg">igraph</span> objects with the CONCOR
partition as a vertex attribute. If multiple adjacency matrices are included in the input
list, they should be multiple relations for the same nodes.
</p>
<p>If any of the input matrices have entries other than 0 and 1, all are treated as weighted
(a <code>weight</code> edge attribute is added to each output graph).
</p>


<h3>Value</h3>

<p>Returns a list of <span class="pkg">igraph</span> objects with a vertex attribute <code>csplitn</code>, where
<code>n</code> is <code>nsplit</code> that contains the block assignment obtained from <code>concor</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concor">concor</a></code>, <code><a href="#topic+concor_igraph_apply">concor_igraph_apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(a) &lt;- c("a", "b", "c", "d")
colnames(a) &lt;- c("a", "b", "c", "d")
concor_make_igraph(list(a))

b &lt;- matrix(c(0, 0, 0, 4, 1, 0, 3, 0, 2, 1, 0, 1, 1, 0, 2, 0), ncol = 4)
rownames(b) &lt;- c("a", "b", "c", "d")
colnames(b) &lt;- c("a", "b", "c", "d")
concor_make_igraph(list(b))

concor_make_igraph(list(a, b))
</code></pre>

<hr>
<h2 id='concor1'>Find +1/-1 convergence points of an input matrix</h2><span id='topic+concor1'></span>

<h3>Description</h3>

<p>A subfunction of <code><a href="#topic+concor">concor</a></code>.
</p>
<p>Runs the Pearson correlation on the matrix stack repeatedly until a square matrix
consisting of only +1 and -1 is formed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concor1(m_stack, cutoff = .9999999, max_iter = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concor1_+3A_m_stack">m_stack</code></td>
<td>
<p>The stack of input matrices, which must include all transposes and
relations.</p>
</td></tr>
<tr><td><code id="concor1_+3A_cutoff">cutoff</code></td>
<td>
<p>The absolute value of the convergence threshold for each matrix element.</p>
</td></tr>
<tr><td><code id="concor1_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of times to run the correlation while seeking
convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For network data with <code>R</code> relations, the input matrix &quot;stack&quot; is a
<code>(2 x N x R) x N</code> matrix, consisting of each relation's adjacency matrix, then the
transpose of that matrix, appended to each other vertically. The correlation is run until
either all matrix entries have absolute values greater than <code>cutoff</code> or the maximum
number of iterations <code>max_iter</code> is reached. On its own, this function does not
execute the whole CONCOR method, but is listed separately from <code>concor</code> to
demonstrate the core step.
</p>


<h3>Value</h3>

<p>A square matrix, with number of rows/columns equal to the number of columns of
<code>m_stack</code>, where the values are either +1 or -1. The input matrix can later be split
into two &quot;positions&quot; based off the locations of the positive/negative values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concor">concor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
b &lt;- rbind(a, t(a))

concor1(b)
</code></pre>

<hr>
<h2 id='concorR'>The concorR Package</h2><span id='topic+concorR'></span>

<h3>Description</h3>

<p><span class="pkg">concorR</span> implements the CONCOR (CONvergence of iterated CORrelations) algorithm as
introduced by Breiger, Boorman, and Arabie (1975) and detailed by Wasserman and Faust
(1994). This package includes the <code><a href="#topic+concor">concor</a></code> algorithm itself, and some useful
functions for plotting and interpreting the outputs. The plotting methods included are:
plotting the overall network with the <code><a href="#topic+concor">concor</a></code> partitions as colors (using
the <span class="pkg">igraph</span> package), plotting a blockmodel using the <code><a href="#topic+concor">concor</a></code>
partitions (using the <span class="pkg">sna</span> package), and plotting reduced network graphs showing the
connections between <code><a href="#topic+concor">concor</a></code> partitions (again using <span class="pkg">igraph</span>).
</p>


<h3>Author(s)</h3>

<p>Tyme Suda <a href="mailto:suda.4@wright.edu">suda.4@wright.edu</a>
</p>
<p>Adrienne Traxler <a href="mailto:adrienne.traxler@wright.edu">adrienne.traxler@wright.edu</a>
</p>
<p>This work was supported by National Science Foundation awards
<a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1712341">DUE-1712341</a> and
<a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1711017">DUE-1711017</a>.
</p>


<h3>References</h3>

<p>R. L. Breiger, S. A. Boorman, P. Arabie, An algorithm for clustering relational data with
applications to social network analysis and comparison with multidimensional scaling.
<em>J. of Mathematical Psychology</em>. <strong>12</strong>, 328 (1975).
doi: <a href="https://doi.org/10.1016/0022-2496(75)90028-0">10.1016/0022-2496(75)90028-0</a>
</p>
<p>S. Wasserman and K. Faust, <em>Social Network Analysis: Methods and Applications</em>
(Cambridge University Press, 1994).
</p>

<hr>
<h2 id='krack_advice'>
Krackhardt High-Tech Managers data
</h2><span id='topic+krack_advice'></span><span id='topic+krack_friend'></span><span id='topic+krack_report'></span>

<h3>Description</h3>

<p>A network of connections between 21 managers at a manufacturing company taken by David
Krackhardt in 1987. The three networks available are advice, friendship, and report
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krack_advice

krack_friend

krack_report
</code></pre>


<h3>Format</h3>

<p>A directed and unweighted <span class="pkg">igraph</span> object.
</p>
<p>Vertex attributes:
</p>

<ul>
<li> <p><code>Name</code>: Vertex names (character; &quot;v1&quot;, &quot;v2&quot;, ..., &quot;v21&quot;).
</p>
</li>
<li> <p><code>x,y</code>: A set of plotting coordinates, used if no other layout is supplied
(numeric).
</p>
</li>
<li> <p><code>Age</code>: The age of each manager (integer).
</p>
</li>
<li> <p><code>Tenure</code>: The tenure of each manager (numeric).
</p>
</li>
<li> <p><code>Level</code>: The level in the corporate hierarchy (integer; 1 = CEO, 2 = Vice
President, 3 = manager).
</p>
</li>
<li> <p><code>Department</code>: What department each manager is in (integer; 1, 2, 3, 4, or 0
for the CEO).
</p>
</li></ul>



<h3>Details</h3>

<p>Edges in the <code>krack_advice</code> and <code>krack_friend</code> networks come survey questions
answered by all 21 managers. The <code>krack_report</code> network uses the formal organization
chart to define connections between managers.
</p>


<h3>Source</h3>

<p>The data was found at
<a href="http://vlado.fmf.uni-lj.si/pub/networks/data/WaFa/default.htm">http://vlado.fmf.uni-lj.si/pub/networks/data/WaFa/default.htm</a>
and reformatted for use in R.
</p>


<h3>References</h3>

<p>D. Krackhardt, Cognitive social structures. <em>Social Networks</em>. <strong>9</strong>, 104
(1987). doi: <a href="https://doi.org/10.1016/0378-8733(87)90009-8">10.1016/0378-8733(87)90009-8</a>
</p>
<p>S. Wasserman and K. Faust, <em>Social Network Analysis: Methods and Applications</em>
(Cambridge University Press, 1994).
</p>

<hr>
<h2 id='make_blk'>Make <code>blockmodel</code> objects using CONCOR partition</h2><span id='topic+make_blk'></span>

<h3>Description</h3>

<p>Use the CONCOR algorithm to find network positions, continuing through a specified number
of splits, and output <code>blockmodel</code> object(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_blk(adj_list, nsplit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_blk_+3A_adj_list">adj_list</code></td>
<td>
<p>A list of adjacency matrices, each representing a different relation
for the same nodes.</p>
</td></tr>
<tr><td><code id="make_blk_+3A_nsplit">nsplit</code></td>
<td>
<p>The total number of splits CONCOR will (attempt to) perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs <code><a href="#topic+concor">concor</a></code> to a specified number of splits (<code>nsplit</code>) and creates a
<code>blockmodel</code> type object from each input matrix in <code>adj_list</code> using the
membership vector generated by <code><a href="#topic+concor">concor</a></code>. This object holds summary
information of interest, such as the reduced density matrix, as well as the permuted
adjacency matrix that shows the blocked structure.
</p>
<p>See the help file for <code><a href="sna.html#topic+blockmodel">blockmodel</a></code> in the <span class="pkg">sna</span> package for more
details.
</p>


<h3>Value</h3>

<p>A list of <code>blockmodel</code> type objects, one for each input adjacency matrix. Each
blockmodel in the list corresponds to one relation.
</p>


<h3>See Also</h3>

<p><code><a href="sna.html#topic+blockmodel">blockmodel</a></code>,
<code><a href="#topic+concor">concor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(g1) &lt;- c("a", "b", "c", "d")
colnames(g1) &lt;- c("a", "b", "c", "d")

g2 &lt;- matrix(c(0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0), ncol = 4)
rownames(g2) &lt;- c("a", "b", "c", "d")
colnames(g2) &lt;- c("a", "b", "c", "d")

gl &lt;- list(g1, g2)
make_blk(gl)
</code></pre>

<hr>
<h2 id='make_reduced'>Run CONCOR and output reduced adjacency matrices</h2><span id='topic+make_reduced'></span>

<h3>Description</h3>

<p>Takes a list of adjacency matrices, partitions using <code><a href="#topic+concor">concor</a></code>, and returns a
list of reduced adjacency matrices and their corresponding cutoff densities. Each reduced
matrix corresponds to one input relation. The <span class="pkg">sna</span> package must be installed, but
does not need to be attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_reduced(adj_list, nsplit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_reduced_+3A_adj_list">adj_list</code></td>
<td>
<p>A list of adjacency matrices, each representing a different relation
for the same nodes.</p>
</td></tr>
<tr><td><code id="make_reduced_+3A_nsplit">nsplit</code></td>
<td>
<p>The total number of splits CONCOR will (attempt to) perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A reduced network represents each identified position in the network as a single node.
Links (or self-links) exist if the density of ties in that block is greater than a
threshold density. In this implementation, the density of the whole network is used as
the threshold for each block.
</p>
<p>In the list of input matrices <code>adj_list</code>, each should correspond to a different
relation for the same nodes. Each adjacency matrix is partitioned with the CONCOR
algorithm, continuing for <code>nsplit</code> divisions. After the threshold density is
applied, each entry in the reduced matrix has values of 0 or 1.
</p>


<h3>Value</h3>

<table>
<tr><td><code>reduced_mat</code></td>
<td>
<p>A list of reduced matrices, one for each input matrix.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>A vector of the cut-off densities used (equal to the edge density of each entry in <code>adj_list</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Wasserman and K. Faust, <em>Social Network Analysis: Methods and Applications</em> (Cambridge University Press, 1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concor">concor</a></code>, <code><a href="#topic+make_blk">make_blk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(g1) &lt;- c("a", "b", "c", "d")
colnames(g1) &lt;- c("a", "b", "c", "d")

g2 &lt;- matrix(c(0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0), ncol = 4)
rownames(g2) &lt;- c("a", "b", "c", "d")
colnames(g2) &lt;- c("a", "b", "c", "d")

make_reduced(list(g1, g2), nsplit = 1)
</code></pre>

<hr>
<h2 id='make_reduced_igraph'>Build an <code>igraph</code> object for a reduced network</h2><span id='topic+make_reduced_igraph'></span>

<h3>Description</h3>

<p>Turns a reduced adjacency matrix (usually output from <code><a href="#topic+make_reduced">make_reduced</a></code>) into an
<code>igraph</code> object. This function requires <span class="pkg">igraph</span> to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_reduced_igraph(reduced_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_reduced_igraph_+3A_reduced_mat">reduced_mat</code></td>
<td>
<p>A reduced network adjacency matrix (typically outputted from
<code><a href="#topic+make_reduced">make_reduced</a></code> in the <code>reduced_mat</code> list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A directed and unweighted <code>igraph</code> object for the reduced matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_reduced">make_reduced</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(a) &lt;- c("a", "b", "c", "d")
colnames(a) &lt;- c("a", "b", "c", "d")

r_mat &lt;- make_reduced(list(a), nsplit = 1)
make_reduced_igraph(r_mat$reduced_mat[[1]])
</code></pre>

<hr>
<h2 id='plot_blk'>Plot a blockmodel</h2><span id='topic+plot_blk'></span>

<h3>Description</h3>

<p>Displays a plot of a blockmodel. Based on <code><a href="sna.html#topic+plot.blockmodel">plot.blockmodel</a></code> (<span class="pkg">sna</span>
must be installed), but reformats the plot to be square and removes the mandatory title.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_blk(x, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_blk_+3A_x">x</code></td>
<td>
<p>An object of class <code>blockmodel</code></p>
</td></tr>
<tr><td><code id="plot_blk_+3A_labels">labels</code></td>
<td>
<p>If <code>TRUE</code>, vertex ids are displayed as row/column/diagonal labels.
If <code>FALSE</code>, no node labels are shown.</p>
</td></tr>
<tr><td><code id="plot_blk_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modification of the <code><a href="sna.html#topic+plot.blockmodel">plot.blockmodel</a></code> function. The original
displays vertex ids as row, column, and diagonal labels, which can be unreadable for
larger networks. <code><a href="sna.html#topic+plot.blockmodel">plot.blockmodel</a></code> also adds a title of the form
&quot;Relation - 1&quot;, which this version omits.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts (buttsc@uci.edu)
</p>
<p>Modified by Tyme Suda
</p>


<h3>References</h3>

<p>Carter T. Butts (2019). sna: Tools for Social Network Analysis. R package version 2.5.
<a href="https://CRAN.R-project.org/package=sna">https://CRAN.R-project.org/package=sna</a>
</p>


<h3>See Also</h3>

<p><code><a href="sna.html#topic+plot.blockmodel">plot.blockmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(g1) &lt;- c("a", "b", "c", "d")
colnames(g1) &lt;- c("a", "b", "c", "d")

gl &lt;- list(g1)
bm &lt;- make_blk(gl, 1)[[1]]
plot_blk(bm)
</code></pre>

<hr>
<h2 id='plot_reduced'>Plot a reduced network</h2><span id='topic+plot_reduced'></span>

<h3>Description</h3>

<p>Plot a reduced network using <span class="pkg">igraph</span>, with nodes colored by block number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_reduced(iobject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_reduced_+3A_iobject">iobject</code></td>
<td>
<p>An <code>igraph</code> object representing the reduced network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the reduced network, where each node represents all the nodes assigned to that
position by CONCOR. Node colors on the reduced network plot are assigned by position, so
if CONCOR is also used for vertex color on a sociogram (as in <code><a href="#topic+plot_socio">plot_socio</a></code>),
the node colors will align between the plots.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_reduced">make_reduced</a></code>, <code><a href="#topic+make_reduced_igraph">make_reduced_igraph</a></code>, <code><a href="#topic+plot_socio">plot_socio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g1 &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(g1) &lt;- c("a", "b", "c", "d")
colnames(g1) &lt;- c("a", "b", "c", "d")

r_mat &lt;- make_reduced(list(g1), nsplit = 1)
r_igraph &lt;- make_reduced_igraph(r_mat$reduced_mat[[1]])

plot_reduced(r_igraph)
</code></pre>

<hr>
<h2 id='plot_socio'>Plot sociogram colored by CONCOR partition</h2><span id='topic+plot_socio'></span>

<h3>Description</h3>

<p>Plots a network of interest using CONCOR partition as vertex color. Uses an <code>igraph</code>
object, normally created by <code><a href="#topic+concor_make_igraph">concor_make_igraph</a></code> or
<code><a href="#topic+concor_igraph_apply">concor_igraph_apply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_socio(iobject, nsplit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_socio_+3A_iobject">iobject</code></td>
<td>
<p>An <code>igraph</code> object with <code>concor</code> split as appropriately-named
vertex attribute.</p>
</td></tr>
<tr><td><code id="plot_socio_+3A_nsplit">nsplit</code></td>
<td>
<p>Split number to use as vertex color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a shortcut to plot an <code>igraph</code> object with usually-readable settings. It
looks for the input <code>iobject</code> to have a vertex attribute called
<code>csplit(nsplit)</code> that holds the CONCOR partition assignment (for example, if
<code>nsplit = 2</code>, then <code>plot_socio</code> expects a vertex attribute named
<code>csplit2</code>).
</p>


<h3>Value</h3>

<p>Returns NULL, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concor">concor</a></code>, <code><a href="#topic+concor_make_igraph">concor_make_igraph</a></code>, <code><a href="#topic+concor_igraph_apply">concor_igraph_apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0), ncol = 4)
rownames(a) &lt;- c("a", "b", "c", "d")
colnames(a) &lt;- c("a", "b", "c", "d")

i_out &lt;- concor_make_igraph(list(a))
plot_socio(i_out[[1]], 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
