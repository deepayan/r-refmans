<!DOCTYPE html><html lang="en"><head><title>Help for package fuzzywuzzyR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fuzzywuzzyR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_availability'><p>This function checks if all relevant python modules are available</p></a></li>
<li><a href='#check_scorer'><p>secondary function for the 'FuzzExtract' class</p></a></li>
<li><a href='#FuzzExtract'><p>Fuzzy extraction from a sequence</p></a></li>
<li><a href='#FuzzMatcher'><p>Fuzzy character string matching ( ratios )</p></a></li>
<li><a href='#FuzzUtils'><p>Utility functions</p></a></li>
<li><a href='#GetCloseMatches'><p>Matches of character strings</p></a></li>
<li><a href='#is_python2'><p>This function returns TRUE if python2 is installed and used in the OS</p></a></li>
<li><a href='#SequenceMatcher'><p>Character string sequence matching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fuzzy String Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-11</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlampros/fuzzywuzzyR/issues">https://github.com/mlampros/fuzzywuzzyR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/fuzzywuzzyR">https://github.com/mlampros/fuzzywuzzyR</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fuzzy string matching implementation of the 'fuzzywuzzy' <a href="https://github.com/seatgeek/fuzzywuzzy">https://github.com/seatgeek/fuzzywuzzy</a> 'python' package. It uses the Levenshtein Distance <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">https://en.wikipedia.org/wiki/Levenshtein_distance</a> to calculate the differences between sequences. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python (&gt;= 2.4), difflib, fuzzywuzzy ( &gt;=0.15.0 ),
python-Levenshtein ( &gt;=0.12.0 ). Detailed installation
instructions for each operating system can be found in the
README file.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate, R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-11 13:21:05 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  SeatGeek Inc [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-11 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_availability'>This function checks if all relevant python modules are available</h2><span id='topic+check_availability'></span>

<h3>Description</h3>

<p>This function checks if all relevant python modules are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_availability()
</code></pre>

<hr>
<h2 id='check_scorer'>secondary function for the 'FuzzExtract' class</h2><span id='topic+check_scorer'></span>

<h3>Description</h3>

<p>secondary function for the 'FuzzExtract' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_scorer(scorer, DECODING)
</code></pre>

<hr>
<h2 id='FuzzExtract'>Fuzzy extraction from a sequence</h2><span id='topic+FuzzExtract'></span>

<h3>Description</h3>

<p>Fuzzy extraction from a sequence
</p>
<p>Fuzzy extraction from a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- FuzzExtract$new(decoding = NULL)
</code></pre>


<h3>Details</h3>

<p>the <em>decoding</em> parameter is useful in case of non-ascii character strings. If this parameter is not NULL then the <em>force_ascii</em> parameter (if applicable) is internally set to FALSE. Decoding applies only to python 2 configurations, as in python 3 character strings are decoded to unicode by default.
</p>
<p>the <em>Extract</em> method selects the best match of a character string vector. It returns a list with the match and it's score.
</p>
<p>the <em>ExtractBests</em> method returns a list of the best matches for a sequence of character strings.
</p>
<p>the <em>ExtractWithoutOrder</em> method returns the best match of a character string vector (in python it returns a generator of tuples containing the match and it's score).
</p>
<p>the <em>ExtractOne</em> method finds the single best match above a score for a character string vector. This is a convenience method which returns the single best choice.
</p>
<p>the <em>Dedupe</em> is a convenience method which takes a character string vector containing duplicates and uses fuzzy matching to identify and remove duplicates. Specifically, it uses the <em>Extract</em> method
to identify duplicates that score greater than a user defined threshold. Then, it looks for the longest item in the duplicate vector since we assume this item contains the most entity information and returns that.
It breaks string length ties on an alphabetical sort. Note: as the threshold DECREASES the number of duplicates that are found INCREASES. This means that the returned deduplicated list will likely be shorter.
Raise the threshold for fuzzy_dedupe to be less sensitive.
</p>


<h3>Methods</h3>


<dl>
<dt><code>FuzzExtract$new(decoding = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Extract(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, limit = 5L)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>ExtractBests(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L, limit = 5L)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>ExtractWithoutOrder(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>ExtractOne(string = NULL, sequence_strings = NULL, processor = NULL, scorer = NULL, score_cutoff = 0L)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Dedupe(contains_dupes = NULL, threshold = 70L, scorer = NULL)</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>FuzzExtract$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Extract"><code>FuzzExtract$Extract()</code></a>
</p>
</li>
<li> <p><a href="#method-ExtractBests"><code>FuzzExtract$ExtractBests()</code></a>
</p>
</li>
<li> <p><a href="#method-ExtractWithoutOrder"><code>FuzzExtract$ExtractWithoutOrder()</code></a>
</p>
</li>
<li> <p><a href="#method-ExtractOne"><code>FuzzExtract$ExtractOne()</code></a>
</p>
</li>
<li> <p><a href="#method-Dedupe"><code>FuzzExtract$Dedupe()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>FuzzExtract$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$new(decoding = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>decoding</code></dt><dd><p>either NULL or a character string. If not NULL then the <em>decoding</em> parameter takes one of the standard python encodings (such as 'utf-8'). See the <em>details</em> and <em>references</em> link for more information.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Extract"></a>



<h4>Method <code>Extract()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$Extract(
  string = NULL,
  sequence_strings = NULL,
  processor = NULL,
  scorer = NULL,
  limit = 5L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>sequence_strings</code></dt><dd><p>a character string vector</p>
</dd>
<dt><code>processor</code></dt><dd><p>either NULL or a function of the form f(a) -&gt; b, where a is the query or individual choice and b is the choice to be used in matching. See the examples for more details.</p>
</dd>
<dt><code>scorer</code></dt><dd><p>a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -&gt; int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.</p>
</dd>
<dt><code>limit</code></dt><dd><p>An integer value for the maximum number of elements to be returned. Defaults to 5L</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExtractBests"></a>



<h4>Method <code>ExtractBests()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$ExtractBests(
  string = NULL,
  sequence_strings = NULL,
  processor = NULL,
  scorer = NULL,
  score_cutoff = 0L,
  limit = 5L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>sequence_strings</code></dt><dd><p>a character string vector</p>
</dd>
<dt><code>processor</code></dt><dd><p>either NULL or a function of the form f(a) -&gt; b, where a is the query or individual choice and b is the choice to be used in matching. See the examples for more details.</p>
</dd>
<dt><code>scorer</code></dt><dd><p>a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -&gt; int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.</p>
</dd>
<dt><code>score_cutoff</code></dt><dd><p>an integer value for the score threshold. No matches with a score less than this number will be returned. Defaults to 0</p>
</dd>
<dt><code>limit</code></dt><dd><p>An integer value for the maximum number of elements to be returned. Defaults to 5L</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExtractWithoutOrder"></a>



<h4>Method <code>ExtractWithoutOrder()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$ExtractWithoutOrder(
  string = NULL,
  sequence_strings = NULL,
  processor = NULL,
  scorer = NULL,
  score_cutoff = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>sequence_strings</code></dt><dd><p>a character string vector</p>
</dd>
<dt><code>processor</code></dt><dd><p>either NULL or a function of the form f(a) -&gt; b, where a is the query or individual choice and b is the choice to be used in matching. See the examples for more details.</p>
</dd>
<dt><code>scorer</code></dt><dd><p>a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -&gt; int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.</p>
</dd>
<dt><code>score_cutoff</code></dt><dd><p>an integer value for the score threshold. No matches with a score less than this number will be returned. Defaults to 0</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExtractOne"></a>



<h4>Method <code>ExtractOne()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$ExtractOne(
  string = NULL,
  sequence_strings = NULL,
  processor = NULL,
  scorer = NULL,
  score_cutoff = 0L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>sequence_strings</code></dt><dd><p>a character string vector</p>
</dd>
<dt><code>processor</code></dt><dd><p>either NULL or a function of the form f(a) -&gt; b, where a is the query or individual choice and b is the choice to be used in matching. See the examples for more details.</p>
</dd>
<dt><code>scorer</code></dt><dd><p>a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -&gt; int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.</p>
</dd>
<dt><code>score_cutoff</code></dt><dd><p>an integer value for the score threshold. No matches with a score less than this number will be returned. Defaults to 0</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dedupe"></a>



<h4>Method <code>Dedupe()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$Dedupe(contains_dupes = NULL, threshold = 70L, scorer = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>contains_dupes</code></dt><dd><p>a vector of strings that we would like to dedupe</p>
</dd>
<dt><code>threshold</code></dt><dd><p>the numerical value (0, 100) point at which we expect to find duplicates. Defaults to 70 out of 100</p>
</dd>
<dt><code>scorer</code></dt><dd><p>a function for scoring matches between the query and an individual processed choice. This should be a function of the form f(query, choice) -&gt; int. By default, FuzzMatcher.WRATIO() is used and expects both query and choice to be strings. See the examples for more details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzExtract$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/process.py, https://docs.python.org/3/library/codecs.html#standard-encodings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {

    if (check_availability()) {

      library(fuzzywuzzyR)

      word = "new york jets"

      choices = c("Atlanta Falcons", "New York Jets", "New York Giants", "Dallas Cowboys")

      duplicat = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin', 'Samuel L. Jackson',

                   'F. Baggins', 'Frody Baggins', 'Bilbo Baggins')

      #------------
      # processor :
      #------------

      init_proc = FuzzUtils$new()

      PROC = init_proc$Full_process    # class process-method

      PROC1 = tolower                  # base R function

      #---------
      # scorer :
      #---------

      init_scor = FuzzMatcher$new()

      SCOR = init_scor$WRATIO


      init &lt;- FuzzExtract$new()

      init$Extract(string = word, sequence_strings = choices, processor = PROC, scorer = SCOR)

      init$ExtractBests(string = word, sequence_strings = choices, processor = PROC1,

                        scorer = SCOR, score_cutoff = 0L, limit = 2L)

      init$ExtractWithoutOrder(string = word, sequence_strings = choices, processor = PROC,

                               scorer = SCOR, score_cutoff = 0L)

      init$ExtractOne(string = word, sequence_strings = choices, processor = PROC,

                      scorer = SCOR, score_cutoff = 0L)

      init$Dedupe(contains_dupes = duplicat, threshold = 70L, scorer = SCOR)

    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='FuzzMatcher'>Fuzzy character string matching ( ratios )</h2><span id='topic+FuzzMatcher'></span>

<h3>Description</h3>

<p>Fuzzy character string matching ( ratios )
</p>
<p>Fuzzy character string matching ( ratios )
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- FuzzMatcher$new(decoding = NULL)
</code></pre>


<h3>Details</h3>

<p>the <em>decoding</em> parameter is useful in case of non-ascii character strings. If this parameter is not NULL then the <em>force_ascii</em> parameter (if applicable) is internally set to FALSE. Decoding applies only to python 2 configurations, as in python 3 character strings are decoded to unicode by default.
</p>
<p>the <em>Partial_token_set_ratio</em> method works in the following way : 1. Find all alphanumeric tokens in each string, 2. treat them as a set, 3. construct two strings of the form, &lt;sorted_intersection&gt;&lt;sorted_remainder&gt;, 4. take ratios of those two strings, 5. controls for unordered partial matches (HERE partial match is TRUE)
</p>
<p>the <em>Partial_token_sort_ratio</em> method returns the ratio of the most similar substring as a number between 0 and 100 but sorting the token before comparing.
</p>
<p>the <em>Ratio</em> method returns a ration in form of an integer value based on a SequenceMatcher-like class, which is built on top of the Levenshtein package (https://github.com/miohtama/python-Levenshtein)
</p>
<p>the <em>QRATIO</em> method performs a quick ratio comparison between two strings. Runs full_process from utils on both strings. Short circuits if either of the strings is empty after processing.
</p>
<p>the <em>WRATIO</em> method returns a measure of the sequences' similarity between 0 and 100, using different algorithms. Steps in the order they occur :
1. Run full_process from utils on both strings, 2. Short circuit if this makes either string empty, 3. Take the ratio of the two processed strings (fuzz.ratio),
4. Run checks to compare the length of the strings (If one of the strings is more than 1.5 times as long as the other use partial_ratio comparisons - scale partial results by 0.9 - this makes sure only full results can return 100 -
If one of the strings is over 8 times as long as the other instead scale by 0.6), 5. Run the other ratio functions (if using partial ratio functions call partial_ratio,
partial_token_sort_ratio and partial_token_set_ratio scale all of these by the ratio based on length otherwise call token_sort_ratio and token_set_ratio all token based comparisons are scaled by 0.95 - on top of any partial scalars)
6. Take the highest value from these results round it and return it as an integer.
</p>
<p>the <em>UWRATIO</em> method returns a measure of the sequences' similarity between 0 and 100, using different algorithms. Same as WRatio but preserving unicode
</p>
<p>the <em>UQRATIO</em> method returns a Unicode quick ratio. It calls <em>QRATIO</em> with force_ascii set to FALSE.
</p>
<p>the <em>Token_sort_ratio</em> method returns a measure of the sequences' similarity between 0 and 100 but sorting the token before comparing
</p>
<p>the <em>Partial_ratio</em> returns the ratio of the most similar substring as a number between 0 and 100.
</p>
<p>the <em>Token_set_ratio</em> method works in the following way : 1. Find all alphanumeric tokens in each string, 2. treat them as a set, 3. construct two strings of the form, &lt;sorted_intersection&gt;&lt;sorted_remainder&gt;, 4. take ratios of those two strings, 5. controls for unordered partial matches (HERE partial match is FALSE)
</p>


<h3>Methods</h3>


<dl>
<dt><code>FuzzMatcher$new(decoding = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Partial_token_set_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Partial_token_sort_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Ratio(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>QRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>WRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>UWRATIO(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>UQRATIO(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Token_sort_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Partial_ratio(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Token_set_ratio(string1 = NULL, string2 = NULL, force_ascii = TRUE, full_process = TRUE)</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>FuzzMatcher$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Partial_token_set_ratio"><code>FuzzMatcher$Partial_token_set_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-Partial_token_sort_ratio"><code>FuzzMatcher$Partial_token_sort_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-Ratio"><code>FuzzMatcher$Ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-QRATIO"><code>FuzzMatcher$QRATIO()</code></a>
</p>
</li>
<li> <p><a href="#method-WRATIO"><code>FuzzMatcher$WRATIO()</code></a>
</p>
</li>
<li> <p><a href="#method-UWRATIO"><code>FuzzMatcher$UWRATIO()</code></a>
</p>
</li>
<li> <p><a href="#method-UQRATIO"><code>FuzzMatcher$UQRATIO()</code></a>
</p>
</li>
<li> <p><a href="#method-Token_sort_ratio"><code>FuzzMatcher$Token_sort_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-Partial_ratio"><code>FuzzMatcher$Partial_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-Token_set_ratio"><code>FuzzMatcher$Token_set_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>FuzzMatcher$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$new(decoding = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>decoding</code></dt><dd><p>either NULL or a character string. If not NULL then the <em>decoding</em> parameter takes one of the standard python encodings (such as 'utf-8'). See the <em>details</em> and <em>references</em> link for more information.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Partial_token_set_ratio"></a>



<h4>Method <code>Partial_token_set_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Partial_token_set_ratio(
  string1 = NULL,
  string2 = NULL,
  force_ascii = TRUE,
  full_process = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
<dt><code>full_process</code></dt><dd><p>either TRUE or FALSE. If TRUE then it process the string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Partial_token_sort_ratio"></a>



<h4>Method <code>Partial_token_sort_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Partial_token_sort_ratio(
  string1 = NULL,
  string2 = NULL,
  force_ascii = TRUE,
  full_process = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
<dt><code>full_process</code></dt><dd><p>either TRUE or FALSE. If TRUE then it process the string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Ratio"></a>



<h4>Method <code>Ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Ratio(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QRATIO"></a>



<h4>Method <code>QRATIO()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$QRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WRATIO"></a>



<h4>Method <code>WRATIO()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$WRATIO(string1 = NULL, string2 = NULL, force_ascii = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-UWRATIO"></a>



<h4>Method <code>UWRATIO()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$UWRATIO(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-UQRATIO"></a>



<h4>Method <code>UQRATIO()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$UQRATIO(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Token_sort_ratio"></a>



<h4>Method <code>Token_sort_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Token_sort_ratio(
  string1 = NULL,
  string2 = NULL,
  force_ascii = TRUE,
  full_process = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
<dt><code>full_process</code></dt><dd><p>either TRUE or FALSE. If TRUE then it process the string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Partial_ratio"></a>



<h4>Method <code>Partial_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Partial_ratio(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Token_set_ratio"></a>



<h4>Method <code>Token_set_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$Token_set_ratio(
  string1 = NULL,
  string2 = NULL,
  force_ascii = TRUE,
  full_process = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
<dt><code>full_process</code></dt><dd><p>either TRUE or FALSE. If TRUE then it process the string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzMatcher$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/fuzz.py, https://docs.python.org/3/library/codecs.html#standard-encodings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {

    if (check_availability()) {

      library(fuzzywuzzyR)

      s1 = "Atlanta Falcons"

      s2 = "New York Jets"

      init = FuzzMatcher$new()

      init$Partial_token_set_ratio(string1 = s1,
                                   string2 = s2,
                                   force_ascii = TRUE,
                                   full_process = TRUE)

      init$Partial_token_sort_ratio(string1 = s1,
                                    string2 = s2,
                                    force_ascii = TRUE,
                                    full_process = TRUE)

      init$Ratio(string1 = s1, string2 = s2)

      init$QRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)

      init$WRATIO(string1 = s1, string2 = s2, force_ascii = TRUE)

      init$UWRATIO(string1 = s1, string2 = s2)

      init$UQRATIO(string1 = s1, string2 = s2)

      init$Token_sort_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)

      init$Partial_ratio(string1 = s1, string2 = s2)

      init$Token_set_ratio(string1 = s1, string2 = s2, force_ascii = TRUE, full_process = TRUE)
    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='FuzzUtils'>Utility functions</h2><span id='topic+FuzzUtils'></span>

<h3>Description</h3>

<p>Utility functions
</p>
<p>Utility functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- FuzzUtils$new()
</code></pre>


<h3>Details</h3>

<p>the <em>decoding</em> parameter is useful in case of non-ascii character strings. If this parameter is not NULL then the <em>force_ascii</em> parameter (if applicable) is internally set to FALSE. Decoding applies only to python 2 configurations, as in python 3 character strings are decoded to unicode by default.
</p>
<p>the <em>Full_process</em> processes a string by : 1. removing all but letters and numbers, 2. trim whitespace, 3. force to lower case and 4. if force_ascii == TRUE, force convert to ascii
</p>
<p>the <em>INTR</em> method returns a correctly rounded integer
</p>
<p>the <em>Make_type_consistent</em> method converts both objects if they aren't either both string or unicode instances to unicode
</p>
<p>the <em>Asciidammit</em> performs ascii dammit using the following expression <em>bad_chars = str(&quot;&quot;).join([chr(i) for i in range(128, 256)])</em>. Applies to any kind of R data type.
</p>
<p>the <em>Asciionly</em> method returns the same result as the <em>Asciidammit</em> method but for character strings using the python <em>.translate()</em> function.
</p>
<p>the <em>Validate_string</em> method checks that the input has length and that length is greater than 0
</p>
<p>Some of the utils functions are used as secondary methods in the <em>FuzzExtract</em> class. See the examples of the <em>FuzzExtract</em> class for more details.
</p>


<h3>Methods</h3>


<dl>
<dt><code>FuzzUtils$new()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Full_process(string = NULL, force_ascii = TRUE, decoding = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>INTR(n = 2.0)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Make_type_consistent(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Asciidammit(input = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Asciionly(string = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>Validate_string(string = NULL)</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>FuzzUtils$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Full_process"><code>FuzzUtils$Full_process()</code></a>
</p>
</li>
<li> <p><a href="#method-INTR"><code>FuzzUtils$INTR()</code></a>
</p>
</li>
<li> <p><a href="#method-Make_type_consistent"><code>FuzzUtils$Make_type_consistent()</code></a>
</p>
</li>
<li> <p><a href="#method-Asciidammit"><code>FuzzUtils$Asciidammit()</code></a>
</p>
</li>
<li> <p><a href="#method-Asciionly"><code>FuzzUtils$Asciionly()</code></a>
</p>
</li>
<li> <p><a href="#method-Validate_string"><code>FuzzUtils$Validate_string()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>FuzzUtils$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$new()</pre></div>


<hr>
<a id="method-Full_process"></a>



<h4>Method <code>Full_process()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$Full_process(string = NULL, force_ascii = TRUE, decoding = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>force_ascii</code></dt><dd><p>allow only ASCII characters (force convert to ascii)</p>
</dd>
<dt><code>decoding</code></dt><dd><p>either NULL or a character string. If not NULL then the <em>decoding</em> parameter takes one of the standard python encodings (such as 'utf-8'). See the <em>details</em> and <em>references</em> link for more information (in this class it applies only to the <em>Full_process</em> function)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-INTR"></a>



<h4>Method <code>INTR()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$INTR(n = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>a float number</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Make_type_consistent"></a>



<h4>Method <code>Make_type_consistent()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$Make_type_consistent(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Asciidammit"></a>



<h4>Method <code>Asciidammit()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$Asciidammit(input = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input</code></dt><dd><p>any kind of data type (applies to the <em>Asciidammit</em> method)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Asciionly"></a>



<h4>Method <code>Asciionly()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$Asciionly(string = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Validate_string"></a>



<h4>Method <code>Validate_string()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$Validate_string(string = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzUtils$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/seatgeek/fuzzywuzzy/blob/master/fuzzywuzzy/utils.py, https://docs.python.org/3/library/codecs.html#standard-encodings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {

    if (check_availability()) {

      library(fuzzywuzzyR)

      s1 = 'Frodo Baggins'

      s2 = 'Bilbo Baggin'

      init = FuzzUtils$new()

      init$Full_process(string = s1, force_ascii = TRUE)

      init$INTR(n = 2.0)

      init$Make_type_consistent(string1 = s1, string2 = s2)

      #------------------------------------
      # 'Asciidammit' with character string
      #------------------------------------

      init$Asciidammit(input = s1)

      #----------------------------------------------------------------
      # 'Asciidammit' with data.frame(123) [ or any kind of data type ]
      #----------------------------------------------------------------

      init$Asciidammit(input = data.frame(123))

      init$Asciionly(string = s1)

      init$Validate_string(string = s2)
    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='GetCloseMatches'>Matches of character strings</h2><span id='topic+GetCloseMatches'></span>

<h3>Description</h3>

<p>Matches of character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCloseMatches(string = NULL, sequence_strings = NULL, n = 3L, cutoff = 0.6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetCloseMatches_+3A_string">string</code></td>
<td>
<p>a character string.</p>
</td></tr>
<tr><td><code id="GetCloseMatches_+3A_sequence_strings">sequence_strings</code></td>
<td>
<p>a vector of character strings.</p>
</td></tr>
<tr><td><code id="GetCloseMatches_+3A_n">n</code></td>
<td>
<p>an integer value specifying the maximum number of close matches to return; n must be greater than 0.</p>
</td></tr>
<tr><td><code id="GetCloseMatches_+3A_cutoff">cutoff</code></td>
<td>
<p>a float number in the range [0, 1], <em>sequence_strings</em> that don't score at least that similar to <em>string</em> are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a list of the best &quot;good enough&quot; matches. <em>string</em> is a sequence for which close matches are desired (typically a string), and <em>sequence_strings</em> is a list of sequences against
which to match <em>string</em> (typically a list of strings).
</p>


<h3>References</h3>

<p>https://www.npmjs.com/package/difflib, http://stackoverflow.com/questions/10383044/fuzzy-string-comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {

    if (check_availability()) {

      library(fuzzywuzzyR)

      vec = c('Frodo Baggins', 'Tom Sawyer', 'Bilbo Baggin')

      str1 = 'Fra Bagg'

      GetCloseMatches(string = str1, sequence_strings = vec, n = 2L, cutoff = 0.6)

    }
  }
}, silent=TRUE)
</code></pre>

<hr>
<h2 id='is_python2'>This function returns TRUE if python2 is installed and used in the OS</h2><span id='topic+is_python2'></span>

<h3>Description</h3>

<p>This function returns TRUE if python2 is installed and used in the OS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_python2()
</code></pre>

<hr>
<h2 id='SequenceMatcher'>Character string sequence matching</h2><span id='topic+SequenceMatcher'></span>

<h3>Description</h3>

<p>Character string sequence matching
</p>
<p>Character string sequence matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- SequenceMatcher$new(string1 = NULL, string2 = NULL)
</code></pre>


<h3>Details</h3>

<p>the <em>ratio</em> method returns a measure of the sequences' similarity as a float in the range [0, 1]. Where T is the total number of elements in both sequences, and M is the number of matches, this
is 2.0*M / T. Note that this is 1.0 if the sequences are identical, and 0.0 if they have nothing in common. This is expensive to compute if getMatchingBlocks() or getOpcodes() hasnâ€™t already been called,
in which case you may want to try quickRatio() or realQuickRatio() first to get an upper bound.
</p>
<p>the <em>quick_ratio</em> method returns an upper bound on ratio() relatively quickly.
</p>
<p>the <em>real_quick_ratio</em> method returns an upper bound on ratio() very quickly.
</p>
<p>the <em>get_matching_blocks</em> method returns a list of triples describing matching subsequences. Each triple is of the form [i, j, n], and means that a[i:i+n] == b[j:j+n]. The triples are monotonically
increasing in i and j. The last triple is a dummy, and has the value [a.length, b.length, 0]. It is the only triple with n == 0. If [i, j, n] and [i', j', n'] are adjacent triples in the list, and the second
is not the last triple in the list, then i+n != i' or j+n != j'; in other words, adjacent triples always describe non-adjacent equal blocks.
</p>
<p>The <em>get_opcodes</em> method returns a list of 5-tuples describing how to turn a into b. Each tuple is of the form [tag, i1, i2, j1, j2]. The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to
the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2. The tag values are strings, with these meanings:
'replace'   a[i1:i2] should be replaced by b[j1:j2].
'delete'    a[i1:i2] should be deleted. Note that j1 == j2 in this case.
'insert'    b[j1:j2] should be inserted at a[i1:i1]. Note that i1 == i2 in this case.
'equal'     a[i1:i2] == b[j1:j2] (the sub-sequences are equal).
</p>


<h3>Methods</h3>


<dl>
<dt><code>SequenceMatcher$new(string1 = NULL, string2 = NULL)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>ratio()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>quick_ratio()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>real_quick_ratio()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>get_matching_blocks()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>get_opcodes()</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>SequenceMatcher$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ratio"><code>SequenceMatcher$ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-quick_ratio"><code>SequenceMatcher$quick_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-real_quick_ratio"><code>SequenceMatcher$real_quick_ratio()</code></a>
</p>
</li>
<li> <p><a href="#method-get_matching_blocks"><code>SequenceMatcher$get_matching_blocks()</code></a>
</p>
</li>
<li> <p><a href="#method-get_opcodes"><code>SequenceMatcher$get_opcodes()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>SequenceMatcher$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$new(string1 = NULL, string2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>string1</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>string2</code></dt><dd><p>a character string.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ratio"></a>



<h4>Method <code>ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$ratio()</pre></div>


<hr>
<a id="method-quick_ratio"></a>



<h4>Method <code>quick_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$quick_ratio()</pre></div>


<hr>
<a id="method-real_quick_ratio"></a>



<h4>Method <code>real_quick_ratio()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$real_quick_ratio()</pre></div>


<hr>
<a id="method-get_matching_blocks"></a>



<h4>Method <code>get_matching_blocks()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$get_matching_blocks()</pre></div>


<hr>
<a id="method-get_opcodes"></a>



<h4>Method <code>get_opcodes()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$get_opcodes()</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SequenceMatcher$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://www.npmjs.com/package/difflib, http://stackoverflow.com/questions/10383044/fuzzy-string-comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
  if (reticulate::py_available(initialize = FALSE)) {

    if (check_availability()) {

      library(fuzzywuzzyR)

      s1 = ' It was a dark and stormy night. I was all alone sitting on a red chair.'

      s2 = ' It was a murky and stormy night. I was all alone sitting on a crimson chair.'

      init = SequenceMatcher$new(string1 = s1, string2 = s2)

      init$ratio()

      init$quick_ratio()

      init$real_quick_ratio()

      init$get_matching_blocks()

      init$get_opcodes()

    }
  }
}, silent=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
