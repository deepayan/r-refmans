<!DOCTYPE html><html lang="en"><head><title>Help for package SoupX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SoupX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustCounts'><p>Remove background contamination from count matrix</p></a></li>
<li><a href='#alloc'><p>Allocate values to &quot;buckets&quot; subject to weights and constraints</p></a></li>
<li><a href='#autoEstCont'><p>Automatically calculate the contamination fraction</p></a></li>
<li><a href='#calculateContaminationFraction'><p>Calculate the contamination fraction</p></a></li>
<li><a href='#estimateNonExpressingCells'><p>Calculate which cells genuinely do not express a particular gene or set of genes</p></a></li>
<li><a href='#estimateSoup'><p>Get expression profile of soup</p></a></li>
<li><a href='#expandClusters'><p>Expands soup counts calculated at the cluster level to the cell level</p></a></li>
<li><a href='#initProgBar'><p>Create Seurat style progress bar</p></a></li>
<li><a href='#load10X'><p>Load a collection of 10X data-sets</p></a></li>
<li><a href='#PBMC_metaData'><p>PBMC 4K meta data</p></a></li>
<li><a href='#PBMC_sc'><p>SoupChannel from PBMC data</p></a></li>
<li><a href='#plotChangeMap'><p>Plot maps comparing corrected/raw expression</p></a></li>
<li><a href='#plotMarkerDistribution'><p>Plots the distribution of the observed to expected expression for marker genes</p></a></li>
<li><a href='#plotMarkerMap'><p>Plot ratio of observed to expected counts on reduced dimension map</p></a></li>
<li><a href='#plotSoupCorrelation'><p>Plot correlation of expression profiles of soup and aggregated cells</p></a></li>
<li><a href='#print.SoupChannel'><p>Print method for SoupChannel</p></a></li>
<li><a href='#quickMarkers'><p>Gets top N markers for each cluster</p></a></li>
<li><a href='#scToy'><p>Toy SoupChanel object</p></a></li>
<li><a href='#setClusters'><p>Sets clustering for SoupChannel</p></a></li>
<li><a href='#setContaminationFraction'><p>Manually set contamination fraction</p></a></li>
<li><a href='#setDR'><p>Manually set dimension reduction for a channel</p></a></li>
<li><a href='#setSoupProfile'><p>Set soup profile</p></a></li>
<li><a href='#SoupChannel'><p>Construct a SoupChannel object</p></a></li>
<li><a href='#SoupX'><p>SoupX: Profile, quantify and remove ambient RNA expression from droplet based RNA-seq</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Single Cell mRNA Soup eXterminator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Daniel Young</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Daniel Young &lt;my4@sanger.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantify, profile and remove ambient mRNA contamination (the "soup") from droplet based single cell RNA-seq experiments.  Implements the method described in Young et al. (2018) &lt;<a href="https://doi.org/10.1101%2F303727">doi:10.1101/303727</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/constantAmateur/SoupX">https://github.com/constantAmateur/SoupX</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rstan, DropletUtils, rmarkdown, formatR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, Matrix, methods, Seurat (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-01 13:18:04 UTC; my4</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-01 14:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustCounts'>Remove background contamination from count matrix</h2><span id='topic+adjustCounts'></span>

<h3>Description</h3>

<p>After the level of background contamination has been estimated or specified for a channel, calculate the resulting corrected count matrix with background contamination removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustCounts(
  sc,
  clusters = NULL,
  method = c("subtraction", "soupOnly", "multinomial"),
  roundToInt = FALSE,
  verbose = 1,
  tol = 0.001,
  pCut = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustCounts_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_clusters">clusters</code></td>
<td>
<p>A vector of cluster IDs, named by cellIDs.  If NULL clusters auto-loaded from <code>sc</code>.  If FALSE, no clusters are used.  See details.</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_method">method</code></td>
<td>
<p>Method to use for correction.  See details.  One of 'multinomial', 'soupOnly', or 'subtraction'</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_roundtoint">roundToInt</code></td>
<td>
<p>Should the resulting matrix be rounded to integers?</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_verbose">verbose</code></td>
<td>
<p>Integer giving level of verbosity.  0 = silence, 1 = Basic information, 2 = Very chatty, 3 = Debug.</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_tol">tol</code></td>
<td>
<p>Allowed deviation from expected number of soup counts.  Don't change this.</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_pcut">pCut</code></td>
<td>
<p>The p-value cut-off used when <code>method='soupOnly'</code>.</p>
</td></tr>
<tr><td><code id="adjustCounts_+3A_...">...</code></td>
<td>
<p>Passed to expandClusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This essentially subtracts off the mean expected background counts for each gene, then redistributes any &quot;unused&quot; counts.  A count is unused if its subtraction has no effect.  For example, subtracting a count from a gene that has zero counts to begin with.
</p>
<p>As expression data is highly sparse at the single cell level, it is highly recommended that clustering information be provided to allow the subtraction method to share information between cells.  Without grouping cells into clusters, it is difficult (and usually impossible) to tell the difference between a count of 1 due to background contamination and a count of 1 due to endogenous expression.  This ambiguity is removed at the cluster level where counts can be aggregated across cells.  This information can then be propagated back to the individual cell level to provide a more accurate removal of contaminating counts.
</p>
<p>To provide clustering information, either set clustering on the SoupChannel object with <code><a href="#topic+setClusters">setClusters</a></code> or explicitly passing the <code>clusters</code> parameter.  
</p>
<p>If <code>roundToInt=TRUE</code>, this function will round the result to integers.  That is, it will take the floor of the connected value and then round back up with probability equal to the fractional part of the number.
</p>
<p>The <code>method</code> parameter controls how the removal of counts in performed.  This should almost always be left at the default ('subtraction'), which iteratively subtracts counts from all genes as described above.  The 'soupOnly' method will use a p-value based estimation procedure to identify those genes that can be confidently identified as having endogenous expression and removes everything else (described in greater detail below).  Because this method either removes all or none of the expression for a gene in a cell, the correction procedure is much faster.  Finally, the 'multinomial' method explicitly maximises the multinomial likelihood for each cell.  This method gives essentially identical results as 'subtraction' and is considerably slower.
</p>
<p>In greater detail, the 'soupOnly' method is done by sorting genes within each cell by their p-value under the null of the expected soup fraction using a Poisson model.  So that genes that definitely do have a endogenous contribution are at the end of the list with p=0.  Those genes for which there is poor evidence of endogenous cell expression are removed, until we have removed approximately nUMIs*rho molecules.  The cut-off to prevent removal of genes above nUMIs*rho in each cell is achieved by calculating a separate p-value for the total number of counts removed to exceed nUMIs*rho, again using a Poisson model.  The two p-values are combined using Fisher's method and the cut-off is applied to the resulting combined p-value calculated using a chi-squared distribution with 4 degrees of freedom.
</p>


<h3>Value</h3>

<p>A modified version of the table of counts, with background contamination removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out = adjustCounts(scToy)
#Return integer counts only
out = adjustCounts(scToy,roundToInt=TRUE)
</code></pre>

<hr>
<h2 id='alloc'>Allocate values to &quot;buckets&quot; subject to weights and constraints</h2><span id='topic+alloc'></span>

<h3>Description</h3>

<p>Allocates <code>tgt</code> of something to <code>length(bucketLims)</code> different &quot;buckets&quot; subject to the constraint that each bucket has a maximum value of <code>bucketLims</code> that cannot be exceeded.  By default counts are distributed equally between buckets, but weights can be provided using <code>ws</code> to have the redistribution prefer certain buckets over others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alloc(tgt, bucketLims, ws = rep(1/length(bucketLims), length(bucketLims)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alloc_+3A_tgt">tgt</code></td>
<td>
<p>Value to distribute between buckets.</p>
</td></tr>
<tr><td><code id="alloc_+3A_bucketlims">bucketLims</code></td>
<td>
<p>The maximum value that each bucket can take.  Must be a vector of positive values.</p>
</td></tr>
<tr><td><code id="alloc_+3A_ws">ws</code></td>
<td>
<p>Weights to be used for each bucket.  Default value makes all buckets equally likely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>bucketLims</code> containing values distributed into buckets.
</p>

<hr>
<h2 id='autoEstCont'>Automatically calculate the contamination fraction</h2><span id='topic+autoEstCont'></span>

<h3>Description</h3>

<p>The idea of this method is that genes that are highly expressed in the soup and are marker genes for some population can be used to estimate the background contamination.  Marker genes are identified using the tfidf method (see <code><a href="#topic+quickMarkers">quickMarkers</a></code>).  The contamination fraction is then calculated at the cluster level for each of these genes and clusters are then aggressively pruned to remove those that give implausible estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoEstCont(
  sc,
  topMarkers = NULL,
  tfidfMin = 1,
  soupQuantile = 0.9,
  maxMarkers = 100,
  contaminationRange = c(0.01, 0.8),
  rhoMaxFDR = 0.2,
  priorRho = 0.05,
  priorRhoStdDev = 0.1,
  doPlot = TRUE,
  forceAccept = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoEstCont_+3A_sc">sc</code></td>
<td>
<p>The SoupChannel object.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_topmarkers">topMarkers</code></td>
<td>
<p>A data.frame giving marker genes.  Must be sorted by decreasing specificity of marker and include a column 'gene' that contains the gene name.  If set to NULL, markers are estimated using <code><a href="#topic+quickMarkers">quickMarkers</a></code>.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_tfidfmin">tfidfMin</code></td>
<td>
<p>Minimum value of tfidf to accept for a marker gene.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_soupquantile">soupQuantile</code></td>
<td>
<p>Only use genes that are at or above this expression quantile in the soup.  This prevents inaccurate estimates due to using genes with poorly constrained contribution to the background.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_maxmarkers">maxMarkers</code></td>
<td>
<p>If we have heaps of good markers, keep only the best <code>maxMarkers</code> of them.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_contaminationrange">contaminationRange</code></td>
<td>
<p>Vector of length 2 that constrains the contamination fraction to lie within this range.  Must be between 0 and 1.  The high end of this range is passed to <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code> as <code>maximumContamination</code>.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_rhomaxfdr">rhoMaxFDR</code></td>
<td>
<p>False discovery rate passed to <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code>, to test if rho is less than <code>maximumContamination</code>.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_priorrho">priorRho</code></td>
<td>
<p>Mode of gamma distribution prior on contamination fraction.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_priorrhostddev">priorRhoStdDev</code></td>
<td>
<p>Standard deviation of gamma distribution prior on contamination fraction.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_doplot">doPlot</code></td>
<td>
<p>Create a plot showing the density of estimates?</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_forceaccept">forceAccept</code></td>
<td>
<p>Passed to <code><a href="#topic+setContaminationFraction">setContaminationFraction</a></code>.  Should we allow very high contamination fractions to be used.</p>
</td></tr>
<tr><td><code id="autoEstCont_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This set of marker genes is filtered to include only those with tf-idf value greater than <code>tfidfMin</code>.  A higher tf-idf value implies a more specific marker.  Specifically a cut-off t implies that a marker gene has the property that geneFreqGlobal &lt; exp(-t/geneFreqInClust).  See <code><a href="#topic+quickMarkers">quickMarkers</a></code>.  It may be necessary to decrease this value for data sets with few good markers.
</p>
<p>This set of marker genes is filtered down to include only the genes that are highly expressed in the soup, controlled by the <code>soupQuantile</code> parameter.  Genes highly expressed in the soup provide a more precise estimate of the contamination fraction.
</p>
<p>The pruning of implausible clusters is based on a call to <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code>.  The parameters <code>maximumContamination=max(contaminationRange)</code> and <code>rhoMaxFDR</code> are passed to this function.  The defaults set here are calibrated to aggressively prune anything that has even the weakest of evidence that it is genuinely expressed. 
</p>
<p>For each cluster/gene pair the posterior distribution of the contamination fraction is calculated (based on gamma prior, controlled by <code>priorRho</code> and <code>priorRhoStdDev</code>).  These posterior distributions are aggregated to produce a final estimate of the contamination fraction. The logic behind this is that estimates from clusters that truly estimate the contamination fraction will cluster around the true value, while erroneous estimates will be spread out across the range (0,1) without a 'preferred value'.  The most probable value of the contamination fraction is then taken as the final global contamination fraction.
</p>


<h3>Value</h3>

<p>A modified SoupChannel object where the global contamination rate has been set.  Information about the estimation is also stored in the slot <code>fit</code>
</p>


<h3>Note</h3>

<p>This function assumes that the channel contains multiple distinct cell types with different marker genes.  If you try and run it on a channel with very homogenous cells (e.g. a cell line, flow-sorted cells), you will likely get a warning, an error, and/or an extremely high contamination estimate.  In such circumstances your best option is usually to manually set the contamination to something reasonable.
</p>


<h3>See Also</h3>

<p>quickMarkers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Use less specific markers
scToy = autoEstCont(scToy,tfidfMin=0.8)
#Allow large contamination fractions to be allocated
scToy = autoEstCont(scToy,forceAccept=TRUE)
#Be quiet
scToy = autoEstCont(scToy,verbose=FALSE,doPlot=FALSE)
</code></pre>

<hr>
<h2 id='calculateContaminationFraction'>Calculate the contamination fraction</h2><span id='topic+calculateContaminationFraction'></span>

<h3>Description</h3>

<p>This function computes the contamination fraction using two user-provided bits of information.  Firstly, a list of sets of genes that can be biologically assumed to be absent in at least some cells in your data set.  For example, these might be haemoglobin genes or immunoglobulin genes, which should not be expressed outside of erythroyctes and antibody producing cells respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateContaminationFraction(
  sc,
  nonExpressedGeneList,
  useToEst,
  verbose = TRUE,
  forceAccept = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateContaminationFraction_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="calculateContaminationFraction_+3A_nonexpressedgenelist">nonExpressedGeneList</code></td>
<td>
<p>A list containing sets of genes which can be assumed to be non-expressed in a subset of cells (see details).</p>
</td></tr>
<tr><td><code id="calculateContaminationFraction_+3A_usetoest">useToEst</code></td>
<td>
<p>A boolean matrix of dimensions ncol(toc) x length(nonExpressedGeneList) indicating which gene-sets should not be assumed to be non-expressed in each cell.  Row names must correspond to the names of <code>nonExpressedGeneList</code>.  Usually produced by <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code>.</p>
</td></tr>
<tr><td><code id="calculateContaminationFraction_+3A_verbose">verbose</code></td>
<td>
<p>Print best estimate.</p>
</td></tr>
<tr><td><code id="calculateContaminationFraction_+3A_forceaccept">forceAccept</code></td>
<td>
<p>Passed to <code><a href="#topic+setContaminationFraction">setContaminationFraction</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Secondly, this function needs to know which cells definitely do not express the gene sets described above.  Continuing with the haemoglobin example, which are the erythrocytes that are producing haemoglobin mRNAs and which are non-erythrocytes that we can safely assume produce no such genes.  The assumption made is any expression from a gene set in cell marked as a &quot;non-expressor&quot; for that gene set, must be derived from the soup.  Therefore, the level of contamination present can be estimated from the amount of expression of these genes seen in these cells.
</p>
<p>Most often, the genesets are user supplied based on your knowledge of the experiment and the cells in which they are genuinely expressed is estimated using <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code>.  However, they can also be supplied directly if other information is available.
</p>
<p>Usually, there is very little variation in the contamination fraction within a channel and very little power to detect the contamination accurately at a single cell level.  As such, the default mode of operation simply estimates one value of the contamination fraction that is applied to all cells in a channel.
</p>
<p>The global model fits a simple Poisson glm to the aggregated count data across all cells.
</p>
<p>Finally, note that if you are not able to find a reliable set of genes to use for contamination estimation, or you do not trust the values produced, the contamination fraction can be manually set by the user using <code><a href="#topic+setContaminationFraction">setContaminationFraction</a></code>.
</p>


<h3>Value</h3>

<p>A modified version of <code>sc</code> with estimates of the contamination (rho) added to the metaData table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Common gene list in real world data
geneList = list(HB=c('HBB','HBA2'))
#Gene list appropriate to toy data
geneList = list(CD7 = 'CD7')
ute = estimateNonExpressingCells(scToy,geneList)
sc = calculateContaminationFraction(scToy,geneList,ute)
</code></pre>

<hr>
<h2 id='estimateNonExpressingCells'>Calculate which cells genuinely do not express a particular gene or set of genes</h2><span id='topic+estimateNonExpressingCells'></span>

<h3>Description</h3>

<p>Given a list of correlated genes (e.g. Haemoglobin genes, Immunoglobulin genes, etc.), make an attempt to estimate which cells genuinely do not express each of these gene sets in turn.  The central idea is that in cells that are not genuinely producing a class of mRNAs (such as haemoglobin genes), any observed expression of these genes must be due to ambient RNA contamination.  As such, if we can identify these cells, we can use the observed level of expression of these genes to estimate the level of contamination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNonExpressingCells(
  sc,
  nonExpressedGeneList,
  clusters = NULL,
  maximumContamination = 1,
  FDR = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateNonExpressingCells_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="estimateNonExpressingCells_+3A_nonexpressedgenelist">nonExpressedGeneList</code></td>
<td>
<p>A list containing sets of genes which will be used to estimate the contamination fraction.</p>
</td></tr>
<tr><td><code id="estimateNonExpressingCells_+3A_clusters">clusters</code></td>
<td>
<p>A named vector indicating how to cluster cells.  Names should be cell IDs, values cluster IDs.  If NULL, we will attempt to load it from sc$metaData$clusters.  If set to FALSE, each cell will be considered individually.</p>
</td></tr>
<tr><td><code id="estimateNonExpressingCells_+3A_maximumcontamination">maximumContamination</code></td>
<td>
<p>The maximum contamination fraction that you would reasonably expect.  The lower this value is set, the more aggressively cells are excluded from use in estimation.</p>
</td></tr>
<tr><td><code id="estimateNonExpressingCells_+3A_fdr">FDR</code></td>
<td>
<p>A Poisson test is used to identify cells to exclude, this is the false discovery rate it uses.  Higher FDR = more aggressive exclusion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ideal way to do this would be to have a prior annotation of your data indicating which cells are (for instance) red blood cells and genuinely expression haemoglobin genes, and which do not and so only express haemoglobin genes due to contamination.  If this is your circumstance, there is no need to run this function, you can instead pass a matrix encoding which cells are haemoglobin expressing and which are not to <code><a href="#topic+calculateContaminationFraction">calculateContaminationFraction</a></code> via the <code>useToEst</code> parameter.
</p>
<p>This function will use a conservative approach to excluding cells that it thinks may express one of your gene sets.  This is because falsely including a cell in the set of non-expressing cells may erroneously inflate your estimated contamination, whereas failing to include a genuine non-expressing cell in this set has no significant effect.
</p>
<p>To this end, this function will exclude any cluster of cells in which any cell is deemed to have genuine expression of a gene set.  Clustering of data is beyond the scope of this package, but can be performed by the user.  In the case of 10X data mapped using cellranger and loaded using <code><a href="#topic+load10X">load10X</a></code>, the cellranger graph based clustering is automatically loaded and used.
</p>
<p>To decide if a cell is genuinely expressing a set of genes, a Poisson test is used.  This tests whether the observed expression is greater than <code>maximumContamination</code> times the expected number of counts for a set of genes, if the cell were assumed to be derived wholly from the background.  This process can be made less conservative (i.e., excluding fewer cells/clusters) by either decreasing the value of the maximum contamination the user believes is plausible (<code>maximumContamination</code>) or making the significance threshold for the test more strict (by reducing <code>FDR</code>).
</p>


<h3>Value</h3>

<p>A matrix indicating which cells to be used to estimate contamination for each set of genes.  Typically passed to the <code>useToEst</code> parameter of <code><a href="#topic+calculateContaminationFraction">calculateContaminationFraction</a></code> or <code><a href="#topic+plotMarkerMap">plotMarkerMap</a></code>.
</p>


<h3>See Also</h3>

<p>calculateContaminationFraction plotMarkerMap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Common gene list in real world data
geneList = list(HB=c('HBB','HBA2'))
#Gene list appropriate to toy data
geneList = list(CD7 = 'CD7')
ute = estimateNonExpressingCells(scToy,geneList)
</code></pre>

<hr>
<h2 id='estimateSoup'>Get expression profile of soup</h2><span id='topic+estimateSoup'></span>

<h3>Description</h3>

<p>This is usually called by <code><a href="#topic+SoupChannel">SoupChannel</a></code>, rather than directly by the user.  Uses the empty droplets in the range provided to calculate the expression profile of the soup under the assumption that these droplets only contain background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSoup(sc, soupRange = c(0, 100), keepDroplets = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateSoup_+3A_sc">sc</code></td>
<td>
<p>A <code>SoupChannel</code> object.</p>
</td></tr>
<tr><td><code id="estimateSoup_+3A_souprange">soupRange</code></td>
<td>
<p>Droplets with total UMI count in this range (excluding endpoints) are used to estimate soup.</p>
</td></tr>
<tr><td><code id="estimateSoup_+3A_keepdroplets">keepDroplets</code></td>
<td>
<p>Storing the full table of counts for all droplets uses a lot of space and is really only used to estimate the soup profile.  Therefore, it is dropped after the soup profile has been estimated unless this is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>sc</code> with an extra <code>soupProfile</code> entry containing a data.frame with the soup profile and confidence limits for all genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load droplet and count tables
tod = Seurat::Read10X(system.file('extdata','toyData','raw_gene_bc_matrices','GRCh38',
                                  package='SoupX'))
toc = Seurat::Read10X(system.file('extdata','toyData','filtered_gene_bc_matrices','GRCh38',
                                  package='SoupX'))
#Suppress calculation of soup profile automatically on load
sc = SoupChannel(tod,toc,calcSoupProfile=FALSE)
#Retain table of droplets
sc = estimateSoup(sc,keepDroplets=TRUE)
#Or use non-default values
sc = estimateSoup(sc,soupRange=c(60,100))
</code></pre>

<hr>
<h2 id='expandClusters'>Expands soup counts calculated at the cluster level to the cell level</h2><span id='topic+expandClusters'></span>

<h3>Description</h3>

<p>Given a clustering of cells and soup counts calculated for each of those clusters, determines a most likely allocation of soup counts at the cell level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandClusters(clustSoupCnts, cellObsCnts, clusters, cellWeights, verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandClusters_+3A_clustsoupcnts">clustSoupCnts</code></td>
<td>
<p>Matrix of genes (rows) by clusters (columns) where counts are number of soup counts for that gene/cluster combination.</p>
</td></tr>
<tr><td><code id="expandClusters_+3A_cellobscnts">cellObsCnts</code></td>
<td>
<p>Matrix of genes (rows) by cells (columns) giving the observed counts</p>
</td></tr>
<tr><td><code id="expandClusters_+3A_clusters">clusters</code></td>
<td>
<p>Mapping from cells to clusters.</p>
</td></tr>
<tr><td><code id="expandClusters_+3A_cellweights">cellWeights</code></td>
<td>
<p>Weighting to give to each cell when distributing counts.  This would usually be set to the number of expected soup counts for each cell.</p>
</td></tr>
<tr><td><code id="expandClusters_+3A_verbose">verbose</code></td>
<td>
<p>Integer giving level of verbosity.  0 = silence, 1 = Basic information, 2 = Very chatty, 3 = Debug.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of genes (rows) by cells (columns) giving the number of soup counts estimated for each cell.  Non-integer values possible.
</p>

<hr>
<h2 id='initProgBar'>Create Seurat style progress bar</h2><span id='topic+initProgBar'></span>

<h3>Description</h3>

<p>Creates progress bar that won't ruin log files and shows progress towards 100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initProgBar(min, max, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initProgBar_+3A_min">min</code></td>
<td>
<p>Minimum value of parameter.</p>
</td></tr>
<tr><td><code id="initProgBar_+3A_max">max</code></td>
<td>
<p>Maximum value of parameter.</p>
</td></tr>
<tr><td><code id="initProgBar_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A txtProgressBar object to use updating progress.
</p>

<hr>
<h2 id='load10X'>Load a collection of 10X data-sets</h2><span id='topic+load10X'></span>

<h3>Description</h3>

<p>Loads unfiltered 10X data from each data-set and identifies which droplets are cells using the cellranger defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load10X(
  dataDir,
  cellIDs = NULL,
  channelName = NULL,
  readArgs = list(),
  includeFeatures = c("Gene Expression"),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load10X_+3A_datadir">dataDir</code></td>
<td>
<p>Top level cellranger output directory (the directory that contains the <code>raw_gene_bc_matrices</code> folder).</p>
</td></tr>
<tr><td><code id="load10X_+3A_cellids">cellIDs</code></td>
<td>
<p>Barcodes of droplets that contain cells.  If NULL, use the default cellranger set.</p>
</td></tr>
<tr><td><code id="load10X_+3A_channelname">channelName</code></td>
<td>
<p>The name of the channel to store.  If NULL set to either <code>names(dataDir)</code> or <code>dataDir</code> is no name is set.</p>
</td></tr>
<tr><td><code id="load10X_+3A_readargs">readArgs</code></td>
<td>
<p>A list of extra parameters passed to <code>Seurat::Read10X</code>.</p>
</td></tr>
<tr><td><code id="load10X_+3A_includefeatures">includeFeatures</code></td>
<td>
<p>If multiple feature types are present, keep only the types mentioned here and collapse to a single matrix.</p>
</td></tr>
<tr><td><code id="load10X_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose?</p>
</td></tr>
<tr><td><code id="load10X_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>SoupChannel</code> construction function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoupChannel object containing the count tables for the 10X dataset.
</p>


<h3>See Also</h3>

<p>SoupChannel estimateSoup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc = load10X(system.file('extdata','toyData',package='SoupX'))
</code></pre>

<hr>
<h2 id='PBMC_metaData'>PBMC 4K meta data</h2><span id='topic+PBMC_metaData'></span>

<h3>Description</h3>

<p>Collection of bits of meta data relating to the 10X PBMC 4K data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PBMC_metaData)
</code></pre>


<h3>Format</h3>

<p><code>PBMC_metaData</code> is a data.frame with 4 columns: RD1, RD2, Cluster, and Annotation.
</p>


<h3>Details</h3>

<p>This data set pertains to the 10X demonstration PBMC 4K data and includes metadata about it in the <code>data.frame</code> named <code>PBMC_metaData</code>.
</p>
<p><code>PBMC_metaData</code> was created using Seurat (v2) to calculate a tSNE representation of the data and cluster cells with these commands.
</p>

<ul>
<li> <p><code>set.seed(1)</code>
</p>
</li>
<li> <p><code>srat = CreateSeuratObject(sc$toc)</code>
</p>
</li>
<li> <p><code>srat = NormalizeData(srat)</code>
</p>
</li>
<li> <p><code>srat = ScaleData(srat)</code>
</p>
</li>
<li> <p><code>srat = FindVariableGenes(srat)</code>
</p>
</li>
<li> <p><code>srat = RunPCA(srat,pcs.compute=30)</code>
</p>
</li>
<li> <p><code>srat = RunTSNE(srat,dims.use=seq(30))</code>
</p>
</li>
<li> <p><code>srat = FindClusters(srat,dims.use=seq(30),resolution=1)</code>
</p>
</li>
<li> <p><code>PBMC_metaData = as.data.frame(srat@dr$tsne@cell.embeddings)</code>
</p>
</li>
<li> <p><code>colnames(PBMC_metaData) = c('RD1','RD2')</code>
</p>
</li>
<li> <p><code>PBMC_metaData$Cluster = factor(srat@meta.data[rownames(PBMC_metaData),'res.1'])</code>
</p>
</li>
<li> <p><code>PBMC_metaData$Annotation = factor(c('7'='B','4'='B','1'='T_CD4','2'='T_CD4','3'='T_CD8','5'='T_CD8','6'='NK','8'='NK','0'='MNP','9'='MNP','10'='MNP','11'='?')[as.character(PBMC_metaData$Cluster)])</code>
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k">https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k</a>
</p>

<hr>
<h2 id='PBMC_sc'>SoupChannel from PBMC data</h2><span id='topic+PBMC_sc'></span>

<h3>Description</h3>

<p><code><a href="#topic+SoupChannel">SoupChannel</a></code> created from 10X demonstration PBMC 4k data.  The cells have been sub-sampled by a factor of 2 to reduce file size of package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PBMC_sc)
</code></pre>


<h3>Format</h3>

<p><code>PBMC_sc</code> is a <code>SoupChannel</code> object with 33,694 genes and 2,170 cells.
</p>


<h3>Details</h3>

<p><code>PBMC_sc</code> was created by running the following commands.
</p>

<ul>
<li> <p><code>set.seed(1137)</code>
</p>
</li>
<li> <p><code>tmpDir = tempdir(check=TRUE)</code>
</p>
</li>
<li> <p><code>download.file('http://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz',destfile=file.path(tmpDir,'tod.tar.gz'))</code>
</p>
</li>
<li> <p><code>download.file('http://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_filtered_gene_bc_matrices.tar.gz',destfile=file.path(tmpDir,'toc.tar.gz'))</code>
</p>
</li>
<li> <p><code>untar(file.path(tmpDir,'tod.tar.gz'),exdir=tmpDir)</code>
</p>
</li>
<li> <p><code>untar(file.path(tmpDir,'toc.tar.gz'),exdir=tmpDir)</code>
</p>
</li>
<li> <p><code>library(SoupX)</code>
</p>
</li>
<li> <p><code>PBMC_sc = load10X(tmpDir,calcSoupProfile=FALSE)</code>
</p>
</li>
<li> <p><code>PBMC_sc = SoupChannel(PBMC_sc$tod,PBMC_sc$toc[,sample(ncol(PBMC_sc$toc),round(ncol(PBMC_sc$toc)*0.5))])</code>
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k">https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k</a>
</p>

<hr>
<h2 id='plotChangeMap'>Plot maps comparing corrected/raw expression</h2><span id='topic+plotChangeMap'></span>

<h3>Description</h3>

<p>Given some reduced dimensional representation of the data (such as UMAP or tSNE) that has been calculated however you would like, this provides a way to visualise how the expression of a geneSet changes after soup correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotChangeMap(
  sc,
  cleanedMatrix,
  geneSet,
  DR,
  dataType = c("soupFrac", "binary", "counts"),
  logData = FALSE,
  pointSize = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotChangeMap_+3A_sc">sc</code></td>
<td>
<p>SoupChannel object.</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_cleanedmatrix">cleanedMatrix</code></td>
<td>
<p>A cleaned matrix to compare against the raw one.  Usually the output of <code><a href="#topic+adjustCounts">adjustCounts</a></code>.</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_geneset">geneSet</code></td>
<td>
<p>A vector with the names of the genes to aggregate and plot evidence for.</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_dr">DR</code></td>
<td>
<p>A data.frame, with rows named by unique cell IDs (i.e., &lt;ChannelName&gt;_&lt;Barcode&gt;) the first two columns of which give the coordinates of each cell in some reduced dimension representation of the data.</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_datatype">dataType</code></td>
<td>
<p>How should data be represented.  Binary sets each cell to expressed or not, counts converts everything to counts, soupFrac plots the fraction of the observed counts that are identified as contamination (i.e., (old-new)/old) for each cell and is the default.</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_logdata">logData</code></td>
<td>
<p>Should we log the thing we plot?</p>
</td></tr>
<tr><td><code id="plotChangeMap_+3A_pointsize">pointSize</code></td>
<td>
<p>Size of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 containing the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out = adjustCounts(scToy)
gg = plotChangeMap(scToy,out,'S100A9')
</code></pre>

<hr>
<h2 id='plotMarkerDistribution'>Plots the distribution of the observed to expected expression for marker genes</h2><span id='topic+plotMarkerDistribution'></span>

<h3>Description</h3>

<p>If each cell were made up purely of background reads, the expression fraction would equal that of the soup.  This plot compares this expectation of pure background to the observed expression fraction in each cell, for each of the groups of genes in <code>nonExpressedGeneList</code>.  For each group of genes, the distribution of this ratio is plotted across all cells.  A value significantly greater than 1 (0 on log scale) can only be obtained if some of the genes in each group are genuinely expressed by the cell.  That is, the assumption that the cell is pure background does not hold for that gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMarkerDistribution(
  sc,
  nonExpressedGeneList,
  maxCells = 150,
  tfidfMin = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMarkerDistribution_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="plotMarkerDistribution_+3A_nonexpressedgenelist">nonExpressedGeneList</code></td>
<td>
<p>Which sets of genes to use to estimate soup (see <code><a href="#topic+calculateContaminationFraction">calculateContaminationFraction</a></code>).</p>
</td></tr>
<tr><td><code id="plotMarkerDistribution_+3A_maxcells">maxCells</code></td>
<td>
<p>Randomly plot only this many cells to prevent over-crowding.</p>
</td></tr>
<tr><td><code id="plotMarkerDistribution_+3A_tfidfmin">tfidfMin</code></td>
<td>
<p>Minimum specificity cut-off used if finding marker genes (see <code><a href="#topic+quickMarkers">quickMarkers</a></code>).</p>
</td></tr>
<tr><td><code id="plotMarkerDistribution_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot is a useful diagnostic for the assumption that a list of genes is non-expressed in most cell types.  For non-expressed cells, the ratio should cluster around the contamination fraction, while for expressed cells it should be elevated.  The most useful non-expressed gene sets are those for which the genes are either strongly expressed, or not expressed at all.  Such groups of genes will show up in this plot as a bimodal distribution, with one mode containing the cells that do not express these genes around the contamination fraction for this channel and another around a value at some value equal to or greater than 0 (1 on non-log scale) for the expressed cells.
</p>
<p>The red line shows the global estimate of the contamination for each group of markers.  This is usually lower than the low mode of the distribution as there will typically be a non-negligible number of cells with 0 observed counts (and hence -infinity log ratio).
</p>
<p>If <code>nonExpressedGeneList</code> is missing, this function will try and find genes that are very specific to different clusters, as these are often the most useful in estimating the contamination fraction.   This is meant only as a heuristic, which can hopefully provide some inspiration as to a class of genes to use to estimation the contamination for your experiment.  Please do **NOT** blindly use the top N genes found in this way to estimate the contamination.  That is, do not feed this list of genes into <code><a href="#topic+calculateContaminationFraction">calculateContaminationFraction</a></code> without any manual consideration or filtering as this *will over-estimate your contamination* (often by a large amount).  For this reason, these gene names are not returned by the function.
</p>


<h3>Value</h3>

<p>A ggplot2 object containing the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg = plotMarkerDistribution(scToy,list(CD7='CD7',LTB='LTB'))
</code></pre>

<hr>
<h2 id='plotMarkerMap'>Plot ratio of observed to expected counts on reduced dimension map</h2><span id='topic+plotMarkerMap'></span>

<h3>Description</h3>

<p>Given some reduced dimensional representation of the data (such as UMAP or tSNE) that has been calculated however you would like, this provides a way to visualise how likely a set of genes are to be soup derived on that map.  That is, given a set of genes, this function calculates how many counts would be expected if that droplet were nothing but soup and compares that to the observed count.  This is done via a log2 ratio of the two values.  A Poisson test is performed and points that have a statistically significant enrichment over the background (at 5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMarkerMap(
  sc,
  geneSet,
  DR,
  ratLims = c(-2, 2),
  FDR = 0.05,
  useToEst = NULL,
  pointSize = 2,
  pointShape = 21,
  pointStroke = 0.5,
  naPointSize = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMarkerMap_+3A_sc">sc</code></td>
<td>
<p>SoupChannel object.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_geneset">geneSet</code></td>
<td>
<p>A vector with the names of the genes to aggregate and plot evidence for.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_dr">DR</code></td>
<td>
<p>A data.frame, with rows named by unique cell IDs (i.e., &lt;ChannelName&gt;_&lt;Barcode&gt;) the first two columns of which give the coordinates of each cell in some reduced dimension representation of the data.  Try and fetch automatically if missing.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_ratlims">ratLims</code></td>
<td>
<p>Truncate log ratios at these values.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_fdr">FDR</code></td>
<td>
<p>False Discovery Rate for statistical test of enrichment over background.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_usetoest">useToEst</code></td>
<td>
<p>A vector (usually obtained from <code><a href="#topic+estimateNonExpressingCells">estimateNonExpressingCells</a></code>), that will be used to mark cells instead of the usual Poisson test.</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_pointsize">pointSize</code></td>
<td>
<p>Size of points</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_pointshape">pointShape</code></td>
<td>
<p>Shape of points</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_pointstroke">pointStroke</code></td>
<td>
<p>Stroke size for points</p>
</td></tr>
<tr><td><code id="plotMarkerMap_+3A_napointsize">naPointSize</code></td>
<td>
<p>Point size for NAs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 containing the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg = plotMarkerMap(scToy,'CD7')
</code></pre>

<hr>
<h2 id='plotSoupCorrelation'>Plot correlation of expression profiles of soup and aggregated cells</h2><span id='topic+plotSoupCorrelation'></span>

<h3>Description</h3>

<p>Calculates an expression profile by aggregating counts across all cells and plots this (on a log10 scale) against the expression profile of the soup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSoupCorrelation(sc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSoupCorrelation_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object containing the plot.
</p>

<hr>
<h2 id='print.SoupChannel'>Print method for SoupChannel</h2><span id='topic+print.SoupChannel'></span>

<h3>Description</h3>

<p>Prints a summary of a SoupChannel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SoupChannel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SoupChannel_+3A_x">x</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="print.SoupChannel_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.  Prints message to console.
</p>

<hr>
<h2 id='quickMarkers'>Gets top N markers for each cluster</h2><span id='topic+quickMarkers'></span>

<h3>Description</h3>

<p>Uses tf-idf ordering to get the top N markers of each cluster.  For each cluster, either the top N or all genes passing the hypergeometric test with the FDR specified, whichever list is smallest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickMarkers(toc, clusters, N = 10, FDR = 0.01, expressCut = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickMarkers_+3A_toc">toc</code></td>
<td>
<p>Table of counts.  Must be a sparse matrix.</p>
</td></tr>
<tr><td><code id="quickMarkers_+3A_clusters">clusters</code></td>
<td>
<p>Vector of length <code>ncol(toc)</code> giving cluster membership.</p>
</td></tr>
<tr><td><code id="quickMarkers_+3A_n">N</code></td>
<td>
<p>Number of marker genes to return per cluster.</p>
</td></tr>
<tr><td><code id="quickMarkers_+3A_fdr">FDR</code></td>
<td>
<p>False discover rate to use.</p>
</td></tr>
<tr><td><code id="quickMarkers_+3A_expresscut">expressCut</code></td>
<td>
<p>Value above which a gene is considered expressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Term Frequency - Inverse Document Frequency is used in natural language processing to identify terms specific to documents.  This function uses the same idea to order genes within a group by how predictive of that group they are.  The main advantage of this is that it is extremely fast and gives reasonable results.
</p>
<p>To do this, gene expression is binarised in each cell so each cell is either considered to express or not each gene.  That is, we replace the counts with <code>toc &gt; zeroCut</code>.  The frequency with which a gene is expressed within the target group is compared to the global frequency to calculate the tf-idf score.  We also calculate a multiple hypothesis corrected p-value based on a hypergeometric test, but this is extremely permissive.
</p>


<h3>Value</h3>

<p>data.frame with top N markers (or all that pass the hypergeometric test) and their statistics for each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate markers of clusters in toy data
mrks = quickMarkers(scToy$toc,scToy$metaData$clusters)
## Not run: 
#Calculate markers from Seurat (v3) object
mrks = quickMarkers(srat@assays$RNA@count,srat@active.ident)

## End(Not run)
</code></pre>

<hr>
<h2 id='scToy'>Toy SoupChanel object</h2><span id='topic+scToy'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+SoupChannel">SoupChannel</a></code> object created from the toy data used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scToy)
</code></pre>


<h3>Format</h3>

<p><code>scToy</code> is a <code>SoupChannel</code> object.
</p>


<h3>Details</h3>

<p>The toy data is created from a modified version of the extremely reduced <code>Seurat</code> <code>pbmc_small</code> dataset.  It includes clusters, tSNE coordinates and a flat estimate of 0.1 contamination.  It includes data for only 226 genes and 62 cells and should not be used for anything other than testing functions as it is not representative of real data in any way.
</p>

<hr>
<h2 id='setClusters'>Sets clustering for SoupChannel</h2><span id='topic+setClusters'></span>

<h3>Description</h3>

<p>Adds or updates clustering information to meta-data table in SoupChannel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setClusters(sc, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setClusters_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="setClusters_+3A_clusters">clusters</code></td>
<td>
<p>A named vector, where entries are the cluster IDs and names are cellIDs.  If no names are provided, the order is assumed to match the order in <code>sc$metaData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated SoupChannel object with clustering information stored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc = load10X(system.file('extdata','toyData',package='SoupX'))
mDat = read.table(system.file('extdata','toyData','metaData.tsv',package='SoupX'),sep='\t')
sc = setClusters(sc,mDat$res.1)
</code></pre>

<hr>
<h2 id='setContaminationFraction'>Manually set contamination fraction</h2><span id='topic+setContaminationFraction'></span>

<h3>Description</h3>

<p>Manually specify the contamination fraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setContaminationFraction(sc, contFrac, forceAccept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setContaminationFraction_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="setContaminationFraction_+3A_contfrac">contFrac</code></td>
<td>
<p>The contamination fraction.  Either a constant, in which case the same value is used for all cells, or a named vector, in which case the value is set for each cell.</p>
</td></tr>
<tr><td><code id="setContaminationFraction_+3A_forceaccept">forceAccept</code></td>
<td>
<p>A warning or error is usually returned for extremely high contamination fractions.  Setting this to TRUE will turn these into messages and proceed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified SoupChannel object for which the contamination (rho) has been set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc = load10X(system.file('extdata','toyData',package='SoupX'))
sc = setContaminationFraction(sc,0.1)
</code></pre>

<hr>
<h2 id='setDR'>Manually set dimension reduction for a channel</h2><span id='topic+setDR'></span>

<h3>Description</h3>

<p>Manually specify the dimension reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDR(sc, DR, reductName = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDR_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="setDR_+3A_dr">DR</code></td>
<td>
<p>The dimension reduction coordinates (e.g., tSNE).  This must be a data.frame, with two columns giving the two dimension reduction coordinates.  The data.frame must either have row names matching the row names of sc$metaData, or be ordered in the same order as sc$metaData.</p>
</td></tr>
<tr><td><code id="setDR_+3A_reductname">reductName</code></td>
<td>
<p>What to name the reduction (defaults to column names provided).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified SoupChannel object for which the dimension reduction has been set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc = load10X(system.file('extdata','toyData',package='SoupX'))
mDat = read.table(system.file('extdata','toyData','metaData.tsv',package='SoupX'),sep='\t')
sc = setDR(sc,mDat[,c('tSNE_1','tSNE_2')])
</code></pre>

<hr>
<h2 id='setSoupProfile'>Set soup profile</h2><span id='topic+setSoupProfile'></span>

<h3>Description</h3>

<p>Manually sets or updates the soup profile for a SoupChannel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSoupProfile(sc, soupProfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSoupProfile_+3A_sc">sc</code></td>
<td>
<p>A SoupChannel object.</p>
</td></tr>
<tr><td><code id="setSoupProfile_+3A_soupprofile">soupProfile</code></td>
<td>
<p>A data.frame with columns <code>est</code> containing the fraction of soup for each gene, <code>counts</code> containing the total counts for each gene and with row names corresponding to the row names of <code>sc$toc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated SoupChannel object with the soup profile set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Suppose only table of counts is available
toc = Seurat::Read10X(system.file('extdata','toyData','filtered_gene_bc_matrices','GRCh38',
                                  package='SoupX'))
#Suppress calculating soup profile automatically
sc = SoupChannel(toc,toc,calcSoupProfile=FALSE)
#And add manually
rowSums = Matrix::rowSums
soupProf = data.frame(row.names = rownames(toc),est=rowSums(toc)/sum(toc),counts=rowSums(toc))
sc = setSoupProfile(sc,soupProf)
</code></pre>

<hr>
<h2 id='SoupChannel'>Construct a SoupChannel object</h2><span id='topic+SoupChannel'></span>

<h3>Description</h3>

<p>Creates a SoupChannel object that contains everything related to the soup estimation of a single channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoupChannel(tod, toc, metaData = NULL, calcSoupProfile = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SoupChannel_+3A_tod">tod</code></td>
<td>
<p>Table of droplets.  A matrix with columns being each droplet and rows each gene.</p>
</td></tr>
<tr><td><code id="SoupChannel_+3A_toc">toc</code></td>
<td>
<p>Table of counts.  Just those columns of <code>tod</code> that contain cells.</p>
</td></tr>
<tr><td><code id="SoupChannel_+3A_metadata">metaData</code></td>
<td>
<p>Meta data pertaining to the cells.  Optional.  Must be a data-frame with rownames equal to column names of <code>toc</code>.</p>
</td></tr>
<tr><td><code id="SoupChannel_+3A_calcsoupprofile">calcSoupProfile</code></td>
<td>
<p>By default, the soup profile is calculated using <code><a href="#topic+estimateSoup">estimateSoup</a></code> with default values.  If you want to do something other than the defaults, set this to <code>FALSE</code> and call <code><a href="#topic+estimateSoup">estimateSoup</a></code> manually.</p>
</td></tr>
<tr><td><code id="SoupChannel_+3A_...">...</code></td>
<td>
<p>Any other named parameters to store.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoupChannel object.
</p>


<h3>See Also</h3>

<p>SoupChannelList estimateSoup setSoupProfile setClusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load droplet and count tables
tod = Seurat::Read10X(system.file('extdata','toyData','raw_gene_bc_matrices','GRCh38',
                                  package='SoupX'))
toc = Seurat::Read10X(system.file('extdata','toyData','filtered_gene_bc_matrices','GRCh38',
                                  package='SoupX'))
#Default calculates soup profile
sc = SoupChannel(tod,toc)
names(sc)
#This can be suppressed
sc = SoupChannel(tod,toc,calcSoupProfile=FALSE)
names(sc)
</code></pre>

<hr>
<h2 id='SoupX'>SoupX: Profile, quantify and remove ambient RNA expression from droplet based RNA-seq</h2><span id='topic+SoupX'></span>

<h3>Description</h3>

<p>This package implements the method described in REF.  First a few notes about nomenclature:
soup - Used a shorthand to refer to the ambient RNA which is contained in the input solution to droplet based RNA-seq experiments and ends up being sequenced along with the cell endogenous RNAs that the experiment is aiming to quantify.
channel - This refers to a single run input into a droplet based sequencing platform.  For Chromium 10X 3' sequencing there are currently 8 &quot;channels&quot; per run of the instrument.  Because the profile of the soup depends on the input solution, this is the minimal unit on which the soup should be estimated and subtracted.
</p>


<h3>Details</h3>

<p>The essential step in performing background correction is deciding which genes are not expressed in a reasonable fraction of cells.  This is because SoupX estimates the contamination fraction by comparing the expression of these non-expressed genes in droplets containing cells to the soup defined from empty droplets.  For solid tissue, the set of Haemoglobin genes usually works well.  The key properties a gene should have are:
- it should be easy to identify when it is truly expressed (i.e., when it's expressed, it should be highly expressed) 
- it should be highly specific to a certain cell type or group of cell types so that when the expression level is low, you can be confident that the expression is coming from the soup and not a very low level of expression from the cell
</p>
<p>Spike-in RNAs are the best case scenario.  In the case where you do not have spike-ins and haemoglobin genes are not viable estimators, the user should begin by using the <a href="#topic+plotMarkerDistribution">plotMarkerDistribution</a> function to plot those genes with bi-modal distributions that have a pattern of expression across cells that is consistent with high cell-type specificity.  The user should then select a set of genes that can be used for estimation from this list.  One or two high quality genes is usually sufficient to obtain a good estimate for the average contamination level of a channel.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
