<!DOCTYPE html><html lang="en"><head><title>Help for package locpol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {locpol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bivNPest'><p> Bivariate Local estimation.</p></a></li>
<li><a href='#compKernVals'><p>Compute kernel values.</p></a></li>
<li><a href='#denCVBwSelC'><p> CV bandwidth selector for density</p></a></li>
<li><a href='#equivKernel'><p> Equivalent Kernel.</p></a></li>
<li><a href='#KernelChars'><p>Kernel characteristics</p></a></li>
<li><a href='#kernelCte'><p> Kernel Constants used in Bandwidth Selection.</p></a></li>
<li><a href='#Kernels'><p> Kernels.</p></a></li>
<li><a href='#locCteWeights'><p> Local Polynomial Weights</p></a></li>
<li><a href='#locpol'><p> Local Polynomial estimation.</p></a></li>
<li><a href='#locpolSmoothers'><p> Local Polynomial estimation.</p></a></li>
<li><a href='#pluginBw'><p> Plugin Bandwidth selector.</p></a></li>
<li><a href='#PRDenEstC'><p> Parzen&ndash;Rosenblatt denstiy estimator.</p></a></li>
<li><a href='#regCVBwSelC'><p> Cross Validation Bandwidth selector.</p></a></li>
<li><a href='#selKernel'><p> Kernel selection.</p></a></li>
<li><a href='#simpleSmoothers'><p> Simple smoother</p></a></li>
<li><a href='#thumbBw'><p> Rule of thumb for bandwidth selection.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Local Polynomial Regression</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes local polynomial estimators for 
  the regression and also density. It comprises several 
  different utilities to handle kernel estimators.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0), graphics, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-28 18:26:23 UTC; bquast</td>
</tr>
<tr>
<td>Author:</td>
<td>Jorge Luis Ojeda Cabrera [aut, cre],
  Bastiaan Quast <a href="https://orcid.org/0000-0002-2951-3577"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jorge Luis Ojeda Cabrera &lt;jojeda@unizar.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-29 07:35:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='bivNPest'> Bivariate Local estimation. </h2><span id='topic+bivDens'></span><span id='topic+bivReg'></span><span id='topic+plot.bivNpEst'></span><span id='topic+predict.bivNpEst'></span><span id='topic+epaK2d'></span><span id='topic+gauK2d'></span><span id='topic+plotBivNpEstOpts'></span><span id='topic+mayBeBwSel'></span>

<h3>Description</h3>

<p>Simple bivariate Local density and regression estimation with weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    bivDens(X,weig,K,H)
    bivReg(X,Y,weig,K,H)
    ## S3 method for class 'bivNpEst'
predict(object,newdata,...)
    ## S3 method for class 'bivNpEst'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivNPest_+3A_x">X</code></td>
<td>
<p> Covariate or independent data, should be a <code>data.frame</code> or <code>matrix</code>, whose two first two columns are used. </p>
</td></tr>
<tr><td><code id="bivNPest_+3A_y">Y</code></td>
<td>
<p> Response data, a <code>vector</code></p>
</td></tr></table>
<p>. 	
</p>
<table role = "presentation">
<tr><td><code id="bivNPest_+3A_weig">weig</code></td>
<td>
<p> Vector of weigths for each observations. </p>
</td></tr>	
<tr><td><code id="bivNPest_+3A_k">K</code></td>
<td>
<p> Bivariate kernel function as <code>bivDens</code> and <code>bivReg</code>. </p>
</td></tr>	
<tr><td><code id="bivNPest_+3A_h">H</code></td>
<td>
<p> Bandwidth matrix. Its default value is determined by <code>mayBeBwSel</code>.</p>
</td></tr>
<tr><td><code id="bivNPest_+3A_object">object</code>, <code id="bivNPest_+3A_x">x</code></td>
<td>
<p><code>bivNpEst</code> class objects, those returned by  <code>bivDens</code> and <code>bivReg</code> functions.</p>
</td></tr>
<tr><td><code id="bivNPest_+3A_newdata">newdata</code></td>
<td>
<p>Data, should be a <code>data.frame</code> where the density or regressions is going to be predicted.</p>
</td></tr>
<tr><td><code id="bivNPest_+3A_...">...</code></td>
<td>
<p>Further graphical parameters. These parameters should agree with those in <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>bivDens</code> and <code>bivReg</code> provide a very basic 
interface that allows bivariate local estimation with weights. It implements 
basic kernel density estimator and Nadaraya&ndash;Watson estimator for bivariate 
data. Very simple interface methods allow the prediction and plotting of 
these estimators.
</p>
<p>The only bivariate kernels provided are <code>epaK2d</code> and <code>gauK2d</code>.
New ones can be added in the same way as functions with a vector of length 2.
</p>
<p>The default bandwidth selector (see <code>mayBeBwSel</code>) that has been 
provided <em>is not optimal or good in any sense</em>. It has been added as 
a simple way to provide an easy, fast and simple way to be able to use the 
estimators. 
</p>
<p>The graphical parameters allowed for <code>...</code> in <code>plot(x,...)</code> are those that appears in the function <a href="graphics.html#topic+persp">persp</a>. The list <code>plotBivNpEstOpts</code> provide a default for some of these graphical parameters.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p> Covariate data. </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p> Response data </p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p> Bandwidth matrix </p>
</td></tr>
<tr><td><code>estFun</code></td>
<td>
<p>Estimator function. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n &lt;- 100
  d &lt;- data.frame(x=rexp(n,rate=1/2),y=rnorm(n))
  ## x is a length-biased version of an exp. dist. with rate 1.
  dDen &lt;- bivDens(d,weig=1/d$x)
  plot(dDen,r=5)
  d &lt;- data.frame(X1=runif(n),X2=runif(n))
  d$Y &lt;-  exp(10*d$X1+d$X2^2) 
  dDen &lt;- bivDens(d[,c("X1","X2")])
  plot(dDen,r=5)
  dReg &lt;- bivReg(d[,c("X1","X2")],d$Y)
  plot(dReg,r=5)
  plot(dReg,r=5,phi=20,theta=40)
</code></pre>

<hr>
<h2 id='compKernVals'>Compute kernel values.</h2><span id='topic+computeRK'></span><span id='topic+computeK4'></span><span id='topic+computeMu'></span><span id='topic+computeMu0'></span><span id='topic+Kconvol'></span><span id='topic+Compute+20kernel+20values'></span>

<h3>Description</h3>

<p>Some <span class="rlang"><b>R</b></span> code provided to compute kernel related values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	computeRK(kernel, lower=dom(kernel)[[1]], upper=dom(kernel)[[2]],
			subdivisions = 25)
	computeK4(kernel, lower=dom(kernel)[[1]], upper=dom(kernel)[[2]],
			subdivisions = 25)
	computeMu(i, kernel, lower=dom(kernel)[[1]], upper=dom(kernel)[[2]],
			subdivisions = 25)
	computeMu0(kernel, lower=dom(kernel)[[1]], upper=dom(kernel)[[2]],
			subdivisions = 25)
	Kconvol(kernel,lower=dom(kernel)[[1]],upper=dom(kernel)[[2]],
			subdivisions = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compKernVals_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="compKernVals_+3A_i">i</code></td>
<td>
<p> Order of kernel moment to compute </p>
</td></tr>
<tr><td><code id="compKernVals_+3A_lower">lower</code>, <code id="compKernVals_+3A_upper">upper</code></td>
<td>
<p> Integration limits. </p>
</td></tr>
<tr><td><code id="compKernVals_+3A_subdivisions">subdivisions</code></td>
<td>
<p> the maximum number of subintervals. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions uses function <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value returning:
</p>
<table role = "presentation">
<tr><td><code>computeK4</code></td>
<td>
<p>The fourth order autoconvolution of <code>K</code>.</p>
</td></tr>
<tr><td><code>computeRK</code></td>
<td>
<p>The second order autoconvolution of <code>K</code>.</p>
</td></tr>
<tr><td><code>computeMu0</code></td>
<td>
<p>The integral of <code>K</code>.</p>
</td></tr>
<tr><td><code>computeMu2</code></td>
<td>
<p>The second order moment of <code>K</code>.</p>
</td></tr>
<tr><td><code>computeMu</code></td>
<td>
<p>The <code class="reqn">i</code>-th order moment of <code>K</code>.</p>
</td></tr>
<tr><td><code>Kconvol</code></td>
<td>
<p>The autoconvolution of <code>K</code>.</p>
</td></tr>
</table>
<p>These functions are implemented by means of <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera. </p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+RK">RK</a></code>, <a href="#topic+Kernel+20characteristics">Kernel characteristics</a>, <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	##	Note that lower and upper params are set in the definition to
	##	use 'dom()' function.
	g &lt;- function(kernels)
	{
		mu0 &lt;- sapply(kernels,function(x) computeMu0(x,))
		mu0.ok &lt;- sapply(kernels,mu0K)
		mu2 &lt;- sapply(kernels,function(x) computeMu(2,x))
		mu2.ok &lt;- sapply(kernels,mu2K)
		Rk.ok &lt;- sapply(kernels,RK)
		RK &lt;- sapply(kernels,function(x) computeRK(x))
		K4 &lt;- sapply(kernels,function(x) computeK4(x))
		res &lt;- data.frame(mu0,mu0.ok,mu2,mu2.ok,RK,Rk.ok,K4)
		res
	}
	g(kernels=c(EpaK,gaussK,TriweigK,TrianK))
</code></pre>

<hr>
<h2 id='denCVBwSelC'> CV bandwidth selector for density </h2><span id='topic+denCVBwSelC'></span>

<h3>Description</h3>

<p>Computes Cross Validation bandwidth selector for the
Parzen&ndash;Rosenblatt density estimator...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denCVBwSelC(x, kernel = gaussK, weig = rep(1, length(x)),
            interval = .lokestOptInt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denCVBwSelC_+3A_x">x</code></td>
<td>
<p> vector with data points. </p>
</td></tr>
<tr><td><code id="denCVBwSelC_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code>. </p>
</td></tr>
<tr><td><code id="denCVBwSelC_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations. </p>
</td></tr>
<tr><td><code id="denCVBwSelC_+3A_interval">interval</code></td>
<td>
<p> A range of values where to look for the bandwidth
parameter. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selector is implemented using its definition.
</p>


<h3>Value</h3>

<p>A numeric value with the bandwidth.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>, <code><a href="KernSmooth.html#topic+dpik">dpik</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stdy &lt;- function(size=100,rVar=rnorm,dVar=dnorm,kernel=gaussK,x=NULL)
{
	if( is.null(x) ) x &lt;- rVar(size)
	Tc &lt;- system.time( dbwc &lt;- denCVBwSelC(x,kernel) )[3]
	ucvT &lt;- system.time( ucvBw &lt;- bw.ucv(x,lower=0.00001,upper=2.0) )[3]
	nrdT &lt;- system.time( nrdBw &lt;- bw.nrd(x) )[3]
	{
		xeval &lt;- seq( min(x)+dbwc , max(x)-dbwc ,length=50)
		hist(x,probability=TRUE)
		lines(xeval,trueDen &lt;- dVar(xeval),col="red")
		lines(density(x),col="cyan")
		xevalDenc &lt;- PRDenEstC(x,xeval,dbwc,kernel)
		dencMSE &lt;- mean( (trueDen-xevalDenc)^2 )
		xevalucvDen &lt;- PRDenEstC(x,xeval,ucvBw,kernel)
		ucvMSE &lt;- mean( (trueDen-xevalucvDen)^2 )
		xevalDenNrd &lt;- PRDenEstC(x,xeval,nrdBw,kernel)
		nrdMSE &lt;- mean( (trueDen-xevalDenNrd)^2 )
		lines(xevalDenc,col="green")
		lines(xevalucvDen,col="blue")
		lines(xevalDenNrd,col="grey")
	}
	return( cbind(  bwVal=c(evalC=dbwc,ucvBw=ucvBw,nrdBw=nrdBw),
				mse=c(dencMSE,ucvMSE,nrdMSE),
				time=c(Tc,ucvT,nrdT) ) )
}
stdy(100,kernel=gaussK)
stdy(100,rVar=rexp,dVar=dexp,kernel=gaussK)
##	check stdy with other kernel, distributions
</code></pre>

<hr>
<h2 id='equivKernel'> Equivalent Kernel. </h2><span id='topic+equivKernel'></span>

<h3>Description</h3>

<p>Computes the Equivalent kernel for the local polynomial estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivKernel(kernel,nu,deg,lower=dom(kernel)[[1]],upper=dom(kernel)[[2]],
	subdivisions=25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equivKernel_+3A_nu">nu</code></td>
<td>
<p> Orders of derivative to estimate. </p>
</td></tr>
<tr><td><code id="equivKernel_+3A_deg">deg</code></td>
<td>
<p> Degree of Local polynomial estimator. </p>
</td></tr>
<tr><td><code id="equivKernel_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="equivKernel_+3A_lower">lower</code>, <code id="equivKernel_+3A_upper">upper</code></td>
<td>
<p> Integration limits. </p>
</td></tr>
<tr><td><code id="equivKernel_+3A_subdivisions">subdivisions</code></td>
<td>
<p> the maximum number of subintervals. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the Equivalent kernel for the local polynomial
estimation can be found in page 64 in Fan and Gijbels(1996). The
implementation uses <code>computeMu</code> to compute matrix <code class="reqn">S</code> and then
returns a function object
</p>


<h3>Value</h3>

<p>Returns a vector whose components are the equivalent kernel used to
compute the local polynomial estimator for the derivatives in <code>nu</code>.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cteNuK">cteNuK</a></code>, <code><a href="#topic+adjNuK">adjNuK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##	Some kernels and equiv. for higher order
##	compare with p=1
curve(EpaK(x),-3,3,ylim=c(-.5,1))
f &lt;- equivKernel(EpaK,0,3)
curve(f(x),-3,3,add=TRUE,col="blue")
curve(gaussK(x),-3,3,add=TRUE)
f &lt;- equivKernel(gaussK,0,3)
curve(f(x),-3,3,add=TRUE,col="blue")
##	Draw several Equivalent locl polynomial kernels
curve(EpaK(x),-3,3,ylim=c(-.5,1))
for(p in 1:5){
	curve(equivKernel(gaussK,0,p)(x),-3,3,add=TRUE)
    }
</code></pre>

<hr>
<h2 id='KernelChars'>Kernel characteristics</h2><span id='topic+K4'></span><span id='topic+RK'></span><span id='topic+RdK'></span><span id='topic+mu0K'></span><span id='topic+mu2K'></span><span id='topic+dom'></span><span id='topic+Kernel+20characteristics'></span>

<h3>Description</h3>

<p>For a given kernel these functions return some of the most commonly used numeric values related to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	RK(K)
	RdK(K)
	mu2K(K)
	mu0K(K)
	K4(K)
	dom(K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernelChars_+3A_k">K</code></td>
<td>
<p> A kernel as given in <code><a href="#topic+Kernels">Kernels</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these functions are implemented as an attribute
of every kernel. For the computations of the numeric value for these
quantities, see references.
</p>


<h3>Value</h3>

<p>A numeric value returning:
</p>
<table role = "presentation">
<tr><td><code>RK</code></td>
<td>
<p>The <code class="reqn">L_2</code> norm of <code>K</code>.</p>
</td></tr>
<tr><td><code>RdK</code></td>
<td>
<p>The <code class="reqn">L_2</code> norm of the derivative of <code>K</code>.</p>
</td></tr>
<tr><td><code>mu2K</code></td>
<td>
<p>The second order moment of <code>K</code>.</p>
</td></tr>
<tr><td><code>mu2K</code></td>
<td>
<p>The zeroth order moment of <code>K</code>.</p>
</td></tr>
<tr><td><code>dom</code></td>
<td>
<p>The support of <code>K</code>.</p>
</td></tr>
<tr><td><code>K4</code></td>
<td>
<p>The fourth order autoconvolution of <code>K</code> at <code class="reqn">x=0</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kernels">Kernels</a></code>, <a href="#topic+Compute+20kernel+20values">Compute kernel values</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	##	Note that lower and upper params are set in the definition to
	##	use 'dom()' function.
	g &lt;- function(kernels)
	{
		mu0 &lt;- sapply(kernels,function(x) computeMu0(x,))
		mu0.ok &lt;- sapply(kernels,mu0K)
		mu2 &lt;- sapply(kernels,function(x) computeMu(2,x))
		mu2.ok &lt;- sapply(kernels,mu2K)
		Rk.ok &lt;- sapply(kernels,RK)
		RK &lt;- sapply(kernels,function(x) computeRK(x))
		K4 &lt;- sapply(kernels,function(x) computeK4(x))
		res &lt;- data.frame(mu0,mu0.ok,mu2,mu2.ok,RK,Rk.ok,K4)
		res
	}
	g(kernels=c(EpaK,gaussK,TriweigK,TrianK))
</code></pre>

<hr>
<h2 id='kernelCte'> Kernel Constants used in Bandwidth Selection. </h2><span id='topic+cteNuK'></span><span id='topic+adjNuK'></span>

<h3>Description</h3>

<p>These are values depending on the kernel and the local polynomial degrees that are used in bandwidth selection, as proposed in Fan and Gijbels(1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cteNuK(nu,p,kernel,lower=dom(kernel)[[1]],upper=dom(kernel)[[2]],
	subdivisions= 25)
adjNuK(nu,p,kernel,lower=dom(kernel)[[1]],upper=dom(kernel)[[2]],
	subdivisions= 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelCte_+3A_nu">nu</code></td>
<td>
<p> Order of derivative to estimate. </p>
</td></tr>
<tr><td><code id="kernelCte_+3A_p">p</code></td>
<td>
<p> Degree of Local polynomial estimator. </p>
</td></tr>
<tr><td><code id="kernelCte_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="kernelCte_+3A_lower">lower</code>, <code id="kernelCte_+3A_upper">upper</code></td>
<td>
<p> Integration limits. </p>
</td></tr>
<tr><td><code id="kernelCte_+3A_subdivisions">subdivisions</code></td>
<td>
<p> the maximum number of subintervals. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cteNuK</code> is computed using <a href="#topic+Compute+20kernel+20values">Compute kernel values</a> and <code>link{equivKernel}</code> jointly with the numerical integration utility
<code><a href="stats.html#topic+integrate">integrate</a></code>. <code>adjNuK</code> is implemented using quotients
of previous functions. See Fan and Gijbels(1996) pages 67 and 119.
</p>


<h3>Value</h3>

<p>Both functions returns numeric values.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+regCVBwSelC">regCVBwSelC</a></code>, <code><a href="#topic+pluginBw">pluginBw</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>

<hr>
<h2 id='Kernels'> Kernels. </h2><span id='topic+Kernels'></span><span id='topic+biweigK'></span><span id='topic+CosK'></span><span id='topic+EpaK'></span><span id='topic+Epa2K'></span><span id='topic+gaussK'></span><span id='topic+gaussKlf'></span><span id='topic+SqK'></span><span id='topic+QuartK'></span><span id='topic+TrianK'></span><span id='topic+tricubK'></span><span id='topic+tricubKlf'></span><span id='topic+TriweigK'></span>

<h3>Description</h3>

<p>Definition of common kernels used in local polynomial estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	CosK(x)
	EpaK(x)
	Epa2K(x)
	gaussK(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kernels_+3A_x">x</code></td>
<td>
<p> Numeric vector o value. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of these kernels is done by means
functions that can operate on vectors.
</p>
<p>Most common referred numeric values for these kernels are provided as
attributes, see <code><a href="#topic+RK">RK</a></code>, <code><a href="#topic+mu0K">mu0K</a></code>, etc....
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera. </p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+RK">RK</a></code>, <code><a href="#topic+mu0K">mu0K</a></code>.
</p>

<hr>
<h2 id='locCteWeights'> Local Polynomial Weights </h2><span id='topic+locCteWeightsC'></span><span id='topic+locLinWeightsC'></span><span id='topic+locWeightsEvalC'></span><span id='topic+locWeightsEval'></span><span id='topic+locPolWeights'></span>

<h3>Description</h3>

<p>Local Constant and local Linear estimator with weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  locCteWeightsC(x, xeval, bw, kernel, weig = rep(1, length(x)))
  locLinWeightsC(x, xeval, bw, kernel, weig = rep(1, length(x)))
  locPolWeights(x, xeval, deg, bw, kernel, weig = rep(1, length(x)))
  locWeightsEval(lpweig, y)
  locWeightsEvalC(lpweig, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locCteWeights_+3A_x">x</code></td>
<td>
<p> x covariate data values. </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_y">y</code></td>
<td>
<p> y response data values. </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_xeval">xeval</code></td>
<td>
<p> Vector with evaluation points. </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_bw">bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_deg">deg</code></td>
<td>
<p>  Local polynomial estimation degree (<code class="reqn">p</code>). </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations. </p>
</td></tr>
<tr><td><code id="locCteWeights_+3A_lpweig">lpweig</code></td>
<td>
<p> Local polynomial weights <code class="reqn">(X^TWX)^{-1}X^TW</code> evaluated at <code>xeval</code> matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>locCteWeightsC</code> and <code>locLinWeightsC</code> computes local
constant and local linear weights, say any of the entries of
the vector <code class="reqn">(X^TWX)^{-1}X^TW</code> for <code class="reqn">p=0</code> and <code class="reqn">p=1</code> resp.
<code>locWeightsEvalC</code> and <code>locWeightsEval</code> computes local
the estimator for a given vector of responses <code>y</code>
</p>


<h3>Value</h3>

<p><code>locCteWeightsC</code> and <code>locLinWeightsC</code> returns a list
with two components
</p>
<table role = "presentation">
<tr><td><code>den</code></td>
<td>
<p>Estimation of <code class="reqn">(n*h*f(x))^{p+1}</code> being <code class="reqn">h</code> the
bandwidth <code>bw</code>.</p>
</td></tr>
<tr><td><code>locWeig</code></td>
<td>
<p><code class="reqn">(X^TWX)^{-1}X^TW</code> evaluated at <code>xeval</code> Matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kernels">Kernels</a></code>, <a href="#topic+locpol">locpol</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	size &lt;- 200
	sigma &lt;- 0.25
	deg &lt;- 1
	kernel &lt;- EpaK
	bw &lt;- .25
	xeval &lt;- 0:100/100
	regFun &lt;- function(x) x^3
	x &lt;- runif(size)
	y &lt;- regFun(x) + rnorm(x, sd = sigma)
	d &lt;- data.frame(x, y)
	lcw &lt;- locCteWeightsC(d$x, xeval, bw, kernel)$locWeig
	lce &lt;- locWeightsEval(lcw, y)
	lceB &lt;- locCteSmootherC(d$x, d$y, xeval, bw, kernel)$beta0
	mean((lce-lceB)^2)
    llw &lt;- locLinWeightsC(d$x, xeval, bw, kernel)$locWeig
	lle &lt;- locWeightsEval(llw, y)
	lleB &lt;- locLinSmootherC(d$x, d$y, xeval, bw, kernel)$beta0
	mean((lle-lleB)^2)
</code></pre>

<hr>
<h2 id='locpol'> Local Polynomial estimation. </h2><span id='topic+locpol'></span><span id='topic+confInterval'></span><span id='topic+residuals.locpol'></span><span id='topic+fitted.locpol'></span><span id='topic+summary.locpol'></span><span id='topic+print.locpol'></span><span id='topic+plot.locpol'></span>

<h3>Description</h3>

<p>Formula interface for the local polynomial estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    locpol(formula,data,weig=rep(1,nrow(data)),bw=NULL,kernel=EpaK,deg=1,
            xeval=NULL,xevalLen=100)
    confInterval(x)
    ## S3 method for class 'locpol'
residuals(object,...)
    ## S3 method for class 'locpol'
fitted(object,deg=0,...)
    ## S3 method for class 'locpol'
summary(object,...)
    ## S3 method for class 'locpol'
print(x,...)
    ## S3 method for class 'locpol'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locpol_+3A_formula">formula</code></td>
<td>
<p> formula as in <code>lm</code>, only first covariate is used. </p>
</td></tr>
<tr><td><code id="locpol_+3A_data">data</code></td>
<td>
<p> data frame with data. </p>
</td></tr>
<tr><td><code id="locpol_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for each observations. </p>
</td></tr>
<tr><td><code id="locpol_+3A_bw">bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code id="locpol_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see
<code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="locpol_+3A_deg">deg</code></td>
<td>
<p> Local polynomial estimation degree (<code class="reqn">p</code>). </p>
</td></tr>
<tr><td><code id="locpol_+3A_xeval">xeval</code></td>
<td>
<p> Vector of evaluation points. By default <code>xevalLen</code> points between the min. and the max. of the regressors.</p>
</td></tr>
<tr><td><code id="locpol_+3A_xevallen">xevalLen</code></td>
<td>
<p> Length of <code>xeval</code> if it is <code>NULL</code> </p>
</td></tr>
<tr><td><code id="locpol_+3A_x">x</code></td>
<td>
<p> A <code>locpol</code> object. </p>
</td></tr>
<tr><td><code id="locpol_+3A_object">object</code></td>
<td>
<p> A <code>locpol</code> object. </p>
</td></tr>
<tr><td><code id="locpol_+3A_...">...</code></td>
<td>
<p> Any other required argument. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the local polynomial estimation function
that provides basic <code>lm</code> functionality. <code>summary</code> and
<code>print</code> methods shows very basic information about the fit,
<code>fitted</code> return the estimation of the derivatives if <code>deg</code>
is larger than 0, and <code>plot</code> provides a plot of data, local
polynomial estimation and the variance estimation.
</p>
<p>Variance estimation is carried out by means of the local constant
regression estimation of the squared residuals.
</p>
<p><code>confInterval</code> provides confidence intervals for all points
in <code>x$lpFit$[,x$X]</code>, say those in <code>xeval</code>.
</p>


<h3>Value</h3>

<p>A list containing among other components:
</p>
<table role = "presentation">
<tr><td><code>mf</code></td>
<td>
<p> Model frame for <code>data</code> and <code>formula</code>. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> data frame with data. </p>
</td></tr>
<tr><td><code>weig</code></td>
<td>
<p> Vector of weight for each observations.</p>
</td></tr>
<tr><td><code>xeval</code></td>
<td>
<p> Vector of evaluation points. </p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p> Kernel used, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code>KName</code></td>
<td>
<p> Kernel name, a string with the name of kernel.</p>
</td></tr>
<tr><td><code>deg</code></td>
<td>
<p> Local polynomial estimation degree (<code class="reqn">p</code>).</p>
</td></tr>
<tr><td><code>X</code>, <code>Y</code></td>
<td>
<p> Names in <code>data</code> of the response and covariate. They are also used in <code>lpFit</code> to name the fitted data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> Residuals of the local polynomial fit.</p>
</td></tr>
<tr><td><code>lpFit</code></td>
<td>
<p> Data frame with the local polynomial fit. It contains covariate, response, derivatives estimation, <code class="reqn">X</code> density estimation, and variance estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>
<p>Crist'obal, J. A. and Alcal\'a, J. T. (2000).
<em> Nonparametric regression estimators for length biased data\/</em>.
J. Statist. Plann. Inference, 89, pp. 145-168.
</p>
<p>Ahmad, Ibrahim A. (1995)
<em>On multivariate kernel estimation for samples from weighted
distributions\/</em>.
Statistics &amp; Probability Letters, 22, num. 2, pp. 121-129
</p>


<h3>See Also</h3>

 <p><code>locpoly</code> from package <span class="pkg">KernSmooth</span>,
<code><a href="stats.html#topic+ksmooth">ksmooth</a></code> and <code><a href="stats.html#topic+loess">loess</a></code> in <span class="pkg">stats</span> (but from earlier package <code>modreg</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    N &lt;- 250
    xeval &lt;- 0:100/100
    ##  ex1
    d &lt;- data.frame(x = runif(N))
    d$y &lt;- d$x^2 - d$x + 1 + rnorm(N, sd = 0.1)
    r &lt;- locpol(y~x,d)
    plot(r)
    ##  ex2
    d &lt;- data.frame(x = runif(N))
    d$y &lt;- d$x^2 - d$x + 1 + (1+d$x)*rnorm(N, sd = 0.1)
    r &lt;- locpol(y~x,d)
    plot(r)
    ## notice:
    rr &lt;- locpol(y~x,d,xeval=runif(50,-1,1))
    ## notice x has null dens. outside (0,1)
    ## plot(rr) raises an error, no conf. bands outside (0,1).
    ## length biased data !!
    d &lt;- data.frame(x = runif(10*N))
    d$y &lt;- d$x^2 - d$x + 1 + (rexp(10*N,rate=4)-.25)
    posy &lt;- d$y[ whichYPos &lt;- which(d$y&gt;0) ];
    d &lt;- d[sample(whichYPos, N,prob=posy,replace=FALSE),]
    rBiased &lt;- locpol(y~x,d)
    r &lt;- locpol(y~x,d,weig=1/d$y)
    plot(d)
    points(r$lpFit[,r$X],r$lpFit[,r$Y],type="l",col="blue")
    points(rBiased$lpFit[,rBiased$X],rBiased$lpFit[,rBiased$Y],type="l")
    curve(x^2 - x + 1,add=TRUE,col="red")

</code></pre>

<hr>
<h2 id='locpolSmoothers'> Local Polynomial estimation. </h2><span id='topic+locCteSmootherC'></span><span id='topic+locLinSmootherC'></span><span id='topic+locCuadSmootherC'></span><span id='topic+locPolSmootherC'></span><span id='topic+looLocPolSmootherC'></span>

<h3>Description</h3>

<p>Computes the local polynomial estimation of the regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locCteSmootherC(x, y, xeval, bw, kernel, weig = rep(1, length(y)))
locLinSmootherC(x, y, xeval, bw, kernel, weig = rep(1, length(y)))
locCuadSmootherC(x, y, xeval, bw, kernel, weig = rep(1, length(y)))
locPolSmootherC(x, y, xeval, bw, deg, kernel, DET = FALSE,
	weig = rep(1, length(y)))
looLocPolSmootherC(x, y, bw, deg, kernel, weig = rep(1, length(y)),
        DET = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locpolSmoothers_+3A_x">x</code></td>
<td>
<p> x covariate data values. </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_y">y</code></td>
<td>
<p> y response data values. </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_xeval">xeval</code></td>
<td>
<p> Vector of evaluation points. </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_bw">bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations. </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_deg">deg</code></td>
<td>
<p> Local polynomial estimation degree (<code class="reqn">p</code>). </p>
</td></tr>
<tr><td><code id="locpolSmoothers_+3A_det">DET</code></td>
<td>
<p> Boolean to ask for the computation of the determinant if the matrix <code class="reqn">X^TWX</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these function perform the estimation of the regression function
for different degrees. While <code>locCteSmootherC</code>, <code>locLinSmootherC</code>,
and <code>locCuadSmootherC</code> uses direct computations for the degrees 0,1
and 2 respectively, <code>locPolSmootherC</code> implements a general method for any degree.
Particularly useful can be <code>looLocPolSmootherC</code>(Leave one out) which computes the local polynomial estimator for any degree as <code>locPolSmootherC</code> does, but estimating <code class="reqn">m(x_i)</code> without using <code class="reqn">i</code>&ndash;th observation on the computation.
</p>


<h3>Value</h3>

<p>A data frame whose components gives the evaluation points, the estimator
for the regression function <code class="reqn">m(x)</code> and its derivatives at each point, and
the estimation of the marginal density for <code>x</code> to the <code class="reqn">p+1</code> power.
These components are given by:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Evaluation points.</p>
</td></tr>
<tr><td><code>beta0</code>, <code>beta1</code>, <code>beta2</code>, <code>...</code></td>
<td>
<p>Estimation of the <code class="reqn">i</code>-th derivative
of the regression function (<code class="reqn">m^{(i)}(x)</code>) for <code class="reqn">i=0,1,...</code>. </p>
</td></tr>
<tr><td><code>den</code></td>
<td>
<p>Estimation of <code class="reqn">(n*h*f(x))^{p+1}</code>, being <code class="reqn">h</code> the
bandwidth <code>bw</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code>locpoly</code> from package <span class="pkg">KernSmooth</span>,
<code><a href="stats.html#topic+ksmooth">ksmooth</a></code> and <code><a href="stats.html#topic+loess">loess</a></code> in <span class="pkg">stats</span> (but from earlier package <code>modreg</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
xeval &lt;- 0:10/10
d &lt;- data.frame(x = runif(N))
bw &lt;- 0.125
fx &lt;- xeval^2 - xeval + 1
##	Non random
d$y &lt;- d$x^2 - d$x + 1
cuest &lt;- locCuadSmootherC(d$x, d$y ,xeval, bw, EpaK)
lpest2 &lt;- locPolSmootherC(d$x, d$y , xeval, bw, 2, EpaK)
print(cbind(x = xeval, fx, cuad0 = cuest$beta0,
lp0 = lpest2$beta0, cuad1 = cuest$beta1, lp1 = lpest2$beta1))
##	Random
d$y &lt;- d$x^2 - d$x + 1 + rnorm(d$x, sd = 0.1)
cuest &lt;- locCuadSmootherC(d$x,d$y , xeval, bw, EpaK)
lpest2 &lt;- locPolSmootherC(d$x,d$y , xeval, bw, 2, EpaK)
lpest3 &lt;- locPolSmootherC(d$x,d$y , xeval, bw, 3, EpaK)
cbind(x = xeval, fx, cuad0 = cuest$beta0, lp20 = lpest2$beta0,
lp30 = lpest3$beta0, cuad1 = cuest$beta1, lp21 = lpest2$beta1,
lp31 = lpest3$beta1)
</code></pre>

<hr>
<h2 id='pluginBw'> Plugin Bandwidth selector. </h2><span id='topic+pluginBw'></span>

<h3>Description</h3>

<p>Implements a plugin bandwidth selector for the regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluginBw(x, y, deg, kernel, weig = rep(1,length(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pluginBw_+3A_x">x</code></td>
<td>
<p> x covariate values. </p>
</td></tr>
<tr><td><code id="pluginBw_+3A_y">y</code></td>
<td>
<p> y response values. </p>
</td></tr>
<tr><td><code id="pluginBw_+3A_deg">deg</code></td>
<td>
<p> degree of the local polynomial. </p>
</td></tr>
<tr><td><code id="pluginBw_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code>. </p>
</td></tr>
<tr><td><code id="pluginBw_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the plug-in bandwidth selector as shown in Fan and Gijbels(1996) book using pilots estimates as given in page 110-112 (Rule of thumb for bandwidth selection).  Currently, only even values of p are can be used.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Note</h3>

<p>Currently, only even values of p are can be used.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+thumbBw">thumbBw</a></code>, <code><a href="#topic+regCVBwSelC">regCVBwSelC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	size &lt;- 200
	sigma &lt;- 0.25
	deg &lt;- 1
	kernel &lt;- EpaK
	xeval &lt;- 0:100/100
	regFun &lt;- function(x) x^3
	x &lt;- runif(size)
	y &lt;- regFun(x) + rnorm(x, sd = sigma)
	d &lt;- data.frame(x, y)
	cvBwSel &lt;- regCVBwSelC(d$x,d$y, deg, kernel, interval = c(0, 0.25))
	thBwSel &lt;- thumbBw(d$x, d$y, deg, kernel)
	piBwSel &lt;- pluginBw(d$x, d$y, deg, kernel)
	est &lt;- function(bw, dat, x) return(locPolSmootherC(dat$x,dat$y, x, bw, deg,
					kernel)$beta0)
	ise &lt;- function(val, est) return(sum((val - est)^2 * xeval[[2]]))
	plot(d$x, d$y)
	trueVal &lt;- regFun(xeval)
	lines(xeval, trueVal, col = "red")
	xevalRes &lt;- est(cvBwSel, d, xeval)
	cvIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue")
	xevalRes &lt;- est(thBwSel, d, xeval)
	thIse &lt;- ise(trueVal, xevalRes)
	xevalRes &lt;- est(piBwSel, d, xeval)
	piIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue", lty = "dashed")
	res &lt;- rbind(	bw = c(cvBwSel, thBwSel, piBwSel),
					ise = c(cvIse, thIse, piIse) )
	colnames(res) &lt;- c("CV", "th", "PI")
	res
</code></pre>

<hr>
<h2 id='PRDenEstC'> Parzen&ndash;Rosenblatt denstiy estimator. </h2><span id='topic+PRDenEstC'></span>

<h3>Description</h3>

<p>Parzen&ndash;Rosenblat univariate density estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRDenEstC(x, xeval, bw, kernel, weig = rep(1, length(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PRDenEstC_+3A_x">x</code></td>
<td>
<p> vector with data points. </p>
</td></tr>
<tr><td><code id="PRDenEstC_+3A_xeval">xeval</code></td>
<td>
<p> Vector of evaluation points. </p>
</td></tr>
<tr><td><code id="PRDenEstC_+3A_bw">bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code id="PRDenEstC_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="PRDenEstC_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple Parzen&ndash;Rosenblat univariate density estimation, computed using
definition.
</p>


<h3>Value</h3>

<p>Returns an <code>(x,den)</code> data frame.
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Evaluation points.</p>
</td></tr>
<tr><td><code>den</code></td>
<td>
<p>Density at each <code>x</code> point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, that uses FT to compute a kernel density
estimator,  <code>bkde</code> from package <span class="pkg">KernSmooth</span> for a
binned version, and <code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>, <code>dpik</code>, <code><a href="#topic+denCVBwSelC">denCVBwSelC</a></code> for bandwidth selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	N &lt;- 100
	x &lt;-  runif(N)
	xeval &lt;- 0:10/10
	b0.125 &lt;- PRDenEstC(x, xeval, 0.125, EpaK)
	b0.05 &lt;- PRDenEstC(x, xeval, 0.05, EpaK)
	cbind(x = xeval, fx = 1, b0.125 = b0.125$den, b0.05 = b0.05$den)
</code></pre>

<hr>
<h2 id='regCVBwSelC'> Cross Validation Bandwidth selector. </h2><span id='topic+regCVBwSelC'></span>

<h3>Description</h3>

<p>Implements Cross validation bandwidth selector for the regression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regCVBwSelC(x, y, deg, kernel=gaussK,weig=rep(1,length(y)),
interval=.lokestOptInt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regCVBwSelC_+3A_x">x</code></td>
<td>
<p> x covariate values. </p>
</td></tr>
<tr><td><code id="regCVBwSelC_+3A_y">y</code></td>
<td>
<p> y response values. </p>
</td></tr>
<tr><td><code id="regCVBwSelC_+3A_deg">deg</code></td>
<td>
<p> degree of the local polynomial. </p>
</td></tr>
<tr><td><code id="regCVBwSelC_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code>. </p>
</td></tr>
<tr><td><code id="regCVBwSelC_+3A_weig">weig</code></td>
<td>
<p> Vector of weights for observations.</p>
</td></tr>
<tr><td><code id="regCVBwSelC_+3A_interval">interval</code></td>
<td>
<p> An interval where to look for the bandwidth. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the weighted ASE for every bandwidth returning the minimum.
The function is implemented by means of a C function that computes for a
single bandwidth the ASE, and a call to <code>optimise</code> on a given interval.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>H\&quot;ardle W.(1990)
<em> Smoothing techniques</em>.
Springer Series in Statistics, New York (1991).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+thumbBw">thumbBw</a></code>, <code><a href="#topic+pluginBw">pluginBw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	size &lt;- 200
	sigma &lt;- 0.25
	deg &lt;- 1
	kernel &lt;- EpaK
	xeval &lt;- 0:100/100
	regFun &lt;- function(x) x^3
	x &lt;- runif(size)
	y &lt;- regFun(x) + rnorm(x, sd = sigma)
	d &lt;- data.frame(x, y)
	cvBwSel &lt;- regCVBwSelC(d$x,d$y, deg, kernel, interval = c(0, 0.25))
	thBwSel &lt;- thumbBw(d$x, d$y, deg, kernel)
	piBwSel &lt;- pluginBw(d$x, d$y, deg, kernel)
	est &lt;- function(bw, dat, x) return(locPolSmootherC(dat$x,dat$y, x, bw, deg,
					kernel)$beta0)
	ise &lt;- function(val, est) return(sum((val - est)^2 * xeval[[2]]))
	plot(d$x, d$y)
	trueVal &lt;- regFun(xeval)
	lines(xeval, trueVal, col = "red")
	xevalRes &lt;- est(cvBwSel, d, xeval)
	cvIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue")
	xevalRes &lt;- est(thBwSel, d, xeval)
	thIse &lt;- ise(trueVal, xevalRes)
	xevalRes &lt;- est(piBwSel, d, xeval)
	piIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue", lty = "dashed")
	res &lt;- rbind(	bw = c(cvBwSel, thBwSel, piBwSel),
					ise = c(cvIse, thIse, piIse) )
	colnames(res) &lt;- c("CV", "th", "PI")
	res
</code></pre>

<hr>
<h2 id='selKernel'> Kernel selection.</h2><span id='topic+selKernel'></span>

<h3>Description</h3>

<p>Uses kernel attributes to selects kernels. This function is mainly used for internal purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selKernel(kernel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selKernel_+3A_kernel">kernel</code></td>
<td>
<p> kernel to use. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>RK(K)</code> to identify a kernel. 
The integer is used in the C code part to perform 
computations with given kernel. It allows for a kernel 
selection in C routines. It is used only for internal 
purposes. 
</p>


<h3>Value</h3>

<p>An integer that is unique for each kernel.
</p>


<h3>Warning </h3>

  
<p>Used only for internal purposes. 
</p>


<h3>Author(s)</h3>

<p> Jorge Luis Ojeda Cabrera. 
</p>

<hr>
<h2 id='simpleSmoothers'> Simple smoother </h2><span id='topic+simpleSmootherC'></span><span id='topic+simpleSqSmootherC'></span>

<h3>Description</h3>

<p>Computes simple kernel smoothing  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  simpleSmootherC(x, y, xeval, bw, kernel, weig = rep(1, length(y)))
  simpleSqSmootherC(x, y, xeval, bw, kernel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleSmoothers_+3A_x">x</code></td>
<td>
<p> x covariate data values. </p>
</td></tr>
<tr><td><code id="simpleSmoothers_+3A_y">y</code></td>
<td>
<p> y response data values. </p>
</td></tr>
<tr><td><code id="simpleSmoothers_+3A_xeval">xeval</code></td>
<td>
<p> Vector with evaluation points. </p>
</td></tr>
<tr><td><code id="simpleSmoothers_+3A_bw">bw</code></td>
<td>
<p> Smoothing parameter, bandwidth. </p>
</td></tr>
<tr><td><code id="simpleSmoothers_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation, see <code><a href="#topic+Kernels">Kernels</a></code></p>
</td></tr>
<tr><td><code id="simpleSmoothers_+3A_weig">weig</code></td>
<td>
<p> weights if they are required. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes simple smoothing, that is to say: it averages <code>y</code> 
values times kernel evaluated on <code>x</code> values. <code>simpleSqSmootherC</code>
does the average with the square of such values.
</p>


<h3>Value</h3>

<p>Both functions returns a <code>data.frame</code> with
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
 <p><code class="reqn">x</code> evaluation points. </p>
</td></tr>
<tr><td><code>reg</code></td>
<td>
<p> the smoothed values at <code>x</code> points. </p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Jorge Luis Ojeda Cabrera. 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+PRDenEstC">PRDenEstC</a></code>, <code><a href="#topic+Kernel+20characteristics">Kernel characteristics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	size &lt;- 1000
	x &lt;- runif(100)
	bw &lt;- 0.125
	kernel &lt;- EpaK
	xeval &lt;- 1:9/10
	y &lt;- rep(1,100)	
	##	x kern. aver. should give density f(x)
	prDen &lt;- PRDenEstC(x,xeval,bw,kernel)$den
	ssDen &lt;- simpleSmootherC(x,y,xeval,bw,kernel)$reg
	all(abs(prDen-ssDen)&lt;1e-15)
	##	x kern. aver. should be f(x)*R2(K) aprox.
	s2Den &lt;- simpleSqSmootherC(x,y,xeval,bw,kernel)$reg
	summary( abs(prDen*RK(kernel)-s2Den) )
	summary( abs(1*RK(kernel)-s2Den) )
	##	x kern. aver. should be f(x)*R2(K) aprox.
	for(n in c(1000,1e4,1e5))
	{
		s2D &lt;- simpleSqSmootherC(runif(n),rep(1,n),xeval,bw,kernel)$reg
		cat("\n",n,"\n")
		print( summary( abs(1*RK(kernel)-s2D) ) )
	}
</code></pre>

<hr>
<h2 id='thumbBw'> Rule of thumb for bandwidth selection.</h2><span id='topic+thumbBw'></span><span id='topic+compDerEst'></span>

<h3>Description</h3>

<p>Implements Fan and Gijbels(1996)'s Rule of thumb for bandwidth selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thumbBw(x, y, deg, kernel, weig = rep(1, length(y)))
compDerEst(x, y, p, weig = rep(1, length(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thumbBw_+3A_x">x</code></td>
<td>
<p> x covariate data values. </p>
</td></tr>
<tr><td><code id="thumbBw_+3A_y">y</code></td>
<td>
<p> y response data values. </p>
</td></tr>
<tr><td><code id="thumbBw_+3A_p">p</code></td>
<td>
<p> order of local polynomial estimator. </p>
</td></tr>
<tr><td><code id="thumbBw_+3A_deg">deg</code></td>
<td>
<p> Local polynomial estimation degree($p$). </p>
</td></tr>
<tr><td><code id="thumbBw_+3A_kernel">kernel</code></td>
<td>
<p> Kernel used to perform the estimation.</p>
</td></tr>
<tr><td><code id="thumbBw_+3A_weig">weig</code></td>
<td>
<p> weights if they are required. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Fan and Gijbels(1996) book, Section 4.2. This implementation is
also considering weights. <code>compDerEst</code> computes the <code class="reqn">p+1</code>
derivative of the regression function in a simple manner, assuming it
is a polynomial in <code class="reqn">x</code>. <code>thumbBw</code> gives a bandwidth selector
by means of pilot estimator given by <code>compDerEst</code> and the mean of
residuals.
</p>


<h3>Value</h3>

<p><code>thumbBw</code> returns a single numeric value, while <code>compDerEst</code> returns a data frame whose components are:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>x values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y values.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>residuals for the parametric estimation.</p>
</td></tr>
<tr><td><code>der</code></td>
<td>
<p>derivative estimation at x values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Luis Ojeda Cabrera.
</p>


<h3>References</h3>

<p>Fan, J. and Gijbels, I.
<em> Local polynomial modelling and its applications\/</em>.
Chapman &amp; Hall, London (1996).
</p>
<p>Wand, M.~P. and Jones, M.~C.
<em> Kernel smoothing\/</em>.
Chapman and Hall Ltd., London (1995).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regCVBwSelC">regCVBwSelC</a></code>, <code><a href="#topic+pluginBw">pluginBw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	size &lt;- 200
	sigma &lt;- 0.25
	deg &lt;- 1
	kernel &lt;- EpaK
	xeval &lt;- 0:100/100
	regFun &lt;- function(x) x^3
	x &lt;- runif(size)
	y &lt;- regFun(x) + rnorm(x, sd = sigma)
	d &lt;- data.frame(x, y)
	cvBwSel &lt;- regCVBwSelC(d$x,d$y, deg, kernel, interval = c(0, 0.25))
	thBwSel &lt;- thumbBw(d$x, d$y, deg, kernel)
	piBwSel &lt;- pluginBw(d$x, d$y, deg, kernel)
	est &lt;- function(bw, dat, x) return(locPolSmootherC(dat$x,dat$y, x, bw, deg,
					kernel)$beta0)
	ise &lt;- function(val, est) return(sum((val - est)^2 * xeval[[2]]))
	plot(d$x, d$y)
	trueVal &lt;- regFun(xeval)
	lines(xeval, trueVal, col = "red")
	xevalRes &lt;- est(cvBwSel, d, xeval)
	cvIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue")
	xevalRes &lt;- est(thBwSel, d, xeval)
	thIse &lt;- ise(trueVal, xevalRes)
	xevalRes &lt;- est(piBwSel, d, xeval)
	piIse &lt;- ise(trueVal, xevalRes)
	lines(xeval, xevalRes, col = "blue", lty = "dashed")
	res &lt;- rbind(	bw = c(cvBwSel, thBwSel, piBwSel),
					ise = c(cvIse, thIse, piIse) )
	colnames(res) &lt;- c("CV", "th", "PI")
	res
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
