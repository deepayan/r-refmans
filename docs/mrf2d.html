<!DOCTYPE html><html><head><title>Help for package mrf2d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mrf2d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#basis_functions'><p>Creation of basis functions</p></a></li>
<li><a href='#bold5000'><p>BOLD5000 neuroimaging data</p></a></li>
<li><a href='#cpmrf2d'><p>Conditional probabilities in a pixel position</p></a></li>
<li><a href='#data_examples'><p>Example Data</p></a></li>
<li><a href='#dplot'><p>Plotting functions for lattice data</p></a></li>
<li><a href='#fit_ghm'><p>EM estimation for Gaussian Hidden Markov field</p></a></li>
<li><a href='#fit_pl'><p>Maximum Pseudo-likelihood fitting of MRFs on 2d lattices.</p></a></li>
<li><a href='#fit_sa'><p>Stochastic Approximation fitting of MRFs on 2d lattices</p></a></li>
<li><a href='#hmrfout'><p>MRF fitting functions output</p></a></li>
<li><a href='#mrf2d-family'><p>Parameter restriction families</p></a></li>
<li><a href='#mrf2d-package'><p>mrf2d: Markov Random Field Models for Image Analysis</p></a></li>
<li><a href='#mrfi-class'><p>mrfi: MRF interaction structure</p></a></li>
<li><a href='#mrfout'><p>MRF fitting functions output</p></a></li>
<li><a href='#pl_mrf2d'><p>Pseudo-likelihood function for MRFs on 2d lattices</p></a></li>
<li><a href='#plot.mrfi'><p>Plotting of <code>mrfi</code> objects.</p></a></li>
<li><a href='#rmrf2d'><p>Sampling of Markov Random Fields on 2d lattices</p></a></li>
<li><a href='#rmrf2d_mc'><p>Markov Chain sampling of MRFs for Monte-Carlo methods</p></a></li>
<li><a href='#smr_array'><p>Summarized representation of theta arrays</p></a></li>
<li><a href='#smr_stat'><p>Summary Statistics</p></a></li>
<li><a href='#Z_potts'><p>Example objects from <code>mrf2d</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Markov Random Field Models for Image Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victor Freguglia &lt;victorfreguglia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Model fitting, sampling and visualization
    for the (Hidden) Markov Random Field model with pairwise interactions and 
    general interaction structure from 
    Freguglia, Garcia &amp; Bicas (2020) &lt;<a href="https://doi.org/10.1002%2Fenv.2613">doi:10.1002/env.2613</a>&gt;,
    which has many popular models used in 2-dimensional lattices
    as particular cases, like the Ising Model and Potts Model.
    A complete manuscript describing the package is available in
    Freguglia &amp; Garcia (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i08">doi:10.18637/jss.v101.i08</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), dplyr(&ge; 0.8.1), tidyr, methods, ggplot2,
Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, knitr, rmarkdown, glue</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Freguglia/mrf2d">https://github.com/Freguglia/mrf2d</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Freguglia/mrf2d/issues">https://github.com/Freguglia/mrf2d/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-25 16:21:16 UTC; victor</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Freguglia <a href="https://orcid.org/0000-0002-6189-4453"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-25 23:52:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='basis_functions'>Creation of basis functions</h2><span id='topic+basis_functions'></span><span id='topic+fourier_2d'></span><span id='topic+polynomial_2d'></span>

<h3>Description</h3>

<p><code>fourier_2d()</code> and <code>polynomial_2d()</code> creates a <code>list</code> of basis
functions to be used as the fixed effect in <code><a href="#topic+fit_ghm">fit_ghm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier_2d(max_freqs, lattice_dim)

polynomial_2d(poly_deg, lattice_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_functions_+3A_max_freqs">max_freqs</code></td>
<td>
<p>A length 2 numeric vector with maximum frequencies considered
(x-axis and y-axis direction, respectively).</p>
</td></tr>
<tr><td><code id="basis_functions_+3A_lattice_dim">lattice_dim</code></td>
<td>
<p>A length 2 numeric vector with lattice dimensions (N,M)
to be used.</p>
</td></tr>
<tr><td><code id="basis_functions_+3A_poly_deg">poly_deg</code></td>
<td>
<p>A length 2 numeric vector with degrees of the bivariate
polynomial to be considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fourier_2d()</code> is for 2-dimensional Fourier transform.
</p>


<h3>Value</h3>

<p>A <code>list</code> of functions.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fourier_2d(c(10,10), dim(Z_potts))
polynomial_2d(c(3,3), dim(Z_potts))

</code></pre>

<hr>
<h2 id='bold5000'>BOLD5000 neuroimaging data</h2><span id='topic+bold5000'></span>

<h3>Description</h3>

<p>An image extracted from the &quot;BOLD5000&quot; open dataset. It was read from
the file in path <code style="white-space: pre;">&#8288;BOLD5000/DS001499/SUB-CSI2/SES-16/ANAT/SUB-CSI2_SES-16_T1W.NII.GZ&#8288;</code>,
available at the OpenNeuro platform (https://openneuro.org/datasets/ds001499/versions/1.3.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bold5000
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 176 rows and 256 columns.
</p>


<h3>Details</h3>

<p>The file was read using the <code>oro.nifti</code> package and the image was extracted from the
matrix in slice 160.
</p>


<h3>References</h3>

<p>Chang, N., Pyles, J. A., Marcus, A., Gupta, A., Tarr, M. J., &amp; Aminoff, E. M. (2019).
BOLD5000, a public fMRI dataset while viewing 5000 visual images. Scientific data, 6(1), 1-18.
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>

<hr>
<h2 id='cpmrf2d'>Conditional probabilities in a pixel position</h2><span id='topic+cpmrf2d'></span><span id='topic+cp_mrf2d'></span>

<h3>Description</h3>

<p>Computes the vector of conditional probabilities
for a pixel position given a field, an interaction structure and
a parameter array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_mrf2d(Z, mrfi, theta, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpmrf2d_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> with integers in <code style="white-space: pre;">&#8288;{0,...,C}&#8288;</code>.</p>
</td></tr>
<tr><td><code id="cpmrf2d_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="cpmrf2d_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="cpmrf2d_+3A_pos">pos</code></td>
<td>
<p>Length-2 vector with the position to compute conditional
probabilities in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector with the conditional probabilities.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp_mrf2d(Z_potts, mrfi(1), theta_potts, c(57,31))
cp_mrf2d(Z_potts, mrfi(1), theta_potts*0.1, c(57,31))

</code></pre>

<hr>
<h2 id='data_examples'>Example Data</h2><span id='topic+data_examples'></span><span id='topic+field1'></span><span id='topic+hfield1'></span>

<h3>Description</h3>

<p><code>mrf2d</code> contains a set of simulated fields to illustrate its
usage.
</p>

<dl>
<dt>field1</dt><dd><p>A binary field sampled from a sparse interaction structure:
<code>mrfi(1) + c(4,4)</code></p>
</dd>
<dt>hfield1</dt><dd><p>A continuous valued field, obtained by Gaussian mixture driven
by <code>field1</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>field1

hfield1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 150 rows and 150 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 150 rows and 150 columns.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>

<hr>
<h2 id='dplot'>Plotting functions for lattice data</h2><span id='topic+dplot'></span><span id='topic+cplot'></span>

<h3>Description</h3>

<p><code>dplot()</code> and <code>cplot()</code> are functions for plotting lattice data.
They are an alternative to base R's <code>image()</code> function using <code>ggplot2</code>
instead.
<code>dplot</code> is used for discrete data and <code>cplot</code> for continuous data, they only
differ in the fact that pixel values are treated as a factor in <code>dplot</code>,
therefore, a discrete scale is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dplot(Z, legend = FALSE)

cplot(Y, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplot_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> object with integers only.</p>
</td></tr>
<tr><td><code id="dplot_+3A_legend">legend</code></td>
<td>
<p><code>logical</code> indicating whether a legend should be included or not.</p>
</td></tr>
<tr><td><code id="dplot_+3A_y">Y</code></td>
<td>
<p>A <code>matrix</code> object with continuous values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since returns a <code>ggplot</code> object, other layers can be added to it
using the usual <code>ggplot2</code> syntax in order to modify any aspect of the plot.
</p>
<p>The data frame used to create the object has columns named <code>x</code>, <code>y</code> and
<code>value</code>, which are mapped to <code>x</code>, <code>y</code> and <code>fill</code>, respectively, used
with <code>geom_tile()</code>.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting discrete data
dplot(Z_potts)

#Making it continuous
cplot(Z_potts + rnorm(length(Z_potts)))

#Adding extra ggplot layers
library(ggplot2)
dplot(Z_potts) + ggtitle("This is a title")
dplot(Z_potts, legend = TRUE) + scale_fill_brewer(palette = "Set1")


</code></pre>

<hr>
<h2 id='fit_ghm'>EM estimation for Gaussian Hidden Markov field</h2><span id='topic+fit_ghm'></span>

<h3>Description</h3>

<p><code>fit_ghm</code> fits a Gaussian Mixture model with hidden components
driven by a Markov random field with known parameters. The inclusion of a
linear combination of basis functions as a fixed effect is also possible.
</p>
<p>The algorithm is a modification of of
(Zhang et al. 2001), which is
described in (Freguglia et al. 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ghm(
  Y,
  mrfi,
  theta,
  fixed_fn = list(),
  equal_vars = FALSE,
  init_mus = NULL,
  init_sigmas = NULL,
  maxiter = 100,
  max_dist = 10^-3,
  icm_cycles = 6,
  verbose = interactive(),
  qr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ghm_+3A_y">Y</code></td>
<td>
<p>A matrix of observed (continuous) pixel values.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_fixed_fn">fixed_fn</code></td>
<td>
<p>A list of functions <code>fn(x,y)</code> to be considered as a fixed
effect. See <code><a href="#topic+basis_functions">basis_functions</a></code>.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_equal_vars">equal_vars</code></td>
<td>
<p><code>logical</code> indicating if the mixture model has the same
variances in all mixture components.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_init_mus">init_mus</code></td>
<td>
<p>Optional. A <code>numeric</code> with length (C+1) with the initial mean
estimate for each component.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_init_sigmas">init_sigmas</code></td>
<td>
<p>Otional. A <code>numeric</code> with length (C+1) with initial sample
deviation estimate for each component.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations allowed. Defaults to 100.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_max_dist">max_dist</code></td>
<td>
<p>Defines a stopping condition. The algorithm stops if the
maximum absolute difference between parameters of two consecutive iterations
is less than <code>max_dist</code>.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_icm_cycles">icm_cycles</code></td>
<td>
<p>Number of steps used in the Iterated Conditional Modes
algorithm executed in each interaction. Defaults to 6.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating wheter to print the progress or not.</p>
</td></tr>
<tr><td><code id="fit_ghm_+3A_qr">qr</code></td>
<td>
<p>The QR decomposition of the design matrix. Used internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>init_mus</code> or <code>init_sigmas</code> is <code>NULL</code> an EM algorithm
considering an independent uniform distriburion for the hidden component is
fitted first and its estimated means and sample deviations are used as
initial values. This is necessary because the algorithm may not converge if
the initial parameter configuration is too far from the maximum likelihood
estimators.
</p>
<p><code>max_dist</code> defines a stopping condition. The algorithm will stop if the
maximum absolute difference between (<code class="reqn">\mu</code> and <code class="reqn">\sigma</code>) parameters
in consecutive iterations is less than <code>max_dist</code>.
</p>


<h3>Value</h3>

<p>A <code>hmrfout</code> containing:
</p>

<ul>
<li> <p><code>par</code>: A <code>data.frame</code> with <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> estimates for each
component.
</p>
</li>
<li> <p><code>fixed</code>: A <code>matrix</code> with the estimated fixed effect in each pixel.
</p>
</li>
<li> <p><code>Z_pred</code>: A <code>matrix</code> with the predicted component (highest probability) in
each pixel.
</p>
</li>
<li> <p><code>predicted</code>: A <code>matrix</code> with the fixed effect + the <code class="reqn">\mu</code> value for
the predicted component in each pixel.
</p>
</li>
<li> <p><code>iterations</code>: Number of EM iterations done.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>References</h3>

<p>Freguglia V, Garcia NL, Bicas JL (2020).
&ldquo;Hidden Markov random field models applied to color homogeneity evaluation in dyed textile images.&rdquo;
<em>Environmetrics</em>, <b>31</b>(4), e2613.<br /><br /> Zhang Y, Brady M, Smith S (2001).
&ldquo;Segmentation of brain MR images through a hidden Markov random field model and the expectation-maximization algorithm.&rdquo;
<em>IEEE transactions on medical imaging</em>, <b>20</b>(1), 45&ndash;57.
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample a Gaussian mixture with components given by Z_potts
# mean values are 0, 1 and 2 and a linear effect on the x-axis.

set.seed(2)
Y &lt;- Z_potts + rnorm(length(Z_potts), sd = 0.4) +
      (row(Z_potts) - mean(row(Z_potts)))*0.01
# Check what the data looks like
cplot(Y)

fixed &lt;- polynomial_2d(c(1,0), dim(Y))
fit &lt;- fit_ghm(Y, mrfi = mrfi(1), theta = theta_potts, fixed_fn = fixed)
fit$par
cplot(fit$fixed)


</code></pre>

<hr>
<h2 id='fit_pl'>Maximum Pseudo-likelihood fitting of MRFs on 2d lattices.</h2><span id='topic+fit_pl'></span>

<h3>Description</h3>

<p>Parameter estimation for Markov random fields via
Pseudo-Likelihood function optimization. See
<code><a href="#topic+pl_mrf2d">pl_mrf2d</a></code> for information on the
Pseudo-Likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_pl(
  Z,
  mrfi,
  family = "onepar",
  init = 0,
  optim_args = list(method = "BFGS"),
  return_optim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_pl_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> object containing the observed MRF. <code>NA</code> values can be
used to create a subregion of the lattice for non-rectangular data.</p>
</td></tr>
<tr><td><code id="fit_pl_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="fit_pl_+3A_family">family</code></td>
<td>
<p>The family of parameter restrictions to potentials. Families
are:
<code>'onepar'</code>, <code>'oneeach'</code>, <code>'absdif'</code>, <code>'dif'</code> or <code>'free'</code>.
See <code><a href="#topic+mrf2d-family">mrf2d-familiy</a></code>.</p>
</td></tr>
<tr><td><code id="fit_pl_+3A_init">init</code></td>
<td>
<p>The initial value to be used in the optimization. It can be:
</p>

<ul>
<li><p> A valid <code>array</code> of parameter values according to <code>family</code>.
</p>
</li>
<li> <p><code>0</code>. If set to <code>0</code> an array with '0&ldquo; in all entries is created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_pl_+3A_optim_args">optim_args</code></td>
<td>
<p>Additional parameters passed to <code>optim()</code>.</p>
</td></tr>
<tr><td><code id="fit_pl_+3A_return_optim">return_optim</code></td>
<td>
<p><code>logical</code> indicating whether information from the
<code>optim()</code> call are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mrfout</code> with elements:
</p>

<ul>
<li> <p><code>theta</code>: The estimated array of potential values.
</p>
</li>
<li> <p><code>mrfi</code>: The interaction structure considered.
</p>
</li>
<li> <p><code>family</code>: The parameter restriction family considered.
</p>
</li>
<li> <p><code>method</code>: The estimation method (<code>"Pseudolikelihood"</code>).
</p>
</li>
<li> <p><code>value</code>: The optimal pseudo-likelihood value.
</p>
</li>
<li> <p><code>opt.xxx</code>(if <code>return_optim</code> is <code>TRUE</code>): Information returned by the
<code>optim()</code> function used for the optimization.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_pl(Z_potts, mrfi(1), family = "onepar")
fit_pl(Z_potts, mrfi(1), family = "oneeach")
fit_pl(Z_potts, mrfi(2), family = "onepar")

</code></pre>

<hr>
<h2 id='fit_sa'>Stochastic Approximation fitting of MRFs on 2d lattices</h2><span id='topic+fit_sa'></span>

<h3>Description</h3>

<p>Estimates the parameters of a MRF by successively sampling from
a parameter configuration and updating it by comparing the sufficient statistics
of the sampled field and the observed field.
</p>
<p>This method aims to find the parameter value where the gradient of the
likelihood function is equal to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sa(
  Z,
  mrfi,
  family = "onepar",
  gamma_seq,
  init = 0,
  cycles = 5,
  refresh_each = length(gamma_seq) + 1,
  refresh_cycles = 60,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sa_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> object containing the observed MRF. <code>NA</code> values can be
used to create a subregion of the lattice for non-rectangular data.</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_family">family</code></td>
<td>
<p>The family of parameter restrictions to potentials. Families
are:
<code>'onepar'</code>, <code>'oneeach'</code>, <code>'absdif'</code>, <code>'dif'</code> or <code>'free'</code>.
See <code><a href="#topic+mrf2d-family">mrf2d-familiy</a></code>.</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_gamma_seq">gamma_seq</code></td>
<td>
<p>A <code>numeric</code> vector with the sequence of constants
used in each step <code class="reqn">\gamma_t</code>.</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_init">init</code></td>
<td>
<p>The initial value to be used in the optimization. It can be:
</p>

<ul>
<li><p> A valid <code>array</code> of parameter values according to <code>family</code>.
</p>
</li>
<li> <p><code>0</code>. If set to <code>0</code> an array with '0&ldquo; in all entries is created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_sa_+3A_cycles">cycles</code></td>
<td>
<p>The number of updates to be done (for each each pixel).</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_refresh_each">refresh_each</code></td>
<td>
<p>An integer with the number of iterations taken before a
complete refresh (restart from a random state). This prevents the sample from
being stuck in a mode for too long. Defaults to <code>length(gamma_seq) + 1</code> (no
refresh happens).</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_refresh_cycles">refresh_cycles</code></td>
<td>
<p>An integer indicating how many Gibbs Sampler cycles are
performed when a refresh happens. Larger is usually better, but slower.</p>
</td></tr>
<tr><td><code id="fit_sa_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether the iteration number is printed
during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stochastic approximation method consists of, given an observed field <code>Z</code>,
and a starting parameters configuration <code class="reqn">\theta_0</code>, successively sample
a field <code class="reqn">Z_t</code> from the current parameter configuration and estimate the
direction of the  gradient of the likelihood function by comparing the
sufficient statistics in the current sample and the observed field.
</p>
<p>The solution is updated by moving in the estimated direction with a predefined
step size <code class="reqn">\gamma_t</code>, a new field <code class="reqn">Z_{t+1}</code> is sampled using the new
parameter configuration and <code class="reqn">Z_t</code> as an initial value, and the process is
repeated.
</p>
<p style="text-align: center;"><code class="reqn">\theta_{t+1} = \theta_t - \gamma_t(T(Z_t) - T(Z)),</code>
</p>

<p>where <code class="reqn">T(Z)</code> is the sufficient statistics for the reference field,
<code class="reqn">T(Z_t)</code> is the sufficient statistics for a field sampled from
<code class="reqn">\theta_t</code>.
</p>
<p><code>gamma_seq</code> is normalized internally by diving values by <code>length(Z)</code>, so the
choice of the sequence is invariant to the lattice dimensions. Typically, a
sequence like <code>seq(from = 1, to = 0, length.out = 1000)</code> should be used for
defining a sequence with <code>1000</code> steps. Some tuning of this sequence is
required.
</p>


<h3>Value</h3>

<p>A <code>mrfout</code> object with the following elements:
</p>

<ul>
<li> <p><code>theta</code>: The estimated <code>array</code> of potentials.
</p>
</li>
<li> <p><code>mrfi</code>: The interaction structure considered.
</p>
</li>
<li> <p><code>family</code>: The parameter restriction family considered.
</p>
</li>
<li> <p><code>method</code>: The estimation method (<code>"Stochastic Approximation"</code>).
</p>
</li>
<li> <p><code>metrics</code>: A <code>data.frame</code> containing the the euclidean distance between
the sufficient statics computed for <code>Z</code> and the current sample.
</p>
</li></ul>



<h3>Note</h3>

<p>Stochastic Approximation is called &quot;Controllable Simulated Annealing&quot; in
some references.
</p>
<p>Examples where Stochastic Approximation is used with MRFs are
(Gimel'farb 1996), (Atchadé et al. 2013).
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>References</h3>

<p>Wikipedia (2019).
&ldquo;Stochastic approximation.&rdquo;
<a href="https://en.wikipedia.org/wiki/Stochastic_approximation">https://en.wikipedia.org/wiki/Stochastic_approximation</a>.
</p>
<p>Atchadé YF, Lartillot N, Robert C, others (2013).
&ldquo;Bayesian computation for statistical models with intractable normalizing constants.&rdquo;
<em>Brazilian Journal of Probability and Statistics</em>, <b>27</b>(4), 416&ndash;436.<br /><br /> Gimel'farb GL (1996).
&ldquo;Texture modeling by multiple pairwise pixel interactions.&rdquo;
<em>IEEE Transactions on pattern analysis and machine intelligence</em>, <b>18</b>(11), 1110&ndash;1114.
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2)
fit1 &lt;- fit_sa(Z_potts, mrfi(1), family = "oneeach", gamma_seq = seq(1, 0, length.out = 50))
# Estimated parameters
fit1$theta
# A visualization of estimated gradient norm over iterations.
plot(fit1$metrics, type = "l")

fit_sa(Z_potts, mrfi(1), family = "oneeach", gamma_seq = seq(1, 0, length.out = 50))


</code></pre>

<hr>
<h2 id='hmrfout'>MRF fitting functions output</h2><span id='topic+hmrfout'></span><span id='topic+print.hmrfout'></span><span id='topic+summary.hmrfout'></span><span id='topic+plot.hmrfout'></span>

<h3>Description</h3>

<p>MRF fitting functions output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmrfout'
print(x, ...)

## S3 method for class 'hmrfout'
summary(object, ...)

## S3 method for class 'hmrfout'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmrfout_+3A_x">x</code></td>
<td>
<p>a <code>hmrfout</code> object.</p>
</td></tr>
<tr><td><code id="hmrfout_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method.</p>
</td></tr>
<tr><td><code id="hmrfout_+3A_object">object</code></td>
<td>
<p>a <code>hmrfout</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='mrf2d-family'>Parameter restriction families</h2><span id='topic+mrf2d-family'></span>

<h3>Description</h3>

<p>Different parameter restrictions can be included in estimation processes
to make sure <code>mrf2d</code> can successfully include a wide range of model types in
its inference functions.
</p>
<p>For model identifiability, at least one linear restriction is necessary.
<code>mrf2d</code> always assume <code class="reqn">\theta_{0,0,r} = 0</code> for all relative positions
<code class="reqn">r</code>.
</p>
<p>Additionally, each family of restrictions may introduce other restrictions:
</p>


<h3>'onepar'</h3>

<p>This family assumes the model is defined by a single parameter
by adding the restriction
</p>
<p style="text-align: center;"><code class="reqn">\theta_{a,b,r} = \phi * 1(a != b).</code>
</p>

<p>Here <code class="reqn">1()</code> denotes de indicator function. In words, the parameter must
be the same value for any pair with different values and 0 for any
equal-valued pair.
</p>


<h3>'oneeach'</h3>

<p>Similar to <code>'onepar'</code>, parameters are 0 for equal-valued pairs and a
constant for pairs with different values, but the constant may differ
between different relative positions <code class="reqn">r</code>:
</p>
<p style="text-align: center;"><code class="reqn">\theta{a,b,r} = \phi_r * 1(a != b).</code>
</p>



<h3>'absdif'</h3>

<p>All parameters <code class="reqn">\theta_{a,b,r}</code> with the same absolute difference
between <code class="reqn">a</code> and <code class="reqn">b</code> must be equal within each relative position
<code class="reqn">r</code>. (Note that <code>'absdif'</code> is equal to <code>'oneeach'</code> for binary images).
</p>
<p style="text-align: center;"><code class="reqn">\theta_{a,b,r} = \sum_d \phi_{d,r} * 1(|a-b| == d)</code>
</p>



<h3>'dif'</h3>

<p>The same as <code>'absdif'</code>, but parameters may differ between positive and
negative differences.
</p>
<p style="text-align: center;"><code class="reqn">\theta_{a,b,r} = \sum_d \phi_{d,r} * 1(a-b == d)</code>
</p>



<h3>'free'</h3>

<p>No additional restriction, all parameters other than <code class="reqn">\theta_{0,0,r}</code>
vary freely.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p><code>vignette("mrf2d-family", package = "mrf2d")</code>
</p>
<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>

<hr>
<h2 id='mrf2d-package'>mrf2d: Markov Random Field Models for Image Analysis</h2><span id='topic+mrf2d'></span><span id='topic+mrf2d-package'></span>

<h3>Description</h3>

<p><code>mrf2d</code> contains tools for Markov Random Field models on
two-dimensional lattices.
</p>
<p>To learn more about <code>mrf2d</code>, read the paper at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Victor Freguglia <a href="mailto:victorfreguglia@gmail.com">victorfreguglia@gmail.com</a> (<a href="https://orcid.org/0000-0002-6189-4453">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Freguglia/mrf2d">https://github.com/Freguglia/mrf2d</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Freguglia/mrf2d/issues">https://github.com/Freguglia/mrf2d/issues</a>
</p>
</li></ul>


<hr>
<h2 id='mrfi-class'>mrfi: MRF interaction structure</h2><span id='topic+mrfi-class'></span><span id='topic+mrfi'></span><span id='topic+rpositions'></span><span id='topic+as.list.mrfi'></span><span id='topic+length+2Cmrfi-method'></span><span id='topic++5B+5B+2Cmrfi+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2Cmrfi+2Cnumeric+2Cmissing-method'></span><span id='topic++2B+2Cmrfi+2Cnumeric-method'></span><span id='topic+-+2Cmrfi+2Cnumeric-method'></span><span id='topic++2B+2Cmrfi+2Cmrfi-method'></span><span id='topic+-+2Cmrfi+2Cmrfi-method'></span><span id='topic+mrfi_to_string'></span>

<h3>Description</h3>

<p>The <code>mrfi</code> S4 class is a representation of the interaction
structure for a spatially-stationary Markov Random Field.
</p>
<p>The function <code><a href="#topic+mrfi">mrfi()</a></code> provides an interface for creation
<code>mrfi</code> objects. A <code>plot</code> method is also available for visualization, as
well as conversion methods like <code>as.list</code> and operators like <code>+</code>.
</p>
<p><code>mrfi()</code> creates an object of class <code>mrfi</code> based on a distance
rule and optionally a list of relative positions. The argument <code>max_norm</code> and
<code>norm_type</code> can be used to automatically include all positions within a
&quot;range&quot; defined by the norm type chosen and distance using that norm.
</p>
<p>A list of relative positions may also be included to specify sparse
interaction structures, for example. Alternatively, <code>rpositions()</code>
can be used to create a based exclusively on a list of relative positions.
</p>
<p>Simple operations are provided to include (set union)
new interacting positions to a <code>mrfi</code> object with the <code>'+'</code> operator and
remove positions (set difference) with <code>-</code>. Individual positions can be
included/excluded using length-2 vectors in the right hand side. Union and
set difference of complete structures can also be computed by adding or
subtracting two <code>mrfi</code> objects.
</p>
<p>These operations deal with opposite directions filtering to avoid redundancy
in the interaction structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrfi(max_norm = 1, norm_type = "1", positions = NULL)

rpositions(positions)

## S3 method for class 'mrfi'
as.list(x, ...)

## S4 method for signature 'mrfi'
length(x)

## S4 method for signature 'mrfi,numeric,missing'
x[[i]]

## S4 method for signature 'mrfi,numeric,missing'
x[i]

## S4 method for signature 'mrfi,numeric'
e1 + e2

## S4 method for signature 'mrfi,numeric'
e1 - e2

## S4 method for signature 'mrfi,mrfi'
e1 + e2

## S4 method for signature 'mrfi,mrfi'
e1 - e2

mrfi_to_string(mrfi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrfi-class_+3A_max_norm">max_norm</code></td>
<td>
<p>a <code>numeric</code> value. All points with norm <code class="reqn">\le</code> <code>max_dist</code>
are included.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_norm_type">norm_type</code></td>
<td>
<p>a <code>character</code> indicating the norm type used. Possible values
are &quot;m&quot;, &quot;1&quot;, &quot;2&quot;, etc. See <code><a href="Matrix.html#topic+norm">norm</a></code> for details.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_positions">positions</code></td>
<td>
<p>a <code>list</code> of <code>numeric</code> vectors of length 2. Each vector
corresponds to a relative position included.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_x">x</code></td>
<td>
<p><code>mrfi</code> object.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_i">i</code></td>
<td>
<p>vector of indexes to extract interacting positions.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_e1">e1</code>, <code id="mrfi-class_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code>mrfi</code> object.</p>
</td></tr>
<tr><td><code id="mrfi-class_+3A_e2">e2</code></td>
<td>
<p>Either a second <code>mrfi</code> object or a length 2 <code>numeric</code> with the new
relative position to include (<code>+</code>) or remove (<code>-</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interaction structure is defined by the list of relative
positions in it. For a specific pixel, conditional to the values of pixels in
these relative positions from it, its value is independent of any other pixel
in the image.
</p>
<p>The relative positions are indentified by two integers <code>rx</code> and <code>ry</code>
representing the &quot;shift&quot; in the <code>x</code>-axis and <code>y</code>-axis respectively. As an
example: The relative position <code style="white-space: pre;">&#8288;(1,0)&#8288;</code> representes the pixel in the immediate
right position, while <code style="white-space: pre;">&#8288;(-1,0)&#8288;</code> the left one.
</p>
<p>Note that the inclusion of a relative position to the dependence also implies
its opposite direction is not conditionally independent (commutativeness of
dependence), but only one is included in the <code>mrfi</code> object.
</p>
<p>To illustrate that, a nearest neighbor dependence structure can be specified
by:
</p>
<p><code>mrfi(1)</code>
</p>
<p>Note that it only includes the positions <code style="white-space: pre;">&#8288;(1,0)&#8288;</code> and <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>, but when
visualizing it, for example, <code>mrf2d</code> understands the opposite directions
are also conditionally dependent, as in
</p>
<p><code>plot(mrfi(1))</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object.
</p>
<p><code>as.list()</code>: converts the <code>mrfi</code> object to a list of interacting
positions (list of length-2 vectors).
</p>
<p><code>[[</code>: converts to list and subsets it.
</p>
<p><code>[</code>: subsets the <code>mrfi</code> object and returns another <code>mrfi</code> object.
</p>
<p><code>+</code>: computes the union of the interaction structure in a <code>mrfi</code> object with
a <code>numeric</code> representing an additional position to include or another <code>mrfi</code>
object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Rmat</code></dt><dd><p>A 2-column <code>matrix</code> where each row represents a relative position
of interaction.</p>
</dd>
</dl>


<h3>Note</h3>

<p>If a position in <code>positions</code> is already included due to the
<code>max_norm</code> and <code>norm_type</code> specification, the second ocurrence is ignored.
The same is valid for repeated or opposite positions in <code>positions</code>.
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(mrfi(max_norm = 2, norm_type = "1"))
plot(mrfi(max_norm = 2, norm_type = "m"))
plot(mrfi(max_norm = 2, norm_type = "1", positions = list(c(4,4))))

as.list(mrfi(1))
mrfi(1)[[1]]
mrfi(2)[[1:3]]

mrfi(1)
rpositions(list(c(1,0), c(0,1)))
mrfi(2)
mrfi(2, norm_type = "m")
mrfi(1, positions = list(c(4,4), c(-4,4)))


#Repeated positions are handled automatically
mrfi(1, positions = list(c(1,0), c(2,0)))

mrfi(1) + c(2,0)
mrfi(1) - c(1,0)
mrfi(1) + mrfi(0, positions = list(c(2,0)))
mrfi(2) - mrfi(1)
</code></pre>

<hr>
<h2 id='mrfout'>MRF fitting functions output</h2><span id='topic+mrfout'></span><span id='topic+print.mrfout'></span><span id='topic+summary.mrfout'></span><span id='topic+plot.mrfout'></span>

<h3>Description</h3>

<p>MRF fitting functions output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrfout'
print(x, ...)

## S3 method for class 'mrfout'
summary(object, ...)

## S3 method for class 'mrfout'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrfout_+3A_x">x</code></td>
<td>
<p>a <code>mrfout</code> object.</p>
</td></tr>
<tr><td><code id="mrfout_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method.</p>
</td></tr>
<tr><td><code id="mrfout_+3A_object">object</code></td>
<td>
<p>a <code>mrfout</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='pl_mrf2d'>Pseudo-likelihood function for MRFs on 2d lattices</h2><span id='topic+pl_mrf2d'></span>

<h3>Description</h3>

<p>Computes the pseudo-likelihood function of a Markov Random Field
on a 2-dimensional lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl_mrf2d(Z, mrfi, theta, log_scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pl_mrf2d_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> with integers in <code style="white-space: pre;">&#8288;{0,...,C}&#8288;</code>.</p>
</td></tr>
<tr><td><code id="pl_mrf2d_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="pl_mrf2d_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="pl_mrf2d_+3A_log_scale">log_scale</code></td>
<td>
<p>A <code>logical</code> value indicating whether the returned value
should be in logarithmic scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pseudo-likelihood function is defined as the product of
conditional probabilities of each pixel given its neighbors:
</p>
<p style="text-align: center;"><code class="reqn">\prod_i P(Z_i | Z_{{N}_i}, \theta).</code>
</p>



<h3>Value</h3>

<p>A <code>numeric</code> with the pseudo-likelihood value.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pl_mrf2d(Z_potts, mrfi(1), theta_potts)

</code></pre>

<hr>
<h2 id='plot.mrfi'>Plotting of <code>mrfi</code> objects.</h2><span id='topic+plot.mrfi'></span><span id='topic+mrfi-plot'></span>

<h3>Description</h3>

<p>Plots a visual representation of the interaction structure
described in a <code>mrfi</code> object. The black tile represents a reference pixel
and gray tiles are shown in relative positions with dependent pixels.
</p>
<p>A <code>ggplot</code> object is used, therefore, the user can load the <code>ggplot2</code>
package and add more <code>ggplot</code> layers to freely customize the <code>plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrfi'
plot(x, include_axis = FALSE, include_opposite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mrfi_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.mrfi_+3A_include_axis">include_axis</code></td>
<td>
<p><code>logical</code> indicating whether the axis and grid lines
are included. If <code>FALSE</code> <code>theme_void()</code> is added to the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plot.mrfi_+3A_include_opposite">include_opposite</code></td>
<td>
<p>´logical' whether opposite directions should be
included in the visualization of the dependence structure.</p>
</td></tr>
<tr><td><code id="plot.mrfi_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>data.frame</code> used for the <code>ggplot</code> call has columns names <code>rx</code>
and <code>ry</code> repŕesenting the relative positions.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object using <code>geom_tile()</code> to represent interacting
relative positions.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(mrfi(1))

library(ggplot2)
plot(mrfi(1)) + geom_tile(fill = "red")
plot(mrfi(1)) + geom_tile(fill = "blue") + theme_void()

plot(mrfi(1)) + geom_text(aes(label = paste0("(",rx,",",ry,")")))

</code></pre>

<hr>
<h2 id='rmrf2d'>Sampling of Markov Random Fields on 2d lattices</h2><span id='topic+rmrf2d'></span>

<h3>Description</h3>

<p>Performs pixelwise updates based on conditional distributions
to sample from a Markov random field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmrf2d(
  init_Z,
  mrfi,
  theta,
  cycles = 60,
  sub_region = NULL,
  fixed_region = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmrf2d_+3A_init_z">init_Z</code></td>
<td>
<p>One of two options:
</p>

<ul>
<li><p> A <code>matrix</code> object with the initial field configuration. Its
valuesmust be integers in <code style="white-space: pre;">&#8288;{0,...,C}&#8288;</code>.
</p>
</li>
<li><p> A length 2 <code>numeric</code> vector with the lattice dimensions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmrf2d_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="rmrf2d_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="rmrf2d_+3A_cycles">cycles</code></td>
<td>
<p>The number of updates to be done (for each each pixel).</p>
</td></tr>
<tr><td><code id="rmrf2d_+3A_sub_region">sub_region</code></td>
<td>
<p><code>NULL</code> if the whole lattice is considered or a <code>logical</code>
<code>matrix</code> with <code>TRUE</code> for pixels in the considered region.</p>
</td></tr>
<tr><td><code id="rmrf2d_+3A_fixed_region">fixed_region</code></td>
<td>
<p><code>NULL</code> if the whole lattice is to be sampled or a
<code>logical</code> <code>matrix</code> with <code>TRUE</code> for pixels to be considered fixed. Fixed
pixels are not updated in the Gibbs Sampler.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a Gibbs Sampling scheme to sample from
a Markov random field by iteratively sampling pixel values from the
conditional distribution
</p>
<p style="text-align: center;"><code class="reqn">P(Z_i | Z_{{N}_i}, \theta).</code>
</p>

<p>A cycle means exactly one update to each pixel. The order pixels are
sampled is randomized within each cycle.
</p>
<p>If <code>init_Z</code> is passed as a length 2 vector with lattice dimensions, the
initial field is sampled from independent discrete uniform distributions in
<code style="white-space: pre;">&#8288;{0,...,C}&#8288;</code>. The value of C is obtained from the number of rows/columns of
<code>theta</code>.
</p>
<p>A MRF can be sampled in a non-rectangular region of the lattice with the use of
the <code>sub_region</code> argument or by setting pixels to <code>NA</code> in the initial
configuration <code>init_Z</code>. Pixels with <code>NA</code> values in <code>init_Z</code> are completely
disconsidered from the conditional probabilities and have the same effect as
setting <code>sub_region = is.na(init_Z)</code>. If <code>init_Z</code> has <code>NA</code> values,
<code>sub_region</code> is ignored and a warning is produced.
</p>
<p>A specific region can be kept constant during the Gibbs Sampler by using the
<code>fixed_region</code> argument. Keeping a subset of pixels constant is useful when
you want to sample in a specific region of the image conditional to the
rest, for example, in texture synthesis problems.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the sampled field.
</p>


<h3>Note</h3>

<p>As in any Gibbs Sampling scheme, a large number of cycles may be
required to achieve the target distribution, specially for strong
interaction systems.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>.
</p>
<p><code><a href="#topic+rmrf2d_mc">rmrf2d_mc</a></code> for generating multiple points of a
Markov Chain to be used in Monte-Carlo methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample using specified lattice dimension
Z &lt;- rmrf2d(c(150,150), mrfi(1), theta_potts)

#Sample using itial configuration

Z2 &lt;- rmrf2d(Z, mrfi(1), theta_potts)

# View results
dplot(Z)
dplot(Z2)

# Using sub-regions
subreg &lt;- matrix(TRUE, 150, 150)
subreg &lt;- abs(row(subreg) - 75) + abs(col(subreg) - 75) &lt;= 80
# view the sub-region
dplot(subreg)

Z3 &lt;- rmrf2d(c(150,150), mrfi(1), theta_potts, sub_region = subreg)
dplot(Z3)

# Using fixed regions
fixreg &lt;- matrix(as.logical(diag(150)), 150, 150)
# Set initial configuration: diagonal values are 0.
init_Z4 &lt;- Z
init_Z4[fixreg] &lt;- 0

Z4 &lt;- rmrf2d(init_Z4, mrfi(1), theta_potts, fixed_region = fixreg)
dplot(Z4)

# Combine fixed regions and sub-regions
Z5 &lt;- rmrf2d(init_Z4, mrfi(1), theta_potts,
fixed_region = fixreg, sub_region = subreg)
dplot(Z5)


</code></pre>

<hr>
<h2 id='rmrf2d_mc'>Markov Chain sampling of MRFs for Monte-Carlo methods</h2><span id='topic+rmrf2d_mc'></span>

<h3>Description</h3>

<p>Generates a Markov Chain of random fields and returns the
sufficient statistics for each of the observations.
</p>
<p>This function automatizes the process of generating a random sample of MRFs
to be used in Monte-Carlo methods by wrapping <code><a href="#topic+rmrf2d">rmrf2d</a></code>
and executing it multiple time while storing sufficient statistics instead
of the entire lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmrf2d_mc(
  init_Z,
  mrfi,
  theta,
  family,
  nmc = 100,
  burnin = 100,
  cycles = 4,
  verbose = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmrf2d_mc_+3A_init_z">init_Z</code></td>
<td>
<p>One of two options:
</p>

<ul>
<li><p> A <code>matrix</code> object with the initial field configuration. Its
valuesmust be integers in <code style="white-space: pre;">&#8288;{0,...,C}&#8288;</code>.
</p>
</li>
<li><p> A length 2 <code>numeric</code> vector with the lattice dimensions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_family">family</code></td>
<td>
<p>The family of parameter restrictions to potentials. Families
are:
<code>'onepar'</code>, <code>'oneeach'</code>, <code>'absdif'</code>, <code>'dif'</code> or <code>'free'</code>.
See <code><a href="#topic+mrf2d-family">mrf2d-familiy</a></code>.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_nmc">nmc</code></td>
<td>
<p>Number of samples to be stored.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_burnin">burnin</code></td>
<td>
<p>Number of cycles iterated before start collecting sufficient
statistics.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_cycles">cycles</code></td>
<td>
<p>Number of cycles between collected samples.</p>
</td></tr>
<tr><td><code id="rmrf2d_mc_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating whether to print iteration number or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each row contains the vector of sufficient statistics
for an observation.
</p>


<h3>Note</h3>

<p>Fixed regions and incomplete lattices are not supported.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmrf2d_mc(c(80, 80), mrfi(1), theta_potts, family = "oneeach", nmc = 8)

</code></pre>

<hr>
<h2 id='smr_array'>Summarized representation of theta arrays</h2><span id='topic+smr_array'></span><span id='topic+expand_array'></span>

<h3>Description</h3>

<p><code>smr_array</code> creates a vector containing only the free parameters from an array
given a restriction <code><a href="#topic+mrf2d-family">family</a></code>. <code>exapand_array</code> is the reverse
operation, expanding a complete array from the vector of sufficient statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smr_array(theta, family)

expand_array(theta_vec, family, mrfi, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smr_array_+3A_theta">theta</code></td>
<td>
<p>A 3-dimensional array describing potentials. Slices represent
interacting positions, rows represent pixel values and columns represent
neighbor values. As an example: <code>theta[1,3,2]</code> has the potential for the
pair of values 0,2 observed in the second relative position of <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="smr_array_+3A_family">family</code></td>
<td>
<p>The family of parameter restrictions to potentials. Families
are:
<code>'onepar'</code>, <code>'oneeach'</code>, <code>'absdif'</code>, <code>'dif'</code> or <code>'free'</code>.
See <code><a href="#topic+mrf2d-family">mrf2d-familiy</a></code>.</p>
</td></tr>
<tr><td><code id="smr_array_+3A_theta_vec">theta_vec</code></td>
<td>
<p>A <code>numeric</code> vector with the free parameters of a potential
array. It's dimension depends on the restriction <code>family</code>, <code>C</code> and the number
of interacting positions on <code>mrfi</code>.</p>
</td></tr>
<tr><td><code id="smr_array_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="smr_array_+3A_c">C</code></td>
<td>
<p>The maximum value of the field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order the parameters appear in the summarized vector matches
the order in <code><a href="#topic+smr_stat">smr_stat()</a></code>.
</p>
<p><code>vec_description()</code> provides a <code>data.frame</code> object describing
which are the relative positions and interactions associated with each
element of the summarized vector in the same order.
</p>


<h3>Value</h3>

<p><code>smr_array</code> returns a numeric vector with the free parameters of <code>theta</code>.
</p>
<p><code>expand_array</code> returns a three-dimensional <code>array</code> of potentials.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smr_array(theta_potts, "onepar")
smr_array(theta_potts, "oneeach")

expand_array(0.99, family = "onepar", mrfi = mrfi(1), C = 2)
expand_array(c(0.1, 0.2), family = "oneeach", mrfi = mrfi(1), C = 3)

</code></pre>

<hr>
<h2 id='smr_stat'>Summary Statistics</h2><span id='topic+smr_stat'></span><span id='topic+cohist'></span><span id='topic+vec_description'></span>

<h3>Description</h3>

<p>Computes the summary count statistics of a field given an
interaction structure and a restriction family.
</p>

<ul>
<li> <p><code>cohist()</code> computes the co-ocurrence histogram.
</p>
</li>
<li> <p><code>smr_stat()</code> computes the co-ocurrence histogram, then converts it into
a vector of sufficient statistics given a <code><a href="#topic+mrf2d-family">family</a></code> of restrictions.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>smr_stat(Z, mrfi, family)

cohist(Z, mrfi)

vec_description(mrfi, family, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smr_stat_+3A_z">Z</code></td>
<td>
<p>A <code>matrix</code> object containing the observed MRF. <code>NA</code> values can be
used to create a subregion of the lattice for non-rectangular data.</p>
</td></tr>
<tr><td><code id="smr_stat_+3A_mrfi">mrfi</code></td>
<td>
<p>A <code><a href="#topic+mrfi-class">mrfi</a></code> object representing the
interaction structure.</p>
</td></tr>
<tr><td><code id="smr_stat_+3A_family">family</code></td>
<td>
<p>The family of parameter restrictions to potentials. Families
are:
<code>'onepar'</code>, <code>'oneeach'</code>, <code>'absdif'</code>, <code>'dif'</code> or <code>'free'</code>.
See <code><a href="#topic+mrf2d-family">mrf2d-familiy</a></code>.</p>
</td></tr>
<tr><td><code id="smr_stat_+3A_c">C</code></td>
<td>
<p>The maximum value of the field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order the summarized counts appear in the summary vector matches
the order in <code><a href="#topic+smr_array">smr_array()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the summarized counts.
</p>
<p>An array representing the co-ocurrence histogram of <code>Z</code> in the relative
positions contained in <code>mrfi</code>. Each row and column corresponds a pair of values
in <code style="white-space: pre;">&#8288;(0, ..., C)&#8288;</code> and each slice corresponds to
</p>
<p>A <code>data.frame</code> describing the relative position
and interaction associated with each potential in the vector
form in each row, in the same order.
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>See Also</h3>

<p>A paper with detailed description of the package can be found at
doi: <a href="https://doi.org/10.18637/jss.v101.i08">10.18637/jss.v101.i08</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smr_stat(Z_potts, mrfi(1), "onepar")
smr_stat(Z_potts, mrfi(1), "oneeach")

cohist(Z_potts, mrfi(1))

</code></pre>

<hr>
<h2 id='Z_potts'>Example objects from <code>mrf2d</code></h2><span id='topic+Z_potts'></span><span id='topic+theta_potts'></span>

<h3>Description</h3>

<p><code>Z_potts</code> and <code>theta_potts</code> are example objects for <code>mrf2d</code>.
</p>
<p><code>Z_potts</code> is a <code>matrix</code> object containing an observed lattice of a 3 color
(C = 2) Potts model.
</p>
<p><code>theta_potts</code> is the parameter array used to sample it,
it consists of a configuration with one parameter (-1.0) and two relative
positions (to be used with a nearest-neighbor structure).
</p>


<h3>Author(s)</h3>

<p>Victor Freguglia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta_potts
dplot(Z_potts)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
