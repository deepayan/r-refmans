<!DOCTYPE html><html lang="en"><head><title>Help for package evolqg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evolqg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evolqg'><p>EvolQG</p></a></li>
<li><a href='#AlphaRep'><p>Alpha repeatability</p></a></li>
<li><a href='#BayesianCalculateMatrix'><p>Calculate Covariance Matrix from a linear model fitted with lm() using different estimators</p></a></li>
<li><a href='#BootstrapR2'><p>R2 confidence intervals by bootstrap resampling</p></a></li>
<li><a href='#BootstrapRep'><p>Bootstrap analysis via resampling</p></a></li>
<li><a href='#BootstrapStat'><p>Non-Parametric population samples and statistic comparison</p></a></li>
<li><a href='#CalcAVG'><p>Calculates mean correlations within- and between-modules</p></a></li>
<li><a href='#CalcEigenVar'><p>Integration measure based on eigenvalue dispersion</p></a></li>
<li><a href='#CalcICV'><p>Calculates the ICV of a covariance matrix.</p></a></li>
<li><a href='#CalcR2'><p>Mean Squared Correlations</p></a></li>
<li><a href='#CalcR2CvCorrected'><p>Corrected integration value</p></a></li>
<li><a href='#CalcRepeatability'><p>Parametric per trait repeatabilities</p></a></li>
<li><a href='#CalculateMatrix'><p>Calculate Covariance Matrix from a linear model fitted with lm()</p></a></li>
<li><a href='#Center2MeanJacobianFast'><p>Centered jacobian residuals</p></a></li>
<li><a href='#ComparisonMap'><p>Generic Comparison Map functions for creating parallel list methods</p>
Internal functions for making eficient comparisons.</a></li>
<li><a href='#CreateHypotMatrix'><p>Creates binary correlation matrices</p></a></li>
<li><a href='#DeltaZCorr'><p>Compare matrices via the correlation between response vectors</p></a></li>
<li><a href='#dentus'><p>Example multivariate data set</p></a></li>
<li><a href='#dentus.tree'><p>Tree for dentus example species</p></a></li>
<li><a href='#DriftTest'><p>Test drift hypothesis</p></a></li>
<li><a href='#EigenTensorDecomposition'><p>Eigentensor Decomposition</p></a></li>
<li><a href='#ExtendMatrix'><p>Control Inverse matrix noise with Extension</p></a></li>
<li><a href='#JacobianArray'><p>Local Jacobian calculation</p></a></li>
<li><a href='#KrzCor'><p>Compare matrices via Krzanowski Correlation</p></a></li>
<li><a href='#KrzProjection'><p>Compare matrices via Modified Krzanowski Correlation</p></a></li>
<li><a href='#KrzSubspace'><p>Krzanowski common subspaces analysis</p></a></li>
<li><a href='#KrzSubspaceBootstrap'><p>Quasi-Bayesian Krzanowski subspace comparison</p></a></li>
<li><a href='#KrzSubspaceDataFrame'><p>Extract confidence intervals from KrzSubspaceBootstrap</p></a></li>
<li><a href='#LModularity'><p>L Modularity</p></a></li>
<li><a href='#LocalShapeVariables'><p>Local Shape Variables</p></a></li>
<li><a href='#MantelCor'><p>Compare matrices via Mantel Correlation</p></a></li>
<li><a href='#MantelModTest'><p>Test single modularity hypothesis using Mantel correlation</p></a></li>
<li><a href='#MatrixCompare'><p>Matrix Compare</p></a></li>
<li><a href='#MatrixDistance'><p>Matrix distance</p></a></li>
<li><a href='#MeanMatrix'><p>Mean Covariance Matrix</p></a></li>
<li><a href='#MeanMatrixStatistics'><p>Calculate mean values for various matrix statistics</p></a></li>
<li><a href='#MINT'><p>Modularity and integration analysis tool</p></a></li>
<li><a href='#MonteCarloR2'><p>R2 confidence intervals by parametric sampling</p></a></li>
<li><a href='#MonteCarloRep'><p>Parametric repeatabilities with covariance or correlation matrices</p></a></li>
<li><a href='#MonteCarloStat'><p>Parametric population samples with covariance or correlation matrices</p></a></li>
<li><a href='#MultiMahalanobis'><p>Calculate Mahalonabis distance for many vectors</p></a></li>
<li><a href='#MultivDriftTest'><p>Multivariate genetic drift test for 2 populations</p></a></li>
<li><a href='#Normalize'><p>Normalize and Norm</p></a></li>
<li><a href='#OverlapDist'><p>Distribution overlap distance</p></a></li>
<li><a href='#Partition2HypotMatrix'><p>Create binary hypothesis</p></a></li>
<li><a href='#PCAsimilarity'><p>Compare matrices using PCA similarity factor</p></a></li>
<li><a href='#PCScoreCorrelation'><p>PC Score Correlation Test</p></a></li>
<li><a href='#PhyloCompare'><p>Compares sister groups</p></a></li>
<li><a href='#PhyloMantel'><p>Mantel test with phylogenetic permutations</p></a></li>
<li><a href='#PhyloW'><p>Calculates ancestral states of some statistic</p></a></li>
<li><a href='#PlotKrzSubspace'><p>Plot KrzSubspace boostrap comparison</p></a></li>
<li><a href='#PlotRarefaction'><p>Plot Rarefaction analysis</p></a></li>
<li><a href='#PlotTreeDriftTest'><p>Plot results from TreeDriftTest</p></a></li>
<li><a href='#PrintMatrix'><p>Print Matrix to file</p></a></li>
<li><a href='#ProjectMatrix'><p>Project Covariance Matrix</p></a></li>
<li><a href='#RandCorr'><p>Random correlation matrix</p></a></li>
<li><a href='#RandomMatrix'><p>Random matrices for tests</p></a></li>
<li><a href='#RandomSkewers'><p>Compare matrices via RandomSkewers</p></a></li>
<li><a href='#Rarefaction'><p>Rarefaction analysis via resampling</p></a></li>
<li><a href='#RarefactionStat'><p>Non-Parametric rarefacted population samples and statistic comparison</p></a></li>
<li><a href='#ratones'><p>Linear distances for five mouse lines</p></a></li>
<li><a href='#RelativeEigenanalysis'><p>Relative Eigenanalysis</p></a></li>
<li><a href='#RemoveSize'><p>Remove Size Variation</p></a></li>
<li><a href='#RevertMatrix'><p>Revert Matrix</p></a></li>
<li><a href='#RiemannDist'><p>Matrix Riemann distance</p></a></li>
<li><a href='#Rotate2MidlineMatrix'><p>Midline rotate</p></a></li>
<li><a href='#RSProjection'><p>Random Skewers projection</p></a></li>
<li><a href='#SingleComparisonMap'><p>Generic Single Comparison Map functions for creating parallel list methods</p>
Internal functions for making efficient comparisons.</a></li>
<li><a href='#SRD'><p>Compare matrices via Selection Response Decomposition</p></a></li>
<li><a href='#TestModularity'><p>Test modularity hypothesis</p></a></li>
<li><a href='#TPS'><p>TPS transform</p></a></li>
<li><a href='#TreeDriftTest'><p>Drift test along phylogeny</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Evolutionary Quantitative Genetics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for covariance matrix comparisons, estimation of repeatabilities in measurements and matrices, and general evolutionary quantitative genetics tools. Melo D, Garcia G, Hubbe A, Assis A P, Marroig G. (2016) &lt;<a href="https://doi.org/10.12688%2Ff1000research.7082.3">doi:10.12688/f1000research.7082.3</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), plyr (&ge; 1.7.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, reshape2, ggplot2, vegan, ape, expm, numDeriv, Morpho,
mvtnorm, coda, igraph, MCMCpack, graphics, grDevices, methods,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, testthat, foreach, grid, gridExtra, doParallel,
cowplot</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lem-usp/evolqg/issues">https://github.com/lem-usp/evolqg/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 16:03:22 UTC; diogro</td>
</tr>
<tr>
<td>Author:</td>
<td>Diogo Melo <a href="https://orcid.org/0000-0002-7603-0092"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Ana Paula Assis [aut],
  Edgar Zanella [ctb],
  Fabio Andrade Machado
    <a href="https://orcid.org/0000-0002-0215-9926"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Guilherme Garcia [aut],
  Alex Hubbe <a href="https://orcid.org/0000-0002-3226-0144"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Gabriel Marroig <a href="https://orcid.org/0000-0003-2542-2034"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diogo Melo &lt;diogro@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 15:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='evolqg'>EvolQG</h2><span id='topic+evolqg'></span><span id='topic+evolqg-package'></span>

<h3>Description</h3>

<p>The package for evolutionary quantitative genetics.
</p>

<hr>
<h2 id='AlphaRep'>Alpha repeatability</h2><span id='topic+AlphaRep'></span>

<h3>Description</h3>

<p>Calculates the matrix repeatability using the equation in Cheverud 1996
Quantitative genetic analysis of cranial morphology in the cotton-top
(Saguinus oedipus) and saddle-back (S. fuscicollis) tamarins. Journal of Evolutionary Biology 9, 5-42.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlphaRep(cor.matrix, sample.size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AlphaRep_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="AlphaRep_+3A_sample.size">sample.size</code></td>
<td>
<p>Sample size used in matrix estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Alpha repeatability for correlation matrix
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Cheverud 1996 Quantitative genetic analysis of cranial morphology in the cotton-top
(Saguinus oedipus) and saddle-back (S. fuscicollis) tamarins. Journal of Evolutionary Biology 9, 5-42.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MonteCarloStat">MonteCarloStat</a></code>, <code><a href="#topic+BootstrapRep">BootstrapRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For single matrices
cor.matrix &lt;- RandomMatrix(10)
AlphaRep(cor.matrix, 10)
AlphaRep(cor.matrix, 100)
#For many matrices
mat.list &lt;- RandomMatrix(10, 100)
sample.sizes &lt;- floor(runif(100, 20, 50))
unlist(Map(AlphaRep, mat.list, sample.sizes))
</code></pre>

<hr>
<h2 id='BayesianCalculateMatrix'>Calculate Covariance Matrix from a linear model fitted with lm() using different estimators</h2><span id='topic+BayesianCalculateMatrix'></span>

<h3>Description</h3>

<p>Calculates covariance matrix using the maximum likelihood estimator, the maximum a posteriori (MAP)
estimator under a regularized Wishart prior, and if the sample is large enough can give samples from the 
posterior and the median posterior estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesianCalculateMatrix(linear.m, samples = NULL, ..., nu = NULL, S_0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesianCalculateMatrix_+3A_linear.m">linear.m</code></td>
<td>
<p>Linear model adjusted for original data</p>
</td></tr>
<tr><td><code id="BayesianCalculateMatrix_+3A_samples">samples</code></td>
<td>
<p>number os samples to be generated from the posterior. Requires sample size to be at least as large as the number of dimensions</p>
</td></tr>
<tr><td><code id="BayesianCalculateMatrix_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored</p>
</td></tr>
<tr><td><code id="BayesianCalculateMatrix_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom in prior distribution, defaults to the number of traits (this can be a too strong prior)</p>
</td></tr>
<tr><td><code id="BayesianCalculateMatrix_+3A_s_0">S_0</code></td>
<td>
<p>cross product matrix of the prior. Default is to use the observed variances and zero covariance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated covariance matrices and posterior samples
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Fabio Machado
</p>


<h3>References</h3>

<p>Murphy, K. P. (2012). Machine learning: a probabilistic perspective. MIT press.
</p>
<p>Schafer, J., e Strimmer, K. (2005). A shrinkage approach to large-scale covariance matrix estimation and implications for functional genomics. Statistical applications in genetics and molecular biology, 4(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
iris.lm = lm(as.matrix(iris[,1:4])~iris[,5])
matrices &lt;- BayesianCalculateMatrix(iris.lm, nu = 0.1, samples = 100)

</code></pre>

<hr>
<h2 id='BootstrapR2'>R2 confidence intervals by bootstrap resampling</h2><span id='topic+BootstrapR2'></span>

<h3>Description</h3>

<p>Random populations are generated by  resampling 
the suplied data or residuals. R2 is calculated on all the
random population's correlation matrices, provinding a distribution based on the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapR2(ind.data, iterations = 1000, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootstrapR2_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or indiviual measurments</p>
</td></tr>
<tr><td><code id="BootstrapR2_+3A_iterations">iterations</code></td>
<td>
<p>Number of resamples to take</p>
</td></tr>
<tr><td><code id="BootstrapR2_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the R2 for all populations
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r2.dist &lt;- BootstrapR2(iris[,1:4], 30)
quantile(r2.dist)
</code></pre>

<hr>
<h2 id='BootstrapRep'>Bootstrap analysis via resampling</h2><span id='topic+BootstrapRep'></span>

<h3>Description</h3>

<p>Calculates the repeatability of the covariance matrix of the supplied data
via bootstrap resampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapRep(
  ind.data,
  ComparisonFunc,
  iterations = 1000,
  sample.size = dim(ind.data)[1],
  correlation = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootstrapRep_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or individual measurements</p>
</td></tr>
<tr><td><code id="BootstrapRep_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function</p>
</td></tr>
<tr><td><code id="BootstrapRep_+3A_iterations">iterations</code></td>
<td>
<p>Number of resamples to take</p>
</td></tr>
<tr><td><code id="BootstrapRep_+3A_sample.size">sample.size</code></td>
<td>
<p>Size of resamples, default is the same size as ind.data</p>
</td></tr>
<tr><td><code id="BootstrapRep_+3A_correlation">correlation</code></td>
<td>
<p>If TRUE, correlation matrix is used, else covariance matrix.</p>
</td></tr>
<tr><td><code id="BootstrapRep_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples with replacement are taken from the full population, a statistic calculated
and compared to the full population statistic.
</p>


<h3>Value</h3>

<p>returns the mean repeatability, that is, the mean value of comparisons from samples to original statistic.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MonteCarloStat">MonteCarloStat</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BootstrapRep(iris[,1:4], MantelCor, iterations = 5, correlation = TRUE)
             
BootstrapRep(iris[,1:4], RandomSkewers, iterations = 50)

BootstrapRep(iris[,1:4], KrzCor, iterations = 50, correlation = TRUE)

BootstrapRep(iris[,1:4], PCAsimilarity, iterations = 50)

#Multiple threads can be used with some foreach backend library, like doMC or doParallel
#library(doParallel)
##Windows:
#cl &lt;- makeCluster(2)
#registerDoParallel(cl)
##Mac and Linux:
#registerDoParallel(cores = 2)
#BootstrapRep(iris[,1:4], PCAsimilarity,
#             iterations = 5,
#             parallel = TRUE)
</code></pre>

<hr>
<h2 id='BootstrapStat'>Non-Parametric population samples and statistic comparison</h2><span id='topic+BootstrapStat'></span>

<h3>Description</h3>

<p>Random populations are generated via ressampling 
using the suplied population. A statistic is calculated on the
random population and compared to the statistic calculated on the
original population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapStat(
  ind.data,
  iterations,
  ComparisonFunc,
  StatFunc,
  sample.size = dim(ind.data)[1],
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootstrapStat_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or indiviual measurments</p>
</td></tr>
<tr><td><code id="BootstrapStat_+3A_iterations">iterations</code></td>
<td>
<p>Number of resamples to take</p>
</td></tr>
<tr><td><code id="BootstrapStat_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function</p>
</td></tr>
<tr><td><code id="BootstrapStat_+3A_statfunc">StatFunc</code></td>
<td>
<p>Function for calculating the statistic</p>
</td></tr>
<tr><td><code id="BootstrapStat_+3A_sample.size">sample.size</code></td>
<td>
<p>Size of ressamples, default is the same size as ind.data</p>
</td></tr>
<tr><td><code id="BootstrapStat_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the mean repeatability, that is, the mean value of comparisons from samples to original statistic.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(5, 1, 1, 10)

BootstrapStat(iris[,1:4], iterations = 50,
               ComparisonFunc = function(x, y) PCAsimilarity(x, y)[1],
               StatFunc = cov)

#Calculating R2 confidence intervals
r2.dist &lt;- BootstrapR2(iris[,1:4], 30)
quantile(r2.dist)

#Multiple threads can be used with some foreach backend library, like doMC or doParallel
#library(doParallel)
##Windows:
#cl &lt;- makeCluster(2)
#registerDoParallel(cl)
##Mac and Linux:
#registerDoParallel(cores = 2)
#BootstrapStat(iris[,1:4], iterations = 100,
#               ComparisonFunc = function(x, y) KrzCor(x, y)[1],
#               StatFunc = cov,
#               parallel = TRUE)
</code></pre>

<hr>
<h2 id='CalcAVG'>Calculates mean correlations within- and between-modules</h2><span id='topic+CalcAVG'></span>

<h3>Description</h3>

<p>Uses a binary correlation matrix as a mask to calculate average within- and between-module
correlations. Also calculates the ratio between them and the Modularity Hypothesis Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcAVG(cor.hypothesis, cor.matrix, MHI = TRUE, landmark.dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcAVG_+3A_cor.hypothesis">cor.hypothesis</code></td>
<td>
<p>Hypothetical correlation matrix, with 1s within-modules and 0s between modules</p>
</td></tr>
<tr><td><code id="CalcAVG_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>Observed empirical correlation matrix.</p>
</td></tr>
<tr><td><code id="CalcAVG_+3A_mhi">MHI</code></td>
<td>
<p>Indicates if Modularity Hypothesis Index should be calculated instead of AVG Ratio.</p>
</td></tr>
<tr><td><code id="CalcAVG_+3A_landmark.dim">landmark.dim</code></td>
<td>
<p>Used if within-landmark correlations are to be excluded in geometric morphometric data. Either 2 for 2d data or 3 for 3d data. Default is NULL for non geometric morphomotric data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with the mean correlations and derived statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Module vectors
modules = matrix(c(rep(c(1, 0, 0), each = 5),
                   rep(c(0, 1, 0), each = 5),
                   rep(c(0, 0, 1), each = 5)), 15)

# Binary modular matrix
cor.hypot = CreateHypotMatrix(modules)[[4]]

# Modular correlation matrix
hypot.mask = matrix(as.logical(cor.hypot), 15, 15)
mod.cor = matrix(NA, 15, 15)
mod.cor[ hypot.mask] = runif(length(mod.cor[ hypot.mask]), 0.8, 0.9) # within-modules
mod.cor[!hypot.mask] = runif(length(mod.cor[!hypot.mask]), 0.3, 0.4) # between-modules
diag(mod.cor) = 1
mod.cor = (mod.cor + t(mod.cor))/2 # correlation matrices should be symmetric

CalcAVG(cor.hypot, mod.cor)
CalcAVG(cor.hypot, mod.cor, MHI = TRUE)
</code></pre>

<hr>
<h2 id='CalcEigenVar'>Integration measure based on eigenvalue dispersion</h2><span id='topic+CalcEigenVar'></span>

<h3>Description</h3>

<p>Calculates integration indexes based on eigenvalue dispersion of covariance 
or correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcEigenVar(
  matrix,
  sd = FALSE,
  rel = TRUE,
  sample = NULL,
  keep.positive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcEigenVar_+3A_matrix">matrix</code></td>
<td>
<p>Covariance/correlation matrix</p>
</td></tr>
<tr><td><code id="CalcEigenVar_+3A_sd">sd</code></td>
<td>
<p>Logical. Default is FALSE. If TRUE, estimates eigenvalue standard 
deviation. If FALSE, estimate the eigenvalue variance.</p>
</td></tr>
<tr><td><code id="CalcEigenVar_+3A_rel">rel</code></td>
<td>
<p>Logical. If TRUE, scales eigenvalue dispersion value by the 
theoretical maximum.</p>
</td></tr>
<tr><td><code id="CalcEigenVar_+3A_sample">sample</code></td>
<td>
<p>Default is NULL. If a integer is provided, function calculates 
the expected integration value for that particular sample size and returns 
value as a deviation from the expected.</p>
</td></tr>
<tr><td><code id="CalcEigenVar_+3A_keep.positive">keep.positive</code></td>
<td>
<p>Logical. If TRUE, non-positive eigenvalues are removed from calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function quantifies morphological integration as the dispersion 
of eigenvalues in a matrix. It takes either a
covariance or a correlation matrix as input, and there is no need to discern 
between them.The output will depend on the combination of parameters 
specified during input. 
</p>
<p>As default, the function calculates the relative eigenvalue variance of the 
matrix, which expresses the eigenvalue variance as a ratio between the 
actual variance and the theoretical maximum for a matrix of the same size 
and same amount of variance (same trace), following Machado et al. (2019). If 
sd=TRUE, the dispersion is measured with the standard deviation of 
eigenvalues instead of the variance (Pavlicev, 2009). If the sample size is 
provided, the function automatically calculates the expected integration 
value for a matrix of the same size but with no integration (e.g. a matrix 
with all eigenvalues equal). In that case, the result is given as a deviation 
from the expected and is invariant to sample size (Wagner, 1984).
</p>


<h3>Value</h3>

<p>Integration index based on eigenvalue dispersion.
</p>


<h3>Author(s)</h3>

<p>Fabio Andrade Machado
</p>
<p>Diogo Melo
</p>


<h3>References</h3>

<p>Machado, Fabio A., Alex Hubbe, Diogo Melo, Arthur Porto, and 
Gabriel Marroig. 2019. &quot;Measuring the magnitude of morphological 
integration: The effect of differences in morphometric representations and 
the inclusion of size.&quot; Evolution 33:402–411.
</p>
<p>Pavlicev, Mihaela, James M. Cheverud, and Gunter P. Wagner. 2009.
&quot;Measuring Morphological Integration Using Eigenvalue Variance.&quot; Evolutionary
Biology 36(1):157-170.
</p>
<p>Wagner, Gunther P. 1984. &quot;On the eigenvalue distribution of 
genetic and phenotypic dispersion matrices: evidence for a nonrandom 
organization of quantitative character variation.&quot; Journal of Mathematical 
Biology 21(1):77–95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalcR2">CalcR2</a></code>, <code><a href="#topic+CalcICV">CalcICV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(10, 1, 1, 10)
# calculates the relative eigenvalue variance of a covariance matrix
CalcEigenVar(cov.matrix)

# calculates the relative eigenvalue variance of a correlation matrix
CalcEigenVar(cov2cor(cov.matrix))

# calculates the relative eigenvalue standard deviation of a covariance 
# matrix
CalcEigenVar(cov.matrix, sd=TRUE)

# calculates the absolute eigenvalue variance of a covariance matrix
CalcEigenVar(cov.matrix, rel=FALSE)

# to evaluate the effect of sampling error on integration
x&lt;-mvtnorm::rmvnorm(10, sigma=cov.matrix)
sample_cov.matrix&lt;-var(x)

# to contrast values of integration obtained from population covariance 
# matrix
CalcEigenVar(cov.matrix)
# with the sample integration
CalcEigenVar(sample_cov.matrix)
# and with the integration measured corrected for sampling error
CalcEigenVar(sample_cov.matrix,sample=10)

</code></pre>

<hr>
<h2 id='CalcICV'>Calculates the ICV of a covariance matrix.</h2><span id='topic+CalcICV'></span>

<h3>Description</h3>

<p>Calculates the coefficient of variation of the eigenvalues of a covariance matrix, a measure of
integration comparable to the R^2 in correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcICV(cov.matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcICV_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: CalcEigenVar is strongly preferred and should probably be used in place of this function.
</p>


<h3>Value</h3>

<p>coefficient of variation of the eigenvalues of a covariance matrix
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>References</h3>

<p>Shirai, Leila T, and Gabriel Marroig. 2010. &quot;Skull Modularity in Neotropical Marsupials and Monkeys: Size Variation and Evolutionary Constraint and Flexibility.&quot; Journal of Experimental Zoology Part B: Molecular and Developmental Evolution 314 B (8): 663-83. doi:10.1002/jez.b.21367.
</p>
<p>Porto, Arthur, Leila Teruko Shirai, Felipe Bandoni de Oliveira, and Gabriel Marroig. 2013. &quot;Size Variation, Growth Strategies, and the Evolution of Modularity in the Mammalian Skull.&quot; Evolution 67 (July): 3305-22. doi:10.1111/evo.12177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalcR2">CalcR2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(10, 1, 1, 10)
CalcICV(cov.matrix)
</code></pre>

<hr>
<h2 id='CalcR2'>Mean Squared Correlations</h2><span id='topic+CalcR2'></span>

<h3>Description</h3>

<p>Calculates the mean squared correlation of a covariance or correlation matrix. Measures integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcR2(c.matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcR2_+3A_c.matrix">c.matrix</code></td>
<td>
<p>Covariance or correlation matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: CalcEigenVar is strongly preferred and should probably be used in place of this function.
</p>


<h3>Value</h3>

<p>Mean squared value of off diagonal elements of correlation matrix
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Porto, Arthur, Felipe B. de Oliveira, Leila T. Shirai, Valderes de Conto, and Gabriel Marroig. 2009. &quot;The Evolution of Modularity in the Mammalian Skull I: Morphological Integration Patterns and Magnitudes.&quot; Evolutionary Biology 36 (1): 118-35. doi:10.1007/s11692-008-9038-3.
</p>
<p>Porto, Arthur, Leila Teruko Shirai, Felipe Bandoni de Oliveira, and Gabriel Marroig. 2013. &quot;Size Variation, Growth Strategies, and the Evolution of Modularity in the Mammalian Skull.&quot; Evolution 67 (July): 3305-22. doi:10.1111/evo.12177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Flexibility">Flexibility</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(10, 1, 1, 10)

# both of the following calls are equivalent,
# CalcR2 converts covariance matrices to correlation matrices internally
CalcR2(cov.matrix)
CalcR2(cov2cor(cov.matrix))
</code></pre>

<hr>
<h2 id='CalcR2CvCorrected'>Corrected integration value</h2><span id='topic+CalcR2CvCorrected'></span><span id='topic+CalcR2CvCorrected.default'></span><span id='topic+CalcR2CvCorrected.lm'></span>

<h3>Description</h3>

<p>Calculates the Young correction for integration, using bootstrap resampling
Warning: CalcEigenVar is strongly preferred and should probably be used in place of this function..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcR2CvCorrected(ind.data, ...)

## Default S3 method:
CalcR2CvCorrected(
  ind.data,
  cv.level = 0.06,
  iterations = 1000,
  parallel = FALSE,
  ...
)

## S3 method for class 'lm'
CalcR2CvCorrected(ind.data, cv.level = 0.06, iterations = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcR2CvCorrected_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of individual measurments, or adjusted linear model</p>
</td></tr>
<tr><td><code id="CalcR2CvCorrected_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="CalcR2CvCorrected_+3A_cv.level">cv.level</code></td>
<td>
<p>Coefficient of variation level chosen for integration index adjustment in linear model. Defaults to 0.06.</p>
</td></tr>
<tr><td><code id="CalcR2CvCorrected_+3A_iterations">iterations</code></td>
<td>
<p>Number of resamples to take</p>
</td></tr>
<tr><td><code id="CalcR2CvCorrected_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with adjusted integration indexes, fitted models and simulated distributions of integration indexes and mean coefficient of variation.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Young, N. M., Wagner, G. P., and Hallgrimsson, B. (2010).
Development and the evolvability of human limbs. Proceedings of the
National Academy of Sciences of the United States of America, 107(8),
3400-5. doi:10.1073/pnas.0911856107
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MeanMatrixStatistics">MeanMatrixStatistics</a></code>, <code><a href="#topic+CalcR2">CalcR2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
integration.dist = CalcR2CvCorrected(iris[,1:4])

#adjusted values
integration.dist[[1]]

#ploting models
library(ggplot2)
ggplot(integration.dist$dist, aes(r2, mean_cv)) + geom_point() +
       geom_smooth(method = 'lm', color= 'black') + theme_bw()

ggplot(integration.dist$dist, aes(eVals_cv, mean_cv)) + geom_point() +
       geom_smooth(method = 'lm', color= 'black') + theme_bw()

## End(Not run)
</code></pre>

<hr>
<h2 id='CalcRepeatability'>Parametric per trait repeatabilities</h2><span id='topic+CalcRepeatability'></span>

<h3>Description</h3>

<p>Estimates the variance in the sample not due to measurement error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcRepeatability(ID, ind.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcRepeatability_+3A_id">ID</code></td>
<td>
<p>identity of individuals</p>
</td></tr>
<tr><td><code id="CalcRepeatability_+3A_ind.data">ind.data</code></td>
<td>
<p>individual measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of repeatabilities
</p>


<h3>Note</h3>

<p>Requires at least two observations per individual
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>


<h3>References</h3>

<p>Lessels, C. M., and Boag, P. T. (1987).
Unrepeatable repeatabilities: a common mistake.
The Auk, 2(January), 116-121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num.ind = length(iris[,1])
ID = rep(1:num.ind, 2)
ind.data = rbind(iris[,1:4], iris[,1:4]+array(rnorm(num.ind*4, 0, 0.1), dim(iris[,1:4])))
CalcRepeatability(ID, ind.data)
</code></pre>

<hr>
<h2 id='CalculateMatrix'>Calculate Covariance Matrix from a linear model fitted with lm()</h2><span id='topic+CalculateMatrix'></span>

<h3>Description</h3>

<p>Calculates covariance matrix using the maximum likelihood estimator and the model residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateMatrix(linear.m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateMatrix_+3A_linear.m">linear.m</code></td>
<td>
<p>Linear model adjusted for original data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Fabio Machado
</p>


<h3>References</h3>

<p>https://github.com/lem-usp/evolqg/wiki/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
old &lt;- options(contrasts=c("contr.sum","contr.poly"))
iris.lm = lm(as.matrix(iris[,1:4])~iris[,5])
cov.matrix &lt;- CalculateMatrix(iris.lm)
options(old)  

#To obtain a corrlation matrix, use:
cor.matrix &lt;- cov2cor(cov.matrix)
</code></pre>

<hr>
<h2 id='Center2MeanJacobianFast'>Centered jacobian residuals</h2><span id='topic+Center2MeanJacobianFast'></span>

<h3>Description</h3>

<p>Calculates mean jacobian matrix for a set of jacobian matrices
describing a local aspect of shape deformation for a given set of volumes,
returning log determinants of deviations from mean jacobian (Woods, 2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Center2MeanJacobianFast(jacobArray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Center2MeanJacobianFast_+3A_jacobarray">jacobArray</code></td>
<td>
<p>Arrays of Jacobian calculated in the JacobianArray function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of centered residual jacobians
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>
<p>Diogo Melo
</p>


<h3>References</h3>

<p>Woods, Roger P. 2003. “Characterizing Volume and Surface
Deformations in an Atlas Framework: Theory, Applications, and Implementation.” NeuroImage 18 (3):769-88.
</p>

<hr>
<h2 id='ComparisonMap'>Generic Comparison Map functions for creating parallel list methods
Internal functions for making eficient comparisons.</h2><span id='topic+ComparisonMap'></span>

<h3>Description</h3>

<p>Generic Comparison Map functions for creating parallel list methods
Internal functions for making eficient comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparisonMap(
  matrix.list,
  MatrixCompFunc,
  ...,
  repeat.vector = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComparisonMap_+3A_matrix.list">matrix.list</code></td>
<td>
<p>list of matrices being compared</p>
</td></tr>
<tr><td><code id="ComparisonMap_+3A_matrixcompfunc">MatrixCompFunc</code></td>
<td>
<p>Function used to compare pair of matrices, must output a vector: comparisons and probabilities</p>
</td></tr>
<tr><td><code id="ComparisonMap_+3A_...">...</code></td>
<td>
<p>Aditional arguments to MatrixCompFunc</p>
</td></tr>
<tr><td><code id="ComparisonMap_+3A_repeat.vector">repeat.vector</code></td>
<td>
<p>Vector of repeatabilities for correlation correction.</p>
</td></tr>
<tr><td><code id="ComparisonMap_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of comparisons, matrix of probabilities.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MantelCor">MantelCor</a></code>, <code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>
</p>

<hr>
<h2 id='CreateHypotMatrix'>Creates binary correlation matrices</h2><span id='topic+CreateHypotMatrix'></span>

<h3>Description</h3>

<p>Takes a binary vector or column matrix and generates list of binary correlation matrices representing
the partition in the vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateHypotMatrix(modularity.hypot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateHypotMatrix_+3A_modularity.hypot">modularity.hypot</code></td>
<td>
<p>Matrix of hypothesis. Each line represents a trait and each column a module.
if modularity.hypot[i,j] == 1, trait i is in module j.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>binary matrix or list of binary matrices. If a matrix is passed, all the vectors are combined in the 
last binary matrix (total hypothesis of full integration hypothesis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rand.hypots &lt;- matrix(sample(c(1, 0), 30, replace=TRUE), 10, 3)
CreateHypotMatrix(rand.hypots) 
</code></pre>

<hr>
<h2 id='DeltaZCorr'>Compare matrices via the correlation between response vectors</h2><span id='topic+DeltaZCorr'></span><span id='topic+DeltaZCorr.default'></span><span id='topic+DeltaZCorr.list'></span>

<h3>Description</h3>

<p>Compares the expected response to selection for two matrices for a specific set of
selection gradients (not random gradients like in the RandomSkewers method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaZCorr(cov.x, cov.y, skewers, ...)

## Default S3 method:
DeltaZCorr(cov.x, cov.y, skewers, ...)

## S3 method for class 'list'
DeltaZCorr(cov.x, cov.y = NULL, skewers, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaZCorr_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix or list of covariance matrices.
If single matrix is supplied, it is compared to cov.y.
If list is supplied and no cov.y is supplied, all matrices
are compared.
If cov.y is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="DeltaZCorr_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.
Optional if cov.x is a list.</p>
</td></tr>
<tr><td><code id="DeltaZCorr_+3A_skewers">skewers</code></td>
<td>
<p>matrix of column vectors to be used as gradients</p>
</td></tr>
<tr><td><code id="DeltaZCorr_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="DeltaZCorr_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of vector correlations between the expected responses for the two matrices for each supplied vector
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Cheverud, J. M., and Marroig, G. (2007). Comparing covariance matrices:
Random skewers method compared to the common principal components model.
Genetics and Molecular Biology, 30, 461-469.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>,,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- RandomMatrix(10, 1, 1, 10)
y &lt;- RandomMatrix(10, 1, 1, 10)

n_skewers = 10
skewers = matrix(rnorm(10*n_skewers), 10, n_skewers)
DeltaZCorr(x, y, skewers)

</code></pre>

<hr>
<h2 id='dentus'>Example multivariate data set</h2><span id='topic+dentus'></span>

<h3>Description</h3>

<p>Simulated example of 4 continuous bone lengths from 5 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dentus)
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows and 5 variables
</p>


<h3>Details</h3>


<ul>
<li><p> humerus 
</p>
</li>
<li><p> ulna 
</p>
</li>
<li><p> femur 
</p>
</li>
<li><p> tibia 
</p>
</li>
<li><p> species 
</p>
</li></ul>


<hr>
<h2 id='dentus.tree'>Tree for dentus example species</h2><span id='topic+dentus.tree'></span>

<h3>Description</h3>

<p>Hypothetical tree for the species in the dentus data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dentus.tree)
</code></pre>


<h3>Format</h3>

<p>ape tree object
</p>

<hr>
<h2 id='DriftTest'>Test drift hypothesis</h2><span id='topic+DriftTest'></span>

<h3>Description</h3>

<p>Given a set of covariance matrices and means for terminals, test the hypothesis
that observed divergence is larger/smaller than expected by drift alone using a regression of
the between-group variances on the within-group eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DriftTest(means, cov.matrix, show.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DriftTest_+3A_means">means</code></td>
<td>
<p>list or array of species means being compared. array must have means in the rows.</p>
</td></tr>
<tr><td><code id="DriftTest_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>ancestral covariance matrix for all populations</p>
</td></tr>
<tr><td><code id="DriftTest_+3A_show.plot">show.plot</code></td>
<td>
<p>Logical. If TRUE, plot of eigenvalues of ancestral matrix by between group variance is showed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results containing:
</p>
<p>regression: the linear regression between the log of the eigenvalues of the ancestral matrix and the log of the between group variance (projected on the eigenvectors of the ancestral matrix)
</p>
<p>coefficient_CI_95: confidence intervals for the regression coefficients
</p>
<p>log.between_group_variance: log of the between group variance (projected on the ancestral matrix eigenvectors)
</p>
<p>log.W_eVals: log of the ancestral matrix eigenvalues
</p>
<p>plot: plot of the regression using ggplot2
</p>


<h3>Note</h3>

<p>If the regression coefficient is significantly different to one, the null hypothesis of drift is rejected.
</p>


<h3>Author(s)</h3>

<p>Ana Paula Assis, Diogo Melo
</p>


<h3>References</h3>

<p>Marroig, G., and Cheverud, J. M. (2004). Did natural selection or genetic drift 
produce the cranial diversification of neotropical monkeys? The American Naturalist, 163(3), 417-428. doi:10.1086/381693
</p>
<p>Proa, M., O'Higgins, P. and Monteiro, L. R. (2013), Type I error rates for testing genetic drift with phenotypic covariance matrices: A simulation study. Evolution, 67: 185-195. doi: 10.1111/j.1558-5646.2012.01746.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Input can be an array with means in each row or a list of mean vectors
means = array(rnorm(40*10), c(10, 40)) 
cov.matrix = RandomMatrix(40, 1, 1, 10)
DriftTest(means, cov.matrix)
</code></pre>

<hr>
<h2 id='EigenTensorDecomposition'>Eigentensor Decomposition</h2><span id='topic+EigenTensorDecomposition'></span><span id='topic+EigenTensorDecomposition.list'></span><span id='topic+EigenTensorDecomposition.default'></span>

<h3>Description</h3>

<p>This function performs eigentensor decomposition on a set of covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EigenTensorDecomposition(matrices, return.projection = TRUE, ...)

## S3 method for class 'list'
EigenTensorDecomposition(matrices, return.projection = TRUE, ...)

## Default S3 method:
EigenTensorDecomposition(matrices, return.projection = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EigenTensorDecomposition_+3A_matrices">matrices</code></td>
<td>
<p>k x k x m array of m covariance matrices with k traits;</p>
</td></tr>
<tr><td><code id="EigenTensorDecomposition_+3A_return.projection">return.projection</code></td>
<td>
<p>Should we project covariance matrices into estimated eigentensors? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="EigenTensorDecomposition_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of estimated eigentensors is the minimum between the number of data points (m) and 
the number of independent variables (k(k + 1)/2) minus one, in a similar manner to the usual 
principal component analysis.
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<p>mean mean covariance matrices used to center the sample (obtained from <code><a href="#topic+MeanMatrix">MeanMatrix</a></code>)
</p>
<p>mean.sqrt square root of mean matrix (saved for use in other functions, 
such as <code><a href="#topic+ProjectMatrix">ProjectMatrix</a></code> and <code><a href="#topic+RevertMatrix">RevertMatrix</a></code>)
</p>
<p>values vector of ordered eigenvalues associated with eigentensors;
</p>
<p>matrices array of eigentensor in matrix form;
</p>
<p>projection matrix of unstandardized projected covariance matrices over eigentensors.
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia, Diogo Melo
</p>


<h3>References</h3>

<p>Basser P. J., Pajevic S. 2007. Spectral decomposition of a 4th-order 
covariance tensor: Applications to diffusion tensor MRI. Signal Processing. 87:220-236.
</p>
<p>Hine E., Chenoweth S. F., Rundle H. D., Blows M. W. 2009. Characterizing 
the evolution of genetic variance using genetic covariance tensors. Philosophical 
transactions of the Royal Society of London. Series B, Biological sciences. 364:1567-78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjectMatrix">ProjectMatrix</a></code>, <code><a href="#topic+RevertMatrix">RevertMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dentus)

dentus.vcv &lt;- daply (dentus, .(species), function(x) cov(x[,-5]))

dentus.vcv &lt;- aperm(dentus.vcv, c(2, 3, 1))

dentus.etd &lt;- EigenTensorDecomposition(dentus.vcv, TRUE)

# Plot some results
oldpar &lt;- par(mfrow = c(1,2))  
plot(dentus.etd $ values, pch = 20, type = 'b', ylab = 'Eigenvalue')
plot(dentus.etd $ projection [, 1:2], pch = 20, 
     xlab = 'Eigentensor 1', ylab = 'Eigentensor 2')
text(dentus.etd $ projection [, 1:2],
     labels = rownames (dentus.etd $ projection), pos = 2)
par(oldpar)  


# we can also deal with posterior samples of covariance matrices using plyr

dentus.models &lt;- dlply(dentus, .(species), 
                       lm, formula = cbind(humerus, ulna, femur, tibia) ~ 1)

dentus.matrices &lt;- llply(dentus.models, BayesianCalculateMatrix, samples = 100)

dentus.post.vcv &lt;- laply(dentus.matrices, function (L) L $ Ps)

dentus.post.vcv &lt;- aperm(dentus.post.vcv, c(3, 4, 1, 2))

# this will perform one eigentensor decomposition for each set of posterior samples
dentus.post.etd &lt;- alply(dentus.post.vcv, 4, EigenTensorDecomposition)

# which would allow us to observe the posterior 
# distribution of associated eigenvalues, for example
dentus.post.eval &lt;- laply (dentus.post.etd, function (L) L $ values)

boxplot(dentus.post.eval, xlab = 'Index', ylab = 'Value', 
        main = 'Posterior Eigenvalue Distribution')

</code></pre>

<hr>
<h2 id='ExtendMatrix'>Control Inverse matrix noise with Extension</h2><span id='topic+ExtendMatrix'></span>

<h3>Description</h3>

<p>Calculates the extended covariance matrix estimation as described in Marroig et al. 2012
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtendMatrix(cov.matrix, var.cut.off = 1e-04, ret.dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExtendMatrix_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="ExtendMatrix_+3A_var.cut.off">var.cut.off</code></td>
<td>
<p>Cut off for second derivative variance. Ignored if ret.dim is passed.</p>
</td></tr>
<tr><td><code id="ExtendMatrix_+3A_ret.dim">ret.dim</code></td>
<td>
<p>Number of retained eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extended covariance matrix and second derivative variance
</p>


<h3>Note</h3>

<p>Covariance matrix being extended should be larger then 10x10
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>References</h3>

<p>Marroig, G., Melo, D. A. R., and Garcia, G. (2012). Modularity, noise, and natural selection. Evolution; international journal of organic evolution, 66(5), 1506-24. doi:10.1111/j.1558-5646.2011.01555.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix = RandomMatrix(11, 1, 1, 100)
ext.matrix = ExtendMatrix(cov.matrix, var.cut.off = 1e-6)
ext.matrix = ExtendMatrix(cov.matrix, ret.dim = 6)
</code></pre>

<hr>
<h2 id='JacobianArray'>Local Jacobian calculation</h2><span id='topic+JacobianArray'></span>

<h3>Description</h3>

<p>Calculates jacobians for a given interpolation in a set of points
determined from tesselation (as centroids of each tetrahedron defined, for now...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JacobianArray(spline, tesselation, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JacobianArray_+3A_spline">spline</code></td>
<td>
<p>Thin plate spline calculated by the TPS function</p>
</td></tr>
<tr><td><code id="JacobianArray_+3A_tesselation">tesselation</code></td>
<td>
<p>matrix of landmarks.</p>
</td></tr>
<tr><td><code id="JacobianArray_+3A_...">...</code></td>
<td>
<p>Additional arguments to some function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of jacobians calculated at the centroids
</p>


<h3>Note</h3>

<p>Jacobians are calculated on the row centroids of the tesselation matrix.
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>

<hr>
<h2 id='KrzCor'>Compare matrices via Krzanowski Correlation</h2><span id='topic+KrzCor'></span><span id='topic+KrzCor.default'></span><span id='topic+KrzCor.list'></span><span id='topic+KrzCor.mcmc_sample'></span>

<h3>Description</h3>

<p>Calculates covariance matrix correlation via Krzanowski Correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrzCor(cov.x, cov.y, ...)

## Default S3 method:
KrzCor(cov.x, cov.y, ret.dim = NULL, ...)

## S3 method for class 'list'
KrzCor(
  cov.x,
  cov.y = NULL,
  ret.dim = NULL,
  repeat.vector = NULL,
  parallel = FALSE,
  ...
)

## S3 method for class 'mcmc_sample'
KrzCor(cov.x, cov.y, ret.dim = NULL, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KrzCor_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix or list of covariance matrices.
If single matrix is supplied, it is compared to cov.y.
If list is supplied and no cov.y is suplied, all matrices
are compared to each other.
If cov.y is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="KrzCor_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.
Optional if cov.x is a list.</p>
</td></tr>
<tr><td><code id="KrzCor_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="KrzCor_+3A_ret.dim">ret.dim</code></td>
<td>
<p>number of retained dimensions in the comparison,
default for nxn matrix is n/2-1</p>
</td></tr>
<tr><td><code id="KrzCor_+3A_repeat.vector">repeat.vector</code></td>
<td>
<p>Vector of repeatabilities for correlation correction.</p>
</td></tr>
<tr><td><code id="KrzCor_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE and a list is passed, computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If cov.x and cov.y are passed, returns Krzanowski correlation
</p>
<p>If cov.x is a list and cov.y is passed, same as above, but for all matrices in cov.x.
</p>
<p>If only a list is passed to cov.x, a matrix of Krzanowski correlation
values.
If repeat.vector is passed, comparison matrix is corrected above
diagonal and repeatabilities returned in diagonal.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Krzanowski, W. J. (1979). Between-Groups Comparison of Principal
Components. Journal of the American Statistical Association, 74(367),
703. doi:10.2307/2286995
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RandomSkewers">RandomSkewers</a></code>,<code><a href="#topic+KrzProjection">KrzProjection</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10, 1, 1, 10)
c2 &lt;- RandomMatrix(10, 1, 1, 10)
c3 &lt;- RandomMatrix(10, 1, 1, 10)
KrzCor(c1, c2)

KrzCor(list(c1, c2, c3))

reps &lt;- unlist(lapply(list(c1, c2, c3), MonteCarloRep, 10, KrzCor, iterations = 10))
KrzCor(list(c1, c2, c3), repeat.vector = reps)

c4 &lt;- RandomMatrix(10)
KrzCor(list(c1, c2, c3), c4)


## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
KrzCor(list(c1, c2, c3), parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='KrzProjection'>Compare matrices via Modified Krzanowski Correlation</h2><span id='topic+KrzProjection'></span><span id='topic+KrzProjection.default'></span><span id='topic+KrzProjection.list'></span>

<h3>Description</h3>

<p>Calculates the modified Krzanowski correlation between matrices,
projecting the variance in each principal  components of the first
matrix in to the ret.dim.2 components of the second matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrzProjection(cov.x, cov.y, ...)

## Default S3 method:
KrzProjection(cov.x, cov.y, ret.dim.1 = NULL, ret.dim.2 = NULL, ...)

## S3 method for class 'list'
KrzProjection(
  cov.x,
  cov.y = NULL,
  ret.dim.1 = NULL,
  ret.dim.2 = NULL,
  parallel = FALSE,
  full.results = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KrzProjection_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix ou list of covariance matrices.
If cov.x is a single matrix is supplied, it is compared to cov.y.
If cov.x is a list of matrices is supplied and no cov.y is supplied, all matrices
are compared between each other.
If cov.x is a list of matrices and a single cov.y matrix is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.
If cov.x is a list, every element in cov.x is projected in cov.y.</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_ret.dim.1">ret.dim.1</code></td>
<td>
<p>number of retained dimensions for first matrix in comparison, default for nxn matrix is n/2-1</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_ret.dim.2">ret.dim.2</code></td>
<td>
<p>number of retained dimensions for second matrix in comparison, default for nxn matrix is n/2-1</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
<tr><td><code id="KrzProjection_+3A_full.results">full.results</code></td>
<td>
<p>if FALSE returns only total variance, if TRUE also per PC variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ratio of projected variance to total variance, and ratio of projected total in each PC
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Krzanowski, W. J. (1979). Between-Groups Comparison of Principal
Components. Journal of the American Statistical Association, 74(367),
703. doi:10.2307/2286995
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RandomSkewers">RandomSkewers</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10)
c2 &lt;- RandomMatrix(10)
KrzProjection(c1, c2)


m.list &lt;- RandomMatrix(10, 3)
KrzProjection(m.list)
KrzProjection(m.list, full.results = TRUE)
KrzProjection(m.list, ret.dim.1 = 5, ret.dim.2 = 4)
KrzProjection(m.list, ret.dim.1 = 4, ret.dim.2 = 5)

KrzProjection(m.list, c1)
KrzProjection(m.list, c1, full.results = TRUE)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
KrzProjection(m.list, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='KrzSubspace'>Krzanowski common subspaces analysis</h2><span id='topic+KrzSubspace'></span>

<h3>Description</h3>

<p>Calculates the subspace most similar across a set of covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrzSubspace(cov.matrices, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KrzSubspace_+3A_cov.matrices">cov.matrices</code></td>
<td>
<p>list of covariance matrices</p>
</td></tr>
<tr><td><code id="KrzSubspace_+3A_k">k</code></td>
<td>
<p>number of dimensions to be retained in calculating the subspace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>H shared space matrix
</p>
<p>k_eVals_H eigen values for shared space matrix, maximum value for each is the number of matrices, representing a fully shared direction
</p>
<p>k_eVecs_H eigen vectors of shared space matrix
</p>
<p>angles between each population subspace and each eigen vector of shared space matrix
</p>


<h3>Note</h3>

<p>can be used to implement the Bayesian comparison from Aguirre et al. 2014
</p>


<h3>References</h3>

<p>Aguirre, J. D., E. Hine, K. McGuigan, and M. W. Blows. &quot;Comparing G: multivariate analysis of genetic variation in multiple populations.&quot; Heredity 112, no. 1 (2014): 21-29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dentus)
dentus.matrices = dlply(dentus, .(species), function(x) cov(x[-5]))
KrzSubspace(dentus.matrices, k = 2)

## Not run: 
# The method in Aguirre et al. 2014 can de implemented using this function as follows:

#Random input data with dimensions traits x traits x populations x MCMCsamples:
cov.matrices = aperm(aaply(1:10, 1, function(x) laply(RandomMatrix(6, 40,                    
                                                      variance = runif(6,1, 10)), 
                           identity)), 
                     c(3, 4, 1, 2))
   
Hs = alply(cov.matrices, 4, function(x) alply(x, 3)) |&gt; llply(function(x) KrzSubspace(x, 3)$H)
avgH = Reduce("+", Hs)/length(Hs)
avgH.vec &lt;- eigen(avgH)$vectors
MCMC.H.val = laply(Hs, function(mat) diag(t(avgH.vec) %*% mat %*% avgH.vec))

# confidence intervals for variation in shared subspace directions
library(coda)
HPDinterval(as.mcmc(MCMC.H.val))    

## End(Not run)
</code></pre>

<hr>
<h2 id='KrzSubspaceBootstrap'>Quasi-Bayesian Krzanowski subspace comparison</h2><span id='topic+KrzSubspaceBootstrap'></span>

<h3>Description</h3>

<p>Calculates the usual Krzanowski subspace comparison using a posterior samples
for a set of phenotypic covariance matrices. Then, this observed comparison 
is contrasted to the subspace comparison across a permutation of the original
data. Residuals, which are used to calculate the observed P-matrices, are 
shuffled across groups. This process is repeated, creating a null distribution
of  subspace comparisons under the hypothesis that all P-matrices come from the
same population. This method is a modification on the fully Bayesian method 
proposed in Aguirre et. al 2013 and improved in Morrisey et al 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrzSubspaceBootstrap(x, rep = 1, MCMCsamples = 1000, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KrzSubspaceBootstrap_+3A_x">x</code></td>
<td>
<p>list of linear models from which P-matrices should be calculated</p>
</td></tr>
<tr><td><code id="KrzSubspaceBootstrap_+3A_rep">rep</code></td>
<td>
<p>number of bootstrap samples to be made</p>
</td></tr>
<tr><td><code id="KrzSubspaceBootstrap_+3A_mcmcsamples">MCMCsamples</code></td>
<td>
<p>number of MCMCsamples for each P-matrix posterior distribution.</p>
</td></tr>
<tr><td><code id="KrzSubspaceBootstrap_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the observed and randomized eigenvalue distributions for the posterior Krz Subspace comparisons.
</p>


<h3>References</h3>

<p>Aguirre, J. D., E. Hine, K. McGuigan, and M. W. Blows. 2013. “Comparing G: multivariate analysis of genetic variation in multiple populations.” Heredity 112 (February): 21–29.
</p>
<p>Morrissey, Michael B., Sandra Hangartner, and Keyne Monro. 2019. “A Note on Simulating Null Distributions for G Matrix Comparisons.” Evolution; International Journal of Organic Evolution 73 (12): 2512–17.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzSubspaceDataFrame">KrzSubspaceDataFrame</a></code>, <code><a href="#topic+PlotKrzSubspace">PlotKrzSubspace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(plyr)
data(ratones)

model_formula = paste("cbind(", paste(names(ratones)[13:20], collapse = ", "), ") ~ SEX")
lm_models = dlply(ratones, .(LIN), function(df) lm(as.formula(model_formula), data = df))
krz_comparsion = KrzSubspaceBootstrap(lm_models, rep = 100, MCMCsamples = 1000)
krz_df = KrzSubspaceDataFrame(krz_comparsion)
PlotKrzSubspace(krz_df)

</code></pre>

<hr>
<h2 id='KrzSubspaceDataFrame'>Extract confidence intervals from KrzSubspaceBootstrap</h2><span id='topic+KrzSubspaceDataFrame'></span>

<h3>Description</h3>

<p>Returns posterior means and confidence intervals from the object produced by the KrzSubspaceBootstrap() function. Mainly used for ploting using PlotKrzSubspace. 
See example in the KrzSubspaceBootstrap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrzSubspaceDataFrame(x, n = ncol(observed), prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KrzSubspaceDataFrame_+3A_x">x</code></td>
<td>
<p>output from KrzSubspaceBootstrap function.</p>
</td></tr>
<tr><td><code id="KrzSubspaceDataFrame_+3A_n">n</code></td>
<td>
<p>number of eigenvalues to use</p>
</td></tr>
<tr><td><code id="KrzSubspaceDataFrame_+3A_prob">prob</code></td>
<td>
<p>Posterior probability interval. Default is 95%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Posterior intervals for the eigenvalues of the H matrix in the KrzSubspace comparison.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzSubspaceBootstrap">KrzSubspaceBootstrap</a></code>, <code><a href="#topic+PlotKrzSubspace">PlotKrzSubspace</a></code>
</p>

<hr>
<h2 id='LModularity'>L Modularity</h2><span id='topic+LModularity'></span>

<h3>Description</h3>

<p>Calculates the L-Modularity (Newman-type modularity) and the partition of traits that minimizes L-Modularity. Wrapper for using correlations matrices in community detection algorithms from igraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LModularity(cor.matrix, method = optimal.community, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LModularity_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>correlation matrix</p>
</td></tr>
<tr><td><code id="LModularity_+3A_method">method</code></td>
<td>
<p>community detection function</p>
</td></tr>
<tr><td><code id="LModularity_+3A_...">...</code></td>
<td>
<p>Additional arguments to igraph community detection function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: Using modularity maximization is almost always a terrible idea. See: https://skewed.de/tiago/blog/modularity-harmful
</p>


<h3>Value</h3>

<p>List with L-Modularity value and trait partition
</p>


<h3>Note</h3>

<p>Community detection is done by transforming the correlation matrix into a weighted graph and using community detection algorithms on this graph. Default method is optimal but slow. See igraph documentation for other options.
</p>
<p>If negative correlations are present, the square of the correlation matrix is used as weights.
</p>


<h3>References</h3>

<p>Modularity and community structure in networks (2006) M. E. J. Newman,  8577-8582, doi: 10.1073/pnas.0601602103
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A modular matrix:
modules = matrix(c(rep(c(1, 0, 0), each = 5),
rep(c(0, 1, 0), each = 5),
rep(c(0, 0, 1), each = 5)), 15)
cor.hypot = CreateHypotMatrix(modules)[[4]]
hypot.mask = matrix(as.logical(cor.hypot), 15, 15)
mod.cor = matrix(NA, 15, 15)
mod.cor[ hypot.mask] = runif(length(mod.cor[ hypot.mask]), 0.8, 0.9) # within-modules
mod.cor[!hypot.mask] = runif(length(mod.cor[!hypot.mask]), 0.3, 0.4) # between-modules
diag(mod.cor) = 1
mod.cor = (mod.cor + t(mod.cor))/2 # correlation matrices should be symmetric

# requires a custom igraph installation with GLPK installed in the system
LModularity(mod.cor)
## End(Not run)
</code></pre>

<hr>
<h2 id='LocalShapeVariables'>Local Shape Variables</h2><span id='topic+LocalShapeVariables'></span>

<h3>Description</h3>

<p>Calculates the local shape variables of a set of landmarks using the sequence:
- TPS transform between all shapes and the mean shape
- Jacobian of the TPS transforms at the centroid of rows of the landmarks in the tesselation argument
- Mean center the Jacobians using the Karcher Mean
- Take the determinant of the centered jacobians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalShapeVariables(
  gpa = NULL,
  cs = NULL,
  landmarks = NULL,
  tesselation,
  run_parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocalShapeVariables_+3A_gpa">gpa</code></td>
<td>
<p>Procustes aligned landmarks.</p>
</td></tr>
<tr><td><code id="LocalShapeVariables_+3A_cs">cs</code></td>
<td>
<p>Centoid sizes</p>
</td></tr>
<tr><td><code id="LocalShapeVariables_+3A_landmarks">landmarks</code></td>
<td>
<p>unaligned landmarks. Ignored if both gpa and cs are passed.</p>
</td></tr>
<tr><td><code id="LocalShapeVariables_+3A_tesselation">tesselation</code></td>
<td>
<p>matrix of rows of the landmarks. The centroid of each row
is used to mark the position of the jacobians</p>
</td></tr>
<tr><td><code id="LocalShapeVariables_+3A_run_parallel">run_parallel</code></td>
<td>
<p>Logical. If computation should be paralleled. Use with
caution, can make things worse. Requires that at parallel back-end like doMC
be registered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with TPS functions, jacobian matrices, local shape variables, mean shape, centroid sizes and individual IDs
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>
<p>Diogo Melo
</p>

<hr>
<h2 id='MantelCor'>Compare matrices via Mantel Correlation</h2><span id='topic+MantelCor'></span><span id='topic+MantelCor.default'></span><span id='topic+MantelCor.list'></span><span id='topic+MantelCor.mcmc_sample'></span><span id='topic+MatrixCor'></span><span id='topic+MatrixCor.default'></span><span id='topic+MatrixCor.list'></span><span id='topic+MatrixCor.mcmc_sample'></span>

<h3>Description</h3>

<p>Calculates correlation matrix correlation and significance via Mantel test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MantelCor(cor.x, cor.y, ...)

## Default S3 method:
MantelCor(
  cor.x,
  cor.y,
  permutations = 1000,
  ...,
  landmark.dim = NULL,
  withinLandmark = FALSE,
  mod = FALSE
)

## S3 method for class 'list'
MantelCor(
  cor.x,
  cor.y = NULL,
  permutations = 1000,
  repeat.vector = NULL,
  parallel = FALSE,
  ...
)

## S3 method for class 'mcmc_sample'
MantelCor(cor.x, cor.y, ..., parallel = FALSE)

MatrixCor(cor.x, cor.y, ...)

## Default S3 method:
MatrixCor(cor.x, cor.y, ...)

## S3 method for class 'list'
MatrixCor(
  cor.x,
  cor.y = NULL,
  permutations = 1000,
  repeat.vector = NULL,
  parallel = FALSE,
  ...
)

## S3 method for class 'mcmc_sample'
MatrixCor(cor.x, cor.y, ..., parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MantelCor_+3A_cor.x">cor.x</code></td>
<td>
<p>Single correlation matrix or list of correlation matrices.
</p>
<p>If single matrix is supplied, it is compared to cor.y.
</p>
<p>If list is supplied and no cor.y is supplied, all matrices
are compared.
</p>
<p>If cor.y is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_cor.y">cor.y</code></td>
<td>
<p>First argument is compared to cor.y.
Optional if cor.x is a list.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations used in significance calculation.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_landmark.dim">landmark.dim</code></td>
<td>
<p>Used if permutations should be performed maintaining landmark structure in geometric morphometric data. Either 2 for 2d data or 3 for 3d data. Default is NULL for non geometric morphomotric data.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_withinlandmark">withinLandmark</code></td>
<td>
<p>Logical. If TRUE within-landmark correlations are used in the calculation of matrix correlation. Only used if landmark.dim is passed, default is FALSE.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_mod">mod</code></td>
<td>
<p>Set TRUE to use mantel in testing modularity hypothesis. Should only be used in MantelModTest.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_repeat.vector">repeat.vector</code></td>
<td>
<p>Vector of repeatabilities for correlation correction.</p>
</td></tr>
<tr><td><code id="MantelCor_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If cor.x and cor.y are passed, returns matrix Pearson
correlation coefficient and significance via Mantel permutations.
</p>
<p>If cor.x is a list of matrices and cor.y is passed, same as above, but for all matrices in cor.x.
</p>
<p>If only cor.x is passed, a matrix of MantelCor average
values and probabilities of all comparisons.
If repeat.vector is passed, comparison matrix is corrected above
diagonal and repeatabilities returned in diagonal.
</p>


<h3>Note</h3>

<p>If the significance is not needed, MatrixCor provides the
correlation and skips the permutations, so it is much faster.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Mantel_test
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>,<code><a href="vegan.html#topic+mantel">mantel</a></code>,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>,<code><a href="#topic+TestModularity">TestModularity</a></code>, <code><a href="#topic+MantelModTest">MantelModTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10, 1, 1, 10)
c2 &lt;- RandomMatrix(10, 1, 1, 10)
c3 &lt;- RandomMatrix(10, 1, 1, 10)
MantelCor(cov2cor(c1), cov2cor(c2))

cov.list &lt;- list(c1, c2, c3)
cor.list &lt;- llply(list(c1, c2, c3), cov2cor)

MantelCor(cor.list)

# For repeatabilities we can use MatrixCor, which skips the significance calculation
reps &lt;- unlist(lapply(cov.list, MonteCarloRep, 10, MatrixCor, correlation = TRUE))
MantelCor(cor.list, repeat.vector = reps)

c4 &lt;- RandomMatrix(10)
MantelCor(cor.list, c4)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
MantelCor(cor.list, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MantelModTest'>Test single modularity hypothesis using Mantel correlation</h2><span id='topic+MantelModTest'></span><span id='topic+MantelModTest.default'></span><span id='topic+MantelModTest.list'></span>

<h3>Description</h3>

<p>Calculates the correlation and Mantel significance test between a hypothetical binary modularity
matrix and a correlation matrix. Also gives mean correlation within- and between-modules. 
This function is usually only called by TestModularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MantelModTest(cor.hypothesis, cor.matrix, ...)

## Default S3 method:
MantelModTest(
  cor.hypothesis,
  cor.matrix,
  permutations = 1000,
  MHI = FALSE,
  ...,
  landmark.dim = NULL,
  withinLandmark = FALSE
)

## S3 method for class 'list'
MantelModTest(
  cor.hypothesis,
  cor.matrix,
  permutations = 1000,
  MHI = FALSE,
  landmark.dim = NULL,
  withinLandmark = FALSE,
  ...,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MantelModTest_+3A_cor.hypothesis">cor.hypothesis</code></td>
<td>
<p>Hypothetical correlation matrix, with 1s within-modules and 0s between modules.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>Observed empirical correlation matrix.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_...">...</code></td>
<td>
<p>additional arguments passed to MantelCor</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations used in significance calculation.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_mhi">MHI</code></td>
<td>
<p>Indicates if Modularity Hypothesis Index should be calculated instead of AVG Ratio.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_landmark.dim">landmark.dim</code></td>
<td>
<p>Used if permutations should be performed maintaining landmark structure in geometric morphometric data. Either 2 for 2d data or 3 for 3d data. Default is NULL for non geometric morphometric data.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_withinlandmark">withinLandmark</code></td>
<td>
<p>Logical. If TRUE within-landmark correlation are used in calculation of correlation. Only used if landmark.dim is passed, default is FALSE.</p>
</td></tr>
<tr><td><code id="MantelModTest_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CalcAVG can be used when a significance test is not required.
</p>


<h3>Value</h3>

<p>Returns a vector with the matrix correlation, significance via Mantel, within- and between module correlation.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Porto, Arthur, Felipe B. Oliveira, Leila T. Shirai, Valderes Conto, and Gabriel Marroig. 2009. &quot;The Evolution of Modularity in the Mammalian Skull I: Morphological Integration Patterns and Magnitudes.&quot; Evolutionary Biology 36 (1): 118-35. doi:10.1007/s11692-008-9038-3.
</p>
<p>Modularity and Morphometrics: Error Rates in Hypothesis Testing Guilherme Garcia, Felipe Bandoni de Oliveira, Gabriel Marroig bioRxiv 030874; doi: http://dx.doi.org/10.1101/030874
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+mantel">mantel</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>,<code><a href="#topic+CalcAVG">CalcAVG</a></code>,<code><a href="#topic+TestModularity">TestModularity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a single modularity hypothesis:
hypot = rep(c(1, 0), each = 6)
cor.hypot = CreateHypotMatrix(hypot)

# First with an unstructured matrix:
un.cor = RandomMatrix(12)
MantelModTest(cor.hypot, un.cor)

# Now with a modular matrix:
hypot.mask = matrix(as.logical(cor.hypot), 12, 12)
mod.cor = matrix(NA, 12, 12)
mod.cor[ hypot.mask] = runif(length(mod.cor[ hypot.mask]), 0.8, 0.9) # within-modules
mod.cor[!hypot.mask] = runif(length(mod.cor[!hypot.mask]), 0.3, 0.4) # between-modules
diag(mod.cor) = 1
mod.cor = (mod.cor + t(mod.cor))/2 # correlation matrices should be symmetric

MantelModTest(cor.hypot, mod.cor)
</code></pre>

<hr>
<h2 id='MatrixCompare'>Matrix Compare</h2><span id='topic+MatrixCompare'></span>

<h3>Description</h3>

<p>Compare two matrices using all available methods. Currently RandomSkewers, MantelCor, KrzCor and PCASimilarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixCompare(cov.x, cov.y, id = ".id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatrixCompare_+3A_cov.x">cov.x</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
<tr><td><code id="MatrixCompare_+3A_cov.y">cov.y</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
<tr><td><code id="MatrixCompare_+3A_id">id</code></td>
<td>
<p>name of the comparison column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of comparisons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cov.x = RandomMatrix(10, 1, 1, 10)
cov.y = RandomMatrix(10, 1, 10, 20)
MatrixCompare(cov.x, cov.y)
</code></pre>

<hr>
<h2 id='MatrixDistance'>Matrix distance</h2><span id='topic+MatrixDistance'></span><span id='topic+MatrixDistance.default'></span><span id='topic+MatrixDistance.list'></span>

<h3>Description</h3>

<p>Calculates Distances between covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixDistance(cov.x, cov.y, distance, ...)

## Default S3 method:
MatrixDistance(cov.x, cov.y, distance = c("OverlapDist", "RiemannDist"), ...)

## S3 method for class 'list'
MatrixDistance(
  cov.x,
  cov.y = NULL,
  distance = c("OverlapDist", "RiemannDist"),
  ...,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatrixDistance_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix or list of covariance matrices.
If single matrix is supplied, it is compared to cov.y.
If list is supplied and no cov.y is supplied, all matrices
are compared.
If cov.y is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="MatrixDistance_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.
Optional if cov.x is a list.</p>
</td></tr>
<tr><td><code id="MatrixDistance_+3A_distance">distance</code></td>
<td>
<p>distance function for use in calculation. Currently supports &quot;Riemann&quot; and &quot;Overlap&quot;.</p>
</td></tr>
<tr><td><code id="MatrixDistance_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="MatrixDistance_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE and a list is passed, computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If cov.x and cov.y are passed, returns distance between them.
</p>
<p>If is a list cov.x and cov.y are passed, same as above, but for all matrices in cov.x.
</p>
<p>If only a list is passed to cov.x, a matrix of Distances is returned
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RiemannDist">RiemannDist</a></code>,<code><a href="#topic+OverlapDist">OverlapDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10)
c2 &lt;- RandomMatrix(10)
c3 &lt;- RandomMatrix(10)
MatrixDistance(c1, c2, "OverlapDist")
MatrixDistance(c1, c2, "RiemannDist")

# Compare multiple matrices
MatrixDistance(list(c1, c2, c3), distance = "OverlapDist")

# Compare multiple matrices to a target matrix
c4 &lt;- RandomMatrix(10)
MatrixDistance(list(c1, c2, c3), c4)

</code></pre>

<hr>
<h2 id='MeanMatrix'>Mean Covariance Matrix</h2><span id='topic+MeanMatrix'></span>

<h3>Description</h3>

<p>Estimate geometric mean for a set of covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanMatrix(matrix.array, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanMatrix_+3A_matrix.array">matrix.array</code></td>
<td>
<p>k x k x m array of covariance matrices, with k traits and m matrices</p>
</td></tr>
<tr><td><code id="MeanMatrix_+3A_tol">tol</code></td>
<td>
<p>minimum riemannian distance between sequential iterated means for accepting an estimated matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>geometric mean covariance matrix
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia, Diogo Melo
</p>


<h3>References</h3>

<p>Bini, D. A., Iannazzo, B. 2013. Computing the Karcher Mean of Symmetric
Positive Definite Matrices. Linear Algebra and Its Applications, 16th ILAS Conference
Proceedings, Pisa 2010, 438 (4): 1700-1710. doi:10.1016/j.laa.2011.08.052.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EigenTensorDecomposition">EigenTensorDecomposition</a></code>, <code><a href="#topic+RiemannDist">RiemannDist</a></code>
</p>

<hr>
<h2 id='MeanMatrixStatistics'>Calculate mean values for various matrix statistics</h2><span id='topic+MeanMatrixStatistics'></span><span id='topic+Autonomy'></span><span id='topic+ConditionalEvolvability'></span><span id='topic+Constraints'></span><span id='topic+Evolvability'></span><span id='topic+Flexibility'></span><span id='topic+Pc1Percent'></span><span id='topic+Respondability'></span>

<h3>Description</h3>

<p>Calculates: Mean Squared Correlation, ICV, Autonomy, ConditionalEvolvability, Constraints, Evolvability, Flexibility, Pc1Percent, Respondability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanMatrixStatistics(
  cov.matrix,
  iterations = 1000,
  full.results = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanMatrixStatistics_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>A covariance matrix</p>
</td></tr>
<tr><td><code id="MeanMatrixStatistics_+3A_iterations">iterations</code></td>
<td>
<p>Number of random vectors to be used in calculating the stochastic statistics</p>
</td></tr>
<tr><td><code id="MeanMatrixStatistics_+3A_full.results">full.results</code></td>
<td>
<p>If TRUE, full distribution of statistics will be returned.</p>
</td></tr>
<tr><td><code id="MeanMatrixStatistics_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dist Full distribution of stochastic statistics, only if full.resuts == TRUE
</p>
<p>mean Mean value for all statistics
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Guilherme Garcia
</p>


<h3>References</h3>

<p>Hansen, T. F., and Houle, D. (2008). Measuring and comparing evolvability
and constraint in multivariate characters. Journal of evolutionary
biology, 21(5), 1201-19. doi:10.1111/j.1420-9101.2008.01573.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- cov(iris[,1:4])
MeanMatrixStatistics(cov.matrix)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
MeanMatrixStatistics(cov.matrix, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MINT'>Modularity and integration analysis tool</h2><span id='topic+MINT'></span><span id='topic+JackKnifeMINT'></span>

<h3>Description</h3>

<p>Combines and compares many modularity hypothesis to a covariance matrix. Comparison values are
adjusted to the number of zeros in the hypothesis using a linear regression. Best hypothesis can
be assessed using a jack-knife procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MINT(
  c.matrix,
  modularity.hypot,
  significance = FALSE,
  sample.size = NULL,
  iterations = 1000
)

JackKnifeMINT(
  ind.data,
  modularity.hypot,
  n = 1000,
  leave.out = floor(dim(ind.data)[1]/10),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MINT_+3A_c.matrix">c.matrix</code></td>
<td>
<p>Correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="MINT_+3A_modularity.hypot">modularity.hypot</code></td>
<td>
<p>Matrix of hypothesis. Each line represents a trait and each column a module.
if modularity.hypot[i,j] == 1, trait i is in module j.</p>
</td></tr>
<tr><td><code id="MINT_+3A_significance">significance</code></td>
<td>
<p>Logical. Indicates if goodness of fit test should be performed.</p>
</td></tr>
<tr><td><code id="MINT_+3A_sample.size">sample.size</code></td>
<td>
<p>sample size in goodness of fit simulations via MonteCarlo</p>
</td></tr>
<tr><td><code id="MINT_+3A_iterations">iterations</code></td>
<td>
<p>number os goodness of fit simulations</p>
</td></tr>
<tr><td><code id="MINT_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or individual measurements</p>
</td></tr>
<tr><td><code id="MINT_+3A_n">n</code></td>
<td>
<p>number of jackknife samples</p>
</td></tr>
<tr><td><code id="MINT_+3A_leave.out">leave.out</code></td>
<td>
<p>number of individuals to be left out of each jackknife, default is 10%</p>
</td></tr>
<tr><td><code id="MINT_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to raply for the jackknife</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with ranked hypothesis, ordered by the corrected gamma value
Jackknife will return the best hypothesis for each sample.
</p>


<h3>Note</h3>

<p>Hypothesis can be named as column names, and these will be used to make labels in the 
output.
</p>


<h3>References</h3>

<p>Marquez, E.J. 2008. A statistical framework for testing modularity in multidimensional data. 
Evolution 62:2688-2708. 
</p>
<p>Parsons, K.J., Marquez, E.J., Albertson, R.C. 2012. Constraint and opportunity: the genetic 
basis and evolution of modularity in the cichlid mandible. The American Naturalist 179:64-78.
</p>
<p>http://www-personal.umich.edu/~emarquez/morph/doc/mint_man.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a modular matrix:
modules = matrix(c(rep(c(1, 0, 0), each = 5),
                 rep(c(0, 1, 0), each = 5),
                 rep(c(0, 0, 1), each = 5)), 15)
                 
cor.hypot = CreateHypotMatrix(modules)[[4]]
hypot.mask = matrix(as.logical(cor.hypot), 15, 15)
mod.cor = matrix(NA, 15, 15)
mod.cor[ hypot.mask] = runif(length(mod.cor[ hypot.mask]), 0.8, 0.9) # within-modules
mod.cor[!hypot.mask] = runif(length(mod.cor[!hypot.mask]), 0.1, 0.2) # between-modules
diag(mod.cor) = 1
mod.cor = (mod.cor + t(mod.cor))/2 # correlation matrices should be symmetric

# True hypothesis and a bunch of random ones.
hypothetical.modules = cbind(modules, matrix(sample(c(1, 0), 4*15, replace=TRUE), 15, 4))

# if hypothesis columns are not named they are assigned numbers
colnames(hypothetical.modules) &lt;- letters[1:7]
 
MINT(mod.cor, hypothetical.modules)

random_var = runif(15, 1, 10)
mod.data = mvtnorm::rmvnorm(100, sigma = sqrt(outer(random_var, random_var)) * mod.cor)
out_jack = JackKnifeMINT(mod.data, hypothetical.modules, n = 50)

library(ggplot2)

ggplot(out_jack, aes(rank, corrected.gamma)) + geom_point() + 
       geom_errorbar(aes(ymin = lower.corrected, ymax = upper.corrected))
</code></pre>

<hr>
<h2 id='MonteCarloR2'>R2 confidence intervals by parametric sampling</h2><span id='topic+MonteCarloR2'></span>

<h3>Description</h3>

<p>Using a multivariate normal model, random populations are generated
using the suplied covariance matrix. R2 is calculated on all the
random population, provinding a distribution based on the original matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MonteCarloR2(cov.matrix, sample.size, iterations = 1000, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MonteCarloR2_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="MonteCarloR2_+3A_sample.size">sample.size</code></td>
<td>
<p>Size of the random populations</p>
</td></tr>
<tr><td><code id="MonteCarloR2_+3A_iterations">iterations</code></td>
<td>
<p>Number of random populations</p>
</td></tr>
<tr><td><code id="MonteCarloR2_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since this function uses multivariate normal model to generate populations, only covariance matrices should be used.
</p>


<h3>Value</h3>

<p>returns a vector with the R2 for all populations
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r2.dist &lt;- MonteCarloR2(RandomMatrix(10, 1, 1, 10), 30)
quantile(r2.dist)
</code></pre>

<hr>
<h2 id='MonteCarloRep'>Parametric repeatabilities with covariance or correlation matrices</h2><span id='topic+MonteCarloRep'></span>

<h3>Description</h3>

<p>Using a multivariate normal model, random populations are generated
using the suplied covariance matrix. A statistic is calculated on the
random population and compared to the statistic calculated on the
original matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MonteCarloRep(
  cov.matrix,
  sample.size,
  ComparisonFunc,
  ...,
  iterations = 1000,
  correlation = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MonteCarloRep_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_sample.size">sample.size</code></td>
<td>
<p>Size of the random populations.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed to ComparisonFunc.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_iterations">iterations</code></td>
<td>
<p>Number of random populations.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_correlation">correlation</code></td>
<td>
<p>If TRUE, correlation matrix is used, else covariance matrix. MantelCor and MatrixCor should always uses correlation matrix.</p>
</td></tr>
<tr><td><code id="MonteCarloRep_+3A_parallel">parallel</code></td>
<td>
<p>If is TRUE and list is passed, computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since this function uses multivariate normal model to generate populations, only covariance matrices should be used, even when computing repeatabilities for covariances matrices.
</p>


<h3>Value</h3>

<p>returns the mean repeatability, or mean value of comparisons from samples to original statistic.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(5, 1, 1, 10)

MonteCarloRep(cov.matrix, sample.size = 30, RandomSkewers, iterations = 20)


MonteCarloRep(cov.matrix, sample.size = 30, RandomSkewers, num.vectors = 100, 
              iterations = 20, correlation = TRUE)
MonteCarloRep(cov.matrix, sample.size = 30, MatrixCor, correlation = TRUE)
MonteCarloRep(cov.matrix, sample.size = 30, KrzCor, iterations = 20)
MonteCarloRep(cov.matrix, sample.size = 30, KrzCor, correlation = TRUE)


#Creating repeatability vector for a list of matrices
mat.list &lt;- RandomMatrix(5, 3, 1, 10)
laply(mat.list, MonteCarloRep, 30, KrzCor, correlation = TRUE)


## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
MonteCarloRep(cov.matrix, 30, RandomSkewers, iterations = 100, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MonteCarloStat'>Parametric population samples with covariance or correlation matrices</h2><span id='topic+MonteCarloStat'></span>

<h3>Description</h3>

<p>Using a multivariate normal model, random populations are generated
using the supplied covariance matrix. A statistic is calculated on the
random population and compared to the statistic calculated on the
original matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MonteCarloStat(
  cov.matrix,
  sample.size,
  iterations,
  ComparisonFunc,
  StatFunc,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MonteCarloStat_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="MonteCarloStat_+3A_sample.size">sample.size</code></td>
<td>
<p>Size of the random populations</p>
</td></tr>
<tr><td><code id="MonteCarloStat_+3A_iterations">iterations</code></td>
<td>
<p>Number of random populations</p>
</td></tr>
<tr><td><code id="MonteCarloStat_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>Comparison functions for the calculated statistic</p>
</td></tr>
<tr><td><code id="MonteCarloStat_+3A_statfunc">StatFunc</code></td>
<td>
<p>Function for calculating the statistic</p>
</td></tr>
<tr><td><code id="MonteCarloStat_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since this function uses multivariate normal model to generate populations, only covariance matrices should be used.
</p>


<h3>Value</h3>

<p>returns the mean repeatability, or mean value of comparisons from samples to original statistic.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>, <code><a href="#topic+AlphaRep">AlphaRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(5, 1, 1, 10)

MonteCarloStat(cov.matrix, sample.size = 30, iterations = 50,
               ComparisonFunc = function(x, y) PCAsimilarity(x, y)[1],
               StatFunc = cov)

#Calculating R2 confidence intervals
r2.dist &lt;- MonteCarloR2(RandomMatrix(10, 1, 1, 10), 30)
quantile(r2.dist)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
##Windows:
#cl &lt;- makeCluster(2)
#registerDoParallel(cl)

##Mac and Linux:
library(doParallel)
registerDoParallel(cores = 2)

MonteCarloStat(cov.matrix, sample.size = 30, iterations = 100,
               ComparisonFunc = function(x, y) KrzCor(x, y)[1],
               StatFunc = cov,
               parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MultiMahalanobis'>Calculate Mahalonabis distance for many vectors</h2><span id='topic+MultiMahalanobis'></span>

<h3>Description</h3>

<p>Calculates the Mahalanobis distance between a list of species mean, using a global covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiMahalanobis(means, cov.matrix, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultiMahalanobis_+3A_means">means</code></td>
<td>
<p>list or array of species means being compared. array must have means in the rows.</p>
</td></tr>
<tr><td><code id="MultiMahalanobis_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>a single covariance matrix defining the scale (or metric tensor) to be used in the distance calculation.</p>
</td></tr>
<tr><td><code id="MultiMahalanobis_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix of species-species distances.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Mahalanobis_distance
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean.1 &lt;- colMeans(matrix(rnorm(30*10), 30, 10))
mean.2 &lt;- colMeans(matrix(rnorm(30*10), 30, 10))
mean.3 &lt;- colMeans(matrix(rnorm(30*10), 30, 10))
mean.list &lt;- list(mean.1, mean.2, mean.3)

# If cov.matrix is the identity, calculated distance is euclidian:
euclidian &lt;- MultiMahalanobis(mean.list, diag(10))
# Using a matrix with half the variance will give twice the distance between each mean:
half.euclidian  &lt;- MultiMahalanobis(mean.list, diag(10)/2)

# Other covariance matrices will give different distances, measured in the scale of the matrix
non.euclidian &lt;- MultiMahalanobis(mean.list, RandomMatrix(10))

#Input can be an array with means in each row
mean.array = array(1:36, c(9, 4))
mat = RandomMatrix(4)
MultiMahalanobis(mean.array, mat)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
MultiMahalanobis(mean.list, RandomMatrix(10), parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MultivDriftTest'>Multivariate genetic drift test for 2 populations</h2><span id='topic+MultivDriftTest'></span>

<h3>Description</h3>

<p>This function estimates populations evolving through drift from an ancestral 
population, given an effective population size, number of generations separating
them and the ancestral G-matrix. It calculates the magnitude of morphological 
divergence expected and compare it to the observed magnitude of morphological 
change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultivDriftTest(
  population1,
  population2,
  G,
  Ne,
  generations,
  iterations = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultivDriftTest_+3A_population1">population1</code></td>
<td>
<p>data.frame with original measurements for the ancestral population</p>
</td></tr>
<tr><td><code id="MultivDriftTest_+3A_population2">population2</code></td>
<td>
<p>data.frame with original measurements for the derived population</p>
</td></tr>
<tr><td><code id="MultivDriftTest_+3A_g">G</code></td>
<td>
<p>ancestral G matrix</p>
</td></tr>
<tr><td><code id="MultivDriftTest_+3A_ne">Ne</code></td>
<td>
<p>effective population size estimated for the populations</p>
</td></tr>
<tr><td><code id="MultivDriftTest_+3A_generations">generations</code></td>
<td>
<p>time in generations separating both populations</p>
</td></tr>
<tr><td><code id="MultivDriftTest_+3A_iterations">iterations</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the 95
drift and the range of the observed magnitude of morphological change
</p>


<h3>Note</h3>

<p>Each trait is estimated independently.
</p>


<h3>Author(s)</h3>

<p>Ana Paula Assis
</p>


<h3>References</h3>

<p>Hohenlohe, P.A ; Arnold, S.J. (2008). MIPod: a hypothesis testing framework for 
microevolutionary inference from patterns of divergence. 
American Naturalist, 171(3),
366-385. doi: 10.1086/527498
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dentus)
A &lt;- dentus[dentus$species== "A",-5]
B &lt;- dentus[dentus$species== "B",-5]
G &lt;- cov(A)
MultivDriftTest(A, B, G, Ne = 1000, generations = 250)

</code></pre>

<hr>
<h2 id='Normalize'>Normalize and Norm</h2><span id='topic+Normalize'></span><span id='topic+Norm'></span>

<h3>Description</h3>

<p>Norm returns the euclidian norm of a vector, Normalize returns a vector with unit norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(x)

Norm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Normalize_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized vector or inpout vector norm.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
n.x &lt;- Normalize(x)
Norm(x)
Norm(n.x)
</code></pre>

<hr>
<h2 id='OverlapDist'>Distribution overlap distance</h2><span id='topic+OverlapDist'></span>

<h3>Description</h3>

<p>Calculates the overlap between two normal distributions, 
defined as the probability that a draw from one distribution 
comes from the other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverlapDist(cov.x, cov.y, iterations = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OverlapDist_+3A_cov.x">cov.x</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
<tr><td><code id="OverlapDist_+3A_cov.y">cov.y</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
<tr><td><code id="OverlapDist_+3A_iterations">iterations</code></td>
<td>
<p>number of drows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Overlap distance between cov.x and cov.y
</p>


<h3>References</h3>

<p>Ovaskainen, O. (2008). A Bayesian framework for comparative quantitative genetics. Proceedings of the Royal Society B, 669-678. doi:10.1098/rspb.2007.0949
</p>

<hr>
<h2 id='Partition2HypotMatrix'>Create binary hypothesis</h2><span id='topic+Partition2HypotMatrix'></span>

<h3>Description</h3>

<p>Takes a vetor describing a trait partition and returns a binary matrix of the partitions where each line represents a trait and each column a module. In the output matrix, if modularity.hypot[i,j] == 1, trait i is in module j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Partition2HypotMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Partition2HypotMatrix_+3A_x">x</code></td>
<td>
<p>vector of trait partition. Each partition receive the same symbol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of hypothesis. Each line represents a trait and each column a module.
if modularity.hypot[i,j] == 1, trait i is in module j.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = sample(c(1, 2, 3), 10, replace = TRUE)
Partition2HypotMatrix(x) 
</code></pre>

<hr>
<h2 id='PCAsimilarity'>Compare matrices using PCA similarity factor</h2><span id='topic+PCAsimilarity'></span><span id='topic+PCAsimilarity.default'></span><span id='topic+PCAsimilarity.list'></span><span id='topic+PCAsimilarity.mcmc_sample'></span>

<h3>Description</h3>

<p>Compare matrices using PCA similarity factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAsimilarity(cov.x, cov.y, ...)

## Default S3 method:
PCAsimilarity(cov.x, cov.y, ret.dim = NULL, ...)

## S3 method for class 'list'
PCAsimilarity(cov.x, cov.y = NULL, ..., repeat.vector = NULL, parallel = FALSE)

## S3 method for class 'mcmc_sample'
PCAsimilarity(cov.x, cov.y, ..., parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCAsimilarity_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix or list of covariance matrices.
If cov.x is a single matrix, it is compared to cov.y.
If cov.x is a list and no cov.y is supplied, all matrices
are compared to each other.
If cov.x is a list and cov.y is supplied, all matrices in cov.x are compared to cov.y.</p>
</td></tr>
<tr><td><code id="PCAsimilarity_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.</p>
</td></tr>
<tr><td><code id="PCAsimilarity_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="PCAsimilarity_+3A_ret.dim">ret.dim</code></td>
<td>
<p>number of retained dimensions in the comparison. Defaults to all.</p>
</td></tr>
<tr><td><code id="PCAsimilarity_+3A_repeat.vector">repeat.vector</code></td>
<td>
<p>Vector of repeatabilities for correlation correction.</p>
</td></tr>
<tr><td><code id="PCAsimilarity_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ratio of projected variance to total variance
</p>


<h3>Author(s)</h3>

<p>Edgar Zanella Alvarenga
</p>


<h3>References</h3>

<p>Singhal, A. and Seborg, D. E. (2005), Clustering multivariate time-series data. J. Chemometrics, 19: 427-438. doi: 10.1002/cem.945
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzProjection">KrzProjection</a></code>,<code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10)
c2 &lt;- RandomMatrix(10)
PCAsimilarity(c1, c2)

m.list &lt;- RandomMatrix(10, 3)
PCAsimilarity(m.list)

PCAsimilarity(m.list, c1)
</code></pre>

<hr>
<h2 id='PCScoreCorrelation'>PC Score Correlation Test</h2><span id='topic+PCScoreCorrelation'></span>

<h3>Description</h3>

<p>Given a set of covariance matrices and means for terminals, test the hypothesis
that observed divergence is larger/smaller than expected by drift alone using the correlation on
principal component scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCScoreCorrelation(
  means,
  cov.matrix,
  taxons = names(means),
  show.plots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCScoreCorrelation_+3A_means">means</code></td>
<td>
<p>list or array of species means being compared. array must have means in the rows.</p>
</td></tr>
<tr><td><code id="PCScoreCorrelation_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>ancestral covariance matrix for all populations</p>
</td></tr>
<tr><td><code id="PCScoreCorrelation_+3A_taxons">taxons</code></td>
<td>
<p>names of taxons being compared. Must be in the same order of the means.</p>
</td></tr>
<tr><td><code id="PCScoreCorrelation_+3A_show.plots">show.plots</code></td>
<td>
<p>Logical. If TRUE, plot of eigenvalues of ancestral matrix by between group variance is showed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results containing:
</p>
<p>correlation matrix of principal component scores and p.values for each correlation. Lower triangle of output are correlations, and upper triangle are p.values.
</p>
<p>if show.plots is TRUE, also returns a list of plots of all projections of the nth PCs, where n is the number of taxons.
</p>


<h3>Author(s)</h3>

<p>Ana Paula Assis, Diogo Melo
</p>


<h3>References</h3>

<p>Marroig, G., and Cheverud, J. M. (2004). Did natural selection or genetic drift 
produce the cranial diversification of neotropical monkeys? The American Naturalist, 163(3), 417-428. doi:10.1086/381693
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Input can be an array with means in each row or a list of mean vectors
means = array(rnorm(40*10), c(10, 40)) 
cov.matrix = RandomMatrix(40, 1, 1, 10)
taxons = LETTERS[1:10]
PCScoreCorrelation(means, cov.matrix, taxons)

## Not run: 
##Plots list can be displayed using plot_grid()
library(cowplot)
pc.score.output &lt;- PCScoreCorrelation(means, cov.matrix, taxons, TRUE)
plot_grid(plotlist = pc.score.output$plots)

## End(Not run)
</code></pre>

<hr>
<h2 id='PhyloCompare'>Compares sister groups</h2><span id='topic+PhyloCompare'></span>

<h3>Description</h3>

<p>Calculates the comparison of some statistic between sister groups along a phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhyloCompare(tree, node.data, ComparisonFunc = PCAsimilarity, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhyloCompare_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="PhyloCompare_+3A_node.data">node.data</code></td>
<td>
<p>list of node data</p>
</td></tr>
<tr><td><code id="PhyloCompare_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function, default is PCAsimilarity</p>
</td></tr>
<tr><td><code id="PhyloCompare_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to ComparisonFunc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with a data.frame of calculated comparisons for each node, using labels or numbers from tree; and a list of comparisons for plotting using phytools (see examples)
</p>


<h3>Note</h3>

<p>Phylogeny must be fully resolved
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(bird.orders)
tree &lt;- bird.orders
mat.list &lt;- RandomMatrix(5, length(tree$tip.label))
names(mat.list) &lt;- tree$tip.label
sample.sizes &lt;- runif(length(tree$tip.label), 15, 20)
phylo.state &lt;- PhyloW(tree, mat.list, sample.sizes)

phylo.comparisons &lt;- PhyloCompare(tree, phylo.state)

# plotting results on a phylogeny:
## Not run: 
library(phytools)
plotBranchbyTrait(tree, phylo.comparisons[[2]])

## End(Not run)
</code></pre>

<hr>
<h2 id='PhyloMantel'>Mantel test with phylogenetic permutations</h2><span id='topic+PhyloMantel'></span>

<h3>Description</h3>

<p>Performs a matrix correlation with significance given by a phylogenetic Mantel Test. 
Pairs of rows and columns are permuted with probability proportional to their phylogenetic distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhyloMantel(
  tree,
  matrix.1,
  matrix.2,
  ...,
  permutations = 1000,
  ComparisonFunc = function(x, y) cor(x[lower.tri(x)], y[lower.tri(y)]),
  k = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhyloMantel_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree. Tip labels must match names in input matrices</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_matrix.1">matrix.1</code></td>
<td>
<p>pair-wise comparison/distance matrix</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_matrix.2">matrix.2</code></td>
<td>
<p>pair-wise comparison/distance matrix</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_...">...</code></td>
<td>
<p>additional parameters, currently ignored</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations used in significance calculation</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function, default is MatrixCor</p>
</td></tr>
<tr><td><code id="PhyloMantel_+3A_k">k</code></td>
<td>
<p>determines the influence of the phylogeny. 1 is strong influence, and larger values converge to a traditional mantel test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with the comparison value and the proportion of times the observed comparison is smaller than the correlations from the permutations.
</p>


<h3>Note</h3>

<p>This method should only be used when there is no option other than representing data as pair-wise. It suffers from low power, and alternatives should be used when available.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, adapted from Harmon &amp; Glor 2010
</p>


<h3>References</h3>

<p>Harmon, L. J., &amp; Glor, R. E. (2010). Poor statistical performance of the Mantel test in phylogenetic comparative analyses. Evolution, 64(7), 2173-2178.
</p>
<p>Lapointe, F. J., &amp; Garland, Jr, T. (2001). A generalized permutation model for the analysis of cross-species data. Journal of Classification, 18(1), 109-127.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dentus)
data(dentus.tree)
tree = dentus.tree
cor.matrices = dlply(dentus, .(species), function(x) cor(x[-5]))
comparisons = MatrixCor(cor.matrices)

sp.means = dlply(dentus, .(species), function(x) colMeans(x[-5]))
mh.dist = MultiMahalanobis(means = sp.means, cov.matrix = PhyloW(dentus.tree, cor.matrices)$'6')
PhyloMantel(dentus.tree, comparisons, mh.dist, k = 10000)

#similar to MantelCor for large k:
## Not run: 
PhyloMantel(dentus.tree, comparisons, mh.dist, k = 10000)
MantelCor(comparisons, mh.dist)

## End(Not run)
</code></pre>

<hr>
<h2 id='PhyloW'>Calculates ancestral states of some statistic</h2><span id='topic+PhyloW'></span>

<h3>Description</h3>

<p>Calculates weighted average of covariances matrices along a phylogeny, returning a withing-group covariance matrice for each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhyloW(tree, tip.data, tip.sample.size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhyloW_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="PhyloW_+3A_tip.data">tip.data</code></td>
<td>
<p>list of tip nodes covariance matrices</p>
</td></tr>
<tr><td><code id="PhyloW_+3A_tip.sample.size">tip.sample.size</code></td>
<td>
<p>vector of tip nodes sample sizes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with calculated within-group matrices, using labels or numbers from tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(dentus)
data(dentus.tree)
tree &lt;- dentus.tree
mat.list &lt;- dlply(dentus, 'species', function(x) cov(x[,1:4]))
sample.sizes &lt;- runif(length(tree$tip.label), 15, 20)
PhyloW(tree, mat.list, sample.sizes)
</code></pre>

<hr>
<h2 id='PlotKrzSubspace'>Plot KrzSubspace boostrap comparison</h2><span id='topic+PlotKrzSubspace'></span>

<h3>Description</h3>

<p>Shows the null and observed distribution of eigenvalues from the Krzanowski subspace comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotKrzSubspace(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotKrzSubspace_+3A_x">x</code></td>
<td>
<p>output from KrzSubspaceDataFrame() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object with the observed vs. random eigenvalues mean and posterior confidence intervals
</p>

<hr>
<h2 id='PlotRarefaction'>Plot Rarefaction analysis</h2><span id='topic+PlotRarefaction'></span>

<h3>Description</h3>

<p>A specialized ploting function displays the results from Rarefaction functions in publication quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotRarefaction(
  comparison.list,
  y.axis = "Statistic",
  x.axis = "Number of sampled specimens"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotRarefaction_+3A_comparison.list">comparison.list</code></td>
<td>
<p>output from rarefaction functions can be used in ploting</p>
</td></tr>
<tr><td><code id="PlotRarefaction_+3A_y.axis">y.axis</code></td>
<td>
<p>Y axis lable in plot</p>
</td></tr>
<tr><td><code id="PlotRarefaction_+3A_x.axis">x.axis</code></td>
<td>
<p>Y axis lable in plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object with rarefaction plot
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ind.data &lt;- iris[1:50,1:4]

results.RS &lt;- Rarefaction(ind.data, PCAsimilarity, num.reps = 5)
results.Mantel &lt;- Rarefaction(ind.data, MatrixCor, correlation = TRUE, num.reps = 5)
results.KrzCov &lt;- Rarefaction(ind.data, KrzCor, num.reps = 5)
results.PCA &lt;- Rarefaction(ind.data, PCAsimilarity, num.reps = 5)

#Plotting using ggplot2
a &lt;- PlotRarefaction(results.RS, "Random Skewers")
b &lt;- PlotRarefaction(results.Mantel, "Mantel")
c &lt;- PlotRarefaction(results.KrzCov, "KrzCor")
d &lt;- PlotRarefaction(results.PCA, "PCAsimilarity")

library(cowplot)
plot_grid(a, b, c, d, labels = c("RS",
                                 "Mantel Correlation",
                                 "Krzanowski Correlation",
                                 "PCA Similarity"),
                      scale = 0.9)

</code></pre>

<hr>
<h2 id='PlotTreeDriftTest'>Plot results from TreeDriftTest</h2><span id='topic+PlotTreeDriftTest'></span>

<h3>Description</h3>

<p>Plot which labels reject drift hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotTreeDriftTest(test.list, tree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotTreeDriftTest_+3A_test.list">test.list</code></td>
<td>
<p>Output from TreeDriftTest</p>
</td></tr>
<tr><td><code id="PlotTreeDriftTest_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="PlotTreeDriftTest_+3A_...">...</code></td>
<td>
<p>adition arguments to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for plot side effects
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>See Also</h3>

<p>DriftTest TreeDriftTest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(bird.orders)

tree &lt;- bird.orders
mean.list &lt;- llply(tree$tip.label, function(x) rnorm(5))
names(mean.list) &lt;- tree$tip.label
cov.matrix.list &lt;- RandomMatrix(5, length(tree$tip.label))
names(cov.matrix.list) &lt;- tree$tip.label
sample.sizes &lt;- runif(length(tree$tip.label), 15, 20)

test.list &lt;- TreeDriftTest(tree, mean.list, cov.matrix.list, sample.sizes)
PlotTreeDriftTest(test.list, tree)
</code></pre>

<hr>
<h2 id='PrintMatrix'>Print Matrix to file</h2><span id='topic+PrintMatrix'></span><span id='topic+PrintMatrix.default'></span><span id='topic+PrintMatrix.list'></span>

<h3>Description</h3>

<p>Print a matrix or a list of matrices to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintMatrix(x, ...)

## Default S3 method:
PrintMatrix(x, output.file, ...)

## S3 method for class 'list'
PrintMatrix(x, output.file, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrintMatrix_+3A_x">x</code></td>
<td>
<p>Matrix or list of matrices</p>
</td></tr>
<tr><td><code id="PrintMatrix_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
<tr><td><code id="PrintMatrix_+3A_output.file">output.file</code></td>
<td>
<p>Output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints coma separated matrices, with labels
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m.list &lt;- RandomMatrix(10, 4)
tmp = file.path(tempdir(), "matrix.csv")
PrintMatrix(m.list, output.file = tmp )
</code></pre>

<hr>
<h2 id='ProjectMatrix'>Project Covariance Matrix</h2><span id='topic+ProjectMatrix'></span>

<h3>Description</h3>

<p>This function projects a given covariance matrix into the basis provided by an eigentensor decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectMatrix(matrix, etd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProjectMatrix_+3A_matrix">matrix</code></td>
<td>
<p>A symmetric covariance matrix for k traits</p>
</td></tr>
<tr><td><code id="ProjectMatrix_+3A_etd">etd</code></td>
<td>
<p>Eigentensor decomposition of m covariance matrices for k traits
(obtained from <code><a href="#topic+EigenTensorDecomposition">EigenTensorDecomposition</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of scores of given covariance matrix onto eigentensor basis.
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia, Diogo Melo
</p>


<h3>References</h3>

<p>Basser P. J., Pajevic S. 2007. Spectral decomposition of a 4th-order 
covariance tensor: Applications to diffusion tensor MRI. Signal Processing. 87:220-236.
</p>
<p>Hine E., Chenoweth S. F., Rundle H. D., Blows M. W. 2009. Characterizing 
the evolution of genetic variance using genetic covariance tensors. Philosophical 
transactions of the Royal Society of London. Series B, Biological sciences. 364:1567-78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EigenTensorDecomposition">EigenTensorDecomposition</a></code>, <code><a href="#topic+RevertMatrix">RevertMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function is useful for projecting posterior samples for a set of 
# covariance matrices onto the eigentensor decomposition done 
# on their estimated means

data(dentus)

dentus.models &lt;- dlply(dentus, .(species), lm, 
                       formula = cbind(humerus, ulna, femur, tibia) ~ 1)

dentus.matrices &lt;- llply(dentus.models, BayesianCalculateMatrix, samples = 100)

dentus.post.vcv &lt;- laply(dentus.matrices, function (L) L $ Ps)
dentus.post.vcv &lt;- aperm(dentus.post.vcv, c(3, 4, 1, 2))

dentus.mean.vcv &lt;- aaply(dentus.post.vcv, 3, MeanMatrix)
dentus.mean.vcv &lt;- aperm(dentus.mean.vcv, c(2, 3, 1))

dentus.mean.etd &lt;- EigenTensorDecomposition(dentus.mean.vcv)
dentus.mean.proj &lt;- data.frame('species' = LETTERS [1:5], dentus.mean.etd $ projection)

dentus.post.proj &lt;- adply(dentus.post.vcv, c(3, 4), ProjectMatrix, etd = dentus.mean.etd)
colnames(dentus.post.proj) [1:2] &lt;- c('species', 'sample')
levels(dentus.post.proj $ species) &lt;- LETTERS[1:5]

require(ggplot2)
ggplot() +
  geom_point(aes(x = ET1, y = ET2, color = species), 
     data = dentus.mean.proj, shape = '+', size = 8) +
  geom_point(aes(x = ET1, y = ET2, color = species), 
     data = dentus.post.proj, shape = '+', size = 3) +
  theme_bw()

</code></pre>

<hr>
<h2 id='RandCorr'>Random correlation matrix</h2><span id='topic+RandCorr'></span>

<h3>Description</h3>

<p>Internal function for generating random correlation matrices.
Use RandomMatrix() instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandCorr(num.traits, ke = 10^-3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RandCorr_+3A_num.traits">num.traits</code></td>
<td>
<p>Number of traits in random matrix</p>
</td></tr>
<tr><td><code id="RandCorr_+3A_ke">ke</code></td>
<td>
<p>Parameter for correlation matrix generation. Involves check for positive defitness</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random Matrix
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Edgar Zanella
</p>

<hr>
<h2 id='RandomMatrix'>Random matrices for tests</h2><span id='topic+RandomMatrix'></span>

<h3>Description</h3>

<p>Provides random covariance/correlation matrices for quick tests.
Should not be used for statistics or hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomMatrix(
  num.traits,
  num.matrices = 1,
  min.var = 1,
  max.var = 1,
  variance = NULL,
  ke = 10^-3,
  LKJ = FALSE,
  shape = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RandomMatrix_+3A_num.traits">num.traits</code></td>
<td>
<p>Number of traits in random matrix</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_num.matrices">num.matrices</code></td>
<td>
<p>Number of matrices to be generated. If greater than 1, a list is returned.</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_min.var">min.var</code></td>
<td>
<p>Lower value for random variance in covariance matrices</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_max.var">max.var</code></td>
<td>
<p>Upper value for random variance in covariance matrices</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_variance">variance</code></td>
<td>
<p>Variance vector. If present will be used in all matrices</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_ke">ke</code></td>
<td>
<p>Parameter for correlation matrix generation. Involves check for positive definiteness</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_lkj">LKJ</code></td>
<td>
<p>logical. Use LKJ distribution for generating correlation matrices.</p>
</td></tr>
<tr><td><code id="RandomMatrix_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for the LKJ distribution. Values closer to zero leads to a more uniform distribution correlations. Higher values lead to correlations closer to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a single matrix, or a list of matrices of equal dimension
</p>


<h3>Author(s)</h3>

<p>Diogo Melo Edgar Zanella
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single 10x10 correlation matrix
RandomMatrix(10)

# single 5x5 covariance matrix, variances between 3 and 4
RandomMatrix(5, 1, 3, 4)

# two 3x3 covariance matrices, with shared variances
RandomMatrix(3, 2, variance= c(3, 4, 5))

# large 10x10 matrix list, with wide range of variances
RandomMatrix(10, 100, 1, 300)
</code></pre>

<hr>
<h2 id='RandomSkewers'>Compare matrices via RandomSkewers</h2><span id='topic+RandomSkewers'></span><span id='topic+RandomSkewers.default'></span><span id='topic+RandomSkewers.list'></span><span id='topic+RandomSkewers.mcmc_sample'></span>

<h3>Description</h3>

<p>Calculates covariance matrix correlation via random skewers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomSkewers(cov.x, cov.y, ...)

## Default S3 method:
RandomSkewers(cov.x, cov.y, num.vectors = 10000, ...)

## S3 method for class 'list'
RandomSkewers(
  cov.x,
  cov.y = NULL,
  num.vectors = 10000,
  repeat.vector = NULL,
  parallel = FALSE,
  ...
)

## S3 method for class 'mcmc_sample'
RandomSkewers(cov.x, cov.y, num.vectors = 10000, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RandomSkewers_+3A_cov.x">cov.x</code></td>
<td>
<p>Single covariance matrix or list of covariance matrices.
If single matrix is supplied, it is compared to cov.y.
If list is supplied and no cov.y is supplied, all matrices
are compared.
If cov.y is supplied, all matrices in list are compared to it.</p>
</td></tr>
<tr><td><code id="RandomSkewers_+3A_cov.y">cov.y</code></td>
<td>
<p>First argument is compared to cov.y.
Optional if cov.x is a list.</p>
</td></tr>
<tr><td><code id="RandomSkewers_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="RandomSkewers_+3A_num.vectors">num.vectors</code></td>
<td>
<p>Number of random vectors used in comparison.</p>
</td></tr>
<tr><td><code id="RandomSkewers_+3A_repeat.vector">repeat.vector</code></td>
<td>
<p>Vector of repeatabilities for correlation correction.</p>
</td></tr>
<tr><td><code id="RandomSkewers_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If cov.x and cov.y are passed, returns average value
of response vectors correlation ('correlation'), significance ('probability') and standard deviation
of response vectors correlation ('correlation_sd')
</p>
<p>If cov.x and cov.y are passed, same as above, but for all matrices in cov.x.
</p>
<p>If only a list is passed to cov.x, a matrix of RandomSkewers average
values and probabilities of all comparisons.
If repeat.vector is passed, comparison matrix is corrected above
diagonal and repeatabilities returned in diagonal.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Cheverud, J. M., and Marroig, G. (2007). Comparing covariance matrices:
Random skewers method compared to the common principal components model.
Genetics and Molecular Biology, 30, 461-469.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+MantelCor">MantelCor</a></code>,<code><a href="#topic+DeltaZCorr">DeltaZCorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- RandomMatrix(10, 1, 1, 10)
c2 &lt;- RandomMatrix(10, 1, 1, 10)
c3 &lt;- RandomMatrix(10, 1, 1, 10)
RandomSkewers(c1, c2)

RandomSkewers(list(c1, c2, c3))

reps &lt;- unlist(lapply(list(c1, c2, c3), MonteCarloRep, sample.size = 10,
                                        RandomSkewers, num.vectors = 100,
                                        iterations = 10))
RandomSkewers(list(c1, c2, c3), repeat.vector = reps)

c4 &lt;- RandomMatrix(10)
RandomSkewers(list(c1, c2, c3), c4)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
RandomSkewers(list(c1, c2, c3), parallel = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Rarefaction'>Rarefaction analysis via resampling</h2><span id='topic+Rarefaction'></span>

<h3>Description</h3>

<p>Calculates the repeatability of a statistic of the data, such as
correlation or covariance matrix, via bootstrap resampling with
varying sample sizes, from 2 to the size of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rarefaction(
  ind.data,
  ComparisonFunc,
  ...,
  num.reps = 10,
  correlation = FALSE,
  replace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rarefaction_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or individual measurments</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to ComparisonFunc</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_num.reps">num.reps</code></td>
<td>
<p>number of populations sampled per sample size</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_correlation">correlation</code></td>
<td>
<p>If TRUE, correlation matrix is used, else covariance matrix. MantelCor always uses correlation matrix.</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_replace">replace</code></td>
<td>
<p>If true, samples are taken with replacement</p>
</td></tr>
<tr><td><code id="Rarefaction_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples of various sizes, with replacement, are taken from the full population, a statistic calculated
and compared to the full population statistic.
</p>
<p>A specialized plotting function displays the results in publication quality.
</p>
<p>Bootstraping may be misleading with very small sample sizes. Use with caution if original sample sizes are small.
</p>


<h3>Value</h3>

<p>returns the mean value of comparisons from samples to original statistic, for all sample sizes.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind.data &lt;- iris[1:50,1:4]

results.RS &lt;- Rarefaction(ind.data, RandomSkewers, num.reps = 5)
#' #Easy parsing of results
library(reshape2)
melt(results.RS)

# or :

results.Mantel &lt;- Rarefaction(ind.data, MatrixCor, correlation = TRUE, num.reps = 5)
results.KrzCov &lt;- Rarefaction(ind.data, KrzCor, num.reps = 5)
results.PCA &lt;- Rarefaction(ind.data, PCAsimilarity, num.reps = 5)


## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
results.KrzCov &lt;- Rarefaction(ind.data, KrzCor, num.reps = 5, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='RarefactionStat'>Non-Parametric rarefacted population samples and statistic comparison</h2><span id='topic+RarefactionStat'></span>

<h3>Description</h3>

<p>Calculates the repeatability of a statistic of the data, such as
correlation or covariance matrix, via resampling with
varying sample sizes, from 2 to the size of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RarefactionStat(
  ind.data,
  StatFunc,
  ComparisonFunc,
  ...,
  num.reps = 10,
  replace = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RarefactionStat_+3A_ind.data">ind.data</code></td>
<td>
<p>Matrix of residuals or indiviual measurments</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_statfunc">StatFunc</code></td>
<td>
<p>Function for calculating the statistic</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_comparisonfunc">ComparisonFunc</code></td>
<td>
<p>comparison function</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed to ComparisonFunc</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_num.reps">num.reps</code></td>
<td>
<p>number of populations sampled per sample size</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_replace">replace</code></td>
<td>
<p>If true, samples are taken with replacement</p>
</td></tr>
<tr><td><code id="RarefactionStat_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach backend must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples of various sizes, without replacement, are taken from the full population, a statistic calculated and compared to the full population statistic.
</p>
<p>A specialized ploting function displays the results in publication quality.
</p>
<p>Bootstraping may be misleading with very small sample sizes. Use with caution.
</p>


<h3>Value</h3>

<p>returns the mean value of comparisons from samples to original statistic, for all sample sizes.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapRep">BootstrapRep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind.data &lt;- iris[1:50,1:4]

#Can be used to calculate any statistic via Rarefaction, not just comparisons
#Integration, for example:
results.R2 &lt;- RarefactionStat(ind.data, cor, function(x, y) CalcR2(y), num.reps = 5)

#Easy access
library(reshape2)
melt(results.R2)

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
results.R2 &lt;- RarefactionStat(ind.data, cor, function(x, y) CalcR2(y), parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ratones'>Linear distances for five mouse lines</h2><span id='topic+ratones'></span>

<h3>Description</h3>

<p>Skull distances measured from landmarks in 5 mice lines: 4 body weight selection lines and 1 control line. 
Originally published in Penna, A., Melo, D. et. al (2017) 10.1111/evo.13304
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ratones)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.5gr8r">Dryad Archive</a>
</p>


<h3>References</h3>

<p>Penna, A., Melo, D., Bernardi, S., Oyarzabal, M.I. and Marroig, G. (2017), The evolution of phenotypic integration: How directional selection reshapes covariation in mice. Evolution, 71: 2370-2380. https://doi.org/10.1111/evo.13304
(<a href="https://pubmed.ncbi.nlm.nih.gov/28685813/">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ratones)
   
# Estimating a W matrix, controlling for line and sex
model_formula = paste0("cbind(", 
                       paste(names(ratones)[13:47], collapse = ", "),
                       ") ~ SEX + LIN")
ratones_W_model = lm(model_formula, data = ratones)
W_matrix = CalculateMatrix(ratones_W_model)

# Estimating the divergence between the two direction of selection
delta_Z = colMeans(ratones[ratones$selection == "upwards", 13:47]) -
          colMeans(ratones[ratones$selection == "downwards", 13:47])
          
 # Reconstructing selection gradients with and without noise control         
Beta = solve(W_matrix, delta_Z)
Beta_non_noise = solve(ExtendMatrix(W_matrix, ret.dim = 10)$ExtMat, delta_Z)

# Comparing the selection gradients to the observed divergence
Beta %*% delta_Z /(Norm(Beta) * Norm(delta_Z))
Beta_non_noise %*% delta_Z /(Norm(Beta_non_noise) * Norm(delta_Z))      
          
</code></pre>

<hr>
<h2 id='RelativeEigenanalysis'>Relative Eigenanalysis</h2><span id='topic+RelativeEigenanalysis'></span>

<h3>Description</h3>

<p>Computes relative eigenvalues and eigenvectors between a pair of covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RelativeEigenanalysis(cov.x, cov.y, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RelativeEigenanalysis_+3A_cov.x">cov.x</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="RelativeEigenanalysis_+3A_cov.y">cov.y</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="RelativeEigenanalysis_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical. If TRUE, computes symmetric eigenanalysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two objects: eigenvalues and eigenvectors
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia, Diogo Melo
</p>


<h3>References</h3>

<p>Bookstein, F. L., and P. Mitteroecker, P. &quot;Comparing Covariance Matrices by
Relative Eigenanalysis, with Applications to Organismal Biology.&quot; Evolutionary Biology 41, no. 2
(June 1, 2014): 336-350. doi:10.1007/s11692-013-9260-5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dentus)
dentus.vcv &lt;- dlply(dentus, .(species), function(df) var(df[, -5]))

dentus.eigrel &lt;- RelativeEigenanalysis(dentus.vcv [[1]], dentus.vcv[[5]])

</code></pre>

<hr>
<h2 id='RemoveSize'>Remove Size Variation</h2><span id='topic+RemoveSize'></span>

<h3>Description</h3>

<p>Removes first principal component effect in a covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveSize(cov.matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RemoveSize_+3A_cov.matrix">cov.matrix</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function sets the first eigenvalue to zero.
</p>


<h3>Value</h3>

<p>Altered covariance matrix with no variation on former first principal component
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix &lt;- RandomMatrix(10, 1, 1, 10)
no.size.cov.matrix &lt;- RemoveSize(cov.matrix)
eigen(cov.matrix)
eigen(no.size.cov.matrix)
</code></pre>

<hr>
<h2 id='RevertMatrix'>Revert Matrix</h2><span id='topic+RevertMatrix'></span>

<h3>Description</h3>

<p>Constructs a covariance matrix based on scores over covariance matrix eigentensors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RevertMatrix(values, etd, scaled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RevertMatrix_+3A_values">values</code></td>
<td>
<p>vector of values to build matrix, each value corresponding 
to a score on the ordered set of eigentensors (up to the maximum number of 
eigentensors on the target decomposition); if there are less values than eigentensors 
provided in etd (see below), the function will assume zero as the value 
for the score in remaining eigentensors</p>
</td></tr>
<tr><td><code id="RevertMatrix_+3A_etd">etd</code></td>
<td>
<p>Eigentensor decomposition of m covariance matrices for 
k traits (obtained from <code><a href="#topic+EigenTensorDecomposition">EigenTensorDecomposition</a></code>)</p>
</td></tr>
<tr><td><code id="RevertMatrix_+3A_scaled">scaled</code></td>
<td>
<p>should we treat each score as a value given in standard 
deviations for each eigentensor? Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric covariance matrix with k traits
</p>


<h3>References</h3>

<p>Basser P. J., Pajevic S. 2007. Spectral decomposition of a 4th-order 
covariance tensor: Applications to diffusion tensor MRI. Signal Processing. 87:220-236.
</p>
<p>Hine E., Chenoweth S. F., Rundle H. D., Blows M. W. 2009. Characterizing 
the evolution of genetic variance using genetic covariance tensors. Philosophical 
transactions of the Royal Society of London. Series B, Biological sciences. 364:1567-78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## we can use RevertMatrix to represent eigentensors using SRD to compare two matrices
## which differ with respect to their projections on a single directions

data(dentus)

dentus.vcv &lt;- daply (dentus, .(species), function(x) cov(x[,-5]))

dentus.vcv &lt;- aperm(dentus.vcv, c(2, 3, 1))

dentus.etd &lt;- EigenTensorDecomposition(dentus.vcv, TRUE)

## calling RevertMatrix with a single value will use this value as the score
## on the first eigentensor and use zero as the value of remaining scores

low.et1 &lt;- RevertMatrix(-1.96, dentus.etd, TRUE)
upp.et1 &lt;- RevertMatrix(1.96, dentus.etd, TRUE)

srd.et1 &lt;- SRD(low.et1, upp.et1)
 
plot(srd.et1)

## we can also look at the second eigentensor, by providing each call 
## of RevertMatrix with a vector of two values, the first being zero

low.et2 &lt;- RevertMatrix(c(0, -1.96), dentus.etd, TRUE)
upp.et2 &lt;- RevertMatrix(c(0, 1.96), dentus.etd, TRUE)

srd.et2 &lt;- SRD(low.et2, upp.et2)
 
plot(srd.et2)

</code></pre>

<hr>
<h2 id='RiemannDist'>Matrix Riemann distance</h2><span id='topic+RiemannDist'></span>

<h3>Description</h3>

<p>Return distance between two covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RiemannDist(cov.x, cov.y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RiemannDist_+3A_cov.x">cov.x</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
<tr><td><code id="RiemannDist_+3A_cov.y">cov.y</code></td>
<td>
<p>covariance or correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Riemann distance between cov.x and cov.y
</p>


<h3>Author(s)</h3>

<p>Edgar Zanella
</p>


<h3>References</h3>

<p>Mitteroecker, P., &amp; Bookstein, F. (2009). The ontogenetic trajectory of the phenotypic covariance matrix, with examples from craniofacial shape in rats and humans. Evolution, 63(3), 727-737. doi:10.1111/j.1558-5646.2008.00587.x
</p>

<hr>
<h2 id='Rotate2MidlineMatrix'>Midline rotate</h2><span id='topic+Rotate2MidlineMatrix'></span>

<h3>Description</h3>

<p>Returns the rotation matrix that aligns a specimen sagital line
to plane y = 0 (2D) or z = 0 (3D)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rotate2MidlineMatrix(X, midline)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rotate2MidlineMatrix_+3A_x">X</code></td>
<td>
<p>shape array</p>
</td></tr>
<tr><td><code id="Rotate2MidlineMatrix_+3A_midline">midline</code></td>
<td>
<p>rows for the midline landmarks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rotation matrix
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>

<hr>
<h2 id='RSProjection'>Random Skewers projection</h2><span id='topic+RSProjection'></span><span id='topic+PlotRSprojection'></span>

<h3>Description</h3>

<p>Uses Bayesian posterior samples of a set of covariance matrices to identify
directions of the morphospace in which these matrices differ in their amount of genetic variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSProjection(cov.matrix.array, p = 0.95, num.vectors = 1000)

PlotRSprojection(rs_proj, cov.matrix.array, p = 0.95, ncols = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RSProjection_+3A_cov.matrix.array">cov.matrix.array</code></td>
<td>
<p>Array with dimensions traits x traits x populations x MCMCsamples</p>
</td></tr>
<tr><td><code id="RSProjection_+3A_p">p</code></td>
<td>
<p>significance threshold for comparison of variation in each random direction</p>
</td></tr>
<tr><td><code id="RSProjection_+3A_num.vectors">num.vectors</code></td>
<td>
<p>number of random vectors</p>
</td></tr>
<tr><td><code id="RSProjection_+3A_rs_proj">rs_proj</code></td>
<td>
<p>output from RSProjection</p>
</td></tr>
<tr><td><code id="RSProjection_+3A_ncols">ncols</code></td>
<td>
<p>number of columns in plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>projection of all matrices in all random vectors
</p>
<p>set of random vectors and confidence intervals for the projections
</p>
<p>eigen decomposition of the random vectors in directions with significant differences of variations
</p>


<h3>References</h3>

<p>Aguirre, J. D., E. Hine, K. McGuigan, and M. W. Blows. &quot;Comparing G: multivariate analysis of genetic variation in multiple populations.&quot; Heredity 112, no. 1 (2014): 21-29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># small MCMCsample to reduce run time, acctual sample should be larger
data(dentus)
cov.matrices = dlply(dentus, .(species), function(x) lm(as.matrix(x[,1:4])~1)) |&gt;
               laply(function(x) BayesianCalculateMatrix(x, samples = 50)$Ps)
cov.matrices = aperm(cov.matrices, c(3, 4, 1, 2))

rs_proj = RSProjection(cov.matrices, p = 0.8)
PlotRSprojection(rs_proj, cov.matrices, ncol = 5)


</code></pre>

<hr>
<h2 id='SingleComparisonMap'>Generic Single Comparison Map functions for creating parallel list methods
Internal functions for making efficient comparisons.</h2><span id='topic+SingleComparisonMap'></span>

<h3>Description</h3>

<p>Generic Single Comparison Map functions for creating parallel list methods
Internal functions for making efficient comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleComparisonMap(matrix.list, y.mat, MatrixCompFunc, ..., parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingleComparisonMap_+3A_matrix.list">matrix.list</code></td>
<td>
<p>list of matrices being compared</p>
</td></tr>
<tr><td><code id="SingleComparisonMap_+3A_y.mat">y.mat</code></td>
<td>
<p>single matrix being compared to list</p>
</td></tr>
<tr><td><code id="SingleComparisonMap_+3A_matrixcompfunc">MatrixCompFunc</code></td>
<td>
<p>Function used to compare pair of matrices, must output a vector: comparisons and probabilities</p>
</td></tr>
<tr><td><code id="SingleComparisonMap_+3A_...">...</code></td>
<td>
<p>Additional arguments to MatrixCompFunc</p>
</td></tr>
<tr><td><code id="SingleComparisonMap_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of comparisons, matrix of probabilities.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MantelCor">MantelCor</a></code>, <code><a href="#topic+KrzCor">KrzCor</a></code>,<code><a href="#topic+RandomSkewers">RandomSkewers</a></code>
</p>

<hr>
<h2 id='SRD'>Compare matrices via Selection Response Decomposition</h2><span id='topic+SRD'></span><span id='topic+SRD.default'></span><span id='topic+SRD.list'></span><span id='topic+plot.SRD'></span>

<h3>Description</h3>

<p>Based on Random Skewers technique, selection response vectors are
expanded in direct and indirect components by trait and compared via
vector correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SRD(cov.x, cov.y, ...)

## Default S3 method:
SRD(cov.x, cov.y, iterations = 1000, ...)

## S3 method for class 'list'
SRD(cov.x, cov.y = NULL, iterations = 1000, parallel = FALSE, ...)

## S3 method for class 'SRD'
plot(x, matrix.label = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SRD_+3A_cov.x">cov.x</code></td>
<td>
<p>Covariance matrix being compared. cov.x can be a matrix or a list.</p>
</td></tr>
<tr><td><code id="SRD_+3A_cov.y">cov.y</code></td>
<td>
<p>Covariance matrix being compared. Ignored if cov.x is a list.</p>
</td></tr>
<tr><td><code id="SRD_+3A_...">...</code></td>
<td>
<p>additional parameters passed to other methods</p>
</td></tr>
<tr><td><code id="SRD_+3A_iterations">iterations</code></td>
<td>
<p>Number of random vectors used in comparison</p>
</td></tr>
<tr><td><code id="SRD_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE computations are done in parallel. Some foreach back-end must be registered, like doParallel or doMC.</p>
</td></tr>
<tr><td><code id="SRD_+3A_x">x</code></td>
<td>
<p>Output from SRD function, used in plotting</p>
</td></tr>
<tr><td><code id="SRD_+3A_matrix.label">matrix.label</code></td>
<td>
<p>Plot label</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output can be plotted using PlotSRD function
</p>


<h3>Value</h3>

<p>List of SRD scores means, confidence intervals, standard
deviations, centered means e centered standard deviations
</p>
<p>pc1 scored along the pc1 of the mean/SD correlation matrix
</p>
<p>model List of linear model results from mean/SD correlation. Quantiles, interval and divergent traits
</p>


<h3>Note</h3>

<p>If input is a list, output is a symmetric list array with pairwise comparisons.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Marroig, G., Melo, D., Porto, A., Sebastiao, H., and Garcia, G.
(2011). Selection Response Decomposition (SRD): A New Tool for
Dissecting Differences and Similarities Between Matrices. Evolutionary
Biology, 38(2), 225-241. doi:10.1007/s11692-010-9107-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RandomSkewers">RandomSkewers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cov.matrix.1 &lt;- cov(matrix(rnorm(30*10), 30, 10))
cov.matrix.2 &lt;- cov(matrix(rnorm(30*10), 30, 10))
colnames(cov.matrix.1) &lt;- colnames(cov.matrix.2) &lt;- sample(letters, 10)
rownames(cov.matrix.1) &lt;- rownames(cov.matrix.2) &lt;- colnames(cov.matrix.1)
srd.output &lt;- SRD(cov.matrix.1, cov.matrix.2)

#lists
m.list &lt;- RandomMatrix(10, 4)
srd.array.result = SRD(m.list)

#divergent traits
colnames(cov.matrix.1)[as.logical(srd.output$model$code)]

#Plot
plot(srd.output)

## For the array generated by SRD(m.list) you must index the idividual positions for plotting:
plot(srd.array.result[1,2][[1]])
plot(srd.array.result[3,4][[1]])

## Not run: 
#Multiple threads can be used with some foreach backend library, like doMC or doParallel
library(doMC)
registerDoMC(cores = 2)
SRD(m.list, parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='TestModularity'>Test modularity hypothesis</h2><span id='topic+TestModularity'></span>

<h3>Description</h3>

<p>Tests modularity hypothesis using cor.matrix matrix and trait groupings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestModularity(
  cor.matrix,
  modularity.hypot,
  permutations = 1000,
  MHI = FALSE,
  ...,
  landmark.dim = NULL,
  withinLandmark = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestModularity_+3A_cor.matrix">cor.matrix</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_modularity.hypot">modularity.hypot</code></td>
<td>
<p>Matrix of hypothesis. Each line represents a trait and each column a module.
if modularity.hypot[i,j] == 1, trait i is in module j.</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations, to be passed to MantelModTest</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_mhi">MHI</code></td>
<td>
<p>Indicates if test should use Modularity Hypothesis Index instead of AVG Ratio</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_...">...</code></td>
<td>
<p>additional arguments passed to MantelModTest</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_landmark.dim">landmark.dim</code></td>
<td>
<p>Used if permutations should be performed maintaining landmark structure in geometric morphometric data. Either 2 for 2d data or 3 for 3d data. Default is NULL for non geometric morphometric data.</p>
</td></tr>
<tr><td><code id="TestModularity_+3A_withinlandmark">withinLandmark</code></td>
<td>
<p>Logical. If TRUE within-landmark correlations are used in the calculation of matrix correlation. Only used if landmark.dim is passed, default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns mantel correlation and associated probability for each modularity hypothesis, along with AVG+, AVG-, AVG Ratio for each module.
A total hypothesis combining all hypothesis is also tested.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo, Guilherme Garcia
</p>


<h3>References</h3>

<p>Porto, Arthur, Felipe B. Oliveira, Leila T. Shirai, Valderes Conto, and Gabriel Marroig. 2009. &quot;The Evolution of Modularity in the Mammalian Skull I: Morphological Integration Patterns and Magnitudes.&quot; Evolutionary Biology 36 (1): 118-35. doi:10.1007/s11692-008-9038-3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MantelModTest">MantelModTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor.matrix &lt;- RandomMatrix(10)
rand.hypots &lt;- matrix(sample(c(1, 0), 30, replace=TRUE), 10, 3)
mod.test &lt;- TestModularity(cor.matrix, rand.hypots)

cov.matrix &lt;- RandomMatrix(10, 1, 1, 10)
cov.mod.test &lt;- TestModularity(cov.matrix, rand.hypots, MHI = TRUE)
nosize.cov.mod.test &lt;- TestModularity(RemoveSize(cov.matrix), rand.hypots, MHI = TRUE)
</code></pre>

<hr>
<h2 id='TPS'>TPS transform</h2><span id='topic+TPS'></span>

<h3>Description</h3>

<p>Calculates the Thin Plate Spline transform between a reference shape and a target shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPS(target.shape, reference.shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TPS_+3A_target.shape">target.shape</code></td>
<td>
<p>Target shape</p>
</td></tr>
<tr><td><code id="TPS_+3A_reference.shape">reference.shape</code></td>
<td>
<p>Reference shape</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the transformation parameters and a function that gives
the value of the TPS function at each point for numerical differentiation
</p>


<h3>Author(s)</h3>

<p>Guilherme Garcia
</p>

<hr>
<h2 id='TreeDriftTest'>Drift test along phylogeny</h2><span id='topic+TreeDriftTest'></span>

<h3>Description</h3>

<p>Performs a regression drift test along a phylogeny using DriftTest function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeDriftTest(tree, mean.list, cov.matrix.list, sample.sizes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TreeDriftTest_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="TreeDriftTest_+3A_mean.list">mean.list</code></td>
<td>
<p>list of tip node means. Names must match tip node labels.</p>
</td></tr>
<tr><td><code id="TreeDriftTest_+3A_cov.matrix.list">cov.matrix.list</code></td>
<td>
<p>list of tip node covariance matrices. Names must match tip node labels.</p>
</td></tr>
<tr><td><code id="TreeDriftTest_+3A_sample.sizes">sample.sizes</code></td>
<td>
<p>vector of tip nodes sample sizes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of regression drift tests performed in nodes with over 4 descendant tips.
</p>


<h3>Author(s)</h3>

<p>Diogo Melo
</p>


<h3>See Also</h3>

<p>DriftTest PlotTreeDriftTest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(bird.orders)

tree &lt;- bird.orders
mean.list &lt;- llply(tree$tip.label, function(x) rnorm(5))
names(mean.list) &lt;- tree$tip.label
cov.matrix.list &lt;- RandomMatrix(5, length(tree$tip.label))
names(cov.matrix.list) &lt;- tree$tip.label
sample.sizes &lt;- runif(length(tree$tip.label), 15, 20)

test.list &lt;- TreeDriftTest(tree, mean.list, cov.matrix.list, sample.sizes)

#Ancestral node plot:
test.list[[length(test.list)]]$plot
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
