<!DOCTYPE html><html><head><title>Help for package rODE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rODE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rODE-package'><p>Ordinary Differential Equations</p></a></li>
<li><a href='#AbstractODESolver-class'><p>AbstractODESolver class</p></a></li>
<li><a href='#DormandPrince45-class'><p>DormandPrince45 ODE solver class</p></a></li>
<li><a href='#doStep'><p>doStep</p></a></li>
<li><a href='#enableRuntimeExceptions'><p>enableRuntimeExceptions</p></a></li>
<li><a href='#Euler-class'><p>Euler ODE solver class</p></a></li>
<li><a href='#EulerRichardson-class'><p>EulerRichardson ODE solver class</p></a></li>
<li><a href='#getEnergy'><p>getEnergy</p></a></li>
<li><a href='#getErrorCode'><p>getErrorCode</p></a></li>
<li><a href='#getExactSolution'><p>getExactSolution</p></a></li>
<li><a href='#getODE'><p>getODE</p></a></li>
<li><a href='#getRate'><p>getRate</p></a></li>
<li><a href='#getRateCounter'><p>getRateCounter</p></a></li>
<li><a href='#getRateCounts'><p>getRateCounts</p></a></li>
<li><a href='#getState'><p>getState</p></a></li>
<li><a href='#getStepSize'><p>getStepSize</p></a></li>
<li><a href='#getTime'><p>getTime</p></a></li>
<li><a href='#getTolerance'><p>getTolerance</p></a></li>
<li><a href='#importFromExamples'><p>importFromExamples</p></a></li>
<li><a href='#init'><p>init</p></a></li>
<li><a href='#ODE-class'><p>ODE class</p></a></li>
<li><a href='#ODEAdaptiveSolver-class'><p>ODEAdaptiveSolver class</p></a></li>
<li><a href='#ODESolver-class'><p>ODESolver virtual class</p></a></li>
<li><a href='#ODESolverFactory-class'><p>ODESolverFactory</p></a></li>
<li><a href='#RK4-class'><p>RK4 class</p></a></li>
<li><a href='#RK45-class'><p>RK45 ODE solver class</p></a></li>
<li><a href='#run_test_applications'><p>run_test_applications</p></a></li>
<li><a href='#setSolver+26lt+3B-'><p>setSolver</p></a></li>
<li><a href='#setState'><p>setState</p></a></li>
<li><a href='#setStepSize'><p>setStepSize</p></a></li>
<li><a href='#setTolerance'><p>setTolerance</p></a></li>
<li><a href='#showMethods2'><p>showMethods2</p></a></li>
<li><a href='#step'><p>step</p></a></li>
<li><a href='#Verlet-class'><p>Verlet ODE solver class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ordinary Differential Equation (ODE) Solvers Written in R Using
S4 Classes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Show physics, math and engineering students how an ODE solver
    is made and how effective R classes can be for the construction of
    the equations that describe natural phenomena. Inspiration for this work 
    comes from the book on "Computer Simulations in Physics" 
    by Harvey Gould, Jan Tobochnik, and Wolfgang Christian. 
    Book link: <a href="http://www.compadre.org/osp/items/detail.cfm?ID=7375">http://www.compadre.org/osp/items/detail.cfm?ID=7375</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, data.table</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown, ggplot2, dplyr, tidyr, covr,
scales</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ode_generics.R' 'ODESolver.R' 'ODE.R' 'AbstractODESolver.R'
'ODEAdaptiveSolver.R' 'DormandPrince45.R' 'Euler.R'
'EulerRichardson.R' 'ODESolverFactory.R' 'RK4.R' 'RK45.R'
'Verlet.R' 'rODE-package.r' 'utils.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/f0nzie/rODE">https://github.com/f0nzie/rODE</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-11-10 01:31:57 UTC; msfz751</td>
</tr>
<tr>
<td>Author:</td>
<td>Alfonso R. Reyes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alfonso R. Reyes &lt;alfonso.reyes@oilgainsanalytics.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-11-10 04:17:51 UTC</td>
</tr>
</table>
<hr>
<h2 id='rODE-package'>Ordinary Differential Equations</h2><span id='topic+rODE-package'></span>

<h3>Description</h3>

<p>Ordinary Differential Equations
rODE.
</p>

<hr>
<h2 id='AbstractODESolver-class'>AbstractODESolver class</h2><span id='topic+AbstractODESolver-class'></span><span id='topic+.AbstractODESolver'></span><span id='topic+AbstractODESolver'></span><span id='topic+step+2CAbstractODESolver-method'></span><span id='topic+getODE+2CAbstractODESolver-method'></span><span id='topic+setStepSize+2CAbstractODESolver-method'></span><span id='topic+init+2CAbstractODESolver-method'></span><span id='topic+init+3C-+2CAbstractODESolver-method'></span><span id='topic+getStepSize+2CAbstractODESolver-method'></span><span id='topic+AbstractODESolver+2Cmissing-method'></span><span id='topic+AbstractODESolver+2CODE-method'></span>

<h3>Description</h3>

<p>Defines the basic methods for all the ODE solvers.
</p>
<p>AbstractODESolver generic
</p>
<p>AbstractODESolver constructor missing
</p>
<p>AbstractODESolver constructor ODE. Uses this constructor when ODE object is passed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AbstractODESolver(ode, ...)

## S4 method for signature 'AbstractODESolver'
step(object, ...)

## S4 method for signature 'AbstractODESolver'
getODE(object, ...)

## S4 method for signature 'AbstractODESolver'
setStepSize(object, stepSize, ...)

## S4 method for signature 'AbstractODESolver'
init(object, stepSize, ...)

## S4 replacement method for signature 'AbstractODESolver'
init(object, ...) &lt;- value

## S4 method for signature 'AbstractODESolver'
getStepSize(object, ...)

## S4 method for signature 'missing'
AbstractODESolver(ode, ...)

## S4 method for signature 'ODE'
AbstractODESolver(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbstractODESolver-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="AbstractODESolver-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="AbstractODESolver-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="AbstractODESolver-class_+3A_stepsize">stepSize</code></td>
<td>
<p>the size of the step</p>
</td></tr>
<tr><td><code id="AbstractODESolver-class_+3A_value">value</code></td>
<td>
<p>the step size value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inherits from: ODESolver class
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is how we start defining a new ODE solver: Euler
.Euler &lt;- setClass("Euler",              # Euler solver very simple; no slots
     contains = c("AbstractODESolver"))



# Here we define the ODE solver Verlet
.Verlet &lt;- setClass("Verlet", slots = c(
    rate1 = "numeric",                          # Verlet calculates two rates
    rate2 = "numeric",
    rateCounter = "numeric"),
contains = c("AbstractODESolver"))



# This is the definition of the ODE solver Runge-Kutta 4
.RK4 &lt;- setClass("RK4", slots = c(       # On the other hand RK4 uses 4 rates
   rate1 = "numeric",
   rate2 = "numeric",
   rate3 = "numeric",
   rate4 = "numeric",
   estimated_state = "numeric"),         # and estimates another state
contains = c("AbstractODESolver"))

</code></pre>

<hr>
<h2 id='DormandPrince45-class'>DormandPrince45 ODE solver class</h2><span id='topic+DormandPrince45-class'></span><span id='topic+.DormandPrince45'></span><span id='topic+DormandPrince45'></span><span id='topic+init+2CDormandPrince45-method'></span><span id='topic+init+3C-+2CDormandPrince45-method'></span><span id='topic+step+2CDormandPrince45-method'></span><span id='topic+enableRuntimeExceptions+2CDormandPrince45-method'></span><span id='topic+enableRuntimeExceptions+2CenableRuntimeExceptions-method'></span><span id='topic+setStepSize+2CDormandPrince45-method'></span><span id='topic+getStepSize+2CDormandPrince45-method'></span><span id='topic+setTolerance+2CDormandPrince45-method'></span><span id='topic+setTolerance+2CsetTolerance-method'></span><span id='topic+setTolerance+3C-+2CDormandPrince45-method'></span><span id='topic+setTolerance+2CsetTolerance-method'></span><span id='topic+getTolerance+2CDormandPrince45-method'></span><span id='topic+getTolerance+2CgetTolerance-method'></span><span id='topic+getErrorCode+2CDormandPrince45-method'></span><span id='topic+getErrorCode+2CgetErrorCode-method'></span><span id='topic+DormandPrince45+2CODE-method'></span>

<h3>Description</h3>

<p>DormandPrince45 ODE solver class
</p>
<p>DormandPrince45 generic
</p>
<p>DormandPrince45 constructor ODE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DormandPrince45(ode, ...)

## S4 method for signature 'DormandPrince45'
init(object, stepSize, ...)

## S4 replacement method for signature 'DormandPrince45'
init(object, ...) &lt;- value

## S4 method for signature 'DormandPrince45'
step(object, ...)

## S4 method for signature 'DormandPrince45'
enableRuntimeExceptions(object, enable)

## S4 method for signature 'DormandPrince45'
setStepSize(object, stepSize, ...)

## S4 method for signature 'DormandPrince45'
getStepSize(object, ...)

## S4 method for signature 'DormandPrince45'
setTolerance(object, tol)

## S4 replacement method for signature 'DormandPrince45'
setTolerance(object, ...) &lt;- value

## S4 method for signature 'DormandPrince45'
getTolerance(object)

## S4 method for signature 'DormandPrince45'
getErrorCode(object)

## S4 method for signature 'ODE'
DormandPrince45(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DormandPrince45-class_+3A_ode">ode</code></td>
<td>
<p>ODE object</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_stepsize">stepSize</code></td>
<td>
<p>size of the step</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_value">value</code></td>
<td>
<p>step size to set</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_enable">enable</code></td>
<td>
<p>a logical flag</p>
</td></tr>
<tr><td><code id="DormandPrince45-class_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  base class: KeplerVerlet.R

setClass("KeplerDormandPrince45", slots = c(
    GM = "numeric",
    odeSolver = "DormandPrince45",
    counter = "numeric"
    ),
    contains = c("ODE")
)

setMethod("initialize", "KeplerDormandPrince45", function(.Object, ...) {
    .Object@GM &lt;- 4 * pi * pi         # gravitation constant times combined mass
    .Object@state &lt;- vector("numeric", 5)  # x, vx, y, vy, t
    .Object@odeSolver &lt;- DormandPrince45(.Object)
    .Object@counter &lt;- 0
    return(.Object)
})

setMethod("doStep", "KeplerDormandPrince45", function(object, ...) {
    object@odeSolver &lt;- step(object@odeSolver)
    object@state &lt;- object@odeSolver@ode@state
    object
})

setMethod("getTime", "KeplerDormandPrince45", function(object, ...) {
    return(object@state[5])
})

setMethod("getEnergy", "KeplerDormandPrince45", function(object, ...) {
    ke &lt;- 0.5 * (object@state[2] * object@state[2] +
                     object@state[4] * object@state[4])
    pe &lt;- -object@GM / sqrt(object@state[1] * object@state[1] +
                                object@state[3] * object@state[3])
    return(pe+ke)
})

setMethod("init", "KeplerDormandPrince45", function(object, initState, ...) {
    object@state &lt;- initState
    # call init in AbstractODESolver
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

setReplaceMethod("init", "KeplerDormandPrince45", function(object, ..., value) {
    object@state &lt;- value
    # call init in AbstractODESolver
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

setMethod("getRate", "KeplerDormandPrince45", function(object, state, ...) {
    # Computes the rate using the given state.
    r2 &lt;- state[1] * state[1] + state[3] * state[3]  # distance squared
    r3 &lt;- r2 * sqrt(r2)   # distance cubed
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- (- object@GM * state[1]) / r3
    object@rate[3] &lt;- state[4]
    object@rate[4] &lt;- (- object@GM * state[3]) / r3
    object@rate[5] &lt;- 1   # time derivative

    object@counter &lt;- object@counter + 1
    object@rate
})

setMethod("getState", "KeplerDormandPrince45", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

setReplaceMethod("setSolver", "KeplerDormandPrince45", function(object, value) {
    object@odeSolver &lt;- value
    object
})

# constructor
KeplerDormandPrince45 &lt;- function() {
    kepler &lt;- new("KeplerDormandPrince45")
    return(kepler)
}
# +++++++++++++++++++++++++++++++++++++++++ Example:      ComparisonRK45ODEApp.R
# Updates the ODE state instead of using the internal state in the ODE solver
# Also plots the solver solution versus the analytical solution at a
# tolerance of 1e-6
# Example file: ComparisonRK45ODEApp.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

library(ggplot2)
library(dplyr)
library(tidyr)

importFromExamples("ODETest.R")

ComparisonRK45ODEApp &lt;- function(verbose = FALSE) {
    ode &lt;- new("ODETest")                         # new ODE instance
    ode_solver &lt;- RK45(ode)                       # select ODE solver
    ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

    # two ways to set tolerance
      # ode_solver &lt;- setTolerance(ode_solver, 1e-6)
    setTolerance(ode_solver) &lt;-  1e-6

    time &lt;-  0
    rowVector &lt;- vector("list")                   # row vector
    i &lt;- 1    # counter
    while (time &lt; 50) {
        # add solution objects to a row vector
        rowVector[[i]] &lt;- list(t     = getState(ode)[2],
                               ODE   = getState(ode)[1],
                               s2    = getState(ode)[2],
                               exact = getExactSolution(ode, time),
                               rate.counts = getRateCounts(ode),
                               time = time )
        ode_solver &lt;- step(ode_solver)            # advance solver one step
        stepSize &lt;-  getStepSize(ode_solver)      # get the current step size
        time  &lt;- time + stepSize
        ode   &lt;- getODE(ode_solver)               # get updated ODE object
        state &lt;- getState(ode)                    # get the `state` vector
        i &lt;- i + 1                                # add a row vector
    }
    DT &lt;- data.table::rbindlist(rowVector)        # create data table
    return(DT)
}

solution &lt;- ComparisonRK45ODEApp()
plot(solution)


# aditional plot for analytics solution vs. RK45 solver
solution.multi &lt;- solution %&gt;%
    select(t, ODE, exact)
plot(solution.multi)             # 3x3 plot

# plot comparative curves analytical vs ODE solver
solution.2x1 &lt;- solution.multi %&gt;%
    gather(key, value, -t)         # make a table of 3 variables. key: ODE/exact

g &lt;- ggplot(solution.2x1, mapping = aes(x = t, y = value, color = key))
g &lt;-  g + geom_line(size = 1) +
    labs(title = "ODE vs Exact solution",
         subtitle = "tolerance = 1E-6")
print(g)




</code></pre>

<hr>
<h2 id='doStep'>doStep</h2><span id='topic+doStep'></span>

<h3>Description</h3>

<p>Perform a step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doStep(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doStep_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="doStep_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++  example: PlanetApp.R
# Simulation of Earth orbiting around the SUn using the Euler ODE solver

importFromExamples("Planet.R")      # source the class

PlanetApp &lt;- function(verbose = FALSE) {
    # x =  1, AU or Astronomical Units. Length of semimajor axis or the orbit
    # of the Earth around the Sun.
    x &lt;- 1; vx &lt;- 0; y &lt;- 0; vy &lt;- 6.28; t &lt;- 0
    state &lt;- c(x, vx, y, vy, t)
    dt &lt;-  0.01
    planet &lt;- Planet()
    planet@odeSolver &lt;- setStepSize(planet@odeSolver, dt)
    planet &lt;- init(planet, initState = state)
    rowvec &lt;- vector("list")
    i &lt;- 1
    # run infinite loop. stop with ESCAPE.
    while (getState(planet)[5] &lt;= 90) {     # Earth orbit is 365 days around the sun
        rowvec[[i]] &lt;- list(t  = getState(planet)[5],     # just doing 3 months
                            x  = getState(planet)[1],     # to speed up for CRAN
                            vx = getState(planet)[2],
                            y  = getState(planet)[3],
                            vy = getState(planet)[4])
        for (j in 1:5) {                 # advances time
            planet &lt;- doStep(planet)
        }
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# run the application
solution &lt;- PlanetApp()
select_rows &lt;- seq(1, nrow(solution), 10)      # do not overplot
solution &lt;- solution[select_rows,]
plot(solution)

# +++++++++++++++++++++++++++++++++++++++++++++++++++   application:  Logistic.R
# Simulates the logistic equation
importFromExamples("Logistic.R")

# Run the application
LogisticApp &lt;- function(verbose = FALSE) {
    x  &lt;- 0.1
    vx &lt;- 0
    r  &lt;- 2        # Malthusian parameter (rate of maximum population growth)
    K  &lt;- 10.0     # carrying capacity of the environment
    dt   &lt;- 0.01; tol  &lt;- 1e-3; tmax &lt;- 10

    population &lt;- Logistic()                # create a Logistic ODE object

    # Two ways of initializing the object
      # population &lt;- init(population, c(x, vx, 0), r, K)
    init(population) &lt;-  list(initState = c(x, vx, 0),
                              r = r,
                              K = K)

    odeSolver &lt;- Verlet(population)        # select the solver

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    population@odeSolver &lt;- odeSolver
    # setSolver(population) &lt;-  odeSolver

    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(population) &lt;= tmax) {
        rowVector[[i]] &lt;- list(t = getTime(population),
                               s1 = getState(population)[1],
                               s2 = getState(population)[2])
        population &lt;- doStep(population)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}
# show solution
solution &lt;- LogisticApp()
plot(solution)
</code></pre>

<hr>
<h2 id='enableRuntimeExceptions'>enableRuntimeExceptions</h2><span id='topic+enableRuntimeExceptions'></span>

<h3>Description</h3>

<p>Enable Runtime Exceptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enableRuntimeExceptions(object, enable, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enableRuntimeExceptions_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="enableRuntimeExceptions_+3A_enable">enable</code></td>
<td>
<p>a boolean to enable exceptions</p>
</td></tr>
<tr><td><code id="enableRuntimeExceptions_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("enableRuntimeExceptions", "DormandPrince45", function(object, enable) {
    object@enableExceptions &lt;- enable
})
</code></pre>

<hr>
<h2 id='Euler-class'>Euler ODE solver class</h2><span id='topic+Euler-class'></span><span id='topic+.Euler'></span><span id='topic+Euler'></span><span id='topic+init+2CEuler-method'></span><span id='topic+init+2Cinit-method'></span><span id='topic+step+2CEuler-method'></span><span id='topic+step+2Cstep-method'></span><span id='topic+setStepSize+2CEuler-method'></span><span id='topic+setStepSize+2CsetStepSize-method'></span><span id='topic+getStepSize+2CEuler-method'></span><span id='topic+getStepSize+2CgetStepSize-method'></span><span id='topic+Euler+2CODE-method'></span><span id='topic+Euler+2Cmissing-method'></span>

<h3>Description</h3>

<p>Euler ODE solver class
</p>
<p>Euler generic
</p>
<p>Euler constructor when 'ODE' passed
</p>
<p>Euler constructor 'missing' is passed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Euler(ode, ...)

## S4 method for signature 'Euler'
init(object, stepSize, ...)

## S4 method for signature 'Euler'
step(object, ...)

## S4 method for signature 'Euler'
setStepSize(object, stepSize, ...)

## S4 method for signature 'Euler'
getStepSize(object, ...)

## S4 method for signature 'ODE'
Euler(ode, ...)

## S4 method for signature 'missing'
Euler(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Euler-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="Euler-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="Euler-class_+3A_object">object</code></td>
<td>
<p>an internal object of the class</p>
</td></tr>
<tr><td><code id="Euler-class_+3A_stepsize">stepSize</code></td>
<td>
<p>the size of the step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># +++++++++++++++++++++++++++++++++++++++++++++++ application: RigidBodyNXFApp.R
# example of a nonstiff system is the system of equations describing
# the motion of a rigid body without external forces.

importFromExamples("RigidBody.R")

# run the application
RigidBodyNXFApp &lt;- function(verbose = FALSE) {
    # load the R class that sets up the solver for this application
    y1 &lt;- 0   # initial y1 value
    y2 &lt;- 1    # initial y2 value
    y3 &lt;- 1    # initial y3 value
    dt        &lt;- 0.01 # delta time for step

    body   &lt;- RigidBodyNXF(y1, y2, y3)
    solver &lt;- Euler(body)
    solver &lt;- setStepSize(solver, dt)
    rowVector &lt;- vector("list")
    i &lt;- 1
    # stop loop when the body hits the ground
    while (getState(body)[4] &lt;= 12) {
        rowVector[[i]] &lt;- list(t  = getState(body)[4],
                               y1 = getState(body)[1],
                               y2 = getState(body)[2],
                               y3 = getState(body)[3])
        solver &lt;- step(solver)
        body   &lt;- getODE(solver)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}

# get the data table from the app
solution &lt;- RigidBodyNXFApp()
plot(solution)

# +++++++++++++++++++++++++++++++++++++++++++++++  example: FallingParticleApp.R
# Application that simulates the free fall of a ball using Euler ODE solver

importFromExamples("FallingParticleODE.R")      # source the class

FallingParticleODEApp &lt;- function(verbose = FALSE) {
    # initial values
    initial_y &lt;- 10
    initial_v &lt;- 0
    dt &lt;- 0.01
    ball   &lt;- FallingParticleODE(initial_y, initial_v)
    solver &lt;- Euler(ball)                        # set the ODE solver
    solver &lt;- setStepSize(solver, dt)            # set the step
    rowVector &lt;- vector("list")
    i &lt;- 1
    # stop loop when the ball hits the ground, state[1] is the vertical position
    while (getState(ball)[1] &gt; 0) {
        rowVector[[i]] &lt;- list(t  = getState(ball)[3],
                               y  = getState(ball)[1],
                               vy = getState(ball)[2])
        solver &lt;- step(solver)                   # move one step at a time
        ball   &lt;- getODE(solver)                       # update the ball state
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}
# show solution
solution &lt;- FallingParticleODEApp()
plot(solution)
# KeplerVerlet.R



setClass("Kepler", slots = c(
    GM = "numeric",
    odeSolver = "Euler",
    counter = "numeric"
    ),
    contains = c("ODE")
)

setMethod("initialize", "Kepler", function(.Object, ...) {
    .Object@GM &lt;- 4 * pi * pi                # gravitation constant times combined mass
    .Object@state &lt;- vector("numeric", 5)  # x, vx, y, vy, t
    .Object@odeSolver &lt;- Euler(.Object)
    .Object@counter &lt;- 0
    return(.Object)
})

setMethod("doStep", "Kepler", function(object, ...) {
    # cat("state@doStep=", object@state, "\n")
    object@odeSolver &lt;- step(object@odeSolver)

    object@state &lt;- object@odeSolver@ode@state

    # object@rate &lt;- object@odeSolver@ode@rate
    # cat("\t", object@odeSolver@ode@state)
    object
})

setMethod("getTime", "Kepler", function(object, ...) {
    return(object@state[5])
})

setMethod("getEnergy", "Kepler", function(object, ...) {
    ke &lt;- 0.5 * (object@state[2] * object@state[2] +
                     object@state[4] * object@state[4])
    pe &lt;- -object@GM / sqrt(object@state[1] * object@state[1] +
                                object@state[3] * object@state[3])
    return(pe+ke)
})

setMethod("init", "Kepler", function(object, initState, ...) {
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

setReplaceMethod("init", "Kepler", function(object, ..., value) {
    object@state &lt;- value
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})


setMethod("getRate", "Kepler", function(object, state, ...) {
    # Computes the rate using the given state.
    r2 &lt;- state[1] * state[1] + state[3] * state[3]  # distance squared
    r3 &lt;- r2 * sqrt(r2)   # distance cubed
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- (- object@GM * state[1]) / r3
    object@rate[3] &lt;- state[4]
    object@rate[4] &lt;- (- object@GM * state[3]) / r3
    object@rate[5] &lt;- 1   # time derivative

    # object@state &lt;- object@odeSolver@ode@state &lt;- state
    # object@state &lt;- state
    object@counter &lt;- object@counter + 1
    object@rate

})

setMethod("getState", "Kepler", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

# constructor
Kepler &lt;- function() {
    kepler &lt;- new("Kepler")
    return(kepler)
}
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++  example: PlanetApp.R
# Simulation of Earth orbiting around the SUn using the Euler ODE solver

importFromExamples("Planet.R")      # source the class

PlanetApp &lt;- function(verbose = FALSE) {
    # x =  1, AU or Astronomical Units. Length of semimajor axis or the orbit
    # of the Earth around the Sun.
    x &lt;- 1; vx &lt;- 0; y &lt;- 0; vy &lt;- 6.28; t &lt;- 0
    state &lt;- c(x, vx, y, vy, t)
    dt &lt;-  0.01
    planet &lt;- Planet()
    planet@odeSolver &lt;- setStepSize(planet@odeSolver, dt)
    planet &lt;- init(planet, initState = state)
    rowvec &lt;- vector("list")
    i &lt;- 1
    # run infinite loop. stop with ESCAPE.
    while (getState(planet)[5] &lt;= 90) {     # Earth orbit is 365 days around the sun
        rowvec[[i]] &lt;- list(t  = getState(planet)[5],     # just doing 3 months
                            x  = getState(planet)[1],     # to speed up for CRAN
                            vx = getState(planet)[2],
                            y  = getState(planet)[3],
                            vy = getState(planet)[4])
        for (j in 1:5) {                 # advances time
            planet &lt;- doStep(planet)
        }
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# run the application
solution &lt;- PlanetApp()
select_rows &lt;- seq(1, nrow(solution), 10)      # do not overplot
solution &lt;- solution[select_rows,]
plot(solution)

# +++++++++++++++++++++++++++++++++++++++++++++++ application: RigidBodyNXFApp.R
# example of a nonstiff system is the system of equations describing
# the motion of a rigid body without external forces.

importFromExamples("RigidBody.R")

# run the application
RigidBodyNXFApp &lt;- function(verbose = FALSE) {
    # load the R class that sets up the solver for this application
    y1 &lt;- 0   # initial y1 value
    y2 &lt;- 1    # initial y2 value
    y3 &lt;- 1    # initial y3 value
    dt        &lt;- 0.01 # delta time for step

    body   &lt;- RigidBodyNXF(y1, y2, y3)
    solver &lt;- Euler(body)
    solver &lt;- setStepSize(solver, dt)
    rowVector &lt;- vector("list")
    i &lt;- 1
    # stop loop when the body hits the ground
    while (getState(body)[4] &lt;= 12) {
        rowVector[[i]] &lt;- list(t  = getState(body)[4],
                               y1 = getState(body)[1],
                               y2 = getState(body)[2],
                               y3 = getState(body)[3])
        solver &lt;- step(solver)
        body   &lt;- getODE(solver)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}

# get the data table from the app
solution &lt;- RigidBodyNXFApp()
plot(solution)

</code></pre>

<hr>
<h2 id='EulerRichardson-class'>EulerRichardson ODE solver class</h2><span id='topic+EulerRichardson-class'></span><span id='topic+.EulerRichardson'></span><span id='topic+EulerRichardson'></span><span id='topic+init+2CEulerRichardson-method'></span><span id='topic+step+2CEulerRichardson-method'></span><span id='topic+EulerRichardson+2CODE-method'></span>

<h3>Description</h3>

<p>EulerRichardson ODE solver class
</p>
<p>EulerRichardson generic
</p>
<p>EulerRichardson constructor ODE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EulerRichardson(ode, ...)

## S4 method for signature 'EulerRichardson'
init(object, stepSize, ...)

## S4 method for signature 'EulerRichardson'
step(object, ...)

## S4 method for signature 'ODE'
EulerRichardson(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EulerRichardson-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="EulerRichardson-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="EulerRichardson-class_+3A_object">object</code></td>
<td>
<p>internal passing object</p>
</td></tr>
<tr><td><code id="EulerRichardson-class_+3A_stepsize">stepSize</code></td>
<td>
<p>the size of the step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++++      example: PendulumApp.R
# Simulation of a pendulum using the EulerRichardson ODE solver

suppressPackageStartupMessages(library(ggplot2))

importFromExamples("Pendulum.R")      # source the class

PendulumApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.1
    pendulum &lt;- Pendulum()
    # pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    pendulum &lt;- setStepSize(pendulum, dt = dt) # using stepSize in RK4
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 40)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],    # time
                            theta    = getState(pendulum)[1], # angle
                            thetadot = getState(pendulum)[2]) # derivative of angle
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# show solution
solution &lt;- PendulumApp()
plot(solution)
</code></pre>

<hr>
<h2 id='getEnergy'>getEnergy</h2><span id='topic+getEnergy'></span>

<h3>Description</h3>

<p>Get the calculated energy level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnergy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEnergy_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getEnergy_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># KeplerEnergy.R
#

setClass("KeplerEnergy", slots = c(
    GM        = "numeric",
    odeSolver = "Verlet",
    counter   = "numeric"
    ),
    contains = c("ODE")
)

setMethod("initialize", "KeplerEnergy", function(.Object, ...) {
    .Object@GM &lt;- 4 * pi * pi         # gravitation constant times combined mass
    .Object@state &lt;- vector("numeric", 5)  # x, vx, y, vy, t
    # .Object@odeSolver &lt;- Verlet(ode = .Object)
    .Object@odeSolver &lt;- Verlet(.Object)
    .Object@counter &lt;- 0
    return(.Object)
})

setMethod("doStep", "KeplerEnergy", function(object, ...) {
    object@odeSolver &lt;- step(object@odeSolver)
    object@state &lt;- object@odeSolver@ode@state
    object
})

setMethod("getTime", "KeplerEnergy", function(object, ...) {
    return(object@state[5])
})

setMethod("getEnergy", "KeplerEnergy", function(object, ...) {
    ke &lt;- 0.5 * (object@state[2] * object@state[2] +
                     object@state[4] * object@state[4])
    pe &lt;- -object@GM / sqrt(object@state[1] * object@state[1] +
                                object@state[3] * object@state[3])
    return(pe+ke)
})


setMethod("init", "KeplerEnergy", function(object, initState, ...) {
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})


setReplaceMethod("init", "KeplerEnergy", function(object, ..., value) {
    initState &lt;- value
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

setMethod("getRate", "KeplerEnergy", function(object, state, ...) {
    # Computes the rate using the given state.
    r2 &lt;- state[1] * state[1] + state[3] * state[3]  # distance squared
    r3 &lt;- r2 * sqrt(r2)   # distance cubed
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- (- object@GM * state[1]) / r3
    object@rate[3] &lt;- state[4]
    object@rate[4] &lt;- (- object@GM * state[3]) / r3
    object@rate[5] &lt;- 1   # time derivative

    object@counter &lt;- object@counter + 1
    object@rate

})


setMethod("getState", "KeplerEnergy", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

# constructor
KeplerEnergy &lt;- function() {
    kepler &lt;- new("KeplerEnergy")
    return(kepler)
}
</code></pre>

<hr>
<h2 id='getErrorCode'>getErrorCode</h2><span id='topic+getErrorCode'></span>

<h3>Description</h3>

<p>Get an error code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getErrorCode(object, tol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getErrorCode_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getErrorCode_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="getErrorCode_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("getErrorCode", "DormandPrince45", function(object) {
return(object@error_code)
})
</code></pre>

<hr>
<h2 id='getExactSolution'>getExactSolution</h2><span id='topic+getExactSolution'></span>

<h3>Description</h3>

<p>Compare analytical and calculated solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExactSolution(object, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExactSolution_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getExactSolution_+3A_t">t</code></td>
<td>
<p>time ath what we are performing the evaluation</p>
</td></tr>
<tr><td><code id="getExactSolution_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++  example: ComparisonRK45App.R
# Compares the solution by the RK45 ODE solver versus the analytical solution
# Example file: ComparisonRK45App.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

importFromExamples("ODETest.R")

 ComparisonRK45App &lt;- function(verbose = FALSE) {
     ode &lt;- new("ODETest")                     # create an `ODETest` object
     ode_solver &lt;- RK45(ode)                   # select the ODE solver
     ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

     # Two ways of setting the tolerance
       # ode_solver &lt;- setTolerance(ode_solver, 1e-8)  # set the tolerance
     setTolerance(ode_solver) &lt;-  1e-8

     time &lt;-  0
     rowVector &lt;- vector("list")
     i &lt;- 1
     while (time &lt; 50) {
         rowVector[[i]] &lt;- list(t  = getState(ode)[2],
                                s1 = getState(ode)[1],
                                s2 = getState(ode)[2],
                                xs = getExactSolution(ode, time),
                                counts = getRateCounts(ode),
                                time   = time
                                )
         ode_solver &lt;- step(ode_solver)           # advance one step
         stepSize   &lt;- getStepSize(ode_solver)
         time &lt;- time + stepSize
         ode  &lt;- getODE(ode_solver)                     # get updated ODE object
         i &lt;- i + 1
     }
     return(data.table::rbindlist(rowVector))    # a data table with the results
 }
# show solution
solution &lt;- ComparisonRK45App()                          # run the example
plot(solution)
# ODETest.R
# Called as base class for examples:
#                         ComparisonRK45App.R
#                         ComparisonRK45ODEApp.R

#' ODETest as an example of ODE class inheritance
#'
#' ODETest is a base class for examples ComparisonRK45App.R and
#' ComparisonRK45ODEApp.R. ODETest also uses an environment variable to store
#' the rate counts.
#'
#' @rdname ODE-class-example
#' @include ODE.R
setClass("ODETest", slots = c(
    n     = "numeric",           # counts the number of getRate evaluations
    stack = "environment"        # environnment object to accumulate rate counts
    ),
    contains = c("ODE")
    )

setMethod("initialize", "ODETest", function(.Object, ...) {
    .Object@stack$rateCounts &lt;-  0              # counter for rate calculations
    .Object@state &lt;- c(5.0, 0.0)
    return(.Object)
})

#' @rdname getExactSolution-method
setMethod("getExactSolution", "ODETest", function(object, t, ...) {
    return(5.0 * exp(-t))
})

#' @rdname getState-method
setMethod("getState", "ODETest", function(object, ...) {
    object@state
})

#' @rdname getRate-method
setMethod("getRate", "ODETest", function(object, state, ...) {
    object@rate[1] &lt;- - state[1]
    object@rate[2] &lt;-  1            # rate of change of time, dt/dt
    # accumulate how many times the rate has been called to calculate
    object@stack$rateCounts &lt;- object@stack$rateCounts + 1
    object@state &lt;- state
    object@rate
})


#' @rdname getRateCounts-method
setMethod("getRateCounts", "ODETest", function(object, ...) {
    # use environment stack to accumulate rate counts
    object@stack$rateCounts
})

# constructor
ODETest &lt;- function() {
    odetest &lt;- new("ODETest")
    odetest
}
</code></pre>

<hr>
<h2 id='getODE'>getODE</h2><span id='topic+getODE'></span>

<h3>Description</h3>

<p>Get the ODE status from the solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getODE(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getODE_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getODE_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='getRate'>getRate</h2><span id='topic+getRate'></span>

<h3>Description</h3>

<p>Get a new rate given a state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRate(object, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRate_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getRate_+3A_state">state</code></td>
<td>
<p>current state</p>
</td></tr>
<tr><td><code id="getRate_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#  Kepler models Keplerian orbits of a mass moving under the influence of an
#  inverse square force by implementing the ODE interface.
#  Kepler.R
#

setClass("Kepler", slots = c(
    GM = "numeric"
    ),
    contains = c("ODE")
)

setMethod("initialize", "Kepler", function(.Object, ...) {
    .Object@GM &lt;- 1.0                 # gravitation constant times combined mass
    .Object@state &lt;- vector("numeric", 5)  # x, vx, y, vy, t
    return(.Object)
})

setMethod("getState", "Kepler", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

setMethod("getRate", "Kepler", function(object, state, ...) {
    # Computes the rate using the given state.
    r2 &lt;- state[1] * state[1] + state[3] * state[3]  # distance squared
    r3 &lt;- r2 * sqrt(r2)   # distance cubed
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- (- object@GM * state[1]) / r3
    object@rate[3] &lt;- state[4]
    object@rate[4] &lt;- (- object@GM * state[3]) / r3
    object@rate[5] &lt;- 1   # time derivative

    object@rate

})

# constructor
Kepler &lt;- function(r, v) {
    kepler &lt;- new("Kepler")
    kepler@state[1] = r[1]
    kepler@state[2] = v[1]
    kepler@state[3] = r[2]
    kepler@state[4] = v[2]
    kepler@state[5] = 0
    return(kepler)
}
</code></pre>

<hr>
<h2 id='getRateCounter'>getRateCounter</h2><span id='topic+getRateCounter'></span>

<h3>Description</h3>

<p>Get the rate counter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRateCounter(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRateCounter_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getRateCounter_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>How many times the rate has changed with a step
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++  example: ComparisonRK45App.R
# Compares the solution by the RK45 ODE solver versus the analytical solution
# Example file: ComparisonRK45App.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

importFromExamples("ODETest.R")

 ComparisonRK45App &lt;- function(verbose = FALSE) {
     ode &lt;- new("ODETest")                     # create an `ODETest` object
     ode_solver &lt;- RK45(ode)                   # select the ODE solver
     ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

     # Two ways of setting the tolerance
       # ode_solver &lt;- setTolerance(ode_solver, 1e-8)  # set the tolerance
     setTolerance(ode_solver) &lt;-  1e-8

     time &lt;-  0
     rowVector &lt;- vector("list")
     i &lt;- 1
     while (time &lt; 50) {
         rowVector[[i]] &lt;- list(t  = getState(ode)[2],
                                s1 = getState(ode)[1],
                                s2 = getState(ode)[2],
                                xs = getExactSolution(ode, time),
                                counts = getRateCounts(ode),
                                time   = time
                                )
         ode_solver &lt;- step(ode_solver)           # advance one step
         stepSize   &lt;- getStepSize(ode_solver)
         time &lt;- time + stepSize
         ode  &lt;- getODE(ode_solver)                     # get updated ODE object
         i &lt;- i + 1
     }
     return(data.table::rbindlist(rowVector))    # a data table with the results
 }
# show solution
solution &lt;- ComparisonRK45App()                          # run the example
plot(solution)
</code></pre>

<hr>
<h2 id='getRateCounts'>getRateCounts</h2><span id='topic+getRateCounts'></span>

<h3>Description</h3>

<p>Get the number of times that the rate has been calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRateCounts(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRateCounts_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getRateCounts_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='getState'>getState</h2><span id='topic+getState'></span>

<h3>Description</h3>

<p>Get current state of the system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getState(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getState_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getState_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++   application: VanderPolApp.R
# Solution of the Van der Pol equation
#
importFromExamples("VanderPol.R")

# run the application
VanderpolApp &lt;- function(verbose = FALSE) {
    # set the orbit into a predefined state.
    y1 &lt;- 2; y2 &lt;- 0; dt &lt;- 0.1;
    rigid_body &lt;- VanderPol(y1, y2)
    solver &lt;- RK45(rigid_body)
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getState(rigid_body)[3] &lt;= 20) {
        rowVector[[i]] &lt;- list(t  = getState(rigid_body)[3],
                               y1 = getState(rigid_body)[1],
                               y2 = getState(rigid_body)[2])
        solver     &lt;- step(solver)
        rigid_body &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)

}
# show solution
solution &lt;- VanderpolApp()
plot(solution)

# ++++++++++++++++++++++++++++++++++++++++++++++++++application:  SpringRK4App.R
# Simulation of a spring considering no friction

importFromExamples("SpringRK4.R")


# run application
SpringRK4App &lt;- function(verbose = FALSE) {
    theta    &lt;- 0
    thetaDot &lt;- -0.2
    tmax     &lt;- 22; dt &lt;- 0.1
    spring &lt;- SpringRK4()
    spring@state[3] &lt;- 0      # set time to zero, t = 0
    spring &lt;- setState(spring, theta, thetaDot)
    #  spring &lt;- setStepSize(spring, dt = dt) # using stepSize in RK4
    spring@odeSolver &lt;- setStepSize(spring@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(spring)[3] &lt;= tmax)    {
        rowvec[[i]] &lt;- list(t  = getState(spring)[3],      # angle
                            y1 = getState(spring)[1],      # derivative of the angle
                            y2 = getState(spring)[2])      # time
        i &lt;- i + 1
        spring &lt;- step(spring)
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}

# show solution
solution &lt;- SpringRK4App()
plot(solution)
</code></pre>

<hr>
<h2 id='getStepSize'>getStepSize</h2><span id='topic+getStepSize'></span>

<h3>Description</h3>

<p>Get the current value of the step size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStepSize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStepSize_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getStepSize_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># +++++++++++++++++++++++++++++++++++++++++ Example:      ComparisonRK45ODEApp.R
# Updates the ODE state instead of using the internal state in the ODE solver
# Also plots the solver solution versus the analytical solution at a
# tolerance of 1e-6
# Example file: ComparisonRK45ODEApp.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

library(ggplot2)
library(dplyr)
library(tidyr)

importFromExamples("ODETest.R")

ComparisonRK45ODEApp &lt;- function(verbose = FALSE) {
    ode &lt;- new("ODETest")                         # new ODE instance
    ode_solver &lt;- RK45(ode)                       # select ODE solver
    ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

    # two ways to set tolerance
      # ode_solver &lt;- setTolerance(ode_solver, 1e-6)
    setTolerance(ode_solver) &lt;-  1e-6

    time &lt;-  0
    rowVector &lt;- vector("list")                   # row vector
    i &lt;- 1    # counter
    while (time &lt; 50) {
        # add solution objects to a row vector
        rowVector[[i]] &lt;- list(t     = getState(ode)[2],
                               ODE   = getState(ode)[1],
                               s2    = getState(ode)[2],
                               exact = getExactSolution(ode, time),
                               rate.counts = getRateCounts(ode),
                               time = time )
        ode_solver &lt;- step(ode_solver)            # advance solver one step
        stepSize &lt;-  getStepSize(ode_solver)      # get the current step size
        time  &lt;- time + stepSize
        ode   &lt;- getODE(ode_solver)               # get updated ODE object
        state &lt;- getState(ode)                    # get the `state` vector
        i &lt;- i + 1                                # add a row vector
    }
    DT &lt;- data.table::rbindlist(rowVector)        # create data table
    return(DT)
}

solution &lt;- ComparisonRK45ODEApp()
plot(solution)


# aditional plot for analytics solution vs. RK45 solver
solution.multi &lt;- solution %&gt;%
    select(t, ODE, exact)
plot(solution.multi)             # 3x3 plot

# plot comparative curves analytical vs ODE solver
solution.2x1 &lt;- solution.multi %&gt;%
    gather(key, value, -t)         # make a table of 3 variables. key: ODE/exact

g &lt;- ggplot(solution.2x1, mapping = aes(x = t, y = value, color = key))
g &lt;-  g + geom_line(size = 1) +
    labs(title = "ODE vs Exact solution",
         subtitle = "tolerance = 1E-6")
print(g)




</code></pre>

<hr>
<h2 id='getTime'>getTime</h2><span id='topic+getTime'></span>

<h3>Description</h3>

<p>Get the elapsed time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTime(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTime_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getTime_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># +++++++++++++++++++++++++++++++++++++++++++++++++++   application:  Logistic.R
# Simulates the logistic equation
importFromExamples("Logistic.R")

# Run the application
LogisticApp &lt;- function(verbose = FALSE) {
    x  &lt;- 0.1
    vx &lt;- 0
    r  &lt;- 2        # Malthusian parameter (rate of maximum population growth)
    K  &lt;- 10.0     # carrying capacity of the environment
    dt   &lt;- 0.01; tol  &lt;- 1e-3; tmax &lt;- 10

    population &lt;- Logistic()                # create a Logistic ODE object

    # Two ways of initializing the object
      # population &lt;- init(population, c(x, vx, 0), r, K)
    init(population) &lt;-  list(initState = c(x, vx, 0),
                              r = r,
                              K = K)

    odeSolver &lt;- Verlet(population)        # select the solver

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    population@odeSolver &lt;- odeSolver
    # setSolver(population) &lt;-  odeSolver

    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(population) &lt;= tmax) {
        rowVector[[i]] &lt;- list(t = getTime(population),
                               s1 = getState(population)[1],
                               s2 = getState(population)[2])
        population &lt;- doStep(population)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}
# show solution
solution &lt;- LogisticApp()
plot(solution)
# KeplerEnergy.R
#

setClass("KeplerEnergy", slots = c(
    GM        = "numeric",
    odeSolver = "Verlet",
    counter   = "numeric"
    ),
    contains = c("ODE")
)

setMethod("initialize", "KeplerEnergy", function(.Object, ...) {
    .Object@GM &lt;- 4 * pi * pi         # gravitation constant times combined mass
    .Object@state &lt;- vector("numeric", 5)  # x, vx, y, vy, t
    # .Object@odeSolver &lt;- Verlet(ode = .Object)
    .Object@odeSolver &lt;- Verlet(.Object)
    .Object@counter &lt;- 0
    return(.Object)
})

setMethod("doStep", "KeplerEnergy", function(object, ...) {
    object@odeSolver &lt;- step(object@odeSolver)
    object@state &lt;- object@odeSolver@ode@state
    object
})

setMethod("getTime", "KeplerEnergy", function(object, ...) {
    return(object@state[5])
})

setMethod("getEnergy", "KeplerEnergy", function(object, ...) {
    ke &lt;- 0.5 * (object@state[2] * object@state[2] +
                     object@state[4] * object@state[4])
    pe &lt;- -object@GM / sqrt(object@state[1] * object@state[1] +
                                object@state[3] * object@state[3])
    return(pe+ke)
})


setMethod("init", "KeplerEnergy", function(object, initState, ...) {
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})


setReplaceMethod("init", "KeplerEnergy", function(object, ..., value) {
    initState &lt;- value
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

setMethod("getRate", "KeplerEnergy", function(object, state, ...) {
    # Computes the rate using the given state.
    r2 &lt;- state[1] * state[1] + state[3] * state[3]  # distance squared
    r3 &lt;- r2 * sqrt(r2)   # distance cubed
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- (- object@GM * state[1]) / r3
    object@rate[3] &lt;- state[4]
    object@rate[4] &lt;- (- object@GM * state[3]) / r3
    object@rate[5] &lt;- 1   # time derivative

    object@counter &lt;- object@counter + 1
    object@rate

})


setMethod("getState", "KeplerEnergy", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

# constructor
KeplerEnergy &lt;- function() {
    kepler &lt;- new("KeplerEnergy")
    return(kepler)
}
</code></pre>

<hr>
<h2 id='getTolerance'>getTolerance</h2><span id='topic+getTolerance'></span>

<h3>Description</h3>

<p>Get the tolerance for the solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTolerance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTolerance_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="getTolerance_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='importFromExamples'>importFromExamples</h2><span id='topic+importFromExamples'></span>

<h3>Description</h3>

<p>Source the R script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importFromExamples(aClassFile, aFolder = "examples")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importFromExamples_+3A_aclassfile">aClassFile</code></td>
<td>
<p>a file containing one or more classes</p>
</td></tr>
<tr><td><code id="importFromExamples_+3A_afolder">aFolder</code></td>
<td>
<p>a folder where examples are located</p>
</td></tr>
</table>

<hr>
<h2 id='init'>init</h2><span id='topic+init'></span><span id='topic+init+3C-'></span>

<h3>Description</h3>

<p>Set initial values before starting the ODE solver
</p>
<p>Set initial values before starting the ODE solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(object, ...)

init(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="init_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="init_+3A_value">value</code></td>
<td>
<p>a value to set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets the tolerance like this: solver &lt;- init(solver, dt)
Not all super classes require an init method.
</p>
<p>Sets the tolerance like this: init(solver) &lt;- dt
</p>


<h3>Examples</h3>

<pre><code class='language-R'># init method in Kepler.R
setMethod("init", "Kepler", function(object, initState, ...) {
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

# init method in LogisticApp.R
setMethod("init", "Logistic", function(object, initState, r, K, ...) {
    object@r &lt;- r
    object@K &lt;- K
    object@state &lt;- initState
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@counter &lt;- 0
    object
})

# init method in Planet.R
setMethod("init", "Planet", function(object, initState, ...) {
    object@state &lt;- object@odeSolver@ode@state &lt;- initState
    # initialize providing the step size
    object@odeSolver &lt;- init(object@odeSolver, getStepSize(object@odeSolver))
    object@rate &lt;- object@odeSolver@ode@rate
    object@state &lt;- object@odeSolver@ode@state
    object
})
</code></pre>

<hr>
<h2 id='ODE-class'>ODE class</h2><span id='topic+ODE-class'></span><span id='topic+ODE'></span><span id='topic+getState+2CODE-method'></span><span id='topic+getState+2CgetState-method'></span><span id='topic+getRate+2CODE-method'></span><span id='topic+getRate+2CgetRate-method'></span>

<h3>Description</h3>

<p>Defines an ODE object for any solver
</p>
<p>ODE constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODE()

## S4 method for signature 'ODE'
getState(object, ...)

## S4 method for signature 'ODE'
getRate(object, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODE-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="ODE-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="ODE-class_+3A_state">state</code></td>
<td>
<p>current state</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++++      example: PendulumApp.R
# Simulation of a pendulum using the EulerRichardson ODE solver

suppressPackageStartupMessages(library(ggplot2))

importFromExamples("Pendulum.R")      # source the class

PendulumApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.1
    pendulum &lt;- Pendulum()
    # pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    pendulum &lt;- setStepSize(pendulum, dt = dt) # using stepSize in RK4
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 40)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],    # time
                            theta    = getState(pendulum)[1], # angle
                            thetadot = getState(pendulum)[2]) # derivative of angle
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# show solution
solution &lt;- PendulumApp()
plot(solution)
# +++++++++++++++++++++++++++++++++++++++++++++++++  example: PendulumEulerApp.R
# Pendulum simulation with the Euler ODE solver
# Notice how Euler is not applicable in this case as it diverges very quickly
# even when it is using a very small `delta t``?ODE

importFromExamples("PendulumEuler.R")      # source the class

PendulumEulerApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.01
    pendulum &lt;- PendulumEuler()
    pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    stepSize &lt;- dt
    pendulum &lt;- setStepSize(pendulum, stepSize)
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 50)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],
                            theta    = getState(pendulum)[1],
                            thetaDot = getState(pendulum)[2])
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}

solution &lt;- PendulumEulerApp()
plot(solution)
#  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ example KeplerApp.R
#  KeplerApp solves an inverse-square law model (Kepler model) using an adaptive
#  stepsize algorithm.
#  Application showing two planet orbiting
#  File in examples: KeplerApp.R

importFromExamples("Kepler.R") # source the class Kepler

KeplerApp &lt;- function(verbose = FALSE) {

    # set the orbit into a predefined state.
    r &lt;- c(2, 0)                                   # orbit radius
    v &lt;- c(0, 0.25)                                # velocity
    dt &lt;- 0.1
    planet &lt;- Kepler(r, v)                         # make up an ODE object
    solver &lt;- RK45(planet)
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getState(planet)[5] &lt;= 10) {
        rowVector[[i]] &lt;- list(t  = planet@state[5],
                               planet1.r = getState(planet)[1],
                               p1anet1.v = getState(planet)[2],
                               planet2.r = getState(planet)[3],
                               p1anet2.v = getState(planet)[4])
        solver &lt;- step(solver)
        planet &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)

    return(DT)
}

solution &lt;- KeplerApp()
plot(solution)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ base class: FallingParticleODE.R
# Class definition for application FallingParticleODEApp.R

setClass("FallingParticleODE", slots = c(
        g = "numeric"
        ),
        prototype = prototype(
            g = 9.8
        ),
        contains = c("ODE")
        )


setMethod("initialize", "FallingParticleODE", function(.Object, ...) {
    .Object@state &lt;- vector("numeric", 3)
    return(.Object)
})

setMethod("getState", "FallingParticleODE", function(object, ...) {
    # Gets the state variables.
    return(object@state)
})

setMethod("getRate", "FallingParticleODE", function(object, state, ...) {
    # Gets the rate of change using the argument's state variables.
    object@rate[1] &lt;- state[2]
    object@rate[2] &lt;- - object@g
    object@rate[3] &lt;- 1

    object@rate
})

# constructor
FallingParticleODE &lt;- function(y, v) {
    .FallingParticleODE &lt;- new("FallingParticleODE")
    .FallingParticleODE@state[1] &lt;- y
    .FallingParticleODE@state[2] &lt;- v
    .FallingParticleODE@state[3] &lt;- 0
    .FallingParticleODE
}
</code></pre>

<hr>
<h2 id='ODEAdaptiveSolver-class'>ODEAdaptiveSolver class</h2><span id='topic+ODEAdaptiveSolver-class'></span><span id='topic+.ODEAdaptiveSolver'></span><span id='topic+ODEAdaptiveSolver'></span><span id='topic+setTolerance+2CODEAdaptiveSolver-method'></span><span id='topic+setTolerance+3C-+2CODEAdaptiveSolver-method'></span><span id='topic+getTolerance+2CODEAdaptiveSolver-method'></span><span id='topic+getErrorCode+2CODEAdaptiveSolver-method'></span><span id='topic+ODEAdaptiveSolver+2CANY-method'></span>

<h3>Description</h3>

<p>Base class to be inherited by adaptive solvers such as RK45
</p>
<p>ODEAdaptiveSolver generic
</p>
<p>ODEAdaptiveSolver constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODEAdaptiveSolver(...)

## S4 method for signature 'ODEAdaptiveSolver'
setTolerance(object, tol)

## S4 replacement method for signature 'ODEAdaptiveSolver'
setTolerance(object, ...) &lt;- value

## S4 method for signature 'ODEAdaptiveSolver'
getTolerance(object)

## S4 method for signature 'ODEAdaptiveSolver'
getErrorCode(object)

## S4 method for signature 'ANY'
ODEAdaptiveSolver(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEAdaptiveSolver-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="ODEAdaptiveSolver-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="ODEAdaptiveSolver-class_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="ODEAdaptiveSolver-class_+3A_value">value</code></td>
<td>
<p>the value for the tolerance</p>
</td></tr>
</table>

<hr>
<h2 id='ODESolver-class'>ODESolver virtual class</h2><span id='topic+ODESolver-class'></span><span id='topic+.ODESolver'></span><span id='topic+ODESolver'></span><span id='topic+init+2CODESolver-method'></span><span id='topic+step+2CODESolver-method'></span><span id='topic+getODE+2CODESolver-method'></span><span id='topic+setStepSize+2CODESolver-method'></span><span id='topic+getStepSize+2CODESolver-method'></span>

<h3>Description</h3>

<p>A virtual class inherited by AbstractODESolver
</p>
<p>ODESolver constructor
</p>
<p>Set initial values and get ready to start the solver
</p>
<p>Set the size of the step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODESolver(object, stepSize, ...)

## S4 method for signature 'ODESolver'
init(object, stepSize, ...)

## S4 method for signature 'ODESolver'
step(object, ...)

## S4 method for signature 'ODESolver'
getODE(object, ...)

## S4 method for signature 'ODESolver'
setStepSize(object, stepSize, ...)

## S4 method for signature 'ODESolver'
getStepSize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODESolver-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="ODESolver-class_+3A_stepsize">stepSize</code></td>
<td>
<p>size of the step</p>
</td></tr>
<tr><td><code id="ODESolver-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ODESolver helpers: <code><a href="#topic+ODESolverFactory-class">ODESolverFactory-class</a></code>
</p>

<hr>
<h2 id='ODESolverFactory-class'>ODESolverFactory</h2><span id='topic+ODESolverFactory-class'></span><span id='topic+.ODESolverFactory'></span><span id='topic+ODESolverFactory'></span><span id='topic+createODESolver'></span><span id='topic+createODESolver+2CODESolverFactory-method'></span><span id='topic+ODESolverFactory+2CANY-method'></span>

<h3>Description</h3>

<p>ODESolverFactory helps to create a solver given only the name as string
</p>
<p>ODESolverFactory generic
</p>
<p>This is a factory method that creates an ODESolver using a name.
</p>
<p>ODESolverFactory constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODESolverFactory(...)

createODESolver(object, ...)

## S4 method for signature 'ODESolverFactory'
createODESolver(object, ode, solverName, ...)

## S4 method for signature 'ANY'
ODESolverFactory(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODESolverFactory-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="ODESolverFactory-class_+3A_object">object</code></td>
<td>
<p>an solver object</p>
</td></tr>
<tr><td><code id="ODESolverFactory-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="ODESolverFactory-class_+3A_solvername">solverName</code></td>
<td>
<p>the desired solver as a string</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ODESolver helpers: <code><a href="#topic+ODESolver-class">ODESolver-class</a></code>
</p>
<p>Other ODESolver helpers: <code><a href="#topic+ODESolver-class">ODESolver-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example uses ODESolverFactory

importFromExamples("SHO.R")

# SHOApp.R
SHOApp &lt;- function(...) {
    x &lt;- 1.0; v &lt;- 0; k &lt;- 1.0; dt &lt;- 0.01; tolerance &lt;- 1e-3
    sho    &lt;- SHO(x, v, k)

    # Use ODESolverFactory
    solver_factory &lt;- ODESolverFactory()
    solver &lt;- createODESolver(solver_factory, sho, "DormandPrince45")
    # solver &lt;- DormandPrince45(sho)                    # this can also be used

    # Two ways of setting the tolerance
    # solver &lt;- setTolerance(solver, tolerance)           # or this below
    setTolerance(solver) &lt;-  tolerance

    # Two ways of initializing the solver
      # solver &lt;- init(solver, dt)
    init(solver) &lt;- dt

    i &lt;- 1; rowVector &lt;- vector("list")
    while (getState(sho)[3] &lt;= 500) {
        rowVector[[i]] &lt;- list(x = getState(sho)[1],
                               v = getState(sho)[2],
                               t = getState(sho)[3])
        solver &lt;- step(solver)
        sho    &lt;- getODE(solver)
        i &lt;- i + 1
    }
    return(data.table::rbindlist(rowVector))
}

solution &lt;- SHOApp()
plot(solution)


# This example uses ODESolverFactory

importFromExamples("SHO.R")

# SHOApp.R
SHOApp &lt;- function(...) {
    x &lt;- 1.0; v &lt;- 0; k &lt;- 1.0; dt &lt;- 0.01; tolerance &lt;- 1e-3
    sho    &lt;- SHO(x, v, k)

    # Use ODESolverFactory
    solver_factory &lt;- ODESolverFactory()
    solver &lt;- createODESolver(solver_factory, sho, "DormandPrince45")
    # solver &lt;- DormandPrince45(sho)                    # this can also be used

    # Two ways of setting the tolerance
    # solver &lt;- setTolerance(solver, tolerance)           # or this below
    setTolerance(solver) &lt;-  tolerance

    # Two ways of initializing the solver
      # solver &lt;- init(solver, dt)
    init(solver) &lt;- dt

    i &lt;- 1; rowVector &lt;- vector("list")
    while (getState(sho)[3] &lt;= 500) {
        rowVector[[i]] &lt;- list(x = getState(sho)[1],
                               v = getState(sho)[2],
                               t = getState(sho)[3])
        solver &lt;- step(solver)
        sho    &lt;- getODE(solver)
        i &lt;- i + 1
    }
    return(data.table::rbindlist(rowVector))
}

solution &lt;- SHOApp()
plot(solution)


</code></pre>

<hr>
<h2 id='RK4-class'>RK4 class</h2><span id='topic+RK4-class'></span><span id='topic+.RK4'></span><span id='topic+RK4'></span><span id='topic+init+2CRK4-method'></span><span id='topic+init+3C-+2CRK4-method'></span><span id='topic+step+2CRK4-method'></span><span id='topic+RK4+2CODE-method'></span>

<h3>Description</h3>

<p>RK4 class
</p>
<p>RK4 generic
</p>
<p>RK4 class constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK4(ode, ...)

## S4 method for signature 'RK4'
init(object, stepSize, ...)

## S4 replacement method for signature 'RK4'
init(object, ...) &lt;- value

## S4 method for signature 'RK4'
step(object, ...)

## S4 method for signature 'ODE'
RK4(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK4-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="RK4-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="RK4-class_+3A_object">object</code></td>
<td>
<p>internal passing object</p>
</td></tr>
<tr><td><code id="RK4-class_+3A_stepsize">stepSize</code></td>
<td>
<p>the size of the step</p>
</td></tr>
<tr><td><code id="RK4-class_+3A_value">value</code></td>
<td>
<p>value for the step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  base class: Projectile.R
# Projectile class to be solved with Euler method


setClass("Projectile", slots = c(
    g = "numeric",
    odeSolver = "RK4"
    ),
    prototype = prototype(
        g = 9.8
    ),
    contains = c("ODE")
    )

setMethod("initialize", "Projectile", function(.Object) {
    .Object@odeSolver &lt;- RK4(.Object)
    return(.Object)
})

setMethod("setStepSize", "Projectile", function(object, stepSize, ...) {
    # use explicit parameter declaration
    # setStepSize generic has two step parameters: stepSize and dt
    object@odeSolver &lt;- setStepSize(object@odeSolver, stepSize)
    object
})


setMethod("step", "Projectile", function(object) {
    object@odeSolver &lt;- step(object@odeSolver)
    object@rate  &lt;- object@odeSolver@ode@rate
    object@state &lt;- object@odeSolver@ode@state
    object
})


setMethod("setState", signature("Projectile"), function(object, x, vx, y, vy, ...) {
    object@state[1] &lt;- x
    object@state[2] &lt;- vx
    object@state[3] &lt;- y
    object@state[4] &lt;- vy
    object@state[5] &lt;- 0     # t + dt
    object@odeSolver@ode@state &lt;- object@state
    object
})


setMethod("getState", "Projectile", function(object) {
    object@state
})


setMethod("getRate", "Projectile", function(object, state, ...) {
    object@rate[1] &lt;- state[2]     # rate of change of x
    object@rate[2] &lt;- 0            # rate of change of vx
    object@rate[3] &lt;- state[4]     # rate of change of y
    object@rate[4] &lt;- - object@g   # rate of change of vy
    object@rate[5] &lt;- 1            # dt/dt = 1

    object@rate
})


# constructor
Projectile &lt;- function()  new("Projectile")
# ++++++++++++++++++++++++++++++++++++++++++++++++++      example: PendulumApp.R
# Simulation of a pendulum using the EulerRichardson ODE solver

suppressPackageStartupMessages(library(ggplot2))

importFromExamples("Pendulum.R")      # source the class

PendulumApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.1
    pendulum &lt;- Pendulum()
    # pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    pendulum &lt;- setStepSize(pendulum, dt = dt) # using stepSize in RK4
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 40)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],    # time
                            theta    = getState(pendulum)[1], # angle
                            thetadot = getState(pendulum)[2]) # derivative of angle
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# show solution
solution &lt;- PendulumApp()
plot(solution)
# +++++++++++++++++++++++++++++++++++++++++++++++++++ application: ReactionApp.R
# ReactionApp solves an autocatalytic oscillating chemical
# reaction (Brusselator model) using
# a fourth-order Runge-Kutta algorithm.

importFromExamples("Reaction.R")      # source the class

ReactionApp &lt;- function(verbose = FALSE) {
    X &lt;- 1; Y &lt;- 5;
    dt &lt;- 0.1

    reaction &lt;- Reaction(c(X, Y, 0))
    solver &lt;- RK4(reaction)
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(reaction)[3] &lt; 100) {             # stop at t = 100
        rowvec[[i]] &lt;- list(t = getState(reaction)[3],
                            X = getState(reaction)[1],
                            Y = getState(reaction)[2])
        solver   &lt;- step(solver)
        reaction &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}


solution &lt;- ReactionApp()
plot(solution)


</code></pre>

<hr>
<h2 id='RK45-class'>RK45 ODE solver class</h2><span id='topic+RK45-class'></span><span id='topic+RK45'></span>

<h3>Description</h3>

<p>RK45 ODE solver class
</p>
<p>RK45 class constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK45(ode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK45-class_+3A_ode">ode</code></td>
<td>
<p>and ODE object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++  example: ComparisonRK45App.R
# Compares the solution by the RK45 ODE solver versus the analytical solution
# Example file: ComparisonRK45App.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

importFromExamples("ODETest.R")

 ComparisonRK45App &lt;- function(verbose = FALSE) {
     ode &lt;- new("ODETest")                     # create an `ODETest` object
     ode_solver &lt;- RK45(ode)                   # select the ODE solver
     ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

     # Two ways of setting the tolerance
       # ode_solver &lt;- setTolerance(ode_solver, 1e-8)  # set the tolerance
     setTolerance(ode_solver) &lt;-  1e-8

     time &lt;-  0
     rowVector &lt;- vector("list")
     i &lt;- 1
     while (time &lt; 50) {
         rowVector[[i]] &lt;- list(t  = getState(ode)[2],
                                s1 = getState(ode)[1],
                                s2 = getState(ode)[2],
                                xs = getExactSolution(ode, time),
                                counts = getRateCounts(ode),
                                time   = time
                                )
         ode_solver &lt;- step(ode_solver)           # advance one step
         stepSize   &lt;- getStepSize(ode_solver)
         time &lt;- time + stepSize
         ode  &lt;- getODE(ode_solver)                     # get updated ODE object
         i &lt;- i + 1
     }
     return(data.table::rbindlist(rowVector))    # a data table with the results
 }
# show solution
solution &lt;- ComparisonRK45App()                          # run the example
plot(solution)
#  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ example KeplerApp.R
#  KeplerApp solves an inverse-square law model (Kepler model) using an adaptive
#  stepsize algorithm.
#  Application showing two planet orbiting
#  File in examples: KeplerApp.R

importFromExamples("Kepler.R") # source the class Kepler

KeplerApp &lt;- function(verbose = FALSE) {

    # set the orbit into a predefined state.
    r &lt;- c(2, 0)                                   # orbit radius
    v &lt;- c(0, 0.25)                                # velocity
    dt &lt;- 0.1
    planet &lt;- Kepler(r, v)                         # make up an ODE object
    solver &lt;- RK45(planet)
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getState(planet)[5] &lt;= 10) {
        rowVector[[i]] &lt;- list(t  = planet@state[5],
                               planet1.r = getState(planet)[1],
                               p1anet1.v = getState(planet)[2],
                               planet2.r = getState(planet)[3],
                               p1anet2.v = getState(planet)[4])
        solver &lt;- step(solver)
        planet &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)

    return(DT)
}

solution &lt;- KeplerApp()
plot(solution)


</code></pre>

<hr>
<h2 id='run_test_applications'>run_test_applications</h2><span id='topic+run_test_applications'></span>

<h3>Description</h3>

<p>Run test all the examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_test_applications()
</code></pre>

<hr>
<h2 id='setSolver+26lt+3B-'>setSolver</h2><span id='topic+setSolver+3C-'></span>

<h3>Description</h3>

<p>Set a solver over an ODE object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSolver(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSolver+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="setSolver+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>value to be set</p>
</td></tr>
</table>

<hr>
<h2 id='setState'>setState</h2><span id='topic+setState'></span>

<h3>Description</h3>

<p>New setState that should work with different methods
&quot;theta&quot;, &quot;thetaDot&quot;:  used in PendulumApp
&quot;x&quot;, &quot;vx&quot;, &quot;y&quot;, &quot;vy&quot;: used in ProjectileApp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setState(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setState_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="setState_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># +++++++++++++++++++++++++++++++++++++++++++++++++ application: ProjectileApp.R
#                                                      test Projectile with RK4
#                                                      originally uses Euler

# suppressMessages(library(data.table))

importFromExamples("Projectile.R")      # source the class

ProjectileApp &lt;- function(verbose = FALSE) {
    # initial values
    x &lt;- 0; vx &lt;- 10; y &lt;- 0; vy &lt;- 10
    state &lt;- c(x, vx, y, vy, 0)                        # state vector
    dt &lt;- 0.01

    projectile &lt;- Projectile()
    projectile &lt;- setState(projectile, x, vx, y, vy)

    projectile@odeSolver &lt;- init(projectile@odeSolver, 0.123)

    # init(projectile) &lt;-  0.123

    projectile@odeSolver &lt;- setStepSize(projectile@odeSolver, dt)
    rowV &lt;- vector("list")
    i &lt;- 1
    while (getState(projectile)[3] &gt;= 0)    {
        rowV[[i]] &lt;- list(t  = getState(projectile)[5],
                          x  = getState(projectile)[1],
                          vx = getState(projectile)[2],
                          y  = getState(projectile)[3],     # vertical position
                          vy = getState(projectile)[4])
        projectile &lt;- step(projectile)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowV)
    return(DT)
}


solution &lt;- ProjectileApp()
plot(solution)
# ++++++++++++++++++++++++++++++++++++++++++++++++++      example: PendulumApp.R
# Simulation of a pendulum using the EulerRichardson ODE solver

suppressPackageStartupMessages(library(ggplot2))

importFromExamples("Pendulum.R")      # source the class

PendulumApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.1
    pendulum &lt;- Pendulum()
    # pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    pendulum &lt;- setStepSize(pendulum, dt = dt) # using stepSize in RK4
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 40)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],    # time
                            theta    = getState(pendulum)[1], # angle
                            thetadot = getState(pendulum)[2]) # derivative of angle
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# show solution
solution &lt;- PendulumApp()
plot(solution)
</code></pre>

<hr>
<h2 id='setStepSize'>setStepSize</h2><span id='topic+setStepSize'></span>

<h3>Description</h3>

<p>setStepSize uses either of two step parameters: stepSize and dt
stepSize works for most of the applications
dt is used in Pendulum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setStepSize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setStepSize_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="setStepSize_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++++application:  SpringRK4App.R
# Simulation of a spring considering no friction

importFromExamples("SpringRK4.R")


# run application
SpringRK4App &lt;- function(verbose = FALSE) {
    theta    &lt;- 0
    thetaDot &lt;- -0.2
    tmax     &lt;- 22; dt &lt;- 0.1
    spring &lt;- SpringRK4()
    spring@state[3] &lt;- 0      # set time to zero, t = 0
    spring &lt;- setState(spring, theta, thetaDot)
    #  spring &lt;- setStepSize(spring, dt = dt) # using stepSize in RK4
    spring@odeSolver &lt;- setStepSize(spring@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(spring)[3] &lt;= tmax)    {
        rowvec[[i]] &lt;- list(t  = getState(spring)[3],      # angle
                            y1 = getState(spring)[1],      # derivative of the angle
                            y2 = getState(spring)[2])      # time
        i &lt;- i + 1
        spring &lt;- step(spring)
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}

# show solution
solution &lt;- SpringRK4App()
plot(solution)
# ++++++++++++++++++++++++++++++++++++++++++++++++  example: ComparisonRK45App.R
# Compares the solution by the RK45 ODE solver versus the analytical solution
# Example file: ComparisonRK45App.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

importFromExamples("ODETest.R")

 ComparisonRK45App &lt;- function(verbose = FALSE) {
     ode &lt;- new("ODETest")                     # create an `ODETest` object
     ode_solver &lt;- RK45(ode)                   # select the ODE solver
     ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

     # Two ways of setting the tolerance
       # ode_solver &lt;- setTolerance(ode_solver, 1e-8)  # set the tolerance
     setTolerance(ode_solver) &lt;-  1e-8

     time &lt;-  0
     rowVector &lt;- vector("list")
     i &lt;- 1
     while (time &lt; 50) {
         rowVector[[i]] &lt;- list(t  = getState(ode)[2],
                                s1 = getState(ode)[1],
                                s2 = getState(ode)[2],
                                xs = getExactSolution(ode, time),
                                counts = getRateCounts(ode),
                                time   = time
                                )
         ode_solver &lt;- step(ode_solver)           # advance one step
         stepSize   &lt;- getStepSize(ode_solver)
         time &lt;- time + stepSize
         ode  &lt;- getODE(ode_solver)                     # get updated ODE object
         i &lt;- i + 1
     }
     return(data.table::rbindlist(rowVector))    # a data table with the results
 }
# show solution
solution &lt;- ComparisonRK45App()                          # run the example
plot(solution)
</code></pre>

<hr>
<h2 id='setTolerance'>setTolerance</h2><span id='topic+setTolerance'></span><span id='topic+setTolerance+3C-'></span>

<h3>Description</h3>

<p>Set the tolerance for the solver
</p>
<p>Set the tolerance for the solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTolerance(object, tol)

setTolerance(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTolerance_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="setTolerance_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="setTolerance_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="setTolerance_+3A_value">value</code></td>
<td>
<p>a value to set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets the tolerance like this: odeSolver &lt;- setTolerance(odeSolver, tol)
</p>
<p>Sets the tolerance like this: setTolerance(odeSolver) &lt;- tol
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++  example: ComparisonRK45App.R
# Compares the solution by the RK45 ODE solver versus the analytical solution
# Example file: ComparisonRK45App.R
# ODE Solver:   Runge-Kutta 45
# ODE class :   RK45
# Base class:   ODETest

importFromExamples("ODETest.R")

 ComparisonRK45App &lt;- function(verbose = FALSE) {
     ode &lt;- new("ODETest")                     # create an `ODETest` object
     ode_solver &lt;- RK45(ode)                   # select the ODE solver
     ode_solver &lt;- setStepSize(ode_solver, 1)      # set the step

     # Two ways of setting the tolerance
       # ode_solver &lt;- setTolerance(ode_solver, 1e-8)  # set the tolerance
     setTolerance(ode_solver) &lt;-  1e-8

     time &lt;-  0
     rowVector &lt;- vector("list")
     i &lt;- 1
     while (time &lt; 50) {
         rowVector[[i]] &lt;- list(t  = getState(ode)[2],
                                s1 = getState(ode)[1],
                                s2 = getState(ode)[2],
                                xs = getExactSolution(ode, time),
                                counts = getRateCounts(ode),
                                time   = time
                                )
         ode_solver &lt;- step(ode_solver)           # advance one step
         stepSize   &lt;- getStepSize(ode_solver)
         time &lt;- time + stepSize
         ode  &lt;- getODE(ode_solver)                     # get updated ODE object
         i &lt;- i + 1
     }
     return(data.table::rbindlist(rowVector))    # a data table with the results
 }
# show solution
solution &lt;- ComparisonRK45App()                          # run the example
plot(solution)
# ++++++++++++++++++++++++++++++++++++++++++ example: KeplerDormandPrince45App.R
# Demostration of the use of ODE solver RK45 for a particle subjected to
# a inverse-law force. The difference with the example KeplerApp is we are
# seeing the effect in thex and y axis on the particle.
# The original routine used the Verlet ODE solver

importFromExamples("KeplerDormandPrince45.R")

set_solver &lt;- function(ode_object, solver) {
    slot(ode_object, "odeSolver") &lt;- solver
    ode_object
}

KeplerDormandPrince45App &lt;- function(verbose = FALSE) {
    # values for the examples
    x  &lt;- 1
    vx &lt;- 0
    y  &lt;- 0
    vy &lt;- 2 * pi
    dt &lt;- 0.01          # step size
    tol &lt;- 1e-3         # tolerance
    particle  &lt;- KeplerDormandPrince45()                      # use class Kepler

    # Two ways of initializing the ODE object
      # particle  &lt;- init(particle, c(x, vx, y, vy, 0))  # enter state vector
    init(particle) &lt;- c(x, vx, y, vy, 0)

    odeSolver &lt;- DormandPrince45(particle)      # select the ODE solver

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)            # start the solver
    init(odeSolver) &lt;-  dt

    # Two ways of setting the tolerance
      # odeSolver &lt;- setTolerance(odeSolver, tol) # this works for adaptive solvers
    setTolerance(odeSolver) &lt;- tol
    setSolver(particle) &lt;-  odeSolver

    initialEnergy &lt;- getEnergy(particle)        # calculate the energy
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(particle) &lt; 1.5) {
    rowVector[[i]] &lt;- list(t  = getState(particle)[5],
                           x  = getState(particle)[1],
                           vx = getState(particle)[2],
                           y  = getState(particle)[3],
                           vx = getState(particle)[4],
                           energy = getEnergy(particle) )
        particle &lt;- doStep(particle)            # advance one step
        energy   &lt;- getEnergy(particle)         # calculate energy
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}

solution &lt;- KeplerDormandPrince45App()
plot(solution)


importFromExamples("AdaptiveStep.R")

# running function
AdaptiveStepApp &lt;- function(verbose = FALSE) {
    ode        &lt;- new("Impulse")
    ode_solver &lt;- RK45(ode)

    # Two ways to initialize the solver
      # ode_solver &lt;- init(ode_solver, 0.1)
    init(ode_solver) &lt;- 0.1

    # two ways to set tolerance
      # ode_solver &lt;- setTolerance(ode_solver, 1.0e-4)
    setTolerance(ode_solver) &lt;- 1.0e-4

    i &lt;- 1; rowVector &lt;- vector("list")
    while (getState(ode)[1] &lt; 12) {
        rowVector[[i]] &lt;- list(s1 = getState(ode)[1],
                               s2 = getState(ode)[2],
                               t  = getState(ode)[3])
        ode_solver &lt;- step(ode_solver)
        ode &lt;- getODE(ode_solver)
        i &lt;- i + 1
    }
    return(data.table::rbindlist(rowVector))
}

# run application
solution &lt;- AdaptiveStepApp()
plot(solution)
</code></pre>

<hr>
<h2 id='showMethods2'>showMethods2</h2><span id='topic+showMethods2'></span>

<h3>Description</h3>

<p>Get the methods in a class. But only those specific to the class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showMethods2(theClass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showMethods2_+3A_theclass">theClass</code></td>
<td>
<p>class to analyze</p>
</td></tr>
</table>

<hr>
<h2 id='step'>step</h2><span id='topic+step'></span>

<h3>Description</h3>

<p>Advances a step within the ODE solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="step_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># +++++++++++++++++++++++++++++++++++++++++++++++++++ application: ReactionApp.R
# ReactionApp solves an autocatalytic oscillating chemical
# reaction (Brusselator model) using
# a fourth-order Runge-Kutta algorithm.

importFromExamples("Reaction.R")      # source the class

ReactionApp &lt;- function(verbose = FALSE) {
    X &lt;- 1; Y &lt;- 5;
    dt &lt;- 0.1

    reaction &lt;- Reaction(c(X, Y, 0))
    solver &lt;- RK4(reaction)
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(reaction)[3] &lt; 100) {             # stop at t = 100
        rowvec[[i]] &lt;- list(t = getState(reaction)[3],
                            X = getState(reaction)[1],
                            Y = getState(reaction)[2])
        solver   &lt;- step(solver)
        reaction &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}


solution &lt;- ReactionApp()
plot(solution)


</code></pre>

<hr>
<h2 id='Verlet-class'>Verlet ODE solver class</h2><span id='topic+Verlet-class'></span><span id='topic+.Verlet'></span><span id='topic+Verlet'></span><span id='topic+init+2CVerlet-method'></span><span id='topic+init-methods'></span><span id='topic+getRateCounter+2CVerlet-method'></span><span id='topic+getRateCounter+2CgetRateCounter-method'></span><span id='topic+step+2CVerlet-method'></span><span id='topic+Verlet+2CODE-method'></span>

<h3>Description</h3>

<p>Verlet ODE solver class
</p>
<p>Verlet generic
</p>
<p>Verlet class constructor ODE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Verlet(ode, ...)

## S4 method for signature 'Verlet'
init(object, stepSize, ...)

## S4 method for signature 'Verlet'
getRateCounter(object, ...)

## S4 method for signature 'Verlet'
step(object, ...)

## S4 method for signature 'ODE'
Verlet(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Verlet-class_+3A_ode">ode</code></td>
<td>
<p>an ODE object</p>
</td></tr>
<tr><td><code id="Verlet-class_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="Verlet-class_+3A_object">object</code></td>
<td>
<p>a class object</p>
</td></tr>
<tr><td><code id="Verlet-class_+3A_stepsize">stepSize</code></td>
<td>
<p>size of the step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ++++++++++++++++++++++++++++++++++++++++++++++++++  example: KeplerEnergyApp.R
# Demostration of the use of the Verlet ODE solver
#

importFromExamples("KeplerEnergy.R") # source the class Kepler

KeplerEnergyApp &lt;- function(verbose = FALSE) {
    # initial values
    x  &lt;- 1
    vx &lt;- 0
    y  &lt;- 0
    vy &lt;- 2 * pi
    dt &lt;- 0.01
    tol &lt;- 1e-3
    particle &lt;- KeplerEnergy()

    # Two ways of initializing the ODE object
      # particle &lt;- init(particle, c(x, vx, y, vy, 0))
    init(particle) &lt;- c(x, vx, y, vy, 0)

    odeSolver &lt;- Verlet(particle)

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    particle@odeSolver &lt;- odeSolver
    initialEnergy      &lt;- getEnergy(particle)
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(particle) &lt;= 1.20) {
        rowVector[[i]] &lt;- list(t  = getState(particle)[5],
                               x  = getState(particle)[1],
                               vx = getState(particle)[2],
                               y  = getState(particle)[3],
                               vy = getState(particle)[4],
                               E  = getEnergy(particle))
        particle &lt;- doStep(particle)
        energy   &lt;- getEnergy(particle)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}

solution &lt;- KeplerEnergyApp()
plot(solution)

# +++++++++++++++++++++++++++++++++++++++++++++++++++   application:  Logistic.R
# Simulates the logistic equation
importFromExamples("Logistic.R")

# Run the application
LogisticApp &lt;- function(verbose = FALSE) {
    x  &lt;- 0.1
    vx &lt;- 0
    r  &lt;- 2        # Malthusian parameter (rate of maximum population growth)
    K  &lt;- 10.0     # carrying capacity of the environment
    dt   &lt;- 0.01; tol  &lt;- 1e-3; tmax &lt;- 10

    population &lt;- Logistic()                # create a Logistic ODE object

    # Two ways of initializing the object
      # population &lt;- init(population, c(x, vx, 0), r, K)
    init(population) &lt;-  list(initState = c(x, vx, 0),
                              r = r,
                              K = K)

    odeSolver &lt;- Verlet(population)        # select the solver

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    population@odeSolver &lt;- odeSolver
    # setSolver(population) &lt;-  odeSolver

    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(population) &lt;= tmax) {
        rowVector[[i]] &lt;- list(t = getTime(population),
                               s1 = getState(population)[1],
                               s2 = getState(population)[2])
        population &lt;- doStep(population)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}
# show solution
solution &lt;- LogisticApp()
plot(solution)
# ++++++++++++++++++++++++++++++++++++++++++++++++++  example: KeplerEnergyApp.R
# Demostration of the use of the Verlet ODE solver
#

importFromExamples("KeplerEnergy.R") # source the class Kepler

KeplerEnergyApp &lt;- function(verbose = FALSE) {
    # initial values
    x  &lt;- 1
    vx &lt;- 0
    y  &lt;- 0
    vy &lt;- 2 * pi
    dt &lt;- 0.01
    tol &lt;- 1e-3
    particle &lt;- KeplerEnergy()

    # Two ways of initializing the ODE object
      # particle &lt;- init(particle, c(x, vx, y, vy, 0))
    init(particle) &lt;- c(x, vx, y, vy, 0)

    odeSolver &lt;- Verlet(particle)

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    particle@odeSolver &lt;- odeSolver
    initialEnergy      &lt;- getEnergy(particle)
    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(particle) &lt;= 1.20) {
        rowVector[[i]] &lt;- list(t  = getState(particle)[5],
                               x  = getState(particle)[1],
                               vx = getState(particle)[2],
                               y  = getState(particle)[3],
                               vy = getState(particle)[4],
                               E  = getEnergy(particle))
        particle &lt;- doStep(particle)
        energy   &lt;- getEnergy(particle)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}

solution &lt;- KeplerEnergyApp()
plot(solution)

# +++++++++++++++++++++++++++++++++++++++++++++++++++   application:  Logistic.R
# Simulates the logistic equation
importFromExamples("Logistic.R")

# Run the application
LogisticApp &lt;- function(verbose = FALSE) {
    x  &lt;- 0.1
    vx &lt;- 0
    r  &lt;- 2        # Malthusian parameter (rate of maximum population growth)
    K  &lt;- 10.0     # carrying capacity of the environment
    dt   &lt;- 0.01; tol  &lt;- 1e-3; tmax &lt;- 10

    population &lt;- Logistic()                # create a Logistic ODE object

    # Two ways of initializing the object
      # population &lt;- init(population, c(x, vx, 0), r, K)
    init(population) &lt;-  list(initState = c(x, vx, 0),
                              r = r,
                              K = K)

    odeSolver &lt;- Verlet(population)        # select the solver

    # Two ways of initializing the solver
      # odeSolver &lt;- init(odeSolver, dt)
    init(odeSolver) &lt;-  dt

    population@odeSolver &lt;- odeSolver
    # setSolver(population) &lt;-  odeSolver

    rowVector &lt;- vector("list")
    i &lt;- 1
    while (getTime(population) &lt;= tmax) {
        rowVector[[i]] &lt;- list(t = getTime(population),
                               s1 = getState(population)[1],
                               s2 = getState(population)[2])
        population &lt;- doStep(population)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowVector)
    return(DT)
}
# show solution
solution &lt;- LogisticApp()
plot(solution)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
