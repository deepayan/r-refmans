<!DOCTYPE html><html><head><title>Help for package selenider</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {selenider}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#selenider-package'><p>selenider: Concise, Lazy and Reliable Wrapper for 'chromote' and 'selenium'</p></a></li>
<li><a href='#as_pretty_dt'><p>Format a difftime</p></a></li>
<li><a href='#as.list.selenider_elements'><p>Iterate over an element collection</p></a></li>
<li><a href='#back'><p>Move back or forward in browsing history</p></a></li>
<li><a href='#chromote_options'><p>Driver options</p></a></li>
<li><a href='#close_session'><p>Close a session object</p></a></li>
<li><a href='#create_chromote_session'><p>Deprecated functions</p></a></li>
<li><a href='#current_url'><p>Get the URL of the current page</p></a></li>
<li><a href='#elem_ancestors'><p>Get the DOM family of an element</p></a></li>
<li><a href='#elem_attr'><p>Get attributes of an element</p></a></li>
<li><a href='#elem_cache'><p>Force an element to be collected and stored</p></a></li>
<li><a href='#elem_click'><p>Click an element</p></a></li>
<li><a href='#elem_css_property'><p>Get a CSS property of an element</p></a></li>
<li><a href='#elem_equal'><p>Are two elements equivalent?</p></a></li>
<li><a href='#elem_expect'><p>Test one or more conditions on HTML elements</p></a></li>
<li><a href='#elem_expect_all'><p>Test conditions on multiple elements</p></a></li>
<li><a href='#elem_filter'><p>Extract a subset of HTML elements</p></a></li>
<li><a href='#elem_flatten'><p>Combine multiple HTML elements</p></a></li>
<li><a href='#elem_hover'><p>Hover over an element</p></a></li>
<li><a href='#elem_name'><p>Get the tag name of an element</p></a></li>
<li><a href='#elem_scroll_to'><p>Scroll to an element</p></a></li>
<li><a href='#elem_select'><p>Select an HTML element</p></a></li>
<li><a href='#elem_set_value'><p>Set the value of an input</p></a></li>
<li><a href='#elem_size'><p>Get the number of elements in a collection</p></a></li>
<li><a href='#elem_submit'><p>Submit an element</p></a></li>
<li><a href='#elem_text'><p>Get the text inside an element</p></a></li>
<li><a href='#execute_js_fn'><p>Execute a JavaScript function</p></a></li>
<li><a href='#find_element'><p>Find a single HTML child element</p></a></li>
<li><a href='#find_elements'><p>Find multiple HTML child elements</p></a></li>
<li><a href='#get_actual_element'><p>Get the element associated with a selenider element</p></a></li>
<li><a href='#get_page_source'><p>Read the HTML of a session</p></a></li>
<li><a href='#get_session'><p>Get or set the local selenider session</p></a></li>
<li><a href='#has_attr'><p>Does an element's attribute match a value?</p></a></li>
<li><a href='#has_css_property'><p>Does an element's css property match a value?</p></a></li>
<li><a href='#has_length'><p>Does a collection have a certain number of elements?</p></a></li>
<li><a href='#has_name'><p>Does an element have a tag name?</p></a></li>
<li><a href='#has_text'><p>Does an element contain a pattern?</p></a></li>
<li><a href='#is_enabled'><p>Is an element enabled?</p></a></li>
<li><a href='#is_present'><p>Does an element exist?</p></a></li>
<li><a href='#is_visible'><p>Is an element visible?</p></a></li>
<li><a href='#keys'><p>Special keys</p></a></li>
<li><a href='#minimal_selenider_session'><p>Create a session with custom HTML</p></a></li>
<li><a href='#open_url'><p>Open a URL</p></a></li>
<li><a href='#print.selenider_element'><p>Print a live HTML element</p></a></li>
<li><a href='#read_html.selenider_session'><p>Read a live HTML document</p></a></li>
<li><a href='#reload'><p>Reload the current page</p></a></li>
<li><a href='#s'><p>Select HTML elements</p></a></li>
<li><a href='#selenider_available'><p>Check if selenider can be used</p></a></li>
<li><a href='#selenider_session'><p>Start a session</p></a></li>
<li><a href='#selenider-config'><p>Selenider options</p></a></li>
<li><a href='#take_screenshot'><p>Take a screenshot of the current page</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Concise, Lazy and Reliable Wrapper for 'chromote' and 'selenium'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A user-friendly wrapper for web automation, using either 'chromote'
    or 'selenium'. Provides a simple and consistent API to make web scraping
    and testing scripts easy to write and understand. Elements are lazy, and
    automatically wait for the website to be valid, resulting in reliable and
    reproducible code, with no visible impact on the experience of the
    programmer.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, coro, curl, lifecycle, prettyunits, processx, rlang (&ge;
1.1.0), utils, vctrs, withr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ashbythorpe/selenider">https://github.com/ashbythorpe/selenider</a>,
<a href="https://ashbythorpe.github.io/selenider/">https://ashbythorpe.github.io/selenider/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ashbythorpe/selenider/issues">https://github.com/ashbythorpe/selenider/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>chromote, jsonlite, knitr, purrr, rmarkdown, RSelenium,
rvest, selenium (&ge; 0.1.3), shiny, shinytest2, showimage,
testthat (&ge; 3.0.0), wdman, xml2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 15:02:16 UTC; ashbythorpe</td>
</tr>
<tr>
<td>Author:</td>
<td>Ashby Thorpe <a href="https://orcid.org/0000-0003-3106-099X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ashby Thorpe &lt;ashbythorpe@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='selenider-package'>selenider: Concise, Lazy and Reliable Wrapper for 'chromote' and 'selenium'</h2><span id='topic+selenider'></span><span id='topic+selenider-package'></span>

<h3>Description</h3>

<p>A user-friendly wrapper for web automation, using either 'chromote' or 'selenium'. Provides a simple and consistent API to make web scraping and testing scripts easy to write and understand. Elements are lazy, and automatically wait for the website to be valid, resulting in reliable and reproducible code, with no visible impact on the experience of the programmer.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ashby Thorpe <a href="mailto:ashbythorpe@gmail.com">ashbythorpe@gmail.com</a> (<a href="https://orcid.org/0000-0003-3106-099X">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ashbythorpe/selenider">https://github.com/ashbythorpe/selenider</a>
</p>
</li>
<li> <p><a href="https://ashbythorpe.github.io/selenider/">https://ashbythorpe.github.io/selenider/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ashbythorpe/selenider/issues">https://github.com/ashbythorpe/selenider/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_pretty_dt'>Format a difftime</h2><span id='topic+as_pretty_dt'></span><span id='topic+cli_format.pretty_dt'></span>

<h3>Description</h3>

<p>Internal method used to print a <code><a href="#topic+selenider_session">selenider_session()</a></code> object. Designed to
be used with <code><a href="prettyunits.html#topic+pretty_dt">prettyunits::pretty_dt()</a></code>, <code><a href="prettyunits.html#topic+pretty_ms">prettyunits::pretty_ms()</a></code> and
<code><a href="prettyunits.html#topic+pretty_sec">prettyunits::pretty_sec()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_pretty_dt(x)

## S3 method for class 'pretty_dt'
cli_format(x, style = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_pretty_dt_+3A_x">x</code></td>
<td>
<p>A string representing a difftime.</p>
</td></tr>
<tr><td><code id="as_pretty_dt_+3A_style">style</code>, <code id="as_pretty_dt_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>pretty_dt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_pretty_dt(prettyunits::pretty_sec(10))

cli::cli_text("{.val x}")

</code></pre>

<hr>
<h2 id='as.list.selenider_elements'>Iterate over an element collection</h2><span id='topic+as.list.selenider_elements'></span><span id='topic+element_list'></span><span id='topic+elem_flatmap'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>as.list()</code> transforms a <code>selenider_elements</code> object into a list of
<code>selenider_element</code> objects. The result can then be used in for loops and
higher order functions like <code><a href="base.html#topic+lapply">lapply()</a></code>/<code><a href="purrr.html#topic+map">purrr::map()</a></code> (whereas a
<code>selenider_element</code> object cannot). This function is stable.
</p>
<p><code>element_list()</code> is the underlying function called by <code>element_list()</code>.
</p>
<p>Use <code>elem_flatmap()</code> when you want to select further sub-elements
<em>for each</em> element of a collection.
</p>
<p><code>elem_flatmap()</code> allows you to apply a function to each element of
a <code>selenider_elements</code> object, provided that the function returns a
<code>selenider_element</code>/<code>selenider_elements</code> object itself. The result will
then be flattened into a single <code>selenider_elements</code> object. The benefit
of this over traditional iteration techniques is that the laziness of the
elements will be maintained, and nothing will be fetched from the DOM.
This function is experimental, and won't work if <code>.f</code> uses <code><a href="#topic+elem_flatten">elem_flatten()</a></code>
(or nested <code>elem_flatmap()</code>).
</p>
<p><code>elem_flatmap()</code> works by executing <code>.f</code> on a mock element, then recording
the results in <code>x</code>. This means that no matter the length of <code>x</code>, <code>.f</code> is
only evaluated once, and during the <code>elem_flatmap()</code> call. For this reason,
<code>.f</code> should not invoke any side effects or do anything other than selecting
sub-elements.
</p>
<p><code>elem_flatmap()</code> can essentially be viewed as a map operation (e.g.
<code><a href="base.html#topic+lapply">lapply()</a></code>, <code><a href="purrr.html#topic+map">purrr::map()</a></code>) followed by a flattening operation
(<code><a href="#topic+elem_flatmap">elem_flatmap()</a></code>). This means that:
</p>
<div class="sourceCode"><pre>x |&gt;
  elem_flatmap(.f)
</pre></div>
<p>is essentially equivalent to:
</p>
<div class="sourceCode"><pre>x |&gt;
  as.list() |&gt;
  lapply(.f) |&gt;
  elem_flatten()
</pre></div>
<p>However, the second approach is not done lazily.
</p>
<p><code>as.list()</code>/<code>element_list()</code> essentially turns <code>x</code> into:
<code>list(x[[1]], x[[2]], ...)</code>
However, to do this, the length of <code>x</code> must be computed. This means that
while each element inside the list is still lazy, the list itself cannot be
considered lazy, since the number of elements in the DOM may change. To
avoid problems, it is recommended to use an element list just after it is
created, to make sure the list is an accurate representation of the DOM
when it is being used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selenider_elements'
as.list(x, timeout = NULL, ...)

element_list(x, timeout = NULL)

elem_flatmap(x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.selenider_elements_+3A_x">x</code></td>
<td>
<p>A <code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="as.list.selenider_elements_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for <code>x</code> to exist while computing its length.</p>
</td></tr>
<tr><td><code id="as.list.selenider_elements_+3A_...">...</code></td>
<td>
<p>Passed into <code>.f</code>.</p>
</td></tr>
<tr><td><code id="as.list.selenider_elements_+3A_.f">.f</code></td>
<td>
<p>A function to apply to each element of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>elem_flatmap()</code> returns a <code>selenider_element</code> object.
<code>as.list()</code>/<code>element_list()</code> returns a list of <code>selenider_element</code> objects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+elem_flatten">elem_flatten()</a></code> to combine multiple
<code>selenider_element</code>/<code>selenider_elements</code> objects into a single object.
</p>
</li>
<li> <p><code><a href="#topic+elem_filter">elem_filter()</a></code> and <code><a href="#topic+elem_find">elem_find()</a></code> to filter element collections using a
condition.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div id='div1'&gt;
  &lt;p&gt;Text 1&lt;/p&gt;
&lt;/div&gt;
&lt;div id='div2'&gt;
  &lt;p&gt;Text 2&lt;/p&gt;
&lt;/div&gt;
&lt;div id='div3'&gt;
  &lt;p&gt;Text 3&lt;/p&gt;
&lt;/div&gt;
&lt;div id='div4'&gt;
  &lt;p&gt;Text 4&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

divs &lt;- ss("div")

# Get the &lt;p&gt; tag inside each div.
divs |&gt;
  elem_flatmap(\(x) x |&gt; find_element("p"))

# Or:
p_tags &lt;- divs |&gt;
  elem_flatmap(find_element, "p")

# To get the text in each tag, we can't use elem_flatmap()
for (elem in as.list(p_tags)) {
  print(elem_text(elem))
}

# Or:
lapply(as.list(p_tags), elem_text)

</code></pre>

<hr>
<h2 id='back'>Move back or forward in browsing history</h2><span id='topic+back'></span><span id='topic+forward'></span>

<h3>Description</h3>

<p><code>back()</code> navigates to the previously opened URL, or the previously opened
page in your browsing history.
</p>
<p><code>forward()</code> reverses the action of <code>back()</code>, going to the next page in your
browsing history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>back(session = NULL)

forward(session = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="back_+3A_session">session</code></td>
<td>
<p>A <code>selenider_session</code> object. If not specified, the global
session object (the result of <code><a href="#topic+get_session">get_session()</a></code>) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The session object, invisibly.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session()

open_url("https://r-project.org")

open_url("https://www.tidyverse.org/")

back()

forward()

</code></pre>

<hr>
<h2 id='chromote_options'>Driver options</h2><span id='topic+chromote_options'></span><span id='topic+selenium_options'></span><span id='topic+selenium_server_options'></span><span id='topic+wdman_server_options'></span><span id='topic+selenium_client_options'></span><span id='topic+rselenium_client_options'></span>

<h3>Description</h3>

<p><code>chromote_options()</code> and <code>selenium_options()</code> return a list of options that
can be passed to the <code>options</code> argument of <code>selenider_session()</code>.
</p>
<p><code>chromote_options()</code> allows you to control the creation of a chromote driver
created using <a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession$new()</a>.
</p>
<p><code>selenium_options()</code> allows you to control the creation of a selenium driver.
</p>
<p><code>selenium_server_options()</code> and <code>wdman_server_options()</code> should be passed to
the <code>server_options</code> argument of <code>selenium_options()</code>. By default, the former
is used, meaning that the server is created using
<code><a href="selenium.html#topic+selenium_server">selenium::selenium_server()</a></code>. If <code>wdman_server_options()</code> is used instead,
the server will be created using <code><a href="wdman.html#topic+selenium">wdman::selenium()</a></code>.
</p>
<p><code>selenium_client_options()</code> should be passed to the <code>client_options</code> argument
of <code>selenium_options()</code>, allowing you to control the creation of a Selenium
client created using
<a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession$new()</a>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Instead of using <code>selenium_client_options()</code>, you can use
<code>rselenium_client_options()</code> to control the creation of an
<code><a href="RSelenium.html#topic+remoteDriver-class">RSelenium::remoteDriver()</a></code> object instead. This is not recommended, since
RSelenium is incompatible with newer versions of Selenium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chromote_options(
  headless = TRUE,
  parent = NULL,
  width = 992,
  height = 1323,
  targetId = NULL,
  wait_ = TRUE,
  auto_events = NULL
)

selenium_options(
  client_options = selenium_client_options(),
  server_options = selenium_server_options()
)

selenium_server_options(
  version = "latest",
  port = 4444L,
  selenium_manager = NULL,
  verbose = FALSE,
  temp = TRUE,
  path = NULL,
  interactive = FALSE,
  echo_cmd = FALSE,
  extra_args = c()
)

wdman_server_options(
  version = "latest",
  driver_version = "latest",
  port = 4444L,
  check = TRUE,
  verbose = FALSE,
  retcommand = FALSE,
  ...
)

selenium_client_options(
  port = 4444L,
  host = "localhost",
  verbose = FALSE,
  capabilities = NULL,
  request_body = NULL,
  timeout = 20
)

rselenium_client_options(
  port = 4444L,
  host = "localhost",
  path = "/wd/hub",
  version = "",
  platform = "ANY",
  javascript = TRUE,
  native_events = TRUE,
  extra_capabilities = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chromote_options_+3A_headless">headless</code></td>
<td>
<p>Whether to run the browser in headless mode, meaning
that you won't actually be able to see the browser as you control it.
For debugging purposes and interactive use, it is often useful to set
this to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_parent">parent</code></td>
<td>
<p>The parent chromote session.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_width">width</code>, <code id="chromote_options_+3A_height">height</code>, <code id="chromote_options_+3A_targetid">targetId</code>, <code id="chromote_options_+3A_wait_">wait_</code>, <code id="chromote_options_+3A_auto_events">auto_events</code></td>
<td>
<p>Passed into
<a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession$new()</a>.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_client_options">client_options</code></td>
<td>
<p>A <code><a href="#topic+selenium_client_options">selenium_client_options()</a></code> object.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_server_options">server_options</code></td>
<td>
<p>A <code><a href="#topic+selenium_server_options">selenium_server_options()</a></code> or
<code><a href="#topic+wdman_server_options">wdman_server_options()</a></code> object.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_version">version</code></td>
<td>
<p>The version of Selenium server to use.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_port">port</code></td>
<td>
<p>The port number to use.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_selenium_manager">selenium_manager</code>, <code id="chromote_options_+3A_verbose">verbose</code>, <code id="chromote_options_+3A_temp">temp</code>, <code id="chromote_options_+3A_path">path</code>, <code id="chromote_options_+3A_interactive">interactive</code>, <code id="chromote_options_+3A_echo_cmd">echo_cmd</code>, <code id="chromote_options_+3A_extra_args">extra_args</code></td>
<td>
<p>Passed into <code><a href="selenium.html#topic+selenium_server">selenium::selenium_server()</a></code>.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_driver_version">driver_version</code></td>
<td>
<p>The version of the browser-specific driver to use.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_check">check</code>, <code id="chromote_options_+3A_retcommand">retcommand</code>, <code id="chromote_options_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="wdman.html#topic+selenium">wdman::selenium()</a></code>.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_host">host</code>, <code id="chromote_options_+3A_capabilities">capabilities</code>, <code id="chromote_options_+3A_request_body">request_body</code>, <code id="chromote_options_+3A_timeout">timeout</code></td>
<td>
<p>Passed into <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession$new()</a>.</p>
</td></tr>
<tr><td><code id="chromote_options_+3A_platform">platform</code>, <code id="chromote_options_+3A_javascript">javascript</code>, <code id="chromote_options_+3A_native_events">native_events</code>, <code id="chromote_options_+3A_extra_capabilities">extra_capabilities</code></td>
<td>
<p>Passed into <code><a href="RSelenium.html#topic+remoteDriver-class">RSelenium::remoteDriver()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='close_session'>Close a session object</h2><span id='topic+close_session'></span>

<h3>Description</h3>

<p>Shut down a session object, closing the browser and stopping the server.
This will be done automatically if the session is set as the local session
(which happens by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_session(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_session_+3A_x">x</code></td>
<td>
<p>A <code>selenider_session</code> object. If omitted, the local session object
will be closed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selenider_session">selenider_session()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session(local = FALSE)

close_session(session)

</code></pre>

<hr>
<h2 id='create_chromote_session'>Deprecated functions</h2><span id='topic+create_chromote_session'></span><span id='topic+create_selenium_server'></span><span id='topic+create_selenium_client'></span><span id='topic+create_rselenium_client'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated and will be removed in a future release.
Use the <code>options</code> argument to <code><a href="#topic+selenider_session">selenider_session()</a></code> instead. If you want
to manually create a chromote or selenium session, use
<a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a>, <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> and
<code><a href="selenium.html#topic+selenium_server">selenium::selenium_server()</a></code> manually, since these functions
are only a thin wrapper around them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_chromote_session(parent = NULL, ...)

create_selenium_server(
  browser,
  version = "latest",
  driver_version = "latest",
  port = 4444L,
  quiet = TRUE,
  selenium_manager = TRUE,
  ...
)

create_selenium_client(browser, port = 4444L, host = "localhost", ...)

create_rselenium_client(browser, port = 4444L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_chromote_session_+3A_parent">parent</code>, <code id="create_chromote_session_+3A_...">...</code>, <code id="create_chromote_session_+3A_version">version</code>, <code id="create_chromote_session_+3A_driver_version">driver_version</code>, <code id="create_chromote_session_+3A_port">port</code>, <code id="create_chromote_session_+3A_quiet">quiet</code>, <code id="create_chromote_session_+3A_host">host</code></td>
<td>
<p>See the
documentation for <code><a href="#topic+chromote_options">chromote_options()</a></code>, <code><a href="#topic+selenium_options">selenium_options()</a></code>,
<code><a href="#topic+selenium_client_options">selenium_client_options()</a></code>, <code><a href="#topic+wdman_server_options">wdman_server_options()</a></code>,
<code><a href="#topic+selenium_client_options">selenium_client_options()</a></code> and <code><a href="#topic+rselenium_client_options">rselenium_client_options()</a></code> for details
about what these arguments mean.</p>
</td></tr>
<tr><td><code id="create_chromote_session_+3A_browser">browser</code></td>
<td>
<p>The browser to use.</p>
</td></tr>
<tr><td><code id="create_chromote_session_+3A_selenium_manager">selenium_manager</code></td>
<td>
<p>If this is <code>FALSE</code>, <code><a href="wdman.html#topic+selenium">wdman::selenium()</a></code> will be used
instead of <code><a href="selenium.html#topic+selenium_server">selenium::selenium_server()</a></code>. The equivalent of using
<code><a href="#topic+wdman_server_options">wdman_server_options()</a></code> over <code><a href="#topic+selenium_server_options">selenium_server_options()</a></code> in
<code><a href="#topic+selenium_options">selenium_options()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>create_chromote_session()</code> returns a <a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a> object.
</p>
<p><code>create_selenium_server()</code> returns a <a href="processx.html#topic+process">processx::process</a> or wdman
equivalent.
</p>
<p><code>create_selenium_client()</code> returns a <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> object.
</p>
<p><code>create_rselenium_client()</code> returns an <a href="RSelenium.html#topic+remoteDriver-class">RSelenium::remoteDriver</a> object.
</p>

<hr>
<h2 id='current_url'>Get the URL of the current page</h2><span id='topic+current_url'></span>

<h3>Description</h3>

<p>Get the full URL of the current page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_url(session = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="current_url_+3A_session">session</code></td>
<td>
<p>Optionally, a <code>selenider_session</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string: the current URL.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session()

open_url("https://r-project.org")

current_url()

</code></pre>

<hr>
<h2 id='elem_ancestors'>Get the DOM family of an element</h2><span id='topic+elem_ancestors'></span><span id='topic+elem_parent'></span><span id='topic+elem_siblings'></span><span id='topic+elem_children'></span><span id='topic+elem_descendants'></span>

<h3>Description</h3>

<p>Find all elements with a certain relative position to an HTML element.
</p>
<p><code>elem_ancestors()</code> selects every element which contains the current element
(children, grand-children, etc.).
</p>
<p><code>elem_parent()</code> selects the element that contains the current element.
</p>
<p><code>elem_siblings()</code> selects every element which has the same parent as the
current element.
</p>
<p><code>elem_children()</code> selects every element which is connected to and directly
below the current element.
</p>
<p><code>elem_descendants()</code> selects every element that is contained by the current
element. The current element does not have to be a direct parent, but must
be some type of ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_ancestors(x)

elem_parent(x)

elem_siblings(x)

elem_children(x)

elem_descendants(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_ancestors_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions except <code>elem_children()</code> and <code>elem_descendants()</code> use XPath
selectors, so may be slow, especially when using <code>chromote</code> as a backend.
</p>


<h3>Value</h3>

<p>All functions return a <code>selenider_elements</code> object, except
<code>elem_parent()</code>, which returns a <code>selenider_element</code> object (since an
element can only have one parent).
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="http://web.simmons.edu/~grovesd/comm244/notes/week4/document-tree">http://web.simmons.edu/~grovesd/comm244/notes/week4/document-tree</a> for a
simple and visual explanation of the document tree.
</p>
</li>
<li> <p><code><a href="#topic+find_element">find_element()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code> for other ways of selecting
elements. These functions allow you to select ancestors using one or more
conditions (e.g. CSS selectors).
</p>
</li>
<li> <p><code><a href="#topic+elem_filter">elem_filter()</a></code> and <code><a href="#topic+elem_find">elem_find()</a></code> for filtering element collections.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;html&gt;
&lt;body&gt;
  &lt;div&gt;
    &lt;div id='current'&gt;
      &lt;p&gt;&lt;/p&gt;
      &lt;div&gt;
        &lt;p&gt;&lt;/p&gt;
        &lt;br&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;p&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
"

session &lt;- minimal_selenider_session(html)

current &lt;- s("#current")

# Get all the names of an element collection
elem_names &lt;- function(x) {
  x |&gt;
    as.list() |&gt;
    vapply(elem_name, FUN.VALUE = character(1))
}

current |&gt;
  elem_ancestors() |&gt;
  elem_expect(has_length(3)) |&gt;
  elem_names() # html, div, body

current |&gt;
  elem_parent() |&gt;
  elem_name() # div

current |&gt;
  elem_siblings() |&gt;
  elem_expect(has_length(2)) |&gt;
  elem_names() # div, p

current |&gt;
  elem_children() |&gt;
  elem_expect(has_length(2)) |&gt;
  elem_names() # p, div

current |&gt;
  elem_descendants() |&gt;
  elem_expect(has_length(4)) |&gt;
  elem_names() # p, div, p, br

</code></pre>

<hr>
<h2 id='elem_attr'>Get attributes of an element</h2><span id='topic+elem_attr'></span><span id='topic+elem_attrs'></span><span id='topic+elem_value'></span>

<h3>Description</h3>

<p>Get an attribute of a <code>selenider_element</code> object.
</p>
<p><code>elem_attr()</code> returns a <em>single</em> attribute value as a string.
</p>
<p><code>elem_attrs()</code> returns a named list containing <em>every</em> attribute.
</p>
<p><code>elem_value()</code> returns the 'value' attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_attr(x, name, default = NULL, timeout = NULL)

elem_attrs(x, timeout = NULL)

elem_value(x, ptype = character(), timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_attr_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute to get; a string.</p>
</td></tr>
<tr><td><code id="elem_attr_+3A_default">default</code></td>
<td>
<p>The default value to use if the attribute does not exist in
the element.</p>
</td></tr>
<tr><td><code id="elem_attr_+3A_timeout">timeout</code></td>
<td>
<p>The time to wait for <code>x</code> to exist.</p>
</td></tr>
<tr><td><code id="elem_attr_+3A_ptype">ptype</code></td>
<td>
<p>The type to cast the value to. Useful when the value is an
integer or decimal number. By default, the value is returned as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>elem_attr()</code> returns a character vector of length 1. <code>elem_attrs()</code>
returns a named list of strings. The return value of <code>elem_value()</code> has the
same type as <code>ptype</code> and length 1.
</p>


<h3>See Also</h3>

<p>Other properties: 
<code><a href="#topic+elem_css_property">elem_css_property</a>()</code>,
<code><a href="#topic+elem_name">elem_name</a>()</code>,
<code><a href="#topic+elem_size">elem_size</a>()</code>,
<code><a href="#topic+elem_text">elem_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;a class='link' href='https://r-project.org'&gt;R&lt;/a&gt;
&lt;input type='number' value='0'&gt;
"

session &lt;- minimal_selenider_session(html)

s("a") |&gt;
  elem_attr("href")

s("a") |&gt;
  elem_attrs()

s("input[type='number']") |&gt;
  elem_value(ptype = integer())

</code></pre>

<hr>
<h2 id='elem_cache'>Force an element to be collected and stored</h2><span id='topic+elem_cache'></span>

<h3>Description</h3>

<p><code>selenider_element</code>/<code>selenider_elements</code> objects are generally
<em>lazy</em>, meaning they only collect the actual element in the DOM
when absolutely necessary, and forget it immediately after. This
is to avoid situations where the DOM changes after an element
has been collected, resulting in errors and unreliable behaviour.
</p>
<p><code>elem_cache()</code> forces an element or collection of elements to be collected
and stored, making it eager rather than lazy. This is useful when you are
operating on the same element multiple times, since only collecting the
element once will improve performance. However, you must be sure that the
element will not change on the page while you are using it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_cache(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_cache_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code>/<code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="elem_cache_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element(s) to exist while collecting
them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not make selenider elements <em>permanently</em> eager. Further
sub-elements will not be cached unless specified.
</p>
<p>For example, consider the following code:
</p>
<div class="sourceCode r"><pre>s(".class1") |&gt;
  elem_parent() |&gt;
  elem_cache() |&gt;
  find_element(".class2")
</pre></div>
<p>In this example, the parent of the element with class &quot;.class1&quot; will be
cached, but the child element with class &quot;.class2&quot; will not.
</p>


<h3>Value</h3>

<p>A modified version of <code>x</code>. The result of <code>elem_cache()</code> can be used
as a normal <code>selenider_element</code>/<code>selenider_elements</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_element">find_element()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code> to select elements.
</p>
</li>
<li> <p><code><a href="#topic+element_list">element_list()</a></code> and <code><a href="#topic+elem_flatmap">elem_flatmap()</a></code> if you want to iterate over an
element collection.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;
&lt;p id='specifictext'&gt;&lt;/p&gt;
&lt;button&gt;&lt;/button&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

# Selecting this button may be slow, since we are using relative XPath
# selectors.
button &lt;- s("#specifictext") |&gt;
  elem_siblings() |&gt;
  elem_find(has_name("button"))

# But we need to click the button 10 times!
# Normally, this would involve fetching the button from the DOM 10 times
click_button_10_times &lt;- function(x) {
  lapply(1:10, \(unnused) elem_click(x))
  invisible(NULL)
}

# But with elem_cache(), the button will only be fetched once
cached_button &lt;- elem_cache(button)

click_button_10_times(cached_button)

# But the cached button is less reliable if the DOM is changing
execute_js_fn("x =&gt; { x.outerHTML = '&lt;button&gt;&lt;/button&gt;'; }", button)

try(elem_click(cached_button, timeout = 0.1))

# But the non-cached version works
elem_click(button)

</code></pre>

<hr>
<h2 id='elem_click'>Click an element</h2><span id='topic+elem_click'></span><span id='topic+elem_double_click'></span><span id='topic+elem_right_click'></span>

<h3>Description</h3>

<p>Clicks on an HTML element, either by simulating a mouse click or by
triggering the element's &quot;click&quot; event.
</p>
<p><code>elem_click()</code> left clicks on the element, <code>elem_double_click()</code> left clicks
on the element two times in a short period of time, while
<code>elem_right_click()</code> right clicks on an element, opening its context menu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_click(x, js = FALSE, timeout = NULL)

elem_double_click(x, js = FALSE, timeout = NULL)

elem_right_click(x, js = FALSE, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_click_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_click_+3A_js">js</code></td>
<td>
<p>Whether to click the element using JavaScript.</p>
</td></tr>
<tr><td><code id="elem_click_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_hover">elem_hover</a>()</code>,
<code><a href="#topic+elem_scroll_to">elem_scroll_to</a>()</code>,
<code><a href="#topic+elem_select">elem_select</a>()</code>,
<code><a href="#topic+elem_set_value">elem_set_value</a>()</code>,
<code><a href="#topic+elem_submit">elem_submit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;button onclick = hidetext() oncontextmenu = showtext()&gt;&lt;/button&gt;
&lt;p id = 'texttohide'&gt;Hello!&lt;/p&gt;
"

js &lt;- "
function hidetext() {
  document.getElementById('texttohide').style.display = 'none'
}

function showtext() {
  document.getElementById('texttohide').style.display = 'block'
}
"

session &lt;- minimal_selenider_session(html, js = js)

elem_expect(s("p"), is_visible)

s("button") |&gt;
  elem_click()

elem_expect(s("p"), is_invisible)

s("button") |&gt;
  elem_right_click()

elem_expect(s("p"), is_visible)

</code></pre>

<hr>
<h2 id='elem_css_property'>Get a CSS property of an element</h2><span id='topic+elem_css_property'></span>

<h3>Description</h3>

<p>Get a CSS property of an element (e.g. <code>"background-color"</code>).
Specifically, the <em>computed</em> style is returned, meaning that,
for example, widths and heights will be returned in pixels, and
colours will be returned as an RGB value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_css_property(x, name, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_css_property_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_css_property_+3A_name">name</code></td>
<td>
<p>The name of the CSS property to get.</p>
</td></tr>
<tr><td><code id="elem_css_property_+3A_timeout">timeout</code></td>
<td>
<p>The time to wait for <code>x</code> to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, or <code>NULL</code> if the property does not exist.
</p>


<h3>See Also</h3>

<p>Other properties: 
<code><a href="#topic+elem_attr">elem_attr</a>()</code>,
<code><a href="#topic+elem_name">elem_name</a>()</code>,
<code><a href="#topic+elem_size">elem_size</a>()</code>,
<code><a href="#topic+elem_text">elem_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;p style='visibility:hidden; color:red;'&gt;Text&lt;/p&gt;
"

session &lt;- minimal_selenider_session(html)

s("p") |&gt;
  elem_css_property("visibility")

s("p") |&gt;
  elem_css_property("color")

</code></pre>

<hr>
<h2 id='elem_equal'>Are two elements equivalent?</h2><span id='topic+elem_equal'></span><span id='topic++3D+3D.selenider_element'></span>

<h3>Description</h3>

<p>Checks if two <code>selenider_element</code> objects point to the
same element on the page. <code>elem_equal()</code> is equivalent to
using <code>==</code>, but allows you to specify a timeout value if
needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_equal(x, y, timeout = NULL)

## S3 method for class 'selenider_element'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_equal_+3A_x">x</code>, <code id="elem_equal_+3A_y">y</code>, <code id="elem_equal_+3A_e1">e1</code>, <code id="elem_equal_+3A_e2">e2</code></td>
<td>
<p><code>selenider_element</code> objects to compare.</p>
</td></tr>
<tr><td><code id="elem_equal_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the elements to be present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+elem_filter">elem_filter()</a></code> and <code><a href="#topic+elem_find">elem_find()</a></code> for filtering collection of elements.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;&lt;/div&gt;
&lt;div class='second'&gt;
  &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

s("div") == ss("div")[[1]]

has_p_child &lt;- function(x) {
  x |&gt;
    elem_children() |&gt; # Direct children
    elem_filter(has_name("p")) |&gt;
    has_at_least(1)
}

ss("div") |&gt;
  elem_find(has_p_child) |&gt;
  elem_equal(s(".second")) # TRUE

</code></pre>

<hr>
<h2 id='elem_expect'>Test one or more conditions on HTML elements</h2><span id='topic+elem_expect'></span><span id='topic+elem_wait_until'></span>

<h3>Description</h3>

<p><code>elem_expect()</code> waits for a set of conditions to return TRUE. If, after a
certain period of time (by default 4 seconds), this does not happen, an
informative error is thrown. Otherwise, the original element is returned.
</p>
<p><code>elem_wait_until()</code> does the same, but returns a logical value (whether or
not the test passed), allowing you to handle the failure case explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_expect(x, ..., testthat = NULL, timeout = NULL)

elem_wait_until(x, ..., timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_expect_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code>/<code>selenider_elements</code> object, or a condition.</p>
</td></tr>
<tr><td><code id="elem_expect_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be <code>TRUE</code> for the test to pass.</p>
</td></tr>
<tr><td><code id="elem_expect_+3A_testthat">testthat</code></td>
<td>
<p>Whether to treat the expectation as a <code>testthat</code> test. You
<em>do not</em> need to explicitly provide this most of the time, since by
default, we can use <code><a href="testthat.html#topic+is_testing">testthat::is_testing()</a></code> to figure out whether
<code>elem_expect()</code> is being called from within a <code>testthat</code> test.</p>
</td></tr>
<tr><td><code id="elem_expect_+3A_timeout">timeout</code></td>
<td>
<p>The number of seconds to wait for a condition to pass. If not
specified, the timeout used for <code>x</code> will be used, or the timeout of the
local session if an element is not given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>elem_expect()</code> invisibly returns the element(s) <code>x</code>, or <code>NULL</code> if an
element or collection of elements was not given in <code>x</code>.
</p>
<p><code>elem_wait_for()</code> returns a boolean flag: TRUE if the test passes, FALSE
otherwise.
</p>


<h3>Conditions</h3>

<p>Conditions can be supplied as functions or calls.
</p>
<p>Functions allow you to use unary conditions without formatting them as a
call (e.g. <code>is_present</code> rather than <code>is_present()</code>). It also allows you to
make use of R's <a href="base.html#topic+function">anonymous function syntax</a> to quickly
create custom conditions. <code>x</code> will be supplied as the first argument of this
function.
</p>
<p>Function calls allow you to use conditions that take multiple arguments
(e.g. <code>has_text()</code>) without the use of an intermediate function. The call
will be modified so that <code>x</code> is the first argument to the function call. For
example, <code>has_text("a")</code> will be modified to become: <code>has_text(x, "a")</code>.
</p>
<p>The and (<code>&amp;&amp;</code>), or (<code>||</code>) and not (<code>!</code>) functions can be used on both types
of conditions. If more than one condition are given in <code>...</code>, they are
combined using <code>&amp;&amp;</code>.
</p>


<h3>Custom conditions</h3>

<p>Any function which takes a selenider element or element collection as its
first argument, and returns a logical value, can be used as a condition.
</p>
<p>Additionally, these functions provide a few features that make creating
custom conditions easy:
</p>

<ul>
<li><p> Errors with class <code>expect_error_continue</code> are handled, and
the function is prevented from terminating early. This means that if
an element is not found, the function will retry instead of immediately
throwing an error.
</p>
</li>
<li> <p><code>selenider</code> functions used inside conditions have their timeout, by
default, set to 0, ignoring the local timeout. This is important, since
<code>elem_expect()</code> and <code>elem_wait_until()</code> implement a retry mechanic
manually. To override this default, manually specify a timeout.
</p>
</li></ul>

<p>These two features allow you to use functions like <code><a href="#topic+elem_text">elem_text()</a></code> to access
properties of an element, without needing to worry about the errors that
they throw or the timeouts that they use. See Examples for a few examples of
a custom condition.
</p>
<p>These custom conditions can also be used with <code><a href="#topic+elem_filter">elem_filter()</a></code> and
<code><a href="#topic+elem_find">elem_find()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+is_present">is_present()</a></code> and other conditions for predicates for HTML elements.
(If you scroll down to the <em>See also</em> section, you will find the rest).
</p>
</li>
<li> <p><code><a href="#topic+elem_expect_all">elem_expect_all()</a></code> and <code><a href="#topic+elem_wait_until_all">elem_wait_until_all()</a></code> for an easy way to test a
single condition on multiple elements.
</p>
</li>
<li> <p><code><a href="#topic+elem_filter">elem_filter()</a></code> and <code><a href="#topic+elem_find">elem_find()</a></code> to use conditions to filter elements.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div class='class1'&gt;
&lt;button id='disabled-button' disabled&gt;Disabled&lt;/button&gt;
&lt;p&gt;Example text&lt;/p&gt;
&lt;button id='enabled-button'&gt;Enabled&lt;/button&gt;
&lt;/div&gt;

&lt;div class='class3'&gt;
&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

s(".class1") |&gt;
  elem_expect(is_present)

s("#enabled-button") |&gt;
  elem_expect(is_visible, is_enabled)

s("#disabled-button") |&gt;
  elem_expect(is_disabled)

# Error: element is visible but not enabled
s("#disabled-button") |&gt;
  elem_expect(is_visible, is_enabled, timeout = 0.5) |&gt;
  try() # Since this condition will fail

s(".class2") |&gt;
  elem_expect(!is_present, !is_in_dom, is_absent) # All 3 are equivalent

# All other conditions will error if the element does not exist
s(".class2") |&gt;
  elem_expect(is_invisible, timeout = 0.1) |&gt;
  try()

# elem_expect() returns the element, so can be used in chains
s("#enabled-button") |&gt;
  elem_expect(is_visible &amp;&amp; is_enabled) |&gt;
  elem_click()
# Note that elem_click() will do this automatically

s("p") |&gt;
  elem_expect(is_visible, has_exact_text("Example text"))

# Or use an anonymous function
s("p") |&gt;
  elem_expect(\(elem) identical(elem_text(elem), "Example text"))

# If your conditions are not specific to an element, you can omit the `x`
# argument
elem_1 &lt;- s(".class1")
elem_2 &lt;- s(".class2")

elem_expect(is_present(elem_1) || is_present(elem_2))

# We can now use the conditions on their own to figure out which element
# exists
if (is_present(elem_1)) {
  print("Element 1 is visible")
} else {
  print("Element 2 is visible")
}

# Use elem_wait_until() to handle failures manually
elem &lt;- s(".class2")
if (elem_wait_until(elem, is_present)) {
  elem_click(elem)
} else {
  reload()
}

# Creating a custom condition is easiest with an anonymous function
s("p") |&gt;
  elem_expect(
    \(elem) elem |&gt;
      elem_text() |&gt;
      grepl(pattern = "Example .*")
  )

# Or create a function, to reuse the condition multiple times
text_contains &lt;- function(x, pattern) {
  text &lt;- elem_text(x)

  grepl(pattern, text)
}

s("p") |&gt;
  elem_expect(text_contains("Example *"))

# If we want to continue on error, we need to use the
# "expect_error_continue" class.
# This involves making a custom error object.
error_condition &lt;- function() {
  my_condition &lt;- list(message = "Custom error!")
  class(my_condition) &lt;- c("expect_error_continue", "error", "condition")
  stop(my_condition)
}

# This is much easier with rlang::abort() / cli::cli_abort():
error_condition_2 &lt;- function() {
  rlang::abort("Custom error!", class = "expect_error_continue")
}

# This error will not be caught
try(elem_expect(stop("Uncaught error!")))

# These will eventually throw an error, but will wait 0.5 seconds to do so.
try(elem_expect(error_condition(), timeout = 0.5))
try(elem_expect(error_condition_2(), timeout = 0.5))

</code></pre>

<hr>
<h2 id='elem_expect_all'>Test conditions on multiple elements</h2><span id='topic+elem_expect_all'></span><span id='topic+elem_wait_until_all'></span>

<h3>Description</h3>

<p><code>elem_expect_all()</code> and <code>elem_wait_until_all()</code> are complements to
<code><a href="#topic+elem_expect">elem_expect()</a></code> and <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> that test conditions on
multiple elements in an element collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_expect_all(x, ..., testthat = NULL, timeout = NULL)

elem_wait_until_all(x, ..., timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_expect_all_+3A_x">x</code></td>
<td>
<p>A <code>selenider_elements()</code> object.</p>
</td></tr>
<tr><td><code id="elem_expect_all_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Function calls or functions
that must return a logical value. If multiple conditions are given, they
must all be <code>TRUE</code> for the test to pass. See <code><a href="#topic+elem_expect">elem_expect()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="elem_expect_all_+3A_testthat">testthat</code></td>
<td>
<p>Whether to treat the expectation as a <code>testthat</code> test. You
<em>do not</em> need to explicitly provide this most of the time, since by
default, we can use <code><a href="testthat.html#topic+is_testing">testthat::is_testing()</a></code> to figure out whether
<code>elem_expect()</code> is being called from within a <code>testthat</code> test.</p>
</td></tr>
<tr><td><code id="elem_expect_all_+3A_timeout">timeout</code></td>
<td>
<p>The number of seconds to wait for a condition to pass. If not
specified, the timeout used for <code>x</code> will be used, or the timeout of the
local session if an element is not given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> does not contain any elements, <code>elem_expect_all()</code> and
<code>elem_wait_until_all()</code> will succeed. You may want to first verify that
at least one element exists with <code><a href="#topic+has_at_least">has_at_least()</a></code>.
</p>
<p><code>elem_expect_all()</code> and <code>elem_wait_until_all()</code> can be thought of as
alternatives to the use of <code>all(vapply(FUN.VALUE = logical(1)))</code> (or
<code><a href="purrr.html#topic+every">purrr::every()</a></code>) within <code><a href="#topic+elem_expect">elem_expect()</a></code> and <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code>.
</p>
<p>For example, the following two expressions are equivalent (where <code>x</code> is an
element collection).
</p>
<div class="sourceCode"><pre>elem_expect(
  x,
  \(element) all(vapply(as.list(element), is_present, logical(1)))
)
elem_expect_all(x, is_present)
</pre></div>
<p>However, the second example will give a more detailed error message on
failure.
</p>


<h3>Value</h3>

<p><code>elem_expect_all()</code> returns <code>x</code>, invisibly.
</p>
<p><code>elem_wait_until_all()</code> returns a boolean flag: TRUE if the test passes,
FALSE otherwise.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+elem_expect">elem_expect()</a></code> and <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+is_present">is_present()</a></code> and other conditions for predicates for HTML elements.
(If you scroll down to the <em>See also</em> section, you will find the rest).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div id='div1'&gt;Content 1&lt;/div&gt;
&lt;div id='div2'&gt;Content 2&lt;/div&gt;
&lt;div id='div3' style='display:none;'&gt;Content 3&lt;/div&gt;
&lt;div id='div4'&gt;Content 4&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

ss("div") |&gt;
  elem_expect_all(is_visible, timeout = 0.1) |&gt;
  try()

ss("div")[-3] |&gt;
  elem_expect_all(is_visible)

</code></pre>

<hr>
<h2 id='elem_filter'>Extract a subset of HTML elements</h2><span id='topic+elem_filter'></span><span id='topic+elem_find'></span><span id='topic++5B.selenider_elements'></span><span id='topic++5B+5B.selenider_elements'></span>

<h3>Description</h3>

<p>Operators to extract a subset of elements, or a single element, from
a selenider element collection.
</p>
<p><code>elem_filter()</code> and <code>elem_find()</code> allow you to use conditions to filter HTML
elements (see <code><a href="#topic+is_present">is_present()</a></code> and other conditions). <code>elem_find()</code> returns
the <em>first</em> element that satisfies one or more conditions, while
<code>elem_filter()</code> returns every element that satisfies these conditions.
</p>
<p><code>[</code> and <code>[[</code> with a numeric subscript can be used on an element collection
to filter the elements by position. <code>[</code> returns a single element at a
specified location, while <code>[[</code> returns a collection of the elements at more
than one position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_filter(x, ...)

elem_find(x, ...)

## S3 method for class 'selenider_elements'
x[i]

## S3 method for class 'selenider_elements'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_filter_+3A_x">x</code></td>
<td>
<p>A <code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="elem_filter_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Conditions (functions or
function calls) that are used to filter the elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="elem_filter_+3A_i">i</code></td>
<td>
<p>A number (or for <code>[</code>, a vector of one or more numbers) used to
select elements by position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with the <code><a href="#topic+find_element">find_element()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code> functions, these
functions are lazy, meaning that the elements are not fetched and filtered
until they are needed.
</p>
<p>Conditions can be functions or function calls (see <code><a href="#topic+elem_expect">elem_expect()</a></code> for more
details).
</p>


<h3>Value</h3>

<p><code>elem_filter()</code> and <code>[</code> return a <code>selenider_elements</code> object, since they can
result in multiple elements.
<code>elem_find()</code> and <code>[[</code> return a single <code>selenider_element</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_elements">find_elements()</a></code> and <code><a href="#topic+ss">ss()</a></code> to get elements to filter.
</p>
</li>
<li> <p><code><a href="#topic+is_present">is_present()</a></code> and other conditions for predicates for HTML elements.
(If you scroll down to the <em>See also</em> section, you will find the rest).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;button disabled&gt;Button 1&lt;/button&gt;
&lt;button&gt;Button 2&lt;/button&gt;
&lt;p&gt;Text&lt;/p&gt;
&lt;div style='display:none;'&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

elements &lt;- ss("*")

# Gives the same result as s()
elements[[1]]

elements[1:3]

elements[-2]

elements |&gt;
  elem_filter(is_visible)

elements |&gt;
  elem_find(is_visible)

# The above is equivalent to:
visible_elems &lt;- elements |&gt;
  elem_filter(is_visible)
visible_elems[[1]]

# In R &gt;= 4.3.0, we can instead do:
# ss(".class1") |&gt;
#   elem_filter(is_visible) |&gt;
#   _[[1]]

ss("button") |&gt;
  elem_filter(is_enabled)

</code></pre>

<hr>
<h2 id='elem_flatten'>Combine multiple HTML elements</h2><span id='topic+elem_flatten'></span><span id='topic+c.selenider_element'></span><span id='topic+c.selenider_elements'></span>

<h3>Description</h3>

<p>Combine a set of <code>selenider_element</code>/<code>selenider_elements</code> objects
into a single <code>selenider_elements</code> object, allowing you to
perform actions on them at once. <code>c()</code> and <code>elem_flatten()</code> do the same
thing, but <code>elem_flatten()</code> works when given a list of
<code>selenider_element</code>/<code>selenider_elements</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_flatten(...)

## S3 method for class 'selenider_element'
c(...)

## S3 method for class 'selenider_elements'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_flatten_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; <code>selenider_element</code> or
<code>selenider_elements</code> objects to be combined, or lists of such objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>selenider_elements</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+as.list.selenider_elements">as.list.selenider_elements()</a></code> to iterate over element collections.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div id='id1'&gt;&lt;/div&gt;
&lt;div class='.class2'&gt;&lt;/div&gt;
&lt;button id='button1'&gt;Click me!&lt;/button&gt;
&lt;div class='button-container'&gt;
  &lt;button id='button2'&gt;No, click me!&lt;/button&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

button_1 &lt;- s("#button1")
button_2 &lt;- s("#button2")

buttons &lt;- elem_flatten(button_1, button_2)

buttons |&gt;
  elem_expect_all(is_enabled)

buttons |&gt;
  as.list() |&gt;
  lapply(elem_click)

# Doesn't just have to be single elements
first_2_divs &lt;- ss("div")[1:2]

elem_flatten(first_2_divs, button_2) |&gt;
  length()

# We would like to use multiple css selectors and combine the results
selectors &lt;- c(
  "#id1", # Will select 1 element
  "button", # Will select 2 elements
  "p" # Will select 0 elements
)

lapply(selectors, ss) |&gt;
  elem_flatten() |&gt;
  length() # 3

</code></pre>

<hr>
<h2 id='elem_hover'>Hover over an element</h2><span id='topic+elem_hover'></span><span id='topic+elem_focus'></span>

<h3>Description</h3>

<p><code>elem_hover()</code> moves the mouse over to an HTML element and hovers over it,
without actually clicking or interacting with it.
</p>
<p><code>elem_focus()</code> focuses an HTML element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_hover(x, js = FALSE, timeout = NULL)

elem_focus(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_hover_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_hover_+3A_js">js</code></td>
<td>
<p>Whether to hover over the element using JavaScript.</p>
</td></tr>
<tr><td><code id="elem_hover_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_click">elem_click</a>()</code>,
<code><a href="#topic+elem_scroll_to">elem_scroll_to</a>()</code>,
<code><a href="#topic+elem_select">elem_select</a>()</code>,
<code><a href="#topic+elem_set_value">elem_set_value</a>()</code>,
<code><a href="#topic+elem_submit">elem_submit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;button onmouseover = settext()&gt;&lt;/button&gt;
&lt;p class = 'text'&gt;&lt;/p&gt;
"

js &lt;- "
function settext() {
  const element = document.getElementsByClassName('text').item(0);

  element.innerHTML = 'Button hovered!';
}
"

session &lt;- minimal_selenider_session(html, js = js)

elem_expect(s(".text"), has_exact_text(""))

s("button") |&gt;
  elem_hover()

elem_expect(s(".text"), has_text("Button hovered!"))

s("button") |&gt;
  elem_focus()

</code></pre>

<hr>
<h2 id='elem_name'>Get the tag name of an element</h2><span id='topic+elem_name'></span>

<h3>Description</h3>

<p>Get the tag name (e.g. <code>"p"</code> for a <code style="white-space: pre;">&#8288;&lt;p&gt;&#8288;</code> tag) of a <code>selenider_element</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_name(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_name_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_name_+3A_timeout">timeout</code></td>
<td>
<p>The time to wait for <code>x</code> to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>See Also</h3>

<p>Other properties: 
<code><a href="#topic+elem_attr">elem_attr</a>()</code>,
<code><a href="#topic+elem_css_property">elem_css_property</a>()</code>,
<code><a href="#topic+elem_size">elem_size</a>()</code>,
<code><a href="#topic+elem_text">elem_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div class='mydiv'&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

s(".mydiv") |&gt;
  elem_name()

</code></pre>

<hr>
<h2 id='elem_scroll_to'>Scroll to an element</h2><span id='topic+elem_scroll_to'></span>

<h3>Description</h3>

<p>Scrolls to an HTML element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_scroll_to(x, js = FALSE, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_scroll_to_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_scroll_to_+3A_js">js</code></td>
<td>
<p>Whether to scroll to the element using JavaScript.</p>
</td></tr>
<tr><td><code id="elem_scroll_to_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_click">elem_click</a>()</code>,
<code><a href="#topic+elem_hover">elem_hover</a>()</code>,
<code><a href="#topic+elem_select">elem_select</a>()</code>,
<code><a href="#topic+elem_set_value">elem_set_value</a>()</code>,
<code><a href="#topic+elem_submit">elem_submit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div style = 'height:100%; min-height:100vh'&gt;&lt;/div&gt;
&lt;button onclick='checkScrolled()'&gt;&lt;/button&gt;
&lt;p&gt;Scroll down to find me!&lt;/p&gt;
"

js &lt;- "
function checkScrolled() {
  let element = document.getElementsByTagName('p').item(0);
  let rect = element.getBoundingClientRect();
  // If paragraph is in view
  const height = window.innerHeight || document.documentElement.clientHeight;
  if (rect.bottom &lt;= height) {
    element.innerText = 'You found me!';
  }
}
"

session &lt;- minimal_selenider_session(html, js = js)

s("p") |&gt;
  elem_scroll_to()

s("button") |&gt;
  elem_click()

elem_expect(s("p"), has_text("You found me!"))

</code></pre>

<hr>
<h2 id='elem_select'>Select an HTML element</h2><span id='topic+elem_select'></span>

<h3>Description</h3>

<p>Select or deselect <code>select</code> and <code>option</code> elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_select(
  x,
  value = NULL,
  text = NULL,
  index = NULL,
  timeout = NULL,
  reset_other = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_select_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object representing a <code>select</code> or <code>option</code>
element.</p>
</td></tr>
<tr><td><code id="elem_select_+3A_value">value</code></td>
<td>
<p>If <code>x</code> is a <code>select</code> element, the value of the option to
select. Can be a character vector, in which case multiple options will be
selected.</p>
</td></tr>
<tr><td><code id="elem_select_+3A_text">text</code></td>
<td>
<p>The text content of the option to select. This does not have to
be a complete match, and multiple options can be selected.</p>
</td></tr>
<tr><td><code id="elem_select_+3A_index">index</code></td>
<td>
<p>A vector of indexes. The nth option elements will be selected.</p>
</td></tr>
<tr><td><code id="elem_select_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
<tr><td><code id="elem_select_+3A_reset_other">reset_other</code></td>
<td>
<p>If <code>TRUE</code> (the default), the other options will be
deselected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no arguments apart from <code>x</code> are supplied, and <code>x</code> is a <code>select</code> element,
all options will be deselected.
</p>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_click">elem_click</a>()</code>,
<code><a href="#topic+elem_hover">elem_hover</a>()</code>,
<code><a href="#topic+elem_scroll_to">elem_scroll_to</a>()</code>,
<code><a href="#topic+elem_set_value">elem_set_value</a>()</code>,
<code><a href="#topic+elem_submit">elem_submit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;select multiple&gt;
  &lt;option value='a'&gt;Option A.&lt;/option&gt;
  &lt;option value='b'&gt;Option B.&lt;/option&gt;
  &lt;option value='c'&gt;Option C.&lt;/option&gt;
&lt;/select&gt;
"
session &lt;- minimal_selenider_session(html)

s("select") |&gt;
  elem_select("a")

s("select") |&gt;
  elem_select(text = c("Option A.", "Option C."))

s("select") |&gt;
  elem_select(index = 2, reset_other = FALSE)

# Reset selection
s("select") |&gt;
  elem_select()

s("select") |&gt;
  elem_select("b")

</code></pre>

<hr>
<h2 id='elem_set_value'>Set the value of an input</h2><span id='topic+elem_set_value'></span><span id='topic+elem_send_keys'></span><span id='topic+elem_clear_value'></span>

<h3>Description</h3>

<p><code>elem_set_value()</code> sets the value of an HTML input element to a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_set_value(x, text, timeout = NULL)

elem_send_keys(x, ..., modifiers = NULL, timeout = NULL)

elem_clear_value(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_set_value_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object. For <code><a href="#topic+elem_send_keys">elem_send_keys()</a></code>, this can be
<code>NULL</code>, meaning that the keys will be sent to the current page (or the
currently focused element) instead of a specific element.</p>
</td></tr>
<tr><td><code id="elem_set_value_+3A_text">text</code></td>
<td>
<p>A string to set the value of the input element to.</p>
</td></tr>
<tr><td><code id="elem_set_value_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
<tr><td><code id="elem_set_value_+3A_...">...</code></td>
<td>
<p>A set of inputs to send to <code>x</code>.</p>
</td></tr>
<tr><td><code id="elem_set_value_+3A_modifiers">modifiers</code></td>
<td>
<p>A character vector; one or more of &quot;shift&quot;,
&quot;ctrl&quot;/&quot;control&quot;, &quot;alt&quot;, and &quot;command&quot;/meta&quot;. Note that when using
chromote as a backend, these do not work on Mac OS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>elem_send_keys()</code> sends a set of inputs to an element.
</p>
<p><code>elem_clear_value()</code> sets the value of an HTML element to <code>""</code>, removing any
existing content.
</p>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_click">elem_click</a>()</code>,
<code><a href="#topic+elem_hover">elem_hover</a>()</code>,
<code><a href="#topic+elem_scroll_to">elem_scroll_to</a>()</code>,
<code><a href="#topic+elem_select">elem_select</a>()</code>,
<code><a href="#topic+elem_submit">elem_submit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;input
  type='text'
  oninput='recordChange(event)'
  onkeypress='return checkEnter(event);'
/&gt;
&lt;p&gt;&lt;/p&gt;
"

js &lt;- "
function recordChange(e) {
  document.getElementsByTagName('p').item(0).innerText = e.target.value;
}

function checkEnter(e) {
  // If the key pressed was Enter
  if (e.keyCode == 13) {
    document.getElementsByTagName('p').item(0).innerText = 'Enter pressed!';
    return false;
  }
  return true;
}
"

session &lt;- minimal_selenider_session(html, js = js)

elem_expect(s("p"), has_exact_text(""))

input &lt;- s("input")

elem_set_value(input, "my text")

elem_expect(s("p"), has_text("my text"))

elem_clear_value(input)

elem_expect(s("p"), has_exact_text(""))

elem_send_keys(input, keys$enter)

elem_expect(s("p"), has_text("Enter pressed!"))

</code></pre>

<hr>
<h2 id='elem_size'>Get the number of elements in a collection</h2><span id='topic+elem_size'></span><span id='topic+length.selenider_elements'></span>

<h3>Description</h3>

<p>Get the number of elements in a HTML element collection, waiting for the
parent elements (if any) to exist before returning a value.
</p>
<p><code>length()</code> and <code>elem_size()</code> can be used interchangeably, the only
difference being that <code>elem_size()</code> allows you to specify a timeout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_size(x, timeout = NULL)

## S3 method for class 'selenider_elements'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_size_+3A_x">x</code></td>
<td>
<p>A <code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="elem_size_+3A_timeout">timeout</code></td>
<td>
<p>The time to wait for the parent of <code>x</code> (if any) to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer representing the number of elements in the collection.
</p>


<h3>See Also</h3>

<p>Other properties: 
<code><a href="#topic+elem_attr">elem_attr</a>()</code>,
<code><a href="#topic+elem_css_property">elem_css_property</a>()</code>,
<code><a href="#topic+elem_name">elem_name</a>()</code>,
<code><a href="#topic+elem_text">elem_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

ss("div") |&gt;
  length()

</code></pre>

<hr>
<h2 id='elem_submit'>Submit an element</h2><span id='topic+elem_submit'></span>

<h3>Description</h3>

<p>If an element is an ancestor of a form, submits the form.
Works by walking up the DOM, checking each ancestor element until
the element is a <code style="white-space: pre;">&#8288;&lt;form&gt;&#8288;</code> element, which it then submits. If such
an element does not exist, an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_submit(x, js = FALSE, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_submit_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_submit_+3A_js">js</code></td>
<td>
<p>Whether to submit the form using JavaScript.</p>
</td></tr>
<tr><td><code id="elem_submit_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for the element to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other actions: 
<code><a href="#topic+elem_click">elem_click</a>()</code>,
<code><a href="#topic+elem_hover">elem_hover</a>()</code>,
<code><a href="#topic+elem_scroll_to">elem_scroll_to</a>()</code>,
<code><a href="#topic+elem_select">elem_select</a>()</code>,
<code><a href="#topic+elem_set_value">elem_set_value</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;form&gt;
&lt;input type='submit'&gt;
&lt;p&gt;Random text&lt;/p&gt;
&lt;/form&gt;
&lt;a&gt;Random link&lt;/a&gt;
"

session &lt;- minimal_selenider_session(html)

elem_submit(s("input"))
elem_submit(s("p"))

# Won't work since the element doesn't have a form ancestor
try(elem_submit(s("a"), timeout = 0.5))

</code></pre>

<hr>
<h2 id='elem_text'>Get the text inside an element</h2><span id='topic+elem_text'></span>

<h3>Description</h3>

<p>Get the inner text of a <code>selenider_element</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elem_text(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem_text_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="elem_text_+3A_timeout">timeout</code></td>
<td>
<p>The time to wait for <code>x</code> to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>See Also</h3>

<p>Other properties: 
<code><a href="#topic+elem_attr">elem_attr</a>()</code>,
<code><a href="#topic+elem_css_property">elem_css_property</a>()</code>,
<code><a href="#topic+elem_name">elem_name</a>()</code>,
<code><a href="#topic+elem_size">elem_size</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;p&gt;Example text&lt;/p&gt;
"

session &lt;- minimal_selenider_session(html)

s("p") |&gt;
  elem_text()

</code></pre>

<hr>
<h2 id='execute_js_fn'>Execute a JavaScript function</h2><span id='topic+execute_js_fn'></span><span id='topic+execute_js_expr'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Execute a JavaScript function on zero or more arguments.
</p>
<p><code>execute_js_expr()</code> is a simpler version of <code>execute_js_fn()</code> that can
evaluate simple expressions (e.g. &quot;alert()&quot;). To return a value, you must
do so explicitly using &quot;return&quot;.
</p>
<p>These functions are experimental because their names and parameters are
liable to change. Additionally, their behaviour can be inconsistent between
different session types (chromote and selenium) and different browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execute_js_fn(fn, ..., .timeout = NULL, .session = NULL, .debug = FALSE)

execute_js_expr(expr, ..., .timeout = NULL, .session = NULL, .debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execute_js_fn_+3A_fn">fn</code></td>
<td>
<p>A string defining the function.</p>
</td></tr>
<tr><td><code id="execute_js_fn_+3A_...">...</code></td>
<td>
<p>Arguments to the function/expression. These must be unnamed, since
JavaScript does not support named arguments.</p>
</td></tr>
<tr><td><code id="execute_js_fn_+3A_.timeout">.timeout</code></td>
<td>
<p>How long to wait for any elements to exist in the DOM.</p>
</td></tr>
<tr><td><code id="execute_js_fn_+3A_.session">.session</code></td>
<td>
<p>The session to use, if <code>...</code> does not contain any
selenider elements.</p>
</td></tr>
<tr><td><code id="execute_js_fn_+3A_.debug">.debug</code></td>
<td>
<p>Whether to print the final expression that is executed. Mostly
used for debugging the functions themselves, but can also be used to
identify problems in your own JavaScript code.</p>
</td></tr>
<tr><td><code id="execute_js_fn_+3A_expr">expr</code></td>
<td>
<p>An expression to execute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>...</code> can contain <code>selenider_element</code>/<code>selenider_elements</code> objects,
which will be collected and then passed into the function. However,
more complex objects (e.g. lists of selenider elements) will not be
moved into the JavaScript world correctly.
</p>
<p>Similarly, nodes and lists of nodes returned from a JavaScript function will
be converted into their corresponding
<code>selenider_element</code>/<code>selenider_elements</code> objects, while more complex objects
will not. These elements are not lazy (see <code><a href="#topic+elem_cache">elem_cache()</a></code>), so make sure you
only use them while you are sure they are still on the page.
</p>


<h3>Value</h3>

<p>The return value of the JavaScript function, turned back into an R object.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;button class='mybutton'&gt;Click me&lt;/button&gt;
"
session &lt;- minimal_selenider_session(html)

execute_js_fn("(x, y) =&gt; x + y", 1, 1)

execute_js_expr("arguments[0] + arguments[1]", 1, 1)

execute_js_fn("x =&gt; x.click()", s(".mybutton"))

execute_js_expr("arguments[0].click()", s(".mybutton"))

</code></pre>

<hr>
<h2 id='find_element'>Find a single HTML child element</h2><span id='topic+find_element'></span><span id='topic+find_element.selenider_session'></span><span id='topic+find_element.selenider_element'></span>

<h3>Description</h3>

<p>Find the first HTML element using a CSS selector, an XPath, or a variety
of other methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_element(x, ...)

## S3 method for class 'selenider_session'
find_element(
  x,
  css = NULL,
  xpath = NULL,
  id = NULL,
  class_name = NULL,
  name = NULL,
  ...
)

## S3 method for class 'selenider_element'
find_element(
  x,
  css = NULL,
  xpath = NULL,
  id = NULL,
  class_name = NULL,
  name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_element_+3A_x">x</code></td>
<td>
<p>A selenider session or element.</p>
</td></tr>
<tr><td><code id="find_element_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="find_element_+3A_css">css</code></td>
<td>
<p>A css selector.</p>
</td></tr>
<tr><td><code id="find_element_+3A_xpath">xpath</code></td>
<td>
<p>An XPath.</p>
</td></tr>
<tr><td><code id="find_element_+3A_id">id</code></td>
<td>
<p>The id of the element you want to select.</p>
</td></tr>
<tr><td><code id="find_element_+3A_class_name">class_name</code></td>
<td>
<p>The class name of the element you want to select.</p>
</td></tr>
<tr><td><code id="find_element_+3A_name">name</code></td>
<td>
<p>The name attribute of the element you want to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more than one method is used to select an element (e.g. <code>css</code> and
<code>xpath</code>), the first element which satisfies all conditions will be found.
</p>
<p>CSS selectors are generally recommended over other options, since they are
usually the easiest to read. Use <code>"tag_name"</code> to select by tag name,
<code>".class"</code> to select by class, and <code>"#id"</code> to select by id.
</p>


<h3>Value</h3>

<p>A <code>selenider_element</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+s">s()</a></code> to quickly select an element without specifying the session.
</p>
</li>
<li> <p><code><a href="#topic+find_elements">find_elements()</a></code> to select multiple elements.
</p>
</li>
<li> <p><code><a href="#topic+selenider_session">selenider_session()</a></code> to begin a session.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div class='class1'&gt;
  &lt;div id='id1'&gt;
    &lt;p class='class2'&gt;Example text&lt;/p&gt;
  &lt;/div&gt;
  &lt;p&gt;Example text&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

session |&gt;
  find_element("div")

session |&gt;
  find_element("div") |&gt;
  find_element(xpath = "./p")

s("div") |&gt;
  find_element("#id1")

s("div") |&gt;
  find_element(id = "id1") |&gt;
  find_element(class_name = "class2")

s(xpath = "//div[contains(@class, 'class1')]/div/p")

# Complex Xpath expressions are easier to read as chained CSS selectors.
# This is equivalent to above
s("div.class1") |&gt;
  find_element("div") |&gt;
  find_element("p")

</code></pre>

<hr>
<h2 id='find_elements'>Find multiple HTML child elements</h2><span id='topic+find_elements'></span><span id='topic+find_elements.selenider_session'></span><span id='topic+find_elements.selenider_element'></span>

<h3>Description</h3>

<p>Find every available HTML element using a CSS selector, an XPath, or a
variety of other methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_elements(x, ...)

## S3 method for class 'selenider_session'
find_elements(
  x,
  css = NULL,
  xpath = NULL,
  id = NULL,
  class_name = NULL,
  name = NULL,
  ...
)

## S3 method for class 'selenider_element'
find_elements(
  x,
  css = NULL,
  xpath = NULL,
  id = NULL,
  class_name = NULL,
  name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_elements_+3A_x">x</code></td>
<td>
<p>A selenider session or element.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_css">css</code></td>
<td>
<p>A css selector.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_xpath">xpath</code></td>
<td>
<p>An XPath.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_id">id</code></td>
<td>
<p>The id of the element you want to select.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_class_name">class_name</code></td>
<td>
<p>The class name of the element you want to select.</p>
</td></tr>
<tr><td><code id="find_elements_+3A_name">name</code></td>
<td>
<p>The name attribute of the element you want to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more than one method is used to select an element (e.g. <code>css</code> and
<code>xpath</code>), the first element which satisfies every condition will be found.
</p>


<h3>Value</h3>

<p>A <code>selenider_elements</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ss">ss()</a></code> to quickly select multiple elements without specifying the session.
</p>
</li>
<li> <p><code><a href="#topic+find_element">find_element()</a></code> to select multiple elements.
</p>
</li>
<li> <p><code><a href="#topic+selenider_session">selenider_session()</a></code> to begin a session.
</p>
</li>
<li> <p><code><a href="#topic+elem_children">elem_children()</a></code> and family to select elements using their relative
position in the DOM.
</p>
</li>
<li> <p><code><a href="#topic+elem_filter">elem_filter()</a></code> and <code><a href="#topic+elem_find">elem_find()</a></code> for filtering element collections.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div id='outer-div'&gt;
  &lt;div&gt;
    &lt;p&gt;Text 1&lt;/p&gt;
    &lt;p&gt;Text 2&lt;/p&gt;
    &lt;p&gt;Text 3&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

session |&gt;
  find_elements("div")

# Or:
ss("div")

session |&gt;
  find_element("#outer-div") |&gt;
  find_elements("p")

# The above can be shortened to:
s("#outer-div") |&gt;
  find_elements("p")

</code></pre>

<hr>
<h2 id='get_actual_element'>Get the element associated with a selenider element</h2><span id='topic+get_actual_element'></span><span id='topic+get_actual_elements'></span>

<h3>Description</h3>

<p>Turn a lazy selenium element or element collection into a backendNodeId
(chromote) or a <a href="selenium.html#topic+WebElement">selenium::WebElement</a>. Use this to perform certain actions
on the element that are not implemented in selenider.
</p>
<p><code>get_actual_element()</code> turns a <code>selenider_element</code> object into a single
backendNodeId or <a href="selenium.html#topic+WebElement">selenium::WebElement</a> object. The function will wait for
the object to exist in the DOM.
</p>
<p><code>get_actual_elements()</code> turns a <code>selenider_elements</code> object into a list
of <a href="selenium.html#topic+WebElement">selenium::WebElement</a> objects, waiting for any parent objects to
exist in the DOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_actual_element(x, timeout = NULL)

get_actual_elements(x, timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_actual_element_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> or <code>selenider_elements</code> object, produced by
<code><a href="#topic+find_element">find_element()</a></code> / <code><a href="#topic+find_elements">find_elements()</a></code>.</p>
</td></tr>
<tr><td><code id="get_actual_element_+3A_timeout">timeout</code></td>
<td>
<p>The timeout to use while asserting that the item exists. If
NULL, the timeout of the <code>selenider_element</code> will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer (backendNodeId), or a <a href="selenium.html#topic+WebElement">selenium::WebElement</a> object.
<code>get_actual_elements()</code> returns a list of such objects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+s">s()</a></code>, <code><a href="#topic+ss">ss()</a></code>, <code><a href="#topic+find_element">find_element()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code> to select selenider
elements.
</p>
</li>
<li> <p><code><a href="#topic+elem_cache">elem_cache()</a></code> and <code><a href="#topic+elem_cache">elem_cache()</a></code> to cache these values.
</p>
</li>
<li><p> The <a href="https://chromedevtools.github.io/devtools-protocol/tot/">Chrome Devtools Protocol documentation</a>
for the operations that can be performed using a backend node id. Note
that this requires the <a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a> object, which can be
retrieved using <code style="white-space: pre;">&#8288;&lt;selenider_session&gt;$driver&#8288;</code>.
</p>
</li>
<li><p> The documentation for <code><a href="selenium.html#topic+WebElement">selenium::WebElement()</a></code> to see the things you can
do with a webElement.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;
&lt;p&gt;Text&lt;/p&gt;
&lt;p&gt;More text&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

elem &lt;- s("div") |&gt;
  get_actual_element()

# The ChromoteSession/SeleniumSession can be accessed using session$driver
driver &lt;- session$driver

if (inherits(driver, "ChromoteSession")) {
  driver$DOM$getBoxModel(backendNodeId = elem)
} else if (inherits(elem, "WebElement")) {
  elem$get_rect()
}

elems &lt;- ss("p") |&gt;
  get_actual_elements()

if (inherits(driver, "ChromoteSession")) {
  driver$DOM$describeNode(backendNodeId = elems[[1]])
} else if (inherits(elems[[1]], "WebElement")) {
  elems[[1]]$get_rect()
}

</code></pre>

<hr>
<h2 id='get_page_source'>Read the HTML of a session</h2><span id='topic+get_page_source'></span>

<h3>Description</h3>

<p>Uses <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code> to read the page source of the session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_page_source(session = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_page_source_+3A_session">session</code></td>
<td>
<p>Optionally, a <code>selenider_session</code> object.</p>
</td></tr>
<tr><td><code id="get_page_source_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An XML document.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;p&gt;Example text&lt;/p&gt;
"

session &lt;- minimal_selenider_session(html)

get_page_source()

</code></pre>

<hr>
<h2 id='get_session'>Get or set the local selenider session</h2><span id='topic+get_session'></span><span id='topic+local_session'></span><span id='topic+with_session'></span>

<h3>Description</h3>

<p>Change the locally defined <code><a href="#topic+selenider_session">selenider_session()</a></code> object, allowing it to be
used in functions like <code><a href="#topic+s">s()</a></code> without explicitly providing it.
</p>
<p><code>get_session()</code> retrieves the current local session. If none have been
created, a session is created automatically.
</p>
<p><code>local_session()</code> sets the local session. The function uses <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to make sure the session is closed and the local session is set to its
previous value when it is no longer needed.
</p>
<p><code>with_session()</code> runs some code with a temporary local session. The session
is closed and the local session is set to its previous value when the code
finishes executing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_session(create = TRUE, .env = rlang::caller_env())

local_session(session, .local_envir = rlang::caller_env(), close = TRUE)

with_session(session, code, close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_session_+3A_create">create</code></td>
<td>
<p>If a session is not found, should we create a new one? If this
is <code>FALSE</code> and a session is not found, <code>NULL</code> is returned.</p>
</td></tr>
<tr><td><code id="get_session_+3A_.env">.env</code></td>
<td>
<p>If <code>get_session()</code> creates a session, the environment where this
session is being used.</p>
</td></tr>
<tr><td><code id="get_session_+3A_session">session</code></td>
<td>
<p>The <code><a href="#topic+selenider_session">selenider_session()</a></code> object to use.</p>
</td></tr>
<tr><td><code id="get_session_+3A_.local_envir">.local_envir</code></td>
<td>
<p>The environment where the session is being used. When
the function associated with this environment finishes execution, the
session will be reset.</p>
</td></tr>
<tr><td><code id="get_session_+3A_close">close</code></td>
<td>
<p>Should we close <code>session</code> when the local session is reset? Set
this to <code>FALSE</code> if you want to use the session even if it is no longer the
local session. If you want to close the session manually, use
<code><a href="#topic+close_session">close_session()</a></code>.</p>
</td></tr>
<tr><td><code id="get_session_+3A_code">code</code></td>
<td>
<p>The code to run with the local session set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code><a href="withr.html#topic+defer">withr::deferred_run()</a></code> to reset any local sessions set using
<code>local_session()</code>.
</p>


<h3>Value</h3>

<p><code>get_session()</code> returns the local <code><a href="#topic+selenider_session">selenider_session()</a></code> object (or a newly
created session).
</p>
<p><code>local_session()</code> returns the <em>previous</em> local session object (or <code>NULL</code>).
This is the same as running <code>get_session()</code> before this function.
</p>
<p><code>with_session()</code> returns the result of <code>code</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selenider_session">selenider_session()</a></code>, which calls <code>local_session()</code> unless otherwise
specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Don't set the local session, since we want to do it manually.
session &lt;- selenider_session(local = FALSE)

get_session(create = FALSE) # NULL

local_session(session, close = FALSE)

get_session(create = FALSE)

withr::deferred_run()

get_session(create = FALSE) # NULL

# By default, the local session is only set inside the function that it is
# called.
# If we want to set the local session outside the scope of a function, we
# need to use the `.local_envir` argument.
set_my_session &lt;- function(env = rlang::caller_env()) {
  # caller_env() is the environment where the function is called.
  local_session(session, .local_envir = env, close = FALSE)
}

set_my_session()

with_session(
  session,
  {
    get_session(create = FALSE)
  },
  close = FALSE
)

get_session(create = FALSE)

</code></pre>

<hr>
<h2 id='has_attr'>Does an element's attribute match a value?</h2><span id='topic+has_attr'></span><span id='topic+attr_contains'></span><span id='topic+has_value'></span>

<h3>Description</h3>

<p><code>has_attr()</code> checks that an element's attribute matches a value, while
<code>attr_contains()</code> checks that an element's attribute contains a value.
</p>
<p><code>has_value()</code> is a shortcut for <code>has_attr("value")</code>: it checks that an
element's value matches a string or number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_attr(x, name, value)

attr_contains(x, name, value)

has_value(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_attr_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="has_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute.</p>
</td></tr>
<tr><td><code id="has_attr_+3A_value">value</code></td>
<td>
<p>The value of the attribute. For <code>has_attr()</code> and <code>has_value()</code>,
this can be a string or a numeric value, while <code>attr_contains()</code> can only
take a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;input class='myclass' value='1.0' data-customattr='Custom attribute text'&gt;
"

session &lt;- minimal_selenider_session(html)

has_attr(s("input"), "class", "myclass")

has_attr(s("input"), "value", 1)
has_value(s("input"), 1)

attr_contains(s("input"), "data-customattr", "Custom attribute")

</code></pre>

<hr>
<h2 id='has_css_property'>Does an element's css property match a value?</h2><span id='topic+has_css_property'></span>

<h3>Description</h3>

<p>Check that the CSS property (e.g. <code>"background-color"</code>) of an element matches
a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_css_property(x, property, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_css_property_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="has_css_property_+3A_property">property</code></td>
<td>
<p>The name of the CSS property</p>
</td></tr>
<tr><td><code id="has_css_property_+3A_value">value</code></td>
<td>
<p>The value of the attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div style='display:none;'&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

has_css_property(s("div"), "display", "none")

</code></pre>

<hr>
<h2 id='has_length'>Does a collection have a certain number of elements?</h2><span id='topic+has_length'></span><span id='topic+has_size'></span><span id='topic+has_at_least'></span>

<h3>Description</h3>

<p><code>has_length()</code> and <code>has_size()</code> checks that a collection of HTML elements
contains a certain number of elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_length(x, n)

has_size(x, n)

has_at_least(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_length_+3A_x">x</code></td>
<td>
<p>A <code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="has_length_+3A_n">n</code></td>
<td>
<p>A numeric vector of possible lengths of <code>x</code>. For <code>has_at_least()</code>,
this must be a single number to compare to the length of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>has_at_least()</code> checks that a collection contains <em>at least</em> <code>n</code> elements.
</p>
<p>These functions do not implement a retry mechanism, and only test a condition
once. Use <code><a href="#topic+elem_expect">elem_expect()</a></code> or <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> to use these conditions in
tests.
</p>


<h3>Value</h3>

<p>A boolean value: <code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div class='div1'&gt;&lt;/div&gt;
&lt;div class='div2'&gt;&lt;/div&gt;
&lt;div class='div3'&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

has_length(ss("div"), 3)
has_at_least(ss("div"), 2)

</code></pre>

<hr>
<h2 id='has_name'>Does an element have a tag name?</h2><span id='topic+has_name'></span>

<h3>Description</h3>

<p>Check that an element has a specified tag name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_name(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_name_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="has_name_+3A_name">name</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div id='mydiv'&gt;&lt;/div&gt;
"
session &lt;- minimal_selenider_session(html)

has_name(s("#mydiv"), "p")

has_name(s("#mydiv"), "div")

</code></pre>

<hr>
<h2 id='has_text'>Does an element contain a pattern?</h2><span id='topic+has_text'></span><span id='topic+has_exact_text'></span>

<h3>Description</h3>

<p><code>has_text()</code> checks that an element's inner text contains a string, while
<code>has_exact_text()</code> checks that the inner text <em>only</em> contains the string.
Both functions throw an error if the element does not exist in the DOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_text(x, text)

has_exact_text(x, text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_text_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="has_text_+3A_text">text</code></td>
<td>
<p>A string, used to test the element's inner text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not implement a retry mechanism, and only test a condition
once. Use <code><a href="#topic+elem_expect">elem_expect()</a></code> or <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> to use these conditions in
tests.
</p>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;p&gt;Example text&lt;/p&gt;
&lt;p class='empty'&gt;&lt;/p&gt;
"

session &lt;- minimal_selenider_session(html)

has_text(s("p"), "Example") # TRUE

has_exact_text(s("p"), "Example") # FALSE

has_exact_text(s("p"), "Example text") # TRUE

# has_exact_text() is useful for checking when there is no text,
# since has_text("") will always be TRUE.
has_exact_text(s(".empty"), "")

</code></pre>

<hr>
<h2 id='is_enabled'>Is an element enabled?</h2><span id='topic+is_enabled'></span><span id='topic+is_disabled'></span>

<h3>Description</h3>

<p><code>is_disabled()</code> checks that an element has the <code>disabled</code> attribute set to
<code>TRUE</code>, while <code>is_enabled()</code> checks that it does not. Both functions throw an
error if the element does not exist in the DOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_enabled(x)

is_disabled(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_enabled_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not implement a retry mechanism, and only test a condition
once. Use <code><a href="#topic+elem_expect">elem_expect()</a></code> or <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> to use these conditions in
tests.
</p>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;button&gt;&lt;/button&gt;
&lt;button disabled&gt;&lt;/button&gt;
"

session &lt;- minimal_selenider_session(html)

is_enabled(s("button")) # TRUE

is_disabled(ss("button")[[2]]) # TRUE

</code></pre>

<hr>
<h2 id='is_present'>Does an element exist?</h2><span id='topic+is_present'></span><span id='topic+is_in_dom'></span><span id='topic+is_absent'></span>

<h3>Description</h3>

<p><code>is_present()</code> and <code>is_in_dom()</code> checks if an element is present on the page,
while <code>is_missing()</code> and <code>is_absent()</code> checks the opposite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_present(x)

is_in_dom(x)

is_absent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_present_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not implement a retry mechanism, and only test a condition
once. Use <code><a href="#topic+elem_expect">elem_expect()</a></code> or <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> to use these conditions in
tests.
</p>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_visible">is_visible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;p class='class1'&gt;&lt;/p&gt;
"

session &lt;- minimal_selenider_session(html)

is_present(s(".class1")) # TRUE

is_in_dom(s(".class2")) # FALSE

is_absent(s(".class2")) # TRUE

</code></pre>

<hr>
<h2 id='is_visible'>Is an element visible?</h2><span id='topic+is_visible'></span><span id='topic+is_displayed'></span><span id='topic+is_hidden'></span><span id='topic+is_invisible'></span>

<h3>Description</h3>

<p><code>is_visible()</code> and <code>is_displayed()</code> checks that an element can be seen on the
page, while <code>is_invisible()</code> and <code>is_hidden()</code> checks the opposite. All
functions throw an error if the element is not in the DOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_visible(x)

is_displayed(x)

is_hidden(x)

is_invisible(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_visible_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not implement a retry mechanism, and only test a condition
once. Use <code><a href="#topic+elem_expect">elem_expect()</a></code> or <code><a href="#topic+elem_wait_until">elem_wait_until()</a></code> to use these conditions in
tests.
</p>


<h3>Value</h3>

<p>A boolean value: TRUE or FALSE.
</p>


<h3>See Also</h3>

<p>Other conditions: 
<code><a href="#topic+has_attr">has_attr</a>()</code>,
<code><a href="#topic+has_css_property">has_css_property</a>()</code>,
<code><a href="#topic+has_length">has_length</a>()</code>,
<code><a href="#topic+has_name">has_name</a>()</code>,
<code><a href="#topic+has_text">has_text</a>()</code>,
<code><a href="#topic+is_enabled">is_enabled</a>()</code>,
<code><a href="#topic+is_present">is_present</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div style='visibility:hidden;'&gt;Content 1&lt;/div&gt;
&lt;div style='display:none'&gt;Content 2&lt;/div&gt;
&lt;div&gt;Content 3&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

is_visible(s("div")) # FALSE

is_invisible(ss("div")[[2]]) # TRUE

is_visible(ss("div")[[3]]) # TRUE

</code></pre>

<hr>
<h2 id='keys'>Special keys</h2><span id='topic+keys'></span>

<h3>Description</h3>

<p>List of special keys, for use with <code><a href="#topic+elem_send_keys">elem_send_keys()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys
</code></pre>


<h3>Format</h3>

<p>A list containing <code>selenider_key</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keys$backspace
</code></pre>

<hr>
<h2 id='minimal_selenider_session'>Create a session with custom HTML</h2><span id='topic+minimal_selenider_session'></span>

<h3>Description</h3>

<p>Create a <code>selenider_session</code> using custom HTML/JavaScript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal_selenider_session(html, js = NULL, ..., .env = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_selenider_session_+3A_html">html</code></td>
<td>
<p>A string to use as HTML. Can also be an <code>xml2</code> object.</p>
</td></tr>
<tr><td><code id="minimal_selenider_session_+3A_js">js</code></td>
<td>
<p>A string (or <code>NULL</code>) to use as JavaScript.</p>
</td></tr>
<tr><td><code id="minimal_selenider_session_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="#topic+selenider_session">selenider_session()</a></code>.</p>
</td></tr>
<tr><td><code id="minimal_selenider_session_+3A_.env">.env</code></td>
<td>
<p>The environment in which the session will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by combining <code>html</code> and <code>js</code> into a single string, then
writing this to a temporary file (and opening it in the session's browser).
</p>


<h3>Value</h3>

<p>A <code>selenider_session</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selenider_session">selenider_session()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- minimal_selenider_session("&lt;p&gt;Example&lt;/p&gt;")

</code></pre>

<hr>
<h2 id='open_url'>Open a URL</h2><span id='topic+open_url'></span>

<h3>Description</h3>

<p>Navigate the browser to specified URL, waiting until the page is considered
open before finishing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_url(url, session = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open_url_+3A_url">url</code></td>
<td>
<p>The URL to navigate to: a string.</p>
</td></tr>
<tr><td><code id="open_url_+3A_session">session</code></td>
<td>
<p>A <code>selenider_session</code> object. If not specified, the global
session object (the result of <code><a href="#topic+get_session">get_session()</a></code>) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The session object, invisibly.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session()

open_url("https://r-project.org")

# Or:
open_url(session = session, "https://r-project.org")

</code></pre>

<hr>
<h2 id='print.selenider_element'>Print a live HTML element</h2><span id='topic+print.selenider_element'></span><span id='topic+print.selenider_elements'></span><span id='topic+print_lazy'></span><span id='topic+print_lazy.selenider_element'></span><span id='topic+print_lazy.selenider_elements'></span>

<h3>Description</h3>

<p>Display an element or collection of elements by fetching the elements and
displaying their HTML contents.
</p>
<p><code>print_lazy()</code> allows an element to be printed without fetching it, by
displaying a summary of the steps that will be taken to reach the element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selenider_element'
print(x, width = getOption("width"), ..., timeout = NULL)

## S3 method for class 'selenider_elements'
print(x, width = getOption("width"), ..., n = 20, timeout = NULL)

print_lazy(x, ...)

## S3 method for class 'selenider_element'
print_lazy(x, ...)

## S3 method for class 'selenider_elements'
print_lazy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.selenider_element_+3A_x">x</code></td>
<td>
<p>A <code>selenider_element</code> or <code>selenider_elements</code> object.</p>
</td></tr>
<tr><td><code id="print.selenider_element_+3A_width">width</code></td>
<td>
<p>The maximum width of the output.</p>
</td></tr>
<tr><td><code id="print.selenider_element_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="print.selenider_element_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for <code>x</code> to exist in order to print its HTML.</p>
</td></tr>
<tr><td><code id="print.selenider_element_+3A_n">n</code></td>
<td>
<p>The maximum number of elements to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;
&lt;p&gt;Text 1&lt;/p&gt;
&lt;p&gt;Text 2&lt;/p&gt;
&lt;p&gt;Text 3&lt;/p&gt;
&lt;p&gt;Text 4&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

print(s("div"))

print(ss("p"))

print(ss("p"), n = 3)

s("div") |&gt;
  find_elements("p") |&gt;
  elem_filter(has_text("Text 3")) |&gt;
  print_lazy()

</code></pre>

<hr>
<h2 id='read_html.selenider_session'>Read a live HTML document</h2><span id='topic+read_html.selenider_session'></span><span id='topic+read_html.selenider_element'></span>

<h3>Description</h3>

<p><code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code> can be used on a selenider session to read the HTML of
the entire page, or on a selenider element to get the HTML of that element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_html.selenider_session(
  x,
  encoding = "",
  ...,
  options = c("RECOVER", "NOERROR", "NOBLANKS")
)

read_html.selenider_element(
  x,
  encoding = "",
  timeout = NULL,
  outer = TRUE,
  ...,
  options = c("RECOVER", "NOERROR", "NOBLANKS")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_html.selenider_session_+3A_x">x</code></td>
<td>
<p>A <code>selenider_session</code>/<code>selenider_element</code> object.</p>
</td></tr>
<tr><td><code id="read_html.selenider_session_+3A_encoding">encoding</code>, <code id="read_html.selenider_session_+3A_...">...</code>, <code id="read_html.selenider_session_+3A_options">options</code></td>
<td>
<p>Passed into <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code>.</p>
</td></tr>
<tr><td><code id="read_html.selenider_session_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait for <code>x</code> to exist in the DOM before throwing
an error.</p>
</td></tr>
<tr><td><code id="read_html.selenider_session_+3A_outer">outer</code></td>
<td>
<p>Whether to read the inner (all children of the current element)
or outer (including the element itself) HTML of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_html()</code> returns an XML document. Note that HTML will always be wrapped
in a <code style="white-space: pre;">&#8288;&lt;html&gt;&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;body&gt;&#8288;</code> tag, if it isn't already.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rvest)

html &lt;- "
&lt;div&gt;
&lt;p&gt;Example text&lt;/p&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

read_html(session)
read_html(s("div"))

</code></pre>

<hr>
<h2 id='reload'>Reload the current page</h2><span id='topic+reload'></span><span id='topic+refresh'></span>

<h3>Description</h3>

<p><code>reload()</code> and <code>refresh()</code> both reload the current page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reload(session = NULL)

refresh(session = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reload_+3A_session">session</code></td>
<td>
<p>A <code>selenider_session</code> object. If not specified, the global
session object (the result of <code><a href="#topic+get_session">get_session()</a></code>) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The session object, invisibly.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+take_screenshot">take_screenshot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session()

open_url("https://r-project.org")

reload()

</code></pre>

<hr>
<h2 id='s'>Select HTML elements</h2><span id='topic+s'></span><span id='topic+ss'></span>

<h3>Description</h3>

<p>Both <code>s()</code> and <code>ss()</code> allow you to select elements without specifying a
session object.
</p>
<p><code>s()</code> selects a single element, being a shorthand for <code><a href="#topic+find_element">find_element()</a></code>
on the current session.
</p>
<p><code>ss()</code> selects multiple elements, being a shorthand for <code><a href="#topic+find_elements">find_elements()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s(css = NULL, xpath = NULL, id = NULL, class_name = NULL, name = NULL)

ss(css = NULL, xpath = NULL, id = NULL, class_name = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_+3A_css">css</code></td>
<td>
<p>A css selector.</p>
</td></tr>
<tr><td><code id="s_+3A_xpath">xpath</code></td>
<td>
<p>An XPath.</p>
</td></tr>
<tr><td><code id="s_+3A_id">id</code></td>
<td>
<p>The id of the element you want to select.</p>
</td></tr>
<tr><td><code id="s_+3A_class_name">class_name</code></td>
<td>
<p>The class name of the element you want to select.</p>
</td></tr>
<tr><td><code id="s_+3A_name">name</code></td>
<td>
<p>The name attribute of the element you want to select.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions allow the starting point for chains of selectors to be made
more concise. Both use <code><a href="#topic+get_session">get_session()</a></code> to get the global session object.
</p>


<h3>Value</h3>

<p><code>s()</code> returns a <code>selenider_element</code> object.
<code>ss()</code> returns a <code>selenider_elements</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+find_element">find_element()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+selenider_session">selenider_session()</a></code> to begin a session.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
html &lt;- "
&lt;div&gt;
&lt;p id='id1' class='inner'&gt;&lt;/p&gt;
&lt;div class='child'&gt;
&lt;p class='inner'&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
"

session &lt;- minimal_selenider_session(html)

s("#id1")

# This is the equivalent of:
find_element(session, "#id1")

ss(".inner")

# This is the equivalent of:
find_element(session, ".inner")

# This provides a more concise way to begin a chain of selectors
s("div") |&gt;
  find_element(".child") |&gt;
  find_element(".inner")

</code></pre>

<hr>
<h2 id='selenider_available'>Check if selenider can be used</h2><span id='topic+selenider_available'></span><span id='topic+skip_if_selenider_unavailable'></span>

<h3>Description</h3>

<p>Checks if selenider's dependencies are available, and that we are in an
environment where it makes sense to open a selenider session.
</p>
<p><code>skip_if_selenider_unavailable()</code> skips a testthat test if
<code>selenider_available()</code> returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selenider_available(
  session = c("chromote", "selenium", "rselenium"),
  online = TRUE
)

skip_if_selenider_unavailable(session = c("chromote", "selenium"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selenider_available_+3A_session">session</code></td>
<td>
<p>Which session we should check. <code>"chromote"</code> is used by
default.</p>
</td></tr>
<tr><td><code id="selenider_available_+3A_online">online</code></td>
<td>
<p>Whether we need to check for an internet connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically, the following is checked:
</p>

<ul>
<li><p> The <code>SELENIDER_AVAILABLE</code> environment variable. Set this to <code>"TRUE" </code>or
<code>"FALSE"</code> to override this function.
</p>
</li>
<li><p> Whether we are on CRAN (using the <code>NOT_CRAN</code> environment variable). If we
are, the function returns <code>FALSE</code>.
</p>
</li>
<li><p> Whether an internet connection is available (using <code><a href="curl.html#topic+nslookup">curl::nslookup()</a></code>).
</p>
</li></ul>

<p>If <code>session</code> is <code>"chromote"</code>, we also check:
</p>

<ul>
<li><p> Whether <code>chromote</code> is installed.
</p>
</li>
<li><p> Whether <code><a href="chromote.html#topic+find_chrome">chromote::find_chrome()</a></code> does not error.
</p>
</li></ul>

<p>If <code>session</code> is <code>"selenium"</code>, we check:
</p>

<ul>
<li><p> Whether <code>selenium</code> is installed.
</p>
</li>
<li><p> Whether we can find a valid browser that is supported by <code>RSelenium</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A boolean flag: <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>selenider_available()

</code></pre>

<hr>
<h2 id='selenider_session'>Start a session</h2><span id='topic+selenider_session'></span>

<h3>Description</h3>

<p>Create a session in selenider, setting it as the local session unless
otherwise specified, allowing the session to be accessed globally in the
environment where it was defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selenider_session(
  session = getOption("selenider.session"),
  browser = getOption("selenider.browser"),
  timeout = 4,
  options = NULL,
  driver = NULL,
  local = TRUE,
  .env = rlang::caller_env(),
  view = FALSE,
  selenium_manager = TRUE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selenider_session_+3A_session">session</code></td>
<td>
<p>The package to use as a backend: either &quot;chromote&quot;,
&quot;selenium&quot; or &quot;rselenium&quot;. By default, chromote is used, since this tends
to be faster and more reliable. Change the default value using the
<code>selenider.session</code> option.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_browser">browser</code></td>
<td>
<p>The name of the browser to run the session in; one of
&quot;chrome&quot;, &quot;firefox&quot;, &quot;edge&quot;, &quot;safari&quot;, or another valid browser name.
If <code>NULL</code>, the function will try to work out which browser you have
installed. If we are using chromote, this option is ignored, since
chromote only works on Chrome. Change the default value of this parameter
using the <code>selenider.browser</code> option.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_timeout">timeout</code></td>
<td>
<p>The default time to wait when collecting an element.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_options">options</code></td>
<td>
<p>A <code><a href="#topic+chromote_options">chromote_options()</a></code> or <code><a href="#topic+selenium_options">selenium_options()</a></code> object,
used to specify options that are specific to chromote or selenium. See
Details for some useful examples of this.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_driver">driver</code></td>
<td>
<p>A driver object to use instead of creating one manually. This
can be one of:
</p>

<ul>
<li><p> A <a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a> object.
</p>
</li>
<li><p> A <a href="shinytest2.html#topic+AppDriver">shinytest2::AppDriver</a> object.
</p>
</li>
<li><p> An <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> object.
</p>
</li>
<li><p> A Selenium server object, created by <code><a href="selenium.html#topic+selenium_server">selenium::selenium_server()</a></code> or
<code><a href="wdman.html#topic+selenium">wdman::selenium()</a></code>. In this case, a client will be created using the
server object.
</p>
</li>
<li><p> A list/environment containing the <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> object,
the Selenium server object, or both.
</p>
</li>
<li><p> An <code><a href="RSelenium.html#topic+remoteDriver-class">RSelenium::remoteDriver()</a></code> object can be used instead of a
<a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="selenider_session_+3A_local">local</code></td>
<td>
<p>Whether to set the session as the local session object,
using <code><a href="#topic+local_session">local_session()</a></code>.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_.env">.env</code></td>
<td>
<p>Passed into <code><a href="#topic+local_session">local_session()</a></code>, to define the
environment in which the session is used. Change this if you want to
create the session inside a function and then use it outside the
function.</p>
</td></tr>
<tr><td><code id="selenider_session_+3A_view">view</code>, <code id="selenider_session_+3A_selenium_manager">selenium_manager</code>, <code id="selenider_session_+3A_quiet">quiet</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use the <code>options</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>selenider_session</code> object. Use <code>session$driver</code> to retrieve the driver
object that controls the browser.
</p>


<h3>Useful session-specific options</h3>

<p>See <code><a href="#topic+chromote_options">chromote_options()</a></code> and <code><a href="#topic+selenium_options">selenium_options()</a></code> for the full range.
</p>


<h4>Making a chromote session non-headless</h4>

<p>By default, chromote will run in headless mode, meaning that you won't
actually be able to see the browser as you control it. Use the <code>view</code>
argument to <code><a href="#topic+chromote_options">chromote_options()</a></code> to change this:
</p>
<div class="sourceCode r"><pre>session &lt;- selenider_session(
  options = chromote_options(view = TRUE)
)
</pre></div>



<h4>Prevent creation of a selenium server</h4>

<p>Sometimes, you want to manage the Selenium server separately, and only let
selenider create client objects to attach to the server. You can do this by
passing <code>NULL</code> into the <code>server_options</code> argument to <code><a href="#topic+selenium_options">selenium_options()</a></code>:
</p>
<div class="sourceCode r"><pre>session &lt;- selenider_session(
  "selenium",
  options = selenium_options(server_options = NULL)
)
</pre></div>
<p>If the port you are using is not 4444, you will need to pass in the <code>port</code>
argument to <code><a href="#topic+selenium_client_options">selenium_client_options()</a></code> as well:
</p>
<div class="sourceCode r"><pre>session &lt;- selenider_session(
  "selenium",
  options = selenium_options(
    client_options = selenium_client_options(port = YOUR_PORT),
    server_options = NULL
  )
)
</pre></div>
<p>One example of when this may be useful is when you are managing the Selenium
server using Docker.
</p>



<h4>Store the Selenium server persistently</h4>

<p>By default, selenium will download and store the Selenium server JAR file
in a temporary directory, which will be deleted when the R session finishes.
This means that every time you start a new R session, this file will be
re-downloaded. You can store the JAR file permanently using the <code>temp</code>
argument to <code><a href="#topic+selenium_server_options">selenium_server_options()</a></code>:
</p>
<div class="sourceCode r"><pre>session &lt;- selenider_session(
  "selenium",
  options = selenium_options(
    server_options = selenium_server_options(temp = TRUE)
  )
)
</pre></div>
<p>The downside of this is you may end up using a lot of storage, especially
if a new version of Selenium is released and the old server file is left
on the filesystem.
</p>
<p>You can also use the <code>path</code> argument to <code><a href="#topic+selenium_server_options">selenium_server_options()</a></code> to
specify the directory where the JAR file should be stored.
</p>



<h3>Structure of a selenider session</h3>

<p>A <code>selenider_session</code> object has several components that can be useful to
access:
</p>

<ul>
<li> <p><code>session</code> - The type of session, either <code>"chromote"</code> or <code>"selenium"</code>.
</p>
</li>
<li> <p><code>driver</code> - The driver object used to control the browser. This is either a
<a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a> or <a href="selenium.html#topic+SeleniumSession">selenium::SeleniumSession</a> object. This is
useful if you want to do something with the driver that is not directly
supported by selenider. See <code><a href="#topic+get_actual_element">get_actual_element()</a></code> for some examples of
this.
</p>
</li>
<li> <p><code>server</code> - The Selenium server object, if one was created or passed in.
</p>
</li>
<li> <p><code>id</code> - A unique ID that can be used to identify the session.
</p>
</li></ul>

<p>Access these components using <code>$</code> (e.g. <code>session$driver</code>).
</p>


<h3>Custom drivers</h3>

<p>If you want complete manual control over creating the underlying driver,
you can pass your own <code>driver</code> argument to stop selenider from creating
the driver for you.
</p>
<p>You can also supply a <a href="shinytest2.html#topic+AppDriver">shinytest2::AppDriver</a> object, allowing selenider and
shinytest2 to share a session:
</p>
<div class="sourceCode"><pre>shiny_app &lt;- shiny::shinyApp(
  ui = shiny::fluidPage(
    # ... Your UI
  ),
  server = function(input, output) {
    # ... Your server
  }
)

app &lt;- shinytest2::AppDriver$new()

session &lt;- selenider_session(
  driver = app
)
</pre></div>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+close_session">close_session()</a></code> to close the session. Note that this will not reset the
result of <code><a href="#topic+get_session">get_session()</a></code>, which is why <code><a href="withr.html#topic+defer">withr::deferred_run()</a></code> is
preferred.
</p>
</li>
<li> <p><code><a href="#topic+local_session">local_session()</a></code> and <code><a href="#topic+with_session">with_session()</a></code> to manually set the local session
object (and <code><a href="#topic+get_session">get_session()</a></code> to get it).
</p>
</li>
<li> <p><code><a href="#topic+open_url">open_url()</a></code>, <code><a href="#topic+s">s()</a></code> and <code><a href="#topic+find_elements">find_elements()</a></code> to get started once you have
created a session.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

session_1 &lt;- selenider_session(timeout = 10)
# session_1 is the local session here

get_session() # Returns session 1

my_function &lt;- function() {
  session_2 &lt;- selenider_session()

  # In here, session_2 is the local session
  get_session()
} # When the function finishes executing, the session is closed

my_function() # Returns `session_2`

# If we want to use a session outside the scope of a function,
# we need to use the `.env` argument.
create_session &lt;- function(timeout = 10, .env = rlang::caller_env()) {
  # caller_env() is the environment where the function is called
  selenider_session(timeout = timeout, .env = .env)
}

my_session &lt;- create_session()

# We can now use this session outside the `create_session()` function
get_session()

# `my_session` will be closed automatically.

</code></pre>

<hr>
<h2 id='selenider-config'>Selenider options</h2><span id='topic+selenider-config'></span>

<h3>Description</h3>

<p><code>selenider</code> has a few options, allowing you to specify the session and
browser to use without having to tell <code><a href="#topic+selenider_session">selenider_session()</a></code> this information
every time.
</p>

<ul>
<li> <p><code>selenider.session</code> - The package to use as a backend: either &quot;chromote&quot;,
&quot;selenium&quot; or &quot;rselenium&quot;.
</p>
</li>
<li> <p><code>selenider.browser</code> - The name of the browser to run the session in; one
of &quot;chrome&quot;, &quot;firefox&quot;, &quot;edge&quot;, &quot;safari&quot;, or another valid browser name.
</p>
</li></ul>


<hr>
<h2 id='take_screenshot'>Take a screenshot of the current page</h2><span id='topic+take_screenshot'></span>

<h3>Description</h3>

<p>Take a screenshot of the current session state, saving this image to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>take_screenshot(file = NULL, view = FALSE, session = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="take_screenshot_+3A_file">file</code></td>
<td>
<p>The file path to save the screenshot to.</p>
</td></tr>
<tr><td><code id="take_screenshot_+3A_view">view</code></td>
<td>
<p>Whether to open the interactively view the screenshot. If this is
<code>TRUE</code> and <code>file</code> is <code>NULL</code>, the screenshot will be deleted after viewing.</p>
</td></tr>
<tr><td><code id="take_screenshot_+3A_session">session</code></td>
<td>
<p>A <code>selenider_session</code> object. If not specified, the global
session object (the result of <code><a href="#topic+get_session">get_session()</a></code>) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>file</code>, if it is not <code>NULL</code>. Otherwise, the session object is returned, invisibly.
</p>


<h3>See Also</h3>

<p>Other global actions: 
<code><a href="#topic+back">back</a>()</code>,
<code><a href="#topic+current_url">current_url</a>()</code>,
<code><a href="#topic+execute_js_fn">execute_js_fn</a>()</code>,
<code><a href="#topic+get_page_source">get_page_source</a>()</code>,
<code><a href="#topic+open_url">open_url</a>()</code>,
<code><a href="#topic+reload">reload</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session &lt;- selenider_session()

open_url("https://www.google.com")

file_path &lt;- withr::local_tempfile(fileext = "png")

take_screenshot(file_path)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
