<!DOCTYPE html><html><head><title>Help for package LMMsolver</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LMMsolver}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LMMsolver'><p>Package LMMsolver</p></a></li>
<li><a href='#ADchol'><p>construct object for Automated Differentiation Cholesky decomposition</p></a></li>
<li><a href='#APSIMdat'><p>Simulated Biomass as function of time using APSIM wheat.</p></a></li>
<li><a href='#Bsplines'><p>Construct design matrix for B-Splines</p></a></li>
<li><a href='#calcStandardErrors'><p>Standard errors for predictions</p></a></li>
<li><a href='#coef.LMMsolve'><p>Coefficients from the mixed model equations of an LMMsolve object.</p></a></li>
<li><a href='#constructRinv'><p>Helper function for constructing Rinv</p></a></li>
<li><a href='#deviance.LMMsolve'><p>Deviance of an LMMsolve object</p></a></li>
<li><a href='#diagnosticsMME'><p>Give diagnostics for mixed model coefficient matrix C and the cholesky</p>
decomposition</a></li>
<li><a href='#displayMME'><p>Display the sparseness of the mixed model coefficient matrix</p></a></li>
<li><a href='#fitted.LMMsolve'><p>Fitted values of an LMMsolve object.</p></a></li>
<li><a href='#LMMsolve'><p>Solve Linear Mixed Models</p></a></li>
<li><a href='#LMMsolveObject'><p>Fitted LMMsolve Object</p></a></li>
<li><a href='#logLik.LMMsolve'><p>Log-likelihood of an LMMsolve object</p></a></li>
<li><a href='#multipop'><p>Simulated QTL mapping data set</p></a></li>
<li><a href='#obtainSmoothTrend'><p>Obtain Smooth Trend.</p></a></li>
<li><a href='#predictTest'><p>Test function for predict, for the moment internal</p></a></li>
<li><a href='#PsplinesKnots'><p>Construct equally placed knots</p></a></li>
<li><a href='#residuals.LMMsolve'><p>Residuals of an LMMsolve object.</p></a></li>
<li><a href='#RowKronecker'><p>Row-wise kronecker product</p></a></li>
<li><a href='#spl1D'><p>Fit P-splines</p></a></li>
<li><a href='#summary.LMMsolve'><p>Summarize Linear Mixed Model fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Mixed Model Solver</td>
</tr>
<tr>
<td>Description:</td>
<td>An efficient and flexible system to solve sparse mixed model
    equations. Important applications are the use of splines to model spatial or temporal
    trends as described in Boer (2023). (&lt;<a href="https://doi.org/10.1177%2F1471082X231178591">doi:10.1177/1471082X231178591</a>&gt;).</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-16</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>agridat, ggplot2, maps, Matrix, methods, Rcpp (&ge; 0.10.4), sf,
spam, splines</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://biometris.github.io/LMMsolver/index.html">https://biometris.github.io/LMMsolver/index.html</a>,
<a href="https://github.com/Biometris/LMMsolver/">https://github.com/Biometris/LMMsolver/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Biometris/LMMsolver/issues">https://github.com/Biometris/LMMsolver/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-16 13:44:48 UTC; rossu027</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Boer <a href="https://orcid.org/0000-0002-1879-4588"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bart-Jan van Rossum
    <a href="https://orcid.org/0000-0002-8673-2514"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bart-Jan van Rossum &lt;bart-jan.vanrossum@wur.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-16 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LMMsolver'>Package LMMsolver</h2><span id='topic+LMMsolver'></span><span id='topic+LMMsolver-package'></span>

<h3>Description</h3>

<p>Linear Mixed Model Solver using sparse matrix algebra.
</p>


<h3>Details</h3>

<p>An efficient and flexible system to solve sparse mixed model
equations, for models that are often used in statistical genetics.
Important applications are the use of splines to model spatial or temporal
trends. Another application area is mixed model QTL analysis for
multiparental populations, allowing for heterogeneous residual variance and
random design matrices with Identity-By-Descent (IBD) probabilities.
</p>


<h3>Author(s)</h3>

<p>Martin Boer <a href="mailto:martin.boer@wur.nl">martin.boer@wur.nl</a>
</p>
<p>Bart-Jan van Rossum <a href="mailto:bart-jan.vanrossum@wur.nl">bart-jan.vanrossum@wur.nl</a> (maintainer)
</p>


<h3>References</h3>

<p>Martin P. Boer (2023). <em>Tensor product P-splines using a sparse mixed model formulation</em>,
Statistical Modelling, 23, p. 465 - 479. <a href="https://doi.org/10.1177/1471082X231178591">doi:10.1177/1471082X231178591</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://biometris.github.io/LMMsolver/index.html">https://biometris.github.io/LMMsolver/index.html</a>
</p>
</li>
<li> <p><a href="https://github.com/Biometris/LMMsolver/">https://github.com/Biometris/LMMsolver/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Biometris/LMMsolver/issues">https://github.com/Biometris/LMMsolver/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ADchol'>construct object for Automated Differentiation Cholesky decomposition</h2><span id='topic+ADchol'></span>

<h3>Description</h3>

<p>Construct object for reverse Automated Differentiation of Cholesky decomposition,
with as input a list of semi-positive symmetric sparse matrices <code class="reqn">P_i</code>, each of
dimension <code class="reqn">q \times q</code>. The function <code>ADchol</code> calculates the matrix <code class="reqn">C</code>, the sum
the precision matrices <code class="reqn">P_i</code>: <code class="reqn">C = \sum_{i}  P_i</code>. Next, it calculates the Cholesky
Decomposition using the multiple minimum degree (MMD) algorithm
of the <code>spam</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADchol(lP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADchol_+3A_lp">lP</code></td>
<td>
<p>a list of symmetric matrices of class spam, each of dimension <code class="reqn">q \times q</code>,
and with sum of the matrices assumed to be positive definite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ADchol</code>. This object is used to calculate the partial
partial derivatives of <code class="reqn">log|C|</code> in an efficient way.
</p>


<h3>References</h3>

<p>Furrer, R., &amp; Sain, S. R. (2010). spam: A sparse matrix R package with emphasis
on MCMC methods for Gaussian Markov random fields.
Journal of Statistical Software, 36, 1-25.
</p>

<hr>
<h2 id='APSIMdat'>Simulated Biomass as function of time using APSIM wheat.</h2><span id='topic+APSIMdat'></span>

<h3>Description</h3>

<p>Simulated Biomass as function of time using APSIM wheat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APSIMdat
</code></pre>


<h3>Format</h3>

<p>A data.frame with 121 rows and 4 columns.
</p>

<dl>
<dt>env</dt><dd><p>Environment, Emerald in 1993</p>
</dd>
<dt>geno</dt><dd><p>Simulated genotype g001</p>
</dd>
<dt>das</dt><dd><p>Days after sowing</p>
</dd>
<dt>biomass</dt><dd><p>Simulated biomass using APSIM; medium measurement error added</p>
</dd>
</dl>



<h3>References</h3>

<p>Bustos-Korts et al. (2019) Combining Crop Growth Modeling and
Statistical Genetic Modeling to Evaluate Phenotyping Strategies
<a href="https://doi.org/10.3389/FPLS.2019.01491">doi:10.3389/FPLS.2019.01491</a>
</p>

<hr>
<h2 id='Bsplines'>Construct design matrix for B-Splines</h2><span id='topic+Bsplines'></span>

<h3>Description</h3>

<p>Construct design matrix for B-Splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bsplines(knots, x, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bsplines_+3A_knots">knots</code></td>
<td>
<p>A numerical vector of knot positions.</p>
</td></tr>
<tr><td><code id="Bsplines_+3A_x">x</code></td>
<td>
<p>a numeric vector of values at which to evaluate the B-spline
functions or derivatives.</p>
</td></tr>
<tr><td><code id="Bsplines_+3A_deriv">deriv</code></td>
<td>
<p>A numerical value. The derivative of the given order is
evaluated at the x positions.</p>
</td></tr>
</table>

<hr>
<h2 id='calcStandardErrors'>Standard errors for predictions</h2><span id='topic+calcStandardErrors'></span>

<h3>Description</h3>

<p>Calculates the standard errors for predictions <code class="reqn">D \hat{u}</code>,
see Welham et al. 2004 and Gilmour et al. 2004 for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcStandardErrors(C, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcStandardErrors_+3A_c">C</code></td>
<td>
<p>a symmetric matrix of class spam</p>
</td></tr>
<tr><td><code id="calcStandardErrors_+3A_d">D</code></td>
<td>
<p>a matrix of class spam</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction error variance is given by <code class="reqn">D C^{-1} D'</code>,
where <code class="reqn">C</code> is the mixed model coefficient matrix, and <code class="reqn">D</code> defines
linear combinations of fixed and random effects.
The standard errors are given by the the square root of
the diagonal. To calculate the standard errors in an efficient way we use that
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial log|C + \xi_i d_i d_i'|}{\partial \xi_i} |_{\xi_i=0}
 = trace(C^{-1} d_i d_i') =
trace(d_i' C^{-1} d_i) = d_i' C^{-1} d_i, </code>
</p>

<p>where <code class="reqn">d_i</code> is row <code class="reqn">i</code> of matrix <code class="reqn">D</code>. The values of
<code class="reqn">d_i' C^{-1} d_i</code> can be calculated more efficient, avoiding the
calculation of the inverse of <code class="reqn">C</code>, by using Automated Differentiation
of the Choleksy algorithm, see section 2.3 in Smith (1995) for details.
</p>


<h3>Value</h3>

<p>a vector with standard errors for predictions <code class="reqn">D \hat{u}</code>.
</p>


<h3>References</h3>

<p>Welham, S., Cullis, B., Gogel, B., Gilmour, A., &amp; Thompson, R. (2004).
Prediction in linear mixed models.
Australian &amp; New Zealand Journal of Statistics, 46(3), 325-347.
</p>
<p>Smith, S. P. (1995). Differentiation of the Cholesky algorithm.
Journal of Computational and Graphical Statistics, 4(2), 134-147.
</p>
<p>Gilmour, A., Cullis, B., Welham, S., Gogel, B., &amp; Thompson, R. (2004).
An efficient computing strategy for prediction in mixed linear models.
Computational statistics &amp; data analysis, 44(4), 571-586.
</p>

<hr>
<h2 id='coef.LMMsolve'>Coefficients from the mixed model equations of an LMMsolve object.</h2><span id='topic+coef.LMMsolve'></span>

<h3>Description</h3>

<p>Obtain the coefficients from the mixed model equations of an LMMsolve object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
coef(object, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.LMMsolve_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve</p>
</td></tr>
<tr><td><code id="coef.LMMsolve_+3A_se">se</code></td>
<td>
<p>calculate standard errors, default FALSE.</p>
</td></tr>
<tr><td><code id="coef.LMMsolve_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors, containing the estimated effects for each fixed
effect and the predictions for each random effect in the defined linear
mixed model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain coefficients.
coefs1 &lt;- coef(LMM1)

## Obtain coefficients with standard errors.
coefs2 &lt;- coef(LMM1, se = TRUE)

</code></pre>

<hr>
<h2 id='constructRinv'>Helper function for constructing Rinv</h2><span id='topic+constructRinv'></span>

<h3>Description</h3>

<p>Helper function for constructing Rinv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructRinv(df, residual, weights)
</code></pre>

<hr>
<h2 id='deviance.LMMsolve'>Deviance of an LMMsolve object</h2><span id='topic+deviance.LMMsolve'></span>

<h3>Description</h3>

<p>Obtain the deviance of a model fitted using LMMsolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
deviance(object, includeConstant = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.LMMsolve_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve</p>
</td></tr>
<tr><td><code id="deviance.LMMsolve_+3A_includeconstant">includeConstant</code></td>
<td>
<p>Should the constant in the restricted log-likelihood
be included. Default is <code>TRUE</code>, as for example in <code>lme4</code> and SAS.
In <code>asreml</code> the constant is omitted.</p>
</td></tr>
<tr><td><code id="deviance.LMMsolve_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deviance of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain deviance.
logLik(LMM1)

## Obtain deviance. without constant.
logLik(LMM1, includeConstant = FALSE)

</code></pre>

<hr>
<h2 id='diagnosticsMME'>Give diagnostics for mixed model coefficient matrix C and the cholesky
decomposition</h2><span id='topic+diagnosticsMME'></span>

<h3>Description</h3>

<p>Give diagnostics for mixed model coefficient matrix C and the cholesky
decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticsMME(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosticsMME_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the mixed model coefficient matrix and its choleski
decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain deviance.
diagnosticsMME(LMM1)

</code></pre>

<hr>
<h2 id='displayMME'>Display the sparseness of the mixed model coefficient matrix</h2><span id='topic+displayMME'></span>

<h3>Description</h3>

<p>Display the sparseness of the mixed model coefficient matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayMME(object, cholesky = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displayMME_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve.</p>
</td></tr>
<tr><td><code id="displayMME_+3A_cholesky">cholesky</code></td>
<td>
<p>Should the cholesky decomposition of the coefficient matrix
be plotted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the sparseness of the mixed model coefficient matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain deviance.
displayMME(LMM1)

</code></pre>

<hr>
<h2 id='fitted.LMMsolve'>Fitted values of an LMMsolve object.</h2><span id='topic+fitted.LMMsolve'></span>

<h3>Description</h3>

<p>Obtain the fitted values from a mixed model fitted using LMMSolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.LMMsolve_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve</p>
</td></tr>
<tr><td><code id="fitted.LMMsolve_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain fitted values.
fitted1 &lt;- fitted(LMM1)

</code></pre>

<hr>
<h2 id='LMMsolve'>Solve Linear Mixed Models</h2><span id='topic+LMMsolve'></span>

<h3>Description</h3>

<p>Solve Linear Mixed Models using REML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMMsolve(
  fixed,
  random = NULL,
  spline = NULL,
  group = NULL,
  ginverse = NULL,
  weights = NULL,
  data,
  residual = NULL,
  family = gaussian(),
  offset = 0,
  tolerance = 1e-06,
  trace = FALSE,
  maxit = 250,
  theta = NULL,
  grpTheta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMMsolve_+3A_fixed">fixed</code></td>
<td>
<p>A formula for the fixed part of the model. Should be of the
form &quot;response ~ pred&quot;</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_random">random</code></td>
<td>
<p>A formula for the random part of the model. Should be of the
form &quot;~ pred&quot;.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_spline">spline</code></td>
<td>
<p>A formula for the spline part of the model. Should be of the
form &quot;~ spl1D()&quot;, ~ spl2D()&quot; or &quot;~spl3D()&quot;.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_group">group</code></td>
<td>
<p>A named list where each component is a numeric vector
specifying contiguous fields in data that are to be considered as a
single term.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_ginverse">ginverse</code></td>
<td>
<p>A named list with each component a symmetric matrix, the
precision matrix of a corresponding random term in the model. The row and
column order of the precision matrices should match the order of the
levels of the corresponding factor in the data.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_weights">weights</code></td>
<td>
<p>A character string identifying the column
of data to use as relative weights in the fit. Default value NULL, weights are
all equal to one.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_data">data</code></td>
<td>
<p>A data.frame containing the modeling data.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_residual">residual</code></td>
<td>
<p>A formula for the residual part of the model. Should be of
the form &quot;~ pred&quot;.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_family">family</code></td>
<td>
<p>An object of class family specifying the distribution
and link function.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_offset">offset</code></td>
<td>
<p>An optional numerical vector containing an a priori
known component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_tolerance">tolerance</code></td>
<td>
<p>A numerical value. The convergence tolerance for the
modified Henderson algorithm to estimate the variance components.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_trace">trace</code></td>
<td>
<p>Should the progress of the algorithm be printed? Default
<code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_maxit">maxit</code></td>
<td>
<p>A numerical value. The maximum number of iterations for the
algorithm. Default <code>maxit = 250</code>.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_theta">theta</code></td>
<td>
<p>initial values for penalty or precision parameters. Default
<code>NULL</code>, all precision parameters set equal to 1.</p>
</td></tr>
<tr><td><code id="LMMsolve_+3A_grptheta">grpTheta</code></td>
<td>
<p>a vector to give components the same penalty. Default
<code>NULL</code>, all components have a separate penalty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Linear Mixed Model (LMM) has the form
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Z u + e, u ~ N(0,G), e ~ N(0,R)</code>
</p>
<p> where
<code class="reqn">y</code> is a vector of observations, <code class="reqn">\beta</code> is a vector with the fixed
effects, <code class="reqn">u</code> is a vector with the random effects, and <code class="reqn">e</code> a vector of
random residuals. <code class="reqn">X</code> and <code class="reqn">Z</code> are design matrices.
</p>
<p>LMMsolve can fit models where the matrices <code class="reqn">G^{-1}</code> and <code class="reqn">R^{-1}</code> are
a linear combination of precision matrices <code class="reqn">Q_{G,i}</code> and <code class="reqn">Q_{R,i}</code>:
</p>
<p style="text-align: center;"><code class="reqn">G^{-1} = \sum_{i} \psi_i Q_{G,i} \;, R^{-1} = \sum_{i} \phi_i Q_{R,i}</code>
</p>

<p>where the precision parameters <code class="reqn">\psi_i</code> and <code class="reqn">\phi_i</code> are estimated
using REML. For most standard mixed models <code class="reqn">1/{\psi_i}</code> are the variance
components and <code class="reqn">1/{\phi_i}</code> the residual variances. We use a formulation
in terms of precision parameters to allow for non-standard mixed models using
tensor product splines.
</p>


<h3>Value</h3>

<p>An object of class <code>LMMsolve</code> representing the fitted model.
See <code><a href="#topic+LMMsolveObject">LMMsolveObject</a></code> for a full description of the components in
this object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LMMsolveObject">LMMsolveObject</a></code>, <code><a href="#topic+spl1D">spl1D</a></code>,
<code><a href="#topic+spl2D">spl2D</a></code>, <code><a href="#topic+spl3D">spl3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit models on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Fit the same model with genotype as random effect.
LMM1_rand &lt;- LMMsolve(fixed = yield ~ rep,
                     random = ~gen,
                     data = john.alpha)

## Fit the model with a 1-dimensional spline at the plot level.
LMM1_spline &lt;- LMMsolve(fixed = yield ~ rep + gen,
                       spline = ~spl1D(x = plot, nseg = 20),
                       data = john.alpha)

## Fit models on multipop data included in the package.
data(multipop)

## The residual variances for the two populations can be different.
## Allow for heterogeneous residual variances using the residual argument.
LMM2 &lt;- LMMsolve(fixed = pheno ~ cross,
                residual = ~cross,
                data = multipop)

## QTL-probabilities are defined by the columns pA, pB, pC.
## They can be included in the random part of the model by specifying the
## group argument and using grp() in the random part.

# Define groups by specifying columns in data corresponding to groups in a list.
# Name used in grp() should match names specified in list.
lGrp &lt;- list(QTL = 3:5)
LMM2_group &lt;- LMMsolve(fixed = pheno ~ cross,
                      group = lGrp,
                      random = ~grp(QTL),
                      residual = ~cross,
                      data = multipop)

</code></pre>

<hr>
<h2 id='LMMsolveObject'>Fitted LMMsolve Object</h2><span id='topic+LMMsolveObject'></span>

<h3>Description</h3>

<p>An object of class <code>LMMsolve</code> returned by the LMMsolve function,
representing a fitted linear mixed model. Objects of this class have
methods for the generic functions coef, fitted, residuals, loglik and
deviance.
</p>


<h3>Value</h3>

<p>An object of class <code>LMMsolve</code> contains the following components:
</p>
<table>
<tr><td><code>logL</code></td>
<td>
<p>The restricted log-likelihood at convergence</p>
</td></tr>
<tr><td><code>sigma2e</code></td>
<td>
<p>The residual error</p>
</td></tr>
<tr><td><code>tau2e</code></td>
<td>
<p>The estimated variance components</p>
</td></tr>
<tr><td><code>EDdf</code></td>
<td>
<p>The effective dimensions</p>
</td></tr>
<tr><td><code>varPar</code></td>
<td>
<p>The number of variance parameters for each variance component</p>
</td></tr>
<tr><td><code>VarDf</code></td>
<td>
<p>The table with variance components</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The precision parameters</p>
</td></tr>
<tr><td><code>coefMME</code></td>
<td>
<p>A vector with all the estimated effects from mixed model equations</p>
</td></tr>
<tr><td><code>ndxCoefficients</code></td>
<td>
<p>The indices of the coefficients with the names</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>The fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals</p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>The number of iterations for the mixed model to converge</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Response variable</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix for the fixed part of the mixed model</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>The design matrix for the random part of the mixed model</p>
</td></tr>
<tr><td><code>lGinv</code></td>
<td>
<p>List with precision matrices for the random terms</p>
</td></tr>
<tr><td><code>lRinv</code></td>
<td>
<p>List with precision matrices for the residual</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The mixed model coefficient matrix after last iteration</p>
</td></tr>
<tr><td><code>cholC</code></td>
<td>
<p>The cholesky decomposition of coefficient matrix C</p>
</td></tr>
<tr><td><code>constantREML</code></td>
<td>
<p>The REML constant</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>The dimensions for each of the fixed and random terms in the
mixed model</p>
</td></tr>
<tr><td><code>term.labels.f</code></td>
<td>
<p>The names of the fixed terms in the mixed model</p>
</td></tr>
<tr><td><code>term.labels.r</code></td>
<td>
<p>The names of the random terms in the mixed model</p>
</td></tr>
<tr><td><code>splRes</code></td>
<td>
<p>An object with definition of spline argument</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>An object of class family specifying the distribution and link function</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>A data.frame with the convergence sequence for the log likelihood and effective dimensions</p>
</td></tr></table>
<p>.
</p>

<hr>
<h2 id='logLik.LMMsolve'>Log-likelihood of an LMMsolve object</h2><span id='topic+logLik.LMMsolve'></span>

<h3>Description</h3>

<p>Obtain the Restricted Maximum Log-Likelihood of a model fitted using
LMMsolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
logLik(object, includeConstant = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.LMMsolve_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve</p>
</td></tr>
<tr><td><code id="logLik.LMMsolve_+3A_includeconstant">includeConstant</code></td>
<td>
<p>Should the constant in the restricted log-likelihood
be included. Default is <code>TRUE</code>, as for example in <code>lme4</code> and SAS.
In <code>asreml</code> the constant is omitted.</p>
</td></tr>
<tr><td><code id="logLik.LMMsolve_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The restricted maximum log-likelihood of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain log-likelihood.
logLik(LMM1)

## Obtain log-likelihood without constant.
logLik(LMM1, includeConstant = FALSE)

</code></pre>

<hr>
<h2 id='multipop'>Simulated QTL mapping data set</h2><span id='topic+multipop'></span>

<h3>Description</h3>

<p>Simulated QTL mapping data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipop
</code></pre>


<h3>Format</h3>

<p>A data.frame with 180 rows and 6 columns.
</p>

<dl>
<dt>cross</dt><dd><p>Cross ID, two populations, AxB and AxC</p>
</dd>
<dt>ind</dt><dd><p>Genotype ID</p>
</dd>
<dt>pA</dt><dd><p>Probability that individual has alleles from parent A</p>
</dd>
<dt>pB</dt><dd><p>Probability that individual has alleles from parent B</p>
</dd>
<dt>pC</dt><dd><p>Probability that individual has alleles from parent C</p>
</dd>
<dt>pheno</dt><dd><p>Simulated phenotypic value</p>
</dd>
</dl>


<hr>
<h2 id='obtainSmoothTrend'>Obtain Smooth Trend.</h2><span id='topic+obtainSmoothTrend'></span>

<h3>Description</h3>

<p>Obtain the smooth trend for models fitted with a spline component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtainSmoothTrend(
  object,
  grid = NULL,
  newdata = NULL,
  deriv = 0,
  includeIntercept = FALSE,
  which = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtainSmoothTrend_+3A_object">object</code></td>
<td>
<p>An object of class LMMsolve.</p>
</td></tr>
<tr><td><code id="obtainSmoothTrend_+3A_grid">grid</code></td>
<td>
<p>A numeric vector having the length of the dimension of the fitted
spline component. This represents the number of grid points at which a
surface will be computed.</p>
</td></tr>
<tr><td><code id="obtainSmoothTrend_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame containing new points for which the smooth
trend should be computed. Column names should include the names used when
fitting the spline model.</p>
</td></tr>
<tr><td><code id="obtainSmoothTrend_+3A_deriv">deriv</code></td>
<td>
<p>Derivative of B-splines, default 0. At the moment only
implemented for spl1D.</p>
</td></tr>
<tr><td><code id="obtainSmoothTrend_+3A_includeintercept">includeIntercept</code></td>
<td>
<p>Should the value of the intercept be included in
the computed smooth trend? Ignored if deriv &gt; 0.</p>
</td></tr>
<tr><td><code id="obtainSmoothTrend_+3A_which">which</code></td>
<td>
<p>An integer, for if there are multiple splxD terms in the model.
Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with predictions for the smooth trend on the specified
grid. The standard errors are saved if 'deriv' has default value 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit a model with a 1-dimensional spline at the plot level.
LMM1_spline &lt;- LMMsolve(fixed = yield ~ rep + gen,
                       spline = ~spl1D(x = plot, nseg = 20),
                       data = john.alpha)

## Obtain the smooth trend for the fitted model on a dense grid.
smooth1 &lt;- obtainSmoothTrend(LMM1_spline,
                            grid = 100)

## Obtain the smooth trend on a new data set - plots 10 to 40.
newdat &lt;- data.frame(plot = 10:40)
smooth2 &lt;- obtainSmoothTrend(LMM1_spline,
                            newdata = newdat)

## The first derivative of the smooth trend can be obtained by setting deriv = 1.
smooth3 &lt;- obtainSmoothTrend(LMM1_spline,
                            grid = 100,
                            deriv = 1)

## For examples of higher order splines see the vignette.

</code></pre>

<hr>
<h2 id='predictTest'>Test function for predict, for the moment internal</h2><span id='topic+predictTest'></span>

<h3>Description</h3>

<p>Test function for predict, for the moment internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictTest(object, classify)
</code></pre>

<hr>
<h2 id='PsplinesKnots'>Construct equally placed knots</h2><span id='topic+PsplinesKnots'></span>

<h3>Description</h3>

<p>Construct equally placed knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PsplinesKnots(xmin, xmax, degree, nseg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PsplinesKnots_+3A_xmin">xmin</code></td>
<td>
<p>A numerical value.</p>
</td></tr>
<tr><td><code id="PsplinesKnots_+3A_xmax">xmax</code></td>
<td>
<p>A numerical value.</p>
</td></tr>
<tr><td><code id="PsplinesKnots_+3A_degree">degree</code></td>
<td>
<p>A numerical value.</p>
</td></tr>
<tr><td><code id="PsplinesKnots_+3A_nseg">nseg</code></td>
<td>
<p>A numerical value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of knot positions.
</p>

<hr>
<h2 id='residuals.LMMsolve'>Residuals of an LMMsolve object.</h2><span id='topic+residuals.LMMsolve'></span>

<h3>Description</h3>

<p>Obtain the residuals from a mixed model fitted using LMMSolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.LMMsolve_+3A_object">object</code></td>
<td>
<p>an object of class LMMsolve</p>
</td></tr>
<tr><td><code id="residuals.LMMsolve_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain fitted values.
residuals1 &lt;- residuals(LMM1)

</code></pre>

<hr>
<h2 id='RowKronecker'>Row-wise kronecker product</h2><span id='topic+RowKronecker'></span>

<h3>Description</h3>

<p>Row-wise kronecker product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RowKronecker(X1, X2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RowKronecker_+3A_x1">X1</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="RowKronecker_+3A_x2">X2</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row-wise kronecker product of X1 and X2.
</p>

<hr>
<h2 id='spl1D'>Fit P-splines</h2><span id='topic+spl1D'></span><span id='topic+spl2D'></span><span id='topic+spl3D'></span>

<h3>Description</h3>

<p>Fit multi dimensional P-splines using sparse implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl1D(
  x,
  nseg,
  pord = 2,
  degree = 3,
  scaleX = TRUE,
  xlim = range(x),
  cond = NULL,
  level = NULL
)

spl2D(
  x1,
  x2,
  nseg,
  pord = 2,
  degree = 3,
  scaleX = TRUE,
  x1lim = range(x1),
  x2lim = range(x2),
  cond = NULL,
  level = NULL
)

spl3D(
  x1,
  x2,
  x3,
  nseg,
  pord = 2,
  degree = 3,
  scaleX = TRUE,
  x1lim = range(x1),
  x2lim = range(x2),
  x3lim = range(x3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spl1D_+3A_x">x</code>, <code id="spl1D_+3A_x1">x1</code>, <code id="spl1D_+3A_x2">x2</code>, <code id="spl1D_+3A_x3">x3</code></td>
<td>
<p>The variables in the data containing the values of
the <code>x</code> covariates.</p>
</td></tr>
<tr><td><code id="spl1D_+3A_nseg">nseg</code></td>
<td>
<p>The number of segments</p>
</td></tr>
<tr><td><code id="spl1D_+3A_pord">pord</code></td>
<td>
<p>The order of penalty, default <code>pord = 2</code></p>
</td></tr>
<tr><td><code id="spl1D_+3A_degree">degree</code></td>
<td>
<p>The degree of B-spline basis, default <code>degree = 3</code></p>
</td></tr>
<tr><td><code id="spl1D_+3A_scalex">scaleX</code></td>
<td>
<p>Should the fixed effects be scaled.</p>
</td></tr>
<tr><td><code id="spl1D_+3A_xlim">xlim</code>, <code id="spl1D_+3A_x1lim">x1lim</code>, <code id="spl1D_+3A_x2lim">x2lim</code>, <code id="spl1D_+3A_x3lim">x3lim</code></td>
<td>
<p>A numerical vector of length 2 containing the
domain of the corresponding x covariate where the knots should be placed.
Default set to <code>NULL</code>, when the covariate range will be used.</p>
</td></tr>
<tr><td><code id="spl1D_+3A_cond">cond</code></td>
<td>
<p>Conditional factor: splines are defined conditional on the level.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="spl1D_+3A_level">level</code></td>
<td>
<p>The level of the conditional factor. Default <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>X</code> - design matrix for fixed effect. The intercept is not included.
</p>
</li>
<li> <p><code>Z</code> - design matrix for random effect.
</p>
</li>
<li> <p><code>lGinv</code> - a list of precision matrices
</p>
</li>
<li> <p><code>knots</code> - a list of vectors with knot positions
</p>
</li>
<li> <p><code>dim.f</code> - the dimensions of the fixed effect.
</p>
</li>
<li> <p><code>dim.r</code> - the dimensions of the random effect.
</p>
</li>
<li> <p><code>term.labels.f</code> - the labels for the fixed effect terms.
</p>
</li>
<li> <p><code>term.labels.r</code> - the labels for the random effect terms.
</p>
</li>
<li> <p><code>x</code> - a list of vectors for the spline variables.
</p>
</li>
<li> <p><code>pord</code> - the order of the penalty.
</p>
</li>
<li> <p><code>degree</code> - the degree of the B-spline basis.
</p>
</li>
<li> <p><code>scaleX</code> - logical indicating if the fixed effects are scaled.
</p>
</li>
<li> <p><code>EDnom</code> - the nominal effective dimensions.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>spl2D()</code>: 2-dimensional splines
</p>
</li>
<li> <p><code>spl3D()</code>: 3-dimensional splines
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+LMMsolve">LMMsolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit a model with a 1-dimensional spline at the plot level.
LMM1_spline &lt;- LMMsolve(fixed = yield ~ rep + gen,
                       spline = ~spl1D(x = plot, nseg = 20),
                       data = john.alpha)

summary(LMM1_spline)

## Fit model on US precipitation data from spam package.
data(USprecip, package = "spam")

## Only use observed data
USprecip &lt;- as.data.frame(USprecip)
USprecip &lt;- USprecip[USprecip$infill == 1, ]

## Fit a model with a 2-dimensional P-spline.
LMM2_spline &lt;- LMMsolve(fixed = anomaly ~ 1,
                       spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),
                       data = USprecip)

summary(LMM2_spline)

</code></pre>

<hr>
<h2 id='summary.LMMsolve'>Summarize Linear Mixed Model fits</h2><span id='topic+summary.LMMsolve'></span><span id='topic+print.summary.LMMsolve'></span>

<h3>Description</h3>

<p>Summary method for class &quot;LMMsolve&quot;. Creates either a table of effective
dimensions (which = &quot;dimensions&quot;) or a table of variances (which =
&quot;variances&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMMsolve'
summary(object, which = c("dimensions", "variances"), ...)

## S3 method for class 'summary.LMMsolve'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LMMsolve_+3A_object">object</code></td>
<td>
<p>An object of class LMMsolve</p>
</td></tr>
<tr><td><code id="summary.LMMsolve_+3A_which">which</code></td>
<td>
<p>A character string indicating which summary table should be
created.</p>
</td></tr>
<tr><td><code id="summary.LMMsolve_+3A_...">...</code></td>
<td>
<p>Some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
<tr><td><code id="summary.LMMsolve_+3A_x">x</code></td>
<td>
<p>An object of class summary.LMMsolve, the result of a call to
summary.LMM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with either effective dimensions or variances depending
on which.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(summary.LMMsolve)</code>: print summary
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model on john.alpha data from agridat package.
data(john.alpha, package = "agridat")

## Fit simple model with only fixed effects.
LMM1 &lt;- LMMsolve(fixed = yield ~ rep + gen,
                data = john.alpha)

## Obtain table of effective dimensions.
summ1 &lt;- summary(LMM1)
print(summ1)

## Obtain table of variances.
summ2 &lt;- summary(LMM1,
                which = "variances")
print(summ2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
