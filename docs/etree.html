<!DOCTYPE html><html lang="en"><head><title>Help for package etree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {etree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#etree-package'><p>etree: Classification and Regression With Structured and Mixed-Type Data</p></a></li>
<li><a href='#data_cls'><p>Classification toy dataset</p></a></li>
<li><a href='#data_reg'><p>Regression toy dataset</p></a></li>
<li><a href='#dist_comp'><p>Distances</p></a></li>
<li><a href='#eforest'><p>Energy Forests</p></a></li>
<li><a href='#etree'><p>Energy Tree</p></a></li>
<li><a href='#etree-methods'><p>Methods for &quot;etree&quot; objects</p></a></li>
<li><a href='#etree-size'><p>Size of Energy Trees</p></a></li>
<li><a href='#nodeapply'><p>Apply functions over nodes</p></a></li>
<li><a href='#nodeids'><p>Extract node identifiers.</p></a></li>
<li><a href='#plot.etree'><p>Visualization of Energy Trees</p></a></li>
<li><a href='#predict.eforest'><p>Predictions for Energy Forests</p></a></li>
<li><a href='#predict.etree'><p>Predictions for Energy Trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Classification and Regression with Structured and Mixed-Type
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Energy Trees, a statistical model to perform 
    classification and regression with structured and mixed-type data. The
    model has a similar structure to Conditional Trees, but brings in Energy
    Statistics to test independence between variables that are possibly 
    structured and of different nature. Currently, the package covers functions
    and graphs as structured covariates. It builds upon 'partykit' to
    provide functionalities for fitting, printing, plotting, and predicting with
    Energy Trees. Energy Trees are described in Giubilei et al. (2022) 
    &lt;<a href="https://doi.org/10.48550/arXiv.2207.04430">doi:10.48550/arXiv.2207.04430</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.7.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brainGraph, cluster, energy, fda.usc (&ge; 2.0.0), igraph,
NetworkDistance, parallel, partykit, survival, TDA, usedist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MLmetrics, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ricgbl/etree">https://github.com/ricgbl/etree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ricgbl/etree/issues">https://github.com/ricgbl/etree/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-15 09:53:19 UTC; ricca</td>
</tr>
<tr>
<td>Author:</td>
<td>Riccardo Giubilei <a href="https://orcid.org/0000-0002-1674-4886"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tullia Padellini [aut],
  Pierpaolo Brutti [aut],
  Marco Brandi [ctb],
  Gabriel Nespoli [ctb],
  Torsten Hothorn <a href="https://orcid.org/0000-0001-8301-0471"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] ((partykit author)),
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] ((partykit author))</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Riccardo Giubilei &lt;riccardogbl@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-16 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='etree-package'>etree: Classification and Regression With Structured and Mixed-Type Data</h2><span id='topic+etree-package'></span>

<h3>Description</h3>

<p>Implementation of Energy Trees, a statistical model to perform classification
and regression with structured and mixed-type data. The model has a similar
structure to Conditional Trees, but brings in Energy Statistics to test
independence between variables that are possibly structured and of different
nature. Currently, the package covers functions and graphs as structured
covariates. It builds upon 'partykit' to provide functionalities for fitting,
printing, plotting, and predicting with Energy Trees.
</p>

<hr>
<h2 id='data_cls'>Classification toy dataset</h2><span id='topic+data_cls'></span>

<h3>Description</h3>

<p>A simple dataset containing simulated values for a nominal response variable
and four covariates of both mixed and partially structured type. The data
generation process is based on Example 4.7 (&rdquo;Signal shape classification&rdquo;,
pages 73-77) from Saito (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_cls
</code></pre>


<h3>Format</h3>

<p>List with two elements: <code>covs</code>, which is a list containing the
covariates, and <code>resp</code>, which is a factor of length 150 representing
the response variable. The response variable is divided into three classes
whose labels are cylinder (<code>Cyl</code>), bell (<code>Bel</code>) and funnel
(<code>Fun</code>). The four covariates in <code>covs</code> all have length 150 and
are characterized as follows:
</p>

<ul>
<li><p> Nominal: <code>Cyl</code> observations are given level 1 with probability 0.8
and levels 2 and 3 with probability 0.1 each, <code>Bel</code> observations are
given level 2 with probability 0.8 and levels 1 and 3 with probability 0.1
each, <code>Fun</code> observations are given level 3 with probability 0.8 and
levels 1 and 2 with probability 0.1 each;
</p>
</li>
<li><p> Numeric: coefficients for one of the basis used to perform the
B-splines expansion of the curves that are in turn specified as in Saito
(1994);
</p>
</li>
<li><p> Functional: curves as specified in Saito (1994);
</p>
</li>
<li><p> Graphs: Erd\&quot;os-R\'enyi graphs with connection probability 0.10 for
<code>Cyl</code> observations, 0.125 for <code>Bel</code> observations, 0.15 for
<code>Fun</code> observations.
</p>
</li></ul>



<h3>References</h3>

<p>Saito, N. (1994). Local feature extraction and its applications using a
library of bases (Doctoral dissertation, Yale University).
</p>

<hr>
<h2 id='data_reg'>Regression toy dataset</h2><span id='topic+data_reg'></span>

<h3>Description</h3>

<p>A simple dataset containing simulated values for a numeric response variable
and four covariates of both mixed and partially structured type. The data
generation process is based on Section 5 (&rdquo;Example: synthetic data&rdquo;) from
Serban and Wasserman (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_reg
</code></pre>


<h3>Format</h3>

<p>List with two elements: <code>covs</code>, which is a list containing the
covariates, and <code>resp</code>, which is a numeric vector of length 200
representing the response variable. The response variable is specified as
in Serban and Wasserman (2005). The four covariates in <code>covs</code> all have
length 200 and are characterized as follows:
</p>

<ul>
<li><p> Nominal: level 0 for observations having negative response variable,
level 1 otherwise;
</p>
</li>
<li><p> Numeric: coefficients for one of the basis used to perform the
B-splines expansion of the curves that are in turn specified as in Serban and
Wasserman (2005);
</p>
</li>
<li><p> Functional: curves as specified in Serban and Wasserman (2005), with 50
observations coming from each of the four curve shapes;
</p>
</li>
<li><p> Graphs: Erd\&quot;os-R\'enyi graphs with connection probability given by
a transformation of the response variable obtained standardizing between 0.2
and 0.8 its value after adding a normally distributed noise with mean 0 and
standard deviation 7.
</p>
</li></ul>



<h3>References</h3>

<p>Serban, N., and Wasserman, L. (2005). CATS: clustering after transformation
and smoothing. <em>Journal of the American Statistical Association</em>,
100(471), 990-999.
</p>

<hr>
<h2 id='dist_comp'>Distances</h2><span id='topic+dist_comp'></span>

<h3>Description</h3>

<p>Compute pairwise distances starting from single objects containing the
original univariate observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_comp(x, lp = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_comp_+3A_x">x</code></td>
<td>
<p>Object containing the original univariate observations. Currently available
types and the form they need to have to be correctly recognized are the
following:
</p>

<ul>
<li><p> Logical: logical vectors;
</p>
</li>
<li><p> Numeric: numeric or integer vectors;
</p>
</li>
<li><p> Nominal: factors;
</p>
</li>
<li><p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li><p> Graphs: (lists of) objects of class <code>"igraph"</code>;
</p>
</li>
<li><p> Persistence diagrams: (lists of) objects with
<code>attributes(x)$names == "diagram"</code>.
</p>
</li></ul>

<p>See Details to find out which distance is used in each case.</p>
</td></tr>
<tr><td><code id="dist_comp_+3A_lp">lp</code></td>
<td>
<p>Integer specifying which norm should be used to compute the
distances for functional data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distances used in each case are the following:
</p>

<ul>
<li><p> Logical: Euclidean distance, implemented via <code><a href="stats.html#topic+dist">dist()</a></code>;
</p>
</li>
<li><p> Numeric: Euclidean distance, implemented via <code><a href="stats.html#topic+dist">dist()</a></code>;
</p>
</li>
<li><p> Nominal: Gower's distance, implemented via <code><a href="cluster.html#topic+daisy">daisy()</a></code>;
</p>
</li>
<li><p> Functions: <code class="reqn">L^{p}</code>-norm, implemented via
<code><a href="fda.usc.html#topic+metric.lp">metric.lp()</a></code> with default options;
</p>
</li>
<li><p> Graphs: Edge Difference distance (Hammond et al., 2013), implemented via
<code><a href="NetworkDistance.html#topic+nd.edd">nd.edd()</a></code>;
</p>
</li>
<li><p> Persistence diagrams: Wasserstein distance, implemented via
<code><a href="TDA.html#topic+wasserstein">wasserstein()</a></code> with default options;
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>"dist"</code> containing the pairwise distances.
</p>


<h3>References</h3>

<p>D. K. Hammond, Y. Gur, and C. R. Johnson (2013). Graph diffusion distance: A
difference measure for weighted graphs based on the graph laplacian
exponential kernel. In <em>2013 IEEE Global Conference on Signal and
Information Processing</em>, pages 419-422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Number of observations
nobs &lt;- 10

## Logical 
obj &lt;- as.logical(rbinom(nobs, 1, 0.5))
d &lt;- dist_comp(obj)

## Integer
obj &lt;- rpois(nobs, 5)
d &lt;- dist_comp(obj)

## Numeric
obj &lt;- rnorm(nobs)
d &lt;- dist_comp(obj)

## Factors
obj &lt;- factor(letters[1:nobs])
d &lt;- dist_comp(obj)

## Functional data
obj &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
d &lt;- dist_comp(obj)

## Graphs
obj &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
d &lt;- dist_comp(obj)

## Persistence diagrams
x &lt;- lapply(rep(100, nobs), function(np) TDA::circleUnif(np))
obj &lt;- lapply(x, TDA::ripsDiag, maxdimension = 1, maxscale = 3)
d &lt;- dist_comp(obj)

</code></pre>

<hr>
<h2 id='eforest'>Energy Forests</h2><span id='topic+eforest'></span>

<h3>Description</h3>

<p>Fits an Energy Forest, in the form of either a bagging of Energy Trees or a
Random Energy Forest, depending on the value of the <code>random_covs</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eforest(
  response,
  covariates,
  weights = NULL,
  ntrees = 100,
  ncores = 1L,
  minbucket = 1,
  alpha = 1,
  R = 500,
  split_type = "cluster",
  coeff_split_type = "test",
  p_adjust_method = "fdr",
  perf_metric = NULL,
  random_covs = "auto",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eforest_+3A_response">response</code></td>
<td>
<p>Response variable, an object of class either
<code>"factor"</code> or <code>"numeric"</code> (for classification and regression,
respectively).</p>
</td></tr>
<tr><td><code id="eforest_+3A_covariates">covariates</code></td>
<td>
<p>Set of covariates. Must be provided as a list, where
each element is a different variable. Currently available types and the
form they need to have to be correctly recognized are the following:
</p>

<ul>
<li><p> Numeric: numeric or integer vectors;
</p>
</li>
<li><p> Nominal: factors;
</p>
</li>
<li><p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li><p> Graphs: (lists of) objects of class <code>"igraph"</code>.
</p>
</li></ul>

<p>Each element (i.e., variable) in the covariates list must have the same
<code>length()</code>, which corresponds to the sample size.</p>
</td></tr>
<tr><td><code id="eforest_+3A_weights">weights</code></td>
<td>
<p>Optional vector of non-negative integer-valued weights to
be used in the fitting process. If not provided, all observations are
assumed to have weight equal to 1.</p>
</td></tr>
<tr><td><code id="eforest_+3A_ntrees">ntrees</code></td>
<td>
<p>Number of Energy Trees to grow, i.e., the number of
bootstrap samples to be generated and used for fitting.</p>
</td></tr>
<tr><td><code id="eforest_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use, i.e., at most how many child processes
will be run simultaneously. Must be exactly 1 on Windows (which uses the
master process). <code>ncores</code> corresponds to <code>mc.cores</code> in
<code><a href="parallel.html#topic+mclapply">mclapply()</a></code>, which is actually used to grow the single
Energy Trees in a parallel fashion.</p>
</td></tr>
<tr><td><code id="eforest_+3A_minbucket">minbucket</code></td>
<td>
<p>Positive integer specifying the minimum number of
observations that each terminal node must contain. Default is 5.</p>
</td></tr>
<tr><td><code id="eforest_+3A_alpha">alpha</code></td>
<td>
<p>Nominal level controlling the probability of type I error in the
Energy tests of independence used for variable selection. Default is 0.05.</p>
</td></tr>
<tr><td><code id="eforest_+3A_r">R</code></td>
<td>
<p>Number of replicates employed to approximate the sampling
distribution of the test statistic in every Energy test of independence.
Default is 1000.</p>
</td></tr>
<tr><td><code id="eforest_+3A_split_type">split_type</code></td>
<td>
<p>Splitting method used when the selected covariate is
structured. It has two possible values: <code>"coeff"</code> for feature vector
extraction, and <code>"cluster"</code> for clustering. See Details for further
information.</p>
</td></tr>
<tr><td><code id="eforest_+3A_coeff_split_type">coeff_split_type</code></td>
<td>
<p>Method to select the split point for the chosen
component when the selected covariate is structured and <code>split_type =
  "coeff"</code>. It has two possible values: <code>"test"</code>, in which case Energy
tests of independence are used, and <code>"traditional"</code>, to employ
traditional methods (Gini index for classification and RSS for regression).
See Details for further information.</p>
</td></tr>
<tr><td><code id="eforest_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>Multiple-testing adjustment method for P-values,
which can be set to any of the values provided by
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>. Default is <code>"fdr"</code> for False
Discovery Rate.</p>
</td></tr>
<tr><td><code id="eforest_+3A_perf_metric">perf_metric</code></td>
<td>
<p>Performance metric that is used to compute the Out-Of-Bag
score. If <code>NULL</code>, default choices are used: Balanced Accuracy for
classification and Root Mean Square Percentage Error for regression. See
Details for further information and possible alternatives.</p>
</td></tr>
<tr><td><code id="eforest_+3A_random_covs">random_covs</code></td>
<td>
<p>Size of the random subset of covariates to choose from at
each split. If set to <code>NULL</code>, all the covariates are considered each
time, resulting in a bagging of Energy Trees. When <code>random_covs</code> is an
integer greater than 1 and less than the total number of covariates, the
model is a Random Energy Forest. By default, it is equal to <code>"auto"</code>,
which implies the square root of the number of covariates for
classification, or one third of the number of covariates for regression (in
both cases, rounded down to the nearest integer).</p>
</td></tr>
<tr><td><code id="eforest_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print a one-line notification
for the conclusion of each tree's fitting process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eforest()</code> generates <code>ntrees</code> bootstrap samples and then calls
<code><a href="#topic+etree">etree()</a></code> on each of them. Then, it computes the Out-Of-Bag (OOB)
score using the performance metric defined through <code>perf_metric</code>.
</p>
<p>For classification, possible values of <code>perf_metric</code> are <code>"BAcc"</code>
and <code>"WBAcc"</code>. Both are general enough to be used in multiclass
classification problems, still producing sensible results in the case of
binary classification. The two options are based on the calculation of a
ground performance metric, the Balanced Accuracy, which is defined as the
arithmetic mean between Sensitivity and Specificity. In this framework,
Balanced Accuracy is computed using a &quot;One vs. All&quot; approach, i.e.,
considering one class at a time: positive instances are those belonging to
that class, and negatives are the ones belonging to any other class. Then,
the &quot;One vs. All&quot; Balanced Accuracies obtained by considering each class must
be averaged. When <code>perf_metric = "BAcc"</code> (default for classification
tasks), the average is arithmetic. When <code>perf_metric = "WBAcc"</code>, the
average is weighted using class sizes, hence giving more importance to the
&quot;One vs. All&quot; Balanced Accuracy of larger classes.
</p>
<p>For regression, the default value of <code>perf_metric</code> is <code>"RMSPE"</code>,
namely, Root Mean Square Percentage Error. Other available options are
<code>c("MAE", "MAPE", "MedianAE", "MedianAPE", "MSE", "NRMSE", "RAE",
"RMSE", "RMLSE")</code>. Each of these name points to the corresponding homonym
function from the package <code><a href="MLmetrics.html#topic+MLmetrics">MLmetrics</a></code>, whose
documentation provides more information about their definition.
</p>


<h3>Value</h3>

<p>Object of class <code>"eforest"</code> with three elements: 1) <code>ensemble</code>,
which is a list gathering all the fitted trees; 2) <code>oob_score</code>,
an object of class <code>"numeric"</code> representing the OOB score computed using
the performance metric defined through <code>perf_metric</code>; 3)
<code>perf_metric</code>, an object of class <code>"character"</code> returning the
performance metric used for computations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Covariates
set.seed(123)
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable(s)
resp_reg &lt;- cov_num ^ 2
y &lt;- round((cov_num - min(cov_num)) / (max(cov_num) - min(cov_num)), 0)
resp_cls &lt;- factor(y)

## Regression ##
eforest_fit &lt;- eforest(response = resp_reg, covariates = cov_list, ntrees = 12)
print(eforest_fit$ensemble[[1]])
plot(eforest_fit$ensemble[[1]])
mean((resp_reg - predict(eforest_fit)) ^ 2)

## Classification ##
eforest_fit &lt;- eforest(response = resp_cls, covariates = cov_list, ntrees = 12)
print(eforest_fit$ensemble[[12]])
plot(eforest_fit$ensemble[[12]])
table(resp_cls, predict(eforest_fit))


</code></pre>

<hr>
<h2 id='etree'>Energy Tree</h2><span id='topic+etree'></span>

<h3>Description</h3>

<p>Fits an Energy Tree for classification or regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etree(
  response,
  covariates,
  weights = NULL,
  minbucket = 5,
  alpha = 0.05,
  R = 1000,
  split_type = "coeff",
  coeff_split_type = "test",
  p_adjust_method = "fdr",
  random_covs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etree_+3A_response">response</code></td>
<td>
<p>Response variable, an object of class either
<code>"factor"</code> or <code>"numeric"</code> (for classification and regression,
respectively).</p>
</td></tr>
<tr><td><code id="etree_+3A_covariates">covariates</code></td>
<td>
<p>Set of covariates. Must be provided as a list, where
each element is a different variable. Currently available types and the
form they need to have to be correctly recognized are the following:
</p>

<ul>
<li><p> Numeric: numeric or integer vectors;
</p>
</li>
<li><p> Nominal: factors;
</p>
</li>
<li><p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li><p> Graphs: (lists of) objects of class <code>"igraph"</code>.
</p>
</li></ul>

<p>Each element (i.e., variable) in the covariates list must have the same
<code>length()</code>, which corresponds to the sample size.</p>
</td></tr>
<tr><td><code id="etree_+3A_weights">weights</code></td>
<td>
<p>Optional vector of non-negative integer-valued weights to
be used in the fitting process. If not provided, all observations are
assumed to have weight equal to 1.</p>
</td></tr>
<tr><td><code id="etree_+3A_minbucket">minbucket</code></td>
<td>
<p>Positive integer specifying the minimum number of
observations that each terminal node must contain. Default is 5.</p>
</td></tr>
<tr><td><code id="etree_+3A_alpha">alpha</code></td>
<td>
<p>Nominal level controlling the probability of type I error in the
Energy tests of independence used for variable selection. Default is 0.05.</p>
</td></tr>
<tr><td><code id="etree_+3A_r">R</code></td>
<td>
<p>Number of replicates employed to approximate the sampling
distribution of the test statistic in every Energy test of independence.
Default is 1000.</p>
</td></tr>
<tr><td><code id="etree_+3A_split_type">split_type</code></td>
<td>
<p>Splitting method used when the selected covariate is
structured. It has two possible values: <code>"coeff"</code> for feature vector
extraction, and <code>"cluster"</code> for clustering. See Details for further
information.</p>
</td></tr>
<tr><td><code id="etree_+3A_coeff_split_type">coeff_split_type</code></td>
<td>
<p>Method to select the split point for the chosen
component when the selected covariate is structured and <code>split_type =
  "coeff"</code>. It has two possible values: <code>"test"</code>, in which case Energy
tests of independence are used, and <code>"traditional"</code>, to employ
traditional methods (Gini index for classification and RSS for regression).
See Details for further information.</p>
</td></tr>
<tr><td><code id="etree_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>Multiple-testing adjustment method for P-values,
which can be set to any of the values provided by
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>. Default is <code>"fdr"</code> for False
Discovery Rate.</p>
</td></tr>
<tr><td><code id="etree_+3A_random_covs">random_covs</code></td>
<td>
<p>Size of the random subset of covariates to choose from
at each split. If set to <code>NULL</code> (default), all the covariates are
considered each time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>etree()</code> is the main function of the homonym package. It allows
implementing Energy Trees by simply specifying the response variable, the set
of covariates, and possibly some other parameters. The function is specified
in the same way regardless of the task type: the choice between
classification and regression is automatically made depending on the nature
of the response variable.
</p>
<p>Energy Trees (Giubilei et al., 2022) are a recursive partitioning tree-based
model built upon
Conditional Trees (Hothorn et al., 2006). At each step of Energy Trees'
iterative procedure, an Energy test of independence (Szekely et al., 2007) is
performed between the response variable and each of the J covariates. If the
test of global independence (defined as the intersection of the J tests of
partial independence) is not rejected at the significance level set by
<code>alpha</code>, the recursion is stopped; otherwise, the covariate most
associated with the response in terms of P-value is selected for splitting.
When the covariate is traditional (i.e, numeric or nominal), an Energy test
of independence is performed for each possible split point, and the one
yielding the strongest association with the response is chosen. When the
selected covariate is structured, the split procedure is defined by the value
of <code>split_type</code>, and possibly by that of <code>coeff_split_type</code>.
</p>
<p><code>split_type</code> specifies the splitting method for structured covariates.
It has two possible values:
</p>

<ul>
<li> <p><code>"coeff"</code>: in this case, feature vector extraction is used to
transform the structured selected covariate into a set of numeric components
using a representation that is specific to its type. Available
transformations of such a kind are cubic B-spline expansions for functional
data and shell distributions (Carmi et al., 2007) for graphs - obtained
through k-cores (Seidman, 1983), s-cores (Eidsaa and Almaas, 2013), and
d-cores (Giatsidis et al., 2013), for binary, weighted, and directed graphs,
respectively. Then, the component most associated with the response is
selected using Energy tests of independence (Szekely et al., 2007), and the
split point for that component is chosen using the method defined by
<code>coeff_split_type</code>;
</p>
</li>
<li> <p><code>"cluster"</code>: in this case, the observed values for the structured
selected covariate are used within a Partitioning Around Medoids (Kaufmann
and Rousseeuw, 1987) step to split observations into the two kid nodes.
Medoids calculation and units assignment are performed using
<code><a href="cluster.html#topic+pam">pam()</a></code>. Distances are specific to each type of
variable (see <code><a href="#topic+dist_comp">dist_comp()</a></code> for details).
</p>
</li></ul>

<p><code>coeff_split_type</code> defines the method to select the split point for the
chosen component of the selected structured covariate if and only if
<code>split_type = "coeff"</code>. It has two possible values:
</p>

<ul>
<li> <p><code>"test"</code>: an Energy test of independence (Szekely et al., 2007) is
performed for each possible split point of the chosen component, and the one
yielding the strongest association with the response is selected;
</p>
</li>
<li> <p><code>"traditional"</code>: the split point for the chosen component is
selected as the one minimizing the Gini index (for classification) or the RSS
(for regression) in the two kid nodes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"etree"</code>, <code>"constparty"</code>, and <code>"party"</code>.
It stores all the information about the fitted tree. Its elements can be
individually accessed using the <code>$</code> operator. Their names and content
are the following:
</p>

<ul>
<li> <p><code>node</code>: a <code><a href="partykit.html#topic+partynode">partynode</a></code> object representing
the basic structure of the tree;
</p>
</li>
<li> <p><code>data</code>: a <code>list</code> containing the data used for the fitting
process. Traditional covariates are included in their original form, while
structured covariates are stored in the form of components if
<code>split_type = "coeff"</code> or as a <code>factor</code> whose levels go from 1 to
the total number of observations if <code>split_type = "cluster"</code>;
</p>
</li>
<li> <p><code>fitted</code>: a <code>data.frame</code> whose number of rows coincides with
the sample size. It includes the fitted terminal node identifiers (in
<code>"(fitted)"</code>) and the response values of all observations (in
<code>"(response)"</code>);
</p>
</li>
<li> <p><code>terms</code>: a <code><a href="stats.html#topic+terms">terms</a></code> object;
</p>
</li>
<li> <p><code>names</code> (optional): names of the nodes in the tree. They can be
set using a <code>character</code> vector: if its length is smaller than the number
of nodes, the remaining nodes have missing names; if its length is larger,
exceeding names are ignored.
</p>
</li></ul>



<h3>References</h3>

<p>R. Giubilei, T. Padellini, P. Brutti (2022). Energy Trees: Regression and
Classification With Structured and Mixed-Type Covariates. arXiv preprint.
https://arxiv.org/pdf/2207.04430.pdf.
</p>
<p>S. Carmi, S. Havlin, S. Kirkpatrick, Y. Shavitt, and E. Shir (2007). A model
of internet topology using k-shell decomposition. <em>Proceedings of the
National Academy of Sciences</em>, 104(27):11150-11154.
</p>
<p>M. Eidsaa and E. Almaas (2013). S-core network decomposition: A
generalization of k-core analysis to weighted networks. <em>Physical Review
E</em>, 88(6):062819.
</p>
<p>C. Giatsidis, D. M. Thilikos, and M. Vazirgiannis (2013). D-cores: measuring
collaboration of directed graphs based on degeneracy. <em>Knowledge and
information systems</em>, 35(2):311-343.
</p>
<p>T. Hothorn, K. Hornik, and A. Zeileis (2006). Unbiased recursive
partitioning: A conditional inference framework. <em>Journal of
Computational and Graphical Statistics</em>, 15(3):651-674.
</p>
<p>L. Kaufmann and P. Rousseeuw (1987). Clustering by means of medoids.
<em>Data Analysis based on the L1-Norm and Related Methods</em>, pages 405-416.
</p>
<p>S. B. Seidman (1983). Network structure and minimum degree. <em>Social
networks</em>, 5(3):269-287.
</p>
<p>G. J. Szekely, M. L. Rizzo, and N. K. Bakirov (2007). Measuring and testing
dependence by correlation of distances. <em>The Annals of Statistics</em>,
35(6):2769-2794.
</p>


<h3>See Also</h3>

<p><code><a href="partykit.html#topic+ctree">ctree()</a></code> for the <code>partykit</code> implementation of
Conditional Trees (Hothorn et al., 2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Covariates
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable(s)
resp_reg &lt;- cov_num ^ 2
y &lt;- round((cov_num - min(cov_num)) / (max(cov_num) - min(cov_num)), 0)
resp_cls &lt;- factor(y)

## Regression ##
etree_fit &lt;- etree(response = resp_reg, covariates = cov_list)
print(etree_fit)
plot(etree_fit)
mean((resp_reg - predict(etree_fit)) ^ 2)

## Classification ##
etree_fit &lt;- etree(response = resp_cls, covariates = cov_list)
print(etree_fit)
plot(etree_fit)
table(resp_cls, predict(etree_fit))


</code></pre>

<hr>
<h2 id='etree-methods'>Methods for &quot;etree&quot; objects</h2><span id='topic+etree-methods'></span><span id='topic+print.etree'></span><span id='topic+length.etree'></span><span id='topic+depth.etree'></span><span id='topic+width.etree'></span><span id='topic++22+5B.etree+22'></span><span id='topic++22+5B+5B.etree+22'></span><span id='topic+length.party'></span><span id='topic+depth.party'></span><span id='topic+width.party'></span><span id='topic++5B.etree'></span><span id='topic++5B+5B.etree'></span>

<h3>Description</h3>

<p>Methods for objects of class <code>"etree"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'etree'
print(
  x,
  FUN = NULL,
  digits = getOption("digits") - 4,
  header = NULL,
  footer = TRUE,
  ...
)

## S3 method for class 'etree'
length(x)

## S3 method for class 'etree'
depth(x, root = FALSE, ...)

## S3 method for class 'etree'
width(x, ...)

## S3 method for class 'etree'
x[i, ...]

## S3 method for class 'etree'
x[[i, ...]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etree-methods_+3A_x">x</code></td>
<td>
<p>Object of class <code>"etree"</code>.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to nodes.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be printed.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_header">header</code></td>
<td>
<p>Header to be printed.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_footer">footer</code></td>
<td>
<p>Footer to be printed.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_root">root</code></td>
<td>
<p>Logical indicating whether the root node should be counted in
<code>depth()</code> or not (default).</p>
</td></tr>
<tr><td><code id="etree-methods_+3A_i">i</code></td>
<td>
<p>Integer specifying the root of the subtree to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>print()</code> method generates a textual representation of the tree.
<code>length()</code> returns the number of nodes in the tree, <code>depth()</code> the
depth of the tree and <code>width()</code> the number of terminal nodes. The subset
methods extract subtrees starting from a given node.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print.etree</code>: Generates textual representation of the tree.
</p>
</li>
<li> <p><code>length.party</code>: Number of nodes in the tree.
</p>
</li>
<li> <p><code>depth.party</code>: Depth of the three.
</p>
</li>
<li> <p><code>width.party</code>: Number of terminal nodes.
</p>
</li>
<li> <p><code>[.etree</code>: Extract subtrees.
</p>
</li>
<li> <p><code>[[.etree</code>: Extract subtrees.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>


## Covariates
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable
resp_reg &lt;- cov_num ^ 2

## Fit
etree_fit &lt;- etree(response = resp_reg, covariates = cov_list)

## Print
print(etree_fit)

## Number of nodes in the tree
length(etree_fit)

## Depth of the tree
depth(etree_fit)

## Number of terminal nodes in the tree
width(etree_fit)

## Extract subtrees
etree_fit[2]
etree_fit[[2]]



</code></pre>

<hr>
<h2 id='etree-size'>Size of Energy Trees</h2><span id='topic+etree-size'></span><span id='topic+depth'></span><span id='topic+width'></span>

<h3>Description</h3>

<p>Depth and width of an Energy Tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(x, ...)

width(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etree-size_+3A_x">x</code></td>
<td>
<p>An object of class <code>etree</code>.</p>
</td></tr>
<tr><td><code id="etree-size_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>depth()</code> returns the depth of the tree and <code>width()</code> gives the
number of terminal nodes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>depth</code>: Depth of the three.
</p>
</li>
<li> <p><code>width</code>: Number of terminal nodes in the tree.
</p>
</li></ul>

<hr>
<h2 id='nodeapply'>Apply functions over nodes</h2><span id='topic+nodeapply'></span><span id='topic+nodeapply.partynode'></span><span id='topic+nodeapply.etree'></span><span id='topic+nodeapply.party'></span>

<h3>Description</h3>

<p>Returns a list of values obtained by applying a function to <code>"etree"</code> or
<code>"partynode"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeapply(obj, ids = 1, FUN = NULL, ...)

## S3 method for class 'partynode'
nodeapply(obj, ids = 1, FUN = NULL, ...)

## S3 method for class 'etree'
nodeapply(obj, ids = 1, FUN = NULL, by_node = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeapply_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>"etree"</code> or <code>"partynode"</code>.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_ids">ids</code></td>
<td>
<p>Integer vector of node identifiers to apply over.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to nodes. By default, the node itself is
returned.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_by_node">by_node</code></td>
<td>
<p>Logical indicating whether FUN should be applied to subsets of
<code>"partynode"</code> objects (default) or not, in which case it is applied to
subsets of <code>"etree"</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code>"partynode"</code> objects apply function <code>FUN</code> to all
nodes with node identifiers in <code>ids</code>. The method for <code>"etree"</code>
objects by default calls the <code>nodeapply</code> method on the corresponding
node slot. If <code>by_node</code> is <code>FALSE</code>, it is applied to the
<code>"etree"</code> object with root node <code>ids</code>.
</p>


<h3>Value</h3>

<p>A list of results whose length is given by <code>length(ids)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>partynode</code>: nodeapply() method for objects of class &quot;partynode&quot;.
</p>
</li>
<li> <p><code>etree</code>: nodeapply() method for objects of class &quot;etree&quot;.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>


## Covariates
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable
resp_reg &lt;- cov_num ^ 2

## Fit
etree_fit &lt;- etree(response = resp_reg, covariates = cov_list)

## Get pvalues of inner nodes
tnodes &lt;- nodeids(etree_fit, terminal = TRUE)
nodes &lt;- 1:max(tnodes)
inodes &lt;- nodes[-tnodes]
nodeapply(etree_fit, ids = inodes, FUN = function(n) n$info$pvalue)

</code></pre>

<hr>
<h2 id='nodeids'>Extract node identifiers.</h2><span id='topic+nodeids'></span><span id='topic+nodeids.partynode'></span><span id='topic+nodeids.etree'></span><span id='topic+nodeids.party'></span>

<h3>Description</h3>

<p>Extract unique identifiers from inner and terminals nodes of <code>"etree"</code>
or <code>"partynode"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeids(obj, ...)

## S3 method for class 'partynode'
nodeids(obj, from = NULL, terminal = FALSE, ...)

## S3 method for class 'etree'
nodeids(obj, from = NULL, terminal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeids_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>"etree"</code> or <code>"partynode"</code>.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_from">from</code></td>
<td>
<p>Integer specifying the node to start from.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_terminal">terminal</code></td>
<td>
<p>Logical indicating whether only identifiers of terminal nodes
should be returned (<code>FALSE</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of node identifiers.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>partynode</code>: nodeids() method for objects of class &quot;partynode&quot;.
</p>
</li>
<li> <p><code>etree</code>: nodeids() method for objects of class &quot;etree&quot;.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>


## Covariates
nobs &lt;- 100
cov_num &lt;- rnorm(nobs)
cov_nom &lt;- factor(rbinom(nobs, size = 1, prob = 0.5))
cov_gph &lt;- lapply(1:nobs, function(j) igraph::sample_gnp(100, 0.2))
cov_fun &lt;- fda.usc::rproc2fdata(nobs, seq(0, 1, len = 100), sigma = 1)
cov_list &lt;- list(cov_num, cov_nom, cov_gph, cov_fun)

## Response variable
resp_reg &lt;- cov_num ^ 2

## Fit
etree_fit &lt;- etree(response = resp_reg, covariates = cov_list)

## Get all nodes identifiers
nodes_ids &lt;- nodeids(etree_fit)

## Get terminal nodes identifiers
tnodes_ids &lt;- nodeids(etree_fit, terminal = TRUE)

## Get all nodes identifiers starting from 2
nodes_ids2 &lt;- nodeids(etree_fit, from = 2)

</code></pre>

<hr>
<h2 id='plot.etree'>Visualization of Energy Trees</h2><span id='topic+plot.etree'></span>

<h3>Description</h3>

<p>Returns the plot of an object of class <code>"etree"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'etree'
plot(
  x,
  main = NULL,
  terminal_panel = NULL,
  tp_args = list(),
  inner_panel = node_inner,
  ip_args = list(),
  edge_panel = edge_simple,
  ep_args = list(),
  type = c("extended", "simple"),
  drop_terminal = NULL,
  tnex = NULL,
  newpage = TRUE,
  pop = TRUE,
  gp = gpar(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.etree_+3A_x">x</code></td>
<td>
<p>An object of class <code>"etree"</code>, i.e., a fitted Energy Tree.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_main">main</code></td>
<td>
<p>Optional title for the plot.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_terminal_panel">terminal_panel</code></td>
<td>
<p>Optional panel function of the form
<code>function(node)</code> plotting the terminal nodes. Alternatively, a panel
generating function of class <code>"grapcon_generator"</code> that is called with
arguments <code>x</code> and <code>tp_args</code> to set up a panel function. By
default, an appropriate panel function is chosen depending on the scale of
the dependent variable.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_tp_args">tp_args</code></td>
<td>
<p>List of arguments passed to <code>terminal_panel</code> if this is
a <code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_inner_panel">inner_panel</code></td>
<td>
<p>Optional panel function of the form
<code>function(node)</code> plotting the inner nodes. Alternatively, a panel
generating function of class <code>"grapcon_generator"</code> that is called with
arguments <code>x</code> and <code>ip_args</code> to set up a panel function.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_ip_args">ip_args</code></td>
<td>
<p>List of arguments passed to <code>inner_panel</code> if this is a
<code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_edge_panel">edge_panel</code></td>
<td>
<p>Optional panel function of the form
<code>function(split, ordered = FALSE, left = TRUE)</code> plotting the edges.
Alternatively, a panel generating function of class
<code>"grapcon_generator"</code> that is called with arguments <code>x</code> and
<code>ep_args</code> to set up a panel function.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_ep_args">ep_args</code></td>
<td>
<p>List of arguments passed to <code>edge_panel</code> if this is a
<code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_type">type</code></td>
<td>
<p>Character specifying the complexity of the plot:
<code>extended</code> tries to visualize the distribution of the response
variable in each terminal node whereas <code>simple</code> only gives some
summary information.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_drop_terminal">drop_terminal</code></td>
<td>
<p>Logical indicating whether all terminal nodes should
be plotted at the bottom.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_tnex">tnex</code></td>
<td>
<p>Numeric value giving the terminal node extension in relation to
the inner nodes.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_newpage">newpage</code></td>
<td>
<p>Logical indicating whether <code>grid.newpage()</code> should be
called.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_pop">pop</code></td>
<td>
<p>Logical indicating whether the viewport tree should be popped before
return.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="plot.etree_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot()</code> method for <code>"etree"</code> objects allows for the
visualization of fitted Energy Trees,  as returned by
<code><a href="#topic+etree">etree()</a></code> or as contained in the <code>ensemble</code>
element of a fitted Random Energy Forest.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (plotting the tree).
</p>

<hr>
<h2 id='predict.eforest'>Predictions for Energy Forests</h2><span id='topic+predict.eforest'></span>

<h3>Description</h3>

<p>Compute predictions for objects of class <code>"eforest"</code> (i.e., as returned
by <code><a href="#topic+eforest">eforest()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eforest'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.eforest_+3A_object">object</code></td>
<td>
<p>A fitted Energy Forest of class <code>"eforest"</code>.</p>
</td></tr>
<tr><td><code id="predict.eforest_+3A_newdata">newdata</code></td>
<td>
<p>Optional set of new covariates used to make predictions. Must
be provided as a list, where each element is a different variable.
Currently available types and the form they need to have to be correctly
recognized are the following:
</p>

<ul>
<li><p> Numeric: numeric or integer vectors;
</p>
</li>
<li><p> Nominal: factors;
</p>
</li>
<li><p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li><p> Graphs: (lists of) objects of class <code>"igraph"</code>.
</p>
</li></ul>

<p>Each element (i.e., variable) in the covariates list must have the same
<code>length()</code>, which corresponds to the (new) sample size. If
<code>newdata</code> is omitted, fitted values of individual trees are somehow
combined (see Details) and returned.</p>
</td></tr>
<tr><td><code id="predict.eforest_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict()</code> method for <code>"eforest"</code> objects computes predictions
for Energy Forests as returned by <code><a href="#topic+eforest">eforest()</a></code>.
Predictions are based either on the fitted values (if <code>newdata</code> is
<code>NULL</code>) or on the new set of covariates (when <code>newdata</code> is
provided). In both cases, each tree in <code>object$ensemble</code> is used to make
predictions by calling <code><a href="#topic+predict.etree">predict()</a></code> on it
(with the same specification of <code>newdata</code>). Then, individual trees'
predictions for any single observation are combined by majority voting rule
for classification or by arithmetic mean for regression.
</p>


<h3>Value</h3>

<p>Predictions, in the form of a factor for classification or as a numeric
vector for regression.
</p>

<hr>
<h2 id='predict.etree'>Predictions for Energy Trees</h2><span id='topic+predict.etree'></span>

<h3>Description</h3>

<p>Compute predictions for objects of class <code>"etree"</code> (i.e., fitted Energy
Trees as returned by <code><a href="#topic+etree">etree()</a></code>, or as contained in
the <code>ensemble</code> element of a fitted Random Energy Forest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'etree'
predict(object, newdata = NULL, perm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.etree_+3A_object">object</code></td>
<td>
<p>A fitted Energy Tree of class <code>"etree"</code>.</p>
</td></tr>
<tr><td><code id="predict.etree_+3A_newdata">newdata</code></td>
<td>
<p>Optional set of new covariates used to make predictions.
Must be provided as a list, where each element is a different variable.
Currently available types and the form they need to have to be correctly
recognized are the following:
</p>

<ul>
<li><p> Numeric: numeric or integer vectors;
</p>
</li>
<li><p> Nominal: factors;
</p>
</li>
<li><p> Functions: objects of class <code>"fdata"</code>;
</p>
</li>
<li><p> Graphs: (lists of) objects of class <code>"igraph"</code>.
</p>
</li></ul>

<p>Each element (i.e., variable) in the covariates list must have the same
<code>length()</code>, which corresponds to the (new) sample size. If
<code>newdata</code> is omitted, fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.etree_+3A_perm">perm</code></td>
<td>
<p>Optional character vector of variable names. Splits of nodes
with a primary split in any of these variables will be permuted (after
dealing with surrogates). Note that surrogate split in the <code>perm</code>
variables will not be permuted.</p>
</td></tr>
<tr><td><code id="predict.etree_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict()</code> method for <code>"etree"</code> objects yields predictions for
fitted Energy Trees as returned by <code><a href="#topic+etree">etree()</a></code> or as
contained in the <code>ensemble</code> element of a fitted Random Energy Forest.
Predictions are based either on fitted values (if <code>newdata</code> is
<code>NULL</code>) or on the new set of covariates (if <code>newdata</code> is provided).
The values of <code>split_type</code> and <code>coeff_split_type</code>, as well as the
number of components for each structured covariate (needed to compute an
equivalent representation for the covariates in <code>newdata</code> when
<code>split_type = "coeff"</code>), are automatically retrieved from the object of
class <code>"etree"</code>.
</p>


<h3>Value</h3>

<p>Predictions, in the form of a factor for classification or as a numeric
vector for regression.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
