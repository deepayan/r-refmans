<!DOCTYPE html><html lang="en-US"><head><title>Help for package WhiteLabRt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WhiteLabRt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WhiteLabRt-package'><p>The 'WhiteLabRt' package.</p></a></li>
<li><a href='#convert_to_linelist'><p>Convert Case Counts to a Line List</p></a></li>
<li><a href='#create_caseCounts'><p>Create a Case Counts Data Frame</p></a></li>
<li><a href='#create_linelist'><p>Create a Line List from Report and Onset Dates</p></a></li>
<li><a href='#out_list_demo'><p>Sample back-calculation output</p></a></li>
<li><a href='#plot.backnow'><p>Plot Estimates or Reproduction Numbers</p></a></li>
<li><a href='#plot.caseCounts'><p>Plot Case Counts Over Time</p></a></li>
<li><a href='#run_backnow'><p>Run Back Calculation and Estimate Reproduction Numbers</p></a></li>
<li><a href='#sample_cases'><p>Sample cases</p></a></li>
<li><a href='#sample_dates'><p>Sample dates</p></a></li>
<li><a href='#sample_location'><p>Sample location</p></a></li>
<li><a href='#sample_m_hier'><p>Sample hierachical model output</p></a></li>
<li><a href='#sample_multi_site'><p>Sample multi site</p></a></li>
<li><a href='#sample_onset_dates'><p>Sample onset dates</p></a></li>
<li><a href='#sample_report_dates'><p>Sample report dates</p></a></li>
<li><a href='#si'><p>Calculate a Serial Interval Distribution</p></a></li>
<li><a href='#spatialRt'><p>Run Spatial R(t) estimation and Estimate Reproduction Numbers</p></a></li>
<li><a href='#transfer_matrix'><p>Transfer matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Novel Methods for Reproduction Number Estimation,
Back-Calculation, and Forecasting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chad Milando &lt;cmilando@bu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions related to novel methods for estimating R(t), 
  created by the lab of Professor Laura White. Currently implemented methods include 
  two-step Bayesian back-calculation and now-casting for line-list data with missing reporting delays, 
  adapted in 'STAN' from Li (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1009210">doi:10.1371/journal.pcbi.1009210</a>&gt;, 
  and calculation of time-varying reproduction number assuming a flux between various adjacent states, adapted into 'STAN' from 
  Zhou (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1010434">doi:10.1371/journal.pcbi.1010434</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.18.1), rstantools (&ge; 2.4.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-16 22:24:10 UTC; cwm</td>
</tr>
<tr>
<td>Author:</td>
<td>Chad Milando [aut, cre],
  Tenglong Li [ctb],
  Zhenwei Zhou [ctb],
  Laura White [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-16 23:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='WhiteLabRt-package'>The 'WhiteLabRt' package.</h2><span id='topic+WhiteLabRt-package'></span><span id='topic+WhiteLabRt'></span>

<h3>Description</h3>

<p>A collection of functions related to novel methods for
estimating reproduction number, R(t), created by the lab of
Professor Laura White at Boston University School of Public Health.
</p>
<p>Currently implemented methods include (1) Temporal R(t) estimation:
Two-step Bayesian back and nowcasting for linelist data with missing
reporting delays, adapted in 'STAN' from
<a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009210">Li et. al. 2021</a>,
and (2) Spatial R(t) estimation: Calculating time-varying reproduction number,
R(t), assuming a flux of infectors between various adjacent states,
in 'STAN' from <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1010434">Zhou et. al. 2021</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Chad Milando <a href="mailto:cmilando@bu.edu">cmilando@bu.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Tenglong Li [contributor]
</p>
</li>
<li><p> Zhenwei Zhou [contributor]
</p>
</li>
<li><p> Laura White [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (NA). RStan: the R interface to Stan. R package version 2.32.6. https://mc-stan.org
</p>

<hr>
<h2 id='convert_to_linelist'>Convert Case Counts to a Line List</h2><span id='topic+convert_to_linelist'></span>

<h3>Description</h3>

<p>This function takes a data frame of case counts and expands it into a line list format,
which is often used for epidemiological analysis. The function validates input data,
manages missingness, and assumes additional generation times based on the specified
reporting function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_linelist(
  caseCounts,
  reportF_missP,
  reportF = NULL,
  reportF_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_linelist_+3A_casecounts">caseCounts</code></td>
<td>
<p>A data frame with columns <code>date</code>, <code>cases</code>, and <code>location</code>.
The data frame must meet several criteria:
- It should only contain data for one location.
- Dates must be in Date format.
- Case numbers must be non-negative integers.
- No missing values are allowed in the necessary columns.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf_missp">reportF_missP</code></td>
<td>
<p>A numeric probability between 0 and 1 (exclusive) indicating the
proportion of missing onset dates. It throws an error if it is out
of bounds or not numeric.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf">reportF</code></td>
<td>
<p>A function used to simulate the delay from case reporting to case onset.
Defaults to a negative binomial distribution function (<code>rnbinom</code>) if NULL.</p>
</td></tr>
<tr><td><code id="convert_to_linelist_+3A_reportf_args">reportF_args</code></td>
<td>
<p>A list of additional arguments to pass to <code>reportF</code>.
Defaults to <code>list(size = 3, mu = 9)</code> when <code>reportF</code> is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function stops and sends error messages for various data integrity issues,
such as incorrect data types, negative cases, or missing required columns.
It also assumes that the input data is for only one location and handles
NA generation according to <code>reportF_missP</code>.
</p>


<h3>Value</h3>

<p>A data frame in line list format, where each row corresponds to a case report.
The data frame includes columns for the report date, the delay from report to onset,
the onset date, weekend indicator, report interval in days from the first report,
and week interval.
The returned data frame has additional attributes set, including <code>min_day</code> and the
class <code>lineList</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts &lt;- create_caseCounts(sample_dates, sample_location, sample_cases)
line_list &lt;- convert_to_linelist(case_Counts, reportF_missP = 0.5)
</code></pre>

<hr>
<h2 id='create_caseCounts'>Create a Case Counts Data Frame</h2><span id='topic+create_caseCounts'></span>

<h3>Description</h3>

<p>This function constructs a data frame from vectors representing dates, locations,
and case numbers, ensuring that all input vectors meet specific data integrity
requirements. It checks for the correct data types, non-negative case numbers,
and uniformity in vector lengths. The function also ensures no missing values are
present and that all data pertain to a single location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_caseCounts(date_vec, location_vec, cases_vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_caseCounts_+3A_date_vec">date_vec</code></td>
<td>
<p>A vector of dates corresponding to case reports; must be of type Date.</p>
</td></tr>
<tr><td><code id="create_caseCounts_+3A_location_vec">location_vec</code></td>
<td>
<p>A character vector representing the location of the case reports;
all entries must refer to the same location.</p>
</td></tr>
<tr><td><code id="create_caseCounts_+3A_cases_vec">cases_vec</code></td>
<td>
<p>A numeric vector representing the number of cases reported on each date;
values must be non-negative integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs several checks to ensure the integrity of the input:
- It verifies that all vectors have the same length.
- It confirms that there are no negative numbers in <code>cases_vec</code>.
- It checks for and disallows any missing values in the data frame.
It throws errors if any of these conditions are not met, indicating that
the input vectors are not appropriately formatted or contain invalid data.
</p>


<h3>Value</h3>

<p>A data frame named <code>caseCounts</code> with columns <code>date</code>, <code>cases</code>, and <code>location</code>.
Each row corresponds to a unique report of cases on a given date at a specified location.
The data frame is assigned a class attribute of <code>caseCounts</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts = create_caseCounts(sample_dates, sample_location, sample_cases)
</code></pre>

<hr>
<h2 id='create_linelist'>Create a Line List from Report and Onset Dates</h2><span id='topic+create_linelist'></span>

<h3>Description</h3>

<p>This function constructs a line list data frame using vectors of report
and onset dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_linelist(report_dates, onset_dates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_linelist_+3A_report_dates">report_dates</code></td>
<td>
<p>A vector of dates representing when cases were
reported; must be of type Date.</p>
</td></tr>
<tr><td><code id="create_linelist_+3A_onset_dates">onset_dates</code></td>
<td>
<p>A vector of dates representing when symptoms onset
occurred; must be of type Date. This vector can contain NA values,
but not exclusively or none at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ensures the following:
- The length of <code>report_dates</code> and <code>onset_dates</code> must be equal.
- There should be no NA values in <code>report_dates</code>.
- <code>onset_dates</code> must contain some but not all NA values.
- Each non-NA onset date must be earlier than or equal to its
corresponding report date.
If any of these conditions are violated, the function will
stop with an error message.
Additionally, the function calculates the delay in days between
onset and report dates,
identifies weekends, and calculates reporting and week intervals
based on the earliest date.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
report_dates, delay_int, onset_dates, is_weekend, report_int, and week_int.
This data frame is ordered by report_dates and assigned a class
attribute of <code>lineList</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
</code></pre>

<hr>
<h2 id='out_list_demo'>Sample back-calculation output</h2><span id='topic+out_list_demo'></span>

<h3>Description</h3>

<p>an example <code>backnow</code> output object from run_backnow()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out_list_demo
</code></pre>


<h3>Format</h3>

<p>An backnow object
</p>

<dl>
<dt>list</dt><dd><p>list</p>
</dd>
</dl>


<hr>
<h2 id='plot.backnow'>Plot Estimates or Reproduction Numbers</h2><span id='topic+plot.backnow'></span>

<h3>Description</h3>

<p>This function plots estimates of case numbers or reproduction numbers (<code>r(t)</code>) based on the
provided object. It can handle two types of plots: 'est' for estimated case numbers over time,
and 'rt' for estimated reproduction numbers over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'backnow'
plot(x, plottype, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.backnow_+3A_x">x</code></td>
<td>
<p>An object containing the necessary data for plotting. This object should have
specific structure depending on the <code>plottype</code>:
- For <code>plottype = 'est'</code>, <code>x</code> should contain <code>report_date</code>, <code>report_cases</code>,
<code>est_back_date</code>, and <code>est_back</code>, where <code>est_back</code> is expected to be a matrix
with three rows representing the lower bound, estimate, and upper bound.
- For <code>plottype = 'rt'</code>, <code>x</code> should contain <code>est_rt_date</code> and <code>est_rt</code>,
with <code>est_rt</code> formatted similarly to <code>est_back</code>.</p>
</td></tr>
<tr><td><code id="plot.backnow_+3A_plottype">plottype</code></td>
<td>
<p>A character string specifying the type of plot to generate. Valid options
are 'est' for case estimates and 'rt' for reproduction numbers.</p>
</td></tr>
<tr><td><code id="plot.backnow_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the <code>plottype</code>:
- 'est': Plots the reported cases over time with a polygon representing the
uncertainty interval and a line showing the central estimate.
- 'rt': Plots the reproduction number over time with a similar style.
</p>


<h3>Value</h3>

<p>a plot object for an object of class <code>backnow</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
sip &lt;- si(14, 4.29, 1.18)
results &lt;- run_backnow(
  line_list,
  sip = sip, chains = 1)
plot(results, "est")

</code></pre>

<hr>
<h2 id='plot.caseCounts'>Plot Case Counts Over Time</h2><span id='topic+plot.caseCounts'></span>

<h3>Description</h3>

<p>This function plots the number of cases over time from a data frame object. If the data frame
contains multiple locations, a specific location must be specified. The plot displays the total
number of cases against dates and annotates one of the earliest points with the location name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caseCounts'
plot(x, loc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.caseCounts_+3A_x">x</code></td>
<td>
<p>A data frame containing the case counts with at least two columns: <code>date</code> and <code>cases</code>.
The data frame may optionally include a <code>location</code> column, which is required if multiple
locations are present.</p>
</td></tr>
<tr><td><code id="plot.caseCounts_+3A_loc">loc</code></td>
<td>
<p>An optional string specifying the location to filter the case counts by. If <code>loc</code> is
provided and <code>location</code> column exists in <code>x</code>, the plot will only show data for the
specified location. If multiple locations are present and <code>loc</code> is not specified,
the function will stop with an error.</p>
</td></tr>
<tr><td><code id="plot.caseCounts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>location</code> column is present in <code>x</code> and contains multiple unique values,
the <code>loc</code> parameter must be specified to indicate which location's data to plot.
The function adds a text annotation to the plot, labeling one of the earliest points
with the specified location's name.
</p>


<h3>Value</h3>

<p>a plot object for an object of class <code>caseCounts</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_dates")
data("sample_location")
data("sample_cases")
case_Counts = create_caseCounts(sample_dates, sample_location, sample_cases)
plot(case_Counts)
</code></pre>

<hr>
<h2 id='run_backnow'>Run Back Calculation and Estimate Reproduction Numbers</h2><span id='topic+run_backnow'></span>

<h3>Description</h3>

<p>This function performs a back-calculation based on provided epidemic case count data,
estimating the time distribution of infections and reproduction numbers (r(t)).
It utilizes extensive input checks and parameter validation to ensure robust model execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_backnow(
  input,
  sip,
  NB_maxdelay = as.integer(20),
  window_size = as.integer(7),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_backnow_+3A_input">input</code></td>
<td>
<p>A 'lineList' data.frame from <code>create_linelist</code> or <code>convert_to_linelist</code>.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_sip">sip</code></td>
<td>
<p>Vector of numeric values specifying the serial interval probabilities.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_nb_maxdelay">NB_maxdelay</code></td>
<td>
<p>Integer, the maximum delay for the negative binomial distribution used in modeling.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_window_size">window_size</code></td>
<td>
<p>Integer, the number of days of the R(t) averaging window.</p>
</td></tr>
<tr><td><code id="run_backnow_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to rstan::sampling()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ensures input data is of the correct class and processes it accordingly.
It handles different input classes by either converting <code>caseCounts</code> to <code>lineList</code> or
directly using <code>lineList</code>. The function stops with an error if the input doesn't meet expected standards.
It performs simulations to estimate both the back-calculation of initial infections and reproduction numbers
over time, while checking and adjusting for potential NA values and ensuring that all conditions for the
model parameters are met. Output includes estimates of initial infections and reproduction numbers along
with diagnostic statistics.
</p>


<h3>Value</h3>

<p>an object of class <code>backnow</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_onset_dates")
data("sample_report_dates")
line_list &lt;- create_linelist(sample_report_dates, sample_onset_dates)
sip &lt;- si(14, 4.29, 1.18)
results &lt;- run_backnow(
  line_list,
  sip = sip, chains = 1)

</code></pre>

<hr>
<h2 id='sample_cases'>Sample cases</h2><span id='topic+sample_cases'></span>

<h3>Description</h3>

<p>Sample of aggregated case counts from a single location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_cases
</code></pre>


<h3>Format</h3>

<p>A vector of length 80.
</p>

<dl>
<dt>Cases</dt><dd><p>Numeric</p>
</dd>
</dl>


<hr>
<h2 id='sample_dates'>Sample dates</h2><span id='topic+sample_dates'></span>

<h3>Description</h3>

<p>Sample of case report dates from a single location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dates
</code></pre>


<h3>Format</h3>

<p>A vector of length 80.
</p>

<dl>
<dt>Dates</dt><dd><p>Dates of reported aggregated cases</p>
</dd>
</dl>


<hr>
<h2 id='sample_location'>Sample location</h2><span id='topic+sample_location'></span>

<h3>Description</h3>

<p>An vector of a single location to accompany <code>sample_dates</code> and <code>sample_cases</code>.
This is to emphasize that linelist functions are for a single location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_location
</code></pre>


<h3>Format</h3>

<p>A vector of length 80.
</p>

<dl>
<dt>Location</dt><dd><p>Character</p>
</dd>
</dl>


<hr>
<h2 id='sample_m_hier'>Sample hierachical model output</h2><span id='topic+sample_m_hier'></span>

<h3>Description</h3>

<p>an example <code>rstan</code> output object from spatialrt()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_m_hier
</code></pre>


<h3>Format</h3>

<p>An rstan object
</p>

<dl>
<dt>list</dt><dd><p>list</p>
</dd>
</dl>


<hr>
<h2 id='sample_multi_site'>Sample multi site</h2><span id='topic+sample_multi_site'></span>

<h3>Description</h3>

<p>A matrix of daily aggregated cases from two sites (Hoth and Tatooine).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_multi_site
</code></pre>


<h3>Format</h3>

<p>A data.table data frame with 80 rows and 2 variables:
</p>

<dl>
<dt>Cases for Site1</dt><dd><p>Number of aggregated cases for Site 1</p>
</dd>
<dt>Cases for Site1</dt><dd><p>Number of aggregated cases for Site 2</p>
</dd>
</dl>


<hr>
<h2 id='sample_onset_dates'>Sample onset dates</h2><span id='topic+sample_onset_dates'></span>

<h3>Description</h3>

<p>Line-list data, onset dates, with some missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_onset_dates
</code></pre>


<h3>Format</h3>

<p>A vector of length 6380, one value per case.
</p>

<dl>
<dt>Date</dt><dd><p>Date of onset</p>
</dd>
</dl>


<hr>
<h2 id='sample_report_dates'>Sample report dates</h2><span id='topic+sample_report_dates'></span>

<h3>Description</h3>

<p>Line-list data, case report dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_report_dates
</code></pre>


<h3>Format</h3>

<p>A vector of length 6380, one value per case.
</p>

<dl>
<dt>Date</dt><dd><p>Date of report</p>
</dd>
</dl>


<hr>
<h2 id='si'>Calculate a Serial Interval Distribution</h2><span id='topic+si'></span>

<h3>Description</h3>

<p>This function computes the probability distribution function (PDF) of the
serial interval using a gamma distribution with specified
shape and rate parameters. The serial interval is defined as the time
between successive cases in a chain of transmission. This implementation
generates a discrete PDF at the <em>daily</em> level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>si(ndays, shape, rate, leading0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="si_+3A_ndays">ndays</code></td>
<td>
<p>Integer, the number of days over which to calculate the
serial interval distribution.</p>
</td></tr>
<tr><td><code id="si_+3A_shape">shape</code></td>
<td>
<p>Numeric, the shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="si_+3A_rate">rate</code></td>
<td>
<p>Numeric, the rate parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="si_+3A_leading0">leading0</code></td>
<td>
<p>Logical, should a leading 0 be added to indicate t0?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the <code>pgamma</code> function to calculate cumulative
probabilities for each day up to <code>ndays</code> and then differences these
to get daily probabilities. The resulting probabilities are normalized to
sum to 1, ensuring that they represent a valid probability distribution.
</p>


<h3>Value</h3>

<p>Numeric vector representing the serial interval probabilities
for each of the first <code>ndays</code> days. The probabilities are normalized
so that their sum is 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>si(ndays = 14, shape = 4.29, rate = 1.18)
</code></pre>

<hr>
<h2 id='spatialRt'>Run Spatial R(t) estimation and Estimate Reproduction Numbers</h2><span id='topic+spatialRt'></span>

<h3>Description</h3>

<p>This function calculates R(t) that arises from transfer of infectors between
different states. There are different flavors of the model, but the base version
calculates a weekly R(t) within each state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialRt(report_dates, case_matrix, transfer_matrix, sip, v2 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialRt_+3A_report_dates">report_dates</code></td>
<td>
<p>A vector of reporting dates</p>
</td></tr>
<tr><td><code id="spatialRt_+3A_case_matrix">case_matrix</code></td>
<td>
<p>A matrix of cases, defined by integers</p>
</td></tr>
<tr><td><code id="spatialRt_+3A_transfer_matrix">transfer_matrix</code></td>
<td>
<p>A matrix that defines how infectors flow between states.
Each row of the transfer matrix must sum to 1.</p>
</td></tr>
<tr><td><code id="spatialRt_+3A_sip">sip</code></td>
<td>
<p>Vector of numeric values specifying the serial interval probabilities.</p>
</td></tr>
<tr><td><code id="spatialRt_+3A_v2">v2</code></td>
<td>
<p>a flag indicating FALSE if the base algorithm is to be used, and TRUE if
the experimental algorithm is desired. The experimental version contains a
non-centered parameterization, an AR1 process, and partial pooling across states.</p>
</td></tr>
<tr><td><code id="spatialRt_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to rstan::sampling()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rstan object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sample_multi_site")
data("transfer_matrix")
Y &lt;- matrix(integer(1), nrow = nrow(sample_multi_site), ncol = 2)
for(i in 1:nrow(Y)) {
  for(j in c(2, 3)) {
    Y[i,j-1] &lt;- as.integer(sample_multi_site[i,j])
  }
}
all(is.integer(Y))
sip &lt;- si(14, 4.29, 1.18, leading0 = FALSE)
sample_m_hier &lt;- spatialRt(report_dates = sample_multi_site$date,
case_matrix = Y,
transfer_matrix = transfer_matrix,
v2 = FALSE,
sip = sip, chains = 1)

</code></pre>

<hr>
<h2 id='transfer_matrix'>Transfer matrix</h2><span id='topic+transfer_matrix'></span>

<h3>Description</h3>

<p>A matrix of daily transfers between two sites (Hoth and Tatooine).
Each row sums to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_matrix
</code></pre>


<h3>Format</h3>

<p>A data.table data frame with 160 rows and 2 variables:
</p>

<dl>
<dt>Transfer to Site1</dt><dd><p>Fraction of transfer to Site 1</p>
</dd>
<dt>Transfer to Site2</dt><dd><p>Fraction of transfer to Site 2</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
