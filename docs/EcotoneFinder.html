<!DOCTYPE html><html><head><title>Help for package EcotoneFinder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EcotoneFinder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange.vars'><p>Re-ordering columns in dataframes:</p></a></li>
<li><a href='#cbindna'><p>qpcR cbind.na method.</p></a></li>
<li><a href='#clustergram'><p>Clustergram base function</p></a></li>
<li><a href='#clustergram.cmeans'><p>cmeans function for clustergram</p></a></li>
<li><a href='#clustergram.cmeans.Ind'><p>cmeans clustering with fuzzy indices computation for clustergram</p></a></li>
<li><a href='#clustergram.kmeans'><p>Type function that clustergram takes for clustering.</p></a></li>
<li><a href='#clustergram.plot.matlines'><p>Plot function for clustergram</p></a></li>
<li><a href='#clustergram.vegclust'><p>Vegclust function for clustergram</p></a></li>
<li><a href='#clustergram.vegclust.Ind'><p>Vegclust clustering with fuzzy indices computation for clustergram</p></a></li>
<li><a href='#clustergramInd'><p>Clustergram with fuzzy indices plot</p></a></li>
<li><a href='#CommunityColor'><p>Tool to assign color to species distribution plots given fuzzy clustering</p>
results.</a></li>
<li><a href='#curveNoPlot'><p>Adaptation of the curve function (without plot).</p></a></li>
<li><a href='#DistEco'><p>Tools for internal data structure exploration</p></a></li>
<li><a href='#EcotoneFinder'><p>Wraper function to perform ecological gradient analysis</p></a></li>
<li><a href='#EcotoneFinderSeries'><p>Extension of EcotoneFinder for space/time series</p></a></li>
<li><a href='#ExtractCentroid'><p>Visualisation of fuzzy centroids:</p></a></li>
<li><a href='#FuzzyIndice.plot.matlines'><p>Plot function for fuzzy indices with clustergram.</p></a></li>
<li><a href='#ggEcotone'><p>GGplot method for EcotoneFinder</p></a></li>
<li><a href='#NetworkCommunity'><p>Perform Spinglass algorythm and find networks communities</p></a></li>
<li><a href='#NetworkEco'><p>Networks for ecotones and communities</p></a></li>
<li><a href='#NetworkEcoSeries'><p>Networkeco for data series</p></a></li>
<li><a href='#plotEco'><p>Plotting component for EcotoneFinder</p></a></li>
<li><a href='#plotEcotone'><p>Plot method for EcotoneFinder</p></a></li>
<li><a href='#plotEnv'><p>Plotting component for EcotoneFinder when run on environmental data</p></a></li>
<li><a href='#plotSlope'><p>Plotting component for Slope</p></a></li>
<li><a href='#rbindna'><p>qpcR rbind.na method.</p></a></li>
<li><a href='#Slope'><p>Method to calculate the derivative of irregular functions:</p></a></li>
<li><a href='#SyntheticData'><p>Create synthetic gaussian-shaped species abundance data</p></a></li>
<li><a href='#SyntheticDataSeries'><p>Synthetic data for Space/Time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Characterising and Locating Ecotones and Communities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Bagnaro</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Bagnaro &lt;antoine.bagnaro@wanadoo.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analytical methods to locate and characterise ecotones, ecosystems and environmental patchiness along ecological gradients. Methods are implemented for isolated sampling or for space/time series. It includes Detrended Correspondence Analysis (Hill &amp; Gauch (1980) &lt;<a href="https://doi.org/10.1007%2FBF00048870">doi:10.1007/BF00048870</a>&gt;), fuzzy clustering (De Cáceres et al. (2010) &lt;<a href="https://doi.org/10.1080%2F01621459.1963.10500845">doi:10.1080/01621459.1963.10500845</a>&gt;), biodiversity indices (Jost (2006) &lt;<a href="https://doi.org/10.1111%2Fj.2006.0030-1299.14714.x">doi:10.1111/j.2006.0030-1299.14714.x</a>&gt;), and network analyses (Epskamp et al. (2012) &lt;<a href="https://doi.org/10.18637%2Fjss.v048.i04">doi:10.18637/jss.v048.i04</a>&gt;) - as well as tools to explore the number of clusters in the data. Functions to produce synthetic ecological datasets are also provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, colorspace, corrplot, e1071, ggplot2, graphics,
qgraph, igraph, methods, philentropy, plyr, purrr, reshape,
rlang, Rmisc, stats, vegan, vegclust, withr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-16 20:48:53 UTC; antoine</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-16 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrange.vars'>Re-ordering columns in dataframes:</h2><span id='topic+arrange.vars'></span>

<h3>Description</h3>

<p>Re-ordering columns in dataframes:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.vars(data, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.vars_+3A_data">data</code></td>
<td>
<p>dataframe to be ordered</p>
</td></tr>
<tr><td><code id="arrange.vars_+3A_vars">vars</code></td>
<td>
<p>nammed vectors of new positions. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an easy way to re-order the columns of a
dataframe. The &quot;vars&quot; parameter must be a nammed numeric vectors with the
names corresponding to the targeted columns and the numbers corresponding
to their desired new positions.
</p>


<h3>Value</h3>

<p>The dataframe with the desired colum order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #### Dummy data:
 dat &lt;- data.frame("Fac1" = c(rep("A", 6), rep("B",6)),
                   "Var1" = rnorm(12, mean = 20, sd = 1),
                   "Fac2" = rep(c("Low","High","Low","High"),
                                each=3),
                   "Var2" = c(rnorm(3,7), rnorm(3,9),
                              rnorm(3,12), rnorm(3,15)))

 # factor columns at the begining.
 arrange.vars(dat, vars =c("Fac2" = 2))
 # factor columns at the end.
 arrange.vars(dat, vars =c("Fac1" = 3, "Fac2" = 4))

</code></pre>

<hr>
<h2 id='cbindna'>qpcR cbind.na method.</h2><span id='topic+cbindna'></span>

<h3>Description</h3>

<p>qpcR cbind.na method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbindna(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbindna_+3A_...">...</code></td>
<td>
<p>(generalized) vectors or matrices. See base::cbind</p>
</td></tr>
<tr><td><code id="cbindna_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer controlling the construction
of labels in the case of non-matrix-like arguments. See base::cbind</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix combining the ... arguments column-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Vectors:
a &lt;- c(rep(1, 5), NA, seq(1:5))
b &lt;- c(rep(1, 4), NA, seq(1:7))

# Complete shorter vector with NAs:
cbindna(a,b)

</code></pre>

<hr>
<h2 id='clustergram'>Clustergram base function</h2><span id='topic+clustergram'></span>

<h3>Description</h3>

<p>Clustergram base function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram(Data, k.range = 2:10,
  clustering.function = clustergram.kmeans,
  clustergram.plot = clustergram.plot.matlines, line.width = 0.004,
  add.center.points = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations</p>
</td></tr>
<tr><td><code id="clustergram_+3A_k.range">k.range</code></td>
<td>
<p>A vector with the number of clusters to plot the clustergram
for.</p>
</td></tr>
<tr><td><code id="clustergram_+3A_clustering.function">clustering.function</code></td>
<td>
<p>Which clustering method to be used. Default is
k-means. Can be FCM is set to clustergram.vegclust. See details</p>
</td></tr>
<tr><td><code id="clustergram_+3A_clustergram.plot">clustergram.plot</code></td>
<td>
<p>Type of plot for the output. See details.</p>
</td></tr>
<tr><td><code id="clustergram_+3A_line.width">line.width</code></td>
<td>
<p>Graphical parameter. Width of the lines.</p>
</td></tr>
<tr><td><code id="clustergram_+3A_add.center.points">add.center.points</code></td>
<td>
<p>Logical. Should the cluster means be plotted (as
points).</p>
</td></tr>
<tr><td><code id="clustergram_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the clustering function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the clustergram function created by Matthias Schonlau. See:
Schonlau M. The clustergram: A graph for visualizing hierarchical and
nonhierarchical cluster analyses. The Stata Journal. 2002;2:391–402.
</p>
<p>It is reproduced in this package for convenience. This package also provide
extensions of the clustergram method for fuzzy-c-means clustering and for
the evolution of the main fuzzy indices. These extensions take the form of
additional options to be passed in the clustering.function argument and the
clustergram.plot argument.
</p>
<p>It is also recommended to run the clustergram analysis several times and
compare the obtained outputs, as they may vary significantly.
</p>


<h3>Value</h3>

<p>A clustergram plot of the inputed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## 6 clustergram plots
   for (i in 1:6) clustergram(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                              k.range = 2:10, line.width = .2)

</code></pre>

<hr>
<h2 id='clustergram.cmeans'>cmeans function for clustergram</h2><span id='topic+clustergram.cmeans'></span>

<h3>Description</h3>

<p>cmeans function for clustergram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.cmeans(Data, k, method = "cmeans", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.cmeans_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans_+3A_k">k</code></td>
<td>
<p>Number of desired groups for the c-means clustering.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans_+3A_method">method</code></td>
<td>
<p>Clustering method for the cmeans function.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the cmeans function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of Fuzzy c-means clustering (with the
cmeans function of the e1071 package) for the clustergram function. The
return list is internally used by the clustergram to build the clustergram
plot.
</p>


<h3>Value</h3>

<p>A list containing the cluster vector and the centers matrix (see
cmeans function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## 6 clustergram plots
   for (i in 1:6) clustergram(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                              clustering.function = clustergram.cmeans,
                              k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='clustergram.cmeans.Ind'>cmeans clustering with fuzzy indices computation for clustergram</h2><span id='topic+clustergram.cmeans.Ind'></span>

<h3>Description</h3>

<p>cmeans clustering with fuzzy indices computation for clustergram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.cmeans.Ind(Data, k, method = "cmeans", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.cmeans.Ind_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans.Ind_+3A_k">k</code></td>
<td>
<p>Number of desired groups for the FCM clustering.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans.Ind_+3A_method">method</code></td>
<td>
<p>Clustering method for the cmeans function.</p>
</td></tr>
<tr><td><code id="clustergram.cmeans.Ind_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the cmeans function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally to the FCM clustering with the cmeans function (e1071
package), the function compute the main fuzzy indices to help with the
decision on the optimal number of cluster in the data. The indices are
computed with the vegclustIndex function of the vegclust package. Maximum
values of PCN or minimum values of PEN can be used as criteria to choose
the number of clusters.
</p>


<h3>Value</h3>

<p>A list containing the cluster vector, the centers matrix and a vector
of four fuzzy indices (partition coefficient (PC), normalized partition
coefficient (PCN), partition entropy (PE) and normalized partition entropy
(PEN)). See vegclust and veclustIndex functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## clustergram plots with fuzzy indices plots:
   clustergramInd(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                                 clustering.function = clustergram.cmeans.Ind,
                                 clustergram.plot = clustergram.plot.matlines,
                                 FuzzyIndice.plot = FuzzyIndice.plot.matlines,
                                 k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='clustergram.kmeans'>Type function that clustergram takes for clustering.</h2><span id='topic+clustergram.kmeans'></span>

<h3>Description</h3>

<p>Type function that clustergram takes for clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.kmeans(Data, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.kmeans_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations</p>
</td></tr>
<tr><td><code id="clustergram.kmeans_+3A_k">k</code></td>
<td>
<p>Number of desired groups for the k-means clustering.</p>
</td></tr>
<tr><td><code id="clustergram.kmeans_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed in the kmeans function (from
the stats package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the type of function that the clustergram function uses for
clustering. The return list is internally used by the clustergram to build
the clustergram plot.
</p>


<h3>Value</h3>

<p>A list containing the cluster vector and the centers matrix (see
kmeans function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## 6 clustergram plots
   for (i in 1:6) clustergram(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                              clustering.function = clustergram.kmeans,
                              k.range = 2:10, line.width = .2)

</code></pre>

<hr>
<h2 id='clustergram.plot.matlines'>Plot function for clustergram</h2><span id='topic+clustergram.plot.matlines'></span>

<h3>Description</h3>

<p>Plot function for clustergram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.plot.matlines(X, Y, k.range, x.range, y.range, COL,
  add.center.points, centers.points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.plot.matlines_+3A_x">X</code></td>
<td>
<p>vector of the k number of cluster for the x-axis</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_y">Y</code></td>
<td>
<p>corrdinates of the cluster centers on the y-axis</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_k.range">k.range</code></td>
<td>
<p>x axis breaks.</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_x.range">x.range</code></td>
<td>
<p>x axis range.</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_y.range">y.range</code></td>
<td>
<p>y axis range (PCA scores).</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_col">COL</code></td>
<td>
<p>colour palette.</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_add.center.points">add.center.points</code></td>
<td>
<p>Should the centers be plotted as points. (see
clustergram)</p>
</td></tr>
<tr><td><code id="clustergram.plot.matlines_+3A_centers.points">centers.points</code></td>
<td>
<p>matrix of centers position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal clustergram plot function. The input arguments are computed
by the clustergram function directly.
</p>


<h3>Value</h3>

<p>A clustergram plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## 6 clustergram plots
   for (i in 1:6) clustergram(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                              clustering.function = clustergram.kmeans,
                              clustergram.plot = clustergram.plot.matlines,
                              k.range = 2:10, line.width = .2)

</code></pre>

<hr>
<h2 id='clustergram.vegclust'>Vegclust function for clustergram</h2><span id='topic+clustergram.vegclust'></span>

<h3>Description</h3>

<p>Vegclust function for clustergram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.vegclust(Data, k, method = method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.vegclust_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust_+3A_k">k</code></td>
<td>
<p>Number of desired groups for the FCM clustering.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust_+3A_method">method</code></td>
<td>
<p>Clustering method for the vegclust function.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the vegclust function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of Fuzzy c-means clustering (with the
vegclust function of the vegclust package) for the clustergram function.
The return list is internally used by the clustergram to build the
clustergram plot.
</p>


<h3>Value</h3>

<p>A list containing the cluster vector and the centers matrix (see
vegclust function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## clustergram plot
   clustergram(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                              clustering.function = clustergram.vegclust,
                              k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='clustergram.vegclust.Ind'>Vegclust clustering with fuzzy indices computation for clustergram</h2><span id='topic+clustergram.vegclust.Ind'></span>

<h3>Description</h3>

<p>Vegclust clustering with fuzzy indices computation for clustergram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergram.vegclust.Ind(Data, k, method = "FCM", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergram.vegclust.Ind_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust.Ind_+3A_k">k</code></td>
<td>
<p>Number of desired groups for the FCM clustering.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust.Ind_+3A_method">method</code></td>
<td>
<p>Clustering method for the vegclust function.</p>
</td></tr>
<tr><td><code id="clustergram.vegclust.Ind_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the vegclust function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally to the FCM clustering, the function compute the main
fuzzy indices to help with the decision on the optimal number of cluster in
the data. Maximum values of PCN or minimum values of PEN can be used as
criteria to choose the number of clusters.
</p>


<h3>Value</h3>

<p>A list containing the cluster vector, the centers matrix and a vector
of four fuzzy indices (partition coefficient (PC), normalized partition
coefficient (PCN), partition entropy (PE) and normalized partition entropy
(PEN)). See vegclust and veclustIndex functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## clustergram plots with fuzzy indices plots:
   clustergramInd(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                                 clustering.function = clustergram.vegclust.Ind,
                                 clustergram.plot = clustergram.plot.matlines,
                                 FuzzyIndice.plot = FuzzyIndice.plot.matlines,
                                 k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='clustergramInd'>Clustergram with fuzzy indices plot</h2><span id='topic+clustergramInd'></span>

<h3>Description</h3>

<p>Clustergram with fuzzy indices plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustergramInd(Data, k.range = 2:10,
  clustering.function = clustergram.kmeans,
  clustergram.plot = clustergram.plot.matlines,
  FuzzyIndice.plot = FuzzyIndice.plot.matlines, line.width = 0.004,
  add.center.points = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustergramInd_+3A_data">Data</code></td>
<td>
<p>Should be a scales matrix. Where each column belongs to a
different dimension of the observations.</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_k.range">k.range</code></td>
<td>
<p>A vector with the number of clusters to plot the clustergram
for.</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_clustering.function">clustering.function</code></td>
<td>
<p>Which clustering method to be used. Default is
k-means. Can be FCM is set to clustergram.vegclust. See details</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_clustergram.plot">clustergram.plot</code></td>
<td>
<p>Type of plot for the clustergram output. See details.</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_fuzzyindice.plot">FuzzyIndice.plot</code></td>
<td>
<p>Type of plot for the fuzzy indices output. See
details.</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_line.width">line.width</code></td>
<td>
<p>Graphical parameter. Width of the lines.</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_add.center.points">add.center.points</code></td>
<td>
<p>Logical. Should the cluster means be plotted (as
points).</p>
</td></tr>
<tr><td><code id="clustergramInd_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the clustering function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This clustergram fuction produces an additional plot with the
evolution of the main fuzzy indices (normalized partition coefficient (PCN)
and normalized partition entropy (PEN)). Maximum values of PCN or minimum
values of PEN can be used as criteria to choose the number of clusters.
</p>


<h3>Value</h3>

<p>A clustergram plot and a fuzzy indices evolution plot of the inputed
data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## clustergram plots with fuzzy indices plots:
   clustergramInd(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                                 clustering.function = clustergram.vegclust.Ind,
                                 clustergram.plot = clustergram.plot.matlines,
                                 FuzzyIndice.plot = FuzzyIndice.plot.matlines,
                                 k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='CommunityColor'>Tool to assign color to species distribution plots given fuzzy clustering
results.</h2><span id='topic+CommunityColor'></span>

<h3>Description</h3>

<p>Tool to assign color to species distribution plots given fuzzy clustering
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CommunityColor(ecotonefinder, method = c("vegclust", "cmeans"),
  pal = c("diverge_hcl", "terrain_hcl", "sequential_hcl", "rainbow_hcl"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CommunityColor_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes. Must contain at least one of vegclust or
cmeans results.</p>
</td></tr>
<tr><td><code id="CommunityColor_+3A_method">method</code></td>
<td>
<p>Which fuzzy clustering to use. Either vegclust or cmeans.</p>
</td></tr>
<tr><td><code id="CommunityColor_+3A_pal">pal</code></td>
<td>
<p>Which palette to use for color picking. Chosen from the colorspace
package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CommunityColor creates a color vector that can be used by plotting
functions. It assigns colors to species of a community matrix given the
results of vegclust or cmeans analyses (using cmeans$centers or
vegclust$mobileCenters). Species are assigned to a color according to the
cluster centroid for which they have their highest membership value (see
Bandelj et al., 2012).
</p>
<p>The palette must be one of the colorspace package.
</p>


<h3>Value</h3>

<p>A vector of color names from the palette in the pal argument, of the
same length and in the same order than the species columns of the provided
data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ######## Artificial dataset &amp; analysis:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 27, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.03,3)),
                                 dev.c = .015,
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 SyntheticEcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger",
                                     diversity = "all")

 ##### Assigning colors to communities:
 SyntheticColor &lt;- CommunityColor(SyntheticEcoFinder, pal = "diverge_hcl",
                   method = "cmeans")

 #### Plotting:
 plotEcotone(data = SyntheticEcoFinder, plot.data = TRUE, plot.method = "none",
             col.data = SyntheticColor)



</code></pre>

<hr>
<h2 id='curveNoPlot'>Adaptation of the curve function (without plot).</h2><span id='topic+curveNoPlot'></span>

<h3>Description</h3>

<p>Adaptation of the curve function (without plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curveNoPlot(expr, from = NULL, to = NULL, n = 101, add = FALSE,
  type = "l", xname = "x", xlab = xname, ylab = NULL, log = NULL,
  xlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curveNoPlot_+3A_expr">expr</code></td>
<td>
<p>The name of a function, or a call or an expression written as a
function of x which will evaluate to an object of the same length as x.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_from">from</code></td>
<td>
<p>the range over which the function will be plotted (start).</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_to">to</code></td>
<td>
<p>the range over which the function will be plotted (end).</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_n">n</code></td>
<td>
<p>integer; the number of x values at which to evaluate.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_add">add</code></td>
<td>
<p>logical; if TRUE add to an already existing plot; if NA start a
new plot taking the defaults for the limits and log-scaling of the x-axis
from the previous plot. Taken as FALSE (with a warning if a different value
is supplied) if no graphics device is open.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_type">type</code></td>
<td>
<p>plot type: see plot.default.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_xname">xname</code></td>
<td>
<p>character string giving the name to be used for the x axis.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_xlab">xlab</code></td>
<td>
<p>labels and graphical parameters.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_ylab">ylab</code></td>
<td>
<p>labels and graphical parameters.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_log">log</code></td>
<td>
<p>labels and graphical parameters. See ‘Details’ for the
interpretation of the default for log.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_xlim">xlim</code></td>
<td>
<p>NULL or a numeric vector of length 2; if non-NULL it provides the
defaults for c(from, to) and, unless add = TRUE, selects the x-limits of
the plot – see plot.window.</p>
</td></tr>
<tr><td><code id="curveNoPlot_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Silently used by SyntheticData and SyntheticDataSeries. Equivalent
to the curve function of the graphics package. See the details of the curve
function in graphics package for more details.
</p>


<h3>Value</h3>

<p>A vector containing the y values of the gaussian along the gradient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian &lt;- function(x) a*exp(-(((x-b)^2)/2*(c^2)))
a &lt;- 60
b &lt;- 250
c &lt;- 0.4
Curve=curveNoPlot(gaussian, from = 1, to = 500, n = 500)
Curve$y


</code></pre>

<hr>
<h2 id='DistEco'>Tools for internal data structure exploration</h2><span id='topic+DistEco'></span>

<h3>Description</h3>

<p>Tools for internal data structure exploration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistEco(data, distance.method = "inner_product", transpose = TRUE,
  symm = FALSE, plot = c("heatmap", "network"),
  palette = "colorblind", spinglass = TRUE, run = 10,
  spinglass.groups = c("rounded", "raw"), manual.groups = NULL,
  return.network = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistEco_+3A_data">data</code></td>
<td>
<p>A community or environmental matrix, containing
species or variables as columns and sites as rows.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_distance.method">distance.method</code></td>
<td>
<p>The distance method to be used for the
calculation of the distance matrix. Must be one of
philentropy::distance</p>
</td></tr>
<tr><td><code id="DistEco_+3A_transpose">transpose</code></td>
<td>
<p>Logical. If TRUE, the distance matrix is
calculated between species. If FALSE, it is calculated between
sites.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_symm">symm</code></td>
<td>
<p>Logical indicating if x should be treated symmetrically;
can only be true when x is a square matrix. See stats::heatmap.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_plot">plot</code></td>
<td>
<p>The kind of plot produced by the function.
Can be “heatmap” or “network”.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_palette">palette</code></td>
<td>
<p>The colour palette for the network, if spinglass = TRUE.
Must be one of the palettes supported by qgraph.
Default to “colorblind”.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_spinglass">spinglass</code></td>
<td>
<p>Logical. Whether or not to run a spinglass
algorithm to produce statistical groups for the network.
The spinglass algorithm is performed with the CommunityNetwork
function.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_run">run</code></td>
<td>
<p>Number of runs for the spinglass algorithm. Higher numbers
produce more trustable results but rapidly increase computation time.
Default to 10.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_spinglass.groups">spinglass.groups</code></td>
<td>
<p>If spinglass = TRUE, the type of
grouping to use from the results of the spinglass algorithm.
See Details.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_manual.groups">manual.groups</code></td>
<td>
<p>If spinglass = FALSE, an object that indicates
which nodes belong together. Can be a list in which each element
is a vector of integers identifying the numbers of the nodes that
belong together, or a factor.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_return.network">return.network</code></td>
<td>
<p>Logical. If TRUE, the qgraph object is returned
as output of the function.</p>
</td></tr>
<tr><td><code id="DistEco_+3A_...">...</code></td>
<td>
<p>Additionnal parameters for heatmap or qgraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot corresponding to the plot argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ### Artificial data:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                 b=c(0,250,500),
                                                 c=rep(0.01,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 ## Network of species, with raw spinglass groups:
 DistEco(SyntheticTrial[,2:ncol(SyntheticTrial)], transpose = TRUE,
         plot = c("network"), spinglass = TRUE, run = 10,
         spinglass.groups = c("raw"))

 ## Heatmap of species:
 DistEco(SyntheticTrial[,2:ncol(SyntheticTrial)], transpose = TRUE,
         symm = FALSE, plot = c("heatmap"))


</code></pre>

<hr>
<h2 id='EcotoneFinder'>Wraper function to perform ecological gradient analysis</h2><span id='topic+EcotoneFinder'></span>

<h3>Description</h3>

<p>Wraper function to perform ecological gradient analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EcotoneFinder(data, dist, method = c("dca", "fanny", "vegclust",
  "diversity", "cmeans", "all"), groups = NULL, m.exp = 2,
  standardize = NULL, seed = 1, diversity = c("shannon", "richness",
  "expShannon", "pielou", "all"), na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EcotoneFinder_+3A_data">data</code></td>
<td>
<p>A dataframe containing species as columns and sites as rows.
May also contain environmental parameters, as long as the parameters are
as columns and the site as rows.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_dist">dist</code></td>
<td>
<p>A vector or column containing the gradient along which the
analysis will be done. Must be of the same lenght as data.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_method">method</code></td>
<td>
<p>One of c(&quot;dca&quot;, &quot;fanny&quot;, &quot;vegclust&quot;, &quot;diversity&quot;, &quot;cmeans&quot;, &quot;all&quot;).
Tell the function which analysis to perform. See details.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_groups">groups</code></td>
<td>
<p>Interger. The desired number of clusters if any of the
clustering method is selected.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_m.exp">m.exp</code></td>
<td>
<p>Integer. The membership exponent for any of the clustering
method.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_standardize">standardize</code></td>
<td>
<p>Standardize method to apply to the data before further
analysis (for fanny and cmeans). Must be one of decostand methods (see
decostand).</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_seed">seed</code></td>
<td>
<p>Integer or NULL. Set a seed for initial membership matrix for
cmeans and vegclust algorithms. Recomended for time series, to keep
a more consistent labelling of fuzzy clusters along the gradient.
See Details.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_diversity">diversity</code></td>
<td>
<p>diversity indice to be calculated. See details.</p>
</td></tr>
<tr><td><code id="EcotoneFinder_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EcotoneFinder is a wraper function to perform multiple ecological
gradient analysis at once. The implemented methods are Detrended
Correspondance Analysis (DCA) - see Brownstein et al. 2013 - Fuzzy C-Means
(FCM) - see DeCaceres et al., 2010 - and the calculation of diversity
indices - see Jost, 2007. The DCA is intenally performed by the decorana
function of the vegan package. The FCM analyses can be performed by the
fanny function (cluster package), the vegclust function (vegclust package)
and the cmeans function (e1071 package) - for comparison purposes as the
outcome of the analyses might differ.
The vegclust and cmeans algorithms use random number generators to create
a matrix of initial centers. Setting a seed with the <em>seed</em> argument
guaranty the reproducibility of the outputs. This argument can also be set
to NULL, to preserve the randomness of initial centres.
</p>
<p>It is recommended to stadardize data before applying fanny or cmeans
analysis. See decostand documentation (vegan package) for information on
standardisation methods. Must be one of:
&quot;total&quot;,&quot;max&quot;,&quot;freq&quot;,&quot;normalize&quot;,&quot;range&quot;,&quot;pa&quot;,&quot;chi.square&quot;,&quot;hellinger&quot;,&quot;log&quot;.
If &quot;log&quot; is chosen, the user will be asked to provide the base to be used
upon launching the function.
</p>
<p>Several diversity incides have been implemented, as they are supposed to
react to ecological gradients. It includes the Shannon index, the Pielou
eveness and species richness - computed with the diversity function of the
vegan package. expShannon corresponds to the shannon index in terms of
effective number of species (see Jost, 2007). If &quot;all&quot; is selected, all the
implemented indices will be calculated.
</p>
<p>If &quot;all&quot; is selected in the method argument, all the implemented methods
will be applied.
</p>


<h3>Value</h3>

<p>Ecofinder returns a list containing the original data, the value of
the main arguments used in the function and the outcome of the selected
analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #### Artificial dataset:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.015,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 ## Analyses:
 SyntheticEcoFinder &lt;- EcotoneFinder(data = SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all",
                                     groups = 3, standardize = "hellinger",
                                     diversity = "all")




</code></pre>

<hr>
<h2 id='EcotoneFinderSeries'>Extension of EcotoneFinder for space/time series</h2><span id='topic+EcotoneFinderSeries'></span>

<h3>Description</h3>

<p>Extension of EcotoneFinder for space/time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EcotoneFinderSeries(data, dist, series = NULL, method = c("dca",
  "fanny", "vegclust", "diversity", "cmeans", "all"), groups = NULL,
  m.exp = 2, standardize = NULL, diversity = c("shannon", "richness",
  "expShannon", "pielou", "all"), na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EcotoneFinderSeries_+3A_data">data</code></td>
<td>
<p>A list of dataframes corresponding to the series or a single
dataframe with a series factor. Species must appear as columns.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_dist">dist</code></td>
<td>
<p>A vector or column containing the gradient along which the
analysis will be done. Must be of the same lenght as data.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_series">series</code></td>
<td>
<p>If data is a single dataframe, must be the name or the number of
the factor column identifying the series.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_method">method</code></td>
<td>
<p>One of c(&quot;dca&quot;, &quot;fanny&quot;, &quot;vegclust&quot;, &quot;diversity&quot;, &quot;cmeans&quot;, &quot;all&quot;).
Tell the function which analysis to perform. See details.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_groups">groups</code></td>
<td>
<p>Interger. The desired number of clusters if any of the
clustering method is selected.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_m.exp">m.exp</code></td>
<td>
<p>Integer. The membership exponent for any of the clustering
method.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_standardize">standardize</code></td>
<td>
<p>Standardize method to apply to the data before further
analysis (for fanny and cmeans). Must be one of decostand methods (see
decostand).</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_diversity">diversity</code></td>
<td>
<p>diversity indice to be calculated. See details.</p>
</td></tr>
<tr><td><code id="EcotoneFinderSeries_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EcotoneFinderSeries is a generalisation of the EcotoneFinder function
to handle space/time series of data. If a dataframe is provided, it will
convert it internally to a named list according to the factor provided by
the series argument. The methods of analysis and standardizations, as well
as the diversity indices are the same as those of the EcotoneFinder
function.
</p>


<h3>Value</h3>

<p>A list of lists containing the outcomes of the EcotoneFinder function
for each series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ############# Synthetic time series data:
 SyntheticTrialSeries &lt;- SyntheticDataSeries(CommunityPool = 40,
                                             CommunityNum = 4, SpCo = NULL,
                                             Length = 500, SeriesNum = 5,
                                             Parameters = list(a=rep(60, 4),
                                                               b=c(0,200,350,500),
                                                               c=rep(0.03,4)),
                                             dev.c = .015,
                                             pal = c("#008585", "#B8CDAE", "#E6C186", "#C7522B"),
                                             replacement = FALSE,
                                             Parameters.repl = TRUE)

 EcoTimeSeriesTrial &lt;- EcotoneFinderSeries(data = SyntheticTrialSeries,
                                           dist = "Distance", method = "cmeans",
                                           series = "Time", groups = 4,
                                           standardize = "hellinger", na.rm = TRUE)



</code></pre>

<hr>
<h2 id='ExtractCentroid'>Visualisation of fuzzy centroids:</h2><span id='topic+ExtractCentroid'></span>

<h3>Description</h3>

<p>Visualisation of fuzzy centroids:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractCentroid(ecotonefinder, method = c("fanny", "cmeans", "vegclust"),
  normalized = c("species", "cluster", "none"), position = "dodge",
  threshold = 0, plot = TRUE, col = NULL, return.plot = TRUE,
  labels = ggplot2::waiver(), main = "Community composition",
  xlab = "species", ylab = "Centroid contribution", cex.x = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractCentroid_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way
than EcotoneFinder function outcomes. Must contain “cmeans”, “fanny”
or “vegclust” results.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_method">method</code></td>
<td>
<p>The fuzzy clustering results from which the centroids
will be extracted.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_normalized">normalized</code></td>
<td>
<p>Method to normalise the centroid values, either
by “species” or “cluster”. If “none”, the centroids are plotted
without transformation. See details.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_position">position</code></td>
<td>
<p>Set the positions of the bars for the barchart.
This is passed down to the geom_bar function of ggplot. Default
is set to “dodge”.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for centroid contribution value under
which the species will not be plotted. Can be used to simplify
plots containing many species. See Details.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_plot">plot</code></td>
<td>
<p>Logical. Should the plot be displayed. If FALSE,
the centroids matrix is returned without plotting.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_col">col</code></td>
<td>
<p>Colour vector for the plot. Should be of the same
length that the number of fuzzy clusters.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_return.plot">return.plot</code></td>
<td>
<p>Logical. Should the GGplot object be
stored internally (e.g. for multi-ploting). Default is
TRUE.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_labels">labels</code></td>
<td>
<p>Character vectors of labels for the legend. Must
be of the same length that the number of fuzzy clusters.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_main">main</code></td>
<td>
<p>Main title for the plot. See plot.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="ExtractCentroid_+3A_cex.x">cex.x</code></td>
<td>
<p>cex for the x-axis labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts and plots the fuzzy centroids species
contributions, according to user-defined normalisation steps and
threshold value. The contributions of the different species in the
fuzzy centroids may be used as a proxy for community compositions.
The cmeans function (cmeans package) and vegclust function (vegclust
package) internally compute the centroid compositions and their
outputs are directly used by the ExtractCentroid function.
The fanny function (cluster package), however, does not provide
internal centroids calculation. They are computed here as:
</p>
<p style="text-align: center;"><code class="reqn">Centroid[cluster j] = \sum[ij] (Membership[ij] x Observation[ij]) / \sum[j] Membership[j]
 </code>
</p>

<p>Where the centroid of a cluster is the mean of all observations,
weighted by their degree of belonging to the cluster.
The obtained species contributions to the centroids of the fuzzy
clusters can then be plotted as they are, if normalised = “none”.
To obtain more intuitive units for the interpretation of the
species contributions, two normalisation methods are proposed.
If normalised = “cluster”, the species contributions are given
in percent per clusters (i.e. the sum of all species contributions
in each cluster centroid equals 100). If normalised = “species”,
each species has its contributions summed to 100 (i.e. each species
is in percent per cluster).
For normalised = “none” and normalised = “cluster”, a threshold
value can be specified. Species that do not score above this
threshold will not be displayed on the resulting plot. This can
be used to simplify the outputs, for dataset containing large
number of species.
</p>


<h3>Value</h3>

<p>A matrix containing the cluster centroids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Artificial dataset &amp; analyses:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 20, CommunityNum = 4,
                                 SpCo = NULL ,Length = 500,
                                 Parameters=list(a = rep(60, 4),
                                                 b = c(0,150,350,500),
                                                 c = rep(0.015,4)),
                                 dev.c = 0.007,
                                 pal = c("#008585", "#B8CDAE", "#E6C186", "#C7522B"))

 EcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                            dist = SyntheticTrial$Distance,
                            method = "all", groups=4,
                            standardize = "hellinger",
                            diversity="all")

 ##### Centroid plot without normalisation:
 Centroid &lt;- ExtractCentroid(EcoFinder, method = "fanny",
                             normalized = "none",  threshold = 0,
                             plot = TRUE, position = "dodge",
                             col = colorspace::heat_hcl(4))

 ##### Centroid plot normalised by clusters:
 Centroid &lt;- ExtractCentroid(EcoFinder, method = "fanny",
                             normalized = "cluster",  threshold = 0,
                             plot = TRUE, position = "dodge",
                             col = colorspace::heat_hcl(4))

</code></pre>

<hr>
<h2 id='FuzzyIndice.plot.matlines'>Plot function for fuzzy indices with clustergram.</h2><span id='topic+FuzzyIndice.plot.matlines'></span>

<h3>Description</h3>

<p>Plot function for fuzzy indices with clustergram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzyIndice.plot.matlines(Z, k.range, x.range, z.range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FuzzyIndice.plot.matlines_+3A_z">Z</code></td>
<td>
<p>Fuzzy indices matrix.</p>
</td></tr>
<tr><td><code id="FuzzyIndice.plot.matlines_+3A_k.range">k.range</code></td>
<td>
<p>x axis breaks.</p>
</td></tr>
<tr><td><code id="FuzzyIndice.plot.matlines_+3A_x.range">x.range</code></td>
<td>
<p>x axis range.</p>
</td></tr>
<tr><td><code id="FuzzyIndice.plot.matlines_+3A_z.range">z.range</code></td>
<td>
<p>y axis range for the fuzzy indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provide the tools to add a fuzzy indices evolution
plot together with the normal clustegram plot with the evolution of the
relative positions of the cluster centers.
</p>


<h3>Value</h3>

<p>A plot with the evolution of the fuzzy indices given the number of
fuzzy clusters that were applied to the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Example data:
   SyntheticTrial &lt;- SyntheticData(SpeciesNum = 100,
                                   CommunityNum = 3, SpCo = NULL,
                                   Length = 500,
                                   Parameters = list(a=c(40, 80, 50),
                                                     b=c(100,250,400),
                                                     c=rep(0.03,3)),
                                   dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

   ######## clustergram plots with fuzzy indices plots:
   clustergramInd(as.matrix(SyntheticTrial[,2:ncol(SyntheticTrial)]),
                                 clustering.function = clustergram.vegclust.Ind,
                                 clustergram.plot = clustergram.plot.matlines,
                                 FuzzyIndice.plot = FuzzyIndice.plot.matlines,
                                 k.range = 2:10, line.width = .2)
 

</code></pre>

<hr>
<h2 id='ggEcotone'>GGplot method for EcotoneFinder</h2><span id='topic+ggEcotone'></span>

<h3>Description</h3>

<p>GGplot method for EcotoneFinder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggEcotone(ecotonefinder, slope = NULL, plot.data = FALSE,
  method = c("none", "dca", "fanny", "vegclust", "cmeans", "diversity",
  "dca_slope", "fanny_slope", "vegclust_slope", "cmeans_slope",
  "diversity_slope"), axis.number = 1, diversity = c("Shannon",
  "SpeciesRichness", "ExpShannon", "Pielou", "SpeciesRichness_slope",
  "Shannon_slope", "ExpShannon_slope", "Pielou_slope"), facet = NULL,
  col = "black", title = NULL, xlab = NULL, ylab = NULL,
  return.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggEcotone_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>list containing elements named in the same way than the
EcotoneFinder function outcomes.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_slope">slope</code></td>
<td>
<p>list containing elements named in the same way than the Slope
function outcomes.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical. Should the data be plotted? Default to FALSE.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_method">method</code></td>
<td>
<p>Analysis method to be plotted from the EcotoneFinder results or
the Slope results. Must be one or several of
&quot;none&quot;,&quot;dca&quot;,&quot;fanny&quot;,&quot;vegclust&quot;, &quot;cmeans&quot;,&quot;diversity&quot;,
&quot;dca_slope&quot;,&quot;fanny_slope&quot;,&quot;vegclust_slope&quot;, &quot;cmeans_slope&quot; or
&quot;diversity_slope&quot;.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_axis.number">axis.number</code></td>
<td>
<p>Number of DCA axis to be plotted. Must be between 1 and 4.
Default to 1.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_diversity">diversity</code></td>
<td>
<p>diversity indice to be plotted, if the method argument
contains &quot;diversity&quot; or &quot;diversity_slope&quot;. Must be one or several of &quot;Shannon&quot;,
&quot;SpeciesRichness&quot;, &quot;ExpShannon&quot;, &quot;Pielou&quot;, &quot;all&quot;</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_facet">facet</code></td>
<td>
<p>Character vector of method names indicating how the plot should
be facetted. Can be provided as a list if several methods are to be plotted
on the same facets. Can contain &quot;data&quot; if plot.data = T. If NULL, no facets
are returned. See details.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_col">col</code></td>
<td>
<p>Color palette to be used for plotting. Must be either of length 1,
of the same lenght than the number of facets (when provided), or of the same
length than the number of species (if plot.data = TRUE), or than the number
of groups or axis plotted with the method argument. See details.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_title">title</code></td>
<td>
<p>Main title for the plot</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="ggEcotone_+3A_return.plot">return.plot</code></td>
<td>
<p>Logical. If TRUE, the plot is directly plotted. If FALSE,
the plot is stored as a ggplot object. Default to FALSE. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ggEcotone function is intended to facilitate the plotting of
EcotoneFinder lists with the use of the ggplot2 grammar. It either directly
print its outputs (if plot = TRUE), or returns a ggplot object that can be
further modified (if plot = FALSE). The latter allows for the addition of
other ggplot2 layers to personalise graphical outputs (see examples).
</p>
<p>Facetting options are implemented to allow for the separation of the
different method outputs and facilitate comparisons. The facet parameter
accepts lists, with each element of the list corresponding to a facet and
consisting of the names of the methods to be plotted on that facet.
</p>
<p>The col parameter allows for basic control over the colors of the lines.
ggplot internally recycles colour vectors for each new facets, making it
difficult to precisely control colours in facetted plots. Plotting the
outputs on several graphs and arranging them on a grid is the best way to
produce &quot;facetted&quot; plots with different coulour schemes. See examples.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Artificial dataset:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL ,Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.015,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 ## Analyses:
 EcoFinder &lt;- EcotoneFinder(data = SyntheticTrial[,-1],
                            dist = SyntheticTrial$Distance,
                            method = "all", groups = 3,
                            standardize = "hellinger", diversity = "all")

 ## Slope calculation:
 EcoSlope &lt;- Slope(EcoFinder, method = "all", axis.number = 2,
                   diversity = "all")

 ## Plots:
 
 require(ggplot2)
 require(colorspace)
 # Species Distributions and Fuzzy clusters:
 Plot &lt;- ggEcotone(EcoFinder, slope = EcoSlope, plot.data = TRUE,
                   method = c("cmeans", "fanny"),
                   col = c("#D33F6A", "#E99A2C", "#E2E6BD"),
                   facet = list(c("data"), c("cmeans", "fanny")),
                   title = "Species distribution and fuzzy clusters",
                   xlab = "Gradient", ylab = "Membership grades") +
   theme(plot.title = element_text(hjust = 0.5, face="bold")) +
   theme_bw()
 Plot

 # Fuzzy clusters &amp; derivatives:
 Plot &lt;- ggEcotone(EcoFinder, slope = EcoSlope, plot.data = FALSE,
                   method = c("cmeans", "cmeans_slope"),
                   col = c("#D33F6A", "#E99A2C", "#E2E6BD"),
                   facet = c("cmeans", "cmeans_slope"),
                   title = "fuzzy clusters and derivatives",
                   xlab = "Gradient", ylab = "Membership grades") +
   theme(plot.title = element_text(hjust = 0.5, face="bold")) +
   theme_bw()
 Plot

 # Multiplot layout:
 GG1 &lt;- ggEcotone(EcoFinder, slope = EcoSlope, plot.data = TRUE,
                  method = c("none"), col = heat_hcl(21), facet = NULL,
                  title = "Species distributions", xlab = NULL,
                  ylab = "Abundances") +
   theme(plot.title = element_text(hjust = 0.5, face="bold")) +
   theme_bw()

 GG2 &lt;- ggEcotone(EcoFinder, slope = EcoSlope, plot.data = FALSE,
                  method = c("cmeans"), col = c("#023FA5", "#BEC1D4", "#D6BCC0"),
                  facet = NULL, title = "Fuzzy clusters", xlab = NULL,
                  ylab = "Membership grades") +
   theme(plot.title = element_text(hjust = 0.5, face="bold")) +
   theme_bw()

 GG3 &lt;- ggEcotone(EcoFinder, slope = EcoSlope, plot.data = FALSE,
                  method = c("diversity"),
                  col = c("#26A63A", "#B4B61A"), facet = NULL,
                  diversity=c("SpeciesRichness", "ExpShannon"),
                  title = "diversity indices", xlab = "Gradient",
                  ylab = "Index scores") +
   theme(plot.title = element_text(hjust = 0.5, face="bold")) +
   theme_bw()

 require(Rmisc)
 Rmisc::multiplot(GG1,GG2,GG3)
 

</code></pre>

<hr>
<h2 id='NetworkCommunity'>Perform Spinglass algorythm and find networks communities</h2><span id='topic+NetworkCommunity'></span>

<h3>Description</h3>

<p>Perform Spinglass algorythm and find networks communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkCommunity(networkeco, run = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkCommunity_+3A_networkeco">networkeco</code></td>
<td>
<p>A network object (either qgraph or igraph) or a list
created by the NetworkEco or NetworkEcoSeries functions.</p>
</td></tr>
<tr><td><code id="NetworkCommunity_+3A_run">run</code></td>
<td>
<p>Number of runs for the spinglass algorithm. Computation may be
heavy for high numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function perform spinglass algorithm on the provided network.
(see spinglass.community() function of the igraph package for more details)
The provided graph is internally transformed into a igraph object if
needed. The function returns a number of summary statistics from the n runs
of the spinglass algorithm. Each run of the spinglass algorithm is done
with a different seed, to ensure different outputs. The seeds are internally
recycled by the <em>with_seed</em> fuction of the <em>withr</em> package, so
that the global environment is not modified.
The frequencies at which a number of communities are recognised in the
network and the average assignements (rounded or not) of the nodes into
these communities are returned by the function. The latter can help
to statistically define groups for network graphical representations.
</p>


<h3>Value</h3>

<p>A list containing the number of runs, the number of possible
communities defined by the spinglass algorithm (with frequencies) and the
mean and rounded mean of the assignement of the nodes of the network to
these communities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #### Artificial data:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.01,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 # Building first network:
 Network &lt;- DistEco(SyntheticTrial[,2:ncol(SyntheticTrial)],
                    transpose = TRUE, plot = c("network"), spinglass = FALSE,
                    return.network = TRUE)

 ### Spinglass algorithm (increase number of run for better accuracy):
 SpinglassTrial &lt;- NetworkCommunity(Network, run = 5)

 ### Network with spinglass groups:
 DistEco(SyntheticTrial[,2:ncol(SyntheticTrial)], transpose = TRUE,
         plot = c("network"), spinglass = FALSE, return.network = FALSE,
         manual.groups = as.factor(SpinglassTrial$Memberships$RoundedMean))


</code></pre>

<hr>
<h2 id='NetworkEco'>Networks for ecotones and communities</h2><span id='topic+NetworkEco'></span>

<h3>Description</h3>

<p>Networks for ecotones and communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkEco(ecotonefinder, threshold = 0.8, plot.type = c("percentage",
  "corrplot", "heatmap", "network"), method = c("cmeans", "vegclust"),
  dist.method = "inner_product", plot = c("species", "community"),
  order.sp = NULL, dist = c("count", "relative", "raw"),
  no.plot = FALSE, network.group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkEco_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes. Must contain cmeans results or vegclust
results.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_threshold">threshold</code></td>
<td>
<p>If count = T, the membership grade threshold used to sort
the species in the different clusters.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_plot.type">plot.type</code></td>
<td>
<p>Which graphical representation to be plotted. Among
&quot;percentage&quot;, &quot;corrplot&quot;, &quot;heatmap&quot;,&quot;network&quot;.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_method">method</code></td>
<td>
<p>The membership computation method to be used. One of &quot;cmeans&quot;
or &quot;vegclust&quot;. Must be present in the ecotonefinder list.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_dist.method">dist.method</code></td>
<td>
<p>Distance method for the computation of a distance matrix,
when dist = &quot;raw&quot; and dist = &quot;relative&quot;.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_plot">plot</code></td>
<td>
<p>If plot = &quot;species&quot;, the distances are computed between the
species in the data. If plot = &quot;community&quot;, the distances are computed
between the cluster centroids.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_order.sp">order.sp</code></td>
<td>
<p>Vector providing the order in which to arrange the species.
If NULL, the column order will be kept.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_dist">dist</code></td>
<td>
<p>The type of data on which distance calculations are made from. If
dist = &quot;raw&quot;, the distance matrix is computed from the membership matrix
directly. if dist = &quot;relative&quot;, the distance matrix is computed from the
relative memberships grades of each species in the clusters (between 0 and
1). If dist = &quot;count&quot;, the species are assigned to clusters according to
the threshold and the distance matrix is computed from the number of common
species between the different clusters. See details.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_no.plot">no.plot</code></td>
<td>
<p>Logical. Should the plot be displayed?. Set to TRUE to gain
computation time with large community matrix.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_network.group">network.group</code></td>
<td>
<p>Grouping parameter for the network. Can be user defined
(see qgraph documentation for details) but must be a factor of the same
lenght as the nodes of the graph.</p>
</td></tr>
<tr><td><code id="NetworkEco_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plotting functions, see
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NetworkEco function provides wqys to explore the relations
between fuzzy clusters. Several options are implemented. If dist = &quot;raw&quot;,
it computes a distance matrix from the membership grade matrix directly. If
dist = &quot;relative&quot;, the membership grades are standardized so that the sum
of the membership grades of a given species equals to 1 for every points
along the gradient (which corresponds to a percentage ot membership in each
cluster). If dist = &quot;count&quot;, the standardized membership grades of the are
used to assign species in the community to a unique cluster and the number
of common species between pairs of clusters is counted. The assignement of
species to clusters is done by listing all the species that score a
membership grade higher than the specified threshold in a cluster. The
resulting list of species are then compared to one another.
</p>
<p>The function also allows the computation of distances between species
rather than between clusters, when plot = &quot;species&quot;. This can only be done
from the memberships grades (raw or relative) and this argument will be
disregarded if dist = &quot;count&quot;.
</p>
<p>Several methods of visualisation are implemented: &quot;percentage&quot;, &quot;corrplot&quot;,
&quot;heatmap&quot; and &quot;network&quot;. If &quot;percentage&quot;, a barplot (using ggplot2) of the
standardized memberships grades per fuzzy cluster is plotted. It always
plot the standardized membership grades regardless of the chosen dist
option, but if dist = &quot;count&quot; or dist = &quot;raw&quot; are chosen, the function
still compute the corresponding distance matrices and return them ti the
output list. For time efficiency, it is not recommended to plot it when the
number of species in the community is large (&gt;100). &quot;corrplot&quot; and
&quot;heatmap&quot; produce correlation matrix and heat map. The &quot;network&quot; is based
on the qgraph function of the qgraph package. The ... argument may be used
to pass additional arguments to the plotting functions (for graphical
purposes).
</p>


<h3>Value</h3>

<p>A list containing the percentage matrix, the distance matrix and the
network object (depending of the arguments passed to the function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #### Artificial dataset:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.015,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 ## Analyses:
 SyntheticEcoFinder &lt;- EcotoneFinder(data = SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all",
                                     groups = 3, standardize = "hellinger",
                                     diversity = "all")

 ## Percentage plot:
 SyntheticNetwork &lt;- NetworkEco(SyntheticEcoFinder, threshold = .3, method = "cmeans",
                                plot.type = "percentage", dist = "count")

 ## Heatmap plot:
 SyntheticNetwork &lt;- NetworkEco(SyntheticEcoFinder, plot.type = "heatmap",
                                method = "cmeans", dist = "raw", plot = "species")

 ## Network:
 # From raw membership grades:
 SyntheticNetwork &lt;- NetworkEco(SyntheticEcoFinder, plot.type = "network",
                                method = "cmeans", dist = "raw", plot = "species")

 # From number of species per clusters:
 SyntheticNetwork &lt;- NetworkEco(SyntheticEcoFinder, plot.type = "network", threshold = .3,
                                method = "cmeans", dist = "count", plot = "community",
                                layout = "spring")

</code></pre>

<hr>
<h2 id='NetworkEcoSeries'>Networkeco for data series</h2><span id='topic+NetworkEcoSeries'></span>

<h3>Description</h3>

<p>Networkeco for data series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkEcoSeries(ecotonefinder, threshold = 0.8, method = c("cmeans",
  "vegclust"), plot.type = c("percentage", "heatmap", "corrplot",
  "network"), plot = c("species", "community"), no.plot = FALSE,
  order.sp = NULL, dist.method = "inner_product", dist = c("count",
  "relative", "raw"), network.group = c("site", "cluster"),
  method.corr = "number", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkEcoSeries_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinderSeries function outcomes. Must contain cmeans results or
vegclust results.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_threshold">threshold</code></td>
<td>
<p>If dist = &quot;count&quot;, the membership grade threshold used to
sort the species in the different clusters.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_method">method</code></td>
<td>
<p>The membership computation method to be used. Must be present
in the ecotonefinder list.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_plot.type">plot.type</code></td>
<td>
<p>Which graphical representation to be plotted. Among
&quot;percentage&quot;, &quot;corrplot&quot;, &quot;heatmap&quot;,&quot;network&quot;</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_plot">plot</code></td>
<td>
<p>If plot = &quot;species&quot;, the distances are computed between the
species in the data. If plot = &quot;community&quot;, the distances are computed
between the cluster centroids.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_no.plot">no.plot</code></td>
<td>
<p>Logical. Should the plot be displayed?. Set to TRUE to gain
computation time with large community matrix.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_order.sp">order.sp</code></td>
<td>
<p>Vector providing the order in which to arrange the species.
If NULL, the column order will be kept.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_dist.method">dist.method</code></td>
<td>
<p>Distance method for the computation of a distance matrix,
when dist = &quot;raw&quot; or dist = &quot;percent&quot;.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_dist">dist</code></td>
<td>
<p>The type of data on which distance calculations are made from. If
dist = &quot;raw&quot;, the distance matrix is computed from the membership matrix
directly. if dist = &quot;relative&quot;, the distance matrix is computed from the
relative memberships grades of each species in the clusters (between 0 and
1). If dist = &quot;count&quot;, the species are assigned to clusters according to
the threshold and the distance matrix is computed from the number of common
species between the different clusters. See details.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_network.group">network.group</code></td>
<td>
<p>If network.group = &quot;site&quot; the nodes of the networks will
be colored according to the different times or sites of the series. If
network.group = &quot;cluster&quot; the nodes of the network will be colored
according to the different fuzzy clusters. Can be user defined (see qgraph
documentation for details) but must be a factor of the same lenght as the
nodes of the graph.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_method.corr">method.corr</code></td>
<td>
<p>If plot.type = &quot;corrplot&quot;, the method to be used for the
corrplot. Must be one of &quot;circle&quot;, &quot;square&quot;, &quot;ellipse&quot;, &quot;number&quot;, &quot;shade&quot;,
&quot;color&quot;, &quot;pie&quot;. Default to &quot;number&quot;.</p>
</td></tr>
<tr><td><code id="NetworkEcoSeries_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plotting functions, see
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NetworkEcoSeries is a generalisation of the NetworkEco function to
analyses space/time series. The ... argument may be used to pass additional
arguments to the plotting functions (for graphical purposes).
</p>


<h3>Value</h3>

<p>A list containing the percentage matrix, the distance matrix and the
network object (depending of the arguments passed to the function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  SyntheticTrialSeries &lt;- SyntheticDataSeries(CommunityPool = 40,
                                              CommunityNum = 4, SpCo = NULL,
                                              Length = 500, SeriesNum = 5,
                                              Parameters = list(a=rep(60, 4),
                                                              b=c(0,200,350,500),
                                                              c=rep(0.03,4)),
                                              pal = c("#008585", "#B8CDAE", "#E6C186", "#C7522B"),
                                              replacement = TRUE,
                                              Parameters.repl = TRUE)

  EcoTimeSeriesTrial &lt;- EcotoneFinderSeries(data = SyntheticTrialSeries,
                                            dist = "Distance",
                                            method = c("cmeans","vegclust"),
                                            series = "Time", groups = 4,
                                            standardize = "hellinger", na.rm=TRUE)

#### Network from the common number of species above membership threshold between clusters:
  SyntheticNetworkSeries &lt;- NetworkEcoSeries(EcoTimeSeriesTrial, threshold = .2,
                                             method = "cmeans", plot.type = "network",
                                             plot = "community", dist = "count",
                                             network.group = "cluster",
                                             dist.method = "inner_product",
                                             no.plot = FALSE, layout = "spring",
                                             shape = "ellipse",
                                             palette = "colorblind")

#### Network of relations between species from their raw membership values in each cluster:
  SyntheticNetworkSeries &lt;- NetworkEcoSeries(EcoTimeSeriesTrial, threshold = .2,
                                             method = "cmeans", plot.type = "network",
                                             plot = "species", dist = "raw",
                                             dist.method = "inner_product",
                                             no.plot = FALSE, layout = "spring",
                                             shape = "ellipse",
                                             palette = "colorblind")
 

</code></pre>

<hr>
<h2 id='plotEco'>Plotting component for EcotoneFinder</h2><span id='topic+plotEco'></span>

<h3>Description</h3>

<p>Plotting component for EcotoneFinder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEco(ecotonefinder, plot.data = FALSE, plot.method = c("none",
  "dca", "fanny", "vegclust", "cmeans", "diversity"), axis.number = 1,
  magnification = 20, magnification.diversity = 5,
  col.data = "black", col.method = c("red", "blue"), title = NULL,
  ylab = "Species", xlab = "Gradient", na.rm = FALSE, alone = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEco_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes</p>
</td></tr>
<tr><td><code id="plotEco_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical. Should the data be plotted.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_plot.method">plot.method</code></td>
<td>
<p>Analysis method to be plotted from the EcotoneFinder
analyses. Must be one or several of &quot;none&quot;,&quot;dca&quot;,&quot;fanny&quot;,&quot;vegclust&quot;,
&quot;cmeans&quot; or&quot;diversity&quot;.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_axis.number">axis.number</code></td>
<td>
<p>Number of axis to plot from the DCA.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_magnification">magnification</code></td>
<td>
<p>Magnification coefficient for the method. Usefull if the
data are being plotted.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_magnification.diversity">magnification.diversity</code></td>
<td>
<p>Particular magnification for the diversity
indices.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_col.data">col.data</code></td>
<td>
<p>Colors to be used for the data. See CommunityColor function.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_col.method">col.method</code></td>
<td>
<p>Colors to be used for the methods.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_alone">alone</code></td>
<td>
<p>Logical. If FALSE, lines are added to an existing plot.</p>
</td></tr>
<tr><td><code id="plotEco_+3A_...">...</code></td>
<td>
<p>Additional argument to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal component of the PlotEcotone function for the plotting of
the EcotoneFinder analyses. Use PlotEcotone directly for more options.
</p>


<h3>Value</h3>

<p>A plot with the EcotoneFinder results along the gradient, and
optionally, the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ######## Artificial dataset &amp; analysis:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 20, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.03,3)),
                                 dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

 SyntheticEcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger",
                                     diversity = "all")

 ### Plot:
 require(colorspace)
 plotEco(SyntheticEcoFinder, plot.data = FALSE,
         plot.method = c("cmeans", "dca"),
         axis.number = 2, col.method = terrain_hcl(3))

</code></pre>

<hr>
<h2 id='plotEcotone'>Plot method for EcotoneFinder</h2><span id='topic+plotEcotone'></span>

<h3>Description</h3>

<p>Plot method for EcotoneFinder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEcotone(data = NULL, slope = NULL, env = NULL,
  plot.data = FALSE, plot.method = c("none", "dca", "fanny",
  "vegclust", "cmeans", "diversity", "dca_slope", "fanny_slope",
  "vegclust_slope", "cmeans_slope", "diversity_slope"), axis.number = 1,
  magnification = 20, magnification.diversity = 5,
  magnification.slope = 500, col.data = "black",
  col.method = c("red", "blue"), col.slope = c("darkgreen", "green"),
  col.env = c("orange", "gold"), title = NULL, ylab = "Species",
  xlab = "Gradient", na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEcotone_+3A_data">data</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_slope">slope</code></td>
<td>
<p>A list containing elements named in the same way than Slope
function outcomes</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_env">env</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes. Usefull if EcotoneFinder has been
run on environmental data and the outcomes are to be compared with
the outcomes from the community matrix. Can also be used to compare
results from two different community matrices, if the x-axis are
similar.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical. Should the data be plotted.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_plot.method">plot.method</code></td>
<td>
<p>Analysis method to be plotted from the EcotoneFinder
results or the Slope results. Must be one or several of
&quot;none&quot;,&quot;dca&quot;,&quot;fanny&quot;,&quot;vegclust&quot;, &quot;cmeans&quot;,&quot;diversity&quot;,
&quot;dca_slope&quot;,&quot;fanny_slope&quot;,&quot;vegclust_slope&quot;, &quot;cmeans_slope&quot; or
&quot;diversity_slope&quot;.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_axis.number">axis.number</code></td>
<td>
<p>Number of axis to plot from the DCA.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_magnification">magnification</code></td>
<td>
<p>Magnification coefficient for the method. Usefull if the
data are being plotted.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_magnification.diversity">magnification.diversity</code></td>
<td>
<p>Particular magnification for the diversity
indices.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_magnification.slope">magnification.slope</code></td>
<td>
<p>Magnification coefficient for the Slope.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_col.data">col.data</code></td>
<td>
<p>Colors to be used for the data. See CommunityColor function.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_col.method">col.method</code></td>
<td>
<p>Colors to be used for the methods (for data).</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_col.slope">col.slope</code></td>
<td>
<p>Colors to be used for the methods (for slope).</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_col.env">col.env</code></td>
<td>
<p>Colors to be used for the methods (for env).</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
<tr><td><code id="plotEcotone_+3A_...">...</code></td>
<td>
<p>Additional argument to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotEcotone function is intended for easy visualisation of the
results of the EcotoneFinder function and the Slope function along the
sampling gradient. It also provide a way to plot the original species data
- for comparison - along with magnification coefficients for the different
method or slopes in order to facilitate visualization. Please note that
large sets of species may be confusing to plot. The CommunityColor function
is also provided to help with data coloring and easy visualisation.
</p>


<h3>Value</h3>

<p>A plot corresponding to the plotEcotone arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ######## Artificial dataset &amp; analysis:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 20, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.03,3)),
                                 dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

 SyntheticEcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger",
                                     diversity = "all")

 ##### Assigning colors to communities:
 SyntheticColor &lt;- CommunityColor(SyntheticEcoFinder, pal = "diverge_hcl",
                                  method = "cmeans")

 ###### Computing the derivatives:
 SyntheticSlope &lt;- Slope(SyntheticEcoFinder, method = "all",
                         axis.number = 2, diversity = "all")

 ####### Plot the derivative of the FCM with the synthetic species data:
 require(colorspace)
 plotEcotone(slope = SyntheticSlope, plot.data = TRUE,
             plot.method = c("cmeans_slope"), axis.number = 2,
             col.method = terrain_hcl(3), col.data = SyntheticColor)

 ####### Plot the derivative and the FCM:
 require(colorspace)
 plotEcotone(data = SyntheticEcoFinder, slope = SyntheticSlope,
             plot.data = TRUE,
             plot.method = c("cmeans", "cmeans_slope"),
             axis.number = 2, col.method = terrain_hcl(3),
             col.data = SyntheticColor)



</code></pre>

<hr>
<h2 id='plotEnv'>Plotting component for EcotoneFinder when run on environmental data</h2><span id='topic+plotEnv'></span>

<h3>Description</h3>

<p>Plotting component for EcotoneFinder when run on environmental data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEnv(env, plot.data = FALSE, plot.method = c("none", "dca", "fanny",
  "vegclust", "cmeans", "diversity"), axis.number = 1,
  magnification = 20, magnification.diversity = 5,
  col.data = "black", col.method = c("red", "blue"), title = NULL,
  ylab = "Species", xlab = "Gradient", na.rm = FALSE, alone = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEnv_+3A_env">env</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical. Should the data be plotted.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_plot.method">plot.method</code></td>
<td>
<p>Analysis method to be plotted from the EcotoneFinder
analyses. Must be one or several of &quot;none&quot;,&quot;dca&quot;,&quot;fanny&quot;,&quot;vegclust&quot;,
&quot;cmeans&quot; or&quot;diversity&quot;.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_axis.number">axis.number</code></td>
<td>
<p>Number of axis to plot from the DCA.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_magnification">magnification</code></td>
<td>
<p>Magnification coefficient for the method. Usefull if the
data are being plotted.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_magnification.diversity">magnification.diversity</code></td>
<td>
<p>Particular magnification for the diversity
indices.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_col.data">col.data</code></td>
<td>
<p>Colors to be used for the data. See CommunityColor function.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_col.method">col.method</code></td>
<td>
<p>Colors to be used for the methods.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_alone">alone</code></td>
<td>
<p>Logical. If FALSE, lines are added to an existing plot.</p>
</td></tr>
<tr><td><code id="plotEnv_+3A_...">...</code></td>
<td>
<p>Additional argument to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal component of the PlotEcotone function for the plotting of
the EcotoneFinder analyses. Use PlotEcotone directly for more options.
The &quot;diversity&quot; method is still implemented, but will send a warning as it
may not be relevant for environmental data.
</p>


<h3>Value</h3>

<p>A plot with the EcotoneFinder results along the gradient, and
optionally, the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ######## Artificial dataset &amp; analysis:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 20, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.03,3)),
                                 dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

 SyntheticEcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger",
                                     diversity = "all")

 ### Plot:
 require(colorspace)
 plotEnv(SyntheticEcoFinder, plot.data = FALSE,
         plot.method = c("cmeans", "dca"),
         axis.number = 2, col.method = terrain_hcl(3))

</code></pre>

<hr>
<h2 id='plotSlope'>Plotting component for Slope</h2><span id='topic+plotSlope'></span>

<h3>Description</h3>

<p>Plotting component for Slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSlope(ecotoneslope, plot.data = FALSE, plot.method = c("none",
  "dca_slope", "fanny_slope", "vegclust_slope", "cmeans_slope",
  "diversity_slope"), axis.number = 1, magnification = 500,
  col.data = "black", col.method = c("red", "blue"), title = NULL,
  ylab = "Species", xlab = "Gradient", na.rm = FALSE, alone = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSlope_+3A_ecotoneslope">ecotoneslope</code></td>
<td>
<p>A list containing elements named in the same way than
Slope function outcomes</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical. Should the data be plotted.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_plot.method">plot.method</code></td>
<td>
<p>Analysis method to be plotted from the Slope results. Must
be one or several of &quot;none&quot;, &quot;dca_slope&quot;,&quot;fanny_slope&quot;,&quot;vegclust_slope&quot;,
&quot;cmeans_slope&quot; or &quot;diversity_slope&quot;.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_axis.number">axis.number</code></td>
<td>
<p>Number of axis to plot from the DCA.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_magnification">magnification</code></td>
<td>
<p>Magnification coefficient for the method. Usefull if the
data are being plotted.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_col.data">col.data</code></td>
<td>
<p>Colors to be used for the data. See CommunityColor function.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_col.method">col.method</code></td>
<td>
<p>Colors to be used for the methods.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should NAs be removed.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_alone">alone</code></td>
<td>
<p>Logical. If FALSE, lines are added to an existing plot.</p>
</td></tr>
<tr><td><code id="plotSlope_+3A_...">...</code></td>
<td>
<p>Additional argument to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal component of the PlotEcotone function for the plotting of
the Slope analyses. Use PlotEcotone directly for more options.
</p>


<h3>Value</h3>

<p>A plot with the Slope results along the gradient, and optionally, the
data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ######## Artificial dataset &amp; analysis:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 20, CommunityNum = 3,
                                 SpCo = NULL, Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.03,3)),
                                 dev.c = .015, pal = c("#008585", "#FBF2C4", "#C7522B"))

 SyntheticEcoFinder &lt;- EcotoneFinder(SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger",
                                     diversity = "all")

 ### Derivatives:
 SyntheticSlope &lt;- Slope(SyntheticEcoFinder, method = "all",
                         axis.number = 2, diversity = "all")

### Plot:
require(colorspace)
plotSlope(SyntheticSlope, plot.data = FALSE,
          plot.method = c("cmeans_slope", "vegclust_slope"),
          col.method = terrain_hcl(3))


</code></pre>

<hr>
<h2 id='rbindna'>qpcR rbind.na method.</h2><span id='topic+rbindna'></span>

<h3>Description</h3>

<p>qpcR rbind.na method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindna(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindna_+3A_...">...</code></td>
<td>
<p>(generalized) vectors or matrices. See base::rbind</p>
</td></tr>
<tr><td><code id="rbindna_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer controlling the construction
of labels in the case of non-matrix-like arguments. See base::rbind</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix combining the ... arguments row-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Vectors:
a &lt;- c(rep(1, 5), NA, seq(1:5))
b &lt;- c(rep(1, 4), NA, seq(1:7))

# Complete shorter vector with NAs:
rbindna(a,b)

</code></pre>

<hr>
<h2 id='Slope'>Method to calculate the derivative of irregular functions:</h2><span id='topic+Slope'></span>

<h3>Description</h3>

<p>Method to calculate the derivative of irregular functions:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slope(ecotonefinder, method = c("dca", "fanny", "vegclust", "cmeans",
  "diversity", "all"), window = 3, axis.number = 1,
  groups = ecotonefinder$groups, diversity = c("shannon", "richness",
  "expShannon", "pielou", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slope_+3A_ecotonefinder">ecotonefinder</code></td>
<td>
<p>A list containing elements named in the same way than
EcotoneFinder function outcomes</p>
</td></tr>
<tr><td><code id="Slope_+3A_method">method</code></td>
<td>
<p>The name of the method for which the slopes should be
calculated. Correspond to the names of the list.</p>
</td></tr>
<tr><td><code id="Slope_+3A_window">window</code></td>
<td>
<p>Must be an odd number. The interval to be used for slope
calculation. The bigger the window, the more averaged the slope will be.</p>
</td></tr>
<tr><td><code id="Slope_+3A_axis.number">axis.number</code></td>
<td>
<p>If &quot;dca&quot; is chosen, indicate the number of axis over which
to calculate the slope (first axis, first and second axis,...)</p>
</td></tr>
<tr><td><code id="Slope_+3A_groups">groups</code></td>
<td>
<p>If any clustering method is chosen, corresponds to the index of
the cluster for which the slope shold be calculated. If &quot;all&quot;, the slope
will be calculated for all the clusters.</p>
</td></tr>
<tr><td><code id="Slope_+3A_diversity">diversity</code></td>
<td>
<p>If &quot;diversity&quot; is chosen in the method argument, define the
diversity index for which to calculate the slope. &quot;all&quot; can be chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slope calculations are done by moving window analysis. The width of
the windows is defined by the window argument. For each window, the result
of slope coefficient of a linear model (lm function of the stat package) is
stored and used to draw the general slope along the gradient. The bigger the
window, the more points will be used to compute the linear models, meaning
the obtained slopes will be smoother. This also results in the addition of
NAs at the ends of the gradient.
</p>
<p>The first axis of DCA has been used as a beta-diversity index, and its
derivative as a method to locate ecotones (see Brownstein et al., 2013). The
Slope function provide the possibility of computing the slope of the other
axis, to avoid the loss of information induced by the reduction of the
dimentionality of the original data. Similarly, the slopes of the fuzzy
clusters can be used to pinpoint the transitions between them. The value of
the slopes can be an indicator of the relative sharpness of the transion
area. Particularly, as the memberships of the fuzzy clusters range betwwen 0
and 1, these values can readilly be compared between studies and datasets.
These values vary depending on the window width and can be very sensible to
noise in the original data. A reliable method to mathematically identify
breaks is still needed and careful interpretation by the user is still
required.
</p>


<h3>Value</h3>

<p>A list of dataframes containing the slope values for the specified
methods and the original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #### Artificial dataset:
 SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                 SpCo = NULL ,Length = 500,
                                 Parameters = list(a=rep(60, 3),
                                                   b=c(0,250,500),
                                                   c=rep(0.015,3)),
                                 pal = c("#008585", "#FBF2C4", "#C7522B"))

 ## Analyses:
 SyntheticEcoFinder &lt;- EcotoneFinder(data = SyntheticTrial[,-1],
                                     dist = SyntheticTrial$Distance,
                                     method = "all", groups = 3,
                                     standardize = "hellinger", diversity = "all")

 ## Slope calculation:
 SyntheticSlope &lt;- Slope(SyntheticEcoFinder, method = "all", axis.number = 2,
                         diversity = "all")


</code></pre>

<hr>
<h2 id='SyntheticData'>Create synthetic gaussian-shaped species abundance data</h2><span id='topic+SyntheticData'></span>

<h3>Description</h3>

<p>Create synthetic gaussian-shaped species abundance data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SyntheticData(SpeciesNum, CommunityNum, Length = 100, SpCo = NULL,
  Parameters = list(a = NULL, b = NULL, c = NULL), dev.a = 10,
  dev.b = 10, dev.c = 0, down.limit = 1, pal = NULL,
  xlab = "Gradient", ylab = "Synthetic species",
  title = "Synthetic data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SyntheticData_+3A_speciesnum">SpeciesNum</code></td>
<td>
<p>An integer giving the total number of species in the
synthetic data.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_communitynum">CommunityNum</code></td>
<td>
<p>An integer giving the number of communities to be
synthetised.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_length">Length</code></td>
<td>
<p>The lenght of the gradient. Corresponds to the x-axis in a
plot.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_spco">SpCo</code></td>
<td>
<p>The ratio of species per communities. If NULL, species will be
spread evenly between communities with additional species in the last
community if the quotient is not an integer. When specified, SpCo must be a
vector of lenght equal to CommunityNum and whose sum is equal to SpeciesNum</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_parameters">Parameters</code></td>
<td>
<p>A list containing the parameters (a, b and c) for the
gaussians. Each parameter must be specified for each community. See
Details.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_dev.a">dev.a</code></td>
<td>
<p>The deviation around parameter a for the gaussian in a
community. If 0 all species curve in the comunity will have the same a
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_dev.b">dev.b</code></td>
<td>
<p>The deviation around parameter b for the gaussian in a
community. If 0 all species curve in the comunity will have the same b
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_dev.c">dev.c</code></td>
<td>
<p>The deviation around parameter a for the gaussian in c
community. If 0 all species curve in the comunity will have the same c
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_down.limit">down.limit</code></td>
<td>
<p>The limit under which the gaussian curve will be rounded
down to 0. The default is 1.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_pal">pal</code></td>
<td>
<p>The color palette to be used. Species curves are colored according
to communities. Either a colorspace palette or a vector of the same lenght
as the number of species.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="SyntheticData_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SyntheticData function is intended for the creation of
articficial dataset to test ecological patterns along gradients. The
gaussian curves that it computes are of the form: <code class="reqn">
  a*exp(-(((x-b)^2)/2*(c^2))) </code> The parameters can be interpreted as follow:
a is the maximum height of the gaussian on the y-axis, b is the center of
the gaussian on the x-axis and c is the steepness of the slopes on each
side of the maximum. The gaussians create a set of continuous data that are
akin to abundances. As gaussians of this type cannot reach 0, any value
that is below the down.limit (default is 1) is rounded down to 0.
</p>


<h3>Value</h3>

<p>SyntheticData returns a dataset with numbered species (sp.1, sp.2,
...) as columns. It also plot the obtained data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 3 distinct communities comprising a total of 21 species
SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                SpCo = NULL, Length = 500,
                                Parameters = list(a=rep(60, 3),
                                                  b=c(0,250,500),
                                                  c=rep(0.03,3)),
                                pal = c("#008585", "#FBF2C4", "#C7522B"))

### 3 distinct communities with uneven species numbers
SyntheticTrial &lt;- SyntheticData(SpeciesNum = 21, CommunityNum = 3,
                                SpCo = c(5, 10, 6), Length = 500,
                                Parameters = list(a=rep(60, 3),
                                                  b=c(0,250,500),
                                                  c=rep(0.03,3)),
                                pal = c("#008585", "#FBF2C4", "#C7522B"))




</code></pre>

<hr>
<h2 id='SyntheticDataSeries'>Synthetic data for Space/Time series</h2><span id='topic+SyntheticDataSeries'></span>

<h3>Description</h3>

<p>Synthetic data for Space/Time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SyntheticDataSeries(CommunityPool, CommunityNum, Length = 100,
  SpCo = NULL, SeriesNum, replacement = TRUE,
  range.repl = as.integer(CommunityPool/5), Parameters = list(a = NULL,
  b = NULL, c = NULL), Parameters.repl = TRUE, dev.a = 10,
  dev.b = 10, dev.c = 0, Parameters.range = 10,
  displacement = NULL, pal = NULL, xlab = "Gradient",
  ylab = "Synthetic species", title = "Synthetic data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SyntheticDataSeries_+3A_communitypool">CommunityPool</code></td>
<td>
<p>Total number of species per series. must either be of
length 1 (if the pool of species is of the same length for all communities)
or of length equal to CommunityNum (specifying the species pool for each
community)</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_communitynum">CommunityNum</code></td>
<td>
<p>An integer giving the number of communities.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_length">Length</code></td>
<td>
<p>The lenght of the gradient. Corresponds to the x-axis in a
plot.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_spco">SpCo</code></td>
<td>
<p>The ratio of species per communities. When replacement = T, SpCo
is computed from CommunityPool and range.repl.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_seriesnum">SeriesNum</code></td>
<td>
<p>The number of series to be synthetised.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_replacement">replacement</code></td>
<td>
<p>Logical. Should the species of a community in a given
series be a sample of the possible number of species in this community. See
Details.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_range.repl">range.repl</code></td>
<td>
<p>An integer. Gives the possible range of species turnover in
a community.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_parameters">Parameters</code></td>
<td>
<p>A list containing the parameters (a, b and c) for the
gaussians. Each parameter must be specified for each community. See
Details.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_parameters.repl">Parameters.repl</code></td>
<td>
<p>Logical. Sould the parameters vary between series.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_dev.a">dev.a</code></td>
<td>
<p>The deviation around parameter a for the gaussian in a
community. If 0 all species curve in the comunity will have the same a
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_dev.b">dev.b</code></td>
<td>
<p>The deviation around parameter b for the gaussian in a
community. If 0 all species curve in the comunity will have the same b
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_dev.c">dev.c</code></td>
<td>
<p>The deviation around parameter a for the gaussian in c
community. If 0 all species curve in the comunity will have the same c
parameter.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_parameters.range">Parameters.range</code></td>
<td>
<p>An integer. Gives the possible range of the parameter
variations between two series. The range of variation is the parameter
diveded by the parameters range. Default is 10.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_displacement">displacement</code></td>
<td>
<p>Numeric matrix to control the direction of the changes in
the mean values of the parameters over the series. See examples.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_pal">pal</code></td>
<td>
<p>The color palette to be used. Species curves are colored according
to communities.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis. See plot.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis. See plot.</p>
</td></tr>
<tr><td><code id="SyntheticDataSeries_+3A_title">title</code></td>
<td>
<p>An overall title for the plot. See plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SyntheticDataSeries is a extention of the SyntheticData function and
intended to produce easy and consistent space/time series of artificial
ecological community datasets. The series of dataframes are stored in an
object of class list. The replacement and Parameters.repl arguments allow
the user to choose wether or not the number of species and their
distribution curves should vary among the different series. range.repl is
an integer that define the boundaries  of the interval in which the number
of species can vary - such as the number of species per community is :
<em>sample([[CommunityPool/CommunityNum - range.repl ;
CommunityPool/CommunityNum + range.repl]])</em> The number it takes is then
used to define SpCo. Given the difference of scales between the 3
parameters a, b and c, the Parameters.range argument controls the
variations of the parameters by divison so that they correspond to :
<em>sample([[Parameters - Parameters/Parameters.range ; Parameters +
Parameters/Parameters.range]])</em> The obtained parameters are then used by
the internal SyntheticData function as base parameters for a given series,
on which dev.a, dev.b and dev.c will apply. The other arguments are
equivalent to those of SyntheticData.
</p>


<h3>Value</h3>

<p>SyntheticDataSeries returns a list of datasets with numbered species
(sp.1, sp.2, ...) as columns. The list has length = SeriesNum. It also plot
the obtained data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### 5 datasets of 40 species spread on 4 communities without turnover
##### on the number of species nor variations in their distribution:

SyntheticTrialSeries &lt;- SyntheticDataSeries(CommunityPool = 40,
                                            CommunityNum = 4, SpCo = NULL,
                                            Length = 500, SeriesNum = 5,
                                            Parameters = list(a=rep(60, 4),
                                                              b=c(0,200,350,500),
                                                              c=rep(0.03,4)),
                                            pal = c("#008585", "#B8CDAE", "#E6C186", "#C7522B"),
                                            replacement = FALSE,
                                            Parameters.repl = FALSE)

##### 5 datasets of 40 species spread on 4 communities with species turnover
##### and variations in their distributions along the gradient:

SyntheticTrialSeries &lt;- SyntheticDataSeries(CommunityPool = 40,
                                            CommunityNum = 4, SpCo = NULL,
                                            Length = 500, SeriesNum = 5,
                                            Parameters = list(a=rep(60, 4),
                                                              b=c(0,200,350,500),
                                                              c=rep(0.03,4)),
                                            pal = c("#008585", "#B8CDAE", "#E6C186", "#C7522B"),
                                            replacement = TRUE,
                                            Parameters.repl = TRUE)

##### With a displacement matrix to control the direction of the changes
##### between series:

# Dispalcement matrix (Parameters x Communities):
disp &lt;- matrix(data=c(0,0,0,
                      0,35,-0.0007,
                      0,10,0), nrow = 3, ncol = 3)

Series &lt;- SyntheticDataSeries(CommunityPool = 60, CommunityNum = 3, Length = 500,
                               SeriesNum = 5, replacement = FALSE, SpCo = c(15,15,30),
                               Parameters = list(a = c(60,60,60),
                                                 b = c(-50,-50,400),
                                                 c = c(0.01, 0.01, 0.01)),
                               dev.a=30, dev.b=40, dev.c=0,
                               displacement = disp,
                               pal = c(rep("#008585",15), rep("#FBF2C4",15),
                                       rep("#C7522B",30)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
