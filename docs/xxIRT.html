<!DOCTYPE html><html><head><title>Help for package xxIRT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xxIRT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ata'><p>Automated Test Assembly (ATA)</p></a></li>
<li><a href='#ata_helpers'><p>Helper functions of ATA</p></a></li>
<li><a href='#cat_sim'><p>Simulation of Computerized Adaptive Testing (CAT)</p></a></li>
<li><a href='#cronbach_alpha'><p>Cronbach's alpha</p></a></li>
<li><a href='#estimate_3pl'><p>Estimate 3-parameter-logistic model</p></a></li>
<li><a href='#estimate_gpcm'><p>Estimate Generalizaed Partial Credit Model</p></a></li>
<li><a href='#estimate_grm'><p>Estimate Graded Response Model</p></a></li>
<li><a href='#estimate_helpers'><p>Helper functions of Model Estimation</p></a></li>
<li><a href='#expected_raw_score_dist'><p>#' Distribution of Expected Raw Scores</p></a></li>
<li><a href='#freq'><p>Frequency Counts</p></a></li>
<li><a href='#hermite_gauss'><p>Hermite-Gauss Quadrature</p></a></li>
<li><a href='#model_3pl'><p>3-parameter-logistic model</p></a></li>
<li><a href='#model_gpcm'><p>Generalized Partial Credit Model</p></a></li>
<li><a href='#model_grm'><p>Graded Response Model</p></a></li>
<li><a href='#mst'><p>Computerized Multistage Testing (MST)</p></a></li>
<li><a href='#mst_sim'><p>Simulation of Multistage Testing</p></a></li>
<li><a href='#rmse'><p>Root Mean Squared Error</p></a></li>
<li><a href='#spearman_brown'><p>Spearman Brown Prophecy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Item Response Theory and Computer-Based Testing in R</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-3-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiao Luo [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiao Luo &lt;xluo1986@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of psychometric analysis tools for research and operation, including:
    (1) computation of probability, information, and likelihood for the 3PL, GPCM, and GRM;
    (2) parameter estimation using joint or marginal likelihood estimation method;
    (3) simulation of computerized adaptive testing using built-in or customized algorithms;
    (4) assembly and simulation of multistage testing. 
    The full documentation and tutorials are at <a href="https://github.com/xluo11/xxIRT">https://github.com/xluo11/xxIRT</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/xluo11/xxIRT">https://github.com/xluo11/xxIRT</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/xluo11/xxIRT/issues">https://github.com/xluo11/xxIRT/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, glpkAPI, lpSolveAPI, reshape2, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-21 23:54:08 UTC; xiaoluo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-22 10:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ata'>Automated Test Assembly (ATA)</h2><span id='topic+ata'></span><span id='topic+print.ata'></span><span id='topic+plot.ata'></span><span id='topic+ata_obj_relative'></span><span id='topic+ata_obj_absolute'></span><span id='topic+ata_constraint'></span><span id='topic+ata_item_use'></span><span id='topic+ata_item_enemy'></span><span id='topic+ata_item_fixedvalue'></span><span id='topic+ata_solve'></span>

<h3>Description</h3>

<p><code>ata</code> initiates an ATA model
</p>
<p><code>ata_obj_relative</code> adds a relative objective to the model
</p>
<p><code>ata_obj_absolute</code> adds an absolute objective to the model
</p>
<p><code>ata_constraint</code> adds a constraint to the model
</p>
<p><code>ata_item_use</code> limits the minimum and maximum usage for items
</p>
<p><code>ata_item_enemy</code> adds an enemy-item constraint to the model
</p>
<p><code>ata_item_fixedvalue</code> forces an item to be selected or not selected
</p>
<p><code>ata_solve</code> solves the MIP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ata(pool, num_form = 1, len = NULL, max_use = NULL, ...)

## S3 method for class 'ata'
print(x, ...)

## S3 method for class 'ata'
plot(x, ...)

ata_obj_relative(x, coef, mode = c("max", "min"), tol = NULL,
  negative = FALSE, forms = NULL, collapse = FALSE,
  internal_index = FALSE, ...)

ata_obj_absolute(x, coef, target, equal_tol = FALSE, tol_up = NULL,
  tol_down = NULL, forms = NULL, collapse = FALSE,
  internal_index = FALSE, ...)

ata_constraint(x, coef, min = NA, max = NA, level = NULL,
  forms = NULL, collapse = FALSE, internal_index = FALSE)

ata_item_use(x, min = NA, max = NA, items = NULL)

ata_item_enemy(x, items)

ata_item_fixedvalue(x, items, min = NA, max = NA, forms)

ata_solve(x, solver = c("lpsolve", "glpk"), as.list = TRUE,
  details = TRUE, time_limit = 10, message = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ata_+3A_pool">pool</code></td>
<td>
<p>item pool, a data.frame</p>
</td></tr>
<tr><td><code id="ata_+3A_num_form">num_form</code></td>
<td>
<p>number of forms to be assembled</p>
</td></tr>
<tr><td><code id="ata_+3A_len">len</code></td>
<td>
<p>test length of each form</p>
</td></tr>
<tr><td><code id="ata_+3A_max_use">max_use</code></td>
<td>
<p>maximum use of each item</p>
</td></tr>
<tr><td><code id="ata_+3A_...">...</code></td>
<td>
<p>options, e.g. group, common_items, overlap_items</p>
</td></tr>
<tr><td><code id="ata_+3A_x">x</code></td>
<td>
<p>an ATA object</p>
</td></tr>
<tr><td><code id="ata_+3A_coef">coef</code></td>
<td>
<p>coefficients of the objective function</p>
</td></tr>
<tr><td><code id="ata_+3A_mode">mode</code></td>
<td>
<p>optimization mode: 'max' for maximization and 'min' for minimization</p>
</td></tr>
<tr><td><code id="ata_+3A_tol">tol</code></td>
<td>
<p>the tolerance paraemter</p>
</td></tr>
<tr><td><code id="ata_+3A_negative">negative</code></td>
<td>
<p><code>TRUE</code> when the objective function is expected to be negative</p>
</td></tr>
<tr><td><code id="ata_+3A_forms">forms</code></td>
<td>
<p>forms where objectives are added. <code>NULL</code> for all forms</p>
</td></tr>
<tr><td><code id="ata_+3A_collapse">collapse</code></td>
<td>
<p><code>TRUE</code> to collapse into one objective function</p>
</td></tr>
<tr><td><code id="ata_+3A_internal_index">internal_index</code></td>
<td>
<p><code>TRUE</code> to use internal form indices</p>
</td></tr>
<tr><td><code id="ata_+3A_target">target</code></td>
<td>
<p>the target values of the objective function</p>
</td></tr>
<tr><td><code id="ata_+3A_equal_tol">equal_tol</code></td>
<td>
<p><code>TRUE</code> to force upward and downward tolerance to be equal</p>
</td></tr>
<tr><td><code id="ata_+3A_tol_up">tol_up</code></td>
<td>
<p>the range of upward tolerance</p>
</td></tr>
<tr><td><code id="ata_+3A_tol_down">tol_down</code></td>
<td>
<p>the range of downward tolerance</p>
</td></tr>
<tr><td><code id="ata_+3A_min">min</code></td>
<td>
<p>the lower bound of the constraint</p>
</td></tr>
<tr><td><code id="ata_+3A_max">max</code></td>
<td>
<p>the upper bound of the constraint</p>
</td></tr>
<tr><td><code id="ata_+3A_level">level</code></td>
<td>
<p>the level of a categorical variable to be constrained</p>
</td></tr>
<tr><td><code id="ata_+3A_items">items</code></td>
<td>
<p>a vector of item indices, <code>NULL</code> for all items</p>
</td></tr>
<tr><td><code id="ata_+3A_solver">solver</code></td>
<td>
<p>use 'lpsolve' for lp_solve 5.5 or 'glpk' for GLPK</p>
</td></tr>
<tr><td><code id="ata_+3A_as.list">as.list</code></td>
<td>
<p><code>TRUE</code> to return results in a list; otherwise, a data frame</p>
</td></tr>
<tr><td><code id="ata_+3A_details">details</code></td>
<td>
<p><code>TRUE</code> to print detailed information</p>
</td></tr>
<tr><td><code id="ata_+3A_time_limit">time_limit</code></td>
<td>
<p>the time limit in seconds passed along to solvers</p>
</td></tr>
<tr><td><code id="ata_+3A_message">message</code></td>
<td>
<p><code>TRUE</code> to print messages from solvers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ATA model stores the definition of a MIP model. <code>ata_solve</code> 
converts the model definition to a real MIP object and attempts to solve it.
</p>
<p><code>ata_obj_relative</code>: 
when mode='max', maximize (y-tol), subject to y &lt;= sum(x) &lt;= y+tol;
when mode='min', minimize (y+tol), subject to y-tol &lt;= sum(x) &lt;= y.
When <code>negative</code> is <code>TRUE</code>, y &lt; 0, tol &gt; 0.
<code>coef</code> can be a numeric vector that has the same length with the pool or forms, 
or a variable name in the pool, or a numeric vector of theta points.
When <code>tol</code> is <code>NULL</code>, it is optimized; when <code>FALSE</code>, ignored; 
when a number, fixed; when a range, constrained with lower and upper bounds.
</p>
<p><code>ata_obj_absolute</code> minimizes y0+y1 subject to t-y0 &lt;= sum(x) &lt;= t+y1.
</p>
<p>When <code>level</code> is <code>NA</code>, it is assumed that the constraint is on
a quantitative item property; otherwise, a categorical item property. 
<code>coef</code> can be a variable name, a constant, or a numeric vector that has
the same size as the pool.
</p>
<p><code>ata_solve</code> takes control options in <code>...</code>. 
For lpsolve, see <code>lpSolveAPI::lp.control.options</code>.
For glpk, see <code>glpkAPI::glpkConstants</code><br />
Once the model is solved, additional data are added to the model.
<code>status</code> shows the status of the solution, <code>optimum</code> 
the optimal value of the objective fucntion found in the solution, 
<code>obj_vars</code> the values of two critical variables in the objective
function, <code>result</code> the assembly results in a binary matrix, and 
<code>items</code> the assembled items
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate a pool of 100 items
n_items &lt;- 100
pool &lt;- with(model_3pl_gendata(1, nitems), data.frame(id=1:n_items, a=a, b=b, c=c))
pool$content &lt;- sample(1:3, n_items, replace=TRUE)
pool$time &lt;- round(rlnorm(n_items, log(60), .2))
pool$group &lt;- sort(sample(1:round(n_items/3), n_items, replace=TRUE))

## ex. 1: four 10-item forms, maximize b parameter
x &lt;- ata(pool, 4, len=10, max_use=1)
x &lt;- ata_obj_relative(x, "b", "max")
x &lt;- ata_solve(x, timeout=5)
data.frame(form=1:4, b=sapply(x$items, function(x) mean(x$b)))

## ex. 2: four 10-item forms, minimize b parameter
x &lt;- ata(pool, 4, len=10, max_use=1)
x &lt;- ata_obj_relative(x, "b", "min", negative=TRUE)
x &lt;- ata_solve(x, as.list=FALSE, timeout=5)
with(x$items, aggregate(b, by=list(form=form), mean))

## ex. 3: two 10-item forms, mean(b)=0, sd(b)=1
## content = (3, 3, 4), avg. time = 58--62 seconds
constr &lt;- data.frame(name='content',level=1:3, min=c(3,3,4), max=c(3,3,4), stringsAsFactors=F)
constr &lt;- rbind(constr, c('time', NA, 58*10, 62*10))
x &lt;- ata(pool, 2, len=10, max_use=1)
x &lt;- ata_obj_absolute(x, pool$b, 0*10)
x &lt;- ata_obj_absolute(x, (pool$b-0)^2, 1*10)
for(i in 1:nrow(constr))
  x &lt;- with(constr, ata_constraint(x, name[i], min[i], max[i], level=level[i]))
x &lt;- ata_solve(x, timeout=5)
sapply(x$items, function(x) c(mean=mean(x$b), sd=sd(x$b)))

## ex. 4: two 10-item forms, max TIF over (-1, 1), consider item sets
x &lt;- ata(pool, 2, len=10, max_use=1, group="group")
x &lt;- ata_obj_relative(x, seq(-1, 1, .5), 'max')
x &lt;- ata_solve(x, timeout=5)
plot(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='ata_helpers'>Helper functions of ATA</h2><span id='topic+ata_helpers'></span><span id='topic+ata_append_constraints'></span><span id='topic+ata_form_index'></span><span id='topic+ata_obj_coef'></span><span id='topic+ata_solve_lpsolve'></span><span id='topic+ata_solve_glpk'></span>

<h3>Description</h3>

<p>miscellaneous helper functions of ATA
</p>
<p><code>ata_append_constraints</code> appends constraint definitions to the model
</p>
<p><code>ata_form_index</code> converts input forms into actual form indices in the model
</p>
<p><code>ata_obj_coef</code> processes input coefficients of the objective functions
</p>
<p><code>ata_solve_lpsolve</code> solves the the MIP model using lp_solve
</p>
<p><code>ata_solve_glpk</code> solves the the MIP model using GLPK
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ata_append_constraints(x, mat, dir, rhs)

ata_form_index(x, forms, collapse, internal_index)

ata_obj_coef(x, coef, compensate)

ata_solve_lpsolve(x, time_limit, message, ...)

ata_solve_glpk(x, time_limit, message, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ata_helpers_+3A_mat">mat</code></td>
<td>
<p>coefficient matrix</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_dir">dir</code></td>
<td>
<p>direction</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_rhs">rhs</code></td>
<td>
<p>right-hand-side value</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_forms">forms</code></td>
<td>
<p>indices of forms</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_collapse">collapse</code></td>
<td>
<p><code>TRUE</code> to collaspe forms into one form</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_internal_index">internal_index</code></td>
<td>
<p><code>TRUE</code> to use internal form indices</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_coef">coef</code></td>
<td>
<p>coefficients</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_compensate">compensate</code></td>
<td>
<p><code>TRUE</code> to combine coefficients</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_time_limit">time_limit</code></td>
<td>
<p>the time limit in seconds passed along to solvers</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_message">message</code></td>
<td>
<p><code>TRUE</code> to print messages from solvers</p>
</td></tr>
<tr><td><code id="ata_helpers_+3A_...">...</code></td>
<td>
<p>additional control parameters for solvers</p>
</td></tr>
</table>

<hr>
<h2 id='cat_sim'>Simulation of Computerized Adaptive Testing (CAT)</h2><span id='topic+cat_sim'></span><span id='topic+cat_estimate_mle'></span><span id='topic+cat_estimate_eap'></span><span id='topic+cat_estimate_hybrid'></span><span id='topic+cat_stop_default'></span><span id='topic+cat_select_maxinfo'></span><span id='topic+cat_select_ccat'></span><span id='topic+cat_select_shadow'></span><span id='topic+print.cat'></span><span id='topic+plot.cat'></span><span id='topic+cat_stop_projection'></span>

<h3>Description</h3>

<p><code>cat_sim</code> runs a simulation of CAT. Use <code>theta</code> in options to set the starting
value of theta estimate.
</p>
<p><code>cat_estimate_mle</code> is the maximum likelihood estimation rule. Use 
<code>map_len</code> to apply MAP to the first K items and use <code>map_prior</code> to set the
prior for MAP.
</p>
<p><code>cat_estimate_eap</code> is the expected a posteriori estimation rule,
using <code>eap_mean</code> and <code>eap_sd</code> option parameters as the prior
</p>
<p><code>cat_estimate_hybrid</code> is a hybrid estimation rule, which uses MLE for
mixed responses and EAP for all 1's or 0's responses
</p>
<p><code>cat_stop_default</code> is a three-way stopping rule. When <code>stop_se</code>
is set in the options, it uses the standard error stopping rule. When
<code>stop_mi</code> is set in the options, it uses the minimum information stopping rule. When
<code>stop_cut</code> is set in the options, it uses the confidence interval (set by <code>ci_width</code>)
stopping rule.
</p>
<p><code>cat_select_maxinfo</code> is the maximum information selection rule. Use <code>group</code>
(a numeric vector) to group items belonging to the same set. Use <code>info_random</code> to implement
the random-esque item exposure control method.
</p>
<p><code>cat_select_ccat</code> is the constrained CAT selection rule. Use
<code>ccat_var</code> to set the content variable in the pool. Use <code>ccat_perc</code> to set
the desired content distribution, with the name of each element being the content code
and tue value of each element being the percentage. Use <code>ccat_random</code> to add randomness
to initial item selections.
</p>
<p><code>cat_select_shadow</code> is the shadow-test selection rule. Use <code>shadow_id</code>
to group item sets. Use <code>constraints</code> to set constraints. Constraints should be in a data.frame
with four columns: var (variable name), level (variable level, <code>NA</code> for quantitative variable), 
min (lower bound), and max (upper bound).
</p>
<p><code>cat_stop_projection</code> is the projection-based stopping rule. Use 
<code>projection_method</code> to choose the projection method ('info' or 'diff'). Use
<code>stop_cut</code> to set the cut score. Use <code>constraints</code> to set the constraints.
Constraints should be a data.frame with columns: var (variable name), 
level (variable level, <code>NA</code> for quantitative varialbe), min (lower bound), max (upper bound)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_sim(true, pool, ...)

cat_estimate_mle(len, theta, stats, admin, pool, opts)

cat_estimate_eap(len, theta, stats, admin, pool, opts)

cat_estimate_hybrid(len, theta, stats, admin, pool, opts)

cat_stop_default(len, theta, stats, admin, pool, opts)

cat_select_maxinfo(len, theta, stats, admin, pool, opts)

cat_select_ccat(len, theta, stats, admin, pool, opts)

cat_select_shadow(len, theta, stats, admin, pool, opts)

## S3 method for class 'cat'
print(x, ...)

## S3 method for class 'cat'
plot(x, ...)

cat_stop_projection(len, theta, stats, admin, pool, opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_sim_+3A_true">true</code></td>
<td>
<p>the true theta</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_pool">pool</code></td>
<td>
<p>the item pool (data.frame)</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_...">...</code></td>
<td>
<p>option/control parameters</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_len">len</code></td>
<td>
<p>the current test length</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_theta">theta</code></td>
<td>
<p>the current theta estimate</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_stats">stats</code></td>
<td>
<p>a matrix of responses, theta estimate, information and std error</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_admin">admin</code></td>
<td>
<p>a data frame of administered items</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_opts">opts</code></td>
<td>
<p>a list of option/control parameters</p>
</td></tr>
<tr><td><code id="cat_sim_+3A_x">x</code></td>
<td>
<p>a <code>cat</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>...</code> takes a variety of option/control parameters for the simulations from users. 
<code>min</code> and max are mandatory for setting limits on the test length. User-defined
selection, estimation, and stopping rules are also passed to the simulator via options.<br />
To write a new rule, the function siganiture must be: <code>function(len, theta, stats, admin, pool, opts)</code>.
See built-in rules for examples.
</p>


<h3>Value</h3>

<p><code>cat_sim</code> returns a <code>cat</code> object
</p>
<p>an estimation rule should return a theta estimate
</p>
<p>a stopping rule should return a boolean: <code>TRUE</code> to stop the CAT, <code>FALSE</code> to continue
</p>
<p>a selection rule should return a list of (a) the selected item and (b) the updated pool
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate a 100-item pool
num_items &lt;- 100
pool &lt;- with(model_3pl_gendata(1, num_items), data.frame(a=a, b=b, c=c))
pool$set_id &lt;- sample(1:30, num_items, replace=TRUE)
pool$content &lt;- sample(1:3, num_items, replace=TRUE)
pool$time &lt;- round(rlnorm(num_items, mean=4.1, sd=.2))

## MLE, EAP, and hybrid estimation rule
cat_sim(1.0, pool, min=10, max=20, estimate_rule=cat_estimate_mle)
cat_sim(1.0, pool, min=10, max=20, estimate_rule=cat_estimate_eap)
cat_sim(1.0, pool, min=10, max=20, estimate_rule=cat_estimate_hybrid)

## SE, MI, and CI stopping rule
cat_sim(1.0, pool, min=10, max=20, stop_se=.3)
cat_sim(1.0, pool, min=10, max=20, stop_mi=.6)
cat_sim(1.0, pool, min=10, max=20, stop_cut=0)
cat_sim(1.0, pool, min=10, max=20, stop_cut=0, ci_width=2.58)

## maximum information selection with item sets
cat_sim(1.0, pool, min=10, max=20, group="set_id")$admin

## maximum information with item exposure control
cat_sim(1.0, pool, min=10, max=20, info_random=5)$admin

## Constrained-CAT selection rule with and without initial randomness
cat_sim(1.0, pool, min=10, max=20, select_rule=cat_select_ccat, 
        ccat_var="content", ccat_perc=c("1"=.2, "2"=.3, "3"=.5))
cat_sim(1.0, pool, min=10, max=20, select_rule=cat_select_ccat, ccat_random=5,
        ccat_var="content", ccat_perc=c("1"=.2, "2"=.3, "3"=.5))

## Shadow-test selection rule
cons &lt;- data.frame(var='content', level=1:3, min=c(3,3,4), max=c(3,3,4))
cons &lt;- rbind(cons, data.frame(var='time', level=NA, min=55*10, max=65*10))
cat_sim(1.0, pool, min=10, max=10, select_rule=cat_select_shadow, constraints=cons)

## Projection-based stopping rule
cons &lt;- data.frame(var='content', level=1:3, min=5, max=15)
cons &lt;- rbind(cons, data.frame(var='time', level=NA, min=60*20, max=60*40))
cat_sim(1.0, pool, min=20, max=40, select_rule=cat_select_shadow, stop_rule=cat_stop_projection, 
        projection_method="diff", stop_cut=0, constraints=cons)

## End(Not run)
</code></pre>

<hr>
<h2 id='cronbach_alpha'>Cronbach's alpha</h2><span id='topic+cronbach_alpha'></span>

<h3>Description</h3>

<p><code>cronbach_alpha</code> computes Cronbach's alpha internal consistency reliability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cronbach_alpha(responses)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cronbach_alpha_+3A_responses">responses</code></td>
<td>
<p>the oberved responses, 2d matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cronbach_alpha(model_3pl_gendata(1000, 20)$u)
</code></pre>

<hr>
<h2 id='estimate_3pl'>Estimate 3-parameter-logistic model</h2><span id='topic+estimate_3pl'></span><span id='topic+model_3pl_eap_scoring'></span><span id='topic+model_3pl_map_scoring'></span><span id='topic+model_3pl_dv_Pt'></span><span id='topic+model_3pl_dv_Pa'></span><span id='topic+model_3pl_dv_Pb'></span><span id='topic+model_3pl_dv_Pc'></span><span id='topic+model_3pl_dv_jmle'></span><span id='topic+model_3pl_estimate_jmle'></span><span id='topic+model_3pl_dv_mmle'></span><span id='topic+model_3pl_estimate_mmle'></span><span id='topic+model_3pl_fitplot'></span>

<h3>Description</h3>

<p>Estimate the 3PL model using the maximum likelihood estimation
</p>
<p><code>model_3pl_eap_scoring</code> scores response vectors using the EAP method
</p>
<p><code>model_3pl_map_scoring</code> scores response vectors using the MAP method
</p>
<p><code>model_3pl_dv_jmle</code> calculates the first and second derivatives for
the joint maximum likelihood estimation
</p>
<p><code>model_3pl_estimate_jmle</code> estimates the parameters using the 
joint maximum likelihood estimation (JMLE) method
</p>
<p><code>model_3pl_dv_mmle</code> calculates the first and second derivatives for
the marginal maximum likelihood estimation
</p>
<p><code>model_3pl_estimate_mmle</code> estimates the parameters using the 
marginal maximum likelihood estimation (MMLE) method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_3pl_eap_scoring(u, a, b, c, D = 1.702, prior = c(0, 1),
  bound = c(-3, 3))

model_3pl_map_scoring(u, a, b, c, D = 1.702, prior = c(0, 1),
  bound = c(-3, 3), nr_iter = 30, nr_conv = 0.001)

model_3pl_dv_Pt(t, a, b, c, D)

model_3pl_dv_Pa(t, a, b, c, D)

model_3pl_dv_Pb(t, a, b, c, D)

model_3pl_dv_Pc(t, a, b, c, D)

model_3pl_dv_jmle(dv, u)

model_3pl_estimate_jmle(u, t = NA, a = NA, b = NA, c = NA,
  D = 1.702, iter = 100, conv = 1, nr_iter = 10, nr_conv = 0.001,
  scale = c(0, 1), bounds_t = c(-3, 3), bounds_a = c(0.01, 2),
  bounds_b = c(-3, 3), bounds_c = c(0, 0.25), priors = list(t = c(0,
  1), a = c(-0.1, 0.2), b = c(0, 1), c = c(4, 20)), decay = 1,
  debug = FALSE, true_params = NULL)

model_3pl_dv_mmle(pdv_fn, u, quad, a, b, c, D)

model_3pl_estimate_mmle(u, t = NA, a = NA, b = NA, c = NA,
  D = 1.702, iter = 100, conv = 1, nr_iter = 10, nr_conv = 0.001,
  bounds_t = c(-3, 3), bounds_a = c(0.01, 2), bounds_b = c(-3, 3),
  bounds_c = c(0, 0.25), priors = list(t = c(0, 1), a = c(-0.1, 0.2), b
  = c(0, 1), c = c(4, 20)), decay = 1, quad_degree = "11",
  scoring = c("eap", "map"), debug = FALSE, true_params = NULL)

model_3pl_fitplot(u, t, a, b, c, D = 1.702, index = NULL,
  intervals = seq(-3, 3, 0.5), show_points = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_3pl_+3A_u">u</code></td>
<td>
<p>observed response matrix, 2d matrix</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_b">b</code></td>
<td>
<p>difficulty parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_c">c</code></td>
<td>
<p>pseudo-guessing parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_prior">prior</code></td>
<td>
<p>the prior distribution</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_nr_iter">nr_iter</code></td>
<td>
<p>the maximum iterations of newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_nr_conv">nr_conv</code></td>
<td>
<p>the convegence criterion for newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_iter">iter</code></td>
<td>
<p>the maximum iterations</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_conv">conv</code></td>
<td>
<p>the convergence criterion of the -2 log-likelihood</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_scale">scale</code></td>
<td>
<p>the meand and SD of the theta scale, N(0, 1) for JMLE by default</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_bounds_t">bounds_t</code></td>
<td>
<p>bounds of ability parameters</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_bounds_a">bounds_a</code></td>
<td>
<p>bounds of discrimination parameters</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_bounds_b">bounds_b</code></td>
<td>
<p>bounds of difficulty parameters</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_bounds_c">bounds_c</code></td>
<td>
<p>bounds of guessing parameters</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_priors">priors</code></td>
<td>
<p>a list of prior distributions</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_decay">decay</code></td>
<td>
<p>decay rate</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_debug">debug</code></td>
<td>
<p>TRUE to print debuggin information</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_true_params">true_params</code></td>
<td>
<p>a list of true parameters for evaluating the estimation accuracy</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_pdv_fn">pdv_fn</code></td>
<td>
<p>the function to compute derivatives of P w.r.t the estimating parameters</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_quad_degree">quad_degree</code></td>
<td>
<p>the number of quadrature points</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_scoring">scoring</code></td>
<td>
<p>the scoring method: 'eap' or 'map'</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_index">index</code></td>
<td>
<p>the indices of items being plotted</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_intervals">intervals</code></td>
<td>
<p>intervals on the x-axis</p>
</td></tr>
<tr><td><code id="estimate_3pl_+3A_show_points">show_points</code></td>
<td>
<p>TRUE to show points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_3pl_gendata(10, 40), cbind(true=t, est=model_3pl_eap_scoring(u, a, b, c)$t))
with(model_3pl_gendata(10, 40), cbind(true=t, est=model_3pl_map_scoring(u, a, b, c)$t))
## Not run: 
# generate data
x &lt;- model_3pl_gendata(2000, 40)
# free estimation
y &lt;- model_3pl_estimate_jmle(x$u, true_params=x)
# fix c-parameters
y &lt;- model_3pl_estimate_jmle(x$u, c=0, true_params=x)
# no priors
y &lt;- model_3pl_estimate_jmle(x$u, priors=NULL, iter=30, debug=T)

## End(Not run)
## Not run: 
# generate data
x &lt;- model_3pl_gendata(2000, 40)
# free estimation
y &lt;- model_3pl_estimate_mmle(x$u, true_params=x)
# fix c-parameters
y &lt;- model_3pl_estimate_mmle(x$u, c=0, true_params=x)
# no priors
y &lt;- model_3pl_estimate_mmle(x$u, priors=NULL, iter=30, debug=T)

## End(Not run)
with(model_3pl_gendata(1000, 20), model_3pl_fitplot(u, t, a, b, c, index=c(1, 3, 5)))
</code></pre>

<hr>
<h2 id='estimate_gpcm'>Estimate Generalizaed Partial Credit Model</h2><span id='topic+estimate_gpcm'></span><span id='topic+model_gpcm_eap_scoring'></span><span id='topic+model_gpcm_map_scoring'></span><span id='topic+model_gpcm_dv_Pt'></span><span id='topic+model_gpcm_dv_Pa'></span><span id='topic+model_gpcm_dv_Pb'></span><span id='topic+model_gpcm_dv_Pd'></span><span id='topic+model_gpcm_dv_jmle'></span><span id='topic+model_gpcm_estimate_jmle'></span><span id='topic+model_gpcm_dv_mmle'></span><span id='topic+model_gpcm_estimate_mmle'></span><span id='topic+model_gpcm_fitplot'></span>

<h3>Description</h3>

<p>Estimate the GPCM using the maximum likelihood estimation
</p>
<p><code>model_gpcm_eap_scoring</code> scores response vectors using the EAP method
</p>
<p><code>model_gpcm_map_scoring</code> scores response vectors using maximum a posteriori
</p>
<p><code>model_gpcm_estimate_jmle</code> estimates the parameters using the 
joint maximum likelihood estimation (JMLE) method
</p>
<p><code>model_gpcm_estimate_mmle</code> estimates the parameters using the 
marginal maximum likelihood estimation (MMLE) method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_gpcm_eap_scoring(u, a, b, d, D = 1.702, prior = c(0, 1),
  bound = c(-3, 3))

model_gpcm_map_scoring(u, a, b, d, D = 1.702, prior = NULL,
  bound = c(-3, 3), nr_iter = 30, nr_conv = 0.001)

model_gpcm_dv_Pt(t, a, b, d, D)

model_gpcm_dv_Pa(t, a, b, d, D)

model_gpcm_dv_Pb(t, a, b, d, D)

model_gpcm_dv_Pd(t, a, b, d, D)

model_gpcm_dv_jmle(ix, dvp)

model_gpcm_estimate_jmle(u, t = NA, a = NA, b = NA, d = NA,
  D = 1.702, iter = 100, nr_iter = 10, conv = 1, nr_conv = 0.001,
  scale = c(0, 1), bounds_t = c(-4, 4), bounds_a = c(0.01, 2),
  bounds_b = c(-4, 4), bounds_d = c(-4, 4), priors = list(t = c(0,
  1), a = c(-0.1, 0.2), b = c(0, 1), d = c(0, 1)), decay = 1,
  debug = FALSE, true_params = NULL)

model_gpcm_dv_mmle(u_ix, quad, pdv)

model_gpcm_estimate_mmle(u, t = NA, a = NA, b = NA, d = NA,
  D = 1.702, iter = 100, nr_iter = 10, conv = 1, nr_conv = 0.001,
  bounds_t = c(-4, 4), bounds_a = c(0.01, 2), bounds_b = c(-4, 4),
  bounds_d = c(-4, 4), priors = list(t = c(0, 1), a = c(-0.1, 0.2), b =
  c(0, 1), d = c(0, 1)), decay = 1, quad_degree = "11",
  scoring = c("eap", "map"), debug = FALSE, true_params = NULL)

model_gpcm_fitplot(u, t, a, b, d, D = 1.702, insert_d0 = NULL,
  index = NULL, intervals = seq(-3, 3, 0.5), show_points = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_gpcm_+3A_u">u</code></td>
<td>
<p>the observed response matrix, 2d matrix</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_b">b</code></td>
<td>
<p>difficulty parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_d">d</code></td>
<td>
<p>category parameters, 2d matrix (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_prior">prior</code></td>
<td>
<p>the prior distribution</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_nr_iter">nr_iter</code></td>
<td>
<p>the maximum iterations of newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_nr_conv">nr_conv</code></td>
<td>
<p>the convegence criterion for newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_ix">ix</code></td>
<td>
<p>the 3d indices</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_dvp">dvp</code></td>
<td>
<p>the derivatives of P</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_iter">iter</code></td>
<td>
<p>the maximum iterations</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_conv">conv</code></td>
<td>
<p>the convergence criterion of the -2 log-likelihood</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_scale">scale</code></td>
<td>
<p>the scale of theta parameters</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_bounds_t">bounds_t</code></td>
<td>
<p>bounds of ability parameters</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_bounds_a">bounds_a</code></td>
<td>
<p>bounds of discrimination parameters</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_bounds_b">bounds_b</code></td>
<td>
<p>bounds of location parameters</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_bounds_d">bounds_d</code></td>
<td>
<p>bounds of category parameters</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_priors">priors</code></td>
<td>
<p>a list of prior distributions</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_decay">decay</code></td>
<td>
<p>decay rate</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_debug">debug</code></td>
<td>
<p>TRUE to print debuggin information</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_true_params">true_params</code></td>
<td>
<p>a list of true parameters for evaluating the estimation accuracy</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_quad_degree">quad_degree</code></td>
<td>
<p>the number of quadrature points</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_scoring">scoring</code></td>
<td>
<p>the scoring method: 'eap' or 'map'</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_insert_d0">insert_d0</code></td>
<td>
<p>insert an initial category value</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_index">index</code></td>
<td>
<p>the indices of items being plotted</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_intervals">intervals</code></td>
<td>
<p>intervals on the x-axis</p>
</td></tr>
<tr><td><code id="estimate_gpcm_+3A_show_points">show_points</code></td>
<td>
<p>TRUE to show points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_gpcm_gendata(10, 40, 3), cbind(true=t, est=model_gpcm_eap_scoring(u, a, b, d)$t))
with(model_gpcm_gendata(10, 40, 3), cbind(true=t, est=model_gpcm_map_scoring(u, a, b, d)$t))
## Not run: 
# generate data
x &lt;- model_gpcm_gendata(1000, 40, 3)
# free calibration
y &lt;- model_gpcm_estimate_jmle(x$u, true_params=x)
# no priors
y &lt;- model_gpcm_estimate_jmle(x$u, priors=NULL, true_params=x)

## End(Not run)
## Not run: 
# generate data
x &lt;- model_gpcm_gendata(1000, 40, 3)
# free estimation
y &lt;- model_gpcm_estimate_mmle(x$u, true_params=x)
# no priors
y &lt;- model_gpcm_estimate_mmle(x$u, priors=NULL, true_params=x)

## End(Not run)
with(model_gpcm_gendata(1000, 20, 3), model_gpcm_fitplot(u, t, a, b, d, index=c(1, 3, 5)))
</code></pre>

<hr>
<h2 id='estimate_grm'>Estimate Graded Response Model</h2><span id='topic+estimate_grm'></span><span id='topic+model_grm_eap_scoring'></span><span id='topic+model_grm_map_scoring'></span><span id='topic+model_grm_dv_Pt'></span><span id='topic+model_grm_dv_Pa'></span><span id='topic+model_grm_dv_Pb'></span><span id='topic+model_grm_dv_jmle'></span><span id='topic+model_grm_estimate_jmle'></span><span id='topic+model_grm_dv_mmle'></span><span id='topic+model_grm_estimate_mmle'></span><span id='topic+model_grm_fitplot'></span>

<h3>Description</h3>

<p>Estimate the GRM using the maximum likelihood estimation
</p>
<p><code>model_grm_eap_scoring</code> scores response vectors using the EAP method
</p>
<p><code>model_grm_map_scoring</code> scores response vectors using the MAP method
</p>
<p><code>model_grm_estimate_jmle</code> estimates the parameters using the 
joint maximum likelihood estimation (JMLE) method
</p>
<p><code>model_grm_estimate_mmle</code> estimates the parameters using the 
marginal maximum likelihood estimation (MMLE) method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_grm_eap_scoring(u, a, b, D = 1.702, prior = c(0, 1),
  bound = c(-3, 3))

model_grm_map_scoring(u, a, b, D = 1.702, prior = NULL, bound = c(-3,
  3), nr_iter = 30, nr_conv = 0.001)

model_grm_dv_Pt(t, a, b, D)

model_grm_dv_Pa(t, a, b, D)

model_grm_dv_Pb(t, a, b, D)

model_grm_dv_jmle(ix, dvp)

model_grm_estimate_jmle(u, t = NA, a = NA, b = NA, D = 1.702,
  iter = 100, nr_iter = 10, conv = 1, nr_conv = 0.001,
  scale = c(0, 1), bounds_t = c(-4, 4), bounds_a = c(0.01, 2),
  bounds_b = c(-4, 4), priors = list(t = c(0, 1), a = c(-0.1, 0.2), b =
  c(0, 1)), decay = 1, debug = FALSE, true_params = NULL)

model_grm_dv_mmle(u_ix, quad, pdv)

model_grm_estimate_mmle(u, t = NA, a = NA, b = NA, d = NA,
  D = 1.702, iter = 100, nr_iter = 10, conv = 1, nr_conv = 0.001,
  bounds_t = c(-4, 4), bounds_a = c(0.01, 2), bounds_b = c(-4, 4),
  bounds_d = c(-4, 4), priors = list(t = c(0, 1), a = c(-0.1, 0.2), b =
  c(0, 1)), decay = 1, quad_degree = "11", scoring = c("eap", "map"),
  debug = FALSE, true_params = NULL)

model_grm_fitplot(u, t, a, b, D = 1.702, index = NULL,
  intervals = seq(-3, 3, 0.5), show_points = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_grm_+3A_u">u</code></td>
<td>
<p>the observed response matrix, 2d matrix</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_b">b</code></td>
<td>
<p>difficulty parameters, 2d matrix (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_prior">prior</code></td>
<td>
<p>the prior distribution</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_nr_iter">nr_iter</code></td>
<td>
<p>the maximum iterations of newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_nr_conv">nr_conv</code></td>
<td>
<p>the convegence criterion of newton-raphson</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector (fixed value) or NA (freely estimate)</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_ix">ix</code></td>
<td>
<p>the 3d indices</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_dvp">dvp</code></td>
<td>
<p>the derivatives of P</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_iter">iter</code></td>
<td>
<p>the maximum iterations</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_conv">conv</code></td>
<td>
<p>the convergence criterion for the -2 log-likelihood</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_scale">scale</code></td>
<td>
<p>the scale of theta parameters</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_bounds_t">bounds_t</code></td>
<td>
<p>bounds of ability parameters</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_bounds_a">bounds_a</code></td>
<td>
<p>bounds of discrimination parameters</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_bounds_b">bounds_b</code></td>
<td>
<p>bounds of location parameters</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_priors">priors</code></td>
<td>
<p>a list of prior distributions</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_decay">decay</code></td>
<td>
<p>decay rate</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_debug">debug</code></td>
<td>
<p>TRUE to print debuggin information</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_true_params">true_params</code></td>
<td>
<p>a list of true parameters for evaluating the estimation accuracy</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_quad_degree">quad_degree</code></td>
<td>
<p>the number of quadrature points</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_scoring">scoring</code></td>
<td>
<p>the scoring method: 'eap' or 'map'</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_index">index</code></td>
<td>
<p>the indices of items being plotted</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_intervals">intervals</code></td>
<td>
<p>intervals on the x-axis</p>
</td></tr>
<tr><td><code id="estimate_grm_+3A_show_points">show_points</code></td>
<td>
<p>TRUE to show points</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_grm_gendata(10, 50, 3), cbind(true=t, est=model_grm_eap_scoring(u, a, b)$t))
with(model_grm_gendata(10, 50, 3), cbind(true=t, est=model_grm_map_scoring(u, a, b)$t))
## Not run: 
# generate data
x &lt;- model_grm_gendata(1000, 40, 3)
# free calibration
y &lt;- model_grm_estimate_jmle(x$u, true_params=x)
# no priors
y &lt;- model_grm_estimate_jmle(x$u, priors=NULL, true_params=x)

## End(Not run)
## Not run: 
# generate data
x &lt;- model_grm_gendata(1000, 40, 3)
# free estimation
y &lt;- model_grm_estimate_mmle(x$u, true_params=x)
# no priors
y &lt;- model_grm_estimate_mmle(x$u, priors=NULL, true_params=x)

## End(Not run)
with(model_grm_gendata(1000, 20, 3), model_grm_fitplot(u, t, a, b, index=c(1, 3, 5)))
</code></pre>

<hr>
<h2 id='estimate_helpers'>Helper functions of Model Estimation</h2><span id='topic+estimate_helpers'></span><span id='topic+estimate_nr_iteration'></span><span id='topic+model_polytomous_3dindex'></span><span id='topic+model_polytomous_3dresponse'></span>

<h3>Description</h3>

<p>miscellaneous helper functions for estimating IRT models
</p>
<p><code>estimate_nr_iteration</code> updates the parameters using the newton-raphson method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_nr_iteration(param, free, dv, h_max, lr, bound)

model_polytomous_3dindex(u)

model_polytomous_3dresponse(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_helpers_+3A_param">param</code></td>
<td>
<p>the parameter being estimated</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_free">free</code></td>
<td>
<p>TRUE to freely estimate specific parameters</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_dv">dv</code></td>
<td>
<p>the first and second derivatives</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_h_max">h_max</code></td>
<td>
<p>the maximum value of h</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_lr">lr</code></td>
<td>
<p>the learning rate</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_bound">bound</code></td>
<td>
<p>the lower and upper bounds of the parameter</p>
</td></tr>
<tr><td><code id="estimate_helpers_+3A_u">u</code></td>
<td>
<p>the observed response, 2d matrix, values start from 0</p>
</td></tr>
</table>

<hr>
<h2 id='expected_raw_score_dist'>#' Distribution of Expected Raw Scores</h2><span id='topic+expected_raw_score_dist'></span>

<h3>Description</h3>

<p>Calculate the distribution of expected raw scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_raw_score_dist(t, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_raw_score_dist_+3A_t">t</code></td>
<td>
<p>the ability parameters, 1d vector</p>
</td></tr>
<tr><td><code id="expected_raw_score_dist_+3A_a">a</code></td>
<td>
<p>the item discrimination parameters, 1d vector</p>
</td></tr>
<tr><td><code id="expected_raw_score_dist_+3A_b">b</code></td>
<td>
<p>the item difficulty parameters, 1d vector</p>
</td></tr>
<tr><td><code id="expected_raw_score_dist_+3A_c">c</code></td>
<td>
<p>the item guessing parameters, 1d vector</p>
</td></tr>
</table>

<hr>
<h2 id='freq'>Frequency Counts</h2><span id='topic+freq'></span>

<h3>Description</h3>

<p>Frequency counts of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq(x, values = NULL, rounding = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_+3A_x">x</code></td>
<td>
<p>a numeric or character vector</p>
</td></tr>
<tr><td><code id="freq_+3A_values">values</code></td>
<td>
<p>valid values, <code>NULL</code> to include all values</p>
</td></tr>
<tr><td><code id="freq_+3A_rounding">rounding</code></td>
<td>
<p>round percentage to n-th decimal places</p>
</td></tr>
</table>

<hr>
<h2 id='hermite_gauss'>Hermite-Gauss Quadrature</h2><span id='topic+hermite_gauss'></span>

<h3>Description</h3>

<p>Pre-computed hermite gaussian quadratures points and weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermite_gauss(degree = c("20", "11", "7"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hermite_gauss_+3A_degree">degree</code></td>
<td>
<p>the degree of hermite-gauss quadrature: '20', '11', '7'</p>
</td></tr>
</table>

<hr>
<h2 id='model_3pl'>3-parameter-logistic model</h2><span id='topic+model_3pl'></span><span id='topic+model_3pl_prob'></span><span id='topic+model_3pl_info'></span><span id='topic+model_3pl_lh'></span><span id='topic+model_3pl_rescale'></span><span id='topic+model_3pl_gendata'></span><span id='topic+model_3pl_plot'></span><span id='topic+model_3pl_plot_loglh'></span>

<h3>Description</h3>

<p>Routine functions for the 3PL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_3pl_prob(t, a, b, c, D = 1.702)

model_3pl_info(t, a, b, c, D = 1.702)

model_3pl_lh(u, t, a, b, c, D = 1.702, log = FALSE)

model_3pl_rescale(t, a, b, c, param = c("t", "b"), mean = 0, sd = 1)

model_3pl_gendata(n_p, n_i, t = NULL, a = NULL, b = NULL, c = NULL,
  D = 1.702, t_dist = c(0, 1), a_dist = c(-0.1, 0.2), b_dist = c(0,
  0.7), c_dist = c(5, 46), missing = NULL)

model_3pl_plot(a, b, c, D = 1.702, type = c("prob", "info"),
  total = FALSE, xaxis = seq(-4, 4, 0.1))

model_3pl_plot_loglh(u, a, b, c, D = 1.702, xaxis = seq(-4, 4, 0.1),
  show_mle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_3pl_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_b">b</code></td>
<td>
<p>difficulty parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_c">c</code></td>
<td>
<p>guessing parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_u">u</code></td>
<td>
<p>observed responses, 2d matrix</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_log">log</code></td>
<td>
<p>True to return log-likelihood</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_param">param</code></td>
<td>
<p>the parameter of the new scale: 't' or 'b'</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_mean">mean</code></td>
<td>
<p>the mean of the new scale</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the new scale</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_n_p">n_p</code></td>
<td>
<p>the number of people to be generated</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_n_i">n_i</code></td>
<td>
<p>the number of items to be generated</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_t_dist">t_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate t-parameters</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_a_dist">a_dist</code></td>
<td>
<p>parameters of the lognormal distribution used to generate a-parameters</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_b_dist">b_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate b-parameters</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_c_dist">c_dist</code></td>
<td>
<p>parameters of the beta distribution used to generate c-parameters</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_missing">missing</code></td>
<td>
<p>the proportion or number of missing responses</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_type">type</code></td>
<td>
<p>the type of plot: 'prob' for item characteristic curve (ICC) and 
'info' for item information function curve (IIFC)</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_total">total</code></td>
<td>
<p>TRUE to sum values over items</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_xaxis">xaxis</code></td>
<td>
<p>the values of x-axis</p>
</td></tr>
<tr><td><code id="model_3pl_+3A_show_mle">show_mle</code></td>
<td>
<p>TRUE to print maximum likelihood estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_3pl_gendata(10, 5), model_3pl_prob(t, a, b, c))
with(model_3pl_gendata(10, 5), model_3pl_info(t, a, b, c))
with(model_3pl_gendata(10, 5), model_3pl_lh(u, t, a, b, c))
model_3pl_gendata(10, 5)
model_3pl_gendata(10, 5, a=1, c=0, missing=.1)
with(model_3pl_gendata(10, 5), model_3pl_plot(a, b, c, type="prob"))
with(model_3pl_gendata(10, 5), model_3pl_plot(a, b, c, type="info", total=TRUE))
with(model_3pl_gendata(5, 50), model_3pl_plot_loglh(u, a, b, c, show_mle=TRUE))
</code></pre>

<hr>
<h2 id='model_gpcm'>Generalized Partial Credit Model</h2><span id='topic+model_gpcm'></span><span id='topic+model_gpcm_prob'></span><span id='topic+model_gpcm_info'></span><span id='topic+model_gpcm_lh'></span><span id='topic+model_gpcm_gendata'></span><span id='topic+model_gpcm_rescale'></span><span id='topic+model_gpcm_plot'></span><span id='topic+model_gpcm_plot_loglh'></span>

<h3>Description</h3>

<p>Routine functions for the GPCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_gpcm_prob(t, a, b, d, D = 1.702, insert_d0 = NULL)

model_gpcm_info(t, a, b, d, D = 1.702, insert_d0 = NULL)

model_gpcm_lh(u, t, a, b, d, D = 1.702, insert_d0 = NULL,
  log = FALSE)

model_gpcm_gendata(n_p, n_i, n_c, t = NULL, a = NULL, b = NULL,
  d = NULL, D = 1.702, sort_d = FALSE, t_dist = c(0, 1),
  a_dist = c(-0.1, 0.2), b_dist = c(0, 0.8), missing = NULL)

model_gpcm_rescale(t, a, b, d, param = c("t", "b"), mean = 0, sd = 1)

model_gpcm_plot(a, b, d, D = 1.702, insert_d0 = NULL,
  type = c("prob", "info"), by_item = FALSE, total = FALSE,
  xaxis = seq(-6, 6, 0.1))

model_gpcm_plot_loglh(u, a, b, d, D = 1.702, insert_d0 = NULL,
  xaxis = seq(-6, 6, 0.1), show_mle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_gpcm_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_b">b</code></td>
<td>
<p>item location parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_d">d</code></td>
<td>
<p>item category parameters, 2d vector</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_insert_d0">insert_d0</code></td>
<td>
<p>insert an initial category value</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_u">u</code></td>
<td>
<p>the observed scores (starting from 0), 2d matrix</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_log">log</code></td>
<td>
<p>TRUE to return log-likelihood</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_n_p">n_p</code></td>
<td>
<p>the number of people to be generated</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_n_i">n_i</code></td>
<td>
<p>the number of items to be generated</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_n_c">n_c</code></td>
<td>
<p>the number of score categories</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_sort_d">sort_d</code></td>
<td>
<p><code>TRUE</code> to sort d parameters for each item</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_t_dist">t_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate t-parameters</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_a_dist">a_dist</code></td>
<td>
<p>parameters of the lognormal distribution parameters of a-parameters</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_b_dist">b_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate b-parameters</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_missing">missing</code></td>
<td>
<p>the proportion or number of missing responses</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_param">param</code></td>
<td>
<p>the parameter of the new scale: 't' or 'b'</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_mean">mean</code></td>
<td>
<p>the mean of the new scale</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the new scale</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_type">type</code></td>
<td>
<p>the type of plot, prob for ICC and info for IIFC</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_by_item">by_item</code></td>
<td>
<p>TRUE to combine categories</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_total">total</code></td>
<td>
<p>TRUE to sum values over items</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_xaxis">xaxis</code></td>
<td>
<p>the values of x-axis</p>
</td></tr>
<tr><td><code id="model_gpcm_+3A_show_mle">show_mle</code></td>
<td>
<p>TRUE to print maximum likelihood values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>NA</code> to represent unused category.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_gpcm_gendata(10, 5, 3), model_gpcm_prob(t, a, b, d))
with(model_gpcm_gendata(10, 5, 3), model_gpcm_info(t, a, b, d))
with(model_gpcm_gendata(10, 5, 3), model_gpcm_lh(u, t, a, b, d))
model_gpcm_gendata(10, 5, 3)
model_gpcm_gendata(10, 5, 3, missing=.1)
# Figure 1 in Muraki, 1992 (APM)
b &lt;- matrix(c(-2,0,2,-.5,0,2,-.5,0,2), nrow=3, byrow=TRUE)
model_gpcm_plot(a=c(1,1,.7), b=rowMeans(b), d=rowMeans(b)-b, D=1.0, insert_d0=0)
# Figure 2 in Muraki, 1992 (APM)
b &lt;- matrix(c(.5,0,NA,0,0,0), nrow=2, byrow=TRUE)
model_gpcm_plot(a=.7, b=rowMeans(b, na.rm=TRUE), d=rowMeans(b, na.rm=TRUE)-b, D=1.0, insert_d0=0)
# Figure 3 in Muraki, 1992 (APM)
b &lt;- matrix(c(1.759,-1.643,3.970,-2.764), nrow=2, byrow=TRUE)
model_gpcm_plot(a=c(.778,.946), b=rowMeans(b), d=rowMeans(b)-b, D=1.0, insert_d0=0)
# Figure 1 in Muraki, 1993 (APM)
b &lt;- matrix(c(0,-2,4,0,-2,2,0,-2,0,0,-2,-2,0,-2,-4), nrow=5, byrow=TRUE)
model_gpcm_plot(a=1, b=rowMeans(b), d=rowMeans(b)-b, D=1.0)
# Figure 2 in Muraki, 1993 (APM)
b &lt;- matrix(c(0,-2,4,0,-2,2,0,-2,0,0,-2,-2,0,-2,-4), nrow=5, byrow=TRUE)
model_gpcm_plot(a=1, b=rowMeans(b), d=rowMeans(b)-b, D=1.0, type='info', by_item=TRUE)
with(model_gpcm_gendata(5, 50, 3), model_gpcm_plot_loglh(u, a, b, d))
</code></pre>

<hr>
<h2 id='model_grm'>Graded Response Model</h2><span id='topic+model_grm'></span><span id='topic+model_grm_prob'></span><span id='topic+model_grm_info'></span><span id='topic+model_grm_lh'></span><span id='topic+model_grm_gendata'></span><span id='topic+model_grm_rescale'></span><span id='topic+model_grm_plot'></span><span id='topic+model_grm_plot_loglh'></span>

<h3>Description</h3>

<p>Routine functions for the GRM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_grm_prob(t, a, b, D = 1.702, raw = FALSE)

model_grm_info(t, a, b, D = 1.702)

model_grm_lh(u, t, a, b, D = 1.702, log = FALSE)

model_grm_gendata(n_p, n_i, n_c, t = NULL, a = NULL, b = NULL,
  D = 1.702, t_dist = c(0, 1), a_dist = c(-0.1, 0.2), b_dist = c(0,
  0.8), missing = NULL)

model_grm_rescale(t, a, b, param = c("t", "b"), mean = 0, sd = 1)

model_grm_plot(a, b, D = 1.702, type = c("prob", "info"),
  by_item = FALSE, total = FALSE, xaxis = seq(-6, 6, 0.1),
  raw = FALSE)

model_grm_plot_loglh(u, a, b, D = 1.702, xaxis = seq(-6, 6, 0.1),
  show_mle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_grm_+3A_t">t</code></td>
<td>
<p>ability parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_grm_+3A_a">a</code></td>
<td>
<p>discrimination parameters, 1d vector</p>
</td></tr>
<tr><td><code id="model_grm_+3A_b">b</code></td>
<td>
<p>item location parameters, 2d matrix</p>
</td></tr>
<tr><td><code id="model_grm_+3A_d">D</code></td>
<td>
<p>the scaling constant, 1.702 by default</p>
</td></tr>
<tr><td><code id="model_grm_+3A_raw">raw</code></td>
<td>
<p>TRUE to return P*</p>
</td></tr>
<tr><td><code id="model_grm_+3A_u">u</code></td>
<td>
<p>the observed scores (starting from 0), 2d matrix</p>
</td></tr>
<tr><td><code id="model_grm_+3A_log">log</code></td>
<td>
<p>TRUE to return log-likelihood</p>
</td></tr>
<tr><td><code id="model_grm_+3A_n_p">n_p</code></td>
<td>
<p>the number of people to be generated</p>
</td></tr>
<tr><td><code id="model_grm_+3A_n_i">n_i</code></td>
<td>
<p>the number of items to be generated</p>
</td></tr>
<tr><td><code id="model_grm_+3A_n_c">n_c</code></td>
<td>
<p>the number of score categories</p>
</td></tr>
<tr><td><code id="model_grm_+3A_t_dist">t_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate t-parameters</p>
</td></tr>
<tr><td><code id="model_grm_+3A_a_dist">a_dist</code></td>
<td>
<p>parameters of the lognormal distribution used to generate a-parameters</p>
</td></tr>
<tr><td><code id="model_grm_+3A_b_dist">b_dist</code></td>
<td>
<p>parameters of the normal distribution used to generate b-parameters</p>
</td></tr>
<tr><td><code id="model_grm_+3A_missing">missing</code></td>
<td>
<p>the proportion or number of missing responses</p>
</td></tr>
<tr><td><code id="model_grm_+3A_param">param</code></td>
<td>
<p>the parameter of the new scale: 't' or 'b'</p>
</td></tr>
<tr><td><code id="model_grm_+3A_mean">mean</code></td>
<td>
<p>the mean of the new scale</p>
</td></tr>
<tr><td><code id="model_grm_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the new scale</p>
</td></tr>
<tr><td><code id="model_grm_+3A_type">type</code></td>
<td>
<p>the type of plot, prob for ICC and info for IIFC</p>
</td></tr>
<tr><td><code id="model_grm_+3A_by_item">by_item</code></td>
<td>
<p>TRUE to combine categories</p>
</td></tr>
<tr><td><code id="model_grm_+3A_total">total</code></td>
<td>
<p>TRUE to sum values over items</p>
</td></tr>
<tr><td><code id="model_grm_+3A_xaxis">xaxis</code></td>
<td>
<p>the values of x-axis</p>
</td></tr>
<tr><td><code id="model_grm_+3A_show_mle">show_mle</code></td>
<td>
<p>TRUE to print maximum likelihood values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>with(model_grm_gendata(10, 5, 3), model_grm_prob(t, a, b))
with(model_grm_gendata(10, 5, 3), model_grm_info(t, a, b))
with(model_grm_gendata(10, 5, 3), model_grm_lh(u, t, a, b))
model_grm_gendata(10, 5, 3)
model_grm_gendata(10, 5, 3, missing=.1)
with(model_grm_gendata(10, 5, 3), model_grm_plot(a, b, type='prob'))
with(model_grm_gendata(10, 5, 3), model_grm_plot(a, b, type='info', by_item=TRUE))
with(model_grm_gendata(5, 50, 3), model_grm_plot_loglh(u, a, b))
</code></pre>

<hr>
<h2 id='mst'>Computerized Multistage Testing (MST)</h2><span id='topic+mst'></span><span id='topic+mst_route'></span><span id='topic+mst_get_indices'></span><span id='topic+mst_obj'></span><span id='topic+mst_constraint'></span><span id='topic+mst_stage_length'></span><span id='topic+mst_rdp'></span><span id='topic+mst_module_info'></span><span id='topic+mst_assemble'></span><span id='topic+print.mst'></span><span id='topic+plot.mst'></span><span id='topic+mst_get_items'></span>

<h3>Description</h3>

<p><code>mst</code> creates a multistage (MST) object for assembly
</p>
<p><code>mst_route</code> adds/removes a route to/from the MST
</p>
<p><code>mst_get_indices</code> maps the input indices to the actual indices
</p>
<p><code>mst_obj</code> adds objective functions to the MST
</p>
<p><code>mst_constraint</code> adds constraints to the MST
</p>
<p><code>mst_stage_length</code> sets length limits on stages
</p>
<p><code>mst_rdp</code> anchors the routing decision point (rdp) between adjacent modules
</p>
<p><code>mst_module_mininfo</code> sets the minimum information for modules
</p>
<p><code>mst_assemble</code> assembles the mst
</p>
<p><code>mst_get_items</code> extracts items from the assembly results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst(pool, design, num_panel, method = c("topdown", "bottomup"),
  len = NULL, max_use = NULL, group = NULL, ...)

mst_route(x, route, op = c("+", "-"))

mst_get_indices(x, indices)

mst_obj(x, theta, indices = NULL, target = NULL, ...)

mst_constraint(x, coef, min = NA, max = NA, level = NULL,
  indices = NULL)

mst_stage_length(x, stages, min = NA, max = NA)

mst_rdp(x, theta, indices, tol = 0)

mst_module_info(x, thetas, min, max, indices)

mst_assemble(x, ...)

## S3 method for class 'mst'
print(x, ...)

## S3 method for class 'mst'
plot(x, ...)

mst_get_items(x, panel_ix = NULL, stage_ix = NULL, module_ix = NULL,
  route_ix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst_+3A_pool">pool</code></td>
<td>
<p>the item pool (data.frame)</p>
</td></tr>
<tr><td><code id="mst_+3A_design">design</code></td>
<td>
<p>the MST design (string): e.g., &quot;1-3&quot;, &quot;1-2-2&quot;, &quot;1-2-3&quot;</p>
</td></tr>
<tr><td><code id="mst_+3A_num_panel">num_panel</code></td>
<td>
<p>the number of panels (integer)</p>
</td></tr>
<tr><td><code id="mst_+3A_method">method</code></td>
<td>
<p>the design method (string): 'topdown' or 'bottomup'</p>
</td></tr>
<tr><td><code id="mst_+3A_len">len</code></td>
<td>
<p>the module/route length (integer)</p>
</td></tr>
<tr><td><code id="mst_+3A_max_use">max_use</code></td>
<td>
<p>the maximum selection of items (integer)</p>
</td></tr>
<tr><td><code id="mst_+3A_group">group</code></td>
<td>
<p>the grouping variable (string or vector)</p>
</td></tr>
<tr><td><code id="mst_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="mst_+3A_x">x</code></td>
<td>
<p>the MST object</p>
</td></tr>
<tr><td><code id="mst_+3A_route">route</code></td>
<td>
<p>a MST route represented by a vector of module indices</p>
</td></tr>
<tr><td><code id="mst_+3A_op">op</code></td>
<td>
<p>&quot;+&quot; to add a route and &quot;-&quot; to remove a route</p>
</td></tr>
<tr><td><code id="mst_+3A_indices">indices</code></td>
<td>
<p>the indices of the route (topdown) or the module (bottomup) where objectives are added</p>
</td></tr>
<tr><td><code id="mst_+3A_theta">theta</code></td>
<td>
<p>a theta point or interval over which the TIF is optimized</p>
</td></tr>
<tr><td><code id="mst_+3A_target">target</code></td>
<td>
<p>the target values of the TIF objectives. <code>NULL</code> for maximization</p>
</td></tr>
<tr><td><code id="mst_+3A_coef">coef</code></td>
<td>
<p>the coefficients of the constraint</p>
</td></tr>
<tr><td><code id="mst_+3A_min">min</code></td>
<td>
<p>the lower bound of the constraint</p>
</td></tr>
<tr><td><code id="mst_+3A_max">max</code></td>
<td>
<p>the upper bound of the constraint</p>
</td></tr>
<tr><td><code id="mst_+3A_level">level</code></td>
<td>
<p>the constrained level, <code>NA</code> for quantitative variable</p>
</td></tr>
<tr><td><code id="mst_+3A_stages">stages</code></td>
<td>
<p>the stage indices</p>
</td></tr>
<tr><td><code id="mst_+3A_tol">tol</code></td>
<td>
<p>tolerance parameter (numeric)</p>
</td></tr>
<tr><td><code id="mst_+3A_thetas">thetas</code></td>
<td>
<p>theta points, a vector</p>
</td></tr>
<tr><td><code id="mst_+3A_panel_ix">panel_ix</code></td>
<td>
<p>the panel index, an int vector</p>
</td></tr>
<tr><td><code id="mst_+3A_stage_ix">stage_ix</code></td>
<td>
<p>the stage index, an int vector</p>
</td></tr>
<tr><td><code id="mst_+3A_module_ix">module_ix</code></td>
<td>
<p>the module index, an int vector</p>
</td></tr>
<tr><td><code id="mst_+3A_route_ix">route_ix</code></td>
<td>
<p>the route index, an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two methods for designing a MST. The bottom-up approach adds objectives 
and constraints on individual modules, whereas the topdown approach adds objectives
and constraints directly on routes.
</p>
<p><code>plot.mst</code> draws module information functions when <code>byroute=FALSE</code>
and route information functions when <code>byroute=TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## generate item pool
num_item &lt;- 300
pool &lt;- with(model_3pl_gendata(1, num_item), data.frame(a=a, b=b, c=c))
pool$id &lt;- 1:num_item
pool$content &lt;- sample(1:3, num_item, replace=TRUE)
pool$time &lt;- round(rlnorm(num_item, 4, .3))
pool$group &lt;- sort(sample(1:round(num_item/3), num_item, replace=TRUE))

## ex. 1: 1-2-2 MST, 2 panels, topdown
## 20 items in total and 10 items in content area 1 in each route
## maximize info. at -1 and 1 for easy and hard routes
x &lt;- mst(pool, "1-2-2", 2, 'topdown', len=20, max_use=1)
x &lt;- mst_obj(x, theta=-1, indices=1:2)
x &lt;- mst_obj(x, theta=1, indices=3:4)
x &lt;- mst_constraint(x, "content", 10, 10, level=1)
x &lt;- mst_assemble(x, timeout=5)
plot(x, byroute=TRUE)
for(p in 1:x$num_panel)
  for(r in 1:x$num_route) {
     route &lt;- paste(x$route[r, 1:x$num_stage], collapse='-')
     count &lt;- sum(mst_get_items(x, panel_ix=p, route_ix=r)$content==1)
     cat('panel=', p, ', route=', route, ': ', count, ' items in content area #1\n', sep='')
  }

## ex. 2: 1-2-3 MST, 2 panels, bottomup,
## remove two routes with large theta change: 1-2-6, 1-3-4 
## 10 items in total and 4 items in content area 2 in each module
## maximize info. at -1, 0 and 1 for easy, medium, and hard modules
x &lt;- mst(pool, "1-2-3", 2, 'bottomup', len=10, max_use=1)
x &lt;- mst_route(x, c(1, 2, 6), "-")
x &lt;- mst_route(x, c(1, 3, 4), "-")
x &lt;- mst_obj(x, theta= 0, indices=c(1, 5))
x &lt;- mst_obj(x, theta=-1, indices=c(2, 4))
x &lt;- mst_obj(x, theta= 1, indices=c(3, 6))
x &lt;- mst_constraint(x, "content", 4, 4, level=2)
x &lt;- mst_assemble(x, timeout=10) 
plot(x, byroute=FALSE)
for(p in 1:x$num_panel)
  for(m in 1:x$num_module){
    count &lt;- sum(mst_get_items(x, panel_ix=p, module_ix=m)$content==2)
    cat('panel=', p, ', module=', m, ': ', count, ' items in content area #2\n', sep='')
  }
 
## ex.3: same with ex.2 (w/o content constraints), but group-based  
x &lt;- mst(pool, "1-2-3", 2, 'bottomup', len=12, max_use=1, group="group")
x &lt;- mst_route(x, c(1, 2, 6), "-")
x &lt;- mst_route(x, c(1, 3, 4), "-")
x &lt;- mst_obj(x, theta= 0, indices=c(1, 5))
x &lt;- mst_obj(x, theta=-1, indices=c(2, 4))
x &lt;- mst_obj(x, theta= 1, indices=c(3, 6))
x &lt;- mst_assemble(x, timeout=10)
plot(x, byroute=FALSE)
for(p in 1:x$num_panel)
  for(m in 1:x$num_module){
    items &lt;- mst_get_items(x, panel_ix=p, module_ix=m)
    cat('panel=', p, ', module=', m, ': ', length(unique(items$id)), ' items from ', 
        length(unique(items$group)), ' groups\n', sep='')
  }
  
## ex.4: 2 panels of 1-2-3 top-down design
## 20 total items and 10 items in content area 3
## 6+ items in stage 1 &amp; 2
x &lt;- mst(pool, "1-2-3", 2, "topdown", len=20, max_use=1)
x &lt;- mst_route(x, c(1, 2, 6), "-")
x &lt;- mst_route(x, c(1, 3, 4), "-")
x &lt;- mst_obj(x, theta=-1, indices=1)
x &lt;- mst_obj(x, theta=0, indices=2:3)
x &lt;- mst_obj(x, theta=1, indices=4)
x &lt;- mst_constraint(x, "content", 10, 10, level=3)
x &lt;- mst_stage_length(x, 1:2, min=6)
x &lt;- mst_assemble(x, timeout=15)
head(x$items)
plot(x, byroute=FALSE)
for(p in 1:x$num_panel)
  for(s in 1:x$num_stage){
    items &lt;- mst_get_items(x, panel_ix=p, stage_ix=s)
    cat('panel=', p, ', stage=', s, ': ', length(unique(items$id)), ' items\n', sep='')
  }

## ex.5: same with ex.4, but use RDP instead of stage length to control routing errors
x &lt;- mst(pool, "1-2-3", 2, "topdown", len=20, max_use=1)
x &lt;- mst_route(x, c(1, 2, 6), "-")
x &lt;- mst_route(x, c(1, 3, 4), "-")
x &lt;- mst_obj(x, theta=-1, indices=1)
x &lt;- mst_obj(x, theta=0, indices=2:3)
x &lt;- mst_obj(x, theta=1, indices=4)
x &lt;- mst_constraint(x, "content", 10, 10, level=3)
x &lt;- mst_rdp(x, 0, 2:3, .1)
x &lt;- mst_module_mininfo(x, 0, 5, 2:3)
x &lt;- mst_assemble(x, timeout=15)
plot(x, byroute=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mst_sim'>Simulation of Multistage Testing</h2><span id='topic+mst_sim'></span><span id='topic+print.mst_sim'></span><span id='topic+plot.mst_sim'></span>

<h3>Description</h3>

<p><code>mst_sim</code> simulates a MST administration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst_sim(x, true, rdp = NULL, ...)

## S3 method for class 'mst_sim'
print(x, ...)

## S3 method for class 'mst_sim'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst_sim_+3A_x">x</code></td>
<td>
<p>the assembled MST</p>
</td></tr>
<tr><td><code id="mst_sim_+3A_true">true</code></td>
<td>
<p>the true theta parameter (numeric)</p>
</td></tr>
<tr><td><code id="mst_sim_+3A_rdp">rdp</code></td>
<td>
<p>routing decision points (list)</p>
</td></tr>
<tr><td><code id="mst_sim_+3A_...">...</code></td>
<td>
<p>additional option/control parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## assemble a MST
nitems &lt;- 200
pool &lt;- with(model_3pl_gendata(1, nitems), data.frame(a=a, b=b, c=c))
pool$content &lt;- sample(1:3, nrow(pool), replace=TRUE)
x &lt;- mst(pool, "1-2-2", 2, 'topdown', len=20, max_use=1)
x &lt;- mst_obj(x, theta=-1, indices=1)
x &lt;- mst_obj(x, theta=0, indices=2:3)
x &lt;- mst_obj(x, theta=1, indices=4)
x &lt;- mst_constraint(x, "content", 6, 6, level=1)
x &lt;- mst_constraint(x, "content", 6, 6, level=2)
x &lt;- mst_constraint(x, "content", 8, 8, level=3)
x &lt;- mst_stage_length(x, 1:2, min=5)
x &lt;- mst_assemble(x)

## ex. 1: administer the MST using fixed RDP for routing
x_sim &lt;- mst_sim(x, .5, list(stage1=0, stage2=0))
plot(x_sim)

## ex. 2: administer the MST using the max. info. for routing
x_sim &lt;- mst_sim(x, .5)
plot(x_sim, ylim=c(-5, 5))

## End(Not run)
</code></pre>

<hr>
<h2 id='rmse'>Root Mean Squared Error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Root mean squared error (RMSE) of two numeric vectors/matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_x">x</code></td>
<td>
<p>a numeric vector/matrix</p>
</td></tr>
<tr><td><code id="rmse_+3A_y">y</code></td>
<td>
<p>a numeric vector/matrix</p>
</td></tr>
</table>

<hr>
<h2 id='spearman_brown'>Spearman Brown Prophecy</h2><span id='topic+spearman_brown'></span><span id='topic+spearman_brown_reverse'></span>

<h3>Description</h3>

<p>Use Spearman-brown formula to compute the predicted reliability
when the test length is extened to n-fold or reversely the n-fold extension of
test length in order to reach the targeted reliability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spearman_brown(n, rho)

spearman_brown_reverse(rho, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spearman_brown_+3A_n">n</code></td>
<td>
<p>extend the test length to n-fold</p>
</td></tr>
<tr><td><code id="spearman_brown_+3A_rho">rho</code></td>
<td>
<p>the reliability of current test</p>
</td></tr>
<tr><td><code id="spearman_brown_+3A_target">target</code></td>
<td>
<p>the targeted reliability</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>spearman_brown(2, .70)
spearman_brown_reverse(.70, .85)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
