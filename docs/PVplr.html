<!DOCTYPE html><html><head><title>Help for package PVplr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PVplr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_na'><p>function to test if an entire column is NA</p></a></li>
<li><a href='#anomalies'><p>Fixes the anomlies</p></a></li>
<li><a href='#anomaly_detector'><p>detects rhw anomalies and returns a dataframw with cleaned and anom_flag column</p></a></li>
<li><a href='#data_quality_check'><p>checks the quality of the data after and before cleaning</p></a></li>
<li><a href='#data_structure'><p>Reads jci files gotten in budget period 2</p></a></li>
<li><a href='#day_time_start_end'><p>finds median start and end time of PV operation</p></a></li>
<li><a href='#df_With_on_time'><p>data with PV on time flag.</p></a></li>
<li><a href='#grade_pv'><p>returns quality information of time series data of PV</p></a></li>
<li><a href='#Int'><p>Largest Intervals</p></a></li>
<li><a href='#ip_num_time'><p>Numerical time interim predictor.</p></a></li>
<li><a href='#lin_inter_hrly_to_fifteen'><p>Linearly interpolate hourly data to 15 min data.</p></a></li>
<li><a href='#lin_inter_missing_energy'><p>Linearly interpolate missing energy values.</p></a></li>
<li><a href='#mbm_resample'><p>Dataframe resample function</p></a></li>
<li><a href='#nc'><p>function to convert to character then numeric</p></a></li>
<li><a href='#num_test'><p>function to test is the values in a column should be numeric</p></a></li>
<li><a href='#parallel_cluster_export'><p>Export variables to a cluster.</p></a></li>
<li><a href='#plr_6k_model'><p>6k Method for PLR Determination</p></a></li>
<li><a href='#plr_bootstrap_output'><p>Bootstrap: Resampling from individual Models</p></a></li>
<li><a href='#plr_bootstrap_output_from_results'><p>Bootstrap: Resample from individual Models</p></a></li>
<li><a href='#plr_bootstrap_uncertainty'><p>Bootstrap: Resampling data going into each Model</p></a></li>
<li><a href='#plr_build_var_list'><p>Build a Custom Variable List</p></a></li>
<li><a href='#plr_cleaning'><p>Basic Data Cleaning</p></a></li>
<li><a href='#plr_convert_columns'><p>Fix Column Typings</p></a></li>
<li><a href='#plr_decomposition'><p>Decompose Seasonality from Data</p></a></li>
<li><a href='#plr_kmeans_test'><p>Statistical k-means Test</p></a></li>
<li><a href='#plr_pvheatmap'><p>Title Heatmap generation for PV data</p></a></li>
<li><a href='#plr_pvusa_model'><p>PVUSA Method for PLR Determination</p></a></li>
<li><a href='#plr_remove_outliers'><p>Filter outliers from Power Predicted Data</p></a></li>
<li><a href='#plr_saturation_removal'><p>Removing Saturated Data</p></a></li>
<li><a href='#plr_seg_extract'><p>Segmented linear PLR extraction function</p></a></li>
<li><a href='#plr_var'><p>PLR linear model uncertainty</p></a></li>
<li><a href='#plr_variable_check'><p>Define Standard Variable Names</p></a></li>
<li><a href='#plr_weighted_regression'><p>Weighted Regression</p></a></li>
<li><a href='#plr_xbx_model'><p>XbX Method for PLR Determination</p></a></li>
<li><a href='#plr_xbx_utc_model'><p>UTC Method for PLR Determination</p></a></li>
<li><a href='#plr_yoy_regression'><p>Year-on-Year Regression</p></a></li>
<li><a href='#spline_timestamp_sync'><p>Spline columns to match timestamps.</p></a></li>
<li><a href='#test_df'><p>DOE RTC Sample PV System Data</p></a></li>
<li><a href='#time_frequency'><p>Determines the minutes between data points in a time-series</p></a></li>
<li><a href='#ts_inflate'><p>Inflate a time series data set.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Performance Loss Rate Analysis Pipeline</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The pipeline contained in this package provides tools used in the
    Solar Durability and Lifetime Extension Center (SDLE) for the analysis of
    Performance Loss Rates (PLR) in real world photovoltaic systems. Functions
    included allow for data cleaning, feature correction, power predictive modeling, 
    PLR determination, and uncertainty bootstrapping through various methods 
    &lt;<a href="https://doi.org/10.1109%2FPVSC40753.2019.8980928">doi:10.1109/PVSC40753.2019.8980928</a>&gt;.
    The vignette "Pipeline Walkthrough" gives
    an explicit run through of typical package usage. 
    This material is based upon work supported by the U.S Department
    of Energy's Office of Energy Efficiency and Renewable Energy (EERE) under
    Solar Energy Technologies Office (SETO) Agreement Number DE-EE-0008172. 
    This work made use of the High Performance Computing Resource in the 
    Core Facility for Advanced Research Computing at
    Case Western Reserve University. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.8), magrittr (&ge; 1.5), broom (&ge; 0.5.1), ggplot2
(&ge; 3.1.0), stlplus (&ge; 0.5.1), cluster (&ge; 2.0.7-1), purrr (&ge;
0.3.3), tidyr (&ge; 1.1.1), minpack.lm (&ge; 1.2-1), rlang (&ge;
0.3.1), segmented, forecast, scales, zoo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-14 17:29:21 UTC; wco3</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Curran <a href="https://orcid.org/0000-0002-4505-8359"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tyler Burleyson <a href="https://orcid.org/0000-0002-6356-5354"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  William Oltjen <a href="https://orcid.org/0000-0003-0380-1033"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sascha Lindig <a href="https://orcid.org/0000-0001-5421-8265"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Moser <a href="https://orcid.org/0000-0002-4895-8862"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Roger French <a href="https://orcid.org/0000-0002-6162-0532"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Solar Durability and Lifetime Extension research center [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger French &lt;roger.french@case.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-14 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_na'>function to test if an entire column is NA</h2><span id='topic+all_na'></span>

<h3>Description</h3>

<p>This function tests for completely NA columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_na_+3A_x">x</code></td>
<td>
<p>any column in a dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns boolean TRUE if column is all NA, FALSE if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- all_na(c(NA, "a", NA))

</code></pre>

<hr>
<h2 id='anomalies'>Fixes the anomlies</h2><span id='topic+anomalies'></span>

<h3>Description</h3>

<p>This function gets the data and finds the anomlies in weekends and
weekdays and gives a dataframe with anomalies and anomaly columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalies(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomalies_+3A_df">df</code></td>
<td>
<p>structured dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>df with two columns of cleaned_energy and anom_flag
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='anomaly_detector'>detects rhw anomalies and returns a dataframw with cleaned and anom_flag column</h2><span id='topic+anomaly_detector'></span>

<h3>Description</h3>

<p>detects rhw anomalies and returns a dataframw with cleaned and anom_flag column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomaly_detector(df, batch_days = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomaly_detector_+3A_df">df</code></td>
<td>
<p>the strucutred data</p>
</td></tr>
<tr><td><code id="anomaly_detector_+3A_batch_days">batch_days</code></td>
<td>
<p>the batch of data that the anomaly detection is applied. Since time series decomposition is used,
one seasonality will be applied for whole data which is inefficeint, if NA, will pass whole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with anomalies
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='data_quality_check'>checks the quality of the data after and before cleaning</h2><span id='topic+data_quality_check'></span>

<h3>Description</h3>

<p>calculates the percentage of anomalies, missings + zeros, gaps, and length of
the data and reports the quality of data before and after cleaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_quality_check(
  energy_data,
  col = "elec_cons",
  id = "pv_df",
  batch_days = 90
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_quality_check_+3A_energy_data">energy_data</code></td>
<td>
<p>structured energy dataframe</p>
</td></tr>
<tr><td><code id="data_quality_check_+3A_col">col</code></td>
<td>
<p>Input column</p>
</td></tr>
<tr><td><code id="data_quality_check_+3A_id">id</code></td>
<td>
<p>PV system ID</p>
</td></tr>
<tr><td><code id="data_quality_check_+3A_batch_days">batch_days</code></td>
<td>
<p>the batch of data that the anomaly detection is applied. Since time series decomposition is used,
one seasonality will be applied for whole data which is inefficient, if NA, will pass whole</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quality grading criteria is as following:
anomalies A: less than 10
missing percentage: A: less than 10
largest gap: A: less than 120 hours, B: 120 to 164 hours, C: 164 to 240 hours
D: more than 240 hours
length P: more than 2 years, F: less than 2 years
</p>


<h3>Value</h3>

<p>a table with grading of the quality after and before cleaning
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='data_structure'>Reads jci files gotten in budget period 2</h2><span id='topic+data_structure'></span>

<h3>Description</h3>

<p>Reads the jci file and modifies the timestamp intevals and
based on location modifies the timezone using googleapi and
then generates the useful columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_structure(df, col = "elec_cons", timestamp_col = "timestamp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_structure_+3A_df">df</code></td>
<td>
<p>dataframe containing at least the timestamp column and the variable to be plotted with the heatmap</p>
</td></tr>
<tr><td><code id="data_structure_+3A_col">col</code></td>
<td>
<p>the character name of the column to be ploted</p>
</td></tr>
<tr><td><code id="data_structure_+3A_timestamp_col">timestamp_col</code></td>
<td>
<p>the character name of the timestamp column
which i is the number of file in the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with fixed timestamps and useful cooumns
</p>


<h3>Author(s)</h3>

<p>Arash
</p>

<hr>
<h2 id='day_time_start_end'>finds median start and end time of PV operation</h2><span id='topic+day_time_start_end'></span>

<h3>Description</h3>

<p>finds median start and end time of PV operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day_time_start_end(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="day_time_start_end_+3A_df">df</code></td>
<td>
<p>with num_time Column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with start and end time
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='df_With_on_time'>data with PV on time flag.</h2><span id='topic+df_With_on_time'></span>

<h3>Description</h3>

<p>returns dataframe of PV with approximate operating period, baed on median of start and end time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_With_on_time(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_With_on_time_+3A_df">df</code></td>
<td>
<p>df with num_time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input data with one more column of on_time
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='grade_pv'>returns quality information of time series data of PV</h2><span id='topic+grade_pv'></span>

<h3>Description</h3>

<p>returns quality information of time series data of PV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade_pv(
  df,
  col = "poay",
  id = "pv_id",
  timestamp_col = "tmst",
  timestamp_format = "%Y-%m-%d %H:%M:%S",
  batch_days = 90
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_pv_+3A_df">df</code></td>
<td>
<p>the PV time series data. It can be the direct output of read.csv(file_name, stringsAsFactors = F)</p>
</td></tr>
<tr><td><code id="grade_pv_+3A_col">col</code></td>
<td>
<p>column of the grading, default 'poay'</p>
</td></tr>
<tr><td><code id="grade_pv_+3A_id">id</code></td>
<td>
<p>The name of the pv data</p>
</td></tr>
<tr><td><code id="grade_pv_+3A_timestamp_col">timestamp_col</code></td>
<td>
<p>the character name of the timestamp column</p>
</td></tr>
<tr><td><code id="grade_pv_+3A_timestamp_format">timestamp_format</code></td>
<td>
<p>the POSIXct format of the timestamp if conversion is needed</p>
</td></tr>
<tr><td><code id="grade_pv_+3A_batch_days">batch_days</code></td>
<td>
<p>the batch of data that the anomaly detection is applied. Since time series decomposition is used,
one seasonality will be applied for whole data which is inefficeint, if NA, will pass whole</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='Int'>Largest Intervals</h2><span id='topic+Int'></span>

<h3>Description</h3>

<p>Largest Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Int(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Int_+3A_df">df</code></td>
<td>
<p>Dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intervals
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='ip_num_time'>Numerical time interim predictor.</h2><span id='topic+ip_num_time'></span>

<h3>Description</h3>

<p>Convert the hour and minute component of each timestamp to a numerical
representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_num_time(data, ts_col = "timestamp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ip_num_time_+3A_data">data</code></td>
<td>
<p>A dataframe with a timestamp column.</p>
</td></tr>
<tr><td><code id="ip_num_time_+3A_ts_col">ts_col</code></td>
<td>
<p>The timestamp column name in <code>data</code>. Default value is
'timestamp'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> with a num_time column added.
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='lin_inter_hrly_to_fifteen'>Linearly interpolate hourly data to 15 min data.</h2><span id='topic+lin_inter_hrly_to_fifteen'></span>

<h3>Description</h3>

<p>Many weather data sets are hourly and we need values for
every 15 minutes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_inter_hrly_to_fifteen(data, data_ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_inter_hrly_to_fifteen_+3A_data">data</code></td>
<td>
<p>A data frame with hourly data.</p>
</td></tr>
<tr><td><code id="lin_inter_hrly_to_fifteen_+3A_data_ts">data_ts</code></td>
<td>
<p>The column name for the <code>data</code>
timestamp.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any value that can not be linearly interpolated such as a
string will remain the same.
</p>


<h3>Value</h3>

<p>The resulting fifteen minute data frame.
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='lin_inter_missing_energy'>Linearly interpolate missing energy values.</h2><span id='topic+lin_inter_missing_energy'></span>

<h3>Description</h3>

<p>If there exist lest than four missing values, represented by
NA values, fill with linearly interpolated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_inter_missing_energy(data, threshold = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_inter_missing_energy_+3A_data">data</code></td>
<td>
<p>A data frame with an 'elec_cons' column.</p>
</td></tr>
<tr><td><code id="lin_inter_missing_energy_+3A_threshold">threshold</code></td>
<td>
<p>The maximum number of consective values
that may be filled with interpolated values. By default
four.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame with 'missing values' filled in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lin_inter_missing_energy(data)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbm_resample'>Dataframe resample function</h2><span id='topic+mbm_resample'></span>

<h3>Description</h3>

<p>This function resamples data from a given dataframe.
Dataframe must have columns created through plr_cleaning to denote time segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbm_resample(df, fraction, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbm_resample_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="mbm_resample_+3A_fraction">fraction</code></td>
<td>
<p>fraction of data to resample from dataframe</p>
</td></tr>
<tr><td><code id="mbm_resample_+3A_by">by</code></td>
<td>
<p>timescale over which to resample, day, week, or month</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns randomly resampled dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
dfc_resampled &lt;- mbm_resample(test_dfc, fraction = 0.65, by = "week")

</code></pre>

<hr>
<h2 id='nc'>function to convert to character then numeric</h2><span id='topic+nc'></span>

<h3>Description</h3>

<p>The function is a shorthand for converting factors to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_+3A_x">x</code></td>
<td>
<p>any factor to convert to numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns supplied parameter as numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num &lt;- nc(test_df$power)

</code></pre>

<hr>
<h2 id='num_test'>function to test is the values in a column should be numeric</h2><span id='topic+num_test'></span>

<h3>Description</h3>

<p>This function tests a column to see if it should be numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_test(col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_test_+3A_col">col</code></td>
<td>
<p>any column in a dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns boolean TRUE if column should be numeric, FALSE if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- num_test(test_df$power)

</code></pre>

<hr>
<h2 id='parallel_cluster_export'>Export variables to a cluster.</h2><span id='topic+parallel_cluster_export'></span>

<h3>Description</h3>

<p>Ghost cluster export call to make sure
testCoverage's trace function and environment
are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_cluster_export(cluster, varlist, envir = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel_cluster_export_+3A_cluster">cluster</code></td>
<td>
<p>Cluster</p>
</td></tr>
<tr><td><code id="parallel_cluster_export_+3A_varlist">varlist</code></td>
<td>
<p>Character vector of names of objects to export.</p>
</td></tr>
<tr><td><code id="parallel_cluster_export_+3A_envir">envir</code></td>
<td>
<p>Environment from which t export variables</p>
</td></tr>
</table>

<hr>
<h2 id='plr_6k_model'>6k Method for PLR Determination</h2><span id='topic+plr_6k_model'></span>

<h3>Description</h3>

<p>This function groups data by the specified time interval
and performs a linear regression using the formula: 
power_var ~ irrad_var/istc * 
(nameplate_power + 
a*log(irrad_var/istc) + 
b*log(irrad_var/istc)^2 +
c*(temp_var - tref) + 
d*(temp_var - tref)*log(irrad_var/istc) + 
e*(temp_var - tref)*log(irrad_var/istc)^2 + 
f*(temp_var - tref)^2).
Predicted values of irradiance, temperature, and wind speed (if applicable)
are added for reference. These values are the lowest daily high
irradiance reading (over 300W/m^2), the average temperature over all data, and
the average wind speed over all data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_6k_model(
  df,
  var_list,
  nameplate_power,
  by = "month",
  data_cutoff = 30,
  predict_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_6k_model_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_6k_model_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_6k_model_+3A_nameplate_power">nameplate_power</code></td>
<td>
<p>The rated power capability of the system, in watts.</p>
</td></tr>
<tr><td><code id="plr_6k_model_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;. The time periods over which
to group data for regression.</p>
</td></tr>
<tr><td><code id="plr_6k_model_+3A_data_cutoff">data_cutoff</code></td>
<td>
<p>The number of data points needed to keep a value in the 
final table. Regressions over less than this number and their data will be discarded.</p>
</td></tr>
<tr><td><code id="plr_6k_model_+3A_predict_data">predict_data</code></td>
<td>
<p>optional; Dataframe; If you have preferred estimations of irradiance,
temperature, and wind speed, include them here to skip automatic generation. Format:
Irradiance, Temperature, Wind (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe of results per passed time scale from 6K modeling
</p>

<hr>
<h2 id='plr_bootstrap_output'>Bootstrap: Resampling from individual Models</h2><span id='topic+plr_bootstrap_output'></span>

<h3>Description</h3>

<p>This function determines uncertainty of a PLR measurement
by sampling results from invididual models. Specify the model you would like
to find the uncertainty of, and the function will put the dataframe through the
selected model and return the uncertainties of the model's results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_bootstrap_output(
  df,
  var_list,
  model,
  by = "month",
  fraction = 0.65,
  n = 1000,
  predict_data = NULL,
  np = NA,
  power_var = "power_var",
  time_var = "time_var",
  ref_irrad = 900,
  irrad_range = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_bootstrap_output_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the plr_variable_check output.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_model">model</code></td>
<td>
<p>The model you would like to calculate the uncertainty of. Use
&quot;xbx&quot;, &quot;xbx+utc&quot;, &quot;pvusa&quot;, or &quot;6k&quot;.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_by">by</code></td>
<td>
<p>String indicating time step count per year for the regression. 
Use &quot;day&quot;, &quot;month&quot;, or &quot;year&quot;. See <code><a href="#topic+plr_weighted_regression">plr_weighted_regression</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_fraction">fraction</code></td>
<td>
<p>The size of each sample relative to the total dataset.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_n">n</code></td>
<td>
<p>Number of samples to take.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_predict_data">predict_data</code></td>
<td>
<p>passed to predict_data in model call. See <code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>
for example.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_np">np</code></td>
<td>
<p>The system's reported name plate power. See <code><a href="#topic+plr_6k_model">plr_6k_model</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_power_var">power_var</code></td>
<td>
<p>The name of the power variable after being put through a Performance
Loss Rate (PLR) determining test. Typically &quot;power_var&quot;.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_time_var">time_var</code></td>
<td>
<p>The name of the time variable after being put through a PLR
determining test. Typically &quot;time_var&quot;.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_ref_irrad">ref_irrad</code></td>
<td>
<p>The irradiance value at which to calculate the universal
temperature coefficient. Since irradiance is a much stronger influencer on power generation
than temperature, it is important to specify a small range of irradiance data 
from which to estimate the effect of temperature.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_+3A_irrad_range">irrad_range</code></td>
<td>
<p>The range of the subset used to calculate the universal
temperature coefficient. See above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PLR value and uncertainty calculated with bootstrap of data from power correction models
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list

var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)

xbx_mbm_plr_output_uncertainty &lt;- plr_bootstrap_output(test_dfc, var_list,
                                                       model = "xbx", fraction = 0.65,
                                                       n = 10, power_var = 'power_var',
                                                       time_var = 'time_var', ref_irrad = 900,
                                                       irrad_range = 10, by = "month",
                                                       np = NA, pred = NULL)


</code></pre>

<hr>
<h2 id='plr_bootstrap_output_from_results'>Bootstrap: Resample from individual Models</h2><span id='topic+plr_bootstrap_output_from_results'></span>

<h3>Description</h3>

<p>The function samples and bootstraps data that has already been
put through a power predictive model. The PLR and Uncertainty are returned in
a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_bootstrap_output_from_results(
  data,
  power_var,
  time_var,
  weight_var,
  by = "month",
  model,
  fraction = 0.65,
  n = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_data">data</code></td>
<td>
<p>Result of modeling data with a PLR determining model, i.e.
plr_xbx_model, plr_6k_model, etc.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_power_var">power_var</code></td>
<td>
<p>Variable name of power in the dataframe. Typically power_var</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_time_var">time_var</code></td>
<td>
<p>Variable name of time in the dataframe. Typically time_var</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_weight_var">weight_var</code></td>
<td>
<p>Variable name of weightings in the dataframe. Typically sigma</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;month&quot;, or &quot;year&quot;. Time over which to perform
<code><a href="#topic+plr_yoy_regression">plr_yoy_regression</a></code> and <code><a href="#topic+plr_weighted_regression">plr_weighted_regression</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_model">model</code></td>
<td>
<p>The name of the model the data has been put through. This
option is only included for the user's benefit in keeping bootstrap outputs
consistent.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_fraction">fraction</code></td>
<td>
<p>The fractional size of the data to be sampled each time.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_output_from_results_+3A_n">n</code></td>
<td>
<p>The number of resamples to take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PLR value and uncertainty calculated with bootstrap of data going into power correction models
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list


var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)
                                  
xbx_mbm_plr_result_uncertainty &lt;- plr_bootstrap_output_from_results(test_xbx_wbw_res, 
                                                                    power_var = 'power_var',
                                                                    time_var = 'time_var',
                                                                    weight_var = 'sigma',
                                                                    by = "month", model = 'xbx',
                                                                    fraction = 0.65, n = 10)


</code></pre>

<hr>
<h2 id='plr_bootstrap_uncertainty'>Bootstrap: Resampling data going into each Model</h2><span id='topic+plr_bootstrap_uncertainty'></span>

<h3>Description</h3>

<p>This function determines the uncertainty of a PLR measurement
through resampling data for each model, prior to putting the data through the
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_bootstrap_uncertainty(
  df,
  n,
  fraction = 0.65,
  var_list,
  model,
  by = "month",
  power_var = "power_var",
  time_var = "time_var",
  data_cutoff = 100,
  np = NA,
  pred = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_n">n</code></td>
<td>
<p>(numeric) Number of samples to take. The higher the n value, the longer it 
takes to complete, but the results become more accurate as well.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_fraction">fraction</code></td>
<td>
<p>The fraction of data that constitutes a resample for the bootstrap.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_var_list">var_list</code></td>
<td>
<p>A list of variables obtained through <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_model">model</code></td>
<td>
<p>the String name of the model to bootstrap. Select from: </p>

<ul>
<li><p> &quot;xbx&quot; (<code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>),
</p>
</li>
<li><p> &quot;correction&quot; (<code><a href="#topic+plr_xbx_utc_model">plr_xbx_utc_model</a></code>),
</p>
</li>
<li><p> &quot;pvusa&quot; (<code><a href="#topic+plr_pvusa_model">plr_pvusa_model</a></code>),
</p>
</li>
<li><p> or &quot;6k&quot; (<code><a href="#topic+plr_6k_model">plr_6k_model</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;. Time over which to perform
<code><a href="#topic+plr_yoy_regression">plr_yoy_regression</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_power_var">power_var</code></td>
<td>
<p>Variable name of power in the dataframe. This must be the
variable's name after being put through your selected model. Typically power_var</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_time_var">time_var</code></td>
<td>
<p>Variable name of time in the dataframe. This must be the
variable's name after being put through your selected model. Typically time_var</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_data_cutoff">data_cutoff</code></td>
<td>
<p>The number of data points needed to keep a value in the
final table. Regressions over less than this number and their data will be discarded.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_np">np</code></td>
<td>
<p>The system's reported name plate power. See <code><a href="#topic+plr_6k_model">plr_6k_model</a></code>.</p>
</td></tr>
<tr><td><code id="plr_bootstrap_uncertainty_+3A_pred">pred</code></td>
<td>
<p>passed to predict_data in model call. See <code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>
for an example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PLR value and uncertainty calculated with bootstrap of data going into power correction models
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list


var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
xbx_mbm_plr_uncertainty &lt;- plr_bootstrap_uncertainty(test_dfc, n = 2, 
                                                     fraction = 0.65, by = 'month',
                                                     power_var = 'power_var', time_var = 'time_var',
                                                     var_list = var_list, model = "xbx",
                                                     data_cutoff = 10, np = NA,
                                                     pred = NULL)


</code></pre>

<hr>
<h2 id='plr_build_var_list'>Build a Custom Variable List</h2><span id='topic+plr_build_var_list'></span>

<h3>Description</h3>

<p>The default var_list generator, plr_variable_check, assumes data comes from
SDLE's sources. If you are using this package with your own data, the format
may not line up appropriately. Use this function to create a variable list to
be passed to other functions so they can keep track of what column names mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_build_var_list(time_var, power_var, irrad_var, temp_var, wind_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_build_var_list_+3A_time_var">time_var</code></td>
<td>
<p>The variable representing time. Typically, a timestamp.</p>
</td></tr>
<tr><td><code id="plr_build_var_list_+3A_power_var">power_var</code></td>
<td>
<p>The variable representing time. Typically, in watts.</p>
</td></tr>
<tr><td><code id="plr_build_var_list_+3A_irrad_var">irrad_var</code></td>
<td>
<p>The variable representing irradiance. Typically, either poa or
ghi irradiance.</p>
</td></tr>
<tr><td><code id="plr_build_var_list_+3A_temp_var">temp_var</code></td>
<td>
<p>The variable representing temperature. Package functions assume 
Celcius.</p>
</td></tr>
<tr><td><code id="plr_build_var_list_+3A_wind_var">wind_var</code></td>
<td>
<p>optional; The variable representing wind speed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe of variable names for the given photovoltaic data for use with later functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)

</code></pre>

<hr>
<h2 id='plr_cleaning'>Basic Data Cleaning</h2><span id='topic+plr_cleaning'></span>

<h3>Description</h3>

<p>Removes entries with irradiance and power readings outside cutoffs,
fixes timestamps to your specified format, and converts columns to numeric
when appropriate - see <code><a href="#topic+plr_convert_columns">plr_convert_columns</a></code>. 
Also, adds columns for days/weeks/years of operation that are used by
other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_cleaning(
  df,
  var_list,
  irrad_thresh = 100,
  low_power_thresh = 0.05,
  high_power_cutoff = NA,
  tmst_format = "%Y-%m-%d %H:%M:%S"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_cleaning_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_cleaning_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_cleaning_+3A_irrad_thresh">irrad_thresh</code></td>
<td>
<p>The lowest meaningful irradiance value.
Values below are filtered.</p>
</td></tr>
<tr><td><code id="plr_cleaning_+3A_low_power_thresh">low_power_thresh</code></td>
<td>
<p>The lowest meaningful power output.
Values below are filtered.</p>
</td></tr>
<tr><td><code id="plr_cleaning_+3A_high_power_cutoff">high_power_cutoff</code></td>
<td>
<p>The highest meaningful power output.
Values above are filtered.</p>
</td></tr>
<tr><td><code id="plr_cleaning_+3A_tmst_format">tmst_format</code></td>
<td>
<p>The desired timestamp format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe with rows filtered out based on passed cleaning parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
                               
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)

</code></pre>

<hr>
<h2 id='plr_convert_columns'>Fix Column Typings</h2><span id='topic+plr_convert_columns'></span>

<h3>Description</h3>

<p>Converts appropriate columns to numeric without specifying
the name of the column. All columns from hbase are read as factors.
Columns are tested to see if they should be numeric by forcing conversion
to numeric. Columns that subsequently contain NA's are not numeric; if not,
they are set to numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_convert_columns(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_convert_columns_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns original dataframe with columns corrected to proper classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- PVplr::plr_convert_columns(test_df)

</code></pre>

<hr>
<h2 id='plr_decomposition'>Decompose Seasonality from Data</h2><span id='topic+plr_decomposition'></span>

<h3>Description</h3>

<p>Decomposes seasonality from a dataframe that has already
passed through a PLR Determination test, e.g. <code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>. This method has
the option of creating plot and data files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_decomposition(
  data,
  freq,
  power_var,
  time_var,
  plot = FALSE,
  plot_file = NULL,
  title = NULL,
  data_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_decomposition_+3A_data">data</code></td>
<td>
<p>a dataframe containing PV data that has undergone a power
predictive model, e.g. <code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>.</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_freq">freq</code></td>
<td>
<p>the frequency of seasonality. This is typically 4 but depends
on the location of the system.</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_power_var">power_var</code></td>
<td>
<p>name of the power variable, e.g. iacp</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_time_var">time_var</code></td>
<td>
<p>name of the time variable, e.g. tvar</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_plot">plot</code></td>
<td>
<p>boolean indicating if you wish to save a plot.</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_plot_file">plot_file</code></td>
<td>
<p>location to save the plot, if the plot param is given TRUE.</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_title">title</code></td>
<td>
<p>the title of the plot created if the plot param is given TRUE.</p>
</td></tr>
<tr><td><code id="plr_decomposition_+3A_data_file">data_file</code></td>
<td>
<p>location to save data. Currently non-functional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing decomposed time series features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
# Perform power modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)
                                  
test_xbx_wbw_decomp &lt;- plr_decomposition(test_xbx_wbw_res, freq = 4,
                                         power_var = 'power_var', time_var = 'time_var',
                                         plot = FALSE, plot_file = NULL, title = NULL, 
                                         data_file = NULL)

</code></pre>

<hr>
<h2 id='plr_kmeans_test'>Statistical k-means Test</h2><span id='topic+plr_kmeans_test'></span>

<h3>Description</h3>

<p>The method builds linear models by day, identifies outliers,
and performs 2-means clustering by slopes. If the lower identified
cluster is significantly less than the higher mean, and constitutes less
than 25% of the data, it is identified as soiled and returned. Otherwise, the
outlier points are identified as soiled and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_kmeans_test(
  df,
  var_list,
  mean_ratio = 0.7,
  plot = FALSE,
  file_path,
  file_name,
  set_cutoff = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_kmeans_test_+3A_df">df</code></td>
<td>
<p>A df containing pv data. Should be 'cleaned' by <code><a href="#topic+plr_cleaning">plr_cleaning</a></code>.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_mean_ratio">mean_ratio</code></td>
<td>
<p>This scales the higher identified cluster's mean for comparison.
Higher values will be more likely to identify the second mean as soiled, and vice versa.
Values should range from 0 to 1.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_plot">plot</code></td>
<td>
<p>optional; Boolean; whether to return the box plot generated by the method
to identify outliers.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_file_path">file_path</code></td>
<td>
<p>optional; location to store the boxplot if plot is set TRUE.
Note this is not necessary if you select to plot - only if you wish to save it.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_file_name">file_name</code></td>
<td>
<p>optional; name of file to save boxplot if plot is set to TRUE.</p>
</td></tr>
<tr><td><code id="plr_kmeans_test_+3A_set_cutoff">set_cutoff</code></td>
<td>
<p>Defaults to FALSE; pass a numeric value to cut off all slopes
less than the cutoff value. This bypasses entirely the outlier and clustering
calculuations to remove slope values you believe to be soiled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method returns a dataframe containing the values that should be
removed. If you want to discard them, try using dplyr::filter().
</p>

<hr>
<h2 id='plr_pvheatmap'>Title Heatmap generation for PV data</h2><span id='topic+plr_pvheatmap'></span>

<h3>Description</h3>

<p>Title Heatmap generation for PV data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_pvheatmap(
  df,
  col,
  timestamp_col,
  timestamp_format = "%Y-%m-%d %H:%M:%S",
  upper_threshold = 1,
  lower_threshold = 0,
  font_size = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_pvheatmap_+3A_df">df</code></td>
<td>
<p>dataframe containing at least the timestamp column and the variable to be plotted with the heatmap</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_col">col</code></td>
<td>
<p>the character name of the column to be ploted</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_timestamp_col">timestamp_col</code></td>
<td>
<p>the character name of the timestamp column</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_timestamp_format">timestamp_format</code></td>
<td>
<p>the POSIXct format of the timestamp if conversion is needed</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_upper_threshold">upper_threshold</code></td>
<td>
<p>the fraction of upper data to include, 1 removes no data, 0.9 remove the top 1 percent etc.</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_lower_threshold">lower_threshold</code></td>
<td>
<p>the fraction of lower data to remove, 0 removes no data, 0.01 remove the bottom 1 percent etc.</p>
</td></tr>
<tr><td><code id="plr_pvheatmap_+3A_font_size">font_size</code></td>
<td>
<p>font size of the output plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a ggplot object heatmap of the specified column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build heatmap
heat &lt;- plr_pvheatmap(test_df, col = "g_poa", timestamp_col = "timestamp", 
                      upper_threshold = 0.99, lower_threshold = 0)
# display heatmap
plot(heat)

</code></pre>

<hr>
<h2 id='plr_pvusa_model'>PVUSA Method for PLR Determination</h2><span id='topic+plr_pvusa_model'></span>

<h3>Description</h3>

<p>This function groups data by the specified time interval
and performs a linear regression using the formula: 
<code class="reqn">P = G_{POA} * (\beta_{0} + \beta_{1} G + \beta_{2} T_{amb} + \beta_{3} W)</code>.
Predicted values of irradiance, temperature, and wind speed (if applicable)
are added for reference. These values are the lowest daily high
irradiance reading (over 300), the average temperature over all data, and
the average wind speed over all data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_pvusa_model(
  df,
  var_list,
  by = "month",
  data_cutoff = 30,
  predict_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_pvusa_model_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_pvusa_model_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_pvusa_model_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;. The time periods over which
to group data for regression.</p>
</td></tr>
<tr><td><code id="plr_pvusa_model_+3A_data_cutoff">data_cutoff</code></td>
<td>
<p>The number of data points needed to keep a value in the 
final table. Regressions over less than this number and their data will be discarded.</p>
</td></tr>
<tr><td><code id="plr_pvusa_model_+3A_predict_data">predict_data</code></td>
<td>
<p>optional; Dataframe; If you have preferred estimations of irradiance,
temperature, and wind speed, include them here to skip automatic generation. Format:
Irradiance, Temperature, Wind (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe of results per passed time scale from PVUSA modeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_pvusa_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)

</code></pre>

<hr>
<h2 id='plr_remove_outliers'>Filter outliers from Power Predicted Data</h2><span id='topic+plr_remove_outliers'></span>

<h3>Description</h3>

<p>This function is used to remove outliers (if desired) after putting data 
through a power predictive model, e.g. <code><a href="#topic+plr_xbx_model">plr_xbx_model</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_remove_outliers(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_remove_outliers_+3A_data">data</code></td>
<td>
<p>A resulting dataframe from a power predictive model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe with outliers flagged by other functions removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)

# Remove outliers from the modeled data
test_xbx_wbw_res_no_outliers &lt;- plr_remove_outliers(test_xbx_wbw_res)

</code></pre>

<hr>
<h2 id='plr_saturation_removal'>Removing Saturated Data</h2><span id='topic+plr_saturation_removal'></span>

<h3>Description</h3>

<p>Tests for readings which may indicate saturation of the system.
Removes values above the power saturation limit (calculated by multiplying
sat_limit and power_thresh).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_saturation_removal(df, var_list, sat_limit, power_thresh = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_saturation_removal_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_saturation_removal_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_saturation_removal_+3A_sat_limit">sat_limit</code></td>
<td>
<p>An upper limit on power saturation. This is multiplied by the
power threshold, and power values above this point are filtered from
the dataframe. The value depends on the system's inverter.</p>
</td></tr>
<tr><td><code id="plr_saturation_removal_+3A_power_thresh">power_thresh</code></td>
<td>
<p>An upper limit on power.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns passed data frame with rows removed which contain power values above the specified threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
test_dfc_removed_saturation &lt;- plr_saturation_removal(test_dfc, var_list,
                                                      sat_limit = 3000, power_thresh = 0.99)

</code></pre>

<hr>
<h2 id='plr_seg_extract'>Segmented linear PLR extraction function</h2><span id='topic+plr_seg_extract'></span>

<h3>Description</h3>

<p>Segmented linear PLR extraction function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_seg_extract(
  df,
  per_year,
  psi = NA,
  n_breakpoints,
  power_var,
  time_var,
  return_model = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_seg_extract_+3A_df">df</code></td>
<td>
<p>data frame of corrected power measurements, typically the output of a weather correction model</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_per_year">per_year</code></td>
<td>
<p>number of data point defining one seasonal year (365 for days, 52 for weeks etc.)</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_psi">psi</code></td>
<td>
<p>vector of 1 or more breakpoint estimates for the model. If not given will evenly space breakpoints across time series</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_n_breakpoints">n_breakpoints</code></td>
<td>
<p>number of desired breakpoints. Determines number of linear models</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_power_var">power_var</code></td>
<td>
<p>character name of the power variable</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_time_var">time_var</code></td>
<td>
<p>character name of the time variable</p>
</td></tr>
<tr><td><code id="plr_seg_extract_+3A_return_model">return_model</code></td>
<td>
<p>logical to return model object. If FALSE returns PLR results from model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if return_model is FALSE it returns PLR results from model, otherwise returns segmented linear model object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
#' # Perform power modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)
                                  
decomp &lt;- plr_decomposition(test_xbx_wbw_res, freq = 4,
                                         power_var = 'power_var', time_var = 'time_var',
                                         plot = FALSE, plot_file = NULL, title = NULL, 
                                         data_file = NULL)

# evaluate segmented PLR results
seg_plr_result &lt;- PVplr::plr_seg_extract(df = decomp, per_year = 365,
                                         n_breakpoints = 1, power_var = "trend",
                                         time_var = "age")

# return segmented model instead of PLR result
model &lt;- PVplr::plr_seg_extract(df = decomp, per_year = 365, n_breakpoints = 1,
                                power_var = "trend", time_var = "age", return_model = TRUE)

# predict data along time-series with piecewise model for plotting
pred &lt;- data.frame(age = seq(1, max(decomp$age, na.rm = TRUE), length.out = 10000))
pred$seg &lt;- predict(model, newdata = pred)

</code></pre>

<hr>
<h2 id='plr_var'>PLR linear model uncertainty</h2><span id='topic+plr_var'></span>

<h3>Description</h3>

<p>This function returns the standard deviation of a PLR calculated from a linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_var(mod, per_year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_var_+3A_mod">mod</code></td>
<td>
<p>linear model</p>
</td></tr>
<tr><td><code id="plr_var_+3A_per_year">per_year</code></td>
<td>
<p>number of data points in a given year baesd on which time scale was selected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns standard deviation of PLR value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)

# obain standard deviation from model
mod &lt;- lm(power_var ~ time_var, data = test_xbx_wbw_res)
plr_sd &lt;- plr_var(mod, per_year = 52)

</code></pre>

<hr>
<h2 id='plr_variable_check'>Define Standard Variable Names</h2><span id='topic+plr_variable_check'></span>

<h3>Description</h3>

<p>The method determines the variable names used by the input dataframe.
It looks for the following labels:
</p>

<ul>
<li><p> power_var &lt;- iacp; if not, sets to idcp
</p>
</li>
<li><p> time_var &lt;- tmst; if not ,sets to tutc
</p>
</li>
<li><p> irrad_var &lt;- poay; if not, sets to ghir
</p>
</li>
<li><p> temp_var &lt;- temp; if not, sets to modt
</p>
</li>
<li><p> wind_var &lt;- wspa; if applicable, else NULL
</p>
</li></ul>

<p>This function assumes data is in a standard HBase format. If you are using other data
(as you most likely are) you should use the companion function, <code><a href="#topic+plr_build_var_list">plr_build_var_list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_variable_check(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_variable_check_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing standard variable names (no data). It will not include
windspeed if the variable was not already included. This is frequently an input
of other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_list &lt;- plr_variable_check(test_df)
 
</code></pre>

<hr>
<h2 id='plr_weighted_regression'>Weighted Regression</h2><span id='topic+plr_weighted_regression'></span>

<h3>Description</h3>

<p>Automatically calculates Performance Loss Rate (PLR)
using weighted linear regression. Note that it needs data from 
a power predictive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_weighted_regression(
  data,
  power_var,
  time_var,
  model,
  per_year = 12,
  weight_var = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_weighted_regression_+3A_data">data</code></td>
<td>
<p>The result of a power predictive model</p>
</td></tr>
<tr><td><code id="plr_weighted_regression_+3A_power_var">power_var</code></td>
<td>
<p>String name of the variable used as power</p>
</td></tr>
<tr><td><code id="plr_weighted_regression_+3A_time_var">time_var</code></td>
<td>
<p>String name of the variable used as time</p>
</td></tr>
<tr><td><code id="plr_weighted_regression_+3A_model">model</code></td>
<td>
<p>String name of the model that the data was passed through</p>
</td></tr>
<tr><td><code id="plr_weighted_regression_+3A_per_year">per_year</code></td>
<td>
<p>the time step count per year based on the model - 
12 for month-by-month, 52 for week-by-week, and 365 for day-by-day</p>
</td></tr>
<tr><td><code id="plr_weighted_regression_+3A_weight_var">weight_var</code></td>
<td>
<p>Used to weight regression, typically sigma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PLR value and error evaluated with linear regression
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)
                                  
# Calculate Performance Loss Rate
xbx_wbw_plr &lt;- plr_weighted_regression(test_xbx_wbw_res, 
                                       power_var = 'power_var', 
                                       time_var = 'time_var',
                                       model = "xbx", 
                                       per_year = 52, 
                                       weight_var = 'sigma')

</code></pre>

<hr>
<h2 id='plr_xbx_model'>XbX Method for PLR Determination</h2><span id='topic+plr_xbx_model'></span>

<h3>Description</h3>

<p>This function groups data by the specified time interval
and performs a linear regression using the formula:
<code class="reqn">P_{pred.} = \beta_0 + \beta_1 G + \beta_2 T + \epsilon</code>.
This is the simplest of the PLR determining methods.
Predicted values of irradiance, temperature, and wind speed (if applicable)
are added to the output for reference. These values are the lowest daily high
irradiance reading (over 300), the average temperature over all data, and
the average wind speed over all data.
Outliers are detected and labeled in a column as TRUE or FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_xbx_model(
  df,
  var_list,
  by = "month",
  data_cutoff = 30,
  predict_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_xbx_model_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_xbx_model_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the plr_variable_check output.</p>
</td></tr>
<tr><td><code id="plr_xbx_model_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;. The time periods over which
to group data for regression.</p>
</td></tr>
<tr><td><code id="plr_xbx_model_+3A_data_cutoff">data_cutoff</code></td>
<td>
<p>The number of data points needed to keep a value in the
final table. Regressions over less than this number and their data will be discarded.</p>
</td></tr>
<tr><td><code id="plr_xbx_model_+3A_predict_data">predict_data</code></td>
<td>
<p>optional; Dataframe; If you have preferred estimations of irradiance,
temperature, and wind speed, include them here to skip automatic generation. Format:
Irradiance, Temperature, Wind (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe of results per passed time scale from XbX modeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)

</code></pre>

<hr>
<h2 id='plr_xbx_utc_model'>UTC Method for PLR Determination</h2><span id='topic+plr_xbx_utc_model'></span>

<h3>Description</h3>

<p>This function groups data by the specified time interval
and performs a linear regression using the formula: 
power_corr ~ irrad_var - 1.
Predicted values of irradiance, temperature, and wind speed (if applicable)
are added for reference. The function uses a universal temperature correction,
rather than the monthly regression correction done in other PLR determining methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_xbx_utc_model(
  df,
  var_list,
  by = "month",
  data_cutoff = 30,
  predict_data = NULL,
  ref_irrad = 900,
  irrad_range = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_xbx_utc_model_+3A_df">df</code></td>
<td>
<p>A dataframe containing pv data.</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_var_list">var_list</code></td>
<td>
<p>A list of the dataframe's standard variable names, obtained from
the output of <code><a href="#topic+plr_variable_check">plr_variable_check</a></code>.</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_by">by</code></td>
<td>
<p>String, either &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;. The time periods over which
to group data for regression.</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_data_cutoff">data_cutoff</code></td>
<td>
<p>The number of data points needed to keep a value in the 
final table. Regressions over less than this number and their data will be discarded.</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_predict_data">predict_data</code></td>
<td>
<p>optional; Dataframe; If you have preferred estimations of irradiance,
temperature, and wind speed, include them here to skip automatic generation. Format:
Irradiance, Temperature, Wind (optional).</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_ref_irrad">ref_irrad</code></td>
<td>
<p>The irradiance value at which to calculate the universal
temperature coefficient. Since irradiance is a much stronger influencer on power generation
than temperature, it is important to specify a small range of irradiance data 
from which to estimate the effect of temperature.</p>
</td></tr>
<tr><td><code id="plr_xbx_utc_model_+3A_irrad_range">irrad_range</code></td>
<td>
<p>The range of the subset used to calculate the universal
temperature coefficient. See above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe of results per passed time scale from XbX with 
universal temperature correction modeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_utc_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL,
                                  ref_irrad = 900, irrad_range = 10)

</code></pre>

<hr>
<h2 id='plr_yoy_regression'>Year-on-Year Regression</h2><span id='topic+plr_yoy_regression'></span>

<h3>Description</h3>

<p>Automatically calculates Performance Loss Rate (PLR)
using year on year regression. Note that it needs data from a 
power predictive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr_yoy_regression(
  data,
  power_var,
  time_var,
  model,
  per_year = 12,
  return_PLR = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_yoy_regression_+3A_data">data</code></td>
<td>
<p>Result of a power predictive model</p>
</td></tr>
<tr><td><code id="plr_yoy_regression_+3A_power_var">power_var</code></td>
<td>
<p>String name of the variable used as power</p>
</td></tr>
<tr><td><code id="plr_yoy_regression_+3A_time_var">time_var</code></td>
<td>
<p>String name of the variable used as time</p>
</td></tr>
<tr><td><code id="plr_yoy_regression_+3A_model">model</code></td>
<td>
<p>String name of the model the data was passed through</p>
</td></tr>
<tr><td><code id="plr_yoy_regression_+3A_per_year">per_year</code></td>
<td>
<p>Time step count per year based on model. 
Typically 12 for MbM, 365 for DbD.</p>
</td></tr>
<tr><td><code id="plr_yoy_regression_+3A_return_plr">return_PLR</code></td>
<td>
<p>boolean; option to return PLR value, rather than
the raw regression data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns PLR value and error evaluated with YoY regression, if return_PLR is false
it will return the individual YoY calculations
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build var_list
var_list &lt;- plr_build_var_list(time_var = "timestamp",
                               power_var = "power",
                               irrad_var = "g_poa",
                               temp_var = "mod_temp",
                               wind_var = NA)
# Clean Data
test_dfc &lt;- plr_cleaning(test_df, var_list, irrad_thresh = 100,
                         low_power_thresh = 0.01, high_power_cutoff = NA)
                         
# Perform the power predictive modeling step
test_xbx_wbw_res &lt;- plr_xbx_model(test_dfc, var_list, by = "week",
                                  data_cutoff = 30, predict_data = NULL)
                                  
# Calculate Performance Loss Rate
xbx_wbw_plr &lt;- plr_yoy_regression(test_xbx_wbw_res, 
                                       power_var = 'power_var', 
                                       time_var = 'time_var',
                                       model = "xbx", 
                                       per_year = 52, 
                                       return_PLR = TRUE)


</code></pre>

<hr>
<h2 id='spline_timestamp_sync'>Spline columns to match timestamps.</h2><span id='topic+spline_timestamp_sync'></span>

<h3>Description</h3>

<p>Often timestamps of two data frames will be mismatched. To
produced matching timestamps, columns that may be splined
will be and then corresponding values at the 'correct'
timestamp are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_timestamp_sync(
  data,
  data_ts = "timestamp",
  merge_data,
  merge_ts = "timestamp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_timestamp_sync_+3A_data">data</code></td>
<td>
<p>A data frame with a correct timestamp column.</p>
</td></tr>
<tr><td><code id="spline_timestamp_sync_+3A_data_ts">data_ts</code></td>
<td>
<p>The column name for the <code>data</code>
timestamp. Defaults to 'timestamp'</p>
</td></tr>
<tr><td><code id="spline_timestamp_sync_+3A_merge_data">merge_data</code></td>
<td>
<p>A data frame that will be linearly
interpolated and merged with <code>data</code>.</p>
</td></tr>
<tr><td><code id="spline_timestamp_sync_+3A_merge_ts">merge_ts</code></td>
<td>
<p>The column name for the
<code>merge_data</code> timestamp. Defaults to 'timestamp'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any value that can not be linearly interpolated such as a
string will remain the same.
</p>


<h3>Value</h3>

<p>The resulting merged data frame.
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='test_df'>DOE RTC Sample PV System Data</h2><span id='topic+test_df'></span>

<h3>Description</h3>

<p>A dataset containing a small, randomly taken sample of PV data
from SDLE's data collection. It is included for the purposes of unit 
tests and vignettes, serving as an example of how the package's functions work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_df
</code></pre>


<h3>Format</h3>

<p>A .csv file that can be read as a dataframe. 16265 rows and 22 variables.
</p>

<hr>
<h2 id='time_frequency'>Determines the minutes between data points in a time-series</h2><span id='topic+time_frequency'></span>

<h3>Description</h3>

<p>Determines the minutes between data points in a time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_frequency(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_frequency_+3A_data">data</code></td>
<td>
<p>A time-series dataframe containing a column named 'timestamp'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value of the minutes between data points
</p>


<h3>Author(s)</h3>

<p>Arash Khalilnejad
</p>

<hr>
<h2 id='ts_inflate'>Inflate a time series data set.</h2><span id='topic+ts_inflate'></span>

<h3>Description</h3>

<p>Shifts known values to the nearest equidistant timestamp and fills in any
missing timestamps with NA values. An additional binary column named
<code>&lt;column to impute&gt;_imp</code> is added where 1 represents an unknown value
and zero represents a known value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_inflate(data, ts_col, col_to_imp, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_inflate_+3A_data">data</code></td>
<td>
<p>A data frame containing columns <code>ts_col</code> and
<code>col_to_imp</code>.</p>
</td></tr>
<tr><td><code id="ts_inflate_+3A_ts_col">ts_col</code></td>
<td>
<p>The name of the timestamp column.</p>
</td></tr>
<tr><td><code id="ts_inflate_+3A_col_to_imp">col_to_imp</code></td>
<td>
<p>The name of the column to impute.</p>
</td></tr>
<tr><td><code id="ts_inflate_+3A_dt">dt</code></td>
<td>
<p>The expected time between consecutive timestamps, in minutes.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
