<!DOCTYPE html><html><head><title>Help for package DiscreteTests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteTests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DiscreteTests-package'><p>Vectorised Computation of P-Values and Their Supports for Several Discrete</p>
Statistical Tests</a></li>
<li><a href='#binom.test.pv'><p>Binomial Tests</p></a></li>
<li><a href='#DiscreteTestResults'><p>Discrete Test Results Class</p></a></li>
<li><a href='#DiscreteTestResultsSummary'><p>Discrete Test Results Summary Class</p></a></li>
<li><a href='#fisher.test.pv'><p>Fisher's Exact Test for Count Data</p></a></li>
<li><a href='#mcnemar.test.pv'><p>McNemar's Test for Count Data</p></a></li>
<li><a href='#poisson.test.pv'><p>Poisson Test</p></a></li>
<li><a href='#summary.DiscreteTestResults'><p>Summarizing Discrete Test Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vectorised Computation of P-Values and Their Supports for
Several Discrete Statistical Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides vectorised functions for computing p-values of various
    common discrete statistical tests, as described e.g. in Agresti (2002)
    &lt;<a href="https://doi.org/10.1002%2F0471249688">doi:10.1002/0471249688</a>&gt;, including their distributions. Exact and
    approximate computation methods are provided. For exact p-values, several
    procedures of determining two-sided p-values are included, which are
    outlined in more detail in Hirji (2006) &lt;<a href="https://doi.org/10.1201%2F9781420036190">doi:10.1201/9781420036190</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, checkmate</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/DiscreteTests">https://github.com/DISOhda/DiscreteTests</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/DiscreteTests/issues">https://github.com/DISOhda/DiscreteTests/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 12:44:10 UTC; fjunge</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Junge [cre, aut],
  Christina Kihn [aut],
  Sebastian Döhler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;diso.fbmn@h-da.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-21 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DiscreteTests-package'>Vectorised Computation of P-Values and Their Supports for Several Discrete
Statistical Tests</h2><span id='topic+DiscreteTests'></span><span id='topic+DiscreteTests-package'></span>

<h3>Description</h3>

<p>This package provides vectorised functions for computing p-values of various
discrete statistical tests. Exact and approximate computation methods are
provided. For exact p-values, several procedures of determining two-sided
p-values are included.
</p>
<p>Additionally, these functions are capable of returning the discrete p-value
supports, i.e. all observable p-values under a null hypothesis. These
supports can be used for multiple testing procedures in the
<a href="DiscreteFDR.html#topic+DiscreteFDR">DiscreteFDR</a> and <a href="FDX.html#topic+FDX-package">FDX</a>
packages.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Junge <a href="mailto:diso.fbmn@h-da.de">diso.fbmn@h-da.de</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Christina Kihn
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sebastian Döhler [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Fisher, R. A. (1935). The logic of inductive inference.
<em>Journal of the Royal Statistical Society Series A</em>, <strong>98</strong>, pp.
39–54. <a href="https://doi.org/10.2307/2342435">doi:10.2307/2342435</a>
</p>
<p>Agresti, A. (2002). <em>Categorical data analysis</em> (2nd ed.). New York: John
Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>
<p>Blaker, H. (2000) Confidence curves and improved exact confidence intervals
for discrete distributions. <em>Canadian Journal of Statistics</em>,
<strong>28</strong>(4), pp. 783-798. <a href="https://doi.org/10.2307/3315916">doi:10.2307/3315916</a>
</p>
<p>Hirji, K. F. (2006). <em>Exact analysis of discrete data</em>. New York: Chapman
and Hall/CRC. pp. 55-83. <a href="https://doi.org/10.1201/9781420036190">doi:10.1201/9781420036190</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DISOhda/DiscreteTests">https://github.com/DISOhda/DiscreteTests</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DISOhda/DiscreteTests/issues">https://github.com/DISOhda/DiscreteTests/issues</a>
</p>
</li></ul>


<hr>
<h2 id='binom.test.pv'>Binomial Tests</h2><span id='topic+binom.test.pv'></span>

<h3>Description</h3>

<p><code>binom.test.pv()</code> performs an exact or approximate binomial test about the
probability of success in a Bernoulli experiment. In contrast to
<code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>, it is vectorised, only calculates p-values and offers
a normal approximation of their computation. Furthermore, it is capable of
returning the discrete p-value supports, i.e. all observable p-values under a
null hypothesis. Multiple tests can be evaluated simultaneously. In two-sided
tests, several procedures of obtaining the respective p-values are
implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.test.pv(
  x,
  n,
  p = 0.5,
  alternative = "two.sided",
  ts.method = "minlike",
  exact = TRUE,
  correct = TRUE,
  simple.output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.test.pv_+3A_x">x</code></td>
<td>
<p>integer vector giving the number of successes.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_n">n</code></td>
<td>
<p>integer vector giving the number of trials.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_p">p</code></td>
<td>
<p>numerical vector of hypothesised probabilities of success.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_alternative">alternative</code></td>
<td>
<p>character vector that indicates the alternative hypotheses; each value must be one of <code>"two.sided"</code> (the default), <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_ts.method">ts.method</code></td>
<td>
<p>single character string that indicates the two-sided p-value computation method (if any value in <code>alternative</code> equals <code>"two.sided"</code>) and must be one of <code>"minlike"</code> (the default), <code>"blaker"</code>, <code>"absdist"</code> or <code>"central"</code> (see details). Ignored, if <code>exact = FALSE</code>.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_exact">exact</code></td>
<td>
<p>logical value that indicates whether p-values are to be calculated by exact computation (<code>exact = TRUE</code>; the default) or by a continuous approximation.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_correct">correct</code></td>
<td>
<p>logical value that indicates if a continuity correction is to be applied (<code>correct = TRUE</code>; the default) or not. Ignored, if <code>exact = TRUE</code>.</p>
</td></tr>
<tr><td><code id="binom.test.pv_+3A_simple.output">simple.output</code></td>
<td>
<p>logical value that indicates whether an R6 class object, including the tests' parameters and support sets, i.e. all observable p-values under each null hypothesis, is to be returned (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>x</code>, <code>n</code>, <code>p</code> and <code>alternative</code> are vectorised. They are
replicated automatically to have the same lengths. This allows multiple
hypotheses to be tested simultaneously.
</p>
<p>If <code>p = NULL</code>, it is tested if the probability of success is 0.5 with
the alternative being specified by <code>alternative</code>.
</p>
<p>For exact computation, various procedures of determining two-sided p-values
are implemented.
</p>

<dl>
<dt><code>"minlike"</code></dt><dd><p>The standard approach in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code> and
<code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>. The probabilities of the
likelihoods that are equal or less than the observed one
are summed up. In Hirji (2006), it is referred to as the
<em>Probability-based</em> approach.</p>
</dd>
<dt><code>"blaker"</code></dt><dd><p>The minima of the observations' lower and upper tail
probabilities are combined with the opposite tail not
greater than these minima. More details can be found in
Blaker (2000) or Hirji (2006), where it is referred to as
the <em>Combined Tails</em> method.</p>
</dd>
<dt><code>"absdist"</code></dt><dd><p>The probabilities of the absolute distances from the
expected value that are greater than or equal to the
observed one are summed up. In Hirji (2006), it is
referred to as the <em>Distance from Center</em> approach.</p>
</dd>
<dt><code>"central"</code></dt><dd><p>The smaller values of the observations' simply doubles
the minimum of lower and upper tail probabilities. In
Hirji (2006), it is referred to as the <em>Twice the
Smaller Tail</em> method.</p>
</dd>
</dl>

<p>For non-exact (i.e. continuous approximation) approaches, <code>ts.method</code> is
ignored, since all its methods would yield the same p-values. More
specifically, they all converge to the doubling approach as in
<code>ts.mthod = "central"</code>.
</p>


<h3>Value</h3>

<p>If <code>simple.output = TRUE</code>, a vector of computed p-values is returned.
Otherwise, the output is a <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> R6 class object, which
also includes the p-value supports and testing parameters. These have to be
accessed by public methods, e.g. <code style="white-space: pre;">&#8288;$get_pvalues()&#8288;</code>.
</p>


<h3>References</h3>

<p>Agresti, A. (2002). <em>Categorical data analysis</em> (2nd ed.). New York: John
Wiley &amp; Sons. pp. 14-15. <a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>
<p>Blaker, H. (2000) Confidence curves and improved exact confidence intervals
for discrete distributions. <em>Canadian Journal of Statistics</em>,
<strong>28</strong>(4), pp. 783-798. <a href="https://doi.org/10.2307/3315916">doi:10.2307/3315916</a>
</p>
<p>Hirji, K. F. (2006). <em>Exact analysis of discrete data</em>. New York: Chapman
and Hall/CRC. pp. 55-83. <a href="https://doi.org/10.1201/9781420036190">doi:10.1201/9781420036190</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing
k &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
n &lt;- c(18, 12, 10)
p &lt;- c(0.5, 0.2, 0.3)

# Computation of exact two-sided p-values ("blaker") and their supports
results.ex  &lt;- binom.test.pv(k, n, p, ts.method = "blaker")
raw.pvalues &lt;- results.ex$get_pvalues()
pCDFlist    &lt;- results.ex$get_pvalue_supports()

# Computation of normal-approximated one-sided p-values (less) and their supports
results.ap  &lt;- binom.test.pv(k, n, p, "less", exact = FALSE)
raw.pvalues &lt;- results.ap$get_pvalues()
pCDFlist    &lt;- results.ap$get_pvalue_supports()

</code></pre>

<hr>
<h2 id='DiscreteTestResults'>Discrete Test Results Class</h2><span id='topic+DiscreteTestResults'></span>

<h3>Description</h3>

<p>This is the class used by the statistical test functions of this package for
returning not only p-values, but also the supports of their distributions and
the parameters of the respective tests. Objects of this class are obtained by
setting the <code>simple.output</code> parameter of a test function to <code>FALSE</code> (the
default). All data members of this class are private to avoid inconsistencies
by deliberate or inadvertent changes by the user. However, the results can be
read by public methods.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DiscreteTestResults-new"><code>DiscreteTestResults$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-get_pvalues"><code>DiscreteTestResults$get_pvalues()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-get_inputs"><code>DiscreteTestResults$get_inputs()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-get_pvalue_supports"><code>DiscreteTestResults$get_pvalue_supports()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-get_support_indices"><code>DiscreteTestResults$get_support_indices()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-print"><code>DiscreteTestResults$print()</code></a>
</p>
</li>
<li> <p><a href="#method-DiscreteTestResults-clone"><code>DiscreteTestResults$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DiscreteTestResults-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <code>DiscreteTestResults</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$new(
  test_name,
  inputs,
  p_values,
  pvalue_supports,
  support_indices,
  data_name
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>test_name</code></dt><dd><p>single character string with the name of the
test(s).</p>
</dd>
<dt><code>inputs</code></dt><dd><p>named list of <strong>exactly three</strong> elements
containing the observations, test parameters and
hypothesised null values <strong>as data frames</strong>;
names of these list fields must be
<code>observations</code>, <code>nullvalues</code> and <code>parameters</code>.
See details for further information about the
requirements for these fields.</p>
</dd>
<dt><code>p_values</code></dt><dd><p>numeric vector of the p-values calculated by
each hypothesis test.</p>
</dd>
<dt><code>pvalue_supports</code></dt><dd><p>list of <strong>unique</strong> numeric vectors containing
all p-values that are observable under the
respective hypothesis; each value of <code>p_values</code>
must occur in its respective p-value support.</p>
</dd>
<dt><code>support_indices</code></dt><dd><p>list of numeric vectors containing the test
indices that indicates to which individual
testing scenario each unique parameter set and
each unique support belongs.</p>
</dd>
<dt><code>data_name</code></dt><dd><p>single character string with the name of the
variable that contains the observed data.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The fields of the <code>inputs</code> have the following requirements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$observations&#8288;</code></dt><dd><p>data frame that contains the observed data; if
the observed data is a matrix, it must be
converted to a data frame; must not be <code>NULL</code>,
only numerical and character values are
allowed.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$nullvalues&#8288;</code></dt><dd><p>data frame that contains the hypothesised values
of the tests, e.g. the rate parameters for Poisson
tests; must not be <code>NULL</code>, only numerical values
are allowed.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$parameters&#8288;</code></dt><dd><p>data frame that holds the parameter combinations
of the null distribution of each test (e.g.
numbers of Bernoulli trials for binomial tests, or
<code>m</code>, <code>n</code> and <code>k</code> for the hypergeometric
distribution used by Fisher's Exact Test, which
have to be  derived from the observations first);
<strong>must</strong> include a mandatory column named
<code>alternative</code>; only numerical and character values
are allowed.</p>
</dd>
</dl>

<p>Missing values or <code>NULL</code>s are not allowed for any of these fields. All
data frames must have the same number of rows. Their column names are
used by the <code>print</code> method for producing text output, therefore they
should be informative, i.e. short and (if necessary) non-syntactic,
like e.g. <code>`number of success`</code>.
</p>


<hr>
<a id="method-DiscreteTestResults-get_pvalues"></a>



<h4>Method <code>get_pvalues()</code></h4>

<p>Returns the computed p-values.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$get_pvalues()</pre></div>



<h5>Returns</h5>

<p>A numeric vector of the p-values of all null hypotheses.
</p>


<hr>
<a id="method-DiscreteTestResults-get_inputs"></a>



<h4>Method <code>get_inputs()</code></h4>

<p>Return the list of the test inputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$get_inputs(unique = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unique</code></dt><dd><p>single logical value that indicates whether only unique
combinations of parameter sets and null values are to be
returned. If <code>unique = FALSE</code> (the default), the returned
data frames may contain duplicate sets.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of three elements. The first one contains a data frame with the
observations for each tested null hypothesis, while the second is another
data frame with the hypothesised null values (e.g. <code>p</code> for binomial
tests). The third list field holds the parameter sets (e.g. <code>n</code> in case
of a binomial test). If <code>unique = TRUE</code>, only unique combinations of
parameter sets and null values are returned, but observations remain
unchanged.
</p>


<hr>
<a id="method-DiscreteTestResults-get_pvalue_supports"></a>



<h4>Method <code>get_pvalue_supports()</code></h4>

<p>Returns the p-value supports, i.e. all observable p-values under the
respective null hypothesis of each test.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$get_pvalue_supports(unique = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unique</code></dt><dd><p>single logical value that indicates whether only unique
p-value supports are to be returned. If <code>unique = FALSE</code>
(the default), the returned supports may be duplicated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of numeric vectors containing the supports of the p-value null
distributions.
</p>


<hr>
<a id="method-DiscreteTestResults-get_support_indices"></a>



<h4>Method <code>get_support_indices()</code></h4>

<p>Returns the indices that indicate to which testing scenario each
unique support belongs.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$get_support_indices()</pre></div>



<h5>Returns</h5>

<p>A list of numeric vectors. Each one contains the indices of the null
hypotheses to which the respective support and/or unique parameter set
belongs.
</p>


<hr>
<a id="method-DiscreteTestResults-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the computed p-values.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$print(
  inputs = TRUE,
  pvalues = TRUE,
  supports = FALSE,
  test_idx = NULL,
  limit = 10,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inputs</code></dt><dd><p>single logical value that indicates if the inputs
values (i.e. observations and parameters) are to be
printed; defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>single logical value that indicates if the resulting
p-values are to be printed; defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>supports</code></dt><dd><p>single logical value that indicates if the p-value
supports are to be printed; defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>test_idx</code></dt><dd><p>integer vector giving the indices of the tests whose
results are to be printed; if <code>NULL</code> (the default),
results of every test up to the index specified by
<code>limit</code> (see below) are printed</p>
</dd>
<dt><code>limit</code></dt><dd><p>single integer that indicates the maximum number of
test results to be printed; if <code>limit = 0</code>, results of
every test are printed; ignored if <code>test_idx</code> is not
set to <code>NULL</code></p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments passed to <code>print.default</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Prints a summary of the tested null hypotheses. The object itself is
invisibly returned.
</p>


<hr>
<a id="method-DiscreteTestResults-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResults$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## one-sided binomial test
#  parameters
x &lt;- 2:4
n &lt;- 5
p &lt;- 0.4
m &lt;- length(x)
#  support (same for all three tests) and p-values
support &lt;- sapply(0:n, function(k) binom.test(k, n, p, "greater")$p.value)
pv &lt;- support[x + 1]
#  DiscreteTestResults object
res &lt;- DiscreteTestResults$new(
  # string with name of the test
  test_name = "Exact binomial test",
  # list of data frames
  inputs = list(
    observations = data.frame(
      `number of successes` = x,
      # no name check of column header to have a speaking name for 'print'
      check.names = FALSE
    ),
    parameters = data.frame(
      # parameter 'n', needs to be replicated to length of 'x'
      `number of trials` = rep(n, m),
      # mandatory parameter 'alternative', needs to be replicated to length of 'x'
      alternative = rep("greater", m),
      # no name check of column header to have a speaking name for 'print'
      check.names = FALSE
    ),
    nullvalues = data.frame(
      # here: only one null value, 'p'; needs to be replicated to length of 'x'
      `probability of success` = rep(p, m),
      # no name check of column header to have a speaking name for 'print'
      check.names = FALSE
    )
  ),
  # numerical vector of p-values
  p_values = pv,
  # list of supports (here: only one support); values must be sorted and unique
  pvalue_supports = list(sort(unique(support))),
  # list of indices that indicate which p-value/hypothesis each support belongs to
  support_indices = list(1:m),
  # name of input data variables
  data_name = "x, n and p"
)

#  print results without supports
print(res)
#  print results with supports
print(res, supports = TRUE)

</code></pre>

<hr>
<h2 id='DiscreteTestResultsSummary'>Discrete Test Results Summary Class</h2><span id='topic+DiscreteTestResultsSummary'></span>

<h3>Description</h3>

<p>This is the class used by <code>DiscreteTests</code> for summarising
<code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> objects. It contains the summarised objects itself, as
well as a summary data frame as private members. Both can be read by public
methods.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-summary.DiscreteTestResults-new"><code>DiscreteTestResultsSummary$new()</code></a>
</p>
</li>
<li> <p><a href="#method-summary.DiscreteTestResults-get_test_results"><code>DiscreteTestResultsSummary$get_test_results()</code></a>
</p>
</li>
<li> <p><a href="#method-summary.DiscreteTestResults-get_summary_table"><code>DiscreteTestResultsSummary$get_summary_table()</code></a>
</p>
</li>
<li> <p><a href="#method-summary.DiscreteTestResults-print"><code>DiscreteTestResultsSummary$print()</code></a>
</p>
</li>
<li> <p><a href="#method-summary.DiscreteTestResults-clone"><code>DiscreteTestResultsSummary$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-summary.DiscreteTestResults-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <code>summary.DiscreteTestResults</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResultsSummary$new(test_results)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>test_results</code></dt><dd><p>the <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> class object to be
summarised.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-summary.DiscreteTestResults-get_test_results"></a>



<h4>Method <code>get_test_results()</code></h4>

<p>Returns the underlying <a href="#topic+DiscreteTestResults">DiscreteTestResults</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResultsSummary$get_test_results()</pre></div>



<h5>Returns</h5>

<p>A <a href="#topic+DiscreteTestResults">DiscreteTestResults</a> R6 class object.
</p>


<hr>
<a id="method-summary.DiscreteTestResults-get_summary_table"></a>



<h4>Method <code>get_summary_table()</code></h4>

<p>Returns the summary table of the underlying <a href="#topic+DiscreteTestResults">DiscreteTestResults</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResultsSummary$get_summary_table()</pre></div>



<h5>Returns</h5>

<p>A data frame.
</p>


<hr>
<a id="method-summary.DiscreteTestResults-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the summary.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResultsSummary$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to <code>print.data.frame</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Prints a summary table of the tested null hypotheses. The object itself
is invisibly returned.
</p>


<hr>
<a id="method-summary.DiscreteTestResults-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiscreteTestResultsSummary$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># binomial tests
obj &lt;- binom.test.pv(0:5, 5, 0.5)
# create DiscreteTestResultsSummary object
res &lt;- DiscreteTestResultsSummary$new(obj)
# print summary
print(res)
# extract summary table
res$get_summary_table()

</code></pre>

<hr>
<h2 id='fisher.test.pv'>Fisher's Exact Test for Count Data</h2><span id='topic+fisher.test.pv'></span>

<h3>Description</h3>

<p><code>fisher.test.pv()</code> performs Fisher's exact test or a chi-square approximation
to assess if rows and columns of a 2-by-2 contingency table with fixed
marginals are independent. In contrast to <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>, it is
vectorised, only calculates p-values and offers a normal approximation of
their computation. Furthermore, it is capable of returning the discrete
p-value supports, i.e. all observable p-values under a null hypothesis.
Multiple tables can be analysed simultaneously. In two-sided tests, several
procedures of obtaining the respective p-values are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.test.pv(
  x,
  alternative = "two.sided",
  ts.method = "minlike",
  exact = TRUE,
  correct = TRUE,
  simple.output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.test.pv_+3A_x">x</code></td>
<td>
<p>integer vector with four elements, a 2-by-2 matrix or an integer
matrix (or data frame) with four columns, where each line
represents a 2-by-2 table to be tested.</p>
</td></tr>
<tr><td><code id="fisher.test.pv_+3A_alternative">alternative</code></td>
<td>
<p>character vector that indicates the alternative hypotheses; each value must be one of <code>"two.sided"</code> (the default), <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="fisher.test.pv_+3A_ts.method">ts.method</code></td>
<td>
<p>single character string that indicates the two-sided p-value computation method (if any value in <code>alternative</code> equals <code>"two.sided"</code>) and must be one of <code>"minlike"</code> (the default), <code>"blaker"</code>, <code>"absdist"</code> or <code>"central"</code> (see details). Ignored, if <code>exact = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fisher.test.pv_+3A_exact">exact</code></td>
<td>
<p>logical value that indicates whether p-values are to be calculated by exact computation (<code>exact = TRUE</code>; the default) or by a continuous approximation.</p>
</td></tr>
<tr><td><code id="fisher.test.pv_+3A_correct">correct</code></td>
<td>
<p>logical value that indicates if a continuity correction is to be applied (<code>correct = TRUE</code>; the default) or not. Ignored, if <code>exact = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fisher.test.pv_+3A_simple.output">simple.output</code></td>
<td>
<p>logical value that indicates whether an R6 class object, including the tests' parameters and support sets, i.e. all observable p-values under each null hypothesis, is to be returned (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>x</code> and <code>alternative</code> are vectorised. They are replicated
automatically, such that the number of <code>x</code>'s rows is the same as the length
of <code>alternative</code>. This allows multiple hypotheses to be tested
simultaneously. Since <code>x</code> is (if necessary) coerced to a matrix with four
columns, it is replicated row-wise.
</p>
<p>If <code>exact = TRUE</code>, Fisher's exact test is performed (the specific hypothesis
depends on the value of <code>alternative</code>). Otherwise, if <code>exact = FALSE</code>, a
chi-square approximation is used for two-sided hypotheses or a normal
approximation for one-sided tests, based on the square root of the
chi-squared statistic. This is possible because the degrees of freedom of
chi-squared tests on 2-by-2 tables are limited to 1.
</p>
<p>For exact computation, various procedures of determining two-sided p-values
are implemented.
</p>

<dl>
<dt><code>"minlike"</code></dt><dd><p>The standard approach in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code> and
<code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>. The probabilities of the
likelihoods that are equal or less than the observed one
are summed up. In Hirji (2006), it is referred to as the
<em>Probability-based</em> approach.</p>
</dd>
<dt><code>"blaker"</code></dt><dd><p>The minima of the observations' lower and upper tail
probabilities are combined with the opposite tail not
greater than these minima. More details can be found in
Blaker (2000) or Hirji (2006), where it is referred to as
the <em>Combined Tails</em> method.</p>
</dd>
<dt><code>"absdist"</code></dt><dd><p>The probabilities of the absolute distances from the
expected value that are greater than or equal to the
observed one are summed up. In Hirji (2006), it is
referred to as the <em>Distance from Center</em> approach.</p>
</dd>
<dt><code>"central"</code></dt><dd><p>The smaller values of the observations' simply doubles
the minimum of lower and upper tail probabilities. In
Hirji (2006), it is referred to as the <em>Twice the
Smaller Tail</em> method.</p>
</dd>
</dl>

<p>For non-exact (i.e. continuous approximation) approaches, <code>ts.method</code> is
ignored, since all its methods would yield the same p-values. More
specifically, they all converge to the doubling approach as in
<code>ts.mthod = "central"</code>.
</p>


<h3>Value</h3>

<p>If <code>simple.output = TRUE</code>, a vector of computed p-values is returned.
Otherwise, the output is a <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> R6 class object, which
also includes the p-value supports and testing parameters. These have to be
accessed by public methods, e.g. <code style="white-space: pre;">&#8288;$get_pvalues()&#8288;</code>.
</p>


<h3>References</h3>

<p>Fisher, R. A. (1935). The logic of inductive inference.
<em>Journal of the Royal Statistical Society Series A</em>, <strong>98</strong>, pp.
39–54. <a href="https://doi.org/10.2307/2342435">doi:10.2307/2342435</a>
</p>
<p>Agresti, A. (2002). <em>Categorical data analysis</em> (2nd ed.). New York: John
Wiley &amp; Sons. pp. 91–97. <a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>
<p>Blaker, H. (2000) Confidence curves and improved exact confidence intervals
for discrete distributions. <em>Canadian Journal of Statistics</em>,
<strong>28</strong>(4), pp. 783-798. <a href="https://doi.org/10.2307/3315916">doi:10.2307/3315916</a>
</p>
<p>Hirji, K. F. (2006). <em>Exact analysis of discrete data</em>. New York: Chapman
and Hall/CRC. pp. 55-83. <a href="https://doi.org/10.1201/9781420036190">doi:10.1201/9781420036190</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing
S1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
S2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
F1 &lt;- N1 - S1
F2 &lt;- N2 - S2
df &lt;- data.frame(S1, F1, S2, F2)

# Computation of Fisher's exact p-values (default: "minlike") and their supports
results.f   &lt;- fisher.test.pv(df)
raw.pvalues &lt;- results.f$get_pvalues()
pCDFlist    &lt;- results.f$get_pvalue_supports()

# Computation of p-values of chi-square tests and their supports
results.c   &lt;- fisher.test.pv(df, exact = FALSE)
raw.pvalues &lt;- results.c$get_pvalues()
pCDFlist    &lt;- results.c$get_pvalue_supports()

</code></pre>

<hr>
<h2 id='mcnemar.test.pv'>McNemar's Test for Count Data</h2><span id='topic+mcnemar.test.pv'></span>

<h3>Description</h3>

<p>Performs McNemar's chi-square test or an exact variant to assess the symmetry
of rows and columns in a 2-by-2 contingency table. In contrast to
<code><a href="stats.html#topic+mcnemar.test">stats::mcnemar.test()</a></code>, it is vectorised, only calculates p-values and
offers their exact computation. Furthermore, it is capable of returning the
discrete p-value supports, i.e. all observable p-values under a null
hypothesis. Multiple tables can be analysed simultaneously. In two-sided
tests, several procedures of obtaining the respective p-values are
implemented. It is a special case of the <a href="#topic+binom.test.pv">binomial test</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcnemar.test.pv(
  x,
  alternative = "two.sided",
  exact = TRUE,
  correct = TRUE,
  simple.output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcnemar.test.pv_+3A_x">x</code></td>
<td>
<p>integer vector with four elements, a 2-by-2 matrix or an integer
matrix (or data frame) with four columns where each line
represents a 2-by-2 table to be tested.</p>
</td></tr>
<tr><td><code id="mcnemar.test.pv_+3A_alternative">alternative</code></td>
<td>
<p>character vector that indicates the alternative hypotheses; each value must be one of <code>"two.sided"</code> (the default), <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="mcnemar.test.pv_+3A_exact">exact</code></td>
<td>
<p>logical value that indicates whether p-values are to be calculated by exact computation (<code>exact = TRUE</code>; the default) or by a continuous approximation.</p>
</td></tr>
<tr><td><code id="mcnemar.test.pv_+3A_correct">correct</code></td>
<td>
<p>logical value that indicates if a continuity correction is to be applied (<code>correct = TRUE</code>; the default) or not. Ignored, if <code>exact = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mcnemar.test.pv_+3A_simple.output">simple.output</code></td>
<td>
<p>logical value that indicates whether an R6 class object, including the tests' parameters and support sets, i.e. all observable p-values under each null hypothesis, is to be returned (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>x</code> and <code>alternative</code> are vectorised. They are replicated
automatically, such that the number of <code>x</code>'s rows is the same as the length
of <code>alternative</code>. This allows multiple hypotheses to be tested
simultaneously. Since 'x is (if necessary) coerced to a matrix with four
columns, it is replicated row-wise.
</p>
<p>It can be shown that McNemar's test is a special case of the binomial test.
Therefore, its computations are handled by <code><a href="#topic+binom.test.pv">binom.test.pv()</a></code>. In contrast to
that function, <code>mcnemar.test.pv</code> does not allow specifying exact two-sided
p-value calculation procedures. The reason is that McNemar's exact test
always tests for a probability of 0.5, in which case all these exact
two-sided p-value computation methods yield exactly the same results.
</p>


<h3>Value</h3>

<p>If <code>simple.output = TRUE</code>, a vector of computed p-values is returned.
Otherwise, the output is a <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> R6 class object, which
also includes the p-value supports and testing parameters. These have to be
accessed by public methods, e.g. <code style="white-space: pre;">&#8288;$get_pvalues()&#8288;</code>.
</p>


<h3>References</h3>

<p>Agresti, A. (2002). <em>Categorical data analysis</em> (2nd ed.). New York: John
Wiley &amp; Sons. pp. 411–413. <a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mcnemar.test">stats::mcnemar.test()</a></code>, <code><a href="#topic+binom.test.pv">binom.test.pv()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing
S1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
S2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
F1 &lt;- N1 - S1
F2 &lt;- N2 - S2
df &lt;- data.frame(S1, F1, S2, F2)

# Computation of exact p-values and their supports
results.ex  &lt;- mcnemar.test.pv(df)
raw.pvalues &lt;- results.ex$get_pvalues()
pCDFlist    &lt;- results.ex$get_pvalue_supports()

# Computation of chisquare p-values and their supports
results.cs  &lt;- mcnemar.test.pv(df, exact = FALSE)
raw.pvalues &lt;- results.cs$get_pvalues()
pCDFlist    &lt;- results.cs$get_pvalue_supports()

</code></pre>

<hr>
<h2 id='poisson.test.pv'>Poisson Test</h2><span id='topic+poisson.test.pv'></span>

<h3>Description</h3>

<p><code>poisson.test.pv()</code> performs an exact or approximate Poisson test about the
rate parameter of a Poisson distribution. In contrast to
<code><a href="stats.html#topic+poisson.test">stats::poisson.test()</a></code>, it is vectorised, only calculates p-values and
offers a normal approximation of their computation. Furthermore, it is
capable of returning the discrete p-value supports, i.e. all observable
p-values under a null hypothesis. Multiple tests can be evaluated
simultaneously. In two-sided tests, several procedures of obtaining the
respective p-values are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson.test.pv(
  x,
  lambda = 1,
  alternative = "two.sided",
  ts.method = "minlike",
  exact = TRUE,
  correct = TRUE,
  simple.output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisson.test.pv_+3A_x">x</code></td>
<td>
<p>integer vector giving the number of events.</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_lambda">lambda</code></td>
<td>
<p>non-negative numerical vector of hypothesised rate(s).</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_alternative">alternative</code></td>
<td>
<p>character vector that indicates the alternative hypotheses; each value must be one of <code>"two.sided"</code> (the default), <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_ts.method">ts.method</code></td>
<td>
<p>single character string that indicates the two-sided p-value computation method (if any value in <code>alternative</code> equals <code>"two.sided"</code>) and must be one of <code>"minlike"</code> (the default), <code>"blaker"</code>, <code>"absdist"</code> or <code>"central"</code> (see details). Ignored, if <code>exact = FALSE</code>.</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_exact">exact</code></td>
<td>
<p>logical value that indicates whether p-values are to be calculated by exact computation (<code>exact = TRUE</code>; the default) or by a continuous approximation.</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_correct">correct</code></td>
<td>
<p>logical value that indicates if a continuity correction is to be applied (<code>correct = TRUE</code>; the default) or not. Ignored, if <code>exact = TRUE</code>.</p>
</td></tr>
<tr><td><code id="poisson.test.pv_+3A_simple.output">simple.output</code></td>
<td>
<p>logical value that indicates whether an R6 class object, including the tests' parameters and support sets, i.e. all observable p-values under each null hypothesis, is to be returned (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>x</code>, <code>lambda</code> and <code>alternative</code> are vectorised. They are
replicated automatically to have the same lengths. This allows multiple
hypotheses to be tested simultaneously.
</p>
<p>Since the Poisson distribution itself has an infinite support, so do the
p-values of exact Poisson tests. Thus supports only contain p-values that are
not rounded off to 0.
</p>
<p>For exact computation, various procedures of determining two-sided p-values
are implemented.
</p>

<dl>
<dt><code>"minlike"</code></dt><dd><p>The standard approach in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code> and
<code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>. The probabilities of the
likelihoods that are equal or less than the observed one
are summed up. In Hirji (2006), it is referred to as the
<em>Probability-based</em> approach.</p>
</dd>
<dt><code>"blaker"</code></dt><dd><p>The minima of the observations' lower and upper tail
probabilities are combined with the opposite tail not
greater than these minima. More details can be found in
Blaker (2000) or Hirji (2006), where it is referred to as
the <em>Combined Tails</em> method.</p>
</dd>
<dt><code>"absdist"</code></dt><dd><p>The probabilities of the absolute distances from the
expected value that are greater than or equal to the
observed one are summed up. In Hirji (2006), it is
referred to as the <em>Distance from Center</em> approach.</p>
</dd>
<dt><code>"central"</code></dt><dd><p>The smaller values of the observations' simply doubles
the minimum of lower and upper tail probabilities. In
Hirji (2006), it is referred to as the <em>Twice the
Smaller Tail</em> method.</p>
</dd>
</dl>

<p>For non-exact (i.e. continuous approximation) approaches, <code>ts.method</code> is
ignored, since all its methods would yield the same p-values. More
specifically, they all converge to the doubling approach as in
<code>ts.mthod = "central"</code>.
</p>


<h3>Value</h3>

<p>If <code>simple.output = TRUE</code>, a vector of computed p-values is returned.
Otherwise, the output is a <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> R6 class object, which
also includes the p-value supports and testing parameters. These have to be
accessed by public methods, e.g. <code style="white-space: pre;">&#8288;$get_pvalues()&#8288;</code>.
</p>


<h3>References</h3>

<p>Blaker, H. (2000) Confidence curves and improved exact confidence intervals
for discrete distributions. <em>Canadian Journal of Statistics</em>,
<strong>28</strong>(4), pp. 783-798. <a href="https://doi.org/10.2307/3315916">doi:10.2307/3315916</a>
</p>
<p>Hirji, K. F. (2006). <em>Exact analysis of discrete data</em>. New York: Chapman
and Hall/CRC. pp. 55-83. <a href="https://doi.org/10.1201/9781420036190">doi:10.1201/9781420036190</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binom.test.pv">binom.test.pv()</a></code>, <code><a href="stats.html#topic+poisson.test">stats::poisson.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing
k &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
lambda &lt;- c(3, 2, 1)

# Computation of exact two-sided p-values ("blaker") and their supports
results.ex  &lt;- poisson.test.pv(k, lambda, ts.method = "blaker")
raw.pvalues &lt;- results.ex$get_pvalues()
pCDFlist    &lt;- results.ex$get_pvalue_supports()

# Computation of normal-approximated one-sided p-values ("less") and their supports
results.ap  &lt;- poisson.test.pv(k, lambda, "less", exact = FALSE)
raw.pvalues &lt;- results.ap$get_pvalues()
pCDFlist    &lt;- results.ap$get_pvalue_supports()

</code></pre>

<hr>
<h2 id='summary.DiscreteTestResults'>Summarizing Discrete Test Results</h2><span id='topic+summary.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteTestResults'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DiscreteTestResults_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+DiscreteTestResults">DiscreteTestResults</a></code> to be summarised;
usually created by using one of the packages test functions,
e.g. <code><a href="#topic+binom.test.pv">binom.test.pv()</a></code>, with <code>simple.output = FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.DiscreteTestResults_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+DiscreteTestResultsSummary">summary.DiscreteTestResults</a></code> R6 class
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binomial tests
obj &lt;- binom.test.pv(0:5, 5, 0.5)
# print summary
summary(obj)
# extract summary table
smry &lt;- summary(obj)
smry$get_summary_table()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
