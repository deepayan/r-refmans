<!DOCTYPE html><html lang="en"><head><title>Help for package simdata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simdata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_array'><p>Helper to apply functions</p></a></li>
<li><a href='#as_function_list'><p>Create <code>function_list</code> object from list of functions</p></a></li>
<li><a href='#colapply_functions'><p>Apply list of functions to column of object</p></a></li>
<li><a href='#contains_constant'><p>Check if matrix contains constant column(s)</p></a></li>
<li><a href='#cor_from_upper'><p>Build correlation matrix</p></a></li>
<li><a href='#cor_to_cov'><p>Convert correlation matrix to covariance matrix</p></a></li>
<li><a href='#cor_to_upper'><p>Convert correlation matrix to specification used by</p>
<code>cor_from_upper</code></a></li>
<li><a href='#do_processing'><p>Post-processing of datamatrix</p></a></li>
<li><a href='#estimate_final_correlation'><p>Estimate correlation matrix via simulation</p></a></li>
<li><a href='#function_list'><p>Apply list of functions to input</p></a></li>
<li><a href='#get_from_function_list'><p>Extract individual functions from <code>function_list</code></p></a></li>
<li><a href='#get_names_from_function_list'><p>Extract names of individual functions from <code>function_list</code></p></a></li>
<li><a href='#is_collinear'><p>Check if matrix is collinear</p></a></li>
<li><a href='#is_cor_matrix'><p>Check if matrix is a correlation matrix</p></a></li>
<li><a href='#optimize_cor_for_pair'><p>Find pairwise initial correlation for NORTA from target correlation</p></a></li>
<li><a href='#optimize_cor_mat'><p>Find initial correlation matrix for NORTA from target correlation</p></a></li>
<li><a href='#partial'><p>Define partial function</p></a></li>
<li><a href='#plot_cor_network'><p>Visualize fixed correlation structure as a network</p></a></li>
<li><a href='#plot_estimated_cor_network'><p>Visualize estimated correlation matrix as a network</p></a></li>
<li><a href='#process_truncate_by_iqr'><p>Truncate columns of datamatrix at datamatrix specific thresholds</p></a></li>
<li><a href='#process_truncate_by_threshold'><p>Truncate columns of datamatrix at specified thresholds</p></a></li>
<li><a href='#quantile_functions_from_data'><p>Helper to estimate quantile functions from data for NORTA</p></a></li>
<li><a href='#simdesign'><p>Design specification for simulating datasets</p></a></li>
<li><a href='#simdesign_discunif'><p>Uniform disc sampling design specification</p></a></li>
<li><a href='#simdesign_mvtnorm'><p>Multivariate normal design specification</p></a></li>
<li><a href='#simdesign_norta'><p>NORTA-based design specification</p></a></li>
<li><a href='#simulate_data'><p>Simulate design matrix</p></a></li>
<li><a href='#simulate_data_conditional'><p>Simulate data which satisfies certain conditions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Simulated Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Kammer &lt;michael.kammer@meduniwien.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate simulated datasets from an initial underlying
    distribution and apply transformations to obtain realistic data. Implements
    the 'NORTA' (Normal-to-anything) approach from Cario and Nelson (1997)
    and other data generating mechanisms. Simple network visualization tools 
    are provided to facilitate communicating the simulation setup.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, mvtnorm, igraph (&ge; 1.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, doRNG, dplyr, fitdistrplus, forcats, ggplot2,
GGally, ggcorrplot, knitr, patchwork, purrr, reshape2,
rmarkdown, NHANES, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://matherealize.github.io/simdata/">https://matherealize.github.io/simdata/</a>,
<a href="https://github.com/matherealize/simdata">https://github.com/matherealize/simdata</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matherealize/simdata/issues">https://github.com/matherealize/simdata/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-03 15:08:35 UTC; MichaelK</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Kammer <a href="https://orcid.org/0000-0003-4821-9928"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-03 23:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_array'>Helper to apply functions</h2><span id='topic+apply_array'></span>

<h3>Description</h3>

<p>Used to make use of apply-like operations, regardless of wether the input
is a matrix or a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_array(obj, dim, fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_array_+3A_obj">obj</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id="apply_array_+3A_dim">dim</code></td>
<td>
<p>Dimension to apply function to.</p>
</td></tr>
<tr><td><code id="apply_array_+3A_fun">fun</code></td>
<td>
<p>Function object to apply.</p>
</td></tr>
</table>

<hr>
<h2 id='as_function_list'>Create <code>function_list</code> object from list of functions</h2><span id='topic+as_function_list'></span>

<h3>Description</h3>

<p>Create a <code>function_list</code> object from a list of functions. This is useful
if such a list is created programmatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_function_list(flist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_function_list_+3A_flist">flist</code></td>
<td>
<p>List in which each entry is a function object. Can be named or unnamed.</p>
</td></tr>
<tr><td><code id="as_function_list_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+function_list">function_list</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with a single input which outputs a data.frame. Has special
'flist' entry in its environment which stores individual functions as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+function_list">function_list</a></code>
</p>

<hr>
<h2 id='colapply_functions'>Apply list of functions to column of object</h2><span id='topic+colapply_functions'></span>

<h3>Description</h3>

<p>Helper function to simplify workflow with lists of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colapply_functions(obj, flist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colapply_functions_+3A_obj">obj</code></td>
<td>
<p>2-dimensional array (matrix or data.frame).</p>
</td></tr>
<tr><td><code id="colapply_functions_+3A_flist">flist</code></td>
<td>
<p>List of functions of length equal to the number of columns of <code>obj</code>.
Each entry must be a function applicable to a single column of <code>obj</code>.
The i-th entry of <code>flist</code> is applied to the i-th column of <code>obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix or data.frame (same type as <code>obj</code>) with names taken from <code>obj</code>.
</p>

<hr>
<h2 id='contains_constant'>Check if matrix contains constant column(s)</h2><span id='topic+contains_constant'></span>

<h3>Description</h3>

<p>Check if matrix contains constant column(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_constant(x, eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contains_constant_+3A_x">x</code></td>
<td>
<p>Matrix or Data.frame.</p>
</td></tr>
<tr><td><code id="contains_constant_+3A_eps">eps</code></td>
<td>
<p>Threshold for standard deviation below which a column is considered to be
constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if one of the columns has standard deviation of below 'eps&ldquo;, else
FALSE.
</p>


<h3>Note</h3>

<p>Prints a warning if constant is found.
</p>

<hr>
<h2 id='cor_from_upper'>Build correlation matrix</h2><span id='topic+cor_from_upper'></span>

<h3>Description</h3>

<p>Use to specify correlation matrix in convenient way
by giving entries of the upper triangular part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_from_upper(n_var, entries = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_from_upper_+3A_n_var">n_var</code></td>
<td>
<p>Integer, number of variables (= rows = columns of matrix).</p>
</td></tr>
<tr><td><code id="cor_from_upper_+3A_entries">entries</code></td>
<td>
<p>Matrix of correlation entries. Consists of 3 columns
(variable_1, variable_2, correlation) that specify both variables
and corresponding correlation in the upper triangular part of
the matrix (i.e. variable_1 &lt; variable_2) .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with user supplied entries.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_to_upper">cor_to_upper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_from_upper(2, rbind(c(1, 2, 0.8)))

</code></pre>

<hr>
<h2 id='cor_to_cov'>Convert correlation matrix to covariance matrix</h2><span id='topic+cor_to_cov'></span>

<h3>Description</h3>

<p>Rescale correlation matrix by variable standard deviations to yield a
covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_to_cov(m, sds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_to_cov_+3A_m">m</code></td>
<td>
<p>Symmetric correlation matrix.</p>
</td></tr>
<tr><td><code id="cor_to_cov_+3A_sds">sds</code></td>
<td>
<p>Standard deviations of the variables. Set to 1 for all varirables by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Symmetric covariance matrix.
</p>

<hr>
<h2 id='cor_to_upper'>Convert correlation matrix to specification used by
<code>cor_from_upper</code></h2><span id='topic+cor_to_upper'></span>

<h3>Description</h3>

<p>Convert correlation matrix to specification used by
<code>cor_from_upper</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_to_upper(m, remove_below = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_to_upper_+3A_m">m</code></td>
<td>
<p>Symmetric correlation matrix.</p>
</td></tr>
<tr><td><code id="cor_to_upper_+3A_remove_below">remove_below</code></td>
<td>
<p>Threshold for absolute correlation values below which they are removed from
the returned matrix. If NULL then no filtering is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with 3 columns (variable_1, variable_2, correlation), where
correlation gives the entry at position (variable_1, variable_2) of the
input correlation matrix. Note that variable_1 &lt; variable_2 holds for all
entries.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_from_upper">cor_from_upper</a></code>
</p>

<hr>
<h2 id='do_processing'>Post-processing of datamatrix</h2><span id='topic+do_processing'></span>

<h3>Description</h3>

<p>Applies functions to a matrix or data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_processing(x, functions = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_processing_+3A_x">x</code></td>
<td>
<p>Matrix or Data.frame.</p>
</td></tr>
<tr><td><code id="do_processing_+3A_functions">functions</code></td>
<td>
<p>List of lists, specifying functions to be applied as well as their
arguments. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions are passed into the post-processor as a named list. The name
<code>f</code> of the list entry is the function to be applied via
<code><a href="base.html#topic+do.call">base::do.call</a></code>.
The list entry itself is another named list, specifying the arguments
to the function <code>f</code> as named arguments.
</p>
<p>The functions must take a matrix or data.frame as first argument and
return another matrix or data.frame of the same dimensions as
single output.
</p>
<p>Examples of post-processing steps are truncation
(<code><a href="#topic+process_truncate_by_iqr">process_truncate_by_iqr</a></code>,
<code><a href="#topic+process_truncate_by_threshold">process_truncate_by_threshold</a></code>) or
centering / standardizing data (via <code><a href="base.html#topic+scale">scale</a></code>,
see example section below).
</p>
<p>Can be useful to apply on simulated datasets, even outside of the
simulation function (e.g. when standardization is only required at the
modeling step).
</p>


<h3>Value</h3>

<p>Matrix or data.frame with post-processing applied.
</p>


<h3>Note</h3>

<p>Use with caution - no error checking is done for now so the user has
to take care of everything themselves! Furthermore, output of the
functions is not checked either.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>do_processing(diag(5), 
    functions = list(scale = list(center = TRUE, scale = FALSE)))

</code></pre>

<hr>
<h2 id='estimate_final_correlation'>Estimate correlation matrix via simulation</h2><span id='topic+estimate_final_correlation'></span>

<h3>Description</h3>

<p>Used to obtain an estimate of the correlation matrix after transforming
the initial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_final_correlation(
  obj,
  n_obs = 1e+05,
  cor_type = "pearson",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_final_correlation_+3A_obj">obj</code></td>
<td>
<p>S3 class object of type <code>simdesign</code> (or inheriting from it).</p>
</td></tr>
<tr><td><code id="estimate_final_correlation_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="estimate_final_correlation_+3A_cor_type">cor_type</code></td>
<td>
<p>Can be either a character (<code>pearson</code>, <code>spearman</code>, <code>kendall</code>) which is
passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> or a function, which is
directly used to compute the correlation matrix on the simulated data.
Such a function is expected to take a single input matrix (and possibly other
arguments which can be set via <code>...</code>) and output a single matrix.</p>
</td></tr>
<tr><td><code id="estimate_final_correlation_+3A_seed">seed</code></td>
<td>
<p>Random number seed. NULL does not change the current seed.</p>
</td></tr>
<tr><td><code id="estimate_final_correlation_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the function that computes the correlation
matrix (either <code><a href="stats.html#topic+cor">stats::cor</a></code> or the user provided
function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to estimate the final correlation of the data after
transformation of the initial data. To provide a robust estimate it is
advised to use a very large number of observations to compute the correlation
matrix.
</p>


<h3>Value</h3>

<p>A numeric matrix given by the pairwise correlation coefficients for each
pair of variables defined by <code>obj</code> and computed according to <code>cor_type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_data">simulate_data</a></code>,
<code><a href="#topic+simdesign">simdesign</a></code>
</p>

<hr>
<h2 id='function_list'>Apply list of functions to input</h2><span id='topic+function_list'></span>

<h3>Description</h3>

<p>Apply list of functions to input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_list(..., stringsAsFactors = FALSE, check.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="function_list_+3A_...">...</code></td>
<td>
<p>Named or unnamed arguments, each of which is a function taking exactly
one input. See details.</p>
</td></tr>
<tr><td><code id="function_list_+3A_stringsasfactors">stringsAsFactors</code>, <code id="function_list_+3A_check.names">check.names</code></td>
<td>
<p>Arguments of <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function which takes a number of functions and returns
another function which applies all of the user specified functions to a new
input, and collects the results as list or data.frame.
This is useful to e.g. transform columns of a data.frame or check
the validity of a matrix during simulations. See the example here and
in <code><a href="#topic+simulate_data_conditional">simulate_data_conditional</a></code>.
</p>
<p>The assumptions for the individual functions are:
</p>

<ul>
<li><p> Each function is expected to take a single input.
</p>
</li>
<li><p> Each function is expected to output a result consistent with the
other functions (i.e. same output length) to ensure that the results can be
summarized as a data.frame.
</p>
</li></ul>



<h3>Value</h3>

<p>Function with a single input which outputs a data.frame. Has special
'flist' entry in its environment which stores individual functions as list.
</p>


<h3>Note</h3>

<p>This function works fine without naming the input arguments, but the
resulting data.frames have empty column names if that is the case. Thus,
it is recommended to only pass named function arguments.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>,
<code><a href="#topic+get_from_function_list">get_from_function_list</a></code>,
<code><a href="#topic+get_names_from_function_list">get_names_from_function_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function_list(
    v1 = function(x) x[, 1] * 2,
    v2 = function(x) x[, 2] + 10)

f(diag(2))

# function_list can be used to add new columns
# naming of columns should be handled separately in such cases

f &lt;- function_list(
    function(x) x, # return x as it is
    X1_X2 = function(x) x[, 2] + 10) # add new column

f(diag(2))

</code></pre>

<hr>
<h2 id='get_from_function_list'>Extract individual functions from <code>function_list</code></h2><span id='topic+get_from_function_list'></span>

<h3>Description</h3>

<p>Extract individual function objects from environment of a <code>function_list</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_from_function_list(flist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_from_function_list_+3A_flist">flist</code></td>
<td>
<p><code>function_list</code> or function object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with named or unnamed entries corresponding to individual function
objects that were passed to the <code>function_list</code> object. If <code>flist</code> is a
simple function, returns NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+function_list">function_list</a></code>
</p>

<hr>
<h2 id='get_names_from_function_list'>Extract names of individual functions from <code>function_list</code></h2><span id='topic+get_names_from_function_list'></span>

<h3>Description</h3>

<p>Extract names of  individual function objects from environment of a
<code>function_list</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_names_from_function_list(flist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_names_from_function_list_+3A_flist">flist</code></td>
<td>
<p><code>function_list</code> or function object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Names of list corresponding to individual function objects that were passed
to the <code>function_list</code> object. If <code>flist</code> is a simple function, returns NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+function_list">function_list</a></code>
</p>

<hr>
<h2 id='is_collinear'>Check if matrix is collinear</h2><span id='topic+is_collinear'></span>

<h3>Description</h3>

<p>Check if matrix is collinear
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_collinear(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_collinear_+3A_x">x</code></td>
<td>
<p>Matrix or Data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if matrix is collinear, else FALSE.
</p>


<h3>Note</h3>

<p>Prints a warning if collinear.
</p>

<hr>
<h2 id='is_cor_matrix'>Check if matrix is a correlation matrix</h2><span id='topic+is_cor_matrix'></span>

<h3>Description</h3>

<p>Checks if matrix is numeric, symmetric, has diagonal elements of one,
has only entries in <code style="white-space: pre;">&#8288;[-1, 1]&#8288;</code>, and is positive definite. Prints a warning
if a problem was found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cor_matrix(m, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_cor_matrix_+3A_m">m</code></td>
<td>
<p>Matrix.</p>
</td></tr>
<tr><td><code id="is_cor_matrix_+3A_tol">tol</code></td>
<td>
<p>Tolerance for checking diagonal elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if matrix is a correlation matrix, else <code>FALSE</code>.
</p>

<hr>
<h2 id='optimize_cor_for_pair'>Find pairwise initial correlation for NORTA from target correlation</h2><span id='topic+optimize_cor_for_pair'></span>

<h3>Description</h3>

<p>This function can be used to find a suitable initial correlation for use
in the NORTA procedure for a pair of variables with given marginal
distributions and target correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_cor_for_pair(
  cor_target,
  dist1,
  dist2,
  n_obs = 1e+05,
  seed = NULL,
  tol = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_cor_for_pair_+3A_cor_target">cor_target</code></td>
<td>
<p>Target correlation of variable pair.</p>
</td></tr>
<tr><td><code id="optimize_cor_for_pair_+3A_dist1">dist1</code>, <code id="optimize_cor_for_pair_+3A_dist2">dist2</code></td>
<td>
<p>Marginal distributions of variable pair, given as univariable quantile
functions.</p>
</td></tr>
<tr><td><code id="optimize_cor_for_pair_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations to be used in the numerical optimization procedure.</p>
</td></tr>
<tr><td><code id="optimize_cor_for_pair_+3A_seed">seed</code></td>
<td>
<p>Seed for generating standard normal random variables in the numerical
optimization procedure.</p>
</td></tr>
<tr><td><code id="optimize_cor_for_pair_+3A_tol">tol</code>, <code id="optimize_cor_for_pair_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="stats.html#topic+uniroot">stats::uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="stats.html#topic+uniroot">stats::uniroot</a></code> for actual optimization.
</p>


<h3>Value</h3>

<p>Output of <code><a href="stats.html#topic+uniroot">stats::uniroot</a></code> for the univariable
optimization for find the initial correlation.
</p>

<hr>
<h2 id='optimize_cor_mat'>Find initial correlation matrix for NORTA from target correlation</h2><span id='topic+optimize_cor_mat'></span>

<h3>Description</h3>

<p>This function can be used to find a suitable correlation matrix to be used
for simulating initial multivariate normal data in a NORTA based simulation
design (see <code><a href="#topic+simdesign_norta">simdesign_norta</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_cor_mat(
  cor_target,
  dist,
  ensure_cor_mat = TRUE,
  conv_norm_type = "O",
  return_diagnostics = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_cor_mat_+3A_cor_target">cor_target</code></td>
<td>
<p>Target correlation matrix.</p>
</td></tr>
<tr><td><code id="optimize_cor_mat_+3A_dist">dist</code></td>
<td>
<p>List of functions of marginal distributions for simulated variables.
Must have the same length as the specified correlation matrix
(<code>cor_target</code>), and the order of the entries must correspond to the
variables in the correlation matrix. See <code><a href="#topic+simdesign_norta">simdesign_norta</a></code> for
details of the specification of the marginal distributions.</p>
</td></tr>
<tr><td><code id="optimize_cor_mat_+3A_ensure_cor_mat">ensure_cor_mat</code></td>
<td>
<p>if TRUE, this function ensures that the optimized matrix is a proper
correlation matrix by ensuring positive definitiness. If FALSE, the
optimized matrix is returned as is.</p>
</td></tr>
<tr><td><code id="optimize_cor_mat_+3A_conv_norm_type">conv_norm_type</code></td>
<td>
<p>Metric to be used to find closest positive definite matrix to optimal matrix,
used if <code>ensure_cor_mat</code> is TRUE.
Passed to <code><a href="Matrix.html#topic+nearPD">Matrix::nearPD</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_cor_mat_+3A_return_diagnostics">return_diagnostics</code></td>
<td>
<p>TRUE to return additional diagnostics of the optimization procedure, see
below.</p>
</td></tr>
<tr><td><code id="optimize_cor_mat_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="#topic+optimize_cor_for_pair">optimize_cor_for_pair</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first finds a suitable correlation matrix for the underlying
multivariate normal data used in the NORTA procedure. It does so by
solving k*(k-1) univariable optimisation problems (where k is the number
of variables). In case the result is not a positive-definite matrix, the
nearest positive-definite matrix is found according to the user specified
metric using <code><a href="Matrix.html#topic+nearPD">Matrix::nearPD</a></code>.
See e.g. Ghosh and Henderson (2003) for an overview of the procedure.
</p>


<h3>Value</h3>

<p>If <code>return_diagnostics</code> is FALSE, a correlation matrix to be used in the
definition of a <code><a href="#topic+simdesign_norta">simdesign_norta</a></code> object. If TRUE, then a list
with two entries: <code>cor_mat</code> containing the correlation matrix, and
<code>convergence</code> containing a list of objects returned by the individual
optimisation problems from <code><a href="stats.html#topic+uniroot">stats::uniroot</a></code>.
</p>


<h3>References</h3>

<p>Ghosh, S. and Henderson, S. G. (2003) <em>Behavior of the
NORTA method for correlated random vector generation as the dimension
increases</em>. ACM Transactions on Modeling and Computer Simulation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign_norta">simdesign_norta</a></code>
</p>

<hr>
<h2 id='partial'>Define partial function</h2><span id='topic+partial'></span>

<h3>Description</h3>

<p>Partial functions are useful to define marginal distributions based on
additional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial(f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_+3A_f">f</code></td>
<td>
<p>Function in two or more parameters.</p>
</td></tr>
<tr><td><code id="partial_+3A_...">...</code></td>
<td>
<p>Parameters to be held fixed for function <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function stores passed arguments in a list, and stores this
list in the environment of the returned function. Thus, it remembers the
arguments that should be held fixed, such that the returned partial function
now is a function with fewer arguments.
</p>


<h3>Value</h3>

<p>Function object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marginal &lt;- partial(function(x, meanx) qnorm(x, meanx), meanx = 2)
marginal(0.5)

</code></pre>

<hr>
<h2 id='plot_cor_network'>Visualize fixed correlation structure as a network</h2><span id='topic+plot_cor_network'></span><span id='topic+plot_cor_network.default'></span><span id='topic+plot_cor_network.simdesign_mvtnorm'></span>

<h3>Description</h3>

<p>Useful to visualize e.g. the associations of the initial multivariate
gaussian distribution used by <code><a href="#topic+simdesign_mvtnorm">simdesign_mvtnorm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cor_network(obj, ...)

## Default S3 method:
plot_cor_network(
  obj,
  categorical_indices = NULL,
  decimals = 2,
  cor_cutoff = 0.1,
  vertex_labels = NULL,
  vertex_label_prefix = "z",
  edge_width_function = function(x) x * 10,
  edge_label_function = function(x) round(x, decimals),
  use_edge_weights = FALSE,
  edge_weight_function = base::identity,
  seed = NULL,
  return_network = FALSE,
  mar = c(0, 0, 0, 0),
  vertex.size = 12,
  margin = 0,
  asp = 0,
  vertex.color = "#ececec",
  vertex.frame.color = "#979797",
  vertex.label.color = "black",
  edge.color = "ramp",
  edge.label.color = "black",
  edge.label.cex = 0.8,
  ...
)

## S3 method for class 'simdesign_mvtnorm'
plot_cor_network(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cor_network_+3A_obj">obj</code></td>
<td>
<p>Correlation matrix or S3 class object which has a class method available (see below).</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="igraph.html#topic+plot.igraph">igraph::plot</a></code>, with a complete list
of arguments and details given in <code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_categorical_indices">categorical_indices</code></td>
<td>
<p>Vector of indices of variables which should be drawn as rectangles
(i.e. represent categorical data).</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_decimals">decimals</code></td>
<td>
<p>Number of decimals, used for default labeling of the network edges.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_cor_cutoff">cor_cutoff</code></td>
<td>
<p>Threshold of absolute correlation below which nodes are not considered
as connected. Useful to control complexity of drawn network.
Set to NULL to disable.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_vertex_labels">vertex_labels</code></td>
<td>
<p>Character vector of length <code>nrow(obj)</code> of labels for vertices. If not NULL,
overrides the <code>vertex_label_prefix</code> argument. If set to NA omits all
or some vertex labels.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_vertex_label_prefix">vertex_label_prefix</code></td>
<td>
<p>String which is added as prefix to node labels.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_edge_width_function">edge_width_function</code></td>
<td>
<p>Function which takes one vector input (absolute correlation values) and
outputs transformation of this vector (must be &gt;= 0). Defines edge widths.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_edge_label_function">edge_label_function</code></td>
<td>
<p>Function which takes on vector input (absolute correlation values) and
outputs labels for these values as character vector. Defines edges labels.
If set to NULL, then no edge labels will be displayed.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_use_edge_weights">use_edge_weights</code></td>
<td>
<p>Logical, if TRUE then the layout will be influenced by the absolute
correlations (i.e. edge weights) such that highly correlated variables will
be put closer together.
If FALSE, then the layout is independent of the correlation structure.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_edge_weight_function">edge_weight_function</code></td>
<td>
<p>Function which takes one vector input (absolute correlation values) and
outputs transformation of this vector (must be &gt;= 0). Defines edge weights.
Only relevant if <code>use_edge_weights</code> is TRUE.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_seed">seed</code></td>
<td>
<p>Set random seed to ensure reproducibility of results. Can be fixed to
obtain same layout but vary edge widths, correlation functions etc. Can
also be used to obtain nicer looking graph layouts.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_return_network">return_network</code></td>
<td>
<p>If TRUE, the <code>igraph</code> network object is returned and can be plotted by
the user using e.g. the interactive <code><a href="igraph.html#topic+tkplot">igraph::tkplot</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_mar">mar</code></td>
<td>
<p><code>mar</code> argument to the <code><a href="graphics.html#topic+par">par</a></code> function to set
margins of the plot (often required when the axes should be drawn).
A numerical vector of the form c(bottom, left, top, right) which gives the
number of lines of margin to be specified on the four sides of the plot.
The default is c(5, 4, 4, 2) + 0.1. Note that this is not the same argument
as the <code>margin</code> argument for the <code>igraph::plot.igraph</code> function.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_vertex.size">vertex.size</code>, <code id="plot_cor_network_+3A_margin">margin</code>, <code id="plot_cor_network_+3A_asp">asp</code>, <code id="plot_cor_network_+3A_vertex.frame.color">vertex.frame.color</code>, <code id="plot_cor_network_+3A_vertex.label.color">vertex.label.color</code>, <code id="plot_cor_network_+3A_edge.label.color">edge.label.color</code>, <code id="plot_cor_network_+3A_edge.label.cex">edge.label.cex</code></td>
<td>
<p>Arguments to <code><a href="igraph.html#topic+plot.igraph">igraph::plot</a></code>, with sensible
defaults for this package's usage.</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Argument passed to <code><a href="igraph.html#topic+plot.igraph">igraph::plot</a></code>. Usually a
character vector with a hex color specification for vertex color.
Alternatively a function that takes as input a data.frame with a column &quot;id&quot;
that gives the column number of the simulated data, and outputs a valid color
specification for the corresponding vertices (i.e. a single character hex
color or a vector of such hex colors of appropriate length).</p>
</td></tr>
<tr><td><code id="plot_cor_network_+3A_edge.color">edge.color</code></td>
<td>
<p>Argument passed to <code><a href="igraph.html#topic+plot.igraph">igraph::plot</a></code>. This
package implements some special functionality: if <code>edge.color = "ramp"</code> then
a colorramp from red (-1) via white (0) to blue (1) is mapped to the
correlations and the edges colored accordingly.
If <code>edge.color = "clipped-ramp"</code> then the ramp is restricted to the
correlation values observed, which may be useful if they are low to increase
visibility.
If <code>edge.color = "red-blue"</code> then all edges with positive correlation values
are colored uniformly red, and all edges with negative correlations are
colored uniformly blue. Alternatively, may be a function that takes as
input the edge correlation values and outputs valid color specifications
(i.e. a single hex color or a vector of hex colors of appropriate length).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an explanation of all parameters not listed here, please refer to
<code><a href="igraph.html#topic+plot.igraph">igraph::plot</a></code>.
</p>


<h3>Value</h3>

<p>If <code>return_network</code> is <code>TRUE</code>, then an <code>igraph</code> network object is returned
that can be plotted by the user using e.g. the interactive
<code><a href="igraph.html#topic+tkplot">igraph::tkplot</a></code> function. Otherwise, the network
object is plotted directly and no output is returned.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>plot_cor_network(default)</code>: Function to be used for correlation matrix.
</p>
</li>
<li> <p><code>plot_cor_network(simdesign_mvtnorm)</code>: Function to be used with <code><a href="#topic+simdesign_mvtnorm">simdesign_mvtnorm</a></code>
S3 class object to visualize initial correlation network of the underlying
multivariate normal distribution.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cor_network.simdesign_mvtnorm">plot_cor_network.simdesign_mvtnorm</a></code>,
<code><a href="#topic+plot_estimated_cor_network">plot_estimated_cor_network</a></code>
</p>

<hr>
<h2 id='plot_estimated_cor_network'>Visualize estimated correlation matrix as a network</h2><span id='topic+plot_estimated_cor_network'></span>

<h3>Description</h3>

<p>Based on approximation via simulation specified by given simulation design.
Convenience wrapper for combining <code><a href="#topic+estimate_final_correlation">estimate_final_correlation</a></code> and
<code><a href="#topic+plot_cor_network">plot_cor_network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_estimated_cor_network(
  obj,
  n_obs = 1e+05,
  cor_type = "pearson",
  seed = NULL,
  show_categorical = TRUE,
  return_network = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_estimated_cor_network_+3A_obj">obj</code></td>
<td>
<p>S3 class object of type <code>simdesign</code> (or inheriting from it).</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_cor_type">cor_type</code></td>
<td>
<p>Can be either a character (<code>pearson</code>, <code>spearman</code>, <code>kendall</code>) which is
passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> or a function, which is
directly used to compute the correlation matrix on the simulated data.
Such a function is expected to take a single input matrix (and possibly other
arguments which can be set via <code>...</code>) and output a single matrix.</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_seed">seed</code></td>
<td>
<p>Random number seed. NULL does not change the current seed.</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_show_categorical">show_categorical</code></td>
<td>
<p>If TRUE, marks categorical variables differently from numeric ones.
Determined by the <code>types_final</code> slot of the <code>obj</code> argument.</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_return_network">return_network</code></td>
<td>
<p>If TRUE, the <code>igraph</code> network object is returned and can be plotted by
the user using e.g. the interactive <code><a href="igraph.html#topic+tkplot">igraph::tkplot</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot_estimated_cor_network_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+plot_cor_network">plot_cor_network</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to estimate the correlation network of a simulation
setup after the initial underlying distribution <code>Z</code> has been transformed to
the final dataset <code>X</code>.
</p>


<h3>Value</h3>

<p>If <code>return_network</code> is <code>TRUE</code>, then an <code>igraph</code> network object is returned
that can be plotted by the user using e.g. the interactive
<code><a href="igraph.html#topic+tkplot">igraph::tkplot</a></code> function. Otherwise, the network
object is plotted directly and no output is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cor_network">plot_cor_network</a></code>,
<code><a href="#topic+estimate_final_correlation">estimate_final_correlation</a></code>
</p>

<hr>
<h2 id='process_truncate_by_iqr'>Truncate columns of datamatrix at datamatrix specific thresholds</h2><span id='topic+process_truncate_by_iqr'></span>

<h3>Description</h3>

<p>Truncation based on the interquartile range to be applied to a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_truncate_by_iqr(x, truncate_multipliers = NA, only_numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_truncate_by_iqr_+3A_x">x</code></td>
<td>
<p>Matrix or Data.frame.</p>
</td></tr>
<tr><td><code id="process_truncate_by_iqr_+3A_truncate_multipliers">truncate_multipliers</code></td>
<td>
<p>Vector of truncation parameters. Either a single value which is
replicated as necessary or of same dimension as <code>ncol(x)</code>.
If any vector entry is NA, the corresponding column will not be
truncated. If named, then the names must correspond to columnnames in <code>x</code>,
and only specified columns will be processed. See details.</p>
</td></tr>
<tr><td><code id="process_truncate_by_iqr_+3A_only_numeric">only_numeric</code></td>
<td>
<p>If TRUE and if <code>x</code> is a data.frame, then only columns of type <code>numeric</code> will
be processed. Otherwise all columns will be processed (e.g. also in the
case that <code>x</code> is a matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Truncation is processed as follows:
</p>

<ol>
<li><p> Compute the 1st and 3rd quartile q1 / q3 of variables in <code>x</code>.
</p>
</li>
<li><p> Multiply these quantities by values in <code>truncate_multipliers</code> to obtain
<em>L</em> and <em>U</em>. If a value is NA, the corresponding variable is not truncated.
</p>
</li>
<li><p> Set any value smaller / larger than <em>L</em> / <em>U</em> to <em>L</em> / <em>U</em>.
</p>
</li></ol>

<p>Truncation multipliers can be specified in three ways (note that whenever
<code>only_numeric</code> is set to TRUE, then only numeric columns are affected):
</p>

<ul>
<li><p> A single numeric - then all columns will be processed in the same way
</p>
</li>
<li><p> A numeric vector without names - it is assumed that the length can be
replicated to the number of columns in <code>x</code>, each column is processed by the
corresponding value in the vector
</p>
</li>
<li><p> A numeric vector with names - length can differ from the columns in
<code>x</code> and only the columns for which the names occur in the vector are
processed
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix or data.frame of same dimensions as input.
</p>

<hr>
<h2 id='process_truncate_by_threshold'>Truncate columns of datamatrix at specified thresholds</h2><span id='topic+process_truncate_by_threshold'></span>

<h3>Description</h3>

<p>Truncation based on fixed thresholds to be applied to a dataset. Allows
to implement truncation by measures derived from the overall data generating
mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_truncate_by_threshold(
  x,
  truncate_lower = NA,
  truncate_upper = NA,
  only_numeric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_truncate_by_threshold_+3A_x">x</code></td>
<td>
<p>Matrix or Data.frame.</p>
</td></tr>
<tr><td><code id="process_truncate_by_threshold_+3A_truncate_lower">truncate_lower</code>, <code id="process_truncate_by_threshold_+3A_truncate_upper">truncate_upper</code></td>
<td>
<p>Vectors of truncation parameters, i.e. lower and upper tresholds for
truncation.
Either a single value which is replicated as necessary or of same dimension
as <code>ncol(x)</code>. If any vector entry is NA, the corresponding column will not be
truncated. Truncation at lower and upper thresholds is treated independently.
If named, then the names must correspond to columnnames in <code>x</code>,
and only specified columns will be processed. See details.</p>
</td></tr>
<tr><td><code id="process_truncate_by_threshold_+3A_only_numeric">only_numeric</code></td>
<td>
<p>If TRUE and if <code>x</code> is a data.frame, then only columns of type <code>numeric</code> will
be processed. Otherwise all columns will be processed (e.g. also in the
case that <code>x</code> is a matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Truncation is defined by setting all values below or above the truncation
threshold to the truncation threshold.
</p>
<p>Truncation parameters can be specified in three ways (note that whenever
<code>only_numeric</code> is set to TRUE, then only numeric columns are affected):
</p>

<ul>
<li><p> A single numeric - then all columns will be processed in the same way
</p>
</li>
<li><p> A numeric vector without names - it is assumed that the length can be
replicated to the number of columns in <code>x</code>, each column is processed by the
corresponding value in the vector
</p>
</li>
<li><p> A numeric vector with names - length can differ from the columns in
<code>x</code> and only the columns for which the names occur in the vector are
processed
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix or data.frame of same dimensions as input.
</p>

<hr>
<h2 id='quantile_functions_from_data'>Helper to estimate quantile functions from data for NORTA</h2><span id='topic+quantile_functions_from_data'></span><span id='topic+quantile_function_from_density'></span><span id='topic+quantile_function_from_quantiles'></span>

<h3>Description</h3>

<p>Helper to estimate quantile functions from data for NORTA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_functions_from_data(
  data,
  method_density = "linear",
  n_density = 200,
  method_quantile = "constant",
  probs_quantile = seq(0, 1, 0.01),
  n_small = 10,
  use_quantile = c(),
  ...
)

quantile_function_from_density(
  x,
  method_density = "linear",
  n_density = 200,
  ...
)

quantile_function_from_quantiles(
  x,
  method_quantile = "constant",
  probs_quantile = seq(0, 1, 0.01)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_functions_from_data_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame for which quantile function should be estimated.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_method_density">method_density</code></td>
<td>
<p>Interpolation method used for density based quantile functions,
passed to <code><a href="stats.html#topic+approxfun">stats::approxfun</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_n_density">n_density</code></td>
<td>
<p>Number of points at which the density is estimated for density bsed
quantile, functions, passed to <code><a href="stats.html#topic+density">stats::density</a></code>.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_method_quantile">method_quantile</code></td>
<td>
<p>Interpolation method used for quantile based quantile functions,
passed to <code><a href="stats.html#topic+approxfun">stats::approxfun</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_probs_quantile">probs_quantile</code></td>
<td>
<p>Specification of quantiles to be estimated from data for quantile based
quantile functions, passed to <code><a href="stats.html#topic+quantile">stats::quantile</a></code>.
See Details.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_n_small">n_small</code></td>
<td>
<p>An integer giving the number of distinct values below which quantile
functions are estimated using <code>quantile_function_from_quantiles()</code> (more
suited for categorical data), rather than <code>quantile_function_from_density()</code>.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_use_quantile">use_quantile</code></td>
<td>
<p>A vector of names indicating columns for which the quantile function
should be estimated using <code>quantile_function_from_quantiles()</code>. Overrides
<code>n_small</code>.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_...">...</code></td>
<td>
<p>Passed to <code>quantile_function_from_density()</code>.</p>
</td></tr>
<tr><td><code id="quantile_functions_from_data_+3A_x">x</code></td>
<td>
<p>Single vector representing variable input to <code>quantile_function_from_density()</code>
or <code>quantile_function_from_quantiles()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NORTA approach requires the specification of the marginals by
quantile functions. This helper estimates those given a dataset automatically
and non-parametrically.
There are two ways implemented to estimate quantile functions from data.
</p>

<ol>
<li><p> Estimate the quantile function by interpolating the observed
quantiles from the data. This is most useful for categorical data, when
the interpolation is using a step-function (default). Implemented in
<code>quantile_function_from_quantiles()</code>.
</p>
</li>
<li><p> Estimate the quantile function via the the empirical cumulative
density function derived from the density of the data. Since the density
is only estimated at specific points, any values in between are interpolated
linearly (default, other options are possible). This is most useful for
continuous data. Implemented in <code>quantile_function_from_density()</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A named list of functions with length <code>ncol(data)</code> giving the quantile
functions of the input data. Each entry is a function returned from
<code><a href="stats.html#topic+approxfun">stats::approxfun</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign_norta">simdesign_norta</a></code>
</p>

<hr>
<h2 id='simdesign'>Design specification for simulating datasets</h2><span id='topic+simdesign'></span>

<h3>Description</h3>

<p>Stores information necessary to simulate and visualize datasets based
on underlying distribution <code>Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdesign(
  generator,
  transform_initial = base::identity,
  n_var_final = -1,
  types_final = NULL,
  names_final = NULL,
  prefix_final = "v",
  process_final = list(),
  name = "Simulation design",
  check_and_infer = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdesign_+3A_generator">generator</code></td>
<td>
<p>Function which generates data from the underlying base distribution. It is
assumed it takes the number of simulated observations <code>n_obs</code> as first
argument, as all random generation functions in the <span class="pkg">stats</span> and
<span class="pkg">extraDistr</span> do. Furthermore, it is expected to return a two-dimensional
array as output (matrix or data.frame). Alternatively an R object derived
from the <code>simdata::simdesign</code> class. See details.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_transform_initial">transform_initial</code></td>
<td>
<p>Function which specifies the transformation of the underlying
dataset <code>Z</code> to final dataset <code>X</code>. See details.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_n_var_final">n_var_final</code></td>
<td>
<p>Integer, number of columns in final datamatrix <code>X</code>. Can be inferred when
<code>check_and_infer</code> is TRUE.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_types_final">types_final</code></td>
<td>
<p>Optional vector of length equal to <code>n_var_final</code> (set by the user or
inferred) and hence number of columns of final dataset <code>X</code>.
Allowed entries are &quot;logical&quot;, &quot;factor&quot; and &quot;numeric&quot;.
Stores the type of the columns of <code>X</code>.
If not specified by, inferred if <code>check_and_infer</code> is set to TRUE.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_names_final">names_final</code></td>
<td>
<p>NULL or character vector with variable names for final dataset <code>X</code>.
Length needs to equal the number of columns of <code>X</code>.
Overrides other naming options. See details.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_prefix_final">prefix_final</code></td>
<td>
<p>NULL or prefix attached to variables in final dataset <code>X</code>. Overriden
by <code>names_final</code> argument. Set to NULL if no prefixes should
be added. See details.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_process_final">process_final</code></td>
<td>
<p>List of lists specifying post-processing functions applied to final
datamatrix <code>X</code> before returning it. See <code><a href="#topic+do_processing">do_processing</a></code>.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_name">name</code></td>
<td>
<p>Character, optional name of the simulation design.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_check_and_infer">check_and_infer</code></td>
<td>
<p>If TRUE, then the simulation design is tested by simulating 5 observations
using <code><a href="#topic+simulate_data">simulate_data</a></code>. If everything works without error,
the variables <code>n_var_final</code> and <code>types_final</code> will be inferred
from the results if not already set correctly by the user.</p>
</td></tr>
<tr><td><code id="simdesign_+3A_...">...</code></td>
<td>
<p>Further arguments are directly stored in the list object to be passed to
<code><a href="#topic+simulate_data">simulate_data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simdesign</code> class should be used in the following workflow:
</p>

<ol>
<li><p> Specify a design template which will be used in subsequent data
generating / visualization steps.
</p>
</li>
<li><p> Sample / visualize datamatrix following template (possibly
multiple times) using <code><a href="#topic+simulate_data">simulate_data</a></code>.
</p>
</li>
<li><p> Use sampled datamatrix for simulation study.
</p>
</li></ol>

<p>For more details on generators and transformations, please see the
documentation of <code><a href="#topic+simulate_data">simulate_data</a></code>.
</p>
<p>For details on post-processing, please see the documentation of
<code><a href="#topic+do_processing">do_processing</a></code>.
</p>


<h3>Value</h3>

<p>List object with class attribute &quot;simdesign&quot; (S3 class) containing
the following entries (if no further information given, entries are
directly saved from user input):
</p>

<dl>
<dt><code>generator</code></dt><dd></dd>
<dt><code>name</code></dt><dd></dd>
<dt><code>transform_initial</code></dt><dd></dd>
<dt><code>n_var_final</code></dt><dd></dd>
<dt><code>types_final</code></dt><dd></dd>
<dt><code>names_final</code></dt><dd></dd>
<dt><code>process_final</code></dt><dd></dd>
<dt><code style="white-space: pre;">&#8288;entries for further information as passed by the user&#8288;</code></dt><dd></dd>
</dl>



<h3>Naming of variables</h3>

<p>If <code>check_and_infer</code> is set to TRUE, the following procedure determines
the names of the variables:
</p>

<ol>
<li><p> use <code>names_final</code> if specified and of correct length
</p>
</li>
<li><p> otherwise, use the names of <code>transform_initial</code> if present and of
correct length
</p>
</li>
<li><p> otherwise, use <code>prefix_final</code> to prefix the variable number if
not NULL
</p>
</li>
<li><p> otherwise, use names from dataset as generated by the <code>generator</code>
function
</p>
</li></ol>



<h3>Simulation Templates</h3>

<p>This class is intended to be used as a template for simulation designs
which are based on specific underlying distributions. All such a template
needs to define is the <code>generator</code> function and its construction and
pass it to this function along with the other arguments. See
<code><a href="#topic+simdesign_mvtnorm">simdesign_mvtnorm</a></code> for an example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign_mvtnorm">simdesign_mvtnorm</a></code>,
<code><a href="#topic+simulate_data">simulate_data</a></code>,
<code><a href="#topic+simulate_data_conditional">simulate_data_conditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generator &lt;- function(n) mvtnorm::rmvnorm(n, mean = 0)
sim_design &lt;- simdesign(generator)
simulate_data(sim_design, 10, seed = 19)

</code></pre>

<hr>
<h2 id='simdesign_discunif'>Uniform disc sampling design specification</h2><span id='topic+simdesign_discunif'></span>

<h3>Description</h3>

<p>Provides 2-dimensional points, spread uniformly over disc, or partial
disc segment (i.e. a circle, or ring, or ring segment). Useful for e.g.
building up clustering exercises.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdesign_discunif(
  r_min = 0,
  r_max = 1,
  angle_min = 0,
  angle_max = 2 * pi,
  name = "Uniform circle simulation design",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdesign_discunif_+3A_r_min">r_min</code></td>
<td>
<p>Minimum radius of points.</p>
</td></tr>
<tr><td><code id="simdesign_discunif_+3A_r_max">r_max</code></td>
<td>
<p>Maximum radius of points.</p>
</td></tr>
<tr><td><code id="simdesign_discunif_+3A_angle_min">angle_min</code></td>
<td>
<p>Minimum angle of points (between 0 and 2pi).</p>
</td></tr>
<tr><td><code id="simdesign_discunif_+3A_angle_max">angle_max</code></td>
<td>
<p>Maximum angle of points (between 0 and 2pi).</p>
</td></tr>
<tr><td><code id="simdesign_discunif_+3A_name">name</code></td>
<td>
<p>Character, optional name of the simulation design.</p>
</td></tr>
<tr><td><code id="simdesign_discunif_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the <code><a href="#topic+simdesign">simdesign</a></code> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of points on a disk depends on the radius - the farther out,
the more area the points need to cover. Thus, simply sampling two uniform
values for radius and angle will not work. See references.
</p>


<h3>Value</h3>

<p>List object with class attribute &quot;simdesign_discunif&quot; (S3 class), inheriting
from &quot;simdesign&quot;. It contains the same entries as a <code><a href="#topic+simdesign">simdesign</a></code>
object but in addition the following entries:
</p>

<dl>
<dt><code>r_min</code></dt><dd></dd>
<dt><code>r_max</code></dt><dd></dd>
<dt><code>angle_min</code></dt><dd></dd>
<dt><code>angle_max</code></dt><dd></dd>
</dl>



<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/DiskPointPicking.html">https://mathworld.wolfram.com/DiskPointPicking.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_sampler &lt;- simdesign_discunif()
plot(simulate_data(disc_sampler, 1000, seed = 19))

ring_segment_sampler &lt;- simdesign_discunif(r_min = 0.5, angle_min = 0.5 * pi)
plot(simulate_data(ring_segment_sampler, 1000, seed = 19))

circle_sampler &lt;- simdesign_discunif(r_min = 1)
plot(simulate_data(circle_sampler, 1000, seed = 19))

</code></pre>

<hr>
<h2 id='simdesign_mvtnorm'>Multivariate normal design specification</h2><span id='topic+simdesign_mvtnorm'></span>

<h3>Description</h3>

<p>Stores information necessary to simulate and visualize datasets based
on underlying distribution multivariate normal distribution <code>Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdesign_mvtnorm(
  relations_initial,
  mean_initial = 0,
  sd_initial = 1,
  is_correlation = TRUE,
  method = "svd",
  name = "Multivariate-normal based simulation design",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdesign_mvtnorm_+3A_relations_initial">relations_initial</code></td>
<td>
<p>Correlation / Covariance matrix of the initial multivariate
Normal distribution <code>Z</code>.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_mean_initial">mean_initial</code></td>
<td>
<p>Vector of mean values of the initial multivariate Normal
distribution <code>Z</code>. Dimension needs to correspond to dimension
of <code>relations</code>.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_sd_initial">sd_initial</code></td>
<td>
<p>Vector of standard deviations of the initial multivariate
Normal distribution Z. Dimension needs to correspond to dimension
of <code>relations</code>. Overriden by suqare root of diagonal elements of
<code>relations</code> if <code>is_correlation</code> is FALSE.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_is_correlation">is_correlation</code></td>
<td>
<p>If TRUE, then <code>relations</code> specifies a correlation matrix (default,
this type of specification is usually more natural than specifying
a covariance matrix). Otherwise, <code>relations</code> specifies a
covariance matrix whose square root diagonal elements override
<code>sd_initial</code>.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_method">method</code></td>
<td>
<p><code>method</code> argument of <code><a href="mvtnorm.html#topic+Mvnorm">mvtnorm::rmvnorm</a></code>.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_name">name</code></td>
<td>
<p>Character, optional name of the simulation design.</p>
</td></tr>
<tr><td><code id="simdesign_mvtnorm_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the <code><a href="#topic+simdesign">simdesign</a></code> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This S3 class implements a simulation design based on an underlying
multivariate normal distribution by creating a <code>generator</code> function
based on <code><a href="mvtnorm.html#topic+Mvnorm">mvtnorm::rmvnorm</a></code>.
</p>


<h3>Value</h3>

<p>List object with class attribute &quot;simdesign_mvtnorm&quot; (S3 class), inheriting
from &quot;simdesign&quot;. It contains the same entries as a <code><a href="#topic+simdesign">simdesign</a></code>
object but in addition the following entries:
</p>

<dl>
<dt><code>mean_initial</code></dt><dd></dd>
<dt><code>sd_initial</code></dt><dd></dd>
<dt><code>cor_initial</code></dt><dd><p>Initial correlation matrix of multivariate normal
distribution</p>
</dd>
</dl>



<h3>Data Generation</h3>

<p>Data will be generated by <code><a href="#topic+simulate_data">simulate_data</a></code> using the
following procedure:
</p>

<ol>
<li><p> The underlying data matrix <code>Z</code> is sampled from a
multivariate Normal distribution (number of dimensions specified by
dimensions of <code>relations</code>).
</p>
</li>
<li> <p><code>Z</code> is then transformed into the final dataset <code>X</code> by applying
the <code>transform_initial</code> function to <code>Z</code>.
</p>
</li>
<li> <p><code>X</code> is post-processed if specified.
</p>
</li></ol>



<h3>Note</h3>

<p>Note that <code>relations</code> specifies the correlation / covariance
of the underlying Normal data <code>Z</code> and thus does not directly translate into
correlations between the variables of the final datamatrix <code>X</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign">simdesign</a></code>,
<code><a href="#topic+simulate_data">simulate_data</a></code>,
<code><a href="#topic+simulate_data_conditional">simulate_data_conditional</a></code>,
<code><a href="#topic+plot_cor_network.simdesign_mvtnorm">plot_cor_network.simdesign_mvtnorm</a></code>
</p>

<hr>
<h2 id='simdesign_norta'>NORTA-based design specification</h2><span id='topic+simdesign_norta'></span>

<h3>Description</h3>

<p>Stores information necessary to simulate datasets based on the NORTA
procedure (Cario and Nelson 1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdesign_norta(
  cor_target_final = NULL,
  cor_initial = NULL,
  dist = list(),
  tol_initial = 0.001,
  n_obs_initial = 10000,
  seed_initial = 1,
  conv_norm_type = "O",
  method = "svd",
  name = "NORTA based simulation design",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdesign_norta_+3A_cor_target_final">cor_target_final</code></td>
<td>
<p>Target correlation matrix for simulated datasets. At least one of
<code>cor_target_final</code> or <code>cor_initial</code> must be specified.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_cor_initial">cor_initial</code></td>
<td>
<p>Correlation matrix for underlying multivariate standard normal distribution
on which the final data is based on.  At least one of <code>cor_target_final</code> or
<code>cor_initial</code> must be specified. If NULL, then <code>cor_initial</code> will be
numerically optimized by simulation for the NORTA procedure using
<code>cor_target_final</code>.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_dist">dist</code></td>
<td>
<p>List of functions of marginal distributions for simulated variables.
Must have the same length as the specified correlation matrix
(<code>cor_target_final</code> and / or <code>cor_inital</code>), and the order of the entries
must correspond to the variables in the correlation matrix. See details for
the specification of the marginal distributions.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_tol_initial">tol_initial</code></td>
<td>
<p>If <code>cor_initial</code> is numerically optimized, specifies the tolerance for the
difference to the target correlation <code>cor_target_final</code>. Parameter passed to
<code><a href="#topic+optimize_cor_for_pair">optimize_cor_for_pair</a></code>.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_n_obs_initial">n_obs_initial</code></td>
<td>
<p>If <code>cor_initial</code> is numerically optimized, specifies the number of draws in
simulation during optimization used to estimate correlations.
Parameter passed to <code><a href="#topic+optimize_cor_for_pair">optimize_cor_for_pair</a></code>.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_seed_initial">seed_initial</code></td>
<td>
<p>Seed used for draws of the initial distribution used during optimization
to estimate correlations.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_conv_norm_type">conv_norm_type</code></td>
<td>
<p>If <code>cor_initial</code> is numerically optimized and found not to be a proper
correlation matrix (i.e. not positive-definite), specifies the metric used to
find the nearest positive-definite correlation matrix.
Parameter passed to <code><a href="Matrix.html#topic+nearPD">Matrix::nearPD</a></code>
(conv.norm.type), see there for details.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_method">method</code></td>
<td>
<p><code>method</code> argument of <code><a href="mvtnorm.html#topic+Mvnorm">mvtnorm::rmvnorm</a></code>.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_name">name</code></td>
<td>
<p>Character, optional name of the simulation design.</p>
</td></tr>
<tr><td><code id="simdesign_norta_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the <code><a href="#topic+simdesign">simdesign</a></code> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This S3 class implements a simulation design based on the
NORmal-To-Anything (NORTA) procedure by Cario and Nelson (1997). See the
corresponding NORTA vignette for usage examples how to approximate real
datasets.
</p>


<h3>Value</h3>

<p>List object with class attribute &quot;simdesign_norta&quot; (S3 class), inheriting
from &quot;simdesign&quot;. It contains the same entries as a <code><a href="#topic+simdesign">simdesign</a></code>
object but in addition the following entries:
</p>

<dl>
<dt><code>cor_target_final</code></dt><dd></dd>
<dt><code>cor_initial</code></dt><dd><p>Initial correlation matrix of multivariate normal
distribution</p>
</dd>
<dt><code>dist</code></dt><dd></dd>
<dt><code>tol_initial</code></dt><dd></dd>
<dt><code>n_obs_initial</code></dt><dd></dd>
<dt><code>conv_norm_type</code></dt><dd></dd>
<dt><code>method</code></dt><dd></dd>
</dl>



<h3>Data Generation</h3>

<p>Data will be generated using the following procedure:
</p>

<ol>
<li><p> An underlying data matrix <code>Z</code> is sampled from a
multivariate standard Normal distribution with correlation structure given by
<code>cor_initial</code>.
</p>
</li>
<li> <p><code>Z</code> is then transformed into a dataset <code>X</code> by applying
the functions given in <code>dist</code> to the columns of <code>Z</code>. The resulting dataset
<code>X</code> will then have the desired marginal distributions, and approximate the
target correlation <code>cor_target_final</code>, if specified.
</p>
</li>
<li> <p><code>X</code> is further transformed by the transformation <code>transform_initial</code>
(note that this may affect the correlation of the final dataset and is not
respected by the optimization procedure), and post-processed if specified.
</p>
</li></ol>



<h3>Marginal distributions</h3>

<p>A list of functions <code>dist</code> is used to define the marginal distributions of
the variables. Each entry must be a quantile function, i.e. a function
that maps <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> to the domain of a probability distribution. Each entry
must take a single input vector, and return a single numeric vector.
Examples for acceptable entries include all standard quantile functions
implemented in R (e.g. <code>qnorm</code>, <code>qbinom</code>, ...), user defined functions
wrapping these (e.g. <code style="white-space: pre;">&#8288;function(x) = qnorm(x, mean = 10, sd = 4)&#8288;</code>), or
empirical quantile functions. The helper function
<a href="#topic+quantile_functions_from_data">quantile_functions_from_data</a> can be used to automatically
estimate empirical quantile functions from a given data to reproduce it using
the NORTA approach.See the example in the NORTA vignette of this package for
workflow details.
</p>


<h3>Target correlations</h3>

<p>Not every valid correlation matrix (i.e. symmetric, positive-definite matrix
with elements in <code style="white-space: pre;">&#8288;[-1, 1]&#8288;</code> and unity diagonal) for a number of variables
is feasible for given desired marginal distributions (see e.g.
Ghosh and Henderson 2003). Therefore, if <code>cor_target_final</code> is specified
as target correlation, this class optimises <code>cor_initial</code> in such a
way, that the final simulated dataset has a correlation which approximates
<code>cor_target_final</code>. However, the actual correlation in the end may differ
if <code>cor_target_final</code> is infeasible for the given specification, or the
NORTA procedure cannot exactly reproduce the target correlation. In general,
however, approximations should be acceptable if target correlations and
marginal structures are derived from real datasets.
See e.g. Ghosh and Henderson 2003 for the motivation why this works.
</p>


<h3>References</h3>

<p>Cario, M. C. and Nelson, B. L. (1997) <em>Modeling and
generating random vectors with arbitrary marginal distributions and
correlation matrix</em>. Technical Report, Department of Industrial Engineering
and Management Sciences, Northwestern University, Evanston, Illinois.
</p>
<p>Ghosh, S. and Henderson, S. G. (2003) <em>Behavior of the NORTA method
for correlated random vector generation as the dimension increases</em>. ACM
Transactions on Modeling and Computer Simulation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign">simdesign</a></code>,
<code><a href="#topic+simulate_data">simulate_data</a></code>,
<code><a href="#topic+simulate_data_conditional">simulate_data_conditional</a></code>,
<code><a href="#topic+quantile_functions_from_data">quantile_functions_from_data</a></code>
</p>

<hr>
<h2 id='simulate_data'>Simulate design matrix</h2><span id='topic+simulate_data'></span><span id='topic+simulate_data.default'></span><span id='topic+simulate_data.simdesign'></span>

<h3>Description</h3>

<p>Generate simulated dataset based on transformation of
an underlying base distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(generator, ...)

## Default S3 method:
simulate_data(
  generator = function(n) matrix(rnorm(n)),
  n_obs = 1,
  transform_initial = base::identity,
  names_final = NULL,
  prefix_final = NULL,
  process_final = list(),
  seed = NULL,
  ...
)

## S3 method for class 'simdesign'
simulate_data(
  generator,
  n_obs = 1,
  seed = NULL,
  apply_transformation = TRUE,
  apply_processing = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_data_+3A_generator">generator</code></td>
<td>
<p>Function which generates data from the underlying base distribution. It is
assumed it takes the number of simulated observations <code>n_obs</code> as first
argument, as all random generation functions in the <span class="pkg">stats</span> and
<span class="pkg">extraDistr</span> do. Furthermore, it is expected to return a two-dimensional
array as output (matrix or data.frame). Alternatively an R object derived
from the <code>simdata::simdesign</code> class. See details.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>generator</code> function.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of simulated observations.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_transform_initial">transform_initial</code></td>
<td>
<p>Function which specifies the transformation of the underlying
dataset <code>Z</code> to final dataset <code>X</code>. See details.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_names_final">names_final</code></td>
<td>
<p>NULL or character vector with variable names for final dataset <code>X</code>.
Length needs to equal the number of columns of <code>X</code>.
Overrides other naming options. See details.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_prefix_final">prefix_final</code></td>
<td>
<p>NULL or prefix attached to variables in final dataset <code>X</code>. Overriden
by <code>names_final</code> argument. Set to NULL if no prefixes should
be added. See details.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_process_final">process_final</code></td>
<td>
<p>List of lists specifying post-processing functions applied to final
datamatrix <code>X</code> before returning it. See <code><a href="#topic+do_processing">do_processing</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_seed">seed</code></td>
<td>
<p>Set random seed to ensure reproducibility of results.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_apply_transformation">apply_transformation</code></td>
<td>
<p>This argument can be set to FALSE to override the information stored in the
passed <code>simdesign</code> object and not transform and process data.
Thus, the raw data from the design generator is returned. This can be useful
for debugging purposes.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_apply_processing">apply_processing</code></td>
<td>
<p>This argument can be set to FALSE to override the information stored in the
passed <code>simdesign</code> object and not transform and process data after
the initial data is transformed. This can be useful for debugging purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data is generated using the following procedure:
</p>

<ol>
<li><p> An underlying dataset <code>Z</code> is sampled from some distribution. This is
done by a call to the <code>generator</code> function.
</p>
</li>
<li> <p><code>Z</code> is then transformed into the final dataset <code>X</code> by applying the
<code>transform</code> function to <code>Z</code>.
</p>
</li>
<li> <p><code>X</code> is post-processed if specified (e.g. truncation to avoid
outliers).
</p>
</li></ol>



<h3>Value</h3>

<p>Data.frame or matrix with <code>n_obs</code> rows for simulated dataset <code>X</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>simulate_data(default)</code>: Function to be used if no <code><a href="#topic+simdesign">simdesign</a></code>
S3 class is used.
</p>
</li>
<li> <p><code>simulate_data(simdesign)</code>: Function to be used with <code><a href="#topic+simdesign">simdesign</a></code>
S3 class.
</p>
</li></ul>


<h3>Generators</h3>

<p>The <code>generator</code> function which is either passed directly, or via a
<code>simdata::simdesign</code> object, is assumed to provide the same interface
as the random generation functions in the R <span class="pkg">stats</span> and <span class="pkg">extraDistr</span>
packages. Specifically, that means it takes the number of observations as
first argument. All further arguments can be set via passing them as
named argument to this function. It is expected to return a two-dimensional
array (matrix or data.frame) for which the number of columns can be
determined. Otherwise the <code>check_and_infer</code> step will fail.
</p>


<h3>Transformations</h3>

<p>Transformations should be applicable to the output of the <code>generator</code>
function (i.e. take a data.frame or matrix as input) and output another
data.frame or matrix. A convenience function <code><a href="#topic+function_list">function_list</a></code> is
provided by this package to specify transformations as a list of functions,
which take the whole datamatrix <code>Z</code> as single argument and can be used to
apply specific transformations to the columns of that matrix. See the
documentation for <code><a href="#topic+function_list">function_list</a></code> for details.
</p>


<h3>Post-processing</h3>

<p>Post-processing the datamatrix is based on <code><a href="#topic+do_processing">do_processing</a></code>.
</p>


<h3>Naming of variables</h3>

<p>Variables are named by <code>names_final</code> if not NULL and of correct length.
Otherwise, if <code>prefix_final</code> is not NULL, it is used as prefix for variable
numbers. Otherwise, variables names remain as returned by the <code>generator</code>
function.
</p>


<h3>Note</h3>

<p>This function is best used in conjunction with the <code><a href="#topic+simdesign">simdesign</a></code>
S3 class or any template based upon it, which facilitates further data
visualization and conveniently stores information as a template for
simulation tasks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign">simdesign</a></code>,
<code><a href="#topic+simdesign_mvtnorm">simdesign_mvtnorm</a></code>,
<code><a href="#topic+simulate_data_conditional">simulate_data_conditional</a></code>,
<code><a href="#topic+do_processing">do_processing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generator &lt;- function(n) mvtnorm::rmvnorm(n, mean = 0)
simulate_data(generator, 10, seed = 24)

</code></pre>

<hr>
<h2 id='simulate_data_conditional'>Simulate data which satisfies certain conditions</h2><span id='topic+simulate_data_conditional'></span>

<h3>Description</h3>

<p>Generate simulated dataset based on transformation of
an underlying base distribution while checking that certain
conditions are met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data_conditional(
  generator,
  n_obs = 1,
  reject = function(x) TRUE,
  reject_max_iter = 10,
  on_reject = "ignore",
  return_tries = FALSE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_data_conditional_+3A_generator">generator</code></td>
<td>
<p>Function which generates data from the underlying base distribution. It is
assumend it takes the number of simulated observations <code>n_obs</code> as first
argument, as all random generation functions in the <span class="pkg">stats</span> and
<span class="pkg">extraDistr</span> do. Furthermore, it is expected to return a two-dimensional
array as output (matrix or data.frame). See details.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of simulated observations.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_reject">reject</code></td>
<td>
<p>Function which takes a matrix or data.frame <code>X</code> as single input and outputs
TRUE or FALSE. Specifies when a simulated final datamatrix <code>X</code> should
be rejected. Functions must output TRUE if condition IS NOT met / FALSE if
condition IS met and matrix can be accepted. Intended to be used with
<code><a href="#topic+function_list">function_list</a></code>. See details.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_reject_max_iter">reject_max_iter</code></td>
<td>
<p>Integer &gt; 0. In case of rejection, how many times should a new datamatrix be
simulated until the conditions in <code>reject</code> are met?</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_on_reject">on_reject</code></td>
<td>
<p>If &quot;stop&quot;, an error is returned if after <code>reject_max_iter</code> times no
suitable datamatrix X could be found. If &quot;current&quot;, the current datamatrix
is returned, regardless of the conditions in <code>reject</code>.
Otherwise, NULL is returned. In each case a warning is reported.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_return_tries">return_tries</code></td>
<td>
<p>If TRUE, then the function also outputs the number of tries necessary to
find a dataset fulfilling the condition. Useful to record to assess
the possible bias of the simulated datasets. See Value.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_seed">seed</code></td>
<td>
<p>Set random seed to ensure reproducibility of results. See Note below.</p>
</td></tr>
<tr><td><code id="simulate_data_conditional_+3A_...">...</code></td>
<td>
<p>All further parameters are passed to <code><a href="#topic+simulate_data">simulate_data</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on generating, transforming and post-processing datasets, see
<code><a href="#topic+simulate_data">simulate_data</a></code>. This function simulates data conditional
on certain requirements that must be met by the final datamatrix <code>X</code>.
This checking is conducted on the output of <code>simulate_data</code> (i.e.
also includes possible post-processing steps).
</p>


<h3>Value</h3>

<p>Data.frame or matrix with <code>n_obs</code> rows for simulated dataset <code>X</code> if all
conditions are met within the iteration limit. Otherwise NULL.
</p>
<p>If <code>return_tries</code> is TRUE, then the output is a list with the first entry
being the data.frame or matrix as described above, and the second entry
(<code>n_tries</code>) giving a numeric with the number of tries necessary to
find the returned dataset.
</p>


<h3>Rejecting Datasets</h3>

<p>Examples for restrictions include
variance restrictions (e.g. no constant columns which could happen due
to extreme transformations of the initial gaussian distribution <code>Z</code>),
ensuring a sufficient number of observations in a given class (e.g. certain
binary variables should have at least x\
multicollinearity (e.g. <code>X</code> must have full column rank). If <code>reject</code>
evaluates to FALSE, the current datamatrix <code>X</code> is rejected.
In case of rejection, new datasets can be simulated until the conditions
are met or a given maximum iteration limit is hit (<code>reject_max_iter</code>),
after which the latest datamatrix is returned or an error is reported.
</p>


<h3>Rejection Function</h3>

<p>The <code>reject</code> function should take a single input (a data.frame or matrix)
and output TRUE if the dataset is to be rejected or FALSE if it is to be
accepted.
This package provides the <code><a href="#topic+function_list">function_list</a></code> convenience function
which allows to easily create a rejection function which assesses several
conditions on the input dataset by simply passing individual test functions
to <code>function_list</code>. Such test function templates are found in
<code><a href="#topic+is_collinear">is_collinear</a></code> and <code><a href="#topic+contains_constant">contains_constant</a></code>.
See the example below.
</p>


<h3>Note</h3>

<p>Seeding the random number generator is tricky in this case. The seed can not
be passed to <code>simulate_data</code> but is set before calling it, otherwise
the random number generation is the same for each of the tries.
This means that the seed used to call this function might not be the seed
corresponding to the returned dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdesign">simdesign</a></code>,
<code><a href="#topic+simulate_data">simulate_data</a></code>,
<code><a href="#topic+function_list">function_list</a></code>,
<code><a href="#topic+is_collinear">is_collinear</a></code>,
<code><a href="#topic+contains_constant">contains_constant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsgn &lt;- simdesign_mvtnorm(diag(5))
simulate_data_conditional(dsgn, 10,
    reject = function_list(is_collinear, contains_constant), 
    seed = 18)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
