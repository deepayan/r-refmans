<!DOCTYPE html><html><head><title>Help for package synchrony</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {synchrony}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#synchrony-package'>
<p>Methods for Computing Spatial, Temporal, and Spatiotemporal Statistics</p></a></li>
<li><a href='#bird.traits'>
<p>bird trait dataset</p></a></li>
<li><a href='#community.sync'>
<p>Compute community-wide synchrony and its significance via Monte Carlo randomizations</p></a></li>
<li><a href='#coord2dist'>
<p>coord2dist</p></a></li>
<li><a href='#correlated.matrix'>
<p>correlated.matrix</p></a></li>
<li><a href='#find.minmax'>
<p>Find min/max of a time series</p></a></li>
<li><a href='#kendall.w'>
<p>Kendall's W</p></a></li>
<li><a href='#latlon2dist'>
<p>latlon2dist</p></a></li>
<li><a href='#meancorr'>
<p>Compute mean column-wise correlation and determine its significance via Monte Carlo randomizations</p></a></li>
<li><a href='#peaks'>
<p>Find the proportion of local minima/maxima common to both time series and compute</p>
its significance via Monte Carlo randomizations</a></li>
<li><a href='#phase.partnered'>
<p>Phase partnered time series</p></a></li>
<li><a href='#phase.sync'>
<p>Phase synchrony of quasi-periodic time series</p></a></li>
<li><a href='#pisco.data'>
<p>PISCO multi-year and spatially-explicit mussel and environmental dataset</p></a></li>
<li><a href='#plot.synchrony'>
<p>Plot <code>synchrony</code> objects</p></a></li>
<li><a href='#plot.vario'>
<p>Plot <code>vario</code> objects</p></a></li>
<li><a href='#plot.variofit'>
<p>Plot <code>variofit</code> objects</p></a></li>
<li><a href='#surrogate.ts'>
<p>Create surrogate time series via Markov process</p></a></li>
<li><a href='#vario'>
<p>vario</p></a></li>
<li><a href='#vario.fit'>
<p>vario.fit</p></a></li>
<li><a href='#vario.func'>
<p>vario.func</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Computing Spatial, Temporal, and Spatiotemporal
Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarik C. Gouhier</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tarik C. Gouhier &lt;tarik.gouhier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for computing spatial, temporal, and spatiotemporal
    statistics as described in Gouhier and Guichard (2014) 
    &lt;<a href="https://doi.org/10.1111%2F2041-210X.12188">doi:10.1111/2041-210X.12188</a>&gt;. These methods include 
    empirical univariate, bivariate and multivariate
    variograms; fitting variogram models; phase locking and synchrony analysis;
    generating autocorrelated and cross-correlated matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/tgouhier/synchrony">http://github.com/tgouhier/synchrony</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-05 17:55:18 UTC; tarik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-05 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='synchrony-package'>
Methods for Computing Spatial, Temporal, and Spatiotemporal Statistics
</h2><span id='topic+synchrony-package'></span><span id='topic+synchrony'></span>

<h3>Description</h3>

<p>Methods for computing spatial, temporal, and spatiotemporal
statistics as described in Gouhier and Guichard (2014) 
&lt;doi:10.1111/2041-210X.12188&gt;. These methods include 
empirical univariate, bivariate and multivariate
variograms; fitting variogram models; phase locking and synchrony analysis;
generating autocorrelated and cross-correlated matrices.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> synchrony</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/tgouhier/synchrony</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>
<p>Maintainer: Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Bjornstad, O. N., and W. Falck. 2001. Nonparametric spatial covariance functions: 
Estimation and testing. <em>Environmental and Ecological Statistics</em> 8:53-70.
</p>
<p>Bjornstad, O. N., R. A. Ims, and X. Lambin. 1999. Spatial population dynamics: 
analyzing patterns and processes of population synchrony. <em>Trends in Ecology &amp; Evolution</em> 14:427-432.
</p>
<p>Buonaccorsi, J. P., J. S. Elkinton, S. R. Evans, and A. M. Liebhold. 2001. 
Measuring and testing for spatial synchrony. <em>Ecology</em> 82:1668-1679.
</p>
<p>Cazelles, B., and L. Stone. 2003. Detection of imperfect population synchrony in 
an uncertain world. <em>Journal of Animal Ecology</em> 72:953-968.
</p>
<p>Fortin, M. J., and M. R. T. Dale. 2005. Spatial Analysis: A Guide for Ecologists. Cambridge University Press.
</p>
<p>Gouhier, T. C., and F. Guichard. 2007. Local disturbance cycles and the maintenance 
of spatial heterogeneity across scales in marine metapopulations. <em>Ecology</em> 88:647-657.
</p>
<p>Gouhier, T. C., F. Guichard, and A. Gonzalez. 2010. Synchrony and stability of 
food webs in metacommunities. <em>The American Naturalist</em> 175:E16-E34.
</p>
<p>Gouhier, T. C., F. Guichard, and B. A. Menge. 2010. Ecological processes can 
synchronize marine population dynamics over continental scales. 
<em>Proceedings of the National Academy of Sciences</em> 107:8281-8286.
</p>
<p>Loreau, M., and C. de Mazancourt. 2008. Species synchrony and its drivers: 
Neutral and nonneutral community dynamics in fluctuating environments. 
<em>The American Naturalist</em> 172:E48-E66.
</p>
<p>Purves, D. W., and R. Law. 2002. Fine-scale spatial structure in a grassland community: 
quantifying the plant's eye view. 
<em>Journal of Ecology</em> 90:121-129.
</p>
<p>Vasseur, D. A. 2007. Environmental colour intensifies the Moran effect when 
population dynamics are spatially heterogeneous. <em>Oikos</em> 116:1726-1736.
</p>
<p>Zar, J. H. 1999. Biostatistical Analysis, Fourth edition. Prentice-Hall, Inc., 
Upper Saddle River, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute phase synchrony
t1=runif(100)
t2=runif(100)
sync=phase.sync(t1, t2)
# Distribution of phase difference
hist(sync$deltaphase$mod_phase_diff_2pi)

# Compute concordant peaks
p=peaks(t1, t2, nrands=100)
# Find proportion of time steps where both time series peak together
p$peaks
# Plot (null) distribution of proportion of time steps where both time
# series peak together
hist(p$rand)
# p-value of observed value
p$pval

# Compute Kendall's W 
data(bird.traits)
(w=kendall.w(bird.traits))

# Community matrix for 20 species undergoing random fluctuations 
comm.rand=matrix(runif(100), nrow=5, ncol=20)
community.sync(comm.rand, nrands=10)
# Community matrix for 20 species undergoing synchronized fluctuations 
comm.corr=matrix(rep(comm.rand[,1], 20), nrow=5, ncol=20)
community.sync(comm.corr, nrands=10)
</code></pre>

<hr>
<h2 id='bird.traits'>
bird trait dataset
</h2><span id='topic+bird.traits'></span>

<h3>Description</h3>

<p>Contains the wing length, tail length, and bill length from 12 birds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bird.traits)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations (birds) on the following 3 variables.
</p>

<dl>
<dt><code>wing.length</code></dt><dd><p>a numeric vector containing wing length in cm</p>
</dd>
<dt><code>tail.length</code></dt><dd><p>a numeric vector containing tail length in cm</p>
</dd>
<dt><code>bill.length</code></dt><dd><p>a numeric vector containing bill length in cm</p>
</dd>
</dl>



<h3>Details</h3>

<p>Dataset from Zar (1999; page 444)
</p>


<h3>Source</h3>

<p>Zar, J. H. 1999. Biostatistical Analysis, Fourth edition. Prentice-Hall, Inc., Upper Saddle River, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.traits)
(w=kendall.w(bird.traits))
</code></pre>

<hr>
<h2 id='community.sync'>
Compute community-wide synchrony and its significance via Monte Carlo randomizations
</h2><span id='topic+community.sync'></span>

<h3>Description</h3>

<p>Compute community-wide synchrony and its the significance via Monte Carlo randomizations. 
If all species fluctuate in perfect unison, the community-wide synchrony will be 1. 
If species undergo uncorrelated fluctuations, the community-wide synchrony will be 1/S.
The Monte Carlo randomizations are performed by shuffling the columns of the community
matrix independently. This function also returns the mean correlation between the columns
of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.sync (data, nrands = 0, method = c("pearson", "kendall", "spearman"), 
                alternative = c("greater", "less"), type = 1, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.sync_+3A_data">data</code></td>
<td>

<p>community matrix in wide format where each row contains the abundance at each time step
and each column corresponds to a different species.
</p>
</td></tr>
<tr><td><code id="community.sync_+3A_nrands">nrands</code></td>
<td>

<p>number of randomizations to perform (default is 0)
</p>
</td></tr>
<tr><td><code id="community.sync_+3A_method">method</code></td>
<td>
<p>Method to compute mean correlation between columns? 
Options include <code>pearson</code>, <code>kendall</code>, and <code>spearman</code>. Default is <code>pearson</code></p>
</td></tr>
<tr><td><code id="community.sync_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis. Options are
<code>less</code> and <code>greater</code>. Default is <code>greater</code></p>
</td></tr>
<tr><td><code id="community.sync_+3A_type">type</code></td>
<td>

<p>Randomization method. The <code>type=1</code> method randomly shuffles each column of the data
matrix, thus destroying both the autocorrelation structure of each column and the cross-correlation
between columns. The <code>type=2</code> method shifts each column of the data matrix
by a random amount, thus preserving the autocorrelation structure of each column but destroying
the cross-correlation between columns (Purves and Law 2002). Default is <code>type=1</code>
</p>
</td></tr>
<tr><td><code id="community.sync_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="community.sync_+3A_...">...</code></td>
<td>

<p>Other parameters to <code><a href="stats.html#topic+cor">cor</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loreau and de Mazancourt (2008) show that community-wide synchrony <code class="reqn">\varphi</code> can be quantified
by computing the temporal variance <code class="reqn">\sigma_{x_T}^2</code> of the community time series
<code class="reqn">x_T(t)=\sum{x_i(t)}</code> and the sum of the temporal standard deviation of the time series
across all species <code class="reqn">\left(\sum{\sigma_{x_i}}\right)^2</code> such that:
<code class="reqn">\varphi=\frac{\sigma_{x_T}^2}{\left(\sum{\sigma_{x_i}}\right)^2}</code>
</p>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>the observed community synchrony</p>
</td></tr>
<tr><td><code>meancorr</code></td>
<td>
<p>the mean correlation between the columns of the matrix</p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p>the community synchrony value the randomizations. 
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value of observed community synchrony. 
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Alternative hypothesis. This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Loreau, M., and C. de Mazancourt. 2008. Species synchrony and its drivers: 
Neutral and nonneutral community dynamics in fluctuating environments. 
<em>The American Naturalist</em> 172:E48-E66.
</p>
<p>Purves, D. W., and R. Law. 2002. Fine-scale spatial structure in a grassland community: quantifying the plant's eye view. 
<em>Journal of Ecology</em> 90:121-129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Community matrix for 20 species undergoing random fluctuations 
comm.rand=matrix(runif(100), nrow=5, ncol=20)
community.sync(comm.rand, nrands=20)$pval
# Community matrix for 20 species undergoing synchronized fluctuations 
comm.corr=matrix(rep(comm.rand[,1], 20), nrow=5, ncol=20)
community.sync(comm.corr, nrands=20)$pval
# On "real" data
data(bird.traits)
community.sync(bird.traits, nrands=20)$pval
</code></pre>

<hr>
<h2 id='coord2dist'>
coord2dist
</h2><span id='topic+coord2dist'></span>

<h3>Description</h3>

<p>Calculate distance between all pairs of sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord2dist (coords, is.latlon = TRUE, lower.tri = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord2dist_+3A_coords">coords</code></td>
<td>

<p><code>n</code> x 4 matrix of coordinates consisting of lat or y, lon or x pairs for each each site
</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_is.latlon">is.latlon</code></td>
<td>

<p>are coordinates latitudes/longitudes? Default is <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_lower.tri">lower.tri</code></td>
<td>

<p>Return lower triangular part of the distance matrix? Default is <code>TRUE</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the distance between all pairs of sites
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords=rbind(c(32, -125), c(43, -130))
# Compute great circle distance
coord2dist(coords)
</code></pre>

<hr>
<h2 id='correlated.matrix'>
correlated.matrix
</h2><span id='topic+correlated.matrix'></span>

<h3>Description</h3>

<p>Create an <code>ntimes</code> x <code>nspecies</code> matrix with correlation rho,
standard deviation sigma, and mean mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlated.matrix (rho = 0, sigma = 1, mu = 0, ntimes = 200, nspecies = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlated.matrix_+3A_rho">rho</code></td>
<td>

<p>Correlation between the columns of the matrix. This can be a single number describing
the correlation between all columns, or the upper triangular portion of a correlation
matrix describing the correlation between all pairs of columns. Default is <code>0</code>
</p>
</td></tr>
<tr><td><code id="correlated.matrix_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of the columns. Default is 1
</p>
</td></tr>
<tr><td><code id="correlated.matrix_+3A_mu">mu</code></td>
<td>

<p>Mean of the columns. Default is 0
</p>
</td></tr>
<tr><td><code id="correlated.matrix_+3A_ntimes">ntimes</code></td>
<td>

<p>Number of rows in the matrix. Default is 200
</p>
</td></tr>
<tr><td><code id="correlated.matrix_+3A_nspecies">nspecies</code></td>
<td>

<p>Number of columns in the matrix. Default is 10
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the Cholesky factorization method described by Legendre (2000).
</p>


<h3>Value</h3>

<p>Returns a named list containing the following:
</p>
<table>
<tr><td><code>rho</code></td>
<td>
<p>Correlation(s) between the columns</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Standard deviation of the columns</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Mean of the columns</p>
</td></tr>
<tr><td><code>community</code></td>
<td>
<p><code>ntimes</code> x <code>nspecies</code> matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Gouhier, T. C., F. Guichard, and A. Gonzalez. 2010. Synchrony and stability of 
food webs in metacommunities. <em>The American Naturalist</em> 175:E16-E34.
</p>
<p>Legendre, P. 2000. Comparison of permutation methods for the partial correlation 
and partial mantel tests. <em>Journal of Statistical Computation and Simulation</em> 67:37-73.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat=correlated.matrix(rho=0.85, sigma=30, mu=10, nspecies=10)
# Check sd of each column
apply(mat$community, 2, sd)
# Check mean of each column
apply(mat$community, 2, mean)
# Check correlation of matrix
community.sync(mat$community)
</code></pre>

<hr>
<h2 id='find.minmax'>
Find min/max of a time series
</h2><span id='topic+find.minmax'></span>

<h3>Description</h3>

<p>Find local minima and maxima of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.minmax (timeseries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.minmax_+3A_timeseries">timeseries</code></td>
<td>

<p>time series in matrix format (<code>n</code> rows x 2 columns). The first column should contain the time 
steps and the second column should contain the values. If <code>timeseries</code> is a column vector 
instead of a matrix, then it will be automatically converted to a matrix with 
column 1 corresponding to a time index ranging from 1 to the length of <code>timeseries</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>mins</code></td>
<td>
<p><code>n</code> x 3 matrix containing the index, time steps, and the local min values</p>
</td></tr>
<tr><td><code>maxs</code></td>
<td>
<p><code>n</code> x 3 matrix containing the index, time steps, and the local max values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1=runif(100)
min.max=find.minmax(t1)
min.max$maxs
plot (t1, t="l")
points (min.max$mins, col="blue", bg="blue", pch=19)
points (min.max$maxs, col="red", bg="red", pch=19)
</code></pre>

<hr>
<h2 id='kendall.w'>
Kendall's W
</h2><span id='topic+kendall.w'></span><span id='topic+concordance'></span>

<h3>Description</h3>

<p>Compute Kendall's coefficient of concordance (W)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendall.w (data, nrands = 0, type = 1, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kendall.w_+3A_data">data</code></td>
<td>

<p>matrix in wide format where each row represents a different sample and each column 
represents a different variable.
</p>
</td></tr>
<tr><td><code id="kendall.w_+3A_nrands">nrands</code></td>
<td>

<p>Number of randomizations to perform to determine significance. Default is 0.
</p>
</td></tr>
<tr><td><code id="kendall.w_+3A_type">type</code></td>
<td>

<p>Randomization method. The <code>type=1</code> method randomly shuffles each column of the data
matrix, thus destroying both the autocorrelation structure of each column and the cross-correlation
between columns. The <code>type=2</code> method shifts each column of the data matrix
by a random amount, thus preserving the autocorrelation structure of each column but destroying
the cross-correlation between columns (Purves and Law 2002). Default is <code>type=1</code>
</p>
</td></tr>
<tr><td><code id="kendall.w_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kendall's W is a non-parametric statistic that ranges from 0 to 1 and measures 
the level of agreement between multiple variables. When the number of observations <code class="reqn">n&gt;10</code>, 
its significance can be determined by using a <code class="reqn">\chi^2</code> distribution with <code class="reqn">df=n-1</code>.
Legendre (2005) shows that the <code class="reqn">\chi^2</code> test is always too conservative (low power)
compared to the randomization test. Hence, both tests have been made available in
this function. The Monte Carlo randomizations are performed by shuffling the 
columns of the community matrix independently (Legendre 2005).
</p>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>w.uncorrected</code></td>
<td>
<p>Kendall's W uncorrected for tied ranks</p>
</td></tr>
<tr><td><code>w.corrected</code></td>
<td>
<p>Kendall's W corrected for tied ranks</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value of Kendall's W</p>
</td></tr>
<tr><td><code>spearman.corr</code></td>
<td>
<p>Spearman's ranked correlation</p>
</td></tr>
<tr><td><code>pval.rand</code></td>
<td>
<p>p-value of Kendall's W based on randomization test. 
This variable is only returned if <code>nrands &gt; 0</code></p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p>randomizations. This variable is only returned if <code>nrands &gt; 0</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Buonaccorsi, J. P., J. S. Elkinton, S. R. Evans, and A. M. Liebhold. 2001. 
Measuring and testing for spatial synchrony. <em>Ecology</em> 82:1668-1679.
</p>
<p>Gouhier, T. C., and F. Guichard. 2007. Local disturbance cycles and the maintenance 
of spatial heterogeneity across scales in marine metapopulations. <em>Ecology</em> 88:647-657.
</p>
<p>Gouhier, T. C., F. Guichard, and A. Gonzalez. 2010. Synchrony and stability of 
food webs in metacommunities. <em>The American Naturalist</em> 175:E16-E34.
</p>
<p>Legendre, P. 2005. Species associations: the Kendall coefficient of concordance 
revisited. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 10:226-245.
</p>
<p>Purves, D. W., and R. Law. 2002. Fine-scale spatial structure in a grassland community: quantifying the plant's eye view. 
<em>Journal of Ecology</em> 90:121-129.
</p>
<p>Zar, J. H. 1999. Biostatistical Analysis, Fourth edition. Prentice-Hall, Inc., 
Upper Saddle River, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.traits)
(w=kendall.w(bird.traits))
</code></pre>

<hr>
<h2 id='latlon2dist'>
latlon2dist
</h2><span id='topic+latlon2dist'></span>

<h3>Description</h3>

<p>Calculate distance between a pair of coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlon2dist (coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlon2dist_+3A_coords">coords</code></td>
<td>

<p>4-element vector of coordinates with format: <code>(lat1, lon1, lat2, lon2)</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the great circle distance distance between the pair of coordinates
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coord2dist">coord2dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords=c(32, -125, 43, -130)
# Compute great circle distance
latlon2dist(coords)
</code></pre>

<hr>
<h2 id='meancorr'>
Compute mean column-wise correlation and determine its significance via Monte Carlo randomizations
</h2><span id='topic+meancorr'></span>

<h3>Description</h3>

<p>Compute mean column-wise correlation and determine its significance via Monte Carlo randomizations. 
The Monte Carlo randomizations are performed by shuffling the columns of the community
matrix independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meancorr (data, nrands = 0, alternative = c("two.tailed", "greater", "less"), 
                            method = c("pearson", "kendall", "spearman"), 
                            type = 1, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meancorr_+3A_data">data</code></td>
<td>

<p>community matrix in wide format where each row contains the abundance at each time step
and each column corresponds to a different species.
</p>
</td></tr>
<tr><td><code id="meancorr_+3A_nrands">nrands</code></td>
<td>

<p>number of randomizations to perform (default is 0)
</p>
</td></tr>
<tr><td><code id="meancorr_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis. Options include <code>greater</code> and 
<code>less</code> for the one-tailed test and <code>two.tailed</code>. Default is <code>two.tailed</code>.</p>
</td></tr>
<tr><td><code id="meancorr_+3A_method">method</code></td>
<td>
<p>Method to compute correlation? Options include <code>pearson</code>, <code>kendall</code>, 
and <code>spearman</code>. Default is <code>pearson</code></p>
</td></tr>
<tr><td><code id="meancorr_+3A_type">type</code></td>
<td>

<p>Randomization method. The <code>type=1</code> method randomly shuffles each column of the data
matrix, thus destroying both the autocorrelation structure of each column and the cross-correlation
between columns. The <code>type=2</code> method shifts each column of the data matrix
by a random amount, thus preserving the autocorrelation structure of each column but destroying
the cross-correlation between columns (Purves and Law 2002). Default is <code>type=1</code>
</p>
</td></tr>
<tr><td><code id="meancorr_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="meancorr_+3A_...">...</code></td>
<td>

<p>Other parameters to <code><a href="stats.html#topic+cor">cor</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>the observed mean correlation</p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p>the mean correlation for each randomization. 
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value of observed mean correlation. 
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Alternative hypothesis.
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used to compute the mean correlation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Purves, D. W., and R. Law. 2002. Fine-scale spatial structure in a grassland community: quantifying the plant's eye view. 
<em>Journal of Ecology</em> 90:121-129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Community matrix for 20 species undergoing random fluctuations 
comm.rand=matrix(runif(100), nrow=5, ncol=20)
meancorr(comm.rand, nrands=20)$pval
# Community matrix for 20 species undergoing synchronized fluctuations 
comm.corr=matrix(rep(comm.rand[,1], 20), nrow=5, ncol=20)
meancorr(comm.corr, nrands=20)$pval
# On "real" data
data(bird.traits)
meancorr(bird.traits, nrands=20)$pval
</code></pre>

<hr>
<h2 id='peaks'>
Find the proportion of local minima/maxima common to both time series and compute 
its significance via Monte Carlo randomizations
</h2><span id='topic+peaks'></span>

<h3>Description</h3>

<p>Find the proportion of local minima/maxima common to both time series and compute 
its significance via Monte Carlo randomizations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks (t1, t2, nrands = 0, type = 1, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_t1">t1</code></td>
<td>

<p>time series 1 in matrix format (<code>n</code> rows x 2 columns). The first column 
should contain the time steps and the second column should contain the values. 
If <code>t1</code> is a column vector instead of a matrix, then it will be automatically 
converted to a matrix with column 1 corresponding to a time index ranging 
from 1 to the length of <code>t1</code>
</p>
</td></tr>
<tr><td><code id="peaks_+3A_t2">t2</code></td>
<td>

<p>time series 2 in matrix format (<code>n</code> rows x 2 columns). The first column should contain the time 
steps and the second column should contain the values. If <code>t2</code> is a column
vector instead of a matrix, then it will be automatically converted to matrix 
with column 1 corresponding to a time index ranging from 1 to the length of <code>t2</code>.
</p>
</td></tr>
<tr><td><code id="peaks_+3A_nrands">nrands</code></td>
<td>

<p>number of randomizations. Default is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="peaks_+3A_type">type</code></td>
<td>

<p>Randomization method. The <code>type=1</code> method randomly shuffles each time series, 
thus destroying both the autocorrelation structure of each time series and their 
cross-correlation. The <code>type=2</code> method shifts each time series by a random amount, 
thus preserving the autocorrelation structure but destroying the cross-correlation 
between the time series (Purves and Law 2002). Default is <code>type=1</code>
</p>
</td></tr>
<tr><td><code id="peaks_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>p-value computed by randomly shuffling both time series <code>nrands</code> times</p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p>proportion of local minima/maxima common to both time series for each randomization</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>proportion of local minima/maxima common to both time series in the observed dataset</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>indices of local minima/maxima common to both time series in the observed dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Buonaccorsi, J. P., J. S. Elkinton, S. R. Evans, and A. M. Liebhold. 2001. 
Measuring and testing for spatial synchrony. <em>Ecology</em> 82:1668-1679.
</p>
<p>Purves, D. W., and R. Law. 2002. Fine-scale spatial structure in a grassland community: quantifying the plant's eye view. 
<em>Journal of Ecology</em> 90:121-129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1=runif(100)
t2=runif(100)
(p=peaks(t1, t2))

</code></pre>

<hr>
<h2 id='phase.partnered'>
Phase partnered time series
</h2><span id='topic+phase.partnered'></span>

<h3>Description</h3>

<p>Create two time series with specific autocorrelation <code class="reqn">\gamma</code>, cross-correlation
<code class="reqn">\rho</code>, mean <code>ts.mean</code>, and standard deviation <code>ts.sd</code> using the 
phase partnered algorithm described by Vasseur (2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.partnered (n = 2000, rho = 1, gamma = 1, sigma = 0.1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase.partnered_+3A_n">n</code></td>
<td>

<p>number of time steps in time series. Default is <code>2000</code>.
</p>
</td></tr>
<tr><td><code id="phase.partnered_+3A_rho">rho</code></td>
<td>

<p>cross-correlation between the two time series (<code class="reqn">-1\le \rho \le 1</code>).
Default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="phase.partnered_+3A_gamma">gamma</code></td>
<td>

<p>autocorrelation of each time series. Gamma (<code class="reqn">\gamma</code>) describes the relationship between 
frequency <code class="reqn">f</code> and power <code class="reqn">P</code>: <code class="reqn">P(f)=1/f^\gamma</code>. If <code class="reqn">-2\le \gamma \le 0</code>: blue noise and <code class="reqn">0\le \gamma \le 2</code>: red noise. Default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="phase.partnered_+3A_sigma">sigma</code></td>
<td>

<p>standard deviation of both time series. Default is <code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="phase.partnered_+3A_mu">mu</code></td>
<td>

<p>mean of both time series. Default is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list containing the following:
</p>
<table>
<tr><td><code>rho</code></td>
<td>
<p>Cross-correlation of the time series</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Autocorrelation of the time series</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Standard deviation of the time series</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Mean of the time series</p>
</td></tr>
<tr><td><code>timeseries</code></td>
<td>
<p><code>n</code> x 2 matrix containing the time series</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Gouhier, T. C., F. Guichard, and A. Gonzalez. 2010. Synchrony and stability of 
food webs in metacommunities. <em>The American Naturalist</em> 175:E16-E34.
</p>
<p>Vasseur, D. A. 2007. Environmental colour intensifies the Moran effect when 
population dynamics are spatially heterogeneous. <em>Oikos</em> 116:1726-1736.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Positively cross-correlated white noise
pos.corr=phase.partnered(n = 100, rho = 0.7, gamma = 0)
# Negatively cross-correlated white noise
neg.corr=phase.partnered(n = 100, rho = -1, gamma = 0)
par(mfrow=c(2,1))
matplot (pos.corr$timeseries, t="l", lty=1)
matplot (neg.corr$timeseries, t="l", lty=1)
</code></pre>

<hr>
<h2 id='phase.sync'>
Phase synchrony of quasi-periodic time series
</h2><span id='topic+phase.sync'></span>

<h3>Description</h3>

<p>Compute the phase synchrony between two quasi-periodic time series by quantifying
their phase difference at each time step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.sync (t1, t2,  nrands = 0, mod = 1, method = c("markov", "fft"), 
            nbreaks = 10, mins = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase.sync_+3A_t1">t1</code></td>
<td>

<p>time series 1 in matrix format (<code>n</code> rows x 2 columns). 
The first column should contain the time 
steps and the second column should contain the values. If <code>t1</code> is a column
vector instead of a matrix, then it will be automatically converted to a 
matrix with column 1 corresponding to a time index ranging from 1 to the length of <code>t1</code>.
</p>
</td></tr>
<tr><td><code id="phase.sync_+3A_t2">t2</code></td>
<td>

<p>time series 2 in matrix format (<code>n</code> rows x 2 columns). 
The first column should contain the time 
steps and the second column should contain the values. If <code>t2</code> is a column
vector instead of a matrix, then it will be automatically converted to
matrix with column 1 corresponding to a time index ranging from 1 to the length of <code>t2</code>.
</p>
</td></tr>
<tr><td><code id="phase.sync_+3A_nrands">nrands</code></td>
<td>

<p>number of randomizations to perform (default is 0)  
</p>
</td></tr>
<tr><td><code id="phase.sync_+3A_mod">mod</code></td>
<td>
<p>flag to indicate whether to compute phase difference modulus <code class="reqn">2\pi</code> 
between 0 and <code class="reqn">2\pi</code> (<code>mod=1</code>) or phase difference modulus 
<code class="reqn">2\pi</code> between <code class="reqn">-\pi</code> and <code class="reqn">\pi</code> (<code>mod=2</code>). Default is <code>mod=1</code>.
</p>
</td></tr> 
<tr><td><code id="phase.sync_+3A_method">method</code></td>
<td>
<p>method to generate surrogate time series for Monte Carlo simulations.
This can be set to <code>markov</code> to use the Markov process described in 
Cazelles and Stone (2004) or <code>fft</code> to use the FFT approach described in
Theiler et al. (1992). Default is <code>method=markov</code>.
</p>
</td></tr> 
<tr><td><code id="phase.sync_+3A_nbreaks">nbreaks</code></td>
<td>
<p>number of bins to use to group the values in the time series.
Default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="phase.sync_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="phase.sync_+3A_mins">mins</code></td>
<td>

<p>use local minima instead of local maxima to compute and the interpolate the phase. Default is
<code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two time series are phase-locked if the relationship between their phases
remains constant over time. This function computes the phase of successive local maxima
or minima for each time series and then uses linear interpolation to find the phase at
time steps that fall between local maxima/minima. A histogram can be used to determine if the
distribution of the phase difference at each time step is uniform (indicating no phase locking) 
or has a clear peak (indicating phase locking).
</p>


<h3>Value</h3>

<p>Returns a list containing <code>Q.obs</code>, <code>pval</code>, <code>rands</code>,
<code>phases1</code>, <code>phases2</code>, <code>deltaphase</code>, and <code>icdf</code>:
</p>
<table>
<tr><td><code>Q.obs</code></td>
<td>
<p> Phase synchrony ranging from 0 (no phase synchrony) to 1 (full phase synchrony)</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value of observed phase synchrony based on randomization test</p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p>Monte Carlo randomizations</p>
</td></tr>
<tr><td><code>phases1</code></td>
<td>
<p><code>n</code> x 3 matrix containing the timestep, value, and phase of the 
first time series </p>
</td></tr>
<tr><td><code>phases2</code></td>
<td>
<p><code>n</code> x 3 matrix containing the timestep, value, and phase of the 
second time series </p>
</td></tr>
<tr><td><code>deltaphase</code></td>
<td>
<p><code>n</code> x 4 matrix containing the timestep, raw phase difference, 
phase difference modulus <code class="reqn">2\pi</code> between 0 and <code class="reqn">2\pi</code>, phase difference 
modulus <code class="reqn">2\pi</code> between <code class="reqn">-\pi</code> and <code class="reqn">\pi</code></p>
</td></tr>
<tr><td><code>icdf</code></td>
<td>
<p>Inverse cumulative distribution of Q values obtained from Monte Carlo randomizatons</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Cazelles, B., and L. Stone. 2003. Detection of imperfect population synchrony 
in an uncertain world. <em>Journal of Animal Ecology</em> 72:953&ndash;968.
</p>
<p>Theiler, J., S. Eubank, A. Longtin, B. Galdrikian, and J. Doyne Farmer. 1992. 
Testing for nonlinearity in time series: the method of surrogate data. 
Physica D: Nonlinear Phenomena 58:77&ndash;94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1=runif(100)
t2=runif(100)
# Compute and interpolate phases using successive local minima
sync.mins=phase.sync(t1, t2, mins=TRUE)
# Compute and interpolate phases using successive local maxima
sync.maxs=phase.sync(t1, t2)
# Plot distribution of phase difference
hist(sync.mins$deltaphase$mod_phase_diff_2pi)
</code></pre>

<hr>
<h2 id='pisco.data'>
PISCO multi-year and spatially-explicit mussel and environmental dataset
</h2><span id='topic+pisco.data'></span>

<h3>Description</h3>

<p>Contains the mean annual chl-a concentration, sea surface temperature, 
upwelling currents, and mussel abundance at 48 intertidal sites
along the West Coast of the United States from 2000-2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pisco.data)</code></pre>


<h3>Format</h3>

<p>A data frame with 192 observations on the following 7 variables.
</p>

<dl>
<dt><code>latitude</code></dt><dd><p>latitude (degrees North)</p>
</dd>
<dt><code>longitude</code></dt><dd><p>longitude (degrees West)</p>
</dd>
<dt><code>chl</code></dt><dd><p>mean annual remote sensed chlorophyll-a concentration</p>
</dd>
<dt><code>sst</code></dt><dd><p>mean annual remote sensed sea surface temperature</p>
</dd>
<dt><code>upwelling</code></dt><dd><p>mean annual remote sensed upwelling currents</p>
</dd>
<dt><code>mussel_abund</code></dt><dd><p>mean annual mussel cover (<em>Mytilus californianus</em>)</p>
</dd>
<dt><code>year</code></dt><dd><p>sampling year</p>
</dd>
</dl>



<h3>References</h3>

<p>Gouhier, T. C., F. Guichard, and B. A. Menge. 2010. Ecological processes can synchronize marine population dynamics over continental scales. <em>Proceedings of the National Academy of Sciences</em> 107:8281-8286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pisco.data)
</code></pre>

<hr>
<h2 id='plot.synchrony'>
Plot <code>synchrony</code> objects
</h2><span id='topic+plot.synchrony'></span>

<h3>Description</h3>

<p>Plot <code>synchrony</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'synchrony'
 plot(x, main = "", xlab = "Values from randomizations", 
                            ylab = "Frequency", line.col = "red", lty = 2, 
                            lwd = 1, col = "grey", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.synchrony_+3A_x">x</code></td>
<td>

<p><code>synchrony</code> object
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_main">main</code></td>
<td>

<p>main title of the figure
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_xlab">xlab</code></td>
<td>

<p>xlabel of the figure. Default is &quot;Values from randomizations&quot;
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_ylab">ylab</code></td>
<td>

<p>ylabel of the figure. Default is &quot;Frequency&quot;
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_line.col">line.col</code></td>
<td>

<p>color of the vertical line indicating the value observed in the data. Default is &quot;red&quot;
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_lty">lty</code></td>
<td>

<p>line type. Default is 2 or dashed
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_lwd">lwd</code></td>
<td>

<p>line width. Default is 1
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_col">col</code></td>
<td>

<p>color of the bars. Default is grey  
</p>
</td></tr>
<tr><td><code id="plot.synchrony_+3A_...">...</code></td>
<td>

<p>other graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comm.rand=matrix(runif(100), nrow=5, ncol=20)
comm.rand.sync=community.sync(comm.rand, nrands=20)
plot(comm.rand.sync)
</code></pre>

<hr>
<h2 id='plot.vario'>
Plot <code>vario</code> objects
</h2><span id='topic+plot.vario'></span>

<h3>Description</h3>

<p>Plot <code>vario</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vario'
 plot(x, xlab = "Lag distance", ylab = NULL, ylim = NULL,
                      xtype = c("mean.bin.dist", "bins"), rug = FALSE, ci = FALSE,
                      pch = 21, col.sig="black", col.nonsig="black", bg.sig="black", 
                      bg.nonsig = "white", alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vario_+3A_x">x</code></td>
<td>

<p><code>vario</code> object generated by <code>vario</code> function.
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_xlab">xlab</code></td>
<td>

<p>xlabel of the figure. Default is &quot;Lag distance&quot;
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_ylab">ylab</code></td>
<td>

<p>ylabel of the figure. Default is <code>NULL</code> and will automatically generate the right label
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_ylim">ylim</code></td>
<td>

<p>y-range. Default is <code>NULL</code> and will automatically generate the best range based on the metric
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_xtype">xtype</code></td>
<td>

<p>Use either the discrete bin classes (<code>bins</code>) or 
the mean distance of the points within each bin (<code>mean.bin.dist</code>) on the x-axis. 
Default is <code>mean.bin.dist</code>
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_rug">rug</code></td>
<td>

<p>Plot rug indicating the density of data points? Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_ci">ci</code></td>
<td>

<p>Plot two-tailed (1-<code class="reqn">\alpha</code>)% confidence intervals? Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_pch">pch</code></td>
<td>

<p>Type of points to use when plotting the variogram. Default is 21
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_col.sig">col.sig</code></td>
<td>

<p>Border color of points for significant values. Default is black
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_col.nonsig">col.nonsig</code></td>
<td>

<p>Border color of points for non-significant values. Default is black
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_bg.sig">bg.sig</code></td>
<td>

<p>Background color of points for significant values. Default is black
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_bg.nonsig">bg.nonsig</code></td>
<td>

<p>Background color of points for non-significant values. Default is black
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_alpha">alpha</code></td>
<td>

<p>Significance level. Default is 0.05
</p>
</td></tr>
<tr><td><code id="plot.vario_+3A_...">...</code></td>
<td>

<p>other graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pisco.data)
d=subset(pisco.data, subset=year==2000, select=c("latitude", "longitude", "sst"))
semiv=vario(data=d)
moran=vario(data=d, type="moran", nrand=100)
geary=vario(data=d, type="geary", nrand=100)

par(mfrow=c(3,1))
plot(semiv)
plot(moran, bg.sig="blue")
plot(geary, bg.sig="red")
</code></pre>

<hr>
<h2 id='plot.variofit'>
Plot <code>variofit</code> objects
</h2><span id='topic+plot.variofit'></span>

<h3>Description</h3>

<p>Plot <code>variofit</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variofit'
 plot(x, xlab = "Lag distance", ylab = "Variogram",
                         col.pts = "black", col.line = "red", 
                         pch = 21, ...)                      
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.variofit_+3A_x">x</code></td>
<td>

<p><code>variofit</code> object generated by <code>vario.fit</code> function
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_xlab">xlab</code></td>
<td>

<p>xlabel of the figure. Default is &quot;Lag distance&quot;
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_ylab">ylab</code></td>
<td>

<p>ylabel of the figure. Default is &quot;Variogram&quot;
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_col.pts">col.pts</code></td>
<td>

<p>Border color of the points. Default is black
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_col.line">col.line</code></td>
<td>

<p>Color of the fitted variogram. Default is red
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_pch">pch</code></td>
<td>

<p>Type of points to use when plotting the variogram. Default is 21
</p>
</td></tr>
<tr><td><code id="plot.variofit_+3A_...">...</code></td>
<td>

<p>other graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Environmental variogram
data(pisco.data)
d=subset(pisco.data, subset=year==2000, select=c("latitude", "longitude", "upwelling"))
semiv=vario(data=d)
mod.sph=vario.fit(semiv$vario, semiv$mean.bin.dist)
plot(mod.sph)
</code></pre>

<hr>
<h2 id='surrogate.ts'>
Create surrogate time series via Markov process
</h2><span id='topic+surrogate.ts'></span>

<h3>Description</h3>

<p>Create surrogate time series with the same short-term time correlation and overall
temporal pattern as the original time series using the Markov process described by
Cazelles and Stones (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.ts (ts, distr.ts = NULL, trans.ts = NULL, nbreaks = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.ts_+3A_ts">ts</code></td>
<td>

<p>time series in matrix format (<code>n</code> rows x 2 columns). The first column should contain the time 
steps and the second column should contain the values. If <code>ts</code> is a column vector 
instead of a matrix, then it will be automatically converted to a matrix with 
column 1 corresponding to a time index ranging from 1 to the length of <code>ts</code></p>
</td></tr>
<tr><td><code id="surrogate.ts_+3A_distr.ts">distr.ts</code></td>
<td>

<p>binning of time series values. This parameter must be specified 
if <code>trans.ts</code> is not set to <code>NULL</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="surrogate.ts_+3A_trans.ts">trans.ts</code></td>
<td>

<p>transition matrix from bin <code class="reqn">i</code> to bin <code class="reqn">j</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="surrogate.ts_+3A_nbreaks">nbreaks</code></td>
<td>

<p>number of bins to use to group the time series values. Default is <code>10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the time series <code class="reqn">x_n</code> are grouped into <code>nbreak</code> equally-sized bins. 
The transition matrix <code class="reqn">M_{ij}</code> describing the probability of <code class="reqn">x_{n+1}</code> belonging to 
bin <code class="reqn">j</code> based on <code class="reqn">x_n</code> belonging to bin <code class="reqn">i</code> is defined using the relative
frequencies of the data such that: 
<code class="reqn">M_{ij}=Pr(x_{n+1} \in b_{j} | x_{n} \in b_{i})</code>. The surrogate time series is then constructed
by randomly selecting a starting value and randomly selecting the next value from the proper bin
based on the transition matrix. This process is repeated until the surrogate time series has 
the same length as the original time series.
</p>


<h3>Value</h3>

<p>Returns a named list containing:
</p>
<table>
<tr><td><code>surr.ts</code></td>
<td>
<p>surrogate time series in matrix format</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>transition matrix <code class="reqn">M_{ij}</code></p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>binning of time series values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Cazelles, B., and L. Stone. 2003. Detection of imperfect population synchrony 
in an uncertain world. <em>Journal of Animal Ecology</em> 72:953-968.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phase.sync">phase.sync</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1=runif(100)
surr.t1=surrogate.ts(ts=t1)
plot(t1, t="l")
lines(surr.t1$surr.ts, col="red")
</code></pre>

<hr>
<h2 id='vario'>
vario
</h2><span id='topic+vario'></span>

<h3>Description</h3>

<p>Compute the empirical variogram and determine its significance via Monte Carlo randomizations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vario (n.bins = 20, size.bins = NULL, extent = 0.5, data, data2 = NULL, 
                  is.latlon = TRUE, is.centered = FALSE, nrands = 0, 
                  type = c("semivar", "cov", "pearson", 
                  "spearman", "kendall", "moran", "geary"),
                  alternative = c("one.tailed", "two.tailed"),
                  mult.test.corr = c("none", "holm", "hochberg", "bonferroni"),
                  regional = c("all", "extent"),
                  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vario_+3A_n.bins">n.bins</code></td>
<td>
<p>Number of bins or lag distances. This argument is only used when 
<code>size.bins=NULL</code>
</p>
</td></tr> 
<tr><td><code id="vario_+3A_size.bins">size.bins</code></td>
<td>
<p>Size of bins in units of distance (e.g., km). When specified, this argument overrides
<code>n.bins</code>. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="vario_+3A_extent">extent</code></td>
<td>
<p>Proportion of the spatial extent of the data over which to compute 
the variogram. Default is 0.5 to limit potentially spurious results due to the 
limited number of data points at large lag distances.
</p>
</td></tr>
<tr><td><code id="vario_+3A_data">data</code></td>
<td>
<p><code>n</code> x <code>m</code> matrix containing y-coordinates (or latitude), 
x-coordinates (or longitude), and values. The values can either be
a single column of observations at each site for univariate variograms
or a matrix of observations at each site for multivariate variograms 
(e.g., to compute spatial synchrony).
</p>
</td></tr>
<tr><td><code id="vario_+3A_data2">data2</code></td>
<td>
<p><code>n</code> x <code>m</code> matrix containing y-coordinates (or latitude), 
x-coordinates (or longitude), and values for second variable. The values 
can either be a single column of observations at each site for univariate 
variograms or a matrix of observations at each site for multivariate 
variograms (e.g., to compute spatial synchrony).
</p>
</td></tr>
<tr><td><code id="vario_+3A_is.latlon">is.latlon</code></td>
<td>
<p>Are coordinates latitudes/longitudes? Default is <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="vario_+3A_is.centered">is.centered</code></td>
<td>
<p>Should the variogram be centered by subtracting the regional mean
from each value? If so, the zero-line represents the regional mean. Default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="vario_+3A_nrands">nrands</code></td>
<td>
<p>Number of randomizations to determine statistical significance 
of variogram. Default is 0.
</p>
</td></tr> 
<tr><td><code id="vario_+3A_type">type</code></td>
<td>
<p>Type of variogram to compute. Default is <code>semivar</code> for semivariance. 
Other options include <code>cov</code> for covariance, <code>pearson</code> for Pearson
correlation, <code>spearman</code> for Spearman correlation, <code>kendall</code> for Kendall correlation,
<code>moran</code> for Moran's I, and <code>geary</code> for Geary's C
</p>
</td></tr>
<tr><td><code id="vario_+3A_alternative">alternative</code></td>
<td>
<p>Conduct a one-tailed or a two-tailed test? Note that the statistical test
is to determine whether the local value within each lag distance is different from the regional
mean. If the variogram is centered, the null hypothesis is that the local values are equal to zero. 
If the variogram is not centered, the null hypothesis is that the local values are equal to the 
regional mean. Default is <code>one.tailed</code></p>
</td></tr>
<tr><td><code id="vario_+3A_mult.test.corr">mult.test.corr</code></td>
<td>
<p>Correct for multiple tests? Default is <code>"none"</code>. Other options include
<code>holm</code>, <code>hochberg</code> and <code>bonferroni</code>
</p>
</td></tr>
<tr><td><code id="vario_+3A_regional">regional</code></td>
<td>

<p>Should the regional average be computed for the entire dataset (<code>all</code>)
or just the extent specified (<code>extent</code>). Default is the entire dataset (<code>all</code>)
</p>
</td></tr>
<tr><td><code id="vario_+3A_quiet">quiet</code></td>
<td>

<p>Suppress progress bar when set to <code>TRUE</code>. Default is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to compute univariate correlograms using Moran's I, 
Geary's C, and the covariance function or variograms using the semivariance function. 
Multivariate (Mantel) correlograms can also be computed using the covariance function, 
Pearson's, Spearman's or Kendall's correlation coefficients. Cross-correlograms/variograms 
between <code>data1</code> and <code>data2</code> can be computed with the covariance function,
Pearson's, Spearman's or Kendall's correlation coefficients for multivariate
variograms and Moran's I, Geary's C, the covariance function, or semivariance 
for univariate variograms.
</p>


<h3>Value</h3>

<p>Returns a named list containing the following variables:
</p>
<table>
<tr><td><code>bins</code></td>
<td>
<p>Center of each lag/bin</p>
</td></tr>
<tr><td><code>mean.bin.dist</code></td>
<td>
<p>Mean distance of each lag/bin</p>
</td></tr>
<tr><td><code>vario</code></td>
<td>
<p>Variogram values in each lag/bin</p>
</td></tr>
<tr><td><code>npoints</code></td>
<td>
<p>Number of pairs of points in each lag/bin</p>
</td></tr>
<tr><td><code>metric</code></td>
<td>
<p>Type of variogram computed</p>
</td></tr>
<tr><td><code>is.centered</code></td>
<td>
<p>Is the variogram centered?</p>
</td></tr>
<tr><td><code>regional.mean</code></td>
<td>
<p>Regional mean value</p>
</td></tr>
<tr><td><code>pvals</code></td>
<td>
<p>p-value for each lag/bin. 
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>rands</code></td>
<td>
<p><code>nrands</code> x <code>n.bins</code> matrix of randomizations.
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>One-tailed or two-tailed test?
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>mult.test.corr</code></td>
<td>
<p>Correct for multiple tests?
This variable is only returned if <code>nrands &gt; 0</code>.</p>
</td></tr>
<tr><td><code>is.multivar</code></td>
<td>
<p>Was the analysis performed on multivariate data?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>References</h3>

<p>Bjornstad, O. N., and W. Falck. 2001. Nonparametric spatial covariance functions: 
Estimation and testing. <em>Environmental and Ecological Statistics</em> 8:53-70.
</p>
<p>Bjornstad, O. N., R. A. Ims, and X. Lambin. 1999. Spatial population dynamics: 
analyzing patterns and processes of population synchrony. <em>Trends in Ecology &amp; Evolution</em> 14:427-432.
</p>
<p>Fortin, M. J., and M. R. T. Dale. 2005. Spatial Analysis: A Guide for Ecologists. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vario.func">vario.func</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pisco.data)
d=subset(pisco.data, subset=year==2000, select=c("latitude", "longitude", "sst"))
semiv=vario(data=d)
moran=vario(data=d, type="moran", nrands=100)
par(mfrow=c(2,1), mar=c(4.2, 4, 1, 1))
plot(semiv$mean.bin.dist, semiv$vario, xlab="Lag distance (km)", ylab="Semivariance")
plot(moran$mean.bin.dist, moran$vario, xlab="Lag distance (km)", ylab="Moran's I", t="l")
points(moran$mean.bin.dist[moran$pvals &gt;= 0.05], moran$vario[moran$pvals &gt;= 0.05], 
       bg="white", pch=21)
points(moran$mean.bin.dist[moran$pvals &lt; 0.05], moran$vario[moran$pvals &lt; 0.05], 
       bg="black", pch=21)
abline(h=0, lty=2)

# Compute spatial synchrony
d.upw=subset(pisco.data, select=c("latitude", "longitude", "year", "upwelling"))
d.cov=subset(pisco.data, select=c("latitude", "longitude", "year", "mussel_abund"))
# Reshape the data
d.upw.wide=reshape(data=d.upw, idvar=c("latitude", "longitude"), timevar=c("year"), 
                   direction="wide")
d.cov.wide=reshape(data=d.cov, idvar=c("latitude", "longitude"), timevar=c("year"), 
                   direction="wide")
# Generate variograms
v.upw=vario(n.bins=12, data=d.upw.wide, type="pearson", extent=1, nrands=999)
v.cov=vario(n.bins=12, data=d.cov.wide, type="pearson", extent=1, nrands=999)
## Fit variograms
v.cov.per=vario.fit(v.cov$vario, v.cov$mean.bin.dist, type="period", 
                    start.vals=list(a=1, b=3, c=0))
v.upw.lin=vario.fit(v.upw$vario, v.upw$mean.bin.dist, type="linear")

par(mfrow=c(2,1))
plot(v.cov, xlab="Lag distance (km)", bg.sig="red", col.nonsig="red", 
     main="Mussel cover", 
     rug=TRUE, ylim=c(-0.3, 0.3))
lines(v.cov$mean.bin.dist, v.cov.per$fit, col="red")
plot(v.upw, xlab="Lag distance (km)", bg.sig="blue", col.nonsig="blue", 
     main="Upwelling", rug=TRUE)
lines(v.upw$mean.bin.dist, v.upw.lin$fit, col="blue")
</code></pre>

<hr>
<h2 id='vario.fit'>
vario.fit
</h2><span id='topic+vario.fit'></span>

<h3>Description</h3>

<p>Fit model to the empirical variogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vario.fit (vario, bins, weights = rep(1, length(vario)),
                       type = c("spherical", "gaussian", "nugget", "linear", 
                       "exponential", "sill", "periodic", "hole"),
                       start.vals = list(c0 = 0, c1 = max(vario), 
                                          a = max(bins)/4, b=0.1, c=0.1),
                       control = list(maxit=10000)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vario.fit_+3A_vario">vario</code></td>
<td>
<p>Empirical variogram from <code>emp.vario</code> function</p>
</td></tr>
<tr><td><code id="vario.fit_+3A_bins">bins</code></td>
<td>
<p>Bins or lag distances from <code>emp.vario</code> function</p>
</td></tr>
<tr><td><code id="vario.fit_+3A_weights">weights</code></td>
<td>
<p>Vector of weights of the same length as <code>vario</code>. If <code>weights</code> is a vector 
containing the number of points in each distance bin, the model will be fit via 
weighted least squares with the weights corresponding to the proportion of points
within each bin (i.e., weights sum to 1). Default is a vector of weights equal to 1</p>
</td></tr>
<tr><td><code id="vario.fit_+3A_type">type</code></td>
<td>
<p>Type of variogram model to fit to the data. Default is <code>spherical</code>. 
Other options are <code>gaussian</code>, <code>nugget</code>, <code>linear</code>, <code>exponential</code>, 
<code>sill</code>, <code>periodic</code>, and <code>hole</code>
</p>
</td></tr>
<tr><td><code id="vario.fit_+3A_start.vals">start.vals</code></td>
<td>
<p>Named list containing the start values for the variogram model: 
<code>c0</code>: nugget, <code>c1</code>: sill, <code>a</code>: spatial range; <code>b</code>: slope; 
<code>c</code>: frequency</p>
</td></tr>
<tr><td><code id="vario.fit_+3A_control">control</code></td>
<td>
<p>optional parameter for the <code>optim</code> function. 
See <code>?optim</code> for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a named list containing the following variables:
</p>
<table>
<tr><td><code>vario</code></td>
<td>
<p>Empirical variogram values</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>Empirical variogram bins/lag distances</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC score of the model fit: <code class="reqn">AIC=nlog\left(\frac{SSE}{n}\right)+2p</code>
where <code class="reqn">n</code> is the number of points in the variogram, <code class="reqn">SSE=\sum{(\hat{x}_{i}-x_{i}})^2</code>,
and <code class="reqn">p</code> is the number of parameters</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root Mean Square Error of the model fit: <code class="reqn">\sqrt{\frac{SSE}{n}}</code></p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Named list containing the best model parameter estimates</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Predicted variogram values from the model fit</p>
</td></tr>
<tr><td><code>nls.success</code></td>
<td>
<p>did <code>nls</code> succeed?</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>did <code>nls</code> or <code>optim</code> converge?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Selecting proper initial values is critical for fitting a reasonable model to the 
empirical variogram. If these values are off, <code>nls</code> will fail and fall-back
functions will be used to determine the best parameter values that minimize the 
Root Mean Square Error (RMSE).
</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vario">vario</a>, <a href="#topic+vario.func">vario.func</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(pisco.data)
# Environmental variogram
d=subset(pisco.data, subset=year==2000, select=c("latitude", "longitude", "upwelling"))
semiv=vario(data=d)
plot(semiv, xlab="Lag distance (km)")
mod.sph=vario.fit(semiv$vario, semiv$mean.bin.dist)
# Weighted least squares fit based on the number of points
mod.exp=vario.fit(semiv$vario, semiv$mean.bin.dist, 
                  weights=semiv$npoints/sum(semiv$npoints), 
                  type="expo")
mod.gau=vario.fit(semiv$vario, semiv$mean.bin.dist, type="gauss")
mod.lin=vario.fit(semiv$vario, semiv$mean.bin.dist, type="lin")
lines(semiv$mean.bin.dist, mod.sph$fit, col="red")
lines(semiv$mean.bin.dist, mod.exp$fit, col="black")
lines(semiv$mean.bin.dist, mod.gau$fit, col="blue")
lines(semiv$mean.bin.dist, mod.lin$fit, col="green")
legend(x="topleft", legend=paste(c("Spherical AIC:", "Exponential AIC:", 
                                   "Gaussian AIC:", "Linear AIC:"), 
                                   c(format(mod.sph$AIC, dig=2), 
                                   format(mod.exp$AIC, dig=2), 
                                   format(mod.gau$AIC, dig=2), 
       format(mod.lin$AIC, dig=2))), lty=1, col=c("red", "black", "blue", "green"), 
       bty="n")

# Correlogram
cover=subset(pisco.data, subset=year==2000, 
             select=c("latitude", "longitude", "mussel_abund"))
moran=vario(data=cover, type="moran")
mod.hol=vario.fit(moran$vario, moran$mean.bin.dist, 
                  type="hole", start.vals=list(c0=0.6, a=25, c1=0.01))
mod.per=vario.fit(moran$vario, moran$mean.bin.dist, type="period",
                  start.vals=list(a=1, b=3, c=0))
mod.lin=vario.fit(moran$vario, moran$mean.bin.dist, type="linear")
plot(moran, xlab="Lag distance (km)", ylim=c(-0.6, 0.8))
lines(moran$mean.bin.dist, mod.per$fit, col="red")
lines(moran$mean.bin.dist, mod.hol$fit, col="black")
lines(moran$mean.bin.dist, mod.lin$fit, col="blue")
legend(x="topleft", legend=paste(c("Periodic AIC:", "Hole AIC:", 
                                   "Linear AIC:"), 
                                   c(format(mod.per$AIC, dig=2), 
                                   format(mod.hol$AIC, dig=2), 
                                   format(mod.lin$AIC, dig=2))), 
                                   lty=1, col=c("red", "black", "blue"), bty="n")
</code></pre>

<hr>
<h2 id='vario.func'>
vario.func
</h2><span id='topic+vario.func'></span>

<h3>Description</h3>

<p>Compute the empirical variogram values for each bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vario.func (x, y, glob.mean, glob.sd, glob.N, is.multivar = FALSE,
                        type = c("semivar", "cov", "pearson", 
                                 "spearman", "kendall", "moran", "geary"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vario.func_+3A_x">x</code></td>
<td>
<p>First set of sites within bin/lag distance</p>
</td></tr>
<tr><td><code id="vario.func_+3A_y">y</code></td>
<td>
<p>Second set of sites within bin/lag distance</p>
</td></tr>
<tr><td><code id="vario.func_+3A_glob.mean">glob.mean</code></td>
<td>
<p>Global mean</p>
</td></tr>
<tr><td><code id="vario.func_+3A_glob.sd">glob.sd</code></td>
<td>
<p>Global standard deviation</p>
</td></tr>
<tr><td><code id="vario.func_+3A_glob.n">glob.N</code></td>
<td>
<p>Global number of points</p>
</td></tr>
<tr><td><code id="vario.func_+3A_is.multivar">is.multivar</code></td>
<td>
<p>Is the data multivariate? Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="vario.func_+3A_type">type</code></td>
<td>
<p>Type of variogram to compute. Default is <code>semivar</code> for semivariance. 
Other options include <code>cov</code> for covariance, <code>pearson</code> for Pearson
correlation, <code>spearman</code> for Spearman correlation, <code>kendall</code> for Kendall correlation,
<code>moran</code> for Moran's I, and <code>geary</code> for Geary's C  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the value.</p>


<h3>Author(s)</h3>

<p>Tarik C. Gouhier (tarik.gouhier@gmail.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vario">vario</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Internal function used by vario
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
