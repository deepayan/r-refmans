<!DOCTYPE html><html><head><title>Help for package JATSdecoder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JATSdecoder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allStats'><p>allStats</p></a></li>
<li><a href='#est.ss'><p>est.ss</p></a></li>
<li><a href='#get.abstract'><p>get.abstract</p></a></li>
<li><a href='#get.aff'><p>get.aff</p></a></li>
<li><a href='#get.alpha.error'><p>get.alpha.error</p></a></li>
<li><a href='#get.assumptions'><p>get.assumptions</p></a></li>
<li><a href='#get.author'><p>get.author</p></a></li>
<li><a href='#get.category'><p>get.category</p></a></li>
<li><a href='#get.contrib'><p>get.contrib</p></a></li>
<li><a href='#get.country'><p>get.country</p></a></li>
<li><a href='#get.doi'><p>get.doi</p></a></li>
<li><a href='#get.editor'><p>get.editor</p></a></li>
<li><a href='#get.history'><p>get.history</p></a></li>
<li><a href='#get.journal'><p>get.journal</p></a></li>
<li><a href='#get.keywords'><p>get.keywords</p></a></li>
<li><a href='#get.method'><p>get.method</p></a></li>
<li><a href='#get.multi.comparison'><p>get.multi.comparison</p></a></li>
<li><a href='#get.n.studies'><p>get.n.studies</p></a></li>
<li><a href='#get.outlier.def'><p>get.outlier.def</p></a></li>
<li><a href='#get.power'><p>get.power</p></a></li>
<li><a href='#get.R.package'><p>get.R.package</p></a></li>
<li><a href='#get.references'><p>get.references</p></a></li>
<li><a href='#get.sentence.with.pattern'><p>get.sentence.with.pattern</p></a></li>
<li><a href='#get.sig.adjectives'><p>get.sig.adjectives</p></a></li>
<li><a href='#get.software'><p>get.software</p></a></li>
<li><a href='#get.stats'><p>get.stats</p></a></li>
<li><a href='#get.subject'><p>get.subject</p></a></li>
<li><a href='#get.tables'><p>get.tables</p></a></li>
<li><a href='#get.test.direction'><p>get.test.direction</p></a></li>
<li><a href='#get.text'><p>get.text</p></a></li>
<li><a href='#get.title'><p>get.title</p></a></li>
<li><a href='#get.type'><p>get.type</p></a></li>
<li><a href='#get.vol'><p>get.vol</p></a></li>
<li><a href='#grep2'><p>grep2</p></a></li>
<li><a href='#has.interaction'><p>has.interaction</p></a></li>
<li><a href='#JATSdecoder'><p>JATSdecoder</p></a></li>
<li><a href='#letter.convert'><p>letter.convert</p></a></li>
<li><a href='#ngram'><p>ngram</p></a></li>
<li><a href='#pCheck'><p>pCheck</p></a></li>
<li><a href='#preCheck'><p>preCheck</p></a></li>
<li><a href='#standardStats'><p>standardStats</p></a></li>
<li><a href='#strsplit2'><p>strsplit2</p></a></li>
<li><a href='#study.character'><p>study.character</p></a></li>
<li><a href='#text2num'><p>text2num</p></a></li>
<li><a href='#text2sentences'><p>text2sentences</p></a></li>
<li><a href='#vectorize.text'><p>vectorize.text</p></a></li>
<li><a href='#which.term'><p>which.term</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Metadata and Text Extraction and Manipulation Tool Set</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ingmar Böschen &lt;ingmar.boeschen@uni-hamburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a function collection to extract metadata, sectioned text and study characteristics from scientific articles in 'NISO-JATS' format. Articles in PDF format can be converted to 'NISO-JATS' with the 'Content ExtRactor and MINEr' ('CERMINE', <a href="https://github.com/CeON/CERMINE">https://github.com/CeON/CERMINE</a>). For convenience, two functions bundle the extraction heuristics: JATSdecoder() converts 'NISO-JATS'-tagged XML files to a structured list with elements title, author, journal, history, 'DOI', abstract, sectioned text and reference list. study.character() extracts multiple study characteristics like number of included studies, statistical methods used, alpha error, power, statistical results, correction method for multiple testing, software used. An estimation of the involved sample size is performed based on reports within the abstract and the reported degrees of freedom within statistical results. In addition, the package contains some useful functions to process text (text2sentences(), text2num(), ngram(), strsplit2(), grep2()). See Böschen, I. (2021) &lt;<a href="https://doi.org/10.1007%2Fs11192-021-04162-z">doi:10.1007/s11192-021-04162-z</a>&gt; Böschen, I. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41598-021-98782-3">doi:10.1038/s41598-021-98782-3</a>&gt; and Böschen, I (2023) &lt;<a href="https://doi.org/10.1038%2Fs41598-022-27085-y">doi:10.1038/s41598-022-27085-y</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, NLP, openNLP</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ingmarboeschen/JATSdecoder">https://github.com/ingmarboeschen/JATSdecoder</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ingmarboeschen/JATSdecoder/issues">https://github.com/ingmarboeschen/JATSdecoder/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 12:26:36 UTC; ingmar</td>
</tr>
<tr>
<td>Author:</td>
<td>Ingmar Böschen <a href="https://orcid.org/0000-0003-1159-3991"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-12 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allStats'>allStats</h2><span id='topic+allStats'></span>

<h3>Description</h3>

<p>Extracts statistical results within a text string and outputs a vector of sticked results, e.g.: c(&quot;t(12)=1.2, p&gt;.05&quot;,&quot;r's(33)&gt;.7, ps&lt;.05&quot;), that can be further processed with <code><a href="#topic+standardStats">standardStats</a></code>. This function is implemented in <code><a href="#topic+get.stats">get.stats</a></code> which returns the results of <code><a href="#topic+allStats">allStats</a></code> and <code><a href="#topic+standardStats">standardStats</a></code>. Besides only plain textual input, <code><a href="#topic+get.stats">get.stats</a></code> enables direct processing of different file formats (NISO-JATS coded XML, DOCX, HTML) without text preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allStats(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allStats_+3A_x">x</code></td>
<td>
<p>A character string that may contain statistical results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with sticked results. Empty, if no result is detected.
</p>


<h3>Source</h3>

<p>A minimal web application that extracts statistical results from single documents with <code><a href="#topic+get.stats">get.stats</a></code> is hosted at: <a href="https://www.get-stats.app">https://www.get-stats.app/</a>
</p>


<h3>References</h3>

<p>Böschen (2021). &quot;Evaluation of JATSdecoder as an automated text extraction tool for statistical results in scientific reports.” <em>Scientific Reports.</em> doi: <a href="https://www.nature.com/articles/s41598-021-98782-3">10.1038/s41598-021-98782-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>
<p><code><a href="#topic+get.stats">get.stats</a></code> for extracting statistical results from textual input and different file formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("The mean difference of scale A was significant (beta=12.9, t(18)=2.5, p&lt;.05)",
"The ANOVA yielded significant results on factor A (F(2,18)=6, p&lt;.05, eta(g)2&lt;-.22).",
"The correlation of x and y was r=.37.")
allStats(x)
</code></pre>

<hr>
<h2 id='est.ss'>est.ss</h2><span id='topic+est.ss'></span>

<h3>Description</h3>

<p>Function to estimate studies sample size by maximizing different conservative estimates.
Performs four different extraction heuristics for sample sizes mentioned in abstract, text and statistical results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.ss(
  abstract = NULL,
  text = NULL,
  stats = NULL,
  standardStats = NULL,
  quantileDF = 0.9,
  max.only = FALSE,
  max.parts = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.ss_+3A_abstract">abstract</code></td>
<td>
<p>an abstract text string.</p>
</td></tr>
<tr><td><code id="est.ss_+3A_text">text</code></td>
<td>
<p>the main text string to process (usually method and result sections). If text has content, arguments &quot;stats&quot; and &quot;standardStats&quot; are deactivated and filled with results by get.stats(text).</p>
</td></tr>
<tr><td><code id="est.ss_+3A_stats">stats</code></td>
<td>
<p>statistics extracted with get.stats(x)$stats (only active if no text is submitted).</p>
</td></tr>
<tr><td><code id="est.ss_+3A_standardstats">standardStats</code></td>
<td>
<p>standard statistics extracted with get.stats(x)$standardStats  (only active if no text is submitted).</p>
</td></tr>
<tr><td><code id="est.ss_+3A_quantiledf">quantileDF</code></td>
<td>
<p>quantile of (df1-1)+(df2+2) to extract.</p>
</td></tr>
<tr><td><code id="est.ss_+3A_max.only">max.only</code></td>
<td>
<p>Logical. If TRUE only the final estimate will be returned, if FALSE all sub estimates are returned as well.</p>
</td></tr>
<tr><td><code id="est.ss_+3A_max.parts">max.parts</code></td>
<td>
<p>Logical. If FALSE outputs all captured sample sizes in sub inputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample size extraction from abstract:<br />
- Extracts N= from abstract text and performs position-of-speech search with list of synonyms of sample units
</p>
<p>Sample size extraction from text:<br />
- Unifies and extracts textlines with age descriptions, than computes sum of hits as nage
- Unifies and extracts all &quot;numeric male-female&quot; patterns than computes sum of first male/female hit
- Unifies and extracts textlines with participant description than computes sum of first three hits as ntext
</p>
<p>Sample size extraction from statistical results:<br />
- Extracts &quot;N=&quot; in statistical results extracted with allStats() that contain p-value: e.g.: chi(2, N=12)=15.2, p&lt;.05
</p>
<p>Sample size extraction by degrees of freedom with result of standardStats(allStats()):<br />
- Extracts df1 and df2 if possible and neither containing a &quot;.&quot;, than calculates specified quantile of (df1+1)+(df2+2) (at least 2 group comparison assumed)
</p>


<h3>Value</h3>

<p>Numeric vector with extracted sample sizes by input and estimated sample size.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 a&lt;-"One hundred twelve students participated in our study."
 est.ss(abstract=a)
 x&lt;-"Our sample consists of three hundred twenty five undergraduate students.
     The F-test indicates significant differences in means F(2,102)=3.21, p&lt;.05."
 est.ss(text=x)

</code></pre>

<hr>
<h2 id='get.abstract'>get.abstract</h2><span id='topic+get.abstract'></span>

<h3>Description</h3>

<p>Extracts abstract tag from NISO-JATS coded XML file or text as vector of abstracts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.abstract(
  x,
  sentences = FALSE,
  remove.title = TRUE,
  letter.convert = TRUE,
  cermine = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.abstract_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.abstract_+3A_sentences">sentences</code></td>
<td>
<p>Logical. If TRUE abstract is returned as vector of sentences.</p>
</td></tr>
<tr><td><code id="get.abstract_+3A_remove.title">remove.title</code></td>
<td>
<p>Logical. If TRUE removes section titles in abstract.</p>
</td></tr>
<tr><td><code id="get.abstract_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="get.abstract_+3A_cermine">cermine</code></td>
<td>
<p>Logical. If TRUE and if 'letter.convert=TRUE' CERMINE specific letter correction is carried out (e.g. inserting of missing operators to statistical results).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. The abstract/s text as floating text or vector of sentences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;abstract&gt;Some abstract&lt;/abstract&gt; some text"
get.abstract(x)
x&lt;-"Some text &lt;abstract&gt;Some abstract&lt;/abstract&gt; TEXT &lt;abstract with subsettings&gt;
Some other abstract&lt;/abstract&gt; Some text "
get.abstract(x)
</code></pre>

<hr>
<h2 id='get.aff'>get.aff</h2><span id='topic+get.aff'></span>

<h3>Description</h3>

<p>Extracts the affiliation tag information from NISO-JATS coded XML file or text as a vector of affiliations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.aff(x, remove.html = FALSE, letter.convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.aff_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.aff_+3A_remove.html">remove.html</code></td>
<td>
<p>Logical. If TRUE removes all html tags.</p>
</td></tr>
<tr><td><code id="get.aff_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted affiliation name/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;aff&gt;Some affiliation&lt;/aff&gt; some text"
get.aff(x)
x&lt;-"TEXT &lt;aff&gt;Some affiliation&lt;/aff&gt; TEXT &lt;aff&gt;Some other affiliation&lt;/aff&gt; TEXT"
get.aff(x)
</code></pre>

<hr>
<h2 id='get.alpha.error'>get.alpha.error</h2><span id='topic+get.alpha.error'></span>

<h3>Description</h3>

<p>Extracts reported and corrected alpha error from text and 1-alpha confidence intervalls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.alpha.error(x, p2alpha = TRUE, output = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.alpha.error_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.alpha.error_+3A_p2alpha">p2alpha</code></td>
<td>
<p>Logical. If TRUE detects and extracts alpha errors denoted with a critical p-value (may lead to some false positive detections).</p>
</td></tr>
<tr><td><code id="get.alpha.error_+3A_output">output</code></td>
<td>
<p>One of c(&quot;list&quot;,&quot;vector&quot;). If output=&quot;list&quot; returns a list containing: alpha_error, <br />
corrected_alpha, alpha_from_CI, alpha_max, alpha_min. If output=&quot;vector&quot; returns unique alpha errors but no distinction of types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Vector with identified alpha-error/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("The threshold for significance was adjusted to .05/2",
"Type 1 error rate was alpha=.05.")
get.alpha.error(x)
x&lt;-c("We used p&lt;.05 as level of significance.",
     "We display .95 CIs and use an adjusted alpha of .10/3.",
     "The effect was significant with p&lt;.025.")
get.alpha.error(x)
</code></pre>

<hr>
<h2 id='get.assumptions'>get.assumptions</h2><span id='topic+get.assumptions'></span>

<h3>Description</h3>

<p>Extracts the mentioned statistical assumptions from a text string by a dictionary search of 22 common statistical assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.assumptions(x, hits_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.assumptions_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.assumptions_+3A_hits_only">hits_only</code></td>
<td>
<p>Logical. If TRUE returns the detected assumtions only, else a hit matrix with all potential assumptions is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with identified statistical assumption/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Sphericity assumption and gaus-marcov was violated."
get.assumptions(x)
</code></pre>

<hr>
<h2 id='get.author'>get.author</h2><span id='topic+get.author'></span>

<h3>Description</h3>

<p>Extracts author tag information from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.author(x, paste = "", short.names = FALSE, letter.convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.author_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.author_+3A_paste">paste</code></td>
<td>
<p>if paste!=&quot;&quot; author list is collapsed to one cell with seperator specified (e.g. paste=&quot;;&quot;).</p>
</td></tr>
<tr><td><code id="get.author_+3A_short.names">short.names</code></td>
<td>
<p>Logical. If TRUE fully available first names will be reduced to single letter abbreviation.</p>
</td></tr>
<tr><td><code id="get.author_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted author name/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.category'>get.category</h2><span id='topic+get.category'></span>

<h3>Description</h3>

<p>Extracts category tag/s from NISO-JATS coded XML file or text as vector of categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.category(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.category_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted category name/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;article-categories&gt;Some category&lt;/article-categories&gt; some text"
get.category(x)
</code></pre>

<hr>
<h2 id='get.contrib'>get.contrib</h2><span id='topic+get.contrib'></span>

<h3>Description</h3>

<p>Extracts contrib tag/s from NISO-JATS coded XML file or text as vector of contributers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.contrib(x, remove.html = FALSE, letter.convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.contrib_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.contrib_+3A_remove.html">remove.html</code></td>
<td>
<p>Logical. If TRUE removes all HTML tags.</p>
</td></tr>
<tr><td><code id="get.contrib_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted contributer tag content.
</p>

<hr>
<h2 id='get.country'>get.country</h2><span id='topic+get.country'></span>

<h3>Description</h3>

<p>Extracts country tag from NISO-JATS coded XML file or text as vector of unique countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.country(x, unifyCountry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.country_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.country_+3A_unifycountry">unifyCountry</code></td>
<td>
<p>Logical. If TRUE replaces country name with standardised country name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted country name/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;country&gt;UK&lt;/country&gt; some text &lt;country&gt;England&lt;/country&gt;
    Text&lt;country&gt;Berlin, Germany&lt;/country&gt;"
get.country(x)
</code></pre>

<hr>
<h2 id='get.doi'>get.doi</h2><span id='topic+get.doi'></span>

<h3>Description</h3>

<p>Extracts articles doi from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.doi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.doi_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with the extracted doi.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.editor'>get.editor</h2><span id='topic+get.editor'></span>

<h3>Description</h3>

<p>Extracts editor tag from NISO-JATS coded XML file or text as vector of editors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.editor(x, role = FALSE, short.names = FALSE, letter.convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.editor_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.editor_+3A_role">role</code></td>
<td>
<p>Logical. If TRUE adds role to editor name, if available.</p>
</td></tr>
<tr><td><code id="get.editor_+3A_short.names">short.names</code></td>
<td>
<p>Logical. If TRUE reduces fully available first names to one letter abbreviation.</p>
</td></tr>
<tr><td><code id="get.editor_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with the extracted editor name/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.history'>get.history</h2><span id='topic+get.history'></span>

<h3>Description</h3>

<p>Extracts available publishing history tags from NISO-JATS coded XML file or text and compute pubDate and pubyear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.history(x, remove.na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.history_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.history_+3A_remove.na">remove.na</code></td>
<td>
<p>Logical. If TRUE hides non available date stamps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the extracted dates of publishing history.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.journal'>get.journal</h2><span id='topic+get.journal'></span>

<h3>Description</h3>

<p>Extracts journal tag from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.journal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.journal_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with the extracted journal name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;journal-title&gt;PLoS One&lt;/journal-title&gt; some text"
get.journal(x)
</code></pre>

<hr>
<h2 id='get.keywords'>get.keywords</h2><span id='topic+get.keywords'></span>

<h3>Description</h3>

<p>Extracts keyword tag/s from NISO-JATS coded XML file or text as vector of keywords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.keywords(
  x,
  paste = "",
  letter.convert = TRUE,
  include.max = length(keyword)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.keywords_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.keywords_+3A_paste">paste</code></td>
<td>
<p>if paste!=&quot;&quot; keyword list is collapsed to one cell with seperator specified (e.g. paste=&quot;;&quot;).</p>
</td></tr>
<tr><td><code id="get.keywords_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="get.keywords_+3A_include.max">include.max</code></td>
<td>
<p>a maximum number of keywords to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with extracted keyword/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;kwd&gt;Keyword 1&lt;/kwd&gt;, &lt;kwd&gt;Keyword 2&lt;/kwd&gt; some text"
get.keywords(x)
get.keywords(x,paste(", "))
</code></pre>

<hr>
<h2 id='get.method'>get.method</h2><span id='topic+get.method'></span>

<h3>Description</h3>

<p>Extracts statistical methods mentioned in text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.method(x, add = NULL, cermine = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.method_+3A_x">x</code></td>
<td>
<p>text to extract statistical methods from.</p>
</td></tr>
<tr><td><code id="get.method_+3A_add">add</code></td>
<td>
<p>possible new end words of method as vector.</p>
</td></tr>
<tr><td><code id="get.method_+3A_cermine">cermine</code></td>
<td>
<p>Logical. If TRUE CERMINE specific letter conversion will be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with identified statistical method/s
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"We used multiple regression analysis and 
two sample t tests to evaluate our results."
get.method(x)
</code></pre>

<hr>
<h2 id='get.multi.comparison'>get.multi.comparison</h2><span id='topic+get.multi.comparison'></span>

<h3>Description</h3>

<p>Extracts alpha-/p-value correction method for multiple comparisons from list with 15 correction methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.multi.comparison(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.multi.comparison_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Identified author/method of multiple comparison correction procedure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"We used Bonferroni corrected p-values."
get.multi.comparison(x)
</code></pre>

<hr>
<h2 id='get.n.studies'>get.n.studies</h2><span id='topic+get.n.studies'></span>

<h3>Description</h3>

<p>Extracts number of studies/experiments from text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.n.studies(x, tolower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.n.studies_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.n.studies_+3A_tolower">tolower</code></td>
<td>
<p>Logical. If TRUE lowerises text and search patterns for processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric number of identified number of studies. Returns '1' as standard output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>

<hr>
<h2 id='get.outlier.def'>get.outlier.def</h2><span id='topic+get.outlier.def'></span>

<h3>Description</h3>

<p>Extracts outlier/extreme value definition/removal in standard deviations, if present in text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.outlier.def(x, range = c(1, 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.outlier.def_+3A_x">x</code></td>
<td>
<p>Character. A text string to process.</p>
</td></tr>
<tr><td><code id="get.outlier.def_+3A_range">range</code></td>
<td>
<p>Numeric vector with length=2. Possible result space of extracted value/s in standard deviations. Use 'c(0,Inf)' for no restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Vector with identified outlier definition in standard deviations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"We removed 4 extreme values that were 3 SD above mean."
get.outlier.def(x)
</code></pre>

<hr>
<h2 id='get.power'>get.power</h2><span id='topic+get.power'></span>

<h3>Description</h3>

<p>Extracts a priori power and empirial power values from text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.power(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.power_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Identified power values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"We used G*Power 3 to calculate the needed sample with 
beta error rate set to 12% and alpha error to .05."
get.power(x)
</code></pre>

<hr>
<h2 id='get.R.package'>get.R.package</h2><span id='topic+get.R.package'></span>

<h3>Description</h3>

<p>Extracts mentioned R packages from text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.R.package(x, update.package.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.R.package_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.R.package_+3A_update.package.list">update.package.list</code></td>
<td>
<p>Logical. If TRUE update of list with available packages is downloaded from CRAN with utils::available.packages().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with identified R package/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.R.package("We used the R Software packages lme4 (and psych).")
</code></pre>

<hr>
<h2 id='get.references'>get.references</h2><span id='topic+get.references'></span>

<h3>Description</h3>

<p>Extracts reference list from NISO-JATS coded XML file or text as vector of references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.references(
  x,
  letter.convert = FALSE,
  remove.html = FALSE,
  extract = "full"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.references_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.references_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="get.references_+3A_remove.html">remove.html</code></td>
<td>
<p>Logical. If TRUE removes all HTML tags.</p>
</td></tr>
<tr><td><code id="get.references_+3A_extract">extract</code></td>
<td>
<p>part of refernces to extract (one of &quot;full&quot; or &quot;title&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with extracted references from reference list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.sentence.with.pattern'>get.sentence.with.pattern</h2><span id='topic+get.sentence.with.pattern'></span>

<h3>Description</h3>

<p>Returns lines with search term patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sentence.with.pattern(x, patterns = c(""), tolower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sentence.with.pattern_+3A_x">x</code></td>
<td>
<p>sentence vector to process.</p>
</td></tr>
<tr><td><code id="get.sentence.with.pattern_+3A_patterns">patterns</code></td>
<td>
<p>search terms.</p>
</td></tr>
<tr><td><code id="get.sentence.with.pattern_+3A_tolower">tolower</code></td>
<td>
<p>Logical. If TRUE converts search terms and text to lower case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with sentences, that contain search pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text&lt;-c("This demo", "demonstrates how", "get.sentence.with.pattern works.")
get.sentence.with.pattern(text,c("Demo","example","work"))
get.sentence.with.pattern(text,c("Demo","example","work"),tolower=FALSE)
</code></pre>

<hr>
<h2 id='get.sig.adjectives'>get.sig.adjectives</h2><span id='topic+get.sig.adjectives'></span>

<h3>Description</h3>

<p>Extracts adjectives used for in/significance out of list with 37 potential adjectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sig.adjectives(x, unique_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sig.adjectives_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.sig.adjectives_+3A_unique_only">unique_only</code></td>
<td>
<p>Logical. If TRUE returns unique hits only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with identified adjectives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.sig.adjectives(
 x&lt;-"We found very highly significance for type 1 effect"
)
</code></pre>

<hr>
<h2 id='get.software'>get.software</h2><span id='topic+get.software'></span>

<h3>Description</h3>

<p>Extracts mentioned software from text by dictionary search for 63 software names (object: .software_names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.software(x, add.software = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.software_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="get.software_+3A_add.software">add.software</code></td>
<td>
<p>a text vector with additional software name patterns to search for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with identified statistical software/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.software("We used the R Software and Excel 4.0 to analyse our data.")
</code></pre>

<hr>
<h2 id='get.stats'>get.stats</h2><span id='topic+get.stats'></span>

<h3>Description</h3>

<p>Extracts statistical results from text string, XML, CERMXML, HTML or DOCX files. The result is a list with a vector containing all identified sticked results and a matrix containing the reported standard statistics and recalculated p-values if computation is possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.stats(
  x,
  output = "both",
  stats.mode = "all",
  recalculate.p = TRUE,
  checkP = FALSE,
  alpha = 0.05,
  criticalDif = 0.02,
  alternative = "undirected",
  estimateZ = FALSE,
  T2t = FALSE,
  R2r = FALSE,
  select = NULL,
  rm.na.col = TRUE,
  cermine = FALSE,
  warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.stats_+3A_x">x</code></td>
<td>
<p>NISO-JATS coded XML or DOCX file path or plain textual content.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_output">output</code></td>
<td>
<p>Select the desired output. One of c(&quot;both&quot;, &quot;allStats&quot;, &quot;standardStats&quot;).</p>
</td></tr>
<tr><td><code id="get.stats_+3A_stats.mode">stats.mode</code></td>
<td>
<p>Select a subset of test results by p-value checkability for output. One of: c(&quot;all&quot;, &quot;checkable&quot;, &quot;computable&quot;, &quot;uncomputable&quot;).</p>
</td></tr>
<tr><td><code id="get.stats_+3A_recalculate.p">recalculate.p</code></td>
<td>
<p>Logical. If TRUE recalculates p-values of test results if possible.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_checkp">checkP</code></td>
<td>
<p>Logical. If TRUE observed and recalculated p-values are checked for consistency.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Defines the alpha level to be used for error assignment.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_criticaldif">criticalDif</code></td>
<td>
<p>Numeric. Sets the absolute maximum difference in reported and recalculated p-values for error detection.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_alternative">alternative</code></td>
<td>
<p>Character. Select test sidedness for recomputation of p-values from t-, r- and beta-values. One of c(&quot;undirected&quot;, &quot;directed&quot;). If &quot;directed&quot; is specified, p-values for directed null-hypothesis are added to the table but still require a manual inspection on consistency of the direction.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_estimatez">estimateZ</code></td>
<td>
<p>Logical. If TRUE detected beta-/d-value is divided by reported standard error &quot;SE&quot; to estimate Z-value (&quot;Zest&quot;) for observed beta/d and recompute p-value. Note: This is only valid, if Gauss-Marcov assumptions are met and a sufficiently large sample size is used. If a Z- or t-value is detected in a report of a beta-/d-coefficient with SE, no estimation will be performed, although set to TRUE.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_t2t">T2t</code></td>
<td>
<p>Logical. If TRUE capital letter T is treated as t-statistic.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_r2r">R2r</code></td>
<td>
<p>Logical. If TRUE capital letter R is treated as correlation.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_select">select</code></td>
<td>
<p>Select specific standard statistics only (e.g.: c(&quot;t&quot;, &quot;F&quot;, &quot;Chi2&quot;)).</p>
</td></tr>
<tr><td><code id="get.stats_+3A_rm.na.col">rm.na.col</code></td>
<td>
<p>Logical. If TRUE removes all columns with only NA from standardStats.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_cermine">cermine</code></td>
<td>
<p>Logical. If TRUE CERMINE specific letter conversion will be peformed on allStats results.</p>
</td></tr>
<tr><td><code id="get.stats_+3A_warnings">warnings</code></td>
<td>
<p>Logical. If FALSE warning messages are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If output=&quot;all&quot;: list with two elements. E1: vector of extracted results by <code><a href="#topic+allStats">allStats</a></code> and E2: matrix of standard results by <code><a href="#topic+standardStats">standardStats</a></code>.<br /> If output=&quot;allStats&quot;: vector of extracted results by <code><a href="#topic+allStats">allStats</a></code>.<br /> If output=&quot;standardStats&quot;: matrix of standard results by <code><a href="#topic+standardStats">standardStats</a></code>.
</p>


<h3>Source</h3>

<p>A minimal web application that extracts statistical results from single documents with <code><a href="#topic+get.stats">get.stats</a></code> is hosted at: <a href="https://www.get-stats.app">https://www.get-stats.app/</a>
</p>
<p>Statistical results extracted with <code><a href="#topic+get.stats">get.stats</a></code> can be analyzed and used to identify articles stored in the PubMed Central library at: <a href="https://www.scianalyzer.com">https://www.scianalyzer.com/</a>.
</p>


<h3>References</h3>

<p>Böschen (2021). &quot;Evaluation of JATSdecoder as an automated text extraction tool for statistical results in scientific reports.” <em>Scientific Reports.</em> doi: <a href="https://www.nature.com/articles/s41598-021-98782-3">10.1038/s41598-021-98782-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting different study characteristics at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Extract results from plain text input
x&lt;-c("The mean difference of scale A was significant (beta=12.9, t(18)=2.5, p&lt;.05).",
"The ANOVA yielded significant results on 
 faktor A (F(2,18)=6, p&lt;.05, eta(g)2&lt;-.22)",
"the correlation of x and y was r=.37.")
get.stats(x)

## Extract results from native NISO-JATS XML file
# download example XML file via URL if a connection is possible
x&lt;-"https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0114876&amp;type=manuscript"
# file name
file&lt;-paste0(tempdir(),"/file.xml")
# download URL as "file.xml" in tempdir() if a connection is possible
tryCatch({
  readLines(x,n=1)
  download.file(x,file)
  },
  warning = function(w) message(
  "Something went wrong. Check your internet connection and the link address."),
  error = function(e) message(
  "Something went wrong. Check your internet connection and the link address.")
)
# apply get.stats() to file
if(file.exists(file)) get.stats(file)
</code></pre>

<hr>
<h2 id='get.subject'>get.subject</h2><span id='topic+get.subject'></span>

<h3>Description</h3>

<p>Extracts subject tag/s from NISO-JATS coded XML file or text as vector of subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.subject(x, letter.convert = TRUE, paste = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.subject_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.subject_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="get.subject_+3A_paste">paste</code></td>
<td>
<p>if paste!=&quot;&quot; subject list is collapsed to one cell with seperator specified (e.g. paste=&quot;;&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with extracted subject/s.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text &lt;subject&gt;Some subject&lt;/subject&gt; some text"
get.subject(x)
x&lt;-"Some text &lt;subject&gt;Some subject&lt;/subject&gt; TEXT ...
&lt;subject&gt;Some other subject&lt;/subject&gt; Some text "
get.subject(x)
get.subject(x,paste=", ")
</code></pre>

<hr>
<h2 id='get.tables'>get.tables</h2><span id='topic+get.tables'></span>

<h3>Description</h3>

<p>Extracts HTML tables as vector of tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tables(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.tables_+3A_x">x</code></td>
<td>
<p>HTML file or html text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with extracted table in html coding.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.test.direction'>get.test.direction</h2><span id='topic+get.test.direction'></span>

<h3>Description</h3>

<p>Extracts mentioned test direction/s (one sided, two sided, one and two sided) from text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.test.direction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.test.direction_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>

<hr>
<h2 id='get.text'>get.text</h2><span id='topic+get.text'></span>

<h3>Description</h3>

<p>Extracts main textual content from NISO-JATS coded XML file or text as sectioned text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.text(
  x,
  sectionsplit = "",
  grepsection = "",
  letter.convert = TRUE,
  greek2text = FALSE,
  sentences = FALSE,
  paragraph = FALSE,
  cermine = "auto",
  rm.table = TRUE,
  rm.formula = TRUE,
  rm.xref = TRUE,
  rm.media = TRUE,
  rm.graphic = TRUE,
  rm.ext_link = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.text_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="get.text_+3A_sectionsplit">sectionsplit</code></td>
<td>
<p>search patterns for section split (forced to lower case), e.g. c(&quot;intro&quot;, &quot;method&quot;, &quot;result&quot;, &quot;discus&quot;).</p>
</td></tr>
<tr><td><code id="get.text_+3A_grepsection">grepsection</code></td>
<td>
<p>search pattern to reduce text to specific section namings only.</p>
</td></tr>
<tr><td><code id="get.text_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="get.text_+3A_greek2text">greek2text</code></td>
<td>
<p>Logical. If TRUE some greek letters and special characters will be unified to textual representation (important to extract stats).</p>
</td></tr>
<tr><td><code id="get.text_+3A_sentences">sentences</code></td>
<td>
<p>Logical. IF TRUE text is returned as sectioned list with sentences.</p>
</td></tr>
<tr><td><code id="get.text_+3A_paragraph">paragraph</code></td>
<td>
<p>Logical. IF TRUE &quot;&lt;New paragraph&gt;&quot; is added at the end of each paragraph to enable manual splitting at paragraphs.</p>
</td></tr>
<tr><td><code id="get.text_+3A_cermine">cermine</code></td>
<td>
<p>Logical. If TRUE CERMINE specific error handling and letter conversion will be applied. If set to &quot;auto&quot; file name ending with 'cermxml$' will set cermine=TRUE.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.table">rm.table</code></td>
<td>
<p>Logical. If TRUE removes &lt;table&gt; tag from text.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.formula">rm.formula</code></td>
<td>
<p>Logical. If TRUE removes &lt;formula&gt; tags.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.xref">rm.xref</code></td>
<td>
<p>Logical. If TRUE removes &lt;xref&gt; tag (citing) from text.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.media">rm.media</code></td>
<td>
<p>Logical. If TRUE removes &lt;media&gt; tag from text.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.graphic">rm.graphic</code></td>
<td>
<p>Logical. If TRUE removes &lt;graphic&gt; and &lt;fig&gt; tag from text.</p>
</td></tr>
<tr><td><code id="get.text_+3A_rm.ext_link">rm.ext_link</code></td>
<td>
<p>Logical. If TRUE removes &lt;ext link&gt; tag from text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements. 1: Character vector with section title/s, 2: Character vector with floating text of sections or list with vector of sentences per section/s if sentences=TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.title'>get.title</h2><span id='topic+get.title'></span>

<h3>Description</h3>

<p>Extracts article title from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.title(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.title_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with extracted article title.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.type'>get.type</h2><span id='topic+get.type'></span>

<h3>Description</h3>

<p>Extracts article type from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.type_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with extracted article type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='get.vol'>get.vol</h2><span id='topic+get.vol'></span>

<h3>Description</h3>

<p>Extracts volume, first and last page from NISO-JATS coded XML file or text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.vol_+3A_x">x</code></td>
<td>
<p>a NISO-JATS XML coded file or text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with extracted journal volume.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>

<hr>
<h2 id='grep2'>grep2</h2><span id='topic+grep2'></span>

<h3>Description</h3>

<p>Extension of grep(). Allows to identify and extract cells with/without multiple search patterns that are connected with AND.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grep2(pattern, x, value = TRUE, invert = FALSE, perl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grep2_+3A_pattern">pattern</code></td>
<td>
<p>Character vector containing regular expression as cells to be matched in the given character vector.</p>
</td></tr>
<tr><td><code id="grep2_+3A_x">x</code></td>
<td>
<p>A character vector where matches are sought, or an object which can be coerced by as.character to a character vector. Long vectors are supported.</p>
</td></tr>
<tr><td><code id="grep2_+3A_value">value</code></td>
<td>
<p>Logical. If FALSE, a vector containing the (integer) indices of the matches determined by grep2 is returned, and if TRUE, a vector containing the matching elements themselves is returned.</p>
</td></tr>
<tr><td><code id="grep2_+3A_invert">invert</code></td>
<td>
<p>Logical. If TRUE return indices or values for elements that do not match.</p>
</td></tr>
<tr><td><code id="grep2_+3A_perl">perl</code></td>
<td>
<p>Logical. Should Perl-compatible regexps be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grep2(value = FALSE) returns a vector of the indices of the elements of x that yielded a match (or not, for invert = TRUE). This will be an integer vector unless the input is a long vector, when it will be a double vector. <br /><br /> grep2(value = TRUE) returns a character vector containing the selected elements of x (after coercion, preserving names but no other attributes).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("ab","ac","ad","bc","bad")
grep2(c("a","b"),x)
grep2(c("a","b"),x,invert=TRUE)
grep2(c("a","b"),x,value=FALSE)
</code></pre>

<hr>
<h2 id='has.interaction'>has.interaction</h2><span id='topic+has.interaction'></span>

<h3>Description</h3>

<p>Identifies mentiones of interaction/moderator/mediator effect in text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.interaction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.interaction_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with type/s of identified interaction/moderator/mediator effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>

<hr>
<h2 id='JATSdecoder'>JATSdecoder</h2><span id='topic+JATSdecoder'></span>

<h3>Description</h3>

<p>Function to extract and restructure NISO-JATS coded XML file or text into a list with metadata and text as selectable elements. Use <a href="https://github.com/CeON/CERMINE">CERMINE</a> to convert PDF to CERMXML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JATSdecoder(
  x,
  sectionsplit = c("intro", "method", "result", "study", "experiment", "conclu",
    "implica", "discussion"),
  grepsection = "",
  sentences = FALSE,
  paragraph = FALSE,
  abstract2sentences = TRUE,
  output = "all",
  letter.convert = TRUE,
  unify.country.name = TRUE,
  greek2text = FALSE,
  warning = TRUE,
  countryconnection = FALSE,
  authorconnection = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JATSdecoder_+3A_x">x</code></td>
<td>
<p>a NISO-JATS coded XML file or text.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_sectionsplit">sectionsplit</code></td>
<td>
<p>search patterns for section split of text parts (forced to lower case), e.g. c(&quot;intro&quot;, &quot;method&quot;, &quot;result&quot;, &quot;discus&quot;).</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_grepsection">grepsection</code></td>
<td>
<p>search pattern in regex to reduce text to specific section only.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_sentences">sentences</code></td>
<td>
<p>Logical. IF TRUE text is returned as sectioned list with sentences.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_paragraph">paragraph</code></td>
<td>
<p>Logical. IF TRUE &quot;&lt;New paragraph&gt;&quot; is added at the end of each paragraph to enable manual splitting at paragraphs.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_abstract2sentences">abstract2sentences</code></td>
<td>
<p>Logical. IF TRUE abstract is returned as vector with sentences.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_output">output</code></td>
<td>
<p>selection of specific results to output c(&quot;all&quot;, &quot;title&quot;, &quot;author&quot;, &quot;affiliation&quot;, &quot;journal&quot;, &quot;volume&quot;, &quot;editor&quot;, &quot;doi&quot;, &quot;type&quot;, &quot;history&quot;, &quot;country&quot;, &quot;subject&quot;, &quot;keywords&quot;, &quot;abstract&quot;, &quot;sections&quot;, &quot;text&quot;, &quot;tables&quot;, &quot;captions&quot;, &quot;references&quot;).</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_letter.convert">letter.convert</code></td>
<td>
<p>Logical. If TRUE converts hexadecimal and HTML coded characters to Unicode.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_unify.country.name">unify.country.name</code></td>
<td>
<p>Logical. If TRUE tries to unify country name/s with list of country names from worldmap().</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_greek2text">greek2text</code></td>
<td>
<p>Logical. If TRUE converts and unifies several greek letters to textual representation, e.g.: &quot;alpha&quot;.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_warning">warning</code></td>
<td>
<p>Logical. If TRUE outputs a warning if processing CERMINE converted PDF files.</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_countryconnection">countryconnection</code></td>
<td>
<p>Logical. If TRUE outputs country connections as vector c(&quot;A - B&quot;,&quot;A - C&quot;, ...).</p>
</td></tr>
<tr><td><code id="JATSdecoder_+3A_authorconnection">authorconnection</code></td>
<td>
<p>Logical. If TRUE outputs connections of a maximum of 50 involved authors as vector c(&quot;A - B&quot;,&quot;A - C&quot;, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with extracted meta data, sectioned text and references.
</p>


<h3>Note</h3>

<p>A short tutorial on how to work with JATSdecoder and the generated outputs can be found at: <a href="https://github.com/ingmarboeschen/JATSdecoder">https://github.com/ingmarboeschen/JATSdecoder</a>
</p>


<h3>Source</h3>

<p>An interactive web application for selecting and analyzing extracted article metadata and study characteristics for articles linked to PubMed Central is hosted at: <a href="https://www.scianalyzer.com">https://www.scianalyzer.com/</a>
</p>
<p>The XML version of PubMed Central database articles can be downloaded in bulk from:<br /><a href="https://ftp.ncbi.nlm.nih.gov/pub/pmc/oa_bulk/">https://ftp.ncbi.nlm.nih.gov/pub/pmc/oa_bulk/</a>
</p>


<h3>References</h3>

<p>Böschen (2021). &quot;Software review: The JATSdecoder package - extract metadata, abstract and sectioned text from NISO-JATS coded XML documents; Insights to PubMed Central’s open access database.” <em>Scientometrics.</em> doi: <a href="https://link.springer.com/article/10.1007/s11192-021-04162-z">10.1007/s1119202104162z</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting different study characteristics at once.
</p>
<p><code><a href="#topic+get.stats">get.stats</a></code> for extracting statistical results from textual input and different file formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># download example XML file via URL
x&lt;-"https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0114876&amp;type=manuscript"
# file name
file&lt;-paste0(tempdir(),"/file.xml")
# download URL as "file.xml" in tempdir() if a connection is possible
tryCatch({
readLines(x,n=1)
download.file(x,file)
},
warning = function(w) message(
  "Something went wrong. Check your internet connection and the link address."),
error = function(e) message(
  "Something went wrong. Check your internet connection and the link address."))
# convert full article to list with metadata, sectioned text and reference list
if(file.exists(file)) JATSdecoder(file)
# extract specific content (here: abstract and text)
if(file.exists(file)) JATSdecoder(file,output=c("abstract","text"))
# or use specific functions, e.g.:
if(file.exists(file)) get.abstract(file)
if(file.exists(file)) get.text(file)
</code></pre>

<hr>
<h2 id='letter.convert'>letter.convert</h2><span id='topic+letter.convert'></span>

<h3>Description</h3>

<p>Converts and unifies most hexadecimal and some HTML coded letters to Unicode characters. Performs CERMINE specific error correction (inserting operators, where these got lost while conversion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>letter.convert(x, cermine = FALSE, greek2text = FALSE, warning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="letter.convert_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="letter.convert_+3A_cermine">cermine</code></td>
<td>
<p>Logical. If TRUE CERMINE specific error handling and letter conversion will be applied.</p>
</td></tr>
<tr><td><code id="letter.convert_+3A_greek2text">greek2text</code></td>
<td>
<p>Logical. If TRUE some greek letters and special characters will be unified to textual representation (important to extract stats).</p>
</td></tr>
<tr><td><code id="letter.convert_+3A_warning">warning</code></td>
<td>
<p>Logical. If TRUE prints warning massage if CERMINE specific letter conversion was performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Text with unified and corrected letter representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("five &amp;#x0003c; ten","five &amp;lt; ten")
letter.convert(x)
</code></pre>

<hr>
<h2 id='ngram'>ngram</h2><span id='topic+ngram'></span>

<h3>Description</h3>

<p>Extracts ngram bag of words around words that match a search pattern. 
Note: If an input contains the search pattern twice, only the ngram bag of words of the last hit is detected. Consider individual text splitting with text2sentences() or strsplit2() before applying ngram().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngram(
  x,
  pattern,
  ngram = c(-3, 3),
  tolower = FALSE,
  split = FALSE,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngram_+3A_x">x</code></td>
<td>
<p>vector of text strings to process.</p>
</td></tr>
<tr><td><code id="ngram_+3A_pattern">pattern</code></td>
<td>
<p>a search term pattern to extract the ngram bag of words.</p>
</td></tr>
<tr><td><code id="ngram_+3A_ngram">ngram</code></td>
<td>
<p>a vector of length=2 that defines the number of words to extract from left and right side of pattern match.</p>
</td></tr>
<tr><td><code id="ngram_+3A_tolower">tolower</code></td>
<td>
<p>Logical. If TRUE converts text and pattern to lower case.</p>
</td></tr>
<tr><td><code id="ngram_+3A_split">split</code></td>
<td>
<p>Logical. If TRUE splits text input at &quot;[.,;:] &quot; before processing. Note: You may consider other text splits before.</p>
</td></tr>
<tr><td><code id="ngram_+3A_exact">exact</code></td>
<td>
<p>Logical. If TRUE only exact word matches will be proceses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Vector with +-n words of search pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text&lt;-"One hundred twenty-eight students participated in our Study, 
that was administred in thirteen clinics."
ngram(text,pattern="study",ngram=c(-1,2))
</code></pre>

<hr>
<h2 id='pCheck'>pCheck</h2><span id='topic+pCheck'></span>

<h3>Description</h3>

<p>Wrapper function for a standardStats data frame to check extracted and recalculated p-value for consistency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pCheck(stats, alpha = 0.05, criticalDif = 0.02, add = TRUE, warnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pCheck_+3A_stats">stats</code></td>
<td>
<p>Data frame. A data frame object of standard stats that was created by get.stats() or standardStats()</p>
</td></tr>
<tr><td><code id="pCheck_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Set the alpha level of tests.</p>
</td></tr>
<tr><td><code id="pCheck_+3A_criticaldif">criticalDif</code></td>
<td>
<p>Numeric. Defines the absolute threshold of absolute differences in extracted and recalculated p-value to be labeled as inconsistency.</p>
</td></tr>
<tr><td><code id="pCheck_+3A_add">add</code></td>
<td>
<p>Logical. If TRUE the result of Pcheck are added to the input data frame.</p>
</td></tr>
<tr><td><code id="pCheck_+3A_warnings">warnings</code></td>
<td>
<p>Logical. If FALSE warning messages are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with error report on each entry in the result of a standard stats data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Extract and check results from plain text input with get.stats(x,checkP=TRUE)
get.stats("some text with consistent or inconsistent statistical results: 
t(12)=3.4, p&lt;.05 or t(12)=3.4, p&gt;=.05",checkP=TRUE)
## Check standardStats extracted with get.stats(x)$standardStats
pCheck(get.stats("some text with consistent or inconsistent statistical results: 
t(12)=3.4, p&lt;.05 or t(12)=3.4, p&gt;=.05")$standardStats)
</code></pre>

<hr>
<h2 id='preCheck'>preCheck</h2><span id='topic+preCheck'></span>

<h3>Description</h3>

<p>Performs prechecks and returns error messages for wrong input. If x is a textual input, x is returned unprocessed. If x is a file, x is read with readLines() and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preCheck(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preCheck_+3A_x">x</code></td>
<td>
<p>anything</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original input, error messages, empty objects or the read file content with readLines().
</p>

<hr>
<h2 id='standardStats'>standardStats</h2><span id='topic+standardStats'></span>

<h3>Description</h3>

<p>Extracts and restructures statistical standard results like Z, t, Cohen's d, F, eta^2, r, R^2, chi^2, BF_10, Q, U, H, OR, RR, beta values into a matrix. Performs a recomputation of two- and one-sided p-values if possible. This function is implemented in <code><a href="#topic+get.stats">get.stats</a></code> which returns the results of <code><a href="#topic+allStats">allStats</a></code> and <code><a href="#topic+standardStats">standardStats</a></code>. Besides only plain textual input, <code><a href="#topic+get.stats">get.stats</a></code> enables direct processing of different file formats (NISO-JATS coded XML, DOCX, HTML) without text preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardStats(
  x,
  stats.mode = "all",
  recalculate.p = TRUE,
  alternative = "undirected",
  estimateZ = FALSE,
  T2t = FALSE,
  R2r = FALSE,
  select = NULL,
  rm.na.col = TRUE,
  warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardStats_+3A_x">x</code></td>
<td>
<p>result vector by <code><a href="#topic+allStats">allStats</a></code> or chracter vector with a statistical test result per cell, e.g. c(&quot;t(12)=1.2, p&gt;.05&quot;,&quot;chi2(2)=12.7, p&lt;.05&quot;)</p>
</td></tr>
<tr><td><code id="standardStats_+3A_stats.mode">stats.mode</code></td>
<td>
<p>Select subset of standard stats. One of: c(&quot;all&quot;, &quot;checkable&quot;, &quot;computable&quot;, &quot;uncomputable&quot;).</p>
</td></tr>
<tr><td><code id="standardStats_+3A_recalculate.p">recalculate.p</code></td>
<td>
<p>Logical. If TRUE recalculates p values (for 2 sided test) if possible.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_alternative">alternative</code></td>
<td>
<p>Character. Select test sidedness for recomputation of p-values from t-, r- and beta-values. One of c(&quot;undirected&quot;, &quot;directed&quot;). If &quot;directed&quot; is specified, p-values for directed null-hypothesis are added to the table but still require a manual inspection on consistency of the direction.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_estimatez">estimateZ</code></td>
<td>
<p>Logical. If TRUE detected beta-/d-value is divided by reported standard error &quot;SE&quot; to estimate Z-value (&quot;Zest&quot;) for observed beta/d and recompute p-value. Note: This is only valid, if Gauss-Marcov assumptions are met and a sufficiently large sample size is used. If a Z- or t-value is detected in a report of a beta-/d-coefficient with SE, no estimation will be performed, although set to TRUE.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_t2t">T2t</code></td>
<td>
<p>Logical. If TRUE capital letter T is treated as t-statistic.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_r2r">R2r</code></td>
<td>
<p>Logical. If TRUE capital letter R is treated as correlation.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_select">select</code></td>
<td>
<p>Select specific standard statistics only (e.g.: c(&quot;t&quot;, &quot;F&quot;, &quot;Chi2&quot;)).</p>
</td></tr>
<tr><td><code id="standardStats_+3A_rm.na.col">rm.na.col</code></td>
<td>
<p>Logical. If TRUE removes all columns with only NA.</p>
</td></tr>
<tr><td><code id="standardStats_+3A_warnings">warnings</code></td>
<td>
<p>Logical. If FALSE warning messages are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with recognized statistical standard results and recalculated p-values. Empty, if no result is detected.
</p>


<h3>Source</h3>

<p>A minimal web application that extracts statistical results from single documents with <code><a href="#topic+get.stats">get.stats</a></code> is hosted at: <a href="https://www.get-stats.app">https://www.get-stats.app/</a>
</p>
<p>Statistical results extracted with <code><a href="#topic+get.stats">get.stats</a></code> can be analyzed and used to identify articles stored in the PubMed Central library at: <a href="https://www.scianalyzer.com">https://www.scianalyzer.com/</a>.
</p>


<h3>References</h3>

<p>Böschen (2021). &quot;Evaluation of JATSdecoder as an automated text extraction tool for statistical results in scientific reports.” <em>Scientific Reports.</em> doi: <a href="https://www.nature.com/articles/s41598-021-98782-3">10.1038/s41598-021-98782-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+study.character">study.character</a></code> for extracting multiple study characteristics at once.
</p>
<p><code><a href="#topic+get.stats">get.stats</a></code> for extracting statistical results from textual input and different file formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("t(38.8)&lt;=&gt;1.96, p&lt;=&gt;.002","F(2,39)&lt;=&gt;4, p&lt;=&gt;.05",
"U(2)=200, p&gt;.25","Z=2.1, F(20.8,22.6)=200, p&lt;.005, 
BF(01)&gt;4","chi=3.2, r(34)=-.7, p&lt;.01, R2=76%.")
standardStats(x)
</code></pre>

<hr>
<h2 id='strsplit2'>strsplit2</h2><span id='topic+strsplit2'></span>

<h3>Description</h3>

<p>Extension of strsplit(). Makes it possible to split lines before or after a pattern match without removing the pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit2(x, split, type = "remove", perl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplit2_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="strsplit2_+3A_split">split</code></td>
<td>
<p>pattern to split text at.</p>
</td></tr>
<tr><td><code id="strsplit2_+3A_type">type</code></td>
<td>
<p>one out of c(&quot;remove&quot;, &quot;before&quot;, &quot;after&quot;).</p>
</td></tr>
<tr><td><code id="strsplit2_+3A_perl">perl</code></td>
<td>
<p>Logical. If TRUE uses perl expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as x, the i-th element of which contains the vector of splits of x[i].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"This is some text, where text is the split pattern of the text."
strsplit2(x,"text","after")
</code></pre>

<hr>
<h2 id='study.character'>study.character</h2><span id='topic+study.character'></span>

<h3>Description</h3>

<p>Extracts study characteristics out of a NISO-JATS coded XML file. Use <a href="https://github.com/CeON/CERMINE">CERMINE</a> to convert PDF to CERMXML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>study.character(
  x,
  stats.mode = "all",
  recalculate.p = TRUE,
  alternative = "auto",
  estimateZ = FALSE,
  T2t = FALSE,
  R2r = FALSE,
  selectStandardStats = NULL,
  checkP = TRUE,
  criticalDif = 0.02,
  alpha = 0.05,
  p2alpha = TRUE,
  alpha_output = "list",
  captions = TRUE,
  text.mode = 1,
  update.package.list = FALSE,
  add.software = NULL,
  quantileDF = 0.9,
  N.max.only = FALSE,
  output = "all",
  rm.na.col = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="study.character_+3A_x">x</code></td>
<td>
<p>NISO-JATS coded XML file.</p>
</td></tr>
<tr><td><code id="study.character_+3A_stats.mode">stats.mode</code></td>
<td>
<p>Character. Select subset of standard stats. One of: c(&quot;all&quot;, &quot;checkable&quot;, &quot;computable&quot;).</p>
</td></tr>
<tr><td><code id="study.character_+3A_recalculate.p">recalculate.p</code></td>
<td>
<p>Logical. If TRUE recalculates p values (for 2 sided test) if possible.</p>
</td></tr>
<tr><td><code id="study.character_+3A_alternative">alternative</code></td>
<td>
<p>Character. Select sidedness of recomputed p-values for t-, r- and Z-values. One of c(&quot;auto&quot;, &quot;undirected&quot;, &quot;directed&quot;). If set to &quot;auto&quot; 'alternative' will be be set to 'directed' if get.test.direction() detects one-directional hypotheses/tests in text. If no directional hypotheses/tests are dtected only &quot;undirected&quot; recomputed p-values will be returned.</p>
</td></tr>
<tr><td><code id="study.character_+3A_estimatez">estimateZ</code></td>
<td>
<p>Logical. If TRUE detected beta-/d-value is divided by reported standard error &quot;SE&quot; to estimate Z-value (&quot;Zest&quot;) for observed beta/d and recompute p-value. Note: This is only valid, if Gauss-Marcov assumptions are met and a sufficiently large sample size is used. If a Z- or t-value is detected in a report of a beta-/d-coefficient with SE, no estimation will be performed, although set to TRUE.</p>
</td></tr>
<tr><td><code id="study.character_+3A_t2t">T2t</code></td>
<td>
<p>Logical. If TRUE capital letter T is treated as t-statistic when extracting statistics with get.stats().</p>
</td></tr>
<tr><td><code id="study.character_+3A_r2r">R2r</code></td>
<td>
<p>Logical. If TRUE capital letter R is treated as correlation when extracting statistics with get.stats().</p>
</td></tr>
<tr><td><code id="study.character_+3A_selectstandardstats">selectStandardStats</code></td>
<td>
<p>Select specific standard statistics only (e.g.: c(&quot;t&quot;, &quot;F&quot;, &quot;Chi2&quot;)).</p>
</td></tr>
<tr><td><code id="study.character_+3A_checkp">checkP</code></td>
<td>
<p>Logical. If TRUE observed and recalculated p-values are checked for consistency.</p>
</td></tr>
<tr><td><code id="study.character_+3A_criticaldif">criticalDif</code></td>
<td>
<p>Numeric. Sets the absolute maximum difference in reported and recalculated p-values for error detection.</p>
</td></tr>
<tr><td><code id="study.character_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Defines the alpha level to be used for error assignment of detected incosistencies.</p>
</td></tr>
<tr><td><code id="study.character_+3A_p2alpha">p2alpha</code></td>
<td>
<p>Logical. If TRUE detects and extracts alpha errors denoted with critical p-value (what may lead to some false positive detections).</p>
</td></tr>
<tr><td><code id="study.character_+3A_alpha_output">alpha_output</code></td>
<td>
<p>One of c(&quot;list&quot;, &quot;vector&quot;). If alpha_output = &quot;list&quot; a list with elements: alpha_error, corrected_alpha, alpha_from_CI, alpha_max, alpha_min is returned. If alpha_output = &quot;vector&quot; unique alpha errors without a distinction of types is returned.</p>
</td></tr>
<tr><td><code id="study.character_+3A_captions">captions</code></td>
<td>
<p>Logical. If TRUE captions text will be scanned for statistical results.</p>
</td></tr>
<tr><td><code id="study.character_+3A_text.mode">text.mode</code></td>
<td>
<p>Numeric. Defines text parts to extract statistical results from (text.mode=1: abstract and full text, text.mode=2: method and result section, text.mode=3: result section only).</p>
</td></tr>
<tr><td><code id="study.character_+3A_update.package.list">update.package.list</code></td>
<td>
<p>Logical. If TRUE updates available R packages with utils::available.packages() function.</p>
</td></tr>
<tr><td><code id="study.character_+3A_add.software">add.software</code></td>
<td>
<p>additional software names to detect as vector.</p>
</td></tr>
<tr><td><code id="study.character_+3A_quantiledf">quantileDF</code></td>
<td>
<p>quantile of (df1+1)+(df2+1) to extract for estimating sample size.</p>
</td></tr>
<tr><td><code id="study.character_+3A_n.max.only">N.max.only</code></td>
<td>
<p>return only maximum of estimated sample sizes.</p>
</td></tr>
<tr><td><code id="study.character_+3A_output">output</code></td>
<td>
<p>output selection of specific results c(&quot;doi&quot;, &quot;title&quot;, &quot;year&quot;, &quot;Nstudies&quot;, <br />
&quot;methods&quot;, &quot;alpha_error&quot;, &quot;power&quot;, &quot;multi_comparison_correction&quot;, <br />
&quot;assumptions&quot;, &quot;OutlierRemovalInSD&quot;, &quot;InteractionModeratorMediatorEffect&quot;, <br />
&quot;test_direction&quot;, &quot;sig_adjectives&quot;, &quot;software&quot;, &quot;Rpackage&quot;, &quot;stats&quot;, <br />
&quot;standardStats&quot;, &quot;estimated_sample_size&quot;).</p>
</td></tr>
<tr><td><code id="study.character_+3A_rm.na.col">rm.na.col</code></td>
<td>
<p>Logical. If TRUE removes all columns with only NA in extracted standard statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with extracted study characteristics.
</p>


<h3>Note</h3>

<p>A short tutorial on how to work with JATSdecoder and the generated outputs can be found at: <a href="https://github.com/ingmarboeschen/JATSdecoder">https://github.com/ingmarboeschen/JATSdecoder</a>
</p>


<h3>Source</h3>

<p>An interactive web application for selecting and analyzing extracted article metadata and study characteristics for articles linked to PubMed Central is hosted at: <a href="https://www.scianalyzer.com">https://www.scianalyzer.com/</a>
</p>
<p>The XML version of PubMed Central database articles can be downloaded in bulk from: <br /><a href="https://ftp.ncbi.nlm.nih.gov/pub/pmc/oa_bulk/">https://ftp.ncbi.nlm.nih.gov/pub/pmc/oa_bulk/</a>
</p>


<h3>References</h3>

<p>Böschen (2023). &quot;Evaluation of the extraction of methodological study characteristics with JATSdecoder.” <em>Scientific Reports.</em> doi: <a href="https://www.nature.com/articles/s41598-022-27085-y">10.1038/s41598-022-27085-y</a>.
</p>
<p>Böschen (2021). &quot;Evaluation of JATSdecoder as an automated text extraction tool for statistical results in scientific reports.” <em>Scientific Reports.</em> doi: <a href="https://www.nature.com/articles/s41598-021-98782-3">10.1038/s41598-021-98782-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JATSdecoder">JATSdecoder</a></code> for simultaneous extraction of meta-tags, abstract, sectioned text and reference list.
</p>
<p><code><a href="#topic+get.stats">get.stats</a></code> for extracting statistical results from textual input and different file formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># download example XML file via URL
x&lt;-"https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0114876&amp;type=manuscript"
# file name
file&lt;-paste0(tempdir(),"/file.xml")
# download URL as "file.xml" in tempdir() if a connection is possible
tryCatch({
readLines(x,n=1)
download.file(x,file)
},
warning = function(w) message(
  "Something went wrong. Check your internet connection and the link address."),
error = function(e) message(
  "Something went wrong. Check your internet connection and the link address."))
# convert full article to list with study characteristics
if(file.exists(file)) study.character(file)
</code></pre>

<hr>
<h2 id='text2num'>text2num</h2><span id='topic+text2num'></span>

<h3>Description</h3>

<p>Converts special annotated number and written numbers in a text string to a fully digit representation.
Can handle numbers with exponent, fraction, percent, e+num, products and written representation (e.g. 'fourtys-one') of all absolut numbers up to 99,999 (Note: gives wrong output for higher spelled numbers). Process is performed in the same order as its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text2num(
  x,
  exponent = TRUE,
  percentage = TRUE,
  fraction = TRUE,
  e = TRUE,
  product = TRUE,
  words = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text2num_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="text2num_+3A_exponent">exponent</code></td>
<td>
<p>Logical. If TRUE values with exponent are converted to a digit representation.</p>
</td></tr>
<tr><td><code id="text2num_+3A_percentage">percentage</code></td>
<td>
<p>Logical. If TRUE percentages are converted to a digit representation.</p>
</td></tr>
<tr><td><code id="text2num_+3A_fraction">fraction</code></td>
<td>
<p>Logical. If TRUE fractions are converted to a digit representation.</p>
</td></tr>
<tr><td><code id="text2num_+3A_e">e</code></td>
<td>
<p>Logical. If TRUE values denoted with 'number e+number' (e.g. '2e+2') or 
number*10^number are converted to a digit representation.</p>
</td></tr>
<tr><td><code id="text2num_+3A_product">product</code></td>
<td>
<p>Logical. If TRUE values products are converted to a digit representation.</p>
</td></tr>
<tr><td><code id="text2num_+3A_words">words</code></td>
<td>
<p>Logical. If TRUE written numbers are converted to a digit representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. Text with unified digital representation of numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c("numbers with exponent: 2^2, -2.5^2, (-3)^2, 6.25^.5, .2^-2 text.",
     "numbers with percentage: 2%, 15 %, 25 percent.",
     "numbers with fractions: 1/100, -2/5, -7/.1",
     "numbers with e: 10e+2, -20e3, .2E-2, 2e4",
     "numbers as products: 100*2, -20*.1, 2*10^3",
     "written numbers: twenty-two, one hundred fourty five, fifteen percent",
     "mix: one hundred ten is not 1/10 is not 10^2 nor 10%/5")
text2num(x)
</code></pre>

<hr>
<h2 id='text2sentences'>text2sentences</h2><span id='topic+text2sentences'></span>

<h3>Description</h3>

<p>Converts floating text to a vector with sentences via fine-tuned regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text2sentences(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text2sentences_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with sentences compiled from floating text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-"Some text with result (t(18)=1.2, p&lt;.05). This shows how text2sentences works."
text2sentences(x)
</code></pre>

<hr>
<h2 id='vectorize.text'>vectorize.text</h2><span id='topic+vectorize.text'></span>

<h3>Description</h3>

<p>Converts vector of text to a list of vectors with words within each cell. Note: punctuation will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorize.text(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorize.text_+3A_x">x</code></td>
<td>
<p>text string to vectorize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with one word per cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text&lt;-"One hundred twenty-eight students participated in our  
Study, that was administred in thirteen clinics."
vectorize.text(text)
</code></pre>

<hr>
<h2 id='which.term'>which.term</h2><span id='topic+which.term'></span>

<h3>Description</h3>

<p>Returns search element/s from vector that is/are present in text or returns search term hit vector for all terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.term(x, terms, tolower = TRUE, hits_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.term_+3A_x">x</code></td>
<td>
<p>text string to process.</p>
</td></tr>
<tr><td><code id="which.term_+3A_terms">terms</code></td>
<td>
<p>search term vector.</p>
</td></tr>
<tr><td><code id="which.term_+3A_tolower">tolower</code></td>
<td>
<p>Logical. If TRUE converts search terms and text to lower case.</p>
</td></tr>
<tr><td><code id="which.term_+3A_hits_only">hits_only</code></td>
<td>
<p>Logical. If TRUE returns search pattern/s, that were found in text and not a search term hit vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binary hit vector with search term named elements if hits_only=FALSE.
</p>
<p>Character vector with identified search term elements if hits_only=TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text&lt;-c("This demo demonstrates how which.term works.",
       "The result is a simple 0, 1 coded vector for all search patterns or 
        a vector including the identified patterns only.")
which.term(text,c("Demo","example","work"))
which.term(text,c("Demo","example","work"),tolower=TRUE,hits_only=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
