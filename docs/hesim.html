<!DOCTYPE html><html><head><title>Help for package hesim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hesim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absorbing'><p>Absorbing states</p></a></li>
<li><a href='#apply_rr'><p>Apply relative risks to transition probability matrices</p></a></li>
<li><a href='#as_array3'><p>Convert between 2D tabular objects and 3D arrays</p></a></li>
<li><a href='#as_pfs_os'><p>Convert multi-state data to PFS and OS data</p></a></li>
<li><a href='#as.data.table.tparams_transprobs'><p>Coerce to <code>data.table</code></p></a></li>
<li><a href='#autoplot.stateprobs'><p>Plot state probabilities</p></a></li>
<li><a href='#autoplot.survival'><p>Plot survival curves</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap a statistical model</p></a></li>
<li><a href='#ce'><p>A cost-effectiveness object</p></a></li>
<li><a href='#cea'><p>Cost-effectiveness analysis</p></a></li>
<li><a href='#check_input_data'><p>Check input data argument for <code>create_input_mats</code></p></a></li>
<li><a href='#check.id_attributes'><p>Input validation for class objects</p></a></li>
<li><a href='#CohortDtstm'><p>Cohort discrete time state transition model</p></a></li>
<li><a href='#CohortDtstmTrans'><p>Transitions for a cohort discrete time state transition model</p></a></li>
<li><a href='#costs'><p>Costs object</p></a></li>
<li><a href='#create_CohortDtstm'><p>Create <code>CohortDtstm</code> object</p></a></li>
<li><a href='#create_CohortDtstmTrans'><p>Create <code>CohortDtstmTrans</code> object</p></a></li>
<li><a href='#create_IndivCtstmTrans'><p>Create <code>IndivCtstmTrans</code> object</p></a></li>
<li><a href='#create_input_mats'><p>Create input matrices</p></a></li>
<li><a href='#create_input_mats.formula_list'><p>Create input matrices from formula</p></a></li>
<li><a href='#create_lines_dt'><p>Create a data table of treatment lines</p></a></li>
<li><a href='#create_object_list'><p>Form a list from <code>...</code></p></a></li>
<li><a href='#create_params'><p>Create a parameter object from a fitted model</p></a></li>
<li><a href='#create_PsmCurves'><p>Create <code>PsmCurves</code> object</p></a></li>
<li><a href='#create_StateVals'><p>Create a <code>StateVals</code> object</p></a></li>
<li><a href='#create_trans_dt'><p>Create a data table of health state transitions</p></a></li>
<li><a href='#CtstmTrans'><p>An <code>R6</code> base class for continuous time state transition models</p></a></li>
<li><a href='#define_model'><p>Define and evaluate model expression</p></a></li>
<li><a href='#define_rng'><p>Define and evaluate random number generation expressions</p></a></li>
<li><a href='#define_tparams'><p>Define and evaluate transformed parameter expressions</p></a></li>
<li><a href='#disprog'><p>Disease progression object</p></a></li>
<li><a href='#expand'><p>Expand object</p></a></li>
<li><a href='#expand.hesim_data'><p>Expand hesim_data</p></a></li>
<li><a href='#expmat'><p>Matrix exponential</p></a></li>
<li><a href='#fast_rgengamma'><p>Random generation for generalized gamma distribution</p></a></li>
<li><a href='#flexsurvreg_list'><p>List of <code>flexsurvreg</code> objects</p></a></li>
<li><a href='#formula_list'><p>List of <code>formula</code> objects</p></a></li>
<li><a href='#get_labels'><p>Get value labels</p></a></li>
<li><a href='#hesim'><p>hesim: Health Economic Simulation Modeling and Decision Analysis</p></a></li>
<li><a href='#hesim_data'><p>Data for health economic simulation modeling</p></a></li>
<li><a href='#hesim_survdists'><p>List of survival distributions</p></a></li>
<li><a href='#icea'><p>Individualized cost-effectiveness analysis</p></a></li>
<li><a href='#icer'><p>Incremental cost-effectiveness ratio</p></a></li>
<li><a href='#icer_tbl'><p>ICER table</p></a></li>
<li><a href='#id_attributes'><p>Attributes for ID variables</p></a></li>
<li><a href='#incr_effect'><p>Incremental treatment effect</p></a></li>
<li><a href='#IndivCtstm'><p>Individual-level continuous time state transition model</p></a></li>
<li><a href='#IndivCtstmTrans'><p>Transitions for an individual-level continuous time state transition model</p></a></li>
<li><a href='#input_mats'><p>Input matrices for a statistical model</p></a></li>
<li><a href='#lm_list'><p>List of <code>lm</code> objects</p></a></li>
<li><a href='#mom_beta'><p>Method of moments for beta distribution</p></a></li>
<li><a href='#mom_gamma'><p>Method of moments for gamma distribution</p></a></li>
<li><a href='#mstate3_exdata'><p>Example data for a reversible 3-state multi-state model</p></a></li>
<li><a href='#multinom_list'><p>List of <code>multinom</code> objects</p></a></li>
<li><a href='#multinom3_exdata'><p>Example data for a 3-state multinomial model</p></a></li>
<li><a href='#normboot'><p>Draw parameters of statistical model from multivariate normal distribution</p></a></li>
<li><a href='#onc3'><p>Multi-state oncology data for 3-state model</p></a></li>
<li><a href='#onc3p'><p>Multi-state panel oncology data for 3-state model</p></a></li>
<li><a href='#params'><p>Parameter object</p></a></li>
<li><a href='#params_lm'><p>Parameters of a linear model</p></a></li>
<li><a href='#params_mlogit'><p>Parameters of a multinomial logit model</p></a></li>
<li><a href='#params_mlogit_list'><p>Parameters of a list of multinomial logit models</p></a></li>
<li><a href='#params_surv'><p>Parameters of a survival model</p></a></li>
<li><a href='#params_surv_list'><p>Parameters of a list of survival models</p></a></li>
<li><a href='#partsurvfit'><p>Partitioned survival regression object</p></a></li>
<li><a href='#plot_ceac'><p>Plot cost-effectiveness acceptability curve</p></a></li>
<li><a href='#plot_ceaf'><p>Plot cost-effectiveness acceptability frontier</p></a></li>
<li><a href='#plot_ceplane'><p>Plot cost-effectiveness plane</p></a></li>
<li><a href='#plot_evpi'><p>Plot expected value of perfect information</p></a></li>
<li><a href='#Psm'><p>N-state partitioned survival model</p></a></li>
<li><a href='#psm4_exdata'><p>Example data for a 4-state partitioned survival model</p></a></li>
<li><a href='#PsmCurves'><p>Partitioned survival curves</p></a></li>
<li><a href='#qalys'><p>Quality-adjusted life-years object</p></a></li>
<li><a href='#qmatrix'><p>Transition intensity matrix</p></a></li>
<li><a href='#qmatrix.matrix'><p>Transition intensity matrix from tabular object</p></a></li>
<li><a href='#qmatrix.msm'><p>Transition intensity matrix from <code>msm</code> object</p></a></li>
<li><a href='#rcat'><p>Random generation for categorical distribution</p></a></li>
<li><a href='#rdirichlet_mat'><p>Random generation for multiple Dirichlet distributions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rng_distributions'><p>Random number generation distributions</p></a></li>
<li><a href='#rpwexp'><p>Random generation for piecewise exponential distribution</p></a></li>
<li><a href='#set_labels'><p>Set value labels</p></a></li>
<li><a href='#sim_ev'><p>Expected values from state probabilities</p></a></li>
<li><a href='#sim_stateprobs'><p>Simulated state probabilities</p></a></li>
<li><a href='#sim_stateprobs.survival'><p>Simulate state probabilities from survival curves</p></a></li>
<li><a href='#stateprobs'><p>State probability object</p></a></li>
<li><a href='#stateval_tbl'><p>Table to store state value parameters</p></a></li>
<li><a href='#StateVals'><p>Model for state values</p></a></li>
<li><a href='#summarize_ce'><p>Summarize costs and effectiveness</p></a></li>
<li><a href='#summary.ce'><p>Summary method for cost-effectiveness object</p></a></li>
<li><a href='#summary.eval_rng'><p>Summarize <code>eval_rng</code> object</p></a></li>
<li><a href='#summary.params'><p>Summarize parameter objects</p></a></li>
<li><a href='#summary.tparams_mean'><p>Summarize <code>tparams_mean</code> object</p></a></li>
<li><a href='#summary.tparams_transprobs'><p>Summarize <code>tparams_transprobs</code> object</p></a></li>
<li><a href='#summary.tpmatrix'><p>Summarize transition probability matrix</p></a></li>
<li><a href='#surv_quantile'><p>Survival quantiles</p></a></li>
<li><a href='#survival'><p>Survival object</p></a></li>
<li><a href='#time_intervals'><p>Time intervals</p></a></li>
<li><a href='#tparams'><p>Transformed parameter object</p></a></li>
<li><a href='#tparams_mean'><p>Predicted means</p></a></li>
<li><a href='#tparams_transprobs'><p>Transition probabilities</p></a></li>
<li><a href='#tpmatrix'><p>Transition probability matrix</p></a></li>
<li><a href='#tpmatrix_id'><p>Transition probability matrix IDs</p></a></li>
<li><a href='#tpmatrix_names'><p>Names for elements of a transition probability matrix</p></a></li>
<li><a href='#uv_rng'><p>Generate variates for univariate distributions</p></a></li>
<li><a href='#weibullNMA'><p>Parameterization of the Weibull distribution for network meta-analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Health Economic Simulation Modeling and Decision Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A modular and computationally efficient R package for  
  parameterizing, simulating, and analyzing health economic simulation 
  models. The package supports cohort discrete time state transition models 
  (Briggs et al. 1998) &lt;<a href="https://doi.org/10.2165%2F00019053-199813040-00003">doi:10.2165/00019053-199813040-00003</a>&gt;,
  N-state partitioned survival models (Glasziou et al. 1990)
  &lt;<a href="https://doi.org/10.1002%2Fsim.4780091106">doi:10.1002/sim.4780091106</a>&gt;, and individual-level continuous 
  time state transition models (Siebert et al. 2012) &lt;<a href="https://doi.org/10.1016%2Fj.jval.2012.06.014">doi:10.1016/j.jval.2012.06.014</a>&gt;,
  encompassing both Markov (time-homogeneous and time-inhomogeneous) and 
  semi-Markov processes. Decision uncertainty from a cost-effectiveness analysis is 
  quantified with standard graphical and tabular summaries of a probabilistic 
  sensitivity analysis (Claxton et al. 2005, Barton et al. 2008) &lt;<a href="https://doi.org/10.1002%2Fhec.985">doi:10.1002/hec.985</a>&gt;, 
  &lt;<a href="https://doi.org/10.1111%2Fj.1524-4733.2008.00358.x">doi:10.1111/j.1524-4733.2008.00358.x</a>&gt;. Use of C++ and data.table
  make individual-patient simulation, probabilistic sensitivity analysis, 
  and incorporation of patient heterogeneity fast.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hesim-dev.github.io/hesim/">https://hesim-dev.github.io/hesim/</a>,
<a href="https://github.com/hesim-dev/hesim">https://github.com/hesim-dev/hesim</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hesim-dev/hesim/issues">https://github.com/hesim-dev/hesim/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, flexsurv, ggplot2, MASS, msm, Rcpp (&ge; 0.12.16),
R6, stats, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, kableExtra, knitr, magrittr, mstate, nnet, numDeriv,
pracma, rmarkdown, scales, testthat, truncnorm</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 00:02:59 UTC; devin</td>
</tr>
<tr>
<td>Author:</td>
<td>Devin Incerti [aut, cre],
  Jeroen P. Jansen [aut],
  Mark Clements [aut],
  R Core Team [ctb] (hesim uses some slightly modified C functions from
    base R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Devin Incerti &lt;devin.incerti@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 01:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='absorbing'>Absorbing states</h2><span id='topic+absorbing'></span><span id='topic+absorbing.matrix'></span><span id='topic+absorbing.tparams_transprobs'></span>

<h3>Description</h3>

<p>This is a generic function that returns a vector of absorbing states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorbing(x, ...)

## S3 method for class 'matrix'
absorbing(x, ...)

## S3 method for class 'tparams_transprobs'
absorbing(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorbing_+3A_x">x</code></td>
<td>
<p>An object of the appropriate class. When <code>x</code> is a <code>matrix</code>,
it must be a transition matrix in the format from the
<code><a href="mstate.html#topic+mstate-package">mstate</a></code> package (see also <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>).</p>
</td></tr>
</table>

<hr>
<h2 id='apply_rr'>Apply relative risks to transition probability matrices</h2><span id='topic+apply_rr'></span>

<h3>Description</h3>

<p>Elements of transition probability matrices are multiplied by relative risks
and the transition probability matrices are adjusted so that rows sum to 1.
Operations are vectorized and each relative risk is multiplied by every
transition matrix (stored in 3-dimensional arrays).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_rr(x, rr, index, complement = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_rr_+3A_x">x</code></td>
<td>
<p>A 3-dimensional array where each slice is a square transition
probability matrix.</p>
</td></tr>
<tr><td><code id="apply_rr_+3A_rr">rr</code></td>
<td>
<p>A 2-dimensional tabular object such as a matrix or data frame where each
column is a vector of relative risks to apply to each transition matrix in <code>x</code>.</p>
</td></tr>
<tr><td><code id="apply_rr_+3A_index">index</code></td>
<td>
<p>The indices of the transition probability matrices that <code>rr</code>  is applied to.
Should either be a matrix where the first column denotes a transition probability matrix row
and the second column denotes a transition probability matrix column or a list
where each element is a vector of length 2 with the first element denoting
a transition probability matrix row and the second column denoting a transition
probability matrix column.</p>
</td></tr>
<tr><td><code id="apply_rr_+3A_complement">complement</code></td>
<td>
<p>Denotes indices of transition probability matrices that are
&quot;complements&quot; (i.e.,  computed as <code class="reqn">1</code> less the sum of all other
elements in that row). Should be in the same format as <code>index</code>. There can be
at most one complementary column in each row of a transition probability
matrix. If <code>NULL</code>, then the diagonals are assumed to be the complements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for applying relative treatment effects measured
using relative risks to an existing transition probability matrix. For example,
a transition probability matrix for the reference treatment strategy may exist or
have been estimated from the data. Relative risks estimated from a meta-analysis
or network meta-analysis can then be applied to the reference transition probability
matrix. If the number of rows in <code>rr</code> exceeds <code>x</code>, then the arrays in <code>x</code> are
recycled to the number of rows in <code>rr</code>, which facilitates the application of
relative risks from multiple treatment strategies to a reference treatment.
</p>


<h3>Value</h3>

<p>A 3-dimensional array where each slice contains matrices of the same
dimension as each matrix in <code>x</code> and the number of slices is equal to the number
of rows in <code>rr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_12 &lt;- c(.7, .5)
p_23 &lt;- c(.1, .2)
x &lt;- as_array3(tpmatrix(
  C, p_12, .1,
  0, C,     p_23,
  0, 0,     1
))

# There are the same number of relative risk rows and transition probability matrices
rr_12 &lt;- runif(2, .8, 1)
rr_13 &lt;- runif(2, .9, 1)
rr &lt;- cbind(rr_12, rr_13)
apply_rr(x, rr, 
         index = list(c(1, 2), c(1, 3)),
         complement = list(c(1, 1), c(2, 2)))
         
# There are more relative risk rows than transition probability matrices
rr_12 &lt;- runif(4, .8, 1)
rr_13 &lt;- runif(4, .9, 1)
rr &lt;- cbind(rr_12, rr_13)
apply_rr(x, rr, 
         index = list(c(1, 2), c(1, 3)),
         complement = list(c(1, 1), c(2, 2)))
</code></pre>

<hr>
<h2 id='as_array3'>Convert between 2D tabular objects and 3D arrays</h2><span id='topic+as_array3'></span><span id='topic+as_tbl2'></span>

<h3>Description</h3>

<p>Convert a 2-dimensional tabular object where each row stores a flattened
square matrix to a 3-dimensional array of square matrices and vice versa.
This allows multiple transition matrices to be stored as either tabular objects
(e.g., matrices, data frames, etc) or as arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_array3(x)

as_tbl2(
  x,
  output = c("data.table", "data.frame", "matrix", "tpmatrix"),
  prefix = "",
  sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_array3_+3A_x">x</code></td>
<td>
<p>For <code>as_array3()</code> a 2-dimensional tabular object where each row stores a flattened
square matrix ordered rowwise. Reasonable classes are <code>matrix</code>, <code>data.frame</code>,
<code>data.table</code>, and <code>tpmatrix</code>. For <code>as_tbl2()</code> a 3-dimensional array
where each slice is a square matrix.</p>
</td></tr>
<tr><td><code id="as_array3_+3A_output">output</code></td>
<td>
<p>The class of the object returned by the function. Either
a <code>data.table</code>, <code>data.frame</code>, <code>matrix</code>, or <code><a href="#topic+tpmatrix">tpmatrix</a></code>.</p>
</td></tr>
<tr><td><code id="as_array3_+3A_prefix">prefix</code>, <code id="as_array3_+3A_sep">sep</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+tpmatrix_names">tpmatrix_names()</a></code> for naming
the transition probability columns. The <code>states</code> argument is based on
the column names (i.e., names of the second dimension) of array;
if <code>NULL</code>, then states are named <code>s1</code>, ..., <code>sh</code> where h is
the number of states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>as_array3()</code> a 3-dimensional array of square matrices;
for <code>as_tbl2()</code> a 2-dimensional tabular object as specified by <code>output</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpmatrix">tpmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_12 &lt;- c(.7, .6)
pmat &lt;- tpmatrix(
 C, p_12,
 0, 1
)
pmat

as_array3(pmat)
as_array3(as.matrix(pmat))
as_tbl2(as_array3(pmat))
as_tbl2(as_array3(pmat), prefix = "p_", sep = ".")
</code></pre>

<hr>
<h2 id='as_pfs_os'>Convert multi-state data to PFS and OS data</h2><span id='topic+as_pfs_os'></span>

<h3>Description</h3>

<p>Convert a multi-state dataset with irreversible transitions containing 3 health
states to a dataset with one row per patient and progression-free survival (PFS)
and overall survival (OS) time-to-event outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_pfs_os(
  data,
  patient_vars,
  status = "status",
  time_stop = "time_stop",
  transition = "transition_id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_pfs_os_+3A_data">data</code></td>
<td>
<p>A multi-state dataset.</p>
</td></tr>
<tr><td><code id="as_pfs_os_+3A_patient_vars">patient_vars</code></td>
<td>
<p>Character vector of the names of patient specific variables.</p>
</td></tr>
<tr><td><code id="as_pfs_os_+3A_status">status</code></td>
<td>
<p>Character string with the name of the status variable (1 = event,
0 = censored).</p>
</td></tr>
<tr><td><code id="as_pfs_os_+3A_time_stop">time_stop</code></td>
<td>
<p>Character string with the name of the stopping time variable
(i.e., time patient transitions from state <code class="reqn">r</code> to state <code class="reqn">s</code>).</p>
</td></tr>
<tr><td><code id="as_pfs_os_+3A_transition">transition</code></td>
<td>
<p>Character string with the name of the variable identifying
a transition. The transition variable should be integer valued with values
1, 2, and 3 for the Stable -&gt; Progression, Stable -&gt; Death, and
Progression -&gt; Death transitions, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with one row per patient containing each variable in
<code>patient_vars</code>  as well as a time variable and status indicator for both
PFS (<code>pfs_status</code>, <code>pfs_time</code>) and OS (<code>os_time</code>, <code>os_status</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_pfs_os(onc3, patient_vars = c("patient_id", "strategy_name", "female", "age")) 

</code></pre>

<hr>
<h2 id='as.data.table.tparams_transprobs'>Coerce to <code>data.table</code></h2><span id='topic+as.data.table.tparams_transprobs'></span>

<h3>Description</h3>

<p>Creates a <code>data.table</code> that combines the transition probability matrices
and ID variables from a <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object. This is often useful for
debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tparams_transprobs'
as.data.table(x, ..., prefix = "prob_", sep = "_", long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.tparams_transprobs_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.table.tparams_transprobs_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="as.data.table.tparams_transprobs_+3A_prefix">prefix</code>, <code id="as.data.table.tparams_transprobs_+3A_sep">sep</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+tpmatrix_names">tpmatrix_names()</a></code> for naming
the transition probability columns. The <code>states</code> argument is based on
the column names (i.e., names of the second dimension) of the <code style="white-space: pre;">&#8288;$value&#8288;</code>
element of <code>x</code>; if <code>NULL</code>, then states are named <code>s1</code>, ..., <code>sh</code> where h is
the number of states. Only used if <code>long = FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.table.tparams_transprobs_+3A_long">long</code></td>
<td>
<p>If <code>TRUE</code>, then output is returned in a longer format with
one row for each transition; if <code>FALSE</code>, then each row contains an entire
flattened transition probability matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output always contains columns for the ID variables and the
transition probabilities, but the form depends on on the <code>long</code> argument.
If <code>FALSE</code>, then a <code>data.table</code> with one row for each transition probability
matrix is returned; otherwise, the <code>data.table</code> contains one row for each
transition and columns <code>from</code> (the state being transitioned from) and
<code>to</code> (the state being transitioned to) are added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tparams_transprobs">tparams_transprobs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create tparams_transprobs object
hesim_dat &lt;- hesim_data(strategies = data.frame(strategy_id = 1:2),
                        patients = data.frame(patient_id = 1:3))
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))    
tpmat_id &lt;- tpmatrix_id(input_data, n_samples = 2)      
p_12 &lt;- runif(nrow(tpmat_id), .6, .7) + 
  .05 * (tpmat_id$strategy_id == 2)
tpmat &lt;- tpmatrix(
  C, p_12,
  0, 1
)
tprobs &lt;- tparams_transprobs(tpmat, tpmat_id)

# Convert to data.table in "wide" format
as.data.table(tprobs)
as.data.table(tprobs, prefix = "")
as.data.table(tprobs, prefix = "", sep = ".")

# Convert to data.table in "long: format
as.data.table(tprobs, long = TRUE)

</code></pre>

<hr>
<h2 id='autoplot.stateprobs'>Plot state probabilities</h2><span id='topic+autoplot.stateprobs'></span>

<h3>Description</h3>

<p>Quickly plot state probabilities stored in a <code><a href="#topic+stateprobs">stateprobs</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stateprobs'
autoplot(
  object,
  labels = NULL,
  ci = FALSE,
  prob = 0.95,
  ci_style = c("ribbon", "line"),
  geom_alpha = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.stateprobs_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+stateprobs">stateprobs</a></code> object.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_ci">ci</code></td>
<td>
<p>A logical value indicating whether confidence intervals should be
plotted. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval <code style="white-space: pre;">&#8288;(0,1)&#8288;</code> giving the confidence interval.
Default is 0.95 for a 95 percent interval.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_ci_style">ci_style</code></td>
<td>
<p>Style to use for the confidence interval if <code>ci = TRUE</code>. If
<code>"line"</code>, then dashed lines are used; if <code>"ribbon"</code>, then shaded confidence
bands are plotted using <code>ggplot2::geom_ribbon()</code>.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_geom_alpha">geom_alpha</code></td>
<td>
<p>The opacity for the shaded confidence bands when
<code>ci_style = "ribbon"</code>. This is the value of the value of the <code>alpha</code> aesthetic
passed to <code>ggplot2::geom_ribbon()</code>.</p>
</td></tr>
<tr><td><code id="autoplot.stateprobs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>If there are multiple patients/groups, then state probabilities are
averaged across patients/groups (using the weights in <code>patient_wt</code> if available)
prior to plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Psm">Psm</a></code> for an example.
</p>

<hr>
<h2 id='autoplot.survival'>Plot survival curves</h2><span id='topic+autoplot.survival'></span>

<h3>Description</h3>

<p>Quickly plot survival curves stored in a <code><a href="#topic+survival">survival</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survival'
autoplot(
  object,
  labels = NULL,
  ci = FALSE,
  prob = 0.95,
  ci_style = c("ribbon", "line"),
  geom_alpha = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.survival_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+survival">survival</a></code> object.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_ci">ci</code></td>
<td>
<p>A logical value indicating whether confidence intervals should be
plotted. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval <code style="white-space: pre;">&#8288;(0,1)&#8288;</code> giving the confidence interval.
Default is 0.95 for a 95 percent interval.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_ci_style">ci_style</code></td>
<td>
<p>Style to use for the confidence interval if <code>ci = TRUE</code>. If
<code>"line"</code>, then dashed lines are used; if <code>"ribbon"</code>, then shaded confidence
bands are plotted using <code>ggplot2::geom_ribbon()</code>.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_geom_alpha">geom_alpha</code></td>
<td>
<p>The opacity for the shaded confidence bands when
<code>ci_style = "ribbon"</code>. This is the value of the value of the <code>alpha</code> aesthetic
passed to <code>ggplot2::geom_ribbon()</code>.</p>
</td></tr>
<tr><td><code id="autoplot.survival_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Note</h3>

<p>If there are multiple patients, then survival probabilities are
averaged across patients (using the weights in <code>patient_wt</code> if available)
prior to plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Psm">Psm</a></code> for an example.
</p>

<hr>
<h2 id='bootstrap'>Bootstrap a statistical model</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap.partsurvfit'></span>

<h3>Description</h3>

<p><code>bootstrap</code> is a generic function for generating bootstrap replicates of the parameters
of a fitted statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(object, B, ...)

## S3 method for class 'partsurvfit'
bootstrap(object, B, max_errors = 0, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_max_errors">max_errors</code></td>
<td>
<p>Maximum number of errors that are allowed when fitting statistical models
during the bootstrap procedure. This argument may be useful if, for instance, the model
fails to converge during some bootstrap replications. Default is 0.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_silent">silent</code></td>
<td>
<p>Logical indicating whether error messages should be suppressed. Passed to
the <code>silent</code> argument of <code><a href="base.html#topic+try">try()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled values of the parameters.
</p>

<hr>
<h2 id='ce'>A cost-effectiveness object</h2><span id='topic+ce'></span>

<h3>Description</h3>

<p>An object that summarizes simulated measures of clinical effectiveness and
costs from a simulation model for use in a cost-effectiveness analysis.
</p>


<h3>Format</h3>

<p>A list containing two elements:
</p>

<dl>
<dt><code>costs</code></dt><dd><p>Total (discounted) costs by category.</p>
</dd>
<dt><code>qalys</code></dt><dd><p>(Discounted) quality-adjusted life-years.</p>
</dd>
</dl>



<h3>Costs</h3>

<p>The <code>costs</code> <code>data.table</code> contains the following columns:
</p>

<dl>
<dt>category</dt><dd><p>The cost category.</p>
</dd>
<dt>dr</dt><dd><p>The discount rate.</p>
</dd>
<dt>sample</dt><dd><p>A randomly sampled parameter set from the probabilistic sensitivity analysis (PSA)</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>grp_id</dt><dd><p>An optional column denoting a subgroup. If not included, it is
assumed that a single subgroup is being analyzed.</p>
</dd>
<dt>costs</dt><dd><p>Costs.</p>
</dd>
</dl>



<h3>Quality-adjusted life-years</h3>

<p>The <code>qalys</code> <code>data.table</code> contains the following columns:
</p>

<dl>
<dt>dr</dt><dd><p>The discount rate.</p>
</dd>
<dt>sample</dt><dd><p>A randomly sampled parameter set from the probabilistic sensitivity analysis (PSA)</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>grp_id</dt><dd><p>An optional column denoting a subgroup. If not included, it is
assumed that a single subgroup is being analyzed.</p>
</dd>
<dt>qalys</dt><dd><p>Quality-adjusted life-years</p>
</dd>
</dl>


<hr>
<h2 id='cea'>Cost-effectiveness analysis</h2><span id='topic+cea'></span><span id='topic+cea_pw'></span><span id='topic+cea.default'></span><span id='topic+cea_pw.default'></span><span id='topic+cea.ce'></span><span id='topic+cea_pw.ce'></span>

<h3>Description</h3>

<p>Conduct cost-effectiveness analysis (CEA) given output of an economic
model; that is, summarize a probabilistic sensitivity analysis (PSA), possibly
by subgroup.
</p>

<ul>
<li> <p><code><a href="#topic+cea">cea()</a></code> computes the probability that
each treatment is most cost-effective, output for a cost-effectiveness acceptability frontier,
the expected value of perfect information, and the net monetary benefit for each treatment.
</p>
</li>
<li> <p><code><a href="#topic+cea_pw">cea_pw()</a></code> conducts pairwise CEA by comparing strategies to a comparator. Computed
quantities include the incremental cost-effectiveness ratio, the
incremental net monetary benefit, output for a cost-effectiveness plane,
and output for a cost-effectiveness acceptability curve.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cea(x, ...)

cea_pw(x, ...)

## Default S3 method:
cea(x, k = seq(0, 2e+05, 500), sample, strategy, grp = NULL, e, c, ...)

## Default S3 method:
cea_pw(
  x,
  k = seq(0, 2e+05, 500),
  comparator,
  sample,
  strategy,
  grp = NULL,
  e,
  c,
  ...
)

## S3 method for class 'ce'
cea(x, k = seq(0, 2e+05, 500), dr_qalys, dr_costs, ...)

## S3 method for class 'ce'
cea_pw(x, k = seq(0, 2e+05, 500), comparator, dr_qalys, dr_costs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cea_+3A_x">x</code></td>
<td>
<p>An object of simulation output characterizing the probability distribution
of clinical effectiveness and costs. If the default method is used, then <code>x</code>
must be a <code>data.frame</code> or <code>data.table</code> containing columns of
mean costs and clinical effectiveness where each row denotes a randomly sampled parameter set
and treatment strategy.</p>
</td></tr>
<tr><td><code id="cea_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
<tr><td><code id="cea_+3A_k">k</code></td>
<td>
<p>Vector of willingness to pay values.</p>
</td></tr>
<tr><td><code id="cea_+3A_sample">sample</code></td>
<td>
<p>Character name of column from <code>x</code> denoting a randomly sampled parameter set.</p>
</td></tr>
<tr><td><code id="cea_+3A_strategy">strategy</code></td>
<td>
<p>Character name of column from <code>x</code> denoting treatment strategy.</p>
</td></tr>
<tr><td><code id="cea_+3A_grp">grp</code></td>
<td>
<p>Character name of column from <code>x</code> denoting subgroup. If <code>NULL</code>, then
it is assumed that there is only one group.</p>
</td></tr>
<tr><td><code id="cea_+3A_e">e</code></td>
<td>
<p>Character name of column from <code>x</code> denoting clinical effectiveness.</p>
</td></tr>
<tr><td><code id="cea_+3A_c">c</code></td>
<td>
<p>Character name of column from <code>x</code> denoting costs.</p>
</td></tr>
<tr><td><code id="cea_+3A_comparator">comparator</code></td>
<td>
<p>Name of the comparator strategy in <code>x</code>.</p>
</td></tr>
<tr><td><code id="cea_+3A_dr_qalys">dr_qalys</code></td>
<td>
<p>Discount rate for quality-adjusted life-years (QALYs).</p>
</td></tr>
<tr><td><code id="cea_+3A_dr_costs">dr_costs</code></td>
<td>
<p>Discount rate for costs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+cea">cea()</a></code> returns a list of four <code>data.table</code> elements.
</p>

<dl>
<dt>summary</dt><dd><p>A <code>data.table</code> of the mean, 2.5% quantile, and 97.5%
quantile by strategy and group for clinical effectiveness and costs.</p>
</dd>
<dt>mce</dt><dd><p>The probability that each strategy is the most effective treatment
for each group for the range of specified willingness to pay values. In addition,
the column <code>best</code> denotes the optimal strategy (i.e., the strategy with the
highest expected net monetary benefit), which can be used to plot the
cost-effectiveness acceptability frontier (CEAF).</p>
</dd>
<dt>evpi</dt><dd><p>The expected value of perfect information (EVPI) by group for the range
of specified willingness to pay values. The EVPI is computed by subtracting the expected net
monetary benefit given current information (i.e., the strategy with the highest
expected net monetary benefit) from the expected net monetary benefit given
perfect information.</p>
</dd>
<dt>nmb</dt><dd><p>The mean, 2.5% quantile, and 97.5% quantile of net monetary benefits
for the range of specified willingness to pay values.</p>
</dd>
</dl>

<p><code>cea_pw</code> also returns a list of four <code>data.table</code> elements:
</p>

<dl>
<dt>summary</dt><dd><p>A data.table of the mean, 2.5% quantile, and 97.5%
quantile by strategy and group for incremental clinical effectiveness and costs.</p>
</dd>
<dt>delta</dt><dd><p>Incremental effectiveness and incremental cost for each simulated
parameter set by strategy and group. Can be used to plot a cost-effectiveness plane. </p>
</dd>
<dt>ceac</dt><dd><p>Values needed to plot a cost-effectiveness acceptability curve by
group. The CEAC plots the probability that each strategy is more cost-effective than
the comparator for the specified willingness to pay values.</p>
</dd>
<dt>inmb</dt><dd><p>The mean, 2.5% quantile, and 97.5% quantile of
incremental net monetary benefits for the range of specified willingness to pay values.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
library("ggplot2")
theme_set(theme_bw())

# Simulation output
n_samples &lt;- 30

sim &lt;- data.table(sample = rep(seq(n_samples), 4),
                  c = c(rlnorm(n_samples, 5, .1), rlnorm(n_samples, 5, .1),
                        rlnorm(n_samples, 11, .1), rlnorm(n_samples, 11, .1)),
                  e = c(rnorm(n_samples, 8, .2), rnorm(n_samples, 8.5, .1),
                        rnorm(n_samples, 11, .6), rnorm(n_samples, 11.5, .6)),
                  strategy_id = rep(1:2, each = n_samples * 2),
                  grp_id = rep(rep(1:2, each = n_samples), 2)
)

# Cost-effectiveness analysis
cea_out &lt;- cea(sim, k = seq(0, 200000, 500), sample = "sample", 
               strategy = "strategy_id", grp = "grp_id", 
               e = "e", c = "c")
names(cea_out)

## Some sample output
## The probability that each strategy is the most cost-effective 
## in each group with a willingness to pay of 20,000
cea_out$mce[k == 20000]

# Pairwise cost-effectiveness analysis
cea_pw_out &lt;-  cea_pw(sim,  k = seq(0, 200000, 500), comparator = 1,
                      sample = "sample", strategy = "strategy_id", 
                      grp = "grp_id", e = "e", c = "c")
names(cea_pw_out)

## Some sample output
## The cost-effectiveness acceptability curve
head(cea_pw_out$ceac[k &gt;= 20000])

# Summarize the incremental cost-effectiveness ratio
labs &lt;- list(strategy_id = c("Strategy 1" = 1, "Strategy 2" = 2),
             grp_id = c("Group 1" = 1, "Group 2" = 2))
format(icer(cea_pw_out, labels = labs))

# Plots
plot_ceplane(cea_pw_out, label = labs)
plot_ceac(cea_out, label = labs)
plot_ceac(cea_pw_out, label = labs)
plot_ceaf(cea_out, label = labs)
plot_evpi(cea_out, label = labs)
</code></pre>

<hr>
<h2 id='check_input_data'>Check input data argument for <code>create_input_mats</code></h2><span id='topic+check_input_data'></span>

<h3>Description</h3>

<p>Check that input data argument for <code>create_input_mats</code> exists and that it is
of the correct type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_input_data(input_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_input_data_+3A_input_data">input_data</code></td>
<td>
<p>An object of class &quot;expanded_hesim_data&quot; returned by the function
<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all tests passed, returns nothing; otherwise, throws an exception.
</p>

<hr>
<h2 id='check.id_attributes'>Input validation for class objects</h2><span id='topic+check.id_attributes'></span><span id='topic+check.input_mats'></span><span id='topic+check.params_lm'></span><span id='topic+check.params_mlogit'></span><span id='topic+check.params_surv'></span><span id='topic+check.params_surv_list'></span><span id='topic+check.tparams_mean'></span><span id='topic+check.tparams_transprobs'></span><span id='topic+check'></span>

<h3>Description</h3>

<p><code>check</code> is a generic function for validating the inputs of class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'id_attributes'
check(object, ...)

## S3 method for class 'input_mats'
check(object, ...)

## S3 method for class 'params_lm'
check(object, ...)

## S3 method for class 'params_mlogit'
check(object, ...)

## S3 method for class 'params_surv'
check(object, ...)

## S3 method for class 'params_surv_list'
check(object, ...)

## S3 method for class 'tparams_mean'
check(object, ...)

## S3 method for class 'tparams_transprobs'
check(object, ...)

check(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.id_attributes_+3A_object">object</code></td>
<td>
<p>object to check.</p>
</td></tr>
<tr><td><code id="check.id_attributes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If validation is successful, returns the object in question; otherwise,
informs the user that an error has occurred.
</p>

<hr>
<h2 id='CohortDtstm'>Cohort discrete time state transition model</h2><span id='topic+CohortDtstm'></span>

<h3>Description</h3>

<p>Simulate outcomes from a cohort discrete time state transition model.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>trans_model</code></dt><dd><p>The model for health state transitions. Must be an object
of class <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The model for health state utility. Must be an object of
class <code><a href="#topic+StateVals">StateVals</a></code>.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The models used to predict costs by health state.
Must be a list of objects of class <code><a href="#topic+StateVals">StateVals</a></code>, where each element of the
list represents a different cost category.</p>
</dd>
<dt><code>stateprobs_</code></dt><dd><p>An object of class <code><a href="#topic+stateprobs">stateprobs</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_stateprobs()&#8288;</code>.</p>
</dd>
<dt><code>qalys_</code></dt><dd><p>An object of class <code><a href="#topic+qalys">qalys</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_qalys()&#8288;</code>.</p>
</dd>
<dt><code>costs_</code></dt><dd><p>An object of class <code><a href="#topic+costs">costs</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_costs()&#8288;</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CohortDtstm-new"><code>CohortDtstm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_stateprobs"><code>CohortDtstm$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_qalys"><code>CohortDtstm$sim_qalys()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_costs"><code>CohortDtstm$sim_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-summarize"><code>CohortDtstm$summarize()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-clone"><code>CohortDtstm$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CohortDtstm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>CohortDtstm</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$new(trans_model = NULL, utility_model = NULL, cost_models = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>trans_model</code></dt><dd><p>The <code>trans_model</code> field.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The <code>utility_model</code> field.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The <code>cost_models</code> field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>CohortDtstm</code> object.
</p>


<hr>
<a id="method-CohortDtstm-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code></h4>

<p>Simulate health state probabilities using <code>CohortDtstmTrans$sim_stateprobs()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_stateprobs(n_cycles)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_cycles</code></dt><dd><p>The number of model cycles to simulate the model for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+stateprobs">stateprobs</a>
stored in <code>stateprobs_</code>.
</p>


<hr>
<a id="method-CohortDtstm-sim_qalys"></a>



<h4>Method <code>sim_qalys()</code></h4>

<p>Simulate quality-adjusted life-years (QALYs) as a function of <code>stateprobs_</code> and
<code>utility_model</code>. See <code>sim_qalys()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_qalys(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  lys = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt><dd><p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
<dt><code>lys</code></dt><dd><p>If <code>TRUE</code>, then life-years are simulated in addition to QALYs.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+qalys">qalys</a> stored
in <code>qalys_</code>.
</p>


<hr>
<a id="method-CohortDtstm-sim_costs"></a>



<h4>Method <code>sim_costs()</code></h4>

<p>Simulate costs as a function of <code>stateprobs_</code> and <code>cost_models</code>.
See <code>sim_costs()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_costs(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt><dd><p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+costs">costs</a> stored
in <code>costs_</code>.
</p>


<hr>
<a id="method-CohortDtstm-summarize"></a>



<h4>Method <code>summarize()</code></h4>

<p>Summarize costs and QALYs so that cost-effectiveness analysis can be performed.
See <code><a href="#topic+summarize_ce">summarize_ce()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$summarize(by_grp = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>by_grp</code></dt><dd><p>If <code>TRUE</code>, then costs and QALYs are computed by subgroup. If
<code>FALSE</code>, then costs and QALYs are aggregated across all patients (and subgroups).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortDtstm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.1 for a description of a cohort DTSTM and details on
simulating costs and QALYs from state probabilities. An example in oncology
is provided in Section 4.3.
</p>


<h3>See Also</h3>

<p><code>CohortDtstm</code> objects can be created from model objects as
documented in <code><a href="#topic+create_CohortDtstm">create_CohortDtstm()</a></code>. The <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> documentation
describes the class for the transition model and the <code><a href="#topic+StateVals">StateVals</a></code> documentation
describes the class for the cost and utility models. A <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>
object is typically created using <code><a href="#topic+create_CohortDtstmTrans">create_CohortDtstmTrans()</a></code>.
</p>
<p>There are currently three relevant vignettes. <code>vignette("markov-cohort")</code>
details a relatively simple Markov model and
<code>vignette("markov-inhomogeneous-cohort")</code> describes a more complex time
inhomogeneous model in which transition probabilities vary in every model
cycle. The <code>vignette("mlogit")</code> shows how a transition model can be parameterized
using a multinomial logistic regression model when transition data is collected
at evenly spaced intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
library("ggplot2")
theme_set(theme_bw())
set.seed(102)

# NOTE: This example replicates the "Simple Markov cohort model" 
# vignette using a different approach. Here, we explicitly construct
# the transition probabilities "by hand". In the vignette, the transition 
# probabilities are defined using expressions (i.e., by using 
# `define_model()`). The `define_model()` approach does (more or less) what 
# is done here under the hood.

# (0) Model setup
hesim_dat &lt;- hesim_data(
  strategies = data.table(
    strategy_id = 1:2,
    strategy_name = c("Monotherapy", "Combination therapy")
  ),
  patients &lt;- data.table(patient_id = 1),
  states = data.table(
    state_id = 1:3,
    state_name = c("State A", "State B", "State C")
  )
)
n_states &lt;- nrow(hesim_dat$states) + 1
labs &lt;- get_labels(hesim_dat)

# (1) Parameters
n_samples &lt;- 10 # Number of samples for PSA

## Transition matrix
### Input data (one transition matrix for each parameter sample,
###             treatment strategy, patient, and time interval)
p_id &lt;- tpmatrix_id(expand(hesim_dat, times = c(0, 2)), n_samples)
N &lt;- nrow(p_id)

### Transition matrices (one for each row in p_id)
p &lt;- array(NA, dim = c(n_states, n_states, nrow(p_id)))

#### Baseline risk
trans_mono &lt;- rbind(
  c(1251, 350, 116, 17),
  c(0, 731, 512, 15),
  c(0, 0, 1312, 437),
  c(0, 0, 0, 469)
)
mono_ind &lt;- which(p_id$strategy_id == 1 | p_id$time_id == 2)
p[,, mono_ind] &lt;- rdirichlet_mat(n = 2, trans_mono)

#### Apply relative risks
combo_ind &lt;- setdiff(1:nrow(p_id), mono_ind)
lrr_se &lt;- (log(.710) - log(.365))/(2 * qnorm(.975))
rr &lt;- rlnorm(n_samples, meanlog = log(.509), sdlog = lrr_se)
rr_indices &lt;- list( # Indices of transition matrix to apply RR to
  c(1, 2), c(1, 3), c(1, 4),
  c(2, 3), c(2, 4),
  c(3, 4)
)
rr_mat &lt;- matrix(rr, nrow = n_samples, ncol = length(rr_indices))
p[,, combo_ind] &lt;- apply_rr(p[, , mono_ind],
                            rr = rr_mat,
                            index = rr_indices)
tp &lt;- tparams_transprobs(p, p_id)

## Utility
utility_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    est = c(1, 1, 1)
  ),
  dist = "fixed"
)

## Costs
drugcost_tbl &lt;- stateval_tbl(
  data.table(
    strategy_id = c(1, 1, 2, 2),
    time_start = c(0, 2, 0, 2),
    est = c(2278, 2278, 2278 + 2086.50, 2278)
  ),
  dist = "fixed"
)

dmedcost_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    mean = c(A = 1701, B = 1774, C = 6948),
    se = c(A = 1701, B = 1774, C = 6948)
  ),
  dist = "gamma"
)

cmedcost_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    mean = c(A = 1055, B = 1278, C = 2059),
    se = c(A = 1055, B = 1278, C = 2059)
  ),
  dist = "gamma"
)

# (2) Simulation
## Constructing the economic model
### Transition probabilities
transmod &lt;- CohortDtstmTrans$new(params = tp)

### Utility
utilitymod &lt;- create_StateVals(utility_tbl,
                               hesim_data = hesim_dat,
                               n = n_samples)

### Costs
drugcostmod &lt;- create_StateVals(drugcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
dmedcostmod &lt;- create_StateVals(dmedcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
cmedcostmod &lt;- create_StateVals(cmedcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
costmods &lt;- list(drug = drugcostmod,
                 direct_medical = dmedcostmod,
                 community_medical = cmedcostmod)

### Economic model
econmod &lt;- CohortDtstm$new(trans_model = transmod,
                           utility_model = utilitymod,
                           cost_models = costmods)

## Simulating outcomes
econmod$sim_stateprobs(n_cycles = 20)
autoplot(econmod$stateprobs_, ci = TRUE, ci_style = "ribbon",
         labels = labs)
econmod$sim_qalys(dr = 0, integrate_method = "riemann_right")
econmod$sim_costs(dr = 0.06, integrate_method = "riemann_right")

# (3) Decision analysis
ce_sim &lt;- econmod$summarize()
wtp &lt;- seq(0, 25000, 500)
cea_pw_out &lt;- cea_pw(ce_sim, comparator = 1, dr_qalys = 0, dr_costs = .06,
                     k = wtp)
format(icer(cea_pw_out))
</code></pre>

<hr>
<h2 id='CohortDtstmTrans'>Transitions for a cohort discrete time state transition model</h2><span id='topic+CohortDtstmTrans'></span>

<h3>Description</h3>

<p>Simulate health state transitions in a cohort discrete time state transition model.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>params</code></dt><dd><p>Parameters for simulating health state transitions.
Supports objects of class <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> or <code><a href="#topic+params_mlogit_list">params_mlogit_list</a></code>.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>An object of class <code><a href="#topic+input_mats">input_mats</a></code>.</p>
</dd>
<dt><code>cycle_length</code></dt><dd><p>The length of a model cycle in terms of years.
The default is <code>1</code> meaning that model cycles are 1 year long.</p>
</dd>
<dt><code>absorbing</code></dt><dd><p>A numeric vector denoting the states that are
absorbing states; i.e., states that cannot be transitioned from.
Each element should correspond to a <code>state_id</code>,
which should, in turn, be the index of the health state.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>start_stateprobs</code></dt><dd><p>A non-negative vector with length equal to the number of
health states containing the probability that the cohort is in each health
state at the start of the simulation. For example,
if there were three states and the cohort began the simulation in state 1,
then <code>start_stateprobs = c(1, 0, 0)</code>. Automatically normalized to sum to 1.
If <code>NULL</code>, then a vector with the first element equal to 1 and
all remaining elements equal to 0.</p>
</dd>
<dt><code>trans_mat</code></dt><dd><p>A transition matrix describing the states and transitions
in a discrete-time multi-state model. Only required if the model is
parameterized using multinomial logistic regression. The <code style="white-space: pre;">&#8288;(i,j)&#8288;</code> element
represents a transition from state <code>i</code> to state <code>j</code>. Each possible transition
from row <code>i</code> should be based on a separate multinomial logistic regression
and ordered from <code>0</code> to <code>K - 1</code> where <code>K</code> is the number of
possible transitions. Transitions that are not possible should be <code>NA</code>.
and the reference category for each row should be <code>0</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CohortDtstmTrans-new"><code>CohortDtstmTrans$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstmTrans-sim_stateprobs"><code>CohortDtstmTrans$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstmTrans-clone"><code>CohortDtstmTrans$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CohortDtstmTrans-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>CohortDtstmTrans</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstmTrans$new(
  params,
  input_data = NULL,
  trans_mat = NULL,
  start_stateprobs = NULL,
  cycle_length = 1,
  absorbing = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>The <code>params</code> field.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>The <code>input_data</code> field.</p>
</dd>
<dt><code>trans_mat</code></dt><dd><p>The <code>trans_mat</code> field.</p>
</dd>
<dt><code>start_stateprobs</code></dt><dd><p>The <code>start_stateprobs</code> field.</p>
</dd>
<dt><code>cycle_length</code></dt><dd><p>The <code>cycle_length</code> field.</p>
</dd>
<dt><code>absorbing</code></dt><dd><p>The <code>absorbing</code> field. If <code>NULL</code>, then the constructor
will determine which states are absorbing automatically; non <code>NULL</code> values
will override this behavior.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>CohortDtstmTrans</code> object.
</p>


<hr>
<a id="method-CohortDtstmTrans-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code></h4>

<p>Simulate probability of being in each health state during each model cycle.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstmTrans$sim_stateprobs(n_cycles)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_cycles</code></dt><dd><p>The number of model cycles to simulate the model for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+stateprobs">stateprobs</a></code>.
</p>


<hr>
<a id="method-CohortDtstmTrans-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstmTrans$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+create_CohortDtstmTrans">create_CohortDtstmTrans()</a></code> creates a <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> object from either
a fitted statistical model or a parameter object. A complete economic model can be implemented
with the <code><a href="#topic+CohortDtstm">CohortDtstm</a></code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("msm")
library("data.table")
set.seed(101)

# We consider two examples that have the same treatment strategies and patients.
# One model is parameterized by fitting a multi-state model with the "msm"
# package; in the second model, the parameters are entered "manually" with
# a "params_mlogit_list" object.

# MODEL SETUP
strategies &lt;- data.table(
  strategy_id = c(1, 2, 3),
  strategy_name = c("SOC", "New 1", "New 2")
)
patients &lt;- data.table(patient_id = 1:2)
hesim_dat &lt;- hesim_data(
  strategies = strategies,
  patients = patients
)

# EXAMPLE #1: msm
## Fit multi-state model with panel data via msm
qinit &lt;- rbind(
  c(0, 0.28163, 0.01239),
  c(0, 0, 0.10204),
  c(0, 0, 0)
)
fit &lt;- msm(state_id ~ time, subject = patient_id,
           data = onc3p[patient_id %in% sample(patient_id, 100)],
           covariates = list("1-2" =~ strategy_name),
           qmatrix = qinit)

## Simulation model
transmod_data &lt;- expand(hesim_dat)
transmod &lt;- create_CohortDtstmTrans(fit,
                                    input_data = transmod_data,
                                    cycle_length = 1/2,
                                    fixedpars = 2,
                                    n = 2)
transmod$sim_stateprobs(n_cycles = 2)

# EXAMPLE #2: params_mlogit_list
## Input data
transmod_data[, intercept := 1]
transmod_data[, new1 := ifelse(strategy_name == "New 1", 1, 0)]
transmod_data[, new2 := ifelse(strategy_name == "New 2", 1, 0)]

## Parameters
n &lt;- 10
transmod_params &lt;- params_mlogit_list(
  
  ## Transitions from stable state (stable -&gt; progression, stable -&gt; death)
  stable = params_mlogit(
    coefs = list(
      progression = data.frame(
        intercept = rnorm(n, -0.65, .1),
        new1 = rnorm(n, log(.8), .02),
        new2 = rnorm(n, log(.7, .02))
      ),
      death = data.frame(
        intercept = rnorm(n, -3.75, .1),
        new1 = rep(0, n),
        new2 = rep(0, n)
      )
    )
  ),
  
  ## Transition from progression state (progression -&gt; death)
  progression = params_mlogit(
    coefs = list(
      death = data.frame(
        intercept = rnorm(n, 2.45, .1),
        new1 = rep(0, n),
        new2 = rep(0, n)
      )
    )
  )
)
transmod_params

## Simulation model
tmat &lt;- rbind(c(0, 1, 2),
              c(NA, 0, 1),
              c(NA, NA, NA))
transmod &lt;- create_CohortDtstmTrans(transmod_params, 
                                    input_data = transmod_data,
                                    trans_mat = tmat, cycle_length = 1)
transmod$sim_stateprobs(n_cycles = 2)


</code></pre>

<hr>
<h2 id='costs'>Costs object</h2><span id='topic+costs'></span>

<h3>Description</h3>

<p>An object of class <code>costs</code> returned from methods
<code style="white-space: pre;">&#8288;$sim_costs()&#8288;</code> in model classes that store simulated costs.
</p>


<h3>Components</h3>

<p>A <code>costs</code> object inherits from <code>data.table</code> and contains
the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>grp_id</dt><dd><p>The subgroup ID.</p>
</dd>
<dt>state_id</dt><dd><p>The health state ID.</p>
</dd>
<dt>dr</dt><dd><p>The rate used to discount costs.</p>
</dd>
<dt>category</dt><dd><p>The cost category (e.g., drug costs, medical costs, etc).</p>
</dd>
<dt>costs</dt><dd><p>The simulated cost values.</p>
</dd>
</dl>


<hr>
<h2 id='create_CohortDtstm'>Create <code>CohortDtstm</code> object</h2><span id='topic+create_CohortDtstm'></span><span id='topic+create_CohortDtstm.model_def'></span>

<h3>Description</h3>

<p>A generic function for creating an object of class <code><a href="#topic+CohortDtstm">CohortDtstm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_CohortDtstm(object, ...)

## S3 method for class 'model_def'
create_CohortDtstm(
  object,
  input_data,
  cost_args = NULL,
  utility_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_CohortDtstm_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="create_CohortDtstm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>CohortDtstmTrans$new()</code> in
<code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_CohortDtstm_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code><a href="#topic+expand.hesim_data">expanded_hesim_data</a></code>.</p>
</td></tr>
<tr><td><code id="create_CohortDtstm_+3A_cost_args">cost_args</code></td>
<td>
<p>A list of further arguments passed to <code>StateVals$new()</code> in
<code><a href="#topic+StateVals">StateVals</a></code> when initiating cost models.</p>
</td></tr>
<tr><td><code id="create_CohortDtstm_+3A_utility_args">utility_args</code></td>
<td>
<p>A list of further arguments passed to <code>StateVals$new()</code> in
<code><a href="#topic+StateVals">StateVals</a></code> when initiating the utility model.</p>
</td></tr>
</table>

<hr>
<h2 id='create_CohortDtstmTrans'>Create <code>CohortDtstmTrans</code> object</h2><span id='topic+create_CohortDtstmTrans'></span><span id='topic+create_CohortDtstmTrans.multinom_list'></span><span id='topic+create_CohortDtstmTrans.msm'></span><span id='topic+create_CohortDtstmTrans.params_mlogit_list'></span>

<h3>Description</h3>

<p>A generic function for creating an object of class <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_CohortDtstmTrans(object, ...)

## S3 method for class 'multinom_list'
create_CohortDtstmTrans(
  object,
  input_data,
  trans_mat,
  n = 1000,
  uncertainty = c("normal", "none"),
  ...
)

## S3 method for class 'msm'
create_CohortDtstmTrans(
  object,
  input_data,
  cycle_length,
  n = 1000,
  uncertainty = c("normal", "none"),
  ...
)

## S3 method for class 'params_mlogit_list'
create_CohortDtstmTrans(object, input_data, trans_mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_CohortDtstmTrans_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class containing either a
fitted statistical model or model parameters.</p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>CohortDtstmTrans$new()</code> in
<code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code></p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_trans_mat">trans_mat</code></td>
<td>
<p>A transition matrix describing the states and transitions
in a discrete-time multi-state model. See <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw. Not used if <code>uncertainty = "none"</code>.</p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method determining how parameter uncertainty should be handled.
If <code>"normal"</code>, then parameters are randomly drawn from their multivariate normal
distribution. If <code>"none"</code>, then only point estimates are returned.</p>
</td></tr>
<tr><td><code id="create_CohortDtstmTrans_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The length of a model cycle in terms of years. The default
is 1 meaning that model cycles are 1 year long.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Disease models may either be created from a fitted statistical
model or from a parameter object. In the case of the former, <code>input_data</code>
is a data frame like object that is used to look for variables from
the statistical model that are required for simulation. In this sense,
<code>input_data</code> is very similar to the <code>newdata</code> argument in most <code><a href="stats.html#topic+predict">predict()</a></code>
methods (e.g., see <code><a href="stats.html#topic+predict.lm">predict.lm()</a></code>). In other words, variables used in the
<code><a href="stats.html#topic+formula">formula</a></code> of the statistical model must also be in <code>input_data</code>.
</p>
<p>In the case of the latter, the columns of <code>input_data</code> must be named in a
manner that is consistent with the parameter object. In the typical case
(e.g., with <code><a href="#topic+params_surv">params_surv</a></code> or <code><a href="#topic+params_mlogit">params_mlogit</a></code>), the parameter object
contains coefficients from a regression model, usually stored as matrix
where rows index parameter samples (i.e., for a probabilistic sensitivity
analysis) and columns index model terms. In such instances, there must
be one column from <code>input_data</code> with the same name as each model term in the
coefficient matrix; that is, the columns in <code>input_data</code> are matched with
the columns of the coefficient matrices by name. If there are model terms
in the coefficient matrices that are not contained in <code>input_data</code>, then
an error will be thrown.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> for examples.
</p>

<hr>
<h2 id='create_IndivCtstmTrans'>Create <code>IndivCtstmTrans</code> object</h2><span id='topic+create_IndivCtstmTrans'></span><span id='topic+create_IndivCtstmTrans.flexsurvreg_list'></span><span id='topic+create_IndivCtstmTrans.flexsurvreg'></span><span id='topic+create_IndivCtstmTrans.params_surv'></span><span id='topic+create_IndivCtstmTrans.params_surv_list'></span>

<h3>Description</h3>

<p>A generic function for creating an object of class <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_IndivCtstmTrans(object, ...)

## S3 method for class 'flexsurvreg_list'
create_IndivCtstmTrans(
  object,
  input_data,
  trans_mat,
  clock = c("reset", "forward"),
  n = 1000,
  uncertainty = c("normal", "none"),
  ...
)

## S3 method for class 'flexsurvreg'
create_IndivCtstmTrans(
  object,
  input_data,
  trans_mat,
  clock = c("reset", "forward"),
  n = 1000,
  uncertainty = c("normal", "none"),
  ...
)

## S3 method for class 'params_surv'
create_IndivCtstmTrans(
  object,
  input_data,
  trans_mat,
  clock = c("reset", "forward", "mix", "mixt"),
  reset_states = NULL,
  transition_types = NULL,
  ...
)

## S3 method for class 'params_surv_list'
create_IndivCtstmTrans(
  object,
  input_data,
  trans_mat,
  clock = c("reset", "forward", "mix", "mixt"),
  reset_states = NULL,
  transition_types = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_IndivCtstmTrans_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class containing either a fitted
multi-state model or parameters of a multi-state model.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>IndivCtstmTrans$new()</code> in <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code><a href="#topic+expand.hesim_data">expand.hesim_data</a></code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_trans_mat">trans_mat</code></td>
<td>
<p>The transition matrix describing the states and transitions in a
multi-state model in the format from the <code><a href="mstate.html#topic+mstate-package">mstate</a></code> package. See <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_clock">clock</code></td>
<td>
<p>&quot;reset&quot; for a clock-reset model, &quot;forward&quot; for a clock-forward model,
&quot;mix&quot; for a mixture by state, and &quot;mixt&quot; for a mixture by transition
of clock-reset and clock-forward models. See the field <code>clock</code> in <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw. Not used if <code>uncertainty = "none"</code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method determining how parameter uncertainty should be handled.
If <code>"normal"</code>, then parameters are randomly drawn from their multivariate normal
distribution. If <code>"none"</code>, then only point estimates are returned.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_reset_states">reset_states</code></td>
<td>
<p>A vector denoting the states in which time resets. See the field
<code>reset_states</code> in <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
<tr><td><code id="create_IndivCtstmTrans_+3A_transition_types">transition_types</code></td>
<td>
<p>A vector denoting the type for each transition. See the field
<code>transition_types</code> in <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Disease models may either be created from a fitted statistical
model or from a parameter object. In the case of the former, <code>input_data</code>
is a data frame like object that is used to look for variables from
the statistical model that are required for simulation. In this sense,
<code>input_data</code> is very similar to the <code>newdata</code> argument in most <code><a href="stats.html#topic+predict">predict()</a></code>
methods (e.g., see <code><a href="stats.html#topic+predict.lm">predict.lm()</a></code>). In other words, variables used in the
<code><a href="stats.html#topic+formula">formula</a></code> of the statistical model must also be in <code>input_data</code>.
</p>
<p>In the case of the latter, the columns of <code>input_data</code> must be named in a
manner that is consistent with the parameter object. In the typical case
(e.g., with <code><a href="#topic+params_surv">params_surv</a></code> or <code><a href="#topic+params_mlogit">params_mlogit</a></code>), the parameter object
contains coefficients from a regression model, usually stored as matrix
where rows index parameter samples (i.e., for a probabilistic sensitivity
analysis) and columns index model terms. In such instances, there must
be one column from <code>input_data</code> with the same name as each model term in the
coefficient matrix; that is, the columns in <code>input_data</code> are matched with
the columns of the coefficient matrices by name. If there are model terms
in the coefficient matrices that are not contained in <code>input_data</code>, then
an error will be thrown.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="R6.html#topic+R6Class">R6Class</a></code> object of class <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code> and <code><a href="#topic+IndivCtstm">IndivCtstm</a></code> for examples.
</p>

<hr>
<h2 id='create_input_mats'>Create input matrices</h2><span id='topic+create_input_mats'></span><span id='topic+create_input_mats.lm'></span><span id='topic+create_input_mats.flexsurvreg'></span><span id='topic+create_input_mats.flexsurvreg_list'></span><span id='topic+create_input_mats.partsurvfit'></span><span id='topic+create_input_mats.params_lm'></span><span id='topic+create_input_mats.params_surv'></span><span id='topic+create_input_mats.params_surv_list'></span><span id='topic+create_input_mats.multinom'></span><span id='topic+create_input_mats.multinom_list'></span><span id='topic+create_input_mats.params_mlogit_list'></span>

<h3>Description</h3>

<p><code>create_input_mats()</code> is a generic function for creating an object of class
<code><a href="#topic+input_mats">input_mats</a></code>. Model matrices are constructed based on the
variables specified in the model <code>object</code> and the data specified in <code>input_data</code>.
<code>create_input_mats()</code> is not typically called by users directly, but is
instead used by functions that create model objects (e.g.,
<code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code>, <code><a href="#topic+create_CohortDtstmTrans">create_CohortDtstmTrans()</a></code>,
<code><a href="#topic+create_PsmCurves">create_PsmCurves()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_input_mats(object, ...)

## S3 method for class 'lm'
create_input_mats(object, input_data, ...)

## S3 method for class 'flexsurvreg'
create_input_mats(object, input_data, ...)

## S3 method for class 'flexsurvreg_list'
create_input_mats(object, input_data, ...)

## S3 method for class 'partsurvfit'
create_input_mats(object, input_data, ...)

## S3 method for class 'params_lm'
create_input_mats(object, input_data, ...)

## S3 method for class 'params_surv'
create_input_mats(object, input_data, ...)

## S3 method for class 'params_surv_list'
create_input_mats(object, input_data, ...)

## S3 method for class 'multinom'
create_input_mats(object, input_data, ...)

## S3 method for class 'multinom_list'
create_input_mats(object, input_data, ...)

## S3 method for class 'params_mlogit_list'
create_input_mats(object, input_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_input_mats_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="create_input_mats_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="create_input_mats_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>. It is used to look for the variables needed to create
an input matrix for use in a statistical models and the ID variables for
indexing rows in the input matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>input_mats</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+input_mats">input_mats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")

strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       age = c(45, 47, 60),
                       female = c(1, 0, 0),
                       group = factor(c("Good", "Medium", "Poor")))
states &lt;- data.frame(state_id =  seq(1, 3),
                     state_name = factor(paste0("state", seq(1, 3))))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)

# Class "lm"
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients", "states"))
medcost_fit &lt;- lm(costs ~ female + state_name, psm4_exdata$costs$medical)
input_mats &lt;- create_input_mats(medcost_fit, input_data)
input_mats

# Class "flexsurvreg"
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))
fit_wei &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ 1,
                       data = ovarian, dist = "weibull")
input_mats &lt;- create_input_mats(fit_wei, input_data)
input_mats
</code></pre>

<hr>
<h2 id='create_input_mats.formula_list'>Create input matrices from formula</h2><span id='topic+create_input_mats.formula_list'></span>

<h3>Description</h3>

<p>This is an internal function for creating input matrices from formulas. It
is currently used in some unit tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula_list'
create_input_mats(object, input_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_input_mats.formula_list_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="create_input_mats.formula_list_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>. It is used to look for the variables needed to create
an input matrix for use in a statistical models and the ID variables for
indexing rows in the input matrix.</p>
</td></tr>
<tr><td><code id="create_input_mats.formula_list_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>input_mats</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_input_mats">create_input_mats()</a></code>
</p>

<hr>
<h2 id='create_lines_dt'>Create a data table of treatment lines</h2><span id='topic+create_lines_dt'></span>

<h3>Description</h3>

<p>Convert a list of treatment lines for multiple treatment strategies to a
<code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lines_dt(strategy_list, strategy_ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lines_dt_+3A_strategy_list">strategy_list</code></td>
<td>
<p>A list where each element is a treatment strategy
consisting of a vector of treatments.</p>
</td></tr>
<tr><td><code id="create_lines_dt_+3A_strategy_ids">strategy_ids</code></td>
<td>
<p>A numeric vector denoting the numeric id of each strategy
in <code>strategy_list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.table</code> in tidy format with three columns:
</p>

<dl>
<dt>strategy_id</dt><dd><p>Treatment strategy ids.</p>
</dd>
<dt>line</dt><dd><p>Line of therapy.</p>
</dd>
<dt>treatment_id</dt><dd><p>Treatment ID for treatment used at a given line of therapy
within a treatment strategy.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>strategies &lt;- list(c(1, 2, 3),
                  c(1, 2))
create_lines_dt(strategies)
</code></pre>

<hr>
<h2 id='create_object_list'>Form a list from <code>...</code></h2><span id='topic+create_object_list'></span>

<h3>Description</h3>

<p>Form a list of objects from <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_object_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_object_list_+3A_...">...</code></td>
<td>
<p>Objects used to form a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects from <code>...</code>.
</p>

<hr>
<h2 id='create_params'>Create a parameter object from a fitted model</h2><span id='topic+create_params'></span><span id='topic+create_params.lm'></span><span id='topic+create_params.multinom'></span><span id='topic+create_params.multinom_list'></span><span id='topic+create_params.flexsurvreg'></span><span id='topic+create_params.flexsurvreg_list'></span><span id='topic+create_params.partsurvfit'></span>

<h3>Description</h3>

<p><code>create_params</code> is a generic function for creating an object containing
parameters from a fitted statistical model. If <code>uncertainty != "none"</code>,
then random samples from suitable probability distributions are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_params(object, ...)

## S3 method for class 'lm'
create_params(object, n = 1000, uncertainty = c("normal", "none"), ...)

## S3 method for class 'multinom'
create_params(object, n = 1000, uncertainty = c("normal", "none"), ...)

## S3 method for class 'multinom_list'
create_params(object, n = 1000, uncertainty = c("normal", "none"), ...)

## S3 method for class 'flexsurvreg'
create_params(object, n = 1000, uncertainty = c("normal", "none"), ...)

## S3 method for class 'flexsurvreg_list'
create_params(object, n = 1000, uncertainty = c("normal", "none"), ...)

## S3 method for class 'partsurvfit'
create_params(
  object,
  n = 1000,
  uncertainty = c("normal", "bootstrap", "none"),
  max_errors = 0,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_params_+3A_object">object</code></td>
<td>
<p>A statistical model to randomly sample parameters from.</p>
</td></tr>
<tr><td><code id="create_params_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="create_params_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw. Not used if <code>uncertainty = "none"</code>.</p>
</td></tr>
<tr><td><code id="create_params_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method determining how parameter uncertainty should be handled.
If <code>"normal"</code>, then parameters are randomly drawn from their multivariate normal
distribution. If <code>"bootstrap"</code>, then parameters are bootstrapped using <code><a href="#topic+bootstrap">bootstrap</a></code>.
If <code>"none"</code>, then only point estimates are returned.</p>
</td></tr>
<tr><td><code id="create_params_+3A_max_errors">max_errors</code></td>
<td>
<p>Maximum number of errors that are allowed when fitting statistical models
during the bootstrap procedure. This argument may be useful if, for instance, the model
fails to converge during some bootstrap replications. Default is 0.</p>
</td></tr>
<tr><td><code id="create_params_+3A_silent">silent</code></td>
<td>
<p>Logical indicating whether error messages should be suppressed. Passed to
the <code>silent</code> argument of <code><a href="base.html#topic+try">try()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object prefixed by <code>params_</code>. Mapping between <code>create_params</code>
and the classes of the returned objects are:
</p>

<ul>
<li> <p><code>create_params.lm</code> -&gt; <code><a href="#topic+params_lm">params_lm</a></code>
</p>
</li>
<li> <p><code>create_params.multinom</code> -&gt; <code><a href="#topic+params_mlogit">params_mlogit</a></code>
</p>
</li>
<li> <p><code>create_params.multinom_list</code> -&gt;  <code><a href="#topic+params_mlogit_list">params_mlogit_list</a></code>
</p>
</li>
<li> <p><code>create_params.flexsurvreg</code> -&gt; <code><a href="#topic+params_surv">params_surv</a></code>
</p>
</li>
<li> <p><code>create_params.flexsurvreg_list</code> -&gt; <code><a href="#topic+params_surv_list">params_surv_list</a></code>
</p>
</li>
<li> <p><code>create_params.partsurvfit</code> -&gt;  <code><a href="#topic+params_surv_list">params_surv_list</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p>These methods are typically used alongside <code><a href="#topic+create_input_mats">create_input_mats()</a></code>
to create model objects as a function of input data and a
fitted statistical model. For instance,
<code><a href="#topic+create_PsmCurves">create_PsmCurves()</a></code> creates the survival model for a partitioned survival model,
<code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code> creates the transition model for an individual
continuous time state transition model,
<code><a href="#topic+create_CohortDtstmTrans">create_CohortDtstmTrans()</a></code> creates the transition model for a cohort discrete
time state transition model, and
<code><a href="#topic+create_StateVals">create_StateVals()</a></code> creates a health state values model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create_params.lm
fit &lt;- lm(costs ~ female, data = psm4_exdata$costs$medical)
n &lt;- 5
params_lm &lt;- create_params(fit, n = n)
head(params_lm$coefs)
head(params_lm$sigma)

# create_params.flexsurvreg
library("flexsurv")
fit &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ 1, 
                   data = ovarian, dist = "weibull")
n &lt;- 5
params_surv_wei &lt;- create_params(fit, n = n)
print(params_surv_wei$dist)
head(params_surv_wei$coefs)
</code></pre>

<hr>
<h2 id='create_PsmCurves'>Create <code>PsmCurves</code> object</h2><span id='topic+create_PsmCurves'></span><span id='topic+create_PsmCurves.flexsurvreg_list'></span><span id='topic+create_PsmCurves.params_surv_list'></span>

<h3>Description</h3>

<p>A generic function for creating a <code><a href="#topic+PsmCurves">PsmCurves</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_PsmCurves(object, ...)

## S3 method for class 'flexsurvreg_list'
create_PsmCurves(
  object,
  input_data,
  n = 1000,
  uncertainty = c("normal", "bootstrap", "none"),
  est_data = NULL,
  ...
)

## S3 method for class 'params_surv_list'
create_PsmCurves(object, input_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_PsmCurves_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class containing either fitted
survival models or parameters of survival models.</p>
</td></tr>
<tr><td><code id="create_PsmCurves_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Passed to <code><a href="#topic+create_params.partsurvfit">create_params.partsurvfit()</a></code>
when <code>object</code> is of class <code><a href="#topic+flexsurvreg_list">flexsurvreg_list</a></code>.</p>
</td></tr>
<tr><td><code id="create_PsmCurves_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>. Must be expanded by the data tables <code>"strategies"</code> and
<code>"patients"</code>.</p>
</td></tr>
<tr><td><code id="create_PsmCurves_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw. Not used if <code>uncertainty = "none"</code>.</p>
</td></tr>
<tr><td><code id="create_PsmCurves_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method determining how parameter uncertainty should be handled.
If <code>"normal"</code>, then parameters are randomly drawn from their multivariate normal
distribution. If <code>"bootstrap"</code>, then parameters are bootstrapped using <code><a href="#topic+bootstrap">bootstrap</a></code>.
If <code>"none"</code>, then only point estimates are returned.</p>
</td></tr>
<tr><td><code id="create_PsmCurves_+3A_est_data">est_data</code></td>
<td>
<p>A <code>data.table</code> or <code>data.frame</code> of estimation data
used to fit survival models during bootstrap replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Disease models may either be created from a fitted statistical
model or from a parameter object. In the case of the former, <code>input_data</code>
is a data frame like object that is used to look for variables from
the statistical model that are required for simulation. In this sense,
<code>input_data</code> is very similar to the <code>newdata</code> argument in most <code><a href="stats.html#topic+predict">predict()</a></code>
methods (e.g., see <code><a href="stats.html#topic+predict.lm">predict.lm()</a></code>). In other words, variables used in the
<code><a href="stats.html#topic+formula">formula</a></code> of the statistical model must also be in <code>input_data</code>.
</p>
<p>In the case of the latter, the columns of <code>input_data</code> must be named in a
manner that is consistent with the parameter object. In the typical case
(e.g., with <code><a href="#topic+params_surv">params_surv</a></code> or <code><a href="#topic+params_mlogit">params_mlogit</a></code>), the parameter object
contains coefficients from a regression model, usually stored as matrix
where rows index parameter samples (i.e., for a probabilistic sensitivity
analysis) and columns index model terms. In such instances, there must
be one column from <code>input_data</code> with the same name as each model term in the
coefficient matrix; that is, the columns in <code>input_data</code> are matched with
the columns of the coefficient matrices by name. If there are model terms
in the coefficient matrices that are not contained in <code>input_data</code>, then
an error will be thrown.
</p>


<h3>Value</h3>

<p>Returns an <code>R6Class</code> object of class <code><a href="#topic+PsmCurves">PsmCurves</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+PsmCurves">PsmCurves</a></code> and <code><a href="#topic+Psm">Psm</a></code> for examples. <code><a href="#topic+PsmCurves">PsmCurves</a></code> provides
an example in which a model is parameterized both with
(via <code>create_PsmCurves.flexsurvreg_list()</code>) and without (via
<code>create_PsmCurves.params_surv_list()</code>) access to patient-level data.
The <code><a href="#topic+Psm">Psm</a></code> example shows how state probabilities, costs, and utilities can
be computed from predicted survival curves.
</p>

<hr>
<h2 id='create_StateVals'>Create a <code>StateVals</code> object</h2><span id='topic+create_StateVals'></span><span id='topic+create_StateVals.lm'></span><span id='topic+create_StateVals.stateval_tbl'></span>

<h3>Description</h3>

<p><code>create_StateVals()</code> is a generic function for creating an object of class
<code><a href="#topic+StateVals">StateVals</a></code> from a fitted statistical model or a <code><a href="#topic+stateval_tbl">stateval_tbl</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_StateVals(object, ...)

## S3 method for class 'lm'
create_StateVals(
  object,
  input_data = NULL,
  n = 1000,
  uncertainty = c("normal", "none"),
  ...
)

## S3 method for class 'stateval_tbl'
create_StateVals(object, hesim_data = NULL, n = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_StateVals_+3A_object">object</code></td>
<td>
<p>A model object of the appropriate class.</p>
</td></tr>
<tr><td><code id="create_StateVals_+3A_...">...</code></td>
<td>
<p>Further arguments (<code>time_reset</code> and <code>method</code>) passed to <code><a href="#topic+StateVals">StateVals$new()</a></code>.</p>
</td></tr>
<tr><td><code id="create_StateVals_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <code><a href="#topic+expand.hesim_data">expanded_hesim_data</a></code>.
Must be expanded by treatment strategies, patients, and health states.</p>
</td></tr>
<tr><td><code id="create_StateVals_+3A_n">n</code></td>
<td>
<p>Number of random observations of the parameters to draw when parameters
are fit using a statistical model.</p>
</td></tr>
<tr><td><code id="create_StateVals_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method determining how parameter uncertainty should be handled. See
documentation in <code><a href="#topic+create_params">create_params()</a></code>.</p>
</td></tr>
<tr><td><code id="create_StateVals_+3A_hesim_data">hesim_data</code></td>
<td>
<p>A <code><a href="#topic+hesim_data">hesim_data</a></code> object. Only required when <code>object</code> is of class
<code><a href="#topic+stateval_tbl">stateval_tbl</a></code>. See &quot;details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is a <code>stateval_tbl</code>, then a <code><a href="#topic+hesim_data">hesim_data</a></code> object is used
to specify treatment strategies, patients, and/or health states not included as
columns in the table, or, to match patients in the table to groups. Not required if
the table includes one row for each treatment strategy, patient, and health state
combination. Patients are matched to groups by specifying both a <code>patient_id</code>
and a <code>grp_var</code> column in the <code>patients</code> table.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+StateVals">StateVals</a></code> object.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+StateVals">StateVals</a></code> for documentation of the class and additional examples.
An example use case for <code><a href="#topic+create_StateVals.stateval_tbl">create_StateVals.stateval_tbl()</a></code> is provided in
the <code><a href="#topic+stateval_tbl">stateval_tbl()</a></code> documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)

# EXAMPLE FOR `create_statevals.lm()`
## Simple example comparing two treatment strategies where
## medical costs vary by sex and health state

## Setup model
hesim_dat &lt;- hesim_data(
  strategies = data.frame(strategy_id = c(1, 2)),
  patients = data.frame(
    patient_id = c(1, 2),
    female = c(1, 0)
  ),
  states = data.frame(
    state_id = c(1, 2, 3),
    state_name = c("state1", "state2", "state3")
  )
)

## Fit model
medcost_estimation_data &lt;- psm4_exdata$costs$medical
medcost_estimation_data$time5 &lt;- rbinom(nrow(medcost_estimation_data), 
                                        1, .5) # Illustrative time dummy
medcost_fit &lt;- lm(costs ~ female + state_name + time5, 
                  data = medcost_estimation_data)

## Create medical cost model
### Allow medical costs to vary across time in addition to by patient and 
### health state
medcost_times &lt;- time_intervals(
  data.frame(time_start = c(0, 3, 5),
            time5 = c(0, 0, 1)) # Time dummy corresponds to time &gt; 5
)
medcost_input_data &lt;- expand(hesim_dat, 
                             by = c("strategies", "patients", "states"),
                             times = medcost_times)
medcost_model &lt;- create_StateVals(medcost_fit, medcost_input_data,
                                  n = 1)

## Explore predictions from medical cost model
### We can assess predictions at multiple time points
medcost_model$sim(t = c(1, 6), type = "predict")
</code></pre>

<hr>
<h2 id='create_trans_dt'>Create a data table of health state transitions</h2><span id='topic+create_trans_dt'></span>

<h3>Description</h3>

<p>Create a data table of health state transitions from a transition matrix describing
the states and transitions in a multi-state model suitable for use with <code><a href="#topic+hesim_data">hesim_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_trans_dt(trans_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_trans_dt_+3A_trans_mat">trans_mat</code></td>
<td>
<p>A transition matrix in the format from the <code><a href="mstate.html#topic+mstate-package">mstate</a></code> package.
See <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> in tidy format with three columns:
</p>

<dl>
<dt>transition_id</dt><dd><p>Health state transition ID.</p>
</dd>
<dt>from</dt><dd><p>The starting health state.</p>
</dd>
<dt>to</dt><dd><p>The health state that will be transitions to.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>tmat &lt;- rbind(c(NA, 1, 2),
              c(NA, NA, 3),
              c(NA, NA, NA))
create_trans_dt(tmat)
</code></pre>

<hr>
<h2 id='CtstmTrans'>An <code>R6</code> base class for continuous time state transition models</h2><span id='topic+CtstmTrans'></span>

<h3>Description</h3>

<p>Contains methods that can be used to summarize both individual- and cohort-level
continuous time state transition models. That is, this class is relevant for
both Markov and semi-Markov multi-state models and does not depend on the
methodology used for prediction of state probabilities.
</p>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6::R6Class</a></code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CtstmTrans-hazard"><code>CtstmTrans$hazard()</code></a>
</p>
</li>
<li> <p><a href="#method-CtstmTrans-cumhazard"><code>CtstmTrans$cumhazard()</code></a>
</p>
</li>
<li> <p><a href="#method-CtstmTrans-clone"><code>CtstmTrans$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CtstmTrans-hazard"></a>



<h4>Method <code>hazard()</code></h4>

<p>Predict the hazard functions for each health state transition.
</p>


<h5>Usage</h5>

<div class="r"><pre>CtstmTrans$hazard(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>transition_id</code>,
<code>sample</code>, <code>strategy_id</code>, <code>grp_id</code>, <code>t</code>, and <code>hazard</code>.
</p>


<hr>
<a id="method-CtstmTrans-cumhazard"></a>



<h4>Method <code>cumhazard()</code></h4>

<p>Predict the cumulative hazard functions for each health state transition.
</p>


<h5>Usage</h5>

<div class="r"><pre>CtstmTrans$cumhazard(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>transition_id</code>,
<code>sample</code>, <code>strategy_id</code>, <code>grp_id</code>, <code>t</code>, and <code>cumhazard</code>.
</p>


<hr>
<a id="method-CtstmTrans-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CtstmTrans$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code>, <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>
</p>

<hr>
<h2 id='define_model'>Define and evaluate model expression</h2><span id='topic+define_model'></span><span id='topic+eval_model'></span>

<h3>Description</h3>

<p>A model expression is defined by specifying random number generation functions
for a probabilistic sensitivity analysis (PSA) and transformations of the sampled
parameters as a function of <code>input_data</code>. The unevaluated expressions
are evaluated with <code>eval_model()</code> and used to generate the model inputs needed to
create an economic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_model(tparams_def, rng_def, params = NULL, n_states = NULL)

eval_model(x, input_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_model_+3A_tparams_def">tparams_def</code></td>
<td>
<p>A <a href="#topic+define_tparams">tparams_def</a> object or a list of
<a href="#topic+define_tparams">tparams_def</a> objects. A list might be considered if time intervals
specified with the <code>times</code> argument in <code><a href="#topic+define_tparams">define_tparams()</a></code> vary across parameters.
Parameters for a transition probability matrix (<code>tpmatrix</code>), utilities (<code>utility</code>),
and/or cost categories (<code>costs</code>) are returned as a named list (see <code><a href="#topic+define_tparams">define_tparams()</a></code>
for more details).</p>
</td></tr>
<tr><td><code id="define_model_+3A_rng_def">rng_def</code></td>
<td>
<p>A <a href="#topic+define_rng">rng_def</a> object used to randomly draw samples
of the parameters from suitable probability distributions.</p>
</td></tr>
<tr><td><code id="define_model_+3A_params">params</code></td>
<td>
<p>Either (i) a list containing the values of parameters for random
number generation or (ii) parameter samples that have already been randomly
generated using <code>eval_rng()</code>. In case (ii), <code>rng_def</code> should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="define_model_+3A_n_states">n_states</code></td>
<td>
<p>The number of health states (inclusive of all health states
including the the death state) in the model. If <code>tpmatrix</code> is
an element returned by <code>tparams_def</code>, then it will be equal to the number of states
in the transition probability matrix; otherwise it must be specified as an argument.</p>
</td></tr>
<tr><td><code id="define_model_+3A_x">x</code></td>
<td>
<p>An object of class <code>model_def</code> created with <code>define_model()</code>.</p>
</td></tr>
<tr><td><code id="define_model_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <a href="#topic+expand.hesim_data">expanded_hesim_data</a>
expanded by patients and treatment strategies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eval_model()</code> evaluates the expressions in an object of class
<code>model_def</code> returned by <code>define_model()</code> and is, in turn, used within
functions that instantiate economic models (e.g., <code><a href="#topic+create_CohortDtstm">create_CohortDtstm()</a></code>).
The direct output of <code>eval_model()</code> can also be useful for understanding and debugging
model definitions, but it is not used directly for simulation.
</p>
<p>Economic models are constructed as a function of input data and parameters:
</p>

<ol>
<li> <p><em>Input data</em>: Objects of class <a href="#topic+expand.hesim_data">expanded_hesim_data</a>
consisting of the treatment strategies and patient population.
</p>
</li>
<li> <p><em>Parameters</em>: The underlying parameter estimates from the literature
are first stored in a list (<code>params</code> argument). Random number generation
is then used to sample the parameters from suitable probability distributions
for the PSA (<code>rng_def</code> argument). Finally, the sampled parameters are
transformed as a function of the input data into values (e.g., elements of a
transition probability matrix) used for the simulation (<code>tparams_def</code> argument).
The <code>params</code> argument can be omitted if the underlying parameters values are
defined inside a <code>define_rng()</code> block.
</p>
</li></ol>



<h3>Value</h3>

<p><code>define_model()</code> returns an object of class <code>model_def</code>,
which is a list containing the arguments to the function. <code>eval_model()</code> returns
a list containing <a href="#topic+id_attributes">ID</a> variables
identifying parameter samples, treatment strategies, patient cohorts, and time
intervals; the values of parameters of the transition probability matrix,
utilities, and/or cost categories; the number of health states; and the number
of random number generation samples for the PSA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_tparams">define_tparams()</a></code>, <code><a href="#topic+define_rng">define_rng()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data
library("data.table")
strategies &lt;- data.table(strategy_id = 1:2,
                         strategy_name = c("Monotherapy", "Combination therapy"))
patients &lt;- data.table(patient_id = 1)
hesim_dat &lt;- hesim_data(strategies = strategies,
                       patients = patients)
data &lt;- expand(hesim_dat)

# Model parameters
rng_def &lt;- define_rng({
  alpha &lt;- matrix(c(1251, 350, 116, 17,
                    0, 731, 512, 15,
                    0, 0, 1312, 437,
                    0, 0, 0, 469),
                  nrow = 4, byrow = TRUE)
  rownames(alpha) &lt;- colnames(alpha) &lt;- c("A", "B", "C", "D")
  lrr_mean &lt;- log(.509)
  lrr_se &lt;- (log(.710) - log(.365))/(2 * qnorm(.975))
  
  list(
    p_mono = dirichlet_rng(alpha),
    rr_comb = lognormal_rng(lrr_mean, lrr_se),
    u = 1,
    c_zido = 2278,
    c_lam = 2086.50,
    c_med = gamma_rng(mean = c(A = 2756, B = 3052, C = 9007),
                      sd = c(A = 2756, B = 3052, C = 9007))
  )
}, n = 2)

tparams_def &lt;- define_tparams({
  rr = ifelse(strategy_name == "Monotherapy", 1, rr_comb)
  list(
    tpmatrix = tpmatrix(
      C, p_mono$A_B * rr, p_mono$A_C * rr, p_mono$A_D * rr,
      0, C, p_mono$B_C * rr, p_mono$B_D * rr,
      0, 0, C, p_mono$C_D * rr,
      0, 0, 0, 1),
    utility = u,
    costs = list(
      drug = ifelse(strategy_name == "Monotherapy",
                    c_zido, c_zido + c_lam),
      medical = c_med
    ) 
  )
})

# Simulation
## Define the economic model
model_def &lt;- define_model(
  tparams_def = tparams_def,
  rng_def = rng_def)

### Evaluate the model expression to generate model inputs
### This can be useful for understanding the output of a model expression
eval_model(model_def, data)

## Create an economic model with a factory function
econmod &lt;- create_CohortDtstm(model_def, data)

</code></pre>

<hr>
<h2 id='define_rng'>Define and evaluate random number generation expressions</h2><span id='topic+define_rng'></span><span id='topic+eval_rng'></span>

<h3>Description</h3>

<p>Random number generation expressions are used to
randomly sample model parameters from suitable distributions for probabilistic
sensitivity analysis. These functions are typically used when evaluating
an object of class <code>model_def</code> defined using <code><a href="#topic+define_model">define_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_rng(expr, n = 1, ...)

eval_rng(x, params = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_rng_+3A_expr">expr</code></td>
<td>
<p>An expression used to randomly draw variates for each parameter of
interest in the model. <a href="base.html#topic+Paren">Braces</a> should be used so that the result
of the last expression within the braces is evaluated. The expression must
return a list where each element is either a <code>vector</code> or tabular object
( <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code>). The length of the vector must
either be or <code>n</code> and the number of rows in the tabular object must be <code>n</code>.</p>
</td></tr>
<tr><td><code id="define_rng_+3A_n">n</code></td>
<td>
<p>Number of samples of the parameters to draw.</p>
</td></tr>
<tr><td><code id="define_rng_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the environment used to evaluate
<code>expr</code>.</p>
</td></tr>
<tr><td><code id="define_rng_+3A_x">x</code></td>
<td>
<p>An object of class <code>rng_def</code> created with <code>define_rng()</code>.</p>
</td></tr>
<tr><td><code id="define_rng_+3A_params">params</code></td>
<td>
<p>A list containing the values of parameters for random number
generation. Each element of the list should either be a <code>vector</code>,
<code>matrix</code>, <code>data.frame</code>, or <code>data.table</code></p>
</td></tr>
<tr><td><code id="define_rng_+3A_check">check</code></td>
<td>
<p>Whether to check the returned output so that (i) it returns a list
and (ii) each element has the correct length or number of rows. Default is <code>TRUE</code>,
meaning that any output can be returned. This is always <code>TRUE</code> when used inside
<code><a href="#topic+define_model">define_model()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hesim</code> contains a number of random number generation functions
that return parameter samples in convenient formats
and do not typically require the number of samples, <code>n</code>, as arguments
(see <code><a href="#topic+rng_distributions">rng_distributions</a></code>). The random number generation expressions
are evaluated using <code>eval_rng()</code> and used within <code>expr</code>
in <code>define_rng()</code>. If a multivariate object is returned by <code>eval_rng()</code>,
then the rows are random samples and columns are
distinct parameters (e.g., costs for each health state, elements of a
transition probability matrix).
</p>


<h3>Value</h3>

<p><code>define_rng()</code> returns an object of class <code>rng_def</code>,
which is a list containing the unevaluated random number generation
expressions passed  to <code>expr</code>, <code>n</code>, and any additional arguments passed to
<code>...</code> . <code>eval_rng()</code> evaluates the <code>rng_def</code> object and
returns an <code>eval_rng</code> object containing the evaluated expression.
</p>


<h3>See Also</h3>

<p>Parameters can be conveniently sampled from probability distributions
using a number of random number generation functions (see <code><a href="#topic+rng_distributions">rng_distributions</a></code>).
An economic model can be created with <code><a href="#topic+create_CohortDtstm">create_CohortDtstm()</a></code> by using
<code>define_rng()</code> (or a previously evaluated <code>eval_rng</code> object)
alongside <code><a href="#topic+define_tparams">define_tparams()</a></code> to define a model with <code><a href="#topic+define_model">define_model()</a></code>.
It can be useful to summarize an evaluated expression with <code>summary.eval_rng()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
params &lt;- list(
  alpha = matrix(c(75, 25, 33, 67), byrow = TRUE, ncol = 2),
  inptcost_mean = c(A = 900, B = 1500, C = 2000),
  outptcost_mean = matrix(c(300, 600, 800,
                            400, 700, 700),
                           ncol = 3, byrow = TRUE)
)
rng_def &lt;- define_rng({
  aecost_mean &lt;- c(500, 800, 1000) # Local object not 
                                   # not returned by eval_rng()
  list( # Sampled values of parameters returned by eval_rng()
    p = dirichlet_rng(alpha), # Default column names
    inptcost = gamma_rng(mean = inptcost_mean, # Column names based on 
                         sd = inptcost_mean),  # named vector
    outptcost = outptcost_mean, # No column names because
                                # outptcost_mean has none.
    aecost = gamma_rng(mean = aecost_mean, # Explicit naming of columns
                       sd = aecost_mean,
                       names = aecost_colnames)
  )
}, n = 2, aecost_colnames = c("A", "B", "C")) # Add aecost_colnames to environment
params_sample &lt;- eval_rng(x = rng_def, params)
summary(params_sample)
params_sample
</code></pre>

<hr>
<h2 id='define_tparams'>Define and evaluate transformed parameter expressions</h2><span id='topic+define_tparams'></span><span id='topic+eval_tparams'></span>

<h3>Description</h3>

<p>Transformed parameter expressions are used to transform the parameter
values sampled with <code><a href="#topic+eval_rng">eval_rng()</a></code> as a function of input data
(treatment strategies and patients) and time
intervals. These functions are used when evaluating an object of class
<code>model_def</code> defined using <code><a href="#topic+define_model">define_model()</a></code>. The transformed parameters
are ultimately converted into <a href="#topic+tparams">tparams</a> objects and used to simulate outcomes with an
economic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_tparams(expr, times = NULL, ...)

eval_tparams(x, input_data, rng_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_tparams_+3A_expr">expr</code></td>
<td>
<p>Expressions used to transform parameters. As with <code><a href="#topic+define_rng">define_rng()</a></code>,
<a href="base.html#topic+Paren">braces</a> should be used so that the result
of the last expression within the braces is evaluated. The expression
must return a named list with the following possible elements:
</p>

<ul>
<li> <p><em>tpmatrix</em>: The transition probability matrix used to simulate transition
probabilities in the economic model. This should either be the output of
<code><a href="#topic+tpmatrix">tpmatrix()</a></code> or a 3-dimensional array as in <code><a href="#topic+tparams_transprobs">tparams_transprobs()</a></code>.
</p>
</li>
<li> <p><em>utility</em>: The utility values to attach to states and used to simulate
quality-adjusted life-years in the economic model. Either a vector (in
which case utility is the same in each health state) or a
<code>data.table</code>/<code>data.frame</code>/<code>matrix</code> with a column for each (non-death)
health state.
</p>
</li>
<li> <p><em>costs</em>:  A named list of costs for each category used to simulate
costs in the economic model. Each element of the
list must be in the same format as <code>utility</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="define_tparams_+3A_times">times</code></td>
<td>
<p>Distinct times denoting the stopping time of time intervals.</p>
</td></tr>
<tr><td><code id="define_tparams_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the environment used to evaluate
<code>expr</code>.</p>
</td></tr>
<tr><td><code id="define_tparams_+3A_x">x</code></td>
<td>
<p>An object of class <code>tparams_def</code>.</p>
</td></tr>
<tr><td><code id="define_tparams_+3A_input_data">input_data</code></td>
<td>
<p>An object of class <a href="#topic+expand.hesim_data">expanded_hesim_data</a> (as
in <code><a href="#topic+eval_model">eval_model()</a></code>) expanded by the distinct times in <code>times</code>.</p>
</td></tr>
<tr><td><code id="define_tparams_+3A_rng_params">rng_params</code></td>
<td>
<p>Random samples of the parameters returned by <code><a href="#topic+eval_rng">eval_rng()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>define_tparams()</code> is evaluated when creating economic models as a
function of <code>model_def</code> objects defined with <code><a href="#topic+define_model">define_model()</a></code>. Operations
are &quot;vectorized&quot; in the sense that they are performed for each unique combination
of <code>input_data</code> and <code>params</code>. <code>expr</code> is evaluated in an environment including
each variable from <code>input_data</code>, all elements of <code>rng_params</code>, and a variable
<code>time</code> containing the values from <code>times</code>. The <code>time</code> variable can be used
to create models where parameters vary as a function of time.
<code>eval_tparams()</code> is not exported and is only meant for use within <code><a href="#topic+eval_model">eval_model()</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+define_tparams">define_tparams()</a></code> returns an object of class <code>tparams_def</code>,
which is a list containing the unevaluated &quot;transformation&quot; expressions
passed  to <code>expr</code>, <code>times</code>, and any additional arguments passed to
<code>...</code> . <code><a href="#topic+eval_tparams">eval_tparams()</a></code> evaluates the <code>tparams_def</code> object
and should return a list of transformed parameter objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_model">define_model()</a></code>, <code><a href="#topic+define_rng">define_rng()</a></code>
</p>

<hr>
<h2 id='disprog'>Disease progression object</h2><span id='topic+disprog'></span>

<h3>Description</h3>

<p>An object of class <code>disprog</code> returned from methods
<code style="white-space: pre;">&#8288;$sim_disease()&#8288;</code> in model classes. It contains simulated trajectories
through a multi-state model.
</p>


<h3>Components</h3>

<p>A <code>disprog</code> object inherits from <code>data.table</code> and contains
the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>from</dt><dd><p>The health state ID transitioned from.</p>
</dd>
<dt>to</dt><dd><p>The health state ID transitioned to.</p>
</dd>
<dt>final</dt><dd><p>An indicator equal to 1 if a patient is in their final health
state during the simulation and 0 otherwise.</p>
</dd>
<dt>time_start</dt><dd><p>The time at the start of the interval.</p>
</dd>
<dt>time_stop</dt><dd><p>The time at the end of the interval.</p>
</dd>
</dl>

<p>The object also contains <code>size</code> and <code>absorbing</code> attributes.
The <code>size</code> attribute is a numeric vector with the elements <code>n_samples</code>,
<code>n_strategies</code>, <code>n_patients</code>, and <code>n_states</code> denoting the number of samples,
treatment strategies, patients, and health states The <code>absorbing</code> attribute
is a numeric vector containing the absorbing health states; i.e., the
health states that cannot be transitioned from. Operationally, an
absorbing state is a row in a transition matrix (as in the <code>trans_mat</code> field
of the <code>IndivCtstmTrans</code> class) with all <code>NA</code>s.
</p>


<h3>See Also</h3>

<p>A disease progression object can be simulated with either the
<code><a href="#topic+IndivCtstm">IndivCtstm</a></code> or <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code> classes.
</p>

<hr>
<h2 id='expand'>Expand object</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>A generic function for &quot;expanding&quot; an object. Only used for
<code>hesim_data</code> objects with <code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(object, by, times)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>
</p>

<hr>
<h2 id='expand.hesim_data'>Expand hesim_data</h2><span id='topic+expand.hesim_data'></span>

<h3>Description</h3>

<p>Create a data table in long format from all combinations of specified tables
from an object of class <a href="#topic+hesim_data">hesim_data</a> and optionally time intervals. See &quot;Details&quot; for
an explanation of how the expansion is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hesim_data'
expand(object, by = c("strategies", "patients"), times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.hesim_data_+3A_object">object</code></td>
<td>
<p>An object of class <code>hesim_data</code>.</p>
</td></tr>
<tr><td><code id="expand.hesim_data_+3A_by">by</code></td>
<td>
<p>A character vector of the names of the data tables in <code>hesim_data</code> to expand by.</p>
</td></tr>
<tr><td><code id="expand.hesim_data_+3A_times">times</code></td>
<td>
<p>Either a numeric vector of distinct times denoting the start of time intervals or
a <a href="#topic+time_intervals">time_intervals</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>, but works for data frames or data tables.
Specifically, it creates a <code>data.table</code> from all combinations of the supplied tables in <code>object</code>
and optionally the start of times intervals in <code>times</code>.
The supplied tables are determined using the <code>by</code> argument. The resulting dataset is sorted by
prioritizing ID variables as follows: (i) <code>strategy_id</code>, (ii) <code>patient_id</code>,
(iii) the health-related ID variable (either <code>state_id</code> or <code>transition_id</code>, and
(iv) the time intervals from <code>times</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>expanded_hesim_data</code>, which is a <code>data.table</code> with an &quot;id_vars&quot;
attribute containing the names of the ID variables in the data table and, if <code>times</code> is
not <code>NULL</code>, a <code>time_intervals</code> object derived from <code>times</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3), age = c(65, 50, 75),
                          gender = c("Female", "Female", "Male"))
states &lt;- data.frame(state_id =  seq(1, 3),
                     state_var = c(2, 1, 9))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)
expand(hesim_dat, by = c("strategies", "patients"))
expand(hesim_dat, by = c("strategies", "patients"),
       times = c(0, 2, 10))
</code></pre>

<hr>
<h2 id='expmat'>Matrix exponential</h2><span id='topic+expmat'></span>

<h3>Description</h3>

<p>This is a wrapper around <code><a href="msm.html#topic+MatrixExp">msm::MatrixExp()</a></code> that computes the exponential
of multiple square matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expmat(x, t = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expmat_+3A_x">x</code></td>
<td>
<p>An array of matrices.</p>
</td></tr>
<tr><td><code id="expmat_+3A_t">t</code></td>
<td>
<p>An optional scaling factor for <code>x</code>.</p>
</td></tr>
<tr><td><code id="expmat_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="msm.html#topic+MatrixExp">msm::MatrixExp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is most useful when exponentiating transition intensity
matrices to produce transition probability matrices. To create transition
probability matrices for discrete time state transition models with annual
cycles, set <code>t=1</code>. An array of matrices is returned which can be used
to create the <code>value</code> element of a <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object. See
<code><a href="#topic+qmatrix">qmatrix()</a></code> for an example.
</p>


<h3>Value</h3>

<p>Returns an array of exponentiated matrices. If <code>length(t) &gt; 1</code>, then
<code>length(t)</code> arrays are returned for each element in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm()</a></code>, <code><a href="#topic+qmatrix.data.table">qmatrix.data.table()</a></code>
</p>

<hr>
<h2 id='fast_rgengamma'>Random generation for generalized gamma distribution</h2><span id='topic+fast_rgengamma'></span>

<h3>Description</h3>

<p>Draw random samples from a generalized gamma distribution using the
parameterization from <code>flexsurv</code>. Written in C++
for speed. Equivalent to <code>flexsurv::rgengamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_rgengamma(n, mu = 0, sigma = 1, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_rgengamma_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw.</p>
</td></tr>
<tr><td><code id="fast_rgengamma_+3A_mu">mu</code></td>
<td>
<p>Vector of location parameters.
and columns correspond to rates during specified time intervals.</p>
</td></tr>
<tr><td><code id="fast_rgengamma_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scale parameters as described in <code>flexsurv</code>.</p>
</td></tr>
<tr><td><code id="fast_rgengamma_+3A_q">Q</code></td>
<td>
<p>Vector of shape parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of random samples from the generalized gamma distribution. The length of the sample is
determined by n. The numerical arguments other than n are recycled so that the number of samples is
equal to n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
m &lt;- 2 ; s &lt;- 1.7; q &lt;- 1
ptm &lt;- proc.time()
r1 &lt;- fast_rgengamma(n, mu = m, sigma = s, Q = q)
proc.time() - ptm
ptm &lt;- proc.time()
library("flexsurv")
r2 &lt;- flexsurv::rgengamma(n, mu = m, sigma = s, Q = q)
proc.time() - ptm
summary(r1)
summary(r2)

</code></pre>

<hr>
<h2 id='flexsurvreg_list'>List of <code>flexsurvreg</code> objects</h2><span id='topic+flexsurvreg_list'></span>

<h3>Description</h3>

<p>Combine <code><a href="flexsurv.html#topic+flexsurvreg">flexsurvreg</a></code> objects into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexsurvreg_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexsurvreg_list_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="flexsurv.html#topic+flexsurvreg">flexsurvreg</a></code>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>flexsurvreg_list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library("flexsurv")
 fit1 &lt;- flexsurv::flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian, dist = "weibull")
 fit2 &lt;- flexsurv::flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian, dist = "exp")
 fsreg_list &lt;- flexsurvreg_list(wei = fit1, exp = fit2)
 class(fsreg_list)
</code></pre>

<hr>
<h2 id='formula_list'>List of <code>formula</code> objects</h2><span id='topic+formula_list'></span>

<h3>Description</h3>

<p>Combine <a href="stats.html#topic+formula">formula</a> or <a href="#topic+formula_list">formula_list</a> object into a
<a href="#topic+formula_list">formula_list</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_list_+3A_...">...</code></td>
<td>
<p>Objects of class <a href="stats.html#topic+formula">formula</a>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>formula_list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create from "formula" objects
flist_wei &lt;- formula_list(shape = formula(~ 1), scale = formula(~ x))
class(flist_wei)

# Create from "formula_list" objects
flist &lt;- formula_list(exponential = formula_list(rate = formula(~1)),
                              weibull = flist_wei)

</code></pre>

<hr>
<h2 id='get_labels'>Get value labels</h2><span id='topic+get_labels'></span>

<h3>Description</h3>

<p>Get value labels for the ID variables in a <code>hesim_data</code> object and create a list
of named vectors that can be passed to formatting and plotting functions. This
lets users create nice labels for treatment strategies, subgroups, health states,
and/or transitions when presenting results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_labels(
  object,
  strategy = "strategy_name",
  grp = "grp_name",
  state = "state_name",
  transition = "transition_name",
  death_label = "Death"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_labels_+3A_object">object</code></td>
<td>
<p>An object of class <code>hesim_data</code> created with <code><a href="#topic+hesim_data">hesim_data()</a></code>.</p>
</td></tr>
<tr><td><code id="get_labels_+3A_strategy">strategy</code></td>
<td>
<p>The name of the column in the <code>strategy</code> element of <code>object</code>
containing labels for <code>strategy_id</code>.</p>
</td></tr>
<tr><td><code id="get_labels_+3A_grp">grp</code></td>
<td>
<p>The name of the column in the <code>patient</code> element of <code>object</code>
containing labels for <code>grp_id</code>.</p>
</td></tr>
<tr><td><code id="get_labels_+3A_state">state</code></td>
<td>
<p>The name of the column in the <code>state</code> element of <code>object</code>
containing labels for <code>state_id</code>.</p>
</td></tr>
<tr><td><code id="get_labels_+3A_transition">transition</code></td>
<td>
<p>The name of the column in the <code>transition</code> element of <code>object</code>
containing labels for <code>transition_id</code>.</p>
</td></tr>
<tr><td><code id="get_labels_+3A_death_label">death_label</code></td>
<td>
<p>The label to use for the death health state. By default a
label named &quot;Death&quot; will be concatenated to the labels for the non-death health
states. The death state can be omitted from labels for the health states by setting
<code>death_label = NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the names
are the labels. The names of the list are the names of the ID variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hesim_data">hesim_data()</a></code>, <code><a href="#topic+set_labels">set_labels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
strategies &lt;- data.table(
  strategy_id = c(1, 2),
  strategy_name = c("Strategy 1", "Strategy 2")
)
patients &lt;- data.table(
  patient_id = seq(1, 4),
  age = c(50, 55, 60, 65),
  grp_id = c(1, 1, 2, 2),
  grp_name = rep(c("Age 50-59", "Age 60-69"), each = 2)
)
states &lt;- data.table(
  state_id =  seq(1, 2),
  state_name = c("State 1", "State 2")
)
hesim_dat &lt;- hesim_data(
  strategies = strategies,
  patients = patients,
  states = states
)
labs &lt;- get_labels(hesim_dat)
labs

# Pass to set_labels()
d &lt;- data.table(strategy_id = c(1, 1, 2, 2),
                grp_id = c(1, 2, 1, 2))
set_labels(d, labs, new_name = c("strategy_name", "grp_name"))
d
</code></pre>

<hr>
<h2 id='hesim'>hesim: Health Economic Simulation Modeling and Decision Analysis</h2><span id='topic+hesim'></span><span id='topic+hesim-package'></span>

<h3>Description</h3>

<p>To learn more about <code>hesim</code> visit the <a href="https://hesim-dev.github.io/hesim/">website</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Devin Incerti <a href="mailto:devin.incerti@gmail.com">devin.incerti@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jeroen P. Jansen
</p>
</li>
<li><p> Mark Clements
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> R Core Team (hesim uses some slightly modified C functions from base R) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://hesim-dev.github.io/hesim/">https://hesim-dev.github.io/hesim/</a>
</p>
</li>
<li> <p><a href="https://github.com/hesim-dev/hesim">https://github.com/hesim-dev/hesim</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hesim-dev/hesim/issues">https://github.com/hesim-dev/hesim/issues</a>
</p>
</li></ul>


<hr>
<h2 id='hesim_data'>Data for health economic simulation modeling</h2><span id='topic+hesim_data'></span>

<h3>Description</h3>

<p>A list of tables required for health economic simulation modeling. This object
is used to setup models by defining the treatment strategies, target population,
and model structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hesim_data(strategies, patients, states = NULL, transitions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hesim_data_+3A_strategies">strategies</code></td>
<td>
<p>A table of treatment strategies. Must contain the column
<code>strategy_id</code> denoting a unique strategy. Other columns are variables
describing the characteristics of a treatment strategy.</p>
</td></tr>
<tr><td><code id="hesim_data_+3A_patients">patients</code></td>
<td>
<p>A table of patients. Must contain the column <code>patient_id</code> denoting
a unique patient. The number of rows should be equal to the number of patients
in the model. The table may also include columns for <code>grp_id</code> for subgroups and
<code>patient_wt</code> specifying the weight to apply to each patient (within a subgroup).
If <code>grp_id</code> is <code>NULL</code>, then it is assumed that there is only one subgroup. If
<code>patient_wt</code> is <code>NULL</code>. then each patient is given the same weight. Weights
cannot be used in individual-level models because each patient should be
weighted equally; that is, weights can only be specified in cohort models.
Weights within subgroups are normalized to sum to one. Other columns are
variables describing the characteristics of a patient.</p>
</td></tr>
<tr><td><code id="hesim_data_+3A_states">states</code></td>
<td>
<p>A table of health states. Must contain the column
<code>state_id</code>, which denotes a unique health state. The number of rows should
be equal to the number of health states in the model. Other columns can describe the
characteristics of a health state.</p>
</td></tr>
<tr><td><code id="hesim_data_+3A_transitions">transitions</code></td>
<td>
<p>A table of health state transitions. Must contain the column
<code>transition_id</code>, which denotes a unique transition; <code>from</code>, which denotes
the starting health state; and <code>to</code> which denotes the state that will be
transitioned to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>hesim_data</code>, which is a list of data tables for
health economic simulation modeling.
</p>


<h3>Note</h3>

<p>Each table must either be a <code>data.frame</code> or <code>data.table</code>. All ID variables
within each table must be numeric vectors of integers and should be of the form
1,2,...N where N is the number of unique values of the ID variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>, <code><a href="#topic+get_labels">get_labels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3), age = c(65, 50, 75),
                       gender = c("Female", "Female", "Male"))
states &lt;- data.frame(state_id =  seq(1, 3),
                     state_var = c(2, 1, 9))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)
</code></pre>

<hr>
<h2 id='hesim_survdists'>List of survival distributions</h2><span id='topic+hesim_survdists'></span>

<h3>Description</h3>

<p>List of additional distributions for parametric survival analysis that are
not contained in <code><a href="flexsurv.html#topic+flexsurv-package">flexsurv</a></code>. Can be used to fit models with
<code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurvreg()</a></code>. Same format as <code><a href="flexsurv.html#topic+flexsurvreg">flexsurv::flexsurv.dists</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hesim_survdists
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>name</dt><dd><p>Name of the probability distribution.</p>
</dd>
<dt>pars</dt><dd><p>Vector of strings naming the parameters of the distribution.
These must be the same names as the arguments of the density and probability functions.</p>
</dd>
<dt>location</dt><dd><p>Name of the location parameter.</p>
</dd>
<dt>transforms</dt><dd><p>List of R functions which transform the range of values
taken by each parameter onto the real line. For example,
<code>c(log, log)</code> for a distribution with two positive parameters.</p>
</dd>
<dt>inv.transforms</dt><dd><p>List of R functions defining the corresponding inverse
transformations. Note these must be lists, even for single parameter
distributions they should be supplied as, e.g. <code>c(exp) or list(exp)</code>.</p>
</dd>
<dt>inits</dt><dd><p>A function of the observed survival times <code>t</code> (including
right-censoring times, and using the halfway point for interval-censored times)
which returns a vector of reasonable initial values for maximum likelihood
estimation of each parameter. For example, <code>function(t){ c(1, mean(t)) }</code>
will always initialize the first of two parameters at 1, and the second
(a scale parameter, for instance) at the mean of <code>t</code>.</p>
</dd>
</dl>


<hr>
<h2 id='icea'>Individualized cost-effectiveness analysis</h2><span id='topic+icea'></span><span id='topic+icea_pw'></span>

<h3>Description</h3>

<p>These functions are deprecated, use <code><a href="#topic+cea">cea()</a></code> and <code><a href="#topic+cea_pw">cea_pw()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icea(x, ...)

icea_pw(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icea_+3A_x">x</code></td>
<td>
<p>An object of simulation output characterizing the probability distribution
of clinical effectiveness and costs.?ic</p>
</td></tr>
<tr><td><code id="icea_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='icer'>Incremental cost-effectiveness ratio</h2><span id='topic+icer'></span><span id='topic+format.icer'></span>

<h3>Description</h3>

<p>Generate a tidy table of incremental cost-effectiveness ratios (ICERs) given output from
<code><a href="#topic+cea_pw">cea_pw()</a></code> with <code>icer()</code> and format for pretty printing with <code>format.icer()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icer(x, prob = 0.95, k = 50000, labels = NULL, ...)

## S3 method for class 'icer'
format(
  x,
  digits_qalys = 2,
  digits_costs = 0,
  pivot_from = "strategy",
  drop_grp = TRUE,
  pretty_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icer_+3A_x">x</code></td>
<td>
<p>An object of class <code>cea_pw</code> returned by <code><a href="#topic+cea_pw">cea_pw()</a></code>.</p>
</td></tr>
<tr><td><code id="icer_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval <code style="white-space: pre;">&#8288;(0,1)&#8288;</code> giving the confidence interval.
Default is 0.95 for a 95 percent interval.</p>
</td></tr>
<tr><td><code id="icer_+3A_k">k</code></td>
<td>
<p>Willingness to pay per quality-adjusted life-year.</p>
</td></tr>
<tr><td><code id="icer_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
<tr><td><code id="icer_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods. Currently unused.</p>
</td></tr>
<tr><td><code id="icer_+3A_digits_qalys">digits_qalys</code></td>
<td>
<p>Number of digits to use to report QALYs.</p>
</td></tr>
<tr><td><code id="icer_+3A_digits_costs">digits_costs</code></td>
<td>
<p>Number of digits to use to report costs.</p>
</td></tr>
<tr><td><code id="icer_+3A_pivot_from">pivot_from</code></td>
<td>
<p>Character vector denoting a column or columns used to
&quot;widen&quot; the data. Should either be <code>"strategy"</code>, <code>"grp"</code>, <code>"outcome"</code>,
or some combination of the three. There will be one column for each value of
the variables in <code>pivot_from</code>. Default is to widen so there is a column for each treatment
strategy. Set to <code>NULL</code> if you do not want to widen the table.</p>
</td></tr>
<tr><td><code id="icer_+3A_drop_grp">drop_grp</code></td>
<td>
<p>If <code>TRUE</code>, then the group column will be removed if there is only
one subgroup; other it will be kept. If <code>FALSE</code>, then the <code>grp</code> column is never
removed.</p>
</td></tr>
<tr><td><code id="icer_+3A_pretty_names">pretty_names</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the columns <code>strategy</code>, <code>grp</code>,
<code>outcome</code>, and <code>value</code> are renamed (if they exist) to <code>Strategy</code>,
<code>Group</code>, <code>Outcome</code>, and <code>Value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>icer()</code> will report negative ICERs; however, <code>format()</code> will
correctly note whether a treatment strategy is dominated by or dominates the
reference treatment.
</p>


<h3>Value</h3>

<p><code>icer()</code> returns an object of class <code>icer</code> that is a tidy
<code>data.table</code> with the following columns:
</p>

<dl>
<dt>strategy</dt><dd><p>The treatment strategy.</p>
</dd>
<dt>grp</dt><dd><p>The subgroup.</p>
</dd>
<dt>outcome</dt><dd><p>The outcome metric.</p>
</dd>
<dt>estimate</dt><dd><p>The point estimate computed as the average across the PSA samples.</p>
</dd>
<dt>lower</dt><dd><p>The lower limit of the confidence interval.</p>
</dd>
<dt>upper</dt><dd><p>The upper limit of the confidence interval.</p>
</dd>
</dl>

<p><code>format.icer()</code> formats the table according to the arguments passed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cea_pw">cea_pw()</a></code>
</p>

<hr>
<h2 id='icer_tbl'>ICER table</h2><span id='topic+icer_tbl'></span>

<h3>Description</h3>

<p>Generate a table of incremental cost-effectiveness ratios given output from
<code><a href="#topic+cea_pw">cea_pw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icer_tbl(
  x,
  k = 50000,
  cri = TRUE,
  prob = 0.95,
  digits_qalys = 2,
  digits_costs = 0,
  output = c("matrix", "data.table"),
  rownames = NULL,
  colnames = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icer_tbl_+3A_x">x</code></td>
<td>
<p>An object of class <code>cea_pw</code> returned by <code><a href="#topic+cea_pw">cea_pw()</a></code>.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_k">k</code></td>
<td>
<p>Willingness to pay.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_cri">cri</code></td>
<td>
<p>If <code>TRUE</code>, credible intervals are computed; otherwise
they are not.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval <code style="white-space: pre;">&#8288;(0,1)&#8288;</code> giving the credible interval.
Default is 0.95 for a 95 percent credible interval.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_digits_qalys">digits_qalys</code></td>
<td>
<p>Number of digits to use to report QALYs.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_digits_costs">digits_costs</code></td>
<td>
<p>Number of digits to use to report costs.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_output">output</code></td>
<td>
<p>Should output be a <code>data.table</code> or a list of matrices for
each group.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_rownames">rownames</code></td>
<td>
<p>Row names for matrices when <code>output = "matrix"</code>.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_colnames">colnames</code></td>
<td>
<p>Column names for matrices when <code>output = "matrix"</code>.</p>
</td></tr>
<tr><td><code id="icer_tbl_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, then the result is coerced to the lowest possible dimension.
Relevant if <code>output = "matrix"</code> and there is one group, in which case a single
matrix will be returned if <code>drop = TRUE</code> and a list of length 1 will be returned
if <code>drop = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output = "matrix"</code>, then a list of matrices (or a matrix if
<code>drop = TRUE</code>) reporting incremental cost-effectiveness ratios (ICERs)
by group. Specifically, each matrix contains five rows for: (i)
incremental quality-adjusted life-years (QALYs), (ii) incremental costs,
(iii) the incremental net monetary benefit (NMB), (iv) the ICER,
and (v) a conclusion stating whether each strategy is cost-effective relative
to a comparator. The number of columns is equal to the
number of strategies (including the comparator).
</p>
<p>If <code>output = "data.table"</code>, then the results are reported as a <code>data.table</code>,
with one row for each strategy and group combination.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cea_pw">cea_pw()</a></code>
</p>

<hr>
<h2 id='id_attributes'>Attributes for ID variables</h2><span id='topic+id_attributes'></span>

<h3>Description</h3>

<p>Stores metadata related to the ID variables used to index <a href="#topic+input_mats">input_mats</a>
and <a href="#topic+tparams">transformed parameter objects</a> already predicted from covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_attributes(
  strategy_id,
  n_strategies,
  patient_id,
  n_patients,
  state_id = NULL,
  n_states = NULL,
  transition_id = NULL,
  n_transitions = NULL,
  time_id = NULL,
  time_intervals = NULL,
  n_times = NULL,
  sample = NULL,
  n_samples = NULL,
  grp_id = NULL,
  patient_wt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_attributes_+3A_strategy_id">strategy_id</code></td>
<td>
<p>A numeric vector of integers denoting the treatment strategy.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_strategies">n_strategies</code></td>
<td>
<p>A scalar denoting the number of unique treatment strategies.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_patient_id">patient_id</code></td>
<td>
<p>A numeric vector of integers denoting the patient.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_patients">n_patients</code></td>
<td>
<p>A scalar denoting the number of unique patients.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_state_id">state_id</code></td>
<td>
<p>A numeric vector of integers denoting the health state.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_states">n_states</code></td>
<td>
<p>A scalar denoting the number of unique health states.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_transition_id">transition_id</code></td>
<td>
<p>A numeric vector denoting the
health state transition. This is only used for state transition models.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_transitions">n_transitions</code></td>
<td>
<p>A scalar denoting the number of unique transitions.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_time_id">time_id</code></td>
<td>
<p>A numeric vector of integers denoting a unique time interval.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_time_intervals">time_intervals</code></td>
<td>
<p>A <code>data.table</code> denoting unique time intervals. Must
contain the columns <code>time_id</code>, <code>time_start</code>, and <code>time_stop</code>.
<code>time_start</code> is the starting time of an interval and <code>time_stop</code> is
the stopping time of an interval. Following the <a href="survival.html#topic+tmerge">survival</a> package,
time intervals are closed on the right and
open on the left (except in the final interval where <code>time_stop</code> is equal to
infinity).</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_times">n_times</code></td>
<td>
<p>A scalar denoting the number of time intervals. Equal to the
number of rows in <code>time_intervals</code>.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_sample">sample</code></td>
<td>
<p>A numeric vector of integer denoting the sample from the posterior
distribution of the parameters.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_n_samples">n_samples</code></td>
<td>
<p>A scalar denoting the number of samples.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_grp_id">grp_id</code></td>
<td>
<p>An optional numeric vector of integers denoting the subgroup.</p>
</td></tr>
<tr><td><code id="id_attributes_+3A_patient_wt">patient_wt</code></td>
<td>
<p>An optional numeric vector denoting the weight to apply to each patient
within a subgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the ID variables to index <a href="#topic+input_mats">input_mats</a>, the sorting order
should be the same as specified in <code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>; that is,
observations must be sorted by prioritizing: (i) <code>strategy_id</code>, (ii) <code>patient_id</code>,
(iii) the health-related ID variable (either <code>state_id</code> or <code>transition_id</code>),
and (iv) <code>time_id</code>. When using ID variables are used to index transformed parameter
objects and <code>sample</code> is used for indexing, then observations must be sorted by
prioritizing: (i) <code>sample</code>, (ii) <code>strategy_id</code>, (iii) <code>patient_id</code>,
(iv) the health-related ID variable, and (v) <code>time_id</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hesim_data">hesim_data()</a></code>,<code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>, <a href="#topic+input_mats">input_mats</a>
</p>

<hr>
<h2 id='incr_effect'>Incremental treatment effect</h2><span id='topic+incr_effect'></span>

<h3>Description</h3>

<p>Computes incremental effect for all treatment strategies
on outcome variables from a probabilistic sensitivity analysis relative to a comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr_effect(x, comparator, sample, strategy, grp = NULL, outcomes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incr_effect_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> containing simulation output with
information on outcome variables for each randomly sampled parameter set from
a PSA. Each row should denote a randomly sampled parameter set
and treatment strategy.</p>
</td></tr>
<tr><td><code id="incr_effect_+3A_comparator">comparator</code></td>
<td>
<p>The comparator strategy. If the strategy column is a character
variable, then must be a character; if the strategy column is an integer variable,
then must be an integer.</p>
</td></tr>
<tr><td><code id="incr_effect_+3A_sample">sample</code></td>
<td>
<p>Character name of column denoting a randomly sampled parameter set.</p>
</td></tr>
<tr><td><code id="incr_effect_+3A_strategy">strategy</code></td>
<td>
<p>Character name of column denoting treatment strategy.</p>
</td></tr>
<tr><td><code id="incr_effect_+3A_grp">grp</code></td>
<td>
<p>Character name of column denoting subgroup. If <code>NULL</code>, then
it is assumed that there is only one group.</p>
</td></tr>
<tr><td><code id="incr_effect_+3A_outcomes">outcomes</code></td>
<td>
<p>Name of columns to compute incremental changes for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the differences in the values of each variable
specified in outcomes between each treatment strategy and the
comparator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulation output
n_samples &lt;- 100
sim &lt;- data.frame(sample = rep(seq(n_samples), 4),
             c = c(rlnorm(n_samples, 5, .1), rlnorm(n_samples, 5, .1),
                    rlnorm(n_samples, 11, .1), rlnorm(n_samples, 11, .1)),
             e = c(rnorm(n_samples, 8, .2), rnorm(n_samples, 8.5, .1),
                   rnorm(n_samples, 11, .6), rnorm(n_samples, 11.5, .6)),
             strategy = rep(paste0("Strategy ", seq(1, 2)),
                           each = n_samples * 2),
             grp = rep(rep(c("Group 1", "Group 2"),
                           each = n_samples), 2)
)
# calculate incremental effect of Strategy 2 relative to Strategy 1 by group
ie &lt;- incr_effect(sim, comparator = "Strategy 1", sample = "sample",
                        strategy = "strategy", grp = "grp", outcomes = c("c", "e"))
head(ie)
</code></pre>

<hr>
<h2 id='IndivCtstm'>Individual-level continuous time state transition model</h2><span id='topic+IndivCtstm'></span>

<h3>Description</h3>

<p>Simulate outcomes from an individual-level continuous time state transition
model (CTSTM). The class supports &quot;clock-reset&quot;
(i.e., semi-Markov), &quot;clock-forward&quot; (i.e., Markov), and mixtures of
clock-reset and clock-forward multi-state models as described in
<code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>trans_model</code></dt><dd><p>The model for health state transitions. Must be an object
of class <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The model for health state utility. Must be an object of
class <code><a href="#topic+StateVals">StateVals</a></code>.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The models used to predict costs by health state.
Must be a list of objects of class <code><a href="#topic+StateVals">StateVals</a></code>, where each element of the
list represents a different cost category.</p>
</dd>
<dt><code>disprog_</code></dt><dd><p>An object of class <code><a href="#topic+disprog">disprog</a></code>.</p>
</dd>
<dt><code>stateprobs_</code></dt><dd><p>An object of class <code><a href="#topic+stateprobs">stateprobs</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_stateprobs()&#8288;</code>.</p>
</dd>
<dt><code>qalys_</code></dt><dd><p>An object of class <code><a href="#topic+qalys">qalys</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_qalys()&#8288;</code>.</p>
</dd>
<dt><code>costs_</code></dt><dd><p>An object of class <code><a href="#topic+costs">costs</a></code> simulated using <code style="white-space: pre;">&#8288;$sim_costs()&#8288;</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IndivCtstm-new"><code>IndivCtstm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-sim_disease"><code>IndivCtstm$sim_disease()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-sim_stateprobs"><code>IndivCtstm$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-sim_qalys"><code>IndivCtstm$sim_qalys()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-sim_costs"><code>IndivCtstm$sim_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-summarize"><code>IndivCtstm$summarize()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstm-clone"><code>IndivCtstm$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IndivCtstm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>IndivCtstm</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$new(trans_model = NULL, utility_model = NULL, cost_models = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>trans_model</code></dt><dd><p>The <code>trans_model</code> field.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The <code>utility_model</code> field.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The <code>cost_models</code> field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>IndivCtstm</code> object.
</p>


<hr>
<a id="method-IndivCtstm-sim_disease"></a>



<h4>Method <code>sim_disease()</code></h4>

<p>Simulate disease progression (i.e., individual trajectories through a multi-state
model) using <code>IndivCtstmTrans$sim_disease()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$sim_disease(max_t = 100, max_age = 100, progress = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_t</code></dt><dd><p>A scalar or vector denoting the length of time to simulate the model.
If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>max_age</code></dt><dd><p>A scalar or vector denoting the maximum age to simulate each patient until.
If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>progress</code></dt><dd><p>An integer, specifying the PSA iteration (i.e., sample) that should be
printed every <code>progress</code> PSA iterations. For example, if <code>progress = 2</code>,
then every second PSA iteration is printed. Default is <code>NULL</code>,
in which case no output is printed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of self with simulated output stored in <code>disprog_</code>.
</p>


<hr>
<a id="method-IndivCtstm-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code></h4>

<p>Simulate health state probabilities as a function of time using the
simulation output stored in <code>disprog</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$sim_stateprobs(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <code><a href="#topic+stateprobs">stateprobs</a></code>
stored in <code>stateprobs_</code>.
</p>


<hr>
<a id="method-IndivCtstm-sim_qalys"></a>



<h4>Method <code>sim_qalys()</code></h4>

<p>Simulate quality-adjusted life-years (QALYs) as a function of <code>disprog_</code> and
<code>utility_model</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$sim_qalys(
  dr = 0.03,
  type = c("predict", "random"),
  lys = TRUE,
  by_patient = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>type</code></dt><dd><p><code>"predict"</code> for mean values or <code>"random"</code> for random samples
as in <code style="white-space: pre;">&#8288;$sim()&#8288;</code> in <code><a href="#topic+StateVals">StateVals</a></code>.</p>
</dd>
<dt><code>lys</code></dt><dd><p>If <code>TRUE</code>, then life-years are simulated in addition to QALYs.</p>
</dd>
<dt><code>by_patient</code></dt><dd><p>If <code>TRUE</code>, then QALYs and/or costs are computed at the patient level.
If <code>FALSE</code>, then they are averaged across patients by health state.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of
class <a href="#topic+qalys">qalys</a> stored in <code>qalys_</code>.
</p>


<hr>
<a id="method-IndivCtstm-sim_costs"></a>



<h4>Method <code>sim_costs()</code></h4>

<p>Simulate costs as a function of <code>disprog_</code> and <code>cost_models</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$sim_costs(
  dr = 0.03,
  type = c("predict", "random"),
  by_patient = FALSE,
  max_t = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>type</code></dt><dd><p><code>"predict"</code> for mean values or <code>"random"</code> for random samples
as in <code style="white-space: pre;">&#8288;$sim()&#8288;</code> in <code><a href="#topic+StateVals">StateVals</a></code>.</p>
</dd>
<dt><code>by_patient</code></dt><dd><p>If <code>TRUE</code>, then QALYs and/or costs are computed at the patient level.
If <code>FALSE</code>, then they are averaged across patients by health state.</p>
</dd>
<dt><code>max_t</code></dt><dd><p>Maximum time duration to compute costs once a patient has
entered a (new) health state. By default, equal to <code>Inf</code>,
so that costs are computed over the entire duration that a patient is in
a given health state. If time varies by each cost category, then time
can also be passed as a numeric vector of length equal to the number of
cost categories (e.g., <code>c(1, 2, Inf, 3)</code> for a model with four cost categories).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+costs">costs</a>
stored in <code>costs_</code>.
</p>


<hr>
<a id="method-IndivCtstm-summarize"></a>



<h4>Method <code>summarize()</code></h4>

<p>Summarize costs and QALYs so that cost-effectiveness analysis can be performed.
See <code><a href="#topic+summarize_ce">summarize_ce()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$summarize(by_grp = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>by_grp</code></dt><dd><p>If <code>TRUE</code>, then costs and QALYs are computed by subgroup. If
<code>FALSE</code>, then costs and QALYs are aggregated across all patients (and subgroups).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-IndivCtstm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.2 for a mathematical description of an individual-level CTSTM and Section 4.1 for
an example in oncology.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code> documentation
describes the class for the transition model and the <code><a href="#topic+StateVals">StateVals</a></code> documentation
describes the class for the cost and utility models. An <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>
object is typically created using <code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code>.
</p>
<p>There are currently two relevant vignettes. <code>vignette("mstate")</code> shows how to
parameterize <code>IndivCtstmTrans</code> objects in cases where patient-level data is
available by fitting a multi-state models. <code>vignette("markov-inhomogeneous-indiv")</code>
shows how the time inhomogeneous Markov cohort model in
<code>vignette("markov-inhomogeneous-cohort")</code> can be developed as an individual
patient simulation; in doing so, it shows how <code>IndivCtstm</code> models can be
used even without access to patient-level data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")

# Treatment strategies, target population, and model structure
strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       age = c(45, 50, 60),
                       female = c(0, 0, 1))
states &lt;- data.frame(state_id = c(1, 2))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)

# Parameter estimation
## Multi-state model
tmat &lt;- rbind(c(NA, 1, 2),
              c(3, NA, 4),
              c(NA, NA, NA))
fits &lt;- vector(length = max(tmat, na.rm = TRUE), mode = "list")
surv_dat &lt;- data.frame(mstate3_exdata$transitions)
for (i in 1:length(fits)){
  fits[[i]] &lt;- flexsurvreg(Surv(years, status) ~ factor(strategy_id),
                           data = surv_dat,
                           subset = (trans == i),
                           dist = "weibull")
}
fits &lt;- flexsurvreg_list(fits)

## Utility
utility_tbl &lt;- stateval_tbl(data.frame(state_id = states$state_id,
                                       mean = mstate3_exdata$utility$mean,
                                       se = mstate3_exdata$utility$se),
                            dist = "beta")
## Costs
drugcost_tbl &lt;- stateval_tbl(data.frame(strategy_id = strategies$strategy_id,
                                        est = mstate3_exdata$costs$drugs$costs),
                             dist = "fixed")
medcost_tbl &lt;- stateval_tbl(data.frame(state_id = states$state_id,
                                       mean = mstate3_exdata$costs$medical$mean,
                                       se = mstate3_exdata$costs$medical$se),
                            dist = "gamma")

# Economic model
n_samples = 2

## Construct model
### Transitions
transmod_data &lt;- expand(hesim_dat)
transmod &lt;- create_IndivCtstmTrans(fits, input_data = transmod_data,
                                   trans_mat = tmat,
                                   n = n_samples)

### Utility
utilitymod &lt;- create_StateVals(utility_tbl, n = n_samples, hesim_data = hesim_dat)

### Costs
drugcostmod &lt;- create_StateVals(drugcost_tbl, n = n_samples, hesim_data = hesim_dat)
medcostmod &lt;- create_StateVals(medcost_tbl, n = n_samples, hesim_data = hesim_dat)
costmods &lt;- list(drugs = drugcostmod,
                 medical = medcostmod)

### Combine
ictstm &lt;- IndivCtstm$new(trans_model = transmod,
                         utility_model = utilitymod,
                         cost_models = costmods)


## Simulate outcomes
head(ictstm$sim_disease()$disprog_)
head(ictstm$sim_stateprobs(t = c(0, 5, 10))$stateprobs_[t == 5])
ictstm$sim_qalys(dr = .03)
ictstm$sim_costs(dr = .03)

### Summarize cost-effectiveness
ce &lt;- ictstm$summarize()
head(ce)
format(summary(ce), pivot_from = "strategy")
</code></pre>

<hr>
<h2 id='IndivCtstmTrans'>Transitions for an individual-level continuous time state transition model</h2><span id='topic+IndivCtstmTrans'></span>

<h3>Description</h3>

<p>Simulate health state transitions in an individual-level continuous time state
transition model using parameters from a multi-state model.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CtstmTrans">hesim::CtstmTrans</a></code> -&gt; <code>IndivCtstmTrans</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>params</code></dt><dd><p>An object of class <code><a href="#topic+params_surv">params_surv</a></code> or <code><a href="#topic+params_surv_list">params_surv_list</a></code>.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>Input data used to simulate health state transitions
by sample from the probabilistic sensitivity analysis (PSA), treatment strategy and patient.
Must be an object of class <code><a href="#topic+input_mats">input_mats</a></code>. If <code>params</code> contains parameters from
a list of models (i.e., of class <code><a href="#topic+params_surv_list">params_surv_list</a></code>), then <code>input_data</code>
must contain a unique row for each treatment strategy
and patient; if <code>params</code> contains parameters from a joint model
(i.e., of class <code><a href="#topic+params_surv">params_surv</a></code>), then <code>input_data</code> must contain a unique
row for each treatment strategy, patient, and transition.</p>
</dd>
<dt><code>trans_mat</code></dt><dd><p>A transition matrix describing the states and transitions
in a multi-state model in the format from the <code><a href="mstate.html#topic+mstate-package">mstate</a></code> package.
See the documentation for the argument <code>"trans"</code> in <code><a href="mstate.html#topic+msprep">mstate::msprep</a></code>.</p>
</dd>
<dt><code>start_state</code></dt><dd><p>A scalar or vector denoting the starting health state.
Default is the first health state. If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>start_age</code></dt><dd><p>A scalar or vector denoting the starting age of each patient
in the simulation. Default is 38. If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>death_state</code></dt><dd><p>The death state in <code>trans_mat</code>. Used with <code>max_age</code>
in <code>sim_disease</code> as patients transition to this state upon reaching maximum age.
By default, it is set to the final absorbing state (i.e., a row in <code>trans_mat</code> with all NAs).</p>
</dd>
<dt><code>clock</code></dt><dd><p>&quot;reset&quot; for a clock-reset model, &quot;forward&quot; for a clock-forward model,
&quot;mix&quot; for a mixture of clock-reset and clock-forward models by state, and
&quot;mixt&quot; for a mixture of clock-reset and clock-forward models by transition. A clock-reset model
is a semi-Markov model in which transition rates depend on time since entering a state.
A clock-forward model is a Markov model in which transition rates depend on time
since entering the initial state. If <code>"mix"</code> is used, then
<code>reset_states</code> must be specified. If <code>"mixt"</code> is used, then <code>transition_types</code> must
be specified.</p>
</dd>
<dt><code>reset_states</code></dt><dd><p>A vector denoting the states in which time resets.
Hazard functions are always a function of elapsed time since either the
start of the model or from when time was previously reset. Only used if
<code>clock = "mix"</code>.</p>
</dd>
<dt><code>transition_types</code></dt><dd><p>A vector denoting the type of transition.
The vector is of the same length as the number of transitions
and takes values <code>"reset"</code>, <code>"time"</code> or <code>"age"</code> for hazards that are functions of
reset time, time since study entry or age, respectively. Only used if
<code>clock = "mixt"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IndivCtstmTrans-new"><code>IndivCtstmTrans$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstmTrans-sim_disease"><code>IndivCtstmTrans$sim_disease()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstmTrans-sim_stateprobs"><code>IndivCtstmTrans$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstmTrans-check"><code>IndivCtstmTrans$check()</code></a>
</p>
</li>
<li> <p><a href="#method-IndivCtstmTrans-clone"><code>IndivCtstmTrans$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="hesim" data-topic="CtstmTrans" data-id="cumhazard"><a href='../../hesim/html/CtstmTrans.html#method-CtstmTrans-cumhazard'><code>hesim::CtstmTrans$cumhazard()</code></a></span></li>
<li><span class="pkg-link" data-pkg="hesim" data-topic="CtstmTrans" data-id="hazard"><a href='../../hesim/html/CtstmTrans.html#method-CtstmTrans-hazard'><code>hesim::CtstmTrans$hazard()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-IndivCtstmTrans-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>IndivCtstmTrans</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstmTrans$new(
  params,
  input_data,
  trans_mat,
  start_state = 1,
  start_age = 38,
  death_state = NULL,
  clock = c("reset", "forward", "mix", "mixt"),
  reset_states = NULL,
  transition_types = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>The <code>params</code> field.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>The <code>input_data</code> field.</p>
</dd>
<dt><code>trans_mat</code></dt><dd><p>The <code>trans_mat</code> field.</p>
</dd>
<dt><code>start_state</code></dt><dd><p>The <code>start_state</code> field.</p>
</dd>
<dt><code>start_age</code></dt><dd><p>The <code>start_age</code> field.</p>
</dd>
<dt><code>death_state</code></dt><dd><p>The <code>death_state</code> field.</p>
</dd>
<dt><code>clock</code></dt><dd><p>The <code>clock</code> field.</p>
</dd>
<dt><code>reset_states</code></dt><dd><p>The <code>reset_states</code> field.</p>
</dd>
<dt><code>transition_types</code></dt><dd><p>The <code>transition_types</code> field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>IndivCtstmTrans</code> object.
</p>


<hr>
<a id="method-IndivCtstmTrans-sim_disease"></a>



<h4>Method <code>sim_disease()</code></h4>

<p>Simulate disease progression (i.e., individual trajectories through a
multi-state model using an individual patient simulation).
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstmTrans$sim_disease(max_t = 100, max_age = 100, progress = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_t</code></dt><dd><p>A scalar or vector denoting the length of time to simulate the model.
If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>max_age</code></dt><dd><p>A scalar or vector denoting the maximum age to simulate
each patient until. If a vector, must be equal to the number of simulated patients.</p>
</dd>
<dt><code>progress</code></dt><dd><p>An integer, specifying the PSA iteration (i.e., sample) that
should be printed every progress PSA iterations. For example, if progress = 2,
then every second PSA iteration is printed. Default is NULL, in which case
no output is printed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+disprog">disprog</a></code>.
</p>


<hr>
<a id="method-IndivCtstmTrans-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code></h4>

<p>Simulate health state probabilities from a <a href="#topic+disprog">disprog</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstmTrans$sim_stateprobs(t, disprog = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
<dt><code>disprog</code></dt><dd><p>A <a href="#topic+disprog">disprog</a> object. If
<code>NULL</code>, then this will be simulated prior to computing state probabilities
using <code>IndivCtstm$sim_disease()</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to <code>IndivCtstm$sim_disease()</code> if
<code>disprog = NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+stateprobs">stateprobs</a></code>.
</p>


<hr>
<a id="method-IndivCtstmTrans-check"></a>



<h4>Method <code>check()</code></h4>

<p>Input validation for class. Checks that fields are the correct type.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstmTrans$check()</pre></div>


<hr>
<a id="method-IndivCtstmTrans-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IndivCtstmTrans$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code>IndivCtstmTrans</code> objects are conveniently created from either
fitted models or parameter objects with <code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code>.
A complete economic model can be implemented with the <code><a href="#topic+IndivCtstm">IndivCtstm</a></code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")

# Simulation data
strategies &lt;- data.frame(strategy_id = c(1, 2, 3))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       age = c(45, 50, 60),
                       female = c(0, 0, 1))

# Multi-state model with transition specific models
tmat &lt;- rbind(c(NA, 1, 2),
              c(NA, NA, 3),
              c(NA, NA, NA))
fits &lt;- vector(length = max(tmat, na.rm = TRUE), mode = "list")
for (i in 1:length(fits)){
  fits[[i]] &lt;- flexsurvreg(Surv(years, status) ~ 1,
                           data = bosms3[bosms3$trans == i, ],
                           dist = "exp")
}
fits &lt;- flexsurvreg_list(fits)

# Simulation model
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients)
fits_data &lt;- expand(hesim_dat)
transmod &lt;- create_IndivCtstmTrans(fits, input_data = fits_data,
                                   trans_mat = tmat,
                                   n = 2)
head(transmod$hazard(c(1, 2, 3)))
head(transmod$cumhazard(c(1, 2, 3)))

## Simulate disease progression and state probabilities together
transmod$sim_stateprobs(t = c(0, 5, 10))[t == 5]

## Simulate disease progression and state probabilities separately
disprog &lt;- transmod$sim_disease(max_t = 10)
transmod$sim_stateprobs(t = c(0, 5, 10), disprog = disprog)[t == 5]
</code></pre>

<hr>
<h2 id='input_mats'>Input matrices for a statistical model</h2><span id='topic+input_mats'></span><span id='topic+as.data.table.input_mats'></span><span id='topic+print.input_mats'></span>

<h3>Description</h3>

<p>An object of class <code>input_mats</code> contains input matrices
for simulating a statistical model. Consists of (i) input matrices, <code>X</code>, and
(ii) <a href="#topic+id_attributes">metadata</a> used to index each matrix in <code>X</code>.
</p>
<p>Once created, an <code>input_mats</code> object can be converted
to a <code><a href="data.table.html#topic+data.table">data.table</a></code> with <code>as.data.table()</code>, which is a helpful way to check that
the object is as expected. The <code>print()</code> method summarizes the object and
prints it to the console.
</p>
<p>More details are provided under &quot;Details&quot; below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_mats(X, ...)

## S3 method for class 'input_mats'
as.data.table(x, ...)

## S3 method for class 'input_mats'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input_mats_+3A_x">X</code></td>
<td>
<p>A list of input matrices for predicting the values of each parameter
in a statistical model. May also be a list of lists of input matrices when a
list of separate models is fit (e.g., with <code><a href="#topic+flexsurvreg_list">flexsurvreg_list()</a></code>).</p>
</td></tr>
<tr><td><code id="input_mats_+3A_...">...</code></td>
<td>
<p>For <code>input_mats()</code>, arguments to pass to <code><a href="#topic+id_attributes">id_attributes()</a></code>. For <code>print()</code>,
arguments to pass to <code><a href="data.table.html#topic+print.data.table">print.data.table()</a></code>.</p>
</td></tr>
<tr><td><code id="input_mats_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+input_mats">input_mats</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>input_mats</code> objects are used with <code><a href="#topic+params">params</a></code> objects to simulate
disease models, cost models, and/or utility models. Each column of <code style="white-space: pre;">&#8288;$X&#8288;</code> contains
variables from the <code>params</code> object and a given row corresponds to a combination
of the ID variables. An input matrix must always have rows for the treatment
strategies (<code>strategy_id</code>) and patients (<code>patient_id</code>); it may optionally
have rows for health variables (<code>state_id</code> or <code>transition_id</code>) and time
intervals (<code>time_id</code>). The rows must be sorted by prioritizing (i) <code>strategy_id</code>,
(ii) <code>patient_id</code>, (iii) the health related ID variable
(either <code>state_id</code> or <code>transition_id</code>) and (iv) <code>time_id</code>.
</p>
<p>While <code>input_mats</code> objects can be created directly with <code><a href="#topic+input_mats">input_mats()</a></code>, it
is rarely a good idea to do so. They are typically created as the
<code>input_data</code> field when creating model objects (e.g., with
<code><a href="#topic+create_IndivCtstmTrans">create_IndivCtstmTrans()</a></code>, <code><a href="#topic+create_CohortDtstmTrans">create_CohortDtstmTrans()</a></code>, and
<code><a href="#topic+create_PsmCurves">create_PsmCurves()</a></code>). Internally, these functions
create the input matrices using <code><a href="#topic+create_input_mats">create_input_mats()</a></code> methods, which ensure
that they are in the correct format. Users may also use <code><a href="#topic+create_input_mats">create_input_mats()</a></code>
methods, but there is not usually a good reason to do so.
</p>
<p><code>as.data.table.input_mats()</code> will convert input matrices into a single
<code>data.table()</code> that column binds the ID variables and the unique combinations
of variables contained in the elements of <code style="white-space: pre;">&#8288;$X&#8288;</code>. <code>print.input_mats()</code> prints
a call to <code>as.data.table()</code> and provides additional information about the
ID variables.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans()</a></code> and <code><a href="#topic+PsmCurves">PsmCurves()</a></code> for examples in which the
<code>input_data</code> field of an instance of a model class is an <code>input_mats</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")

# Input matrices are typically created as part of model objects
# Let's illustrate with a partitioned survival model (PSM)

## Model setup
strategies &lt;- data.frame(strategy_id = c(1, 2),
                         new_strategy = c(0, 1))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       age = c(45, 47, 60),
                       female = c(1, 0, 0),
                       group = factor(c("Good", "Medium", "Poor")))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients)

## Create survival models for PSM
### Parameters
n &lt;- 2
survmod_params &lt;- params_surv_list(
  # Progression free survival (PFS) 
  pfs = params_surv(
    coefs = list(
      rate = data.frame(intercept = rnorm(n, log(1/5), 1),
                        new_strategy = rnorm(n, log(.8), 1))
      ),
    dist = "exp"
  ),
  
  # Overall survival (OS)
  os = params_surv(
    coefs = list(
      rate = data.frame(intercept = rnorm(n, log(1/10), 1))
    ),
    dist = "exp"
  )
)

### Input data
survmod_input_data &lt;- expand(hesim_dat)[, intercept := 1]

### Model object
survmod &lt;- create_PsmCurves(survmod_params, input_data = survmod_input_data)

## Inspect input data
survmod$input_data # Print "input_mats" object to console
as.data.table(survmod$input_data) # Convert "input_mats" object to data.table
</code></pre>

<hr>
<h2 id='lm_list'>List of <code>lm</code> objects</h2><span id='topic+lm_list'></span>

<h3>Description</h3>

<p>Combine <code><a href="stats.html#topic+lm">lm</a></code> objects into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_list_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="stats.html#topic+lm">lm</a></code>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>lm_list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dat &lt;- psm4_exdata$costs$medical
 lm_fits &lt;- lm_list(fit1 = stats::lm(costs ~ 1, data = dat), 
                    fit2 = stats::lm(costs ~ female, data = dat))
 class(lm_fits)
</code></pre>

<hr>
<h2 id='mom_beta'>Method of moments for beta distribution</h2><span id='topic+mom_beta'></span>

<h3>Description</h3>

<p>Compute the parameters <code>shape1</code> and <code>shape2</code> of the beta distribution
using method of moments given the mean and standard
deviation of the random variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom_beta(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom_beta_+3A_mean">mean</code></td>
<td>
<p>Mean of the random variable.</p>
</td></tr>
<tr><td><code id="mom_beta_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the random variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\mu</code> is the mean and
<code class="reqn">\sigma</code> is the standard deviation of the random variable, then the method
of moments estimates of the parameters <code>shape1</code> = <code class="reqn">\alpha &gt; 0</code> and
<code>shape2</code> = <code class="reqn">\beta &gt; 0</code> are:
</p>
<p style="text-align: center;"><code class="reqn">\alpha = \mu \left(\frac{\mu(1-\mu)}{\sigma^2}-1 \right)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\beta = (1 - \mu) \left(\frac{\mu(1-\mu)}{\sigma^2}-1 \right)</code>
</p>



<h3>Value</h3>

<p>A list containing the parameters <code>shape1</code> and <code>shape2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mom_beta(mean = .8, sd = .1)
# The function is vectorized.
mom_beta(mean = c(.6, .8), sd = c(.08, .1))

</code></pre>

<hr>
<h2 id='mom_gamma'>Method of moments for gamma distribution</h2><span id='topic+mom_gamma'></span>

<h3>Description</h3>

<p>Compute the shape and scale (or rate) parameters of the gamma distribution
using method of moments for the random variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom_gamma(mean, sd, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom_gamma_+3A_mean">mean</code></td>
<td>
<p>Mean of the random variable.</p>
</td></tr>
<tr><td><code id="mom_gamma_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the random variable.</p>
</td></tr>
<tr><td><code id="mom_gamma_+3A_scale">scale</code></td>
<td>
<p>Logical. If TRUE (default), then the scale parameter is returned; otherwise,
the rate parameter is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\mu</code> is the mean and
<code class="reqn">\sigma</code> is the standard deviation of the random variable, then the method
of moments estimates of the parameters <code>shape</code> = <code class="reqn">\alpha &gt; 0</code> and
<code>scale</code> = <code class="reqn">\theta &gt; 0</code> are:
</p>
<p style="text-align: center;"><code class="reqn">\theta = \frac{\sigma^2}{\mu}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\alpha = \frac{\mu}{\theta}</code>
</p>

<p>The inverse of the scale parameter, <code class="reqn">\beta = 1/\theta</code>, is the rate parameter.
</p>


<h3>Value</h3>

<p>If <code>scale = TRUE</code>, then a list containing the parameters <code>shape</code> and <code>scale</code>; otherwise,
if <code>scale = FALSE</code>, then a list containing the parameters <code>shape</code> and <code>rate</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mom_gamma(mean = 10000, sd = 2000)
# The function is vectorized.
mom_gamma(mean = c(8000, 10000), sd = c(1500, 2000))

</code></pre>

<hr>
<h2 id='mstate3_exdata'>Example data for a reversible 3-state multi-state model</h2><span id='topic+mstate3_exdata'></span>

<h3>Description</h3>

<p>Example multi-state data for parameterizing a continuous time state
transition model. Costs and utility
are also included to facilitate cost-effectiveness analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstate3_exdata
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>transitions</dt><dd><p>A data frame containing the times at which patient transitions between health states based
on the <a href="mstate.html#topic+Liver-cirrhosis-data">prothr</a> dataset from the <a href="mstate.html#topic+mstate-package">mstate</a> package.</p>
</dd>
<dt>costs</dt><dd><p>A list of data frames. The first data frame contains summary medical cost estimates and the
second data frame contains drug cost data.</p>
</dd>
<dt>utility</dt><dd><p>A data frame of summary utility estimates.</p>
</dd>
</dl>



<h3>Transitions data</h3>

<p>The data frame has the following columns:
</p>

<dl>
<dt>strategy_id</dt><dd><p>Treatment strategy identification number.</p>
</dd>
<dt>patient_id</dt><dd><p>Patient identification number.</p>
</dd>
<dt>age</dt><dd><p>Patient age (in years).</p>
</dd>
<dt>female</dt><dd><p>1 if a patient is female; 0 if male.</p>
</dd>
<dt>from</dt><dd><p>Starting state.</p>
</dd>
<dt>to</dt><dd><p>Receiving state.</p>
</dd>
<dt>trans</dt><dd><p>Transition number.</p>
</dd>
<dt>Tstart</dt><dd><p>Starting time.</p>
</dd>
<dt>Tstop</dt><dd><p>Transition time.</p>
</dd>
<dt>years</dt><dd><p>Elapsed years between <code>Tstart</code> and <code>Tstop</code>.</p>
</dd>
<dt>status</dt><dd><p>Status variable; 1=transition, 0=censored.</p>
</dd>
</dl>



<h3>Cost data</h3>

<p>The cost list contains two data frames. The first data frame contains
data on the drug costs associated with each treatment strategy.
</p>

<dl>
<dt>strategy_id</dt><dd><p>The treatment strategy identification number.</p>
</dd>
<dt>costs</dt><dd><p>Annualized drug costs.</p>
</dd>
</dl>

<p>The second data frame contains summary data on
medical costs by health state, and contains the following columns:
</p>

<dl>
<dt>state_id</dt><dd><p>The health state identification number.</p>
</dd>
<dt>mean</dt><dd><p>Mean costs.</p>
</dd>
<dt>se</dt><dd><p>Standard error of medical costs.</p>
</dd>
</dl>



<h3>Utility data</h3>

<p>The data frame has the following columns:
</p>

<dl>
<dt>state_id</dt><dd><p>The health state identification number.</p>
</dd>
<dt>mean</dt><dd><p>Mean utility</p>
</dd>
<dt>se</dt><dd><p>Standard error of utility</p>
</dd>
</dl>


<hr>
<h2 id='multinom_list'>List of <code>multinom</code> objects</h2><span id='topic+multinom_list'></span>

<h3>Description</h3>

<p>Combine <code>multinom</code> objects into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom_list_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="nnet.html#topic+multinom">multinom</a></code>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>multinom_list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library("nnet")
 library("data.table")
 trans_data &lt;- data.table(multinom3_exdata$transitions)
 dat_healthy &lt;- trans_data[state_from == "Healthy"]
 fit_healthy &lt;- multinom(state_to ~ strategy_name + female + age_cat + year_cat, 
                          data = dat_healthy)
 dat_sick &lt;- trans_data[state_from == "Sick"]
 dat_sick$state_to &lt;- droplevels(dat_sick$state_to)
 fit_sick &lt;- multinom(state_to ~ strategy_name + female + age_cat + year_cat, 
                      data = dat_sick)
 fits &lt;- multinom_list(healthy = fit_healthy, sick = fit_sick)
 class(fits)
</code></pre>

<hr>
<h2 id='multinom3_exdata'>Example data for a 3-state multinomial model</h2><span id='topic+multinom3_exdata'></span>

<h3>Description</h3>

<p>Example discrete time health state transitions data simulated using
multinomial logistic regression. Costs and utility
are also included to facilitate cost-effectiveness analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom3_exdata
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>transitions</dt><dd><p> A data frame containing patient transitions between health
states at discrete time intervals (i.e., on a yearly basis).</p>
</dd>
<dt>costs</dt><dd><p> A list of data frames. The first data frame contains
drug cost data and the second contains summary medical cost estimates.</p>
</dd>
<dt>utility</dt><dd><p> A data frame of summary utility estimates.</p>
</dd>
</dl>



<h3>Transitions data</h3>

<p>The data frame has the following columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>Patient identification number.</p>
</dd>
<dt>strategy_id</dt><dd><p>Treatment strategy identification number.</p>
</dd>
<dt>strategy_name</dt><dd><p>Treatment strategy name.</p>
</dd>
<dt>age</dt><dd><p>Patient age (in years).</p>
</dd>
<dt>age_cat</dt><dd><p>A factor variable with 3 age groups: (i) age less than 40,
(ii) age at least 40 and less than 60, and (iii) age at least 60.</p>
</dd>
<dt>female</dt><dd><p>1 if a patient is female; 0 if male.</p>
</dd>
<dt>year</dt><dd><p>The year since the start of data collection with the first year equal to 1.</p>
</dd>
<dt>state_from</dt><dd><p>State making a transition from.</p>
</dd>
<dt>state_to</dt><dd><p>State making a transition to.</p>
</dd>
<dt>year_cat</dt><dd><p>Factor variable for year with 3 categories: (i) year 3 and below, (ii)
year between 3 and 6, and (iii) year 7 and above.</p>
</dd>
</dl>



<h3>Cost data</h3>

<p>The cost list contains two data frames. The first data frame contains
data on the drug costs associated with each treatment strategy.
</p>

<dl>
<dt>strategy_id</dt><dd><p>The treatment strategy identification number.</p>
</dd>
<dt>strategy_name</dt><dd><p>The treatment strategy name.</p>
</dd>
<dt>costs</dt><dd><p>Annualized drug costs.</p>
</dd>
</dl>

<p>The second data frame contains summary data on
medical costs by health state, and contains the following columns:
</p>

<dl>
<dt>state_id</dt><dd><p>The health state identification number.</p>
</dd>
<dt>state_name</dt><dd><p>The name of the health state.</p>
</dd>
<dt>mean</dt><dd><p>Mean medical costs.</p>
</dd>
<dt>se</dt><dd><p>Standard error of medical costs.</p>
</dd>
</dl>



<h3>Utility data</h3>

<p>The data frame has the following columns:
</p>

<dl>
<dt>state_id</dt><dd><p>The health state identification number.</p>
</dd>
<dt>state_name</dt><dd><p>The name of the health state.</p>
</dd>
<dt>mean</dt><dd><p>Mean utility</p>
</dd>
<dt>se</dt><dd><p>Standard error of utility.</p>
</dd>
</dl>


<hr>
<h2 id='normboot'>Draw parameters of statistical model from multivariate normal distribution</h2><span id='topic+normboot'></span><span id='topic+normboot.msm'></span>

<h3>Description</h3>

<p><code>normboot</code> is a generic function for drawing parameters from a fitted
statistical model from their (asymptotic) multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normboot(object, B, ...)

## S3 method for class 'msm'
normboot(object, B = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normboot_+3A_object">object</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="normboot_+3A_b">B</code></td>
<td>
<p>Number of draws of the parameters.</p>
</td></tr>
<tr><td><code id="normboot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='onc3'>Multi-state oncology data for 3-state model</h2><span id='topic+onc3'></span>

<h3>Description</h3>

<p>Simulated 3-state dataset in oncology with three health states
(Stable, Progression, and Death) and three possible transitions (Stable -&gt;
Progression, Stable -&gt; Death, and Progression -&gt; Death).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onc3
</code></pre>


<h3>Format</h3>

<p>A <code>data.table</code> with the following columns:
</p>

<dl>
<dt>from</dt><dd><p>Health state making a transition from.</p>
</dd>
<dt>to</dt><dd><p>Health state making a transition to.</p>
</dd>
<dt>strategy_name</dt><dd><p>Standard of care (SOC), new treatment 1 (New 1), or
new treatment 2 (New 2).</p>
</dd>
<dt>female</dt><dd><p>1 if a patient is female; 0 if male.</p>
</dd>
<dt>age</dt><dd><p>Patient age (in years).</p>
</dd>
<dt>patient_id</dt><dd><p>Patient identification number.</p>
</dd>
<dt>time_start</dt><dd><p>Starting time.</p>
</dd>
<dt>time_stop</dt><dd><p>Stopping time.</p>
</dd>
<dt>status</dt><dd><p>Status indicator: 1=transition, 0=censored.</p>
</dd>
<dt>transition_id</dt><dd><p>Integer denoting transition: 1 = Stable -&gt; Progression,
2 = Stable -&gt; Death, 3 = Progression -&gt; Death.</p>
</dd>
<dt>strategy_id</dt><dd><p>Strategy identification number.</p>
</dd>
<dt>time</dt><dd><p>Elapsed years between <code>time_start</code> and <code>time_stop</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+onc3p">onc3p</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(onc3)
</code></pre>

<hr>
<h2 id='onc3p'>Multi-state panel oncology data for 3-state model</h2><span id='topic+onc3p'></span>

<h3>Description</h3>

<p>The same dataset as <a href="#topic+onc3">onc3</a> converted into a panel data format in which health
states are recorded at a finite series of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onc3p
</code></pre>


<h3>Format</h3>

<p>A <code>data.table</code> with the following columns:
</p>

<dl>
<dt>state</dt><dd><p>The name of the health state (Stable, Progression,
and Death).</p>
</dd>
<dt>strategy_name</dt><dd><p>Standard of care (SOC), new treatment 1 (New 1), or
new treatment 2 (New 2).</p>
</dd>
<dt>female</dt><dd><p>1 if a patient is female; 0 if male.</p>
</dd>
<dt>age</dt><dd><p>Patient age (in years).</p>
</dd>
<dt>patient_id</dt><dd><p>Patient identification number.</p>
</dd>
<dt>time</dt><dd><p>Time that <code>state</code> was recorded.</p>
</dd>
<dt>strategy_id</dt><dd><p>Strategy identification number.</p>
</dd>
<dt>state_id</dt><dd><p>The health state identification number.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+onc3">onc3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(onc3p)
</code></pre>

<hr>
<h2 id='params'>Parameter object</h2><span id='topic+params'></span>

<h3>Description</h3>

<p>Objects prefixed by &quot;params_&quot; are lists containing the parameters of a statistical model
used for simulation modeling. The parameters are used to simulate outcomes
as a function of covariates contained in input matrices (<a href="#topic+input_mats">input_mats</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tparams">tparams</a></code>
</p>

<hr>
<h2 id='params_lm'>Parameters of a linear model</h2><span id='topic+params_lm'></span>

<h3>Description</h3>

<p>Create a list containing the parameters of a fitted linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_lm(coefs, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_lm_+3A_coefs">coefs</code></td>
<td>
<p>Samples of the coefficients under sampling uncertainty.
Must be a matrix or any object coercible to a matrix such as <code>data.frame</code>
or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="params_lm_+3A_sigma">sigma</code></td>
<td>
<p>A vector of samples of the standard error of the regression model.
Default value is 1 for all samples. Only used if the model is
used to randomly simulate values (rather than to predict means).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitted linear models are used to predict values, <code class="reqn">y</code>,
as a function of covariates, <code class="reqn">x</code>,
</p>
<p style="text-align: center;"><code class="reqn">y = x^T\beta + \epsilon.</code>
</p>

<p>Predicted means are given by <code class="reqn">x^T\hat{\beta}</code> where <code class="reqn">\hat{\beta}</code>
is the vector of estimated regression coefficients. Random samples are obtained by
sampling the error term from a normal distribution,
<code class="reqn">\epsilon \sim N(0, \hat{\sigma}^2)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>params_lm</code>, which is a list containing <code>coefs</code>,
<code>sigma</code>, and <code>n_samples</code>. <code>n_samples</code> is equal to the
number of rows in <code>coefs</code>. The <code>coefs</code> element is always converted into a
matrix.
</p>


<h3>See Also</h3>

<p>This parameter object is useful for modeling <a href="#topic+StateVals">health state values</a>
when values can vary across patients and/or health states as a function of
covariates. In many cases it will, however, be simpler, and more flexible to
use a <code><a href="#topic+stateval_tbl">stateval_tbl</a></code>. For an example use case see the documentation for
<code><a href="#topic+create_StateVals.lm">create_StateVals.lm()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MASS")
n &lt;- 2
params &lt;- params_lm(
  coefs = mvrnorm(n, mu = c(.5,.6),
                  Sigma = matrix(c(.05, .01, .01, .05), nrow = 2)),
  sigma &lt;- rgamma(n, shape = .5, rate = 4)
)
summary(params)
params

</code></pre>

<hr>
<h2 id='params_mlogit'>Parameters of a multinomial logit model</h2><span id='topic+params_mlogit'></span><span id='topic+print.params_mlogit'></span>

<h3>Description</h3>

<p>Store the parameters of a fitted multinomial logistic
regression model. The model is used to predict probabilities of <code class="reqn">K</code>
classes, which represent the probability of transitioning to particular health
state in a discrete time state transition model. Can be used as an element of a
<code><a href="#topic+params_mlogit_list">params_mlogit_list</a></code> to parameterize a <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_mlogit(coefs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_mlogit_+3A_coefs">coefs</code></td>
<td>
<p>A 3D array of stacked matrices containing samples of the regression
coefficients under sampling uncertainty. May also be a
list of objects (e.g., data frames) that can be coerced into matrices with
<code>as.matrix()</code>. Each matrix must have the same number of columns and the
number of matrices must be equal to <code class="reqn">K-1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multinomial logit models are used to predict the probability of
membership for subject <code class="reqn">i</code> in each of <code class="reqn">K</code> classes as a function of covariates:
</p>
<p style="text-align: center;"><code class="reqn">Pr(y_i = c) = \frac{e^{\beta_c x_i}}{\sum_{k=1}^K e^{\beta_k x_i}}</code>
</p>



<h3>Value</h3>

<p>An object of class <code>params_mlogit</code>, which is a list containing <code>coefs</code>
and <code>n_samples</code>, where <code>n_samples</code> is equal to the number of rows in each
element of <code>coefs</code>. The <code>coefs</code> element is always converted into
a 3D array of stacked matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.params_mlogit">summary.params_mlogit()</a></code>, <code><a href="#topic+params_mlogit_list">params_mlogit_list()</a></code>, <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a sick-sicker model and model transitions from the sick state

## We can instantiate from a list of data frames
params &lt;- params_mlogit(
  coefs = list(
    ### Transition from sick to sicker
    sicker = data.frame(
      intercept = c(-0.33, -.2, -.15),
      treat = c(log(.75), log(.8), log(.9))
    ),
    
   ### Transition from sick to death
    death = data.frame(
      intercept = c(-1, -1.2, -.5),
      treat = c(log(.6), log(.65), log(.55))
    )
  )
)
summary(params)
params

## We can also instantiate from an array
coefs_sicker &lt;- data.frame(
  intercept = c(-0.33, -.2, -.15),
  treat = c(log(.75), log(.8), log(.9))
)
coefs_death &lt;- data.frame(
  intercept = c(-1, -1.2, -.5),
  treat = c(log(.6), log(.65), log(.55))
)

params2 &lt;- params_mlogit(
  coefs &lt;- array(
    data = c(as.matrix(coefs_sicker),
             as.matrix(coefs_death)),
    dim = c(3, 2, 2),
    dimnames = list(NULL, c("intercept", "treat"), c("sicker", "death"))
  )
)
params2
</code></pre>

<hr>
<h2 id='params_mlogit_list'>Parameters of a list of multinomial logit models</h2><span id='topic+params_mlogit_list'></span>

<h3>Description</h3>

<p>Create a list containing the parameters of multiple fitted multinomial logit models.
Can be used to parameterize state transitions in a discrete time transition model
by passing to the <code>params</code> field of a <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_mlogit_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_mlogit_list_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="#topic+params_mlogit">params_mlogit</a></code>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>params_mlogit_list</code>, which is a list containing
<code><a href="#topic+params_mlogit">params_mlogit</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.params_mlogit_list">summary.params_mlogit_list()</a></code>, <code><a href="#topic+params_mlogit">params_mlogit()</a></code>, <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a sick-sicker model

params &lt;- params_mlogit_list(
  ## Transitions from sick state (sick -&gt; sicker, sick -&gt; death)
  sick = params_mlogit(
    coefs = list(
      sicker = data.frame(
        intercept = c(-0.33, -.2),
        treat = c(log(.75), log(.8))
      ),
      death = data.frame(
        intercept = c(-1, -1.2),
        treat = c(log(.6), log(.65))
      )
    )
  ),
  
  ## Transitions from sicker state (sicker -&gt; death)
  sicker = params_mlogit(
    coefs = list(
      death = data.frame(
        intercept = c(-1.5, -1.4),
        treat = c(log(.5), log(.55))
      )
    )
  )
)
summary(params)
params

</code></pre>

<hr>
<h2 id='params_surv'>Parameters of a survival model</h2><span id='topic+params_surv'></span><span id='topic+print.params_surv'></span>

<h3>Description</h3>

<p>Create a list containing the parameters of a single fitted parametric or
flexible parametric survival model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_surv(coefs, dist, aux = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_surv_+3A_coefs">coefs</code></td>
<td>
<p>A list of length equal to the number of parameters in the
survival distribution. Each element of the list is a matrix of samples
of the regression coefficients under sampling uncertainty used to predict
a given parameter. All parameters are expressed on the real line (e.g.,
after log transformation if they are defined as positive). Each element
of the list may also be an object coercible to a matrix such as a
<code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="params_surv_+3A_dist">dist</code></td>
<td>
<p>Character vector denoting the parametric distribution. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="params_surv_+3A_aux">aux</code></td>
<td>
<p>Auxiliary arguments used with splines, fractional polynomial,
or piecewise exponential models. See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Survival is modeled as a function of <code class="reqn">L</code> parameters <code class="reqn">\alpha_l</code>.
Letting <code class="reqn">F(t)</code> be the cumulative distribution function, survival at time <code class="reqn">t</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">1 - F(t | \alpha_1(x_{1}), \ldots, \alpha_L(x_{L})).</code>
</p>

<p>The parameters are modeled as a function of covariates, <code class="reqn">x_l</code>, with an
inverse transformation function <code class="reqn">g^{-1}()</code>,
</p>
<p style="text-align: center;"><code class="reqn">\alpha_l =  g^{-1}(x_{l}^T \beta_l).</code>
</p>

<p><code class="reqn">g^{-1}()</code> is typically <code class="reqn">exp()</code> if a parameter is strictly positive
and the identity function if the parameter space is unrestricted.
</p>
<p>The types of distributions that can be specified are:
</p>

<dl>
<dt><code>exponential</code> or <code>exp</code></dt><dd><p> Exponential distribution. <code>coef</code>
must contain the <code>rate</code> parameter on the log scale and the same parameterization as in
<code><a href="stats.html#topic+Exponential">stats::Exponential</a></code>.</p>
</dd>
<dt><code>weibull</code> or <code>weibull.quiet</code></dt><dd><p> Weibull distribution. The first
element of <code>coef</code> is the <code>shape</code> parameter (on the log scale) and the second
element is the <code>scale</code> parameter (also on the log scale). The parameterization is
that same as in <code><a href="stats.html#topic+Weibull">stats::Weibull</a></code>.</p>
</dd>
<dt><code>weibullPH</code></dt><dd><p> Weibull distribution with a proportional hazards
parameterization. The first element of <code>coef</code> is the <code>shape</code> parameter
(on the log scale) and the second element is the <code>scale</code> parameter
(also on the log scale). The parameterization is
that same as in <code><a href="flexsurv.html#topic+WeibullPH">flexsurv::WeibullPH</a></code>.</p>
</dd>
<dt><code>gamma</code></dt><dd><p> Gamma distribution. The first
element of <code>coef</code> is the <code>shape</code> parameter (on the log scale) and the second
element is the <code>rate</code> parameter (also on the log scale). The parameterization is
that same as in <code><a href="stats.html#topic+GammaDist">stats::GammaDist</a></code>.</p>
</dd>
<dt><code>lnorm</code></dt><dd><p> Lognormal distribution. The first
element of <code>coef</code> is the <code>meanlog</code> parameter (i.e., the mean of survival on
the log scale) and the second element is the <code>sdlog</code> parameter (i.e.,
the standard deviation of survival on the log scale). The parameterization is
that same as in <code><a href="stats.html#topic+Lognormal">stats::Lognormal</a></code>. The coefficients predicting the <code>meanlog</code>
parameter are untransformed whereas the coefficients predicting the <code>sdlog</code>
parameter are defined on the log scale.</p>
</dd>
<dt><code>gompertz</code></dt><dd><p> Gompertz distribution. The first
element of <code>coef</code> is the <code>shape</code> parameter and the second
element is the <code>rate</code> parameter (on the log scale). The parameterization is
that same as in <code><a href="flexsurv.html#topic+Gompertz">flexsurv::Gompertz</a></code>.</p>
</dd>
<dt><code>llogis</code></dt><dd><p> Log-logistic distribution. The first
element of <code>coef</code> is the <code>shape</code> parameter (on the log scale) and the second
element is the <code>scale</code> parameter (also on the log scale). The parameterization is
that same as in <code><a href="flexsurv.html#topic+Llogis">flexsurv::Llogis</a></code>.</p>
</dd>
<dt><code>gengamma</code></dt><dd><p> Generalized gamma distribution. The first
element of <code>coef</code> is the location parameter <code>mu</code>, the second
element is the scale parameter <code>sigma</code> (on the log scale), and the
third element is the shape parameter <code>Q</code>. The parameterization is
that same as in <code><a href="flexsurv.html#topic+GenGamma">flexsurv::GenGamma</a></code>.</p>
</dd>
<dt><code>survspline</code></dt><dd><p> Survival splines. Each element of <code>coef</code> is a parameter of the
spline model (i.e. <code>gamma_0</code>, <code>gamma_1</code>, <code class="reqn">\ldots</code>) with length equal
to the number of knots (including the boundary knots). See below for details on the
auxiliary arguments. The parameterization is that same as in <code><a href="flexsurv.html#topic+Survspline">flexsurv::Survspline</a></code>.</p>
</dd>
<dt><code>fracpoly</code></dt><dd><p> Fractional polynomials. Each element of <code>coef</code> is a parameter of the
fractional polynomial model (i.e. <code>gamma_0</code>, <code>gamma_1</code>, <code class="reqn">\ldots</code>) with length equal
to the number of powers plus 1. See below for details on the auxiliary arguments
(i.e., <code>powers</code>).</p>
</dd>
<dt><code>pwexp</code></dt><dd><p> Piecewise exponential distribution. Each element of <code>coef</code> is
rate parameter for a distinct time interval. The times at which the rates
change should be specified with the auxiliary argument <code>time</code> (see below
for more details)</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>fixed</code></dt><dd><p> A fixed survival time. Can be used for &quot;non-random&quot; number
generation. <code>coef</code> should contain a single parameter, <code>est</code>, of the fixed
survival times.</p>
</dd>
</dl>

<p>Auxiliary arguments for spline models should be specified as a list containing the elements:
</p>

<dl>
<dt><code>knots</code></dt><dd><p>A numeric vector of knots.</p>
</dd>
<dt><code>scale</code></dt><dd><p>The survival outcome to be modeled
as a spline function. Options are <code>"log_cumhazard"</code> for the log cumulative hazard;
<code>"log_hazard"</code> for the log hazard rate; <code>"log_cumodds"</code> for the log cumulative odds;
and <code>"inv_normal"</code> for the inverse normal distribution function.</p>
</dd>
<dt><code>timescale</code></dt><dd><p>If <code>"log"</code> (the default), then survival is modeled as a spline function
of log time; if <code>"identity"</code>, then it is modeled as a spline function of time.</p>
</dd>
</dl>

<p>Auxiliary arguments for fractional polynomial models should be specified as a list containing the elements:
</p>

<dl>
<dt><code>powers</code></dt><dd><p> A vector of the powers of the fractional polynomial with each element
chosen from the following set: -2. -1, -0.5, 0, 0.5, 1, 2, 3.</p>
</dd>
</dl>

<p>Auxiliary arguments for piecewise exponential models should be specified as
a list containing the element:
</p>

<dl>
<dt><code>time</code></dt><dd><p> A vector equal to the number of rate parameters giving the
times at which the rate changes.</p>
</dd>
</dl>

<p>Furthermore, when splines (with <code>scale = "log_hazard"</code>) or fractional
polynomials are used, numerical methods must be used to compute the cumulative
hazard and for random number generation. The following additional auxiliary arguments
can therefore be specified:
</p>

<dl>
<dt><code>cumhaz_method</code></dt><dd><p>Numerical method used to compute cumulative hazard
(i.e., to integrate the hazard function). Always used for fractional polynomials
but only used for splines if <code>scale = "log_hazard"</code>.
Options are <code>"quad"</code> for adaptive quadrature and <code>"riemann"</code> for Riemann sum.</p>
</dd>
<dt><code>random_method</code></dt><dd><p>Method used to randomly draw from
an arbitrary survival function. Options are <code>"invcdf"</code> for the inverse CDF and
<code>"discrete"</code> for a discrete time approximation that randomly samples
events from a Bernoulli distribution at discrete times.</p>
</dd>
<dt><code>step</code></dt><dd><p>Step size for computation of cumulative hazard with
numerical integration. Only required when using <code>"riemann"</code> to compute the
cumulative hazard or using <code>"discrete"</code> for random number generation.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>params_surv</code>, which is a list containing <code>coefs</code>,
<code>dist</code>, and <code>n_samples</code>. <code>n_samples</code> is equal to the
number of rows in each element of <code>coefs</code>, which must be the same. The <code>coefs</code>
element is always converted into a list of matrices. The list may also contain
<code>aux</code> if a spline, fractional polynomial, or piecewise exponential model is
used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
params &lt;- params_surv(
  coefs = list(
    shape = data.frame(
      intercept = rnorm(n, .5, .23)
    ),
    scale = data.frame(
      intercept = rnorm(n, 12.39, 1.49),
      age = rnorm(n, -.09, .023)
   )
  ),
  dist = "weibull"
)
summary(params)
params
</code></pre>

<hr>
<h2 id='params_surv_list'>Parameters of a list of survival models</h2><span id='topic+params_surv_list'></span>

<h3>Description</h3>

<p>Create a list containing the parameters of multiple fitted parametric survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_surv_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_surv_list_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="#topic+params_surv">params_surv</a></code>, which can be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>params_surv_list</code>, which is a list containing <code><a href="#topic+params_surv">params_surv</a></code>
objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_params">create_params()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
params &lt;- params_surv_list(
  # Model for progression free survival
  pfs = params_surv(
    coefs = list(
      rate = data.frame(intercept = rnorm(n, log(.5), .5),
                        new_strategy = rnorm(n, log(.8), .1))
   ),
    dist = "exp"
  ),
 
  # Model for overall survival
  os = params_surv(
    coefs = list(
      rate = data.frame(intercept = rnorm(n, log(.3) , .5))
    ),
    dist = "exp"
  )
)
summary(params)
params
</code></pre>

<hr>
<h2 id='partsurvfit'>Partitioned survival regression object</h2><span id='topic+partsurvfit'></span>

<h3>Description</h3>

<p>Create a partitioned survival regression object of class <code>partsurvfit</code>. The object contains a list
of fitted survival models fit using either <code>flexsurvreg</code> or <code>flexsurvspline</code> (i.e.,
an object of class <code><a href="#topic+flexsurvreg_list">flexsurvreg_list</a></code>) and the data frame used to perform the fit of each model.
The same data frame must have been used for each fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partsurvfit(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partsurvfit_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+flexsurvreg_list">flexsurvreg_list</a></code>.</p>
</td></tr>
<tr><td><code id="partsurvfit_+3A_data">data</code></td>
<td>
<p>The data frame used to fit each survival model in <code>object</code>.
<code>flexsurvreg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>partsurvfit</code>, which is a list containing two elements.
The first element, &quot;models&quot;, contains the survival models passed to <code>object</code>, and the second
element, &quot;data&quot; contains the data frame passed to <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")
fit1 &lt;- flexsurv::flexsurvreg(formula = Surv(endpoint1_time, endpoint1_status) ~ age, 
                              data = psm4_exdata$survival,
                              dist = "weibull")
fit2 &lt;- flexsurv::flexsurvreg(formula = Surv(endpoint2_time, endpoint2_status) ~ age, 
                              data = psm4_exdata$survival, 
                              dist = "weibull")
fsreg_list &lt;- flexsurvreg_list(endpoint1 = fit1, endpoint2 = fit2)
fits &lt;- partsurvfit(fsreg_list, data = psm4_exdata$survival)
class(fits)
</code></pre>

<hr>
<h2 id='plot_ceac'>Plot cost-effectiveness acceptability curve</h2><span id='topic+plot_ceac'></span><span id='topic+plot_ceac.cea_pw'></span><span id='topic+plot_ceac.cea'></span>

<h3>Description</h3>

<p>Plot a cost-effectiveness curve from either the output of <code><a href="#topic+cea">cea()</a></code> or
<code><a href="#topic+cea_pw">cea_pw()</a></code> using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>. The former compares all treatment strategies
simultaneously and uses the probabilistic sensitivity analysis (PSA) to compute
the probability that each strategy is the most cost-effective at a given
willingness to pay value, while the latter uses the PSA to compute the probability
that each treatment is cost-effective relative to a comparator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ceac(x, ...)

## S3 method for class 'cea_pw'
plot_ceac(x, labels = NULL, ...)

## S3 method for class 'cea'
plot_ceac(x, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ceac_+3A_x">x</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="plot_ceac_+3A_...">...</code></td>
<td>
<p>Further arguments passed to and from methods. Currently unused.</p>
</td></tr>
<tr><td><code id="plot_ceac_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+cea">cea()</a></code> documentation for an example. If there are multiple subgroups,
then a faceted plot is produced with one plot for each subgroup.
</p>

<hr>
<h2 id='plot_ceaf'>Plot cost-effectiveness acceptability frontier</h2><span id='topic+plot_ceaf'></span>

<h3>Description</h3>

<p>Plot a cost-effectiveness acceptability frontier (CEAF) from the output of
<code><a href="#topic+cea">cea</a></code> using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>. The CEAF plots the probability
that the optimal treatment strategy (i.e., the strategy with the highest
expected net monetary benefit) is cost-effective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ceaf(x, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ceaf_+3A_x">x</code></td>
<td>
<p>A <code>cea</code> object produced by <code><a href="#topic+cea">cea</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ceaf_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+cea">cea()</a></code> documentation for an example. If there are multiple subgroups,
then a faceted plot is produced with one plot for each subgroup.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='plot_ceplane'>Plot cost-effectiveness plane</h2><span id='topic+plot_ceplane'></span>

<h3>Description</h3>

<p>Plot a cost-effectiveness plane from the output of <code><a href="#topic+cea_pw">cea_pw()</a></code> using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>.
Each point is a random draw of incremental costs (y-axis) and incremental QALYs (x-axis)
from a probabilistic sensitivity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ceplane(x, k = 50000, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ceplane_+3A_x">x</code></td>
<td>
<p>A <code>cea_pw</code> object produced by <code><a href="#topic+cea_pw">cea_pw()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ceplane_+3A_k">k</code></td>
<td>
<p>Willingness to pay per QALY.</p>
</td></tr>
<tr><td><code id="plot_ceplane_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+cea_pw">cea_pw()</a></code> documentation for an example. If there are multiple subgroups,
then a faceted plot is produced with one plot for each subgroup.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='plot_evpi'>Plot expected value of perfect information</h2><span id='topic+plot_evpi'></span>

<h3>Description</h3>

<p>Plot the expected value of perfect information (EVPI) from the output of
<code><a href="#topic+cea">cea()</a></code> using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>. Intuitively, the EVPI provides an estimate of the
amount that a decision maker would be willing to pay to collect additional data
and completely eliminate uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_evpi(x, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_evpi_+3A_x">x</code></td>
<td>
<p>A <code>cea</code> object produced by <code><a href="#topic+cea">cea()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="#topic+cea">cea()</a></code> documentation for an example. If there are multiple subgroups,
then a faceted plot is produced with one plot for each subgroup.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='Psm'>N-state partitioned survival model</h2><span id='topic+Psm'></span>

<h3>Description</h3>

<p>Simulate outcomes from an N-state partitioned survival model.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>survival_models</code></dt><dd><p>The survival models used to predict survival curves. Must be
an object of class <code><a href="#topic+PsmCurves">PsmCurves</a></code>.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The model for health state utility. Must be an object of
class <code><a href="#topic+StateVals">StateVals</a></code>.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The models used to predict costs by health state.
Must be a list of objects of class <code><a href="#topic+StateVals">StateVals</a></code>, where each element of the
list represents a different cost category.</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of states in the partitioned survival model.</p>
</dd>
<dt><code>t_</code></dt><dd><p>A numeric vector of times at which survival curves were predicted. Determined
by the argument <code>t</code> in <code style="white-space: pre;">&#8288;$sim_curves()&#8288;</code>.</p>
</dd>
<dt><code>survival_</code></dt><dd><p>An object of class <a href="#topic+survival">survival</a> simulated using <code>sim_survival()</code>.</p>
</dd>
<dt><code>stateprobs_</code></dt><dd><p>An object of class <a href="#topic+stateprobs">stateprobs</a> simulated using <code style="white-space: pre;">&#8288;$sim_stateprobs()&#8288;</code>.</p>
</dd>
<dt><code>qalys_</code></dt><dd><p>An object of class <a href="#topic+qalys">qalys</a> simulated using <code style="white-space: pre;">&#8288;$sim_qalys()&#8288;</code>.</p>
</dd>
<dt><code>costs_</code></dt><dd><p>An object of class <a href="#topic+costs">costs</a> simulated using <code style="white-space: pre;">&#8288;$sim_costs()&#8288;</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Psm-new"><code>Psm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-sim_survival"><code>Psm$sim_survival()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-sim_stateprobs"><code>Psm$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-sim_qalys"><code>Psm$sim_qalys()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-sim_costs"><code>Psm$sim_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-summarize"><code>Psm$summarize()</code></a>
</p>
</li>
<li> <p><a href="#method-Psm-clone"><code>Psm$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Psm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Psm</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$new(survival_models = NULL, utility_model = NULL, cost_models = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>survival_models</code></dt><dd><p>The <code>survival_models</code> field.</p>
</dd>
<dt><code>utility_model</code></dt><dd><p>The <code>utility_model</code> field.</p>
</dd>
<dt><code>cost_models</code></dt><dd><p>The <code>cost_models</code> field.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p><code>n_states</code> is set equal to the number of survival models plus one.
</p>



<h5>Returns</h5>

<p>A new <code>Psm</code> object.
</p>


<hr>
<a id="method-Psm-sim_survival"></a>



<h4>Method <code>sim_survival()</code></h4>

<p>Simulate survival curves as a function of time using <code>PsmCurves$survival()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$sim_survival(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times. The first element must be <code>0</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output from <code>PsmCurves$survival()</code>
stored in <code>survival_</code>.
</p>


<hr>
<a id="method-Psm-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code></h4>

<p>Simulate health state probabilities from <code>survival_</code> using a partitioned
survival analysis.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$sim_stateprobs()</pre></div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+stateprobs">stateprobs</a>
stored in <code>stateprobs_</code>.
</p>


<hr>
<a id="method-Psm-sim_qalys"></a>



<h4>Method <code>sim_qalys()</code></h4>

<p>Simulate quality-adjusted life-years (QALYs) as a function of <code>stateprobs_</code> and
<code>utility_model</code>. See <code>sim_qalys()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$sim_qalys(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  lys = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt><dd><p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
<dt><code>lys</code></dt><dd><p>If <code>TRUE</code>, then life-years are simulated in addition to QALYs.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+qalys">qalys</a> stored
in <code>qalys_</code>.
</p>


<hr>
<a id="method-Psm-sim_costs"></a>



<h4>Method <code>sim_costs()</code></h4>

<p>Simulate costs as a function of <code>stateprobs_</code> and <code>cost_models</code>.
See <code>sim_costs()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$sim_costs(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt><dd><p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class <a href="#topic+costs">costs</a> stored
in <code>costs_</code>.
</p>


<hr>
<a id="method-Psm-summarize"></a>



<h4>Method <code>summarize()</code></h4>

<p>Summarize costs and QALYs so that cost-effectiveness analysis can be performed.
See <code><a href="#topic+summarize_ce">summarize_ce()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$summarize(by_grp = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>by_grp</code></dt><dd><p>If <code>TRUE</code>, then costs and QALYs are computed by subgroup. If
<code>FALSE</code>, then costs and QALYs are aggregated across all patients (and subgroups).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Psm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Psm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.3 for a mathematical description of a PSM and Section 4.2 for an
example in oncology. The mathematical approach used to simulate costs and QALYs from
state probabilities is described in Section 2.1.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+PsmCurves">PsmCurves</a></code> documentation
describes the class for the survival models and the <code><a href="#topic+StateVals">StateVals</a></code> documentation
describes the class for the cost and utility models. A <code><a href="#topic+PsmCurves">PsmCurves</a></code>
object is typically created using <code><a href="#topic+create_PsmCurves">create_PsmCurves()</a></code>.
The <code><a href="#topic+PsmCurves">PsmCurves</a></code> documentation provides an example in which the model
is parameterized from parameter objects (i.e., without having the patient-level
data required to fit a model with <code>R</code>). A longer example is provided in
<code>vignette("psm")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")
library("ggplot2")
theme_set(theme_bw())

# Model setup
strategies &lt;- data.frame(strategy_id = c(1, 2, 3),
                         strategy_name = paste0("Strategy ", 1:3))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       age = c(45, 50, 60),
                       female = c(0, 0, 1))
states &lt;- data.frame(state_id =  seq(1, 3),
                     state_name = paste0("State ", seq(1, 3)))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)
labs &lt;- c(
  get_labels(hesim_dat),
  list(curve = c("Endpoint 1" = 1,
                 "Endpoint 2" = 2,
                 "Endpoint 3" = 3))
)
n_samples &lt;- 2

# Survival models
surv_est_data &lt;- psm4_exdata$survival
fit1 &lt;- flexsurvreg(Surv(endpoint1_time, endpoint1_status) ~ factor(strategy_id),
                    data = surv_est_data, dist = "exp")
fit2 &lt;- flexsurvreg(Surv(endpoint2_time, endpoint2_status) ~ factor(strategy_id),
                    data = surv_est_data, dist = "exp")
fit3 &lt;- flexsurvreg(Surv(endpoint3_time, endpoint3_status) ~ factor(strategy_id),
                    data = surv_est_data, dist = "exp")
fits &lt;- flexsurvreg_list(fit1, fit2, fit3)

surv_input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))
psm_curves &lt;- create_PsmCurves(fits, input_data = surv_input_data,
                               uncertainty = "bootstrap", est_data = surv_est_data,
                               n = n_samples)

# Cost model(s)
cost_input_data &lt;- expand(hesim_dat, by = c("strategies", "patients", "states"))
fit_costs_medical &lt;- lm(costs ~ female + state_name,
                        data = psm4_exdata$costs$medical)
psm_costs_medical &lt;- create_StateVals(fit_costs_medical,
                                      input_data = cost_input_data,
                                      n = n_samples)

# Utility model
utility_tbl &lt;- stateval_tbl(tbl = data.frame(state_id = states$state_id,
                                             min = psm4_exdata$utility$lower,
                                             max = psm4_exdata$utility$upper),
                            dist = "unif")
psm_utility &lt;- create_StateVals(utility_tbl, n = n_samples,
                                hesim_data = hesim_dat)

# Partitioned survival decision model
psm &lt;- Psm$new(survival_models = psm_curves,
               utility_model = psm_utility,
               cost_models = list(medical = psm_costs_medical))
psm$sim_survival(t = seq(0, 5, 1/12))
autoplot(psm$survival_, labels = labs, ci = FALSE, ci_style = "ribbon")
psm$sim_stateprobs()
autoplot(psm$stateprobs_, labels = labs)
psm$sim_costs(dr = .03)
head(psm$costs_)
head(psm$sim_qalys(dr = .03)$qalys_)
</code></pre>

<hr>
<h2 id='psm4_exdata'>Example data for a 4-state partitioned survival model</h2><span id='topic+psm4_exdata'></span>

<h3>Description</h3>

<p>A collection of example datasets containing simulated survival, costs, and utility data for a 4-state
partitioned survival model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psm4_exdata
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>Survival</dt><dd><p>A data frame containing patient information and time to 3 separate survival endpoints.</p>
</dd>
<dt>Costs</dt><dd><p>A list of data frames. The first data frame contains medical cost data and the
second data frame contains drug cost data.</p>
</dd>
</dl>



<h3>Survival data</h3>

<p>The survival data frame contains a list of 3 survival curves, each containing the following columns.
</p>

<dl>
<dt>female</dt><dd><p>An indicator variable equal to 1 if the patient is female and 0 otherwise.</p>
</dd>
<dt>age</dt><dd><p>The age of the patient in years.</p>
</dd>
<dt>strategy_id</dt><dd><p>The id of the treatment strategy used.</p>
</dd>
<dt>endpoint1_time</dt><dd><p>Follow up time with right censored data to survival endpoint 1.</p>
</dd>
<dt>endpoint1_status</dt><dd><p>A status indicator for survival endpoint 1 equal to 0 if alive and 1 if dead.</p>
</dd>
<dt>endpoint2_time</dt><dd><p>Follow up time with right censored data to survival endpoint 2.</p>
</dd>
<dt>endpoint2_status</dt><dd><p>A status indicator for survival endpoint 2 equal to 0 if alive and 1 if dead.</p>
</dd>
<dt>endpoint3_time</dt><dd><p>Follow up time with right censored data to survival endpoint 3.</p>
</dd>
<dt>endpoint3_status</dt><dd><p>A status indicator for survival endpoint 3 equal to 0 if alive and 1 if dead.</p>
</dd>
</dl>



<h3>Cost data</h3>

<p>The cost list contains two data frames.The first data frame contains data on the
medical costs by patient and health state, and contains the following columns:
</p>

<dl>
<dt>patient_id</dt><dd><p>An integer denoting the id of the patient.</p>
</dd>
<dt>female</dt><dd><p>An indicator variable equal to 1 if the patient is female and 0 otherwise.</p>
</dd>
<dt>state_name</dt><dd><p>A categorical variable denoting the three possible health states.</p>
</dd>
<dt>costs</dt><dd><p>Annualized medical costs.</p>
</dd>
</dl>

<p>The second data frame contains data on the drug costs associated with each treatment strategy.
</p>

<dl>
<dt>strategy_id</dt><dd><p>The id of each treatment strategy.</p>
</dd>
<dt>costs</dt><dd><p>Annualized drug costs.</p>
</dd>
</dl>


<hr>
<h2 id='PsmCurves'>Partitioned survival curves</h2><span id='topic+PsmCurves'></span>

<h3>Description</h3>

<p>Summarize N-1 survival curves for an N-state partitioned survival model.
</p>


<h3>Format</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>params</code></dt><dd><p>An object of class <code><a href="#topic+params_surv_list">params_surv_list</a></code>.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>An object of class <code><a href="#topic+input_mats">input_mats</a></code>. Each row in <code>X</code> must
be a unique treatment strategy and patient.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PsmCurves-new"><code>PsmCurves$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-hazard"><code>PsmCurves$hazard()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-cumhazard"><code>PsmCurves$cumhazard()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-survival"><code>PsmCurves$survival()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-rmst"><code>PsmCurves$rmst()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-quantile"><code>PsmCurves$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-check"><code>PsmCurves$check()</code></a>
</p>
</li>
<li> <p><a href="#method-PsmCurves-clone"><code>PsmCurves$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PsmCurves-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>PsmCurves</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$new(params, input_data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>The <code>params</code> field.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>The <code>input_data</code> field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PsmCurves</code> object.
</p>


<hr>
<a id="method-PsmCurves-hazard"></a>



<h4>Method <code>hazard()</code></h4>

<p>Predict the hazard function for each survival curve as a function of time.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$hazard(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>sample</code>, <code>strategy_id</code>,
<code>patient_id</code>, <code>grp_id</code>, <code>curve</code> (the curve number), <code>t</code>, and <code>hazard</code>.
</p>


<hr>
<a id="method-PsmCurves-cumhazard"></a>



<h4>Method <code>cumhazard()</code></h4>

<p>Predict the cumulative hazard function for each survival curve as a function of time.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$cumhazard(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>sample</code>, <code>strategy_id</code>,
<code>patient_id</code>, <code>grp_id</code>, <code>curve</code>, <code>t</code>, and <code>cumhazard</code>.
</p>


<hr>
<a id="method-PsmCurves-survival"></a>



<h4>Method <code>survival()</code></h4>

<p>Predict survival probabilities for each survival curve as a function of time.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$survival(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+survival">survival</a></code>.
</p>


<hr>
<a id="method-PsmCurves-rmst"></a>



<h4>Method <code>rmst()</code></h4>

<p>Predict the restricted mean survival time up until time points <code>t</code>
for each survival curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$rmst(t, dr = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
<dt><code>dr</code></dt><dd><p>Discount rate.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>sample</code>, <code>strategy_id</code>,
<code>patient_id</code>, <code>grp_id</code>, <code>curve</code>, <code>t</code>, and <code>rmst</code>.
</p>


<hr>
<a id="method-PsmCurves-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Predict quantiles of the survival distribution for each survival curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$quantile(p)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>A numeric vector of probabilities for computing quantiles.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> with columns <code>sample</code>, <code>strategy_id</code>,
<code>patient_id</code>, <code>grp_id</code>, <code>curve</code>, <code>p</code> and <code>quantile</code>.
</p>


<hr>
<a id="method-PsmCurves-check"></a>



<h4>Method <code>check()</code></h4>

<p>Input validation for class. Checks that fields are the correct type.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$check()</pre></div>


<hr>
<a id="method-PsmCurves-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PsmCurves$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code>PsmCurves</code> are conveniently created from either fitted models or
parameter objects with <code><a href="#topic+create_PsmCurves">create_PsmCurves()</a></code>. A complete economic model can be
implemented with the <code><a href="#topic+Psm">Psm</a></code> class. A longer example is provided in
<code>vignette("psm")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("flexsurv")
N_SAMPLES &lt;- 5 # Number of parameter samples for PSA

# Consider a 3-state model where there is a 
# progression-free survival (PFS) and an
# overall survival (OS) endpoint

# (0) Model setup
hesim_dat &lt;- hesim_data(
  strategies = data.frame(
    strategy_id = c(1, 2),
    strategy_name = c("SOC", "New 1")
  ),
  patients = data.frame(
    patient_id = 1
  )
)

# (1) Parameterize survival models
## (1.1) If patient-level data is available, 
## we can fit survival models

### (1.1.1) Data for estimation (for simplicity, only use 2 strategies)
surv_est_data &lt;- as_pfs_os(
  onc3[strategy_name != "New 2"], 
  patient_vars = c("patient_id", "strategy_name")
)
surv_est_data$strategy_name &lt;- droplevels(surv_est_data$strategy_name)

### (1.1.2) Fit models
fit_pfs &lt;- flexsurvreg(Surv(pfs_time, pfs_status) ~ strategy_name,
                       data = surv_est_data, dist = "exp")
fit_os &lt;- flexsurvreg(Surv(os_time, os_status) ~ strategy_name,
                      data = surv_est_data, dist = "exp")
fits &lt;- flexsurvreg_list(pfs = fit_pfs, os = fit_os)

## (1.2) If patient-level data is NOT available, 
## we can construct the parameter objects "manually"

### (1.2.1) Baseline hazard:
### Assume that we know the (log) rate parameters for both PFS and OS 
### for SOC (i.e., the intercept) and their standard error
logint_pfs_est &lt;- -1.7470900
logint_pfs_se &lt;-  0.03866223
logint_os_est &lt;- -2.7487675
logint_os_se &lt;- 0.04845015

### (1.2.2) Relative treatment effect:
### Assume we know the log hazard ratios (and their standard errors) 
### for comparing the new interventions to the SOC
loghr_pfs_est_new1 &lt;- -0.1772028 
loghr_pfs_se_new1 &lt;- 0.05420119
loghr_os_est_new1 &lt;- -0.1603632
loghr_os_se_new1 &lt;- 0.06948962

### (1.2.3) Create "params_surv_list" object by combining the baseline hazard 
### and relative treatment effects
params &lt;- params_surv_list(
  #### Model for PFS
  pfs = params_surv(
    coefs = list( 
      rate = data.frame( # coefficients predict log rate
        intercept = rnorm(N_SAMPLES, logint_pfs_est, logint_pfs_se),
        new1 = rnorm(N_SAMPLES, loghr_pfs_est_new1, loghr_pfs_se_new1)
      )
    ),
    dist = "exp"
  ),
  
  #### Model for OS
  os = params_surv(
    coefs = list(
      rate = data.frame(
        intercept = rnorm(N_SAMPLES, logint_os_est, logint_os_se),
        new1 = rnorm(N_SAMPLES, loghr_os_est_new1, loghr_os_se_new1)
      )
    ),
    dist = "exp"
  )
)

#### The print (and summary) methods for the "params_surv_list" object will 
#### summarize each of the model terms, which is a good way to check
#### if it's been setup correctly
params 

# (2) Simulation
## (2.1) Construct the model
### (2.1.1) Case where patient-level data was available
### Use create_PsmCurves.params_flexsurvreg_list() method
surv_input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))
psm_curves1 &lt;- create_PsmCurves(fits, input_data = surv_input_data, 
                                n = N_SAMPLES,
                                uncertainty = "normal",
                                est_data = surv_est_data)

### (2.1.2) Case where patient-level data was NOT available
### Use create_PsmCurves.params_surv_list() method
surv_input_data$intercept &lt;- 1
surv_input_data$new1 &lt;- ifelse(surv_input_data$strategy_name == "New 1", 
                               1, 0)
psm_curves2 &lt;- create_PsmCurves(params, input_data = surv_input_data)

## (2.2) Summarize survival models
## There are minor discrepancies between the case where models were fit
## with flexsurvreg() and the case where the "params_surv_list" object
## was constructed manually due to differences in the random draws
## of the parameter samples. These differences are decreasing in the size 
## of N_SAMPLES
times &lt;- seq(0, 10, 1/12) # Monthly times

### Quantiles
head(psm_curves1$quantile(p = c(.25, .5, .75)))
head(psm_curves2$quantile(p = c(.25, .5, .75)))

### Survival curves
head(psm_curves1$survival(t = times))
head(psm_curves2$survival(t = times))

### Restricted mean survival
head(psm_curves1$rmst(t = c(2, 5)))
head(psm_curves2$rmst(t = c(2, 5)))
</code></pre>

<hr>
<h2 id='qalys'>Quality-adjusted life-years object</h2><span id='topic+qalys'></span>

<h3>Description</h3>

<p>An object of class <code>qalys</code> returned from methods
<code style="white-space: pre;">&#8288;$sim_qalys()&#8288;</code> in model classes that store simulated
quality-adjusted life-years (QALYs).
</p>


<h3>Components</h3>

<p>A <code>qalys</code> object inherits from <code>data.table</code> and contains
the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>grp_id</dt><dd><p>The subgroup ID.</p>
</dd>
<dt>state_id</dt><dd><p>The health state ID.</p>
</dd>
<dt>dr</dt><dd><p>The rate used to discount QALYs.</p>
</dd>
<dt>category</dt><dd><p>A single category always equal to &quot;qalys&quot;.</p>
</dd>
<dt>qalys</dt><dd><p>The simulated values of QALYs.</p>
</dd>
</dl>

<p>If the argument <code>lys = TRUE</code>, then the <code>data.table</code> also contains a column
<code>lys</code> containing simulated life-years.
</p>

<hr>
<h2 id='qmatrix'>Transition intensity matrix</h2><span id='topic+qmatrix'></span>

<h3>Description</h3>

<p>A generic function for creating transition intensity matrices where
elements represent the instantaneous risk of moving between health states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmatrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatrix_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object.</p>
</td></tr>
<tr><td><code id="qmatrix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='qmatrix.matrix'>Transition intensity matrix from tabular object</h2><span id='topic+qmatrix.matrix'></span><span id='topic+qmatrix.data.table'></span><span id='topic+qmatrix.data.frame'></span>

<h3>Description</h3>

<p>Creates transition intensity matrices where elements represent
the instantaneous risk of moving between health states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
qmatrix(x, trans_mat, ...)

## S3 method for class 'data.table'
qmatrix(x, trans_mat, ...)

## S3 method for class 'data.frame'
qmatrix(x, trans_mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatrix.matrix_+3A_x">x</code></td>
<td>
<p>A two-dimensional tabular object containing
elements of the transition intensity matrix. A column represents a transition
from state <code class="reqn">r</code> to state <code class="reqn">s</code>. Each row represents elements of a different
transition intensity matrix. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="qmatrix.matrix_+3A_trans_mat">trans_mat</code></td>
<td>
<p>Just as in <code><a href="#topic+IndivCtstmTrans">IndivCtstmTrans</a></code>, a transition matrix
describing the states and transitions in a multi-state model.</p>
</td></tr>
<tr><td><code id="qmatrix.matrix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>x</code> must only contain non-zero and non-diagonal elements
of a transition intensity matrix. The diagonal elements are automatically computed
as the negative sum of the other rows.
</p>


<h3>Value</h3>

<p>An array of transition intensity matrices with the third dimension
equal to the number of rows in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmatrix.msm">qmatrix.msm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3 state irreversible model
tmat &lt;- rbind(c(NA, 1, 2),
              c(NA, NA, 3),
              c(NA, NA, NA)) 
q12 &lt;- c(.8, .7)
q13 &lt;- c(.2, .3)
q23 &lt;- c(1.1, 1.2)
q &lt;- data.frame(q12, q13, q23)
qmat &lt;- qmatrix(q, trans_mat = tmat)
print(qmat)

# Matrix exponential of each matrix in array
expmat(qmat)

</code></pre>

<hr>
<h2 id='qmatrix.msm'>Transition intensity matrix from <code>msm</code> object</h2><span id='topic+qmatrix.msm'></span>

<h3>Description</h3>

<p>Draw transition intensity matrices for a probabilistic sensitivity analysis
from a fitted <code>msm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
qmatrix(x, newdata = NULL, uncertainty = c("normal", "none"), n = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatrix.msm_+3A_x">x</code></td>
<td>
<p>A <code><a href="msm.html#topic+msm">msm::msm</a></code> object.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_newdata">newdata</code></td>
<td>
<p>A data frame to look for variables with which to predict. A
separate transition intensity matrix is predicted based on each row in
<code>newdata</code>. Can be <code>NULL</code> if no covariates are included in the fitted <code>msm</code>
object.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Method used to draw transition intensity matrices. If <code style="white-space: pre;">&#8288;"none&#8288;</code>&quot;,
then point estimates are used. If <code>"normal"</code>, then samples are drawn from the
multivariate normal distribution of the regression coefficients.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_n">n</code></td>
<td>
<p>Number of random observations of the parameters to draw.</p>
</td></tr>
<tr><td><code id="qmatrix.msm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of transition intensity matrices with the third dimension
equal to the number of rows in <code>newdata</code>.
</p>


<h3>See Also</h3>

<p><code>qmatrix.matrix()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("msm")
set.seed(101)
 qinit &lt;- rbind(
   c(0, 0.28163, 0.01239),
   c(0, 0, 0.10204),
   c(0, 0, 0)
 )
fit &lt;- msm(state_id ~ time, subject = patient_id, 
           data = onc3p[patient_id %in% sample(patient_id, 100)],
           covariates = list("1-2" =~ age + strategy_name), 
           qmatrix = qinit)
qmatrix(fit, newdata = data.frame(age = 55, strategy_name = "New 1"),
        uncertainty = "none")
qmatrix(fit, newdata = data.frame(age = 55, strategy_name = "New 1"),
        uncertainty = "normal",  n = 3)

</code></pre>

<hr>
<h2 id='rcat'>Random generation for categorical distribution</h2><span id='topic+rcat'></span>

<h3>Description</h3>

<p>Draw random samples from a categorical distribution given a matrix of probabilities.
<code>rcat</code> is vectorized and written in C++ for speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcat(n, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcat_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw.</p>
</td></tr>
<tr><td><code id="rcat_+3A_prob">prob</code></td>
<td>
<p>A matrix of probabilities where rows correspond to observations
and columns correspond to categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of random samples from the categorical distribution. The length of the sample is
determined by n. The numerical arguments other than n are recycled so that the number of samples is
equal to n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(.2, .5, .3)
n &lt;- 10000
pmat &lt;- matrix(rep(p, n), nrow = n, ncol = length(p), byrow = TRUE)

# rcat
set.seed(100)
ptm &lt;- proc.time()
samp1 &lt;- rcat(n, pmat)
proc.time() - ptm
prop.table(table(samp1))

# rmultinom from base R 
set.seed(100)
ptm &lt;- proc.time()
samp2 &lt;- t(apply(pmat, 1, rmultinom, n = 1, size = 1))
samp2 &lt;- apply(samp2, 1, function(x) which(x == 1))
proc.time() - ptm
prop.table(table(samp2))
</code></pre>

<hr>
<h2 id='rdirichlet_mat'>Random generation for multiple Dirichlet distributions</h2><span id='topic+rdirichlet_mat'></span>

<h3>Description</h3>

<p>Draw random samples from multiple Dirichlet distributions for use in
transition probability matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet_mat(
  n,
  alpha,
  output = c("array", "matrix", "data.frame", "data.table")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdirichlet_mat_+3A_n">n</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="rdirichlet_mat_+3A_alpha">alpha</code></td>
<td>
<p>A matrix where each row is a separate vector of shape parameters.</p>
</td></tr>
<tr><td><code id="rdirichlet_mat_+3A_output">output</code></td>
<td>
<p>The class of the object returned by the function. Either an
<code>array</code>, <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant for representing the distribution of
transition probabilities in a transition matrix. The <code style="white-space: pre;">&#8288;(i,j)&#8288;</code> element of
<code>alpha</code> is a transition from state <code>i</code> to state <code>j</code>. It is vectorized and
written in <code style="white-space: pre;">&#8288;C++&#8288;</code> for speed.
</p>


<h3>Value</h3>

<p>If <code>output = "array"</code>, then an array of matrices is returned
where each row of each matrix is a sample from the Dirichlet distribution.
If <code>output</code> results in a two dimensional object (i.e., a <code>matrix</code>,
<code>data.frame</code>, or <code>data.table</code>, then each row contains
all elements of the sampled matrix from the Dirichlet distribution
ordered rowwise; that is, each matrix is flattened. In these cases,
the number of rows must be less than or equal to the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- matrix(c(100, 200, 500, 50, 70, 75), ncol = 3, nrow = 2, byrow = TRUE)
samp &lt;- rdirichlet_mat(100, alpha)
print(samp[, , 1:2])
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as.data.table'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rng_distributions'>Random number generation distributions</h2><span id='topic+rng_distributions'></span><span id='topic+beta_rng'></span><span id='topic+dirichlet_rng'></span><span id='topic+fixed'></span><span id='topic+custom'></span><span id='topic+gamma_rng'></span><span id='topic+lognormal_rng'></span><span id='topic+multi_normal_rng'></span><span id='topic+normal_rng'></span><span id='topic+uniform_rng'></span>

<h3>Description</h3>

<p>A collection of functions for randomly generating deviates from probability
distributions with <code><a href="#topic+define_rng">define_rng()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_rng(
  shape1 = 1,
  shape2 = 1,
  mean = NULL,
  sd = NULL,
  names = NULL,
  n = parent.frame()$n
)

dirichlet_rng(alpha, names = NULL, n = parent.frame()$n)

fixed(est, names = NULL, n = parent.frame()$n)

custom(x, names = NULL, n = parent.frame()$n)

gamma_rng(mean, sd, names = NULL, n = parent.frame()$n)

lognormal_rng(meanlog, sdlog, names = NULL, n = parent.frame()$n)

multi_normal_rng(mu, Sigma, names = NULL, n = parent.frame()$n, ...)

normal_rng(mean, sd, names = NULL, n = parent.frame()$n)

uniform_rng(min, max, names = NULL, n = parent.frame()$n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_distributions_+3A_shape1">shape1</code>, <code id="rng_distributions_+3A_shape2">shape2</code></td>
<td>
<p>Non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_mean">mean</code>, <code id="rng_distributions_+3A_sd">sd</code></td>
<td>
<p>Mean and standard deviation of the random variable.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_names">names</code></td>
<td>
<p>Names for columns if an object with multiple columns is returned
by the function.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_n">n</code></td>
<td>
<p>The number of random samples of the parameters to draw. Default is
the value of <code>n</code> in the environment in which the function is called, which
can be useful when used inside <code>define_rng</code> because it means that a value does
not need to be explicitly passed to <code>n</code>.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_alpha">alpha</code></td>
<td>
<p>A matrix where each row is a separate vector of shape parameters.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_est">est</code></td>
<td>
<p>A vector of estimates of the variable of interest.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_x">x</code></td>
<td>
<p>A numeric <code>vector</code>, <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code> containing
random samples of the variable of interest from a suitable probability distribution. This would
typically be a posterior distribution from a Bayesian analysis.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_meanlog">meanlog</code>, <code id="rng_distributions_+3A_sdlog">sdlog</code></td>
<td>
<p>Mean and standard deviation of the distribution on the
log scale.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_mu">mu</code>, <code id="rng_distributions_+3A_sigma">Sigma</code></td>
<td>
<p><code>mu</code> is a vector giving the means of the variables and
<code>Sigma</code> is a positive-definite symmetric matrix specifying the
covariance matrix of the variables.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to underlying random number generation
functions. See &quot;details&quot;.</p>
</td></tr>
<tr><td><code id="rng_distributions_+3A_min">min</code>, <code id="rng_distributions_+3A_max">max</code></td>
<td>
<p>Lower and upper limits of the distribution. Must be finite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not exported and are meant for use with
<code><a href="#topic+define_rng">define_rng()</a></code>. They consequently assume that the number of samples to draw, <code>n</code>,
is defined in the parent environment. Convenience random number generation
functions include:
</p>

<dl>
<dt><code>beta_rng()</code></dt><dd><p>If <code>mean</code> and <code>sd</code> are both not <code>NULL</code>, then
parameters of the beta distribution are derived using
the methods of moments with <code><a href="#topic+mom_beta">mom_beta()</a></code>. Beta variates are generated with
<code><a href="stats.html#topic+Beta">stats::rbeta()</a></code>.</p>
</dd>
<dt><code>custom()</code></dt><dd><p>Use previously sampled values from a custom probability distribution.
There are three possibilities: (i) if <code>n</code> is equal to the number previously
sampled values (say <code>n_samples</code>), then <code>x</code> is returned as is; (ii) if
<code>n</code> &lt; <code>n_samples</code>, then samples from <code>x</code> are sampled without replacement;
and (iii) if <code>n</code> &gt; <code>n_samples</code>, then samples from <code>x</code> are sampled with replacement
and a warning is provided.</p>
</dd>
<dt><code>dirichlet_rng()</code></dt><dd><p>Dirichlet variates for each row in the matrix are
generated with <code><a href="#topic+rdirichlet_mat">rdirichlet_mat()</a></code>. The sampled values are stored in a <code>data.table</code>
where there is a column for each element of <code>alpha</code>
(with elements ordered rowwise).</p>
</dd>
<dt><code>fixed()</code></dt><dd><p>This function should be used when values of the variable
of interest are fixed (i.e., they are known with certainty). If <code>length(est) &gt; 1</code>,
an <code>n</code> by <code>length(est)</code> <code>data.table</code> is returned meaning that each element of <code>est</code>
is repeated <code>n</code> times; otherwise (if <code>length(est) == 1</code>), a vector is returned
where <code>est</code> is repeated <code>n</code> times.</p>
</dd>
<dt><code>gamma_rng()</code></dt><dd><p>The parameters of the gamma distribution are derived using
the methods of moments with <code><a href="#topic+mom_gamma">mom_gamma()</a></code> and gamma variates are generated
with <code><a href="stats.html#topic+GammaDist">stats::rgamma()</a></code>.</p>
</dd>
<dt><code>lognormal_rng()</code></dt><dd><p>Lognormal variates are generated with <code><a href="stats.html#topic+Lognormal">stats::rlnorm()</a></code>.</p>
</dd>
<dt><code>multi_normal_rng()</code></dt><dd><p>Multivariate normal variates are generated with <code><a href="MASS.html#topic+mvrnorm">MASS::mvrnorm()</a></code>.</p>
</dd>
<dt><code>normal_rng()</code></dt><dd><p>Normal variates are generated with <code><a href="stats.html#topic+Normal">stats::rnorm()</a></code>.</p>
</dd>
<dt><code>uniform_rng()</code></dt><dd><p>Uniform variates are generated with <code><a href="stats.html#topic+Uniform">stats::runif()</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Functions either return a vector of length <code>n</code> or an <code>n</code> by <code>k</code> <code>data.table</code>.
Multivariate distributions always return a <code>data.table</code>. If a
univariate distribution is used, then a <code>data.table</code> is returned if each
parameter is specified as a vector with length greater than 1; otherwise, if
parameters are scalars, then a vector is returned. In the <code>data.table</code> case,
<code>k</code> is equal to the length of the parameter vectors
entered as  arguments. For example, if the probability distribution contained
<code>mean</code> as an argument and <code>mean</code> were
of length 3, then an <code>n</code> by 3 matrix would be returned. The length of all
parameter vectors must be the same. For instance, if the vector <code>mean</code>
were of length 3 then all additional parameters (e.g., <code>sd</code>)
must also be of length 3.
</p>
<p>If a <code>data.table</code> is returned by a distribution, then its column names are set
according to the following hierarchy:
</p>

<ol>
<li><p> With the <code>names</code> argument if it is not <code>NULL</code>
</p>
</li>
<li><p> With the names of the parameter vectors if they are named vectors. If there
are multiple parameter vector arguments, then the names of the first parameter
vector with non <code>NULL</code> names is used. For instance, if <code>mean</code> and <code>sd</code> are
both arguments to a random number generation function and <code>mean</code> is a
named vector, then the names from the vector <code>mean</code> are used.
</p>
</li>
<li><p> As <code>v1</code>, ..., <code>vk</code> if the <code>names</code> argument is <code>NULL</code> and there are no
named parameter vectors.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+define_rng">define_rng()</a></code>
</p>

<hr>
<h2 id='rpwexp'>Random generation for piecewise exponential distribution</h2><span id='topic+rpwexp'></span>

<h3>Description</h3>

<p>Draw random samples from an exponential distribution with piecewise rates.
<code>rpwexp</code> is vectorized and written in C++ for speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpwexp(n, rate = 1, time = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpwexp_+3A_n">n</code></td>
<td>
<p>Number of random observations to draw.</p>
</td></tr>
<tr><td><code id="rpwexp_+3A_rate">rate</code></td>
<td>
<p>A matrix of rates where rows correspond to observations
and columns correspond to rates during specified time intervals.</p>
</td></tr>
<tr><td><code id="rpwexp_+3A_time">time</code></td>
<td>
<p>A vector equal to the number of columns in <code>rate</code> giving the
times at which the rate changes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of random samples from the piecewise exponential distribution. The length of the sample is
determined by n. The numerical arguments other than n are recycled so that the number of samples is
equal to n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate &lt;- c(.6, 1.2, 1.3)
n &lt;- 100000
ratemat &lt;- matrix(rep(rate, n/2), nrow = n, 
                  ncol = 3, byrow = TRUE)
t &lt;- c(0, 10, 15) 
ptm &lt;- proc.time()
samp &lt;- rpwexp(n, ratemat, t)
proc.time() - ptm
summary(samp)
</code></pre>

<hr>
<h2 id='set_labels'>Set value labels</h2><span id='topic+set_labels'></span>

<h3>Description</h3>

<p>Update existing variables or create new ones that replace existing values
with more informative labels as in <code><a href="base.html#topic+factor">factor()</a></code>. All modifications are performed
by reference (see <code><a href="data.table.html#topic+assign">data.table::set()</a></code> for more information about assignment by
reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_labels(x, labels, new_names = NULL, as_factor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_labels_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="set_labels_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
<tr><td><code id="set_labels_+3A_new_names">new_names</code></td>
<td>
<p>A character vector of the same length as <code>labels</code> where
each element denotes the name of a new variable to create for the
corresponding element in <code>labels</code>. If <code>NULL</code>, then the variables in <code>labels</code>
are modified and no new variables are created; otherwise, the existing variables
are not modified and new variables are created instead.</p>
</td></tr>
<tr><td><code id="set_labels_+3A_as_factor">as_factor</code></td>
<td>
<p>If <code>TRUE</code> factor variables are created; otherwise character
vectors are created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is modified by reference and returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_labels">get_labels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
labs &lt;- list("strategy_id" = c("s1" = 1, 
                               "s2" = 2),
            "grp_id" = c("g1" = 1, 
                         "g2" = 2))
d1 &lt;- data.table(strategy_id = 1:2, grp_id = 1:2)
d2 &lt;- copy(d1); d3 &lt;- copy(d2)
set_labels(d2, labels = labs)
set_labels(d3, labels = labs, new_names = c("strategy_name", "grp_name"))
d1
d2
d3
</code></pre>

<hr>
<h2 id='sim_ev'>Expected values from state probabilities</h2><span id='topic+sim_ev'></span><span id='topic+sim_ev.stateprobs'></span><span id='topic+sim_costs'></span><span id='topic+sim_qalys'></span>

<h3>Description</h3>

<p>Simulate expected values as a function of simulated state occupancy
probabilities, with simulation of costs and quality-adjusted life-years
(QALYs) as particular use cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stateprobs'
sim_ev(
  object,
  models = NULL,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  value_name = "value",
  outcome_name = "outcome",
  ...
)

sim_qalys(
  object,
  model,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  lys = TRUE
)

sim_costs(
  object,
  models,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ev_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+stateprobs">stateprobs</a></code> object.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_dr">dr</code></td>
<td>
<p>Discount rate.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_integrate_method">integrate_method</code></td>
<td>
<p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> (the default) for the trapezoid rule,
<code>riemann_left</code> left for a left Riemann sum, and
<code>riemann_right</code> right for a right Riemann sum.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_value_name">value_name</code></td>
<td>
<p>Name of the column containing values of the outcome. Default
is <code>"value"</code>.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_outcome_name">outcome_name</code></td>
<td>
<p>Name of the column indicating the outcome corresponding
to each model. Only used if <code>models</code> is a list. Default is <code>"outcome"</code>.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_model">model</code>, <code id="sim_ev_+3A_models">models</code></td>
<td>
<p>An object or list of objects of class <code><a href="#topic+StateVals">StateVals</a></code> used to
model state values. When using <code>sim_qalys()</code>, this should be
a single model for utility. With <code>sim_costs()</code>, a list of models should be
used with one model for each cost category. Finally, with <code>sim_ev()</code>,
this may either be a single model or a list of models. May also be <code>NULL</code>,
in which case length of stay is computed based on the state probabilities
contained in <code>object</code>.</p>
</td></tr>
<tr><td><code id="sim_ev_+3A_lys">lys</code></td>
<td>
<p>If <code>TRUE</code>, then life-years are simulated in addition to
QALYs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expected values in cohort models (i.e.,  those implemented with
the <code><a href="#topic+CohortDtstm">CohortDtstm</a></code> and <code><a href="#topic+Psm">Psm</a></code> classes) are mean outcomes for patients comprising
the cohort. The method used to simulate expected values depends on the
<code style="white-space: pre;">&#8288;$method&#8288;</code> field in the <code><a href="#topic+StateVals">StateVals</a></code> object(s) stored in <code>model(s)</code>. If
<code style="white-space: pre;">&#8288;$method = "starting"&#8288;</code>, then state values represent a one-time value that
occurs at time 0.
</p>
<p>The more common use case is <code style="white-space: pre;">&#8288;$method = "wlos"&#8288;</code>, or a &quot;weighted length of stay&quot;.
That is, expected values for each health state can be thought of as state values
weighted by the time a patient spends in each state (and discounted by a
discount factor that depends on the discount rate <code>dr</code>). The
precise computation proceeds in four steps. In the first step, the probability
of being in each health state at each discrete time point is simulated
(this is the output contained in the <code><a href="#topic+stateprobs">stateprobs</a></code> object). Second, a
<code><a href="#topic+StateVals">StateVals</a></code> model is used to predict state values at each time point.
Third an expected value at each time point is computed by multiplying the
state probability, the state value, and the discount factor. Fourth, the
expected values at each time point are summed across all time points.
</p>
<p>The summation in the fourth step can be thought of as a discrete approximation
of an integral. In particular, the limits of integration can be partitioned
into time intervals, with each interval containing a start and an end.
The <code>integrate_method</code> argument determines the approach used
for this approximation:
</p>

<ol>
<li><p> A left Riemann sum (<code>integrate_method = "riemann_left"</code>) uses expected values
at the start of each time interval.
</p>
</li>
<li><p> A right Riemann sum (<code>integrate_method = "riemann_right"</code>) uses expected values
at the end of each time interval.
</p>
</li>
<li><p> The trapezoid rule (<code>integrate_method = "trapz"</code>) averages expected values
at the start and end of each time interval. (This will generally be the
most accurate and is recommended.)
</p>
</li></ol>

<p>Mathematical details are provided in the reference within the &quot;References&quot;
section below.
</p>


<h3>Value</h3>

<p><code>sim_ev()</code> returns a <code>data.table</code> with the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>grp_id</dt><dd><p>The subgroup ID.</p>
</dd>
<dt>state_id</dt><dd><p>The health state ID.</p>
</dd>
<dt>dr</dt><dd><p>The rate used to discount costs.</p>
</dd>
<dt>outcome</dt><dd><p>The outcome corresponding to each model in <code>models</code>.
Only included if <code>models</code> is a list.</p>
</dd>
<dt>value</dt><dd><p>The expected value.</p>
</dd>
</dl>

<p>The names of the <code>outcome</code> and <code>value</code> columns may be changed with the
<code>value_name</code> and <code>outcome_name</code> arguments. <code>sim_costs()</code> and <code>sim_qalys()</code>
return similar objects, that are of class <code><a href="#topic+costs">costs</a></code> and <code><a href="#topic+qalys">qalys</a></code>, respectively.
</p>


<h3>Note</h3>

<p>The ID variables in the state value models in <code>models</code> must be
consistent with the ID variables contained in <code>object</code>. In particular,
the <code>models</code> should predict state values for each non-absorbing health state
in <code>object</code>; that is, the number of health states modeled with the
<code>models</code> should equal the number of health states in <code>object</code> less the number
of absorbing states.
</p>
<p>The absorbing states are saved as an attribute named <code>absorbing</code> to
<code><a href="#topic+stateprobs">stateprobs</a></code> objects. When simulating state probabilities with a
<code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> object, the absorbing state is determined by the
<code>absorbing</code> field in the class; in a <code>Psm</code> (or with
<code><a href="#topic+sim_stateprobs.survival">sim_stateprobs.survival()</a></code>), the absorbing state is always equal to the
final health state.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.1 for mathematical details.
</p>


<h3>See Also</h3>

<p>State probabilities can be simulated using the
<code style="white-space: pre;">&#8288;$sim_stateprobs()&#8288;</code> methods from either the <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code>
(or <code><a href="#topic+CohortDtstm">CohortDtstm</a></code>) or <code><a href="#topic+Psm">Psm</a></code> classes. State probabilities can also be
computed directly from survival curves with the generic method
<code><a href="#topic+sim_stateprobs.survival">sim_stateprobs.survival()</a></code>.
</p>
<p>Costs and QALYs are typically computed within the <code>R6</code> model classes
using the <code style="white-space: pre;">&#8288;$sim_costs()&#8288;</code> and <code style="white-space: pre;">&#8288;$sim_qalys()&#8288;</code> methods. For instance, see the
documentation and examples for the <code><a href="#topic+CohortDtstm">CohortDtstm</a></code> and <code><a href="#topic+Psm">Psm</a></code> classes.
The <code>sim_qalys()</code> and <code>sim_costs()</code> functions are exported to give users
additional flexibility when creating their own modeling pipelines.
<code>sim_ev()</code> may be useful for computing outcomes other than costs or QALYs.
</p>
<p><code><a href="#topic+costs">costs</a></code> and <code><a href="#topic+qalys">qalys</a></code> objects can be passed to <code><a href="#topic+summarize_ce">summarize_ce()</a></code> to
create a cost-effectiveness object for performing a cost-effectiveness analysis
with <code><a href="#topic+cea">cea()</a></code>. Although note that typically the <code style="white-space: pre;">&#8288;$summarize()&#8288;</code> method
belonging to the <code><a href="#topic+CohortDtstm">CohortDtstm</a></code> or <code><a href="#topic+Psm">Psm</a></code> classes would be used instead.
</p>
<p>Use the <code><a href="#topic+IndivCtstm">IndivCtstm</a></code> class to simulate costs and QALYs with an individual
continuous-time state transition model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need (i) a state probability object and (ii) a model for state values
## We should start by setting up our decision problem
hesim_dat &lt;-  hesim_data(strategies = data.frame(strategy_id = 1:2),
                         patients = data.frame(patient_id = 1:3),
                         states = data.frame(state_id = 1))
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))

## (i) Simulate a state probability object
tpmat_id &lt;- tpmatrix_id(input_data, n_samples = 2) 
p_12 &lt;- ifelse(tpmat_id$strategy_id == 1, .15, .1)
tpmat &lt;- tpmatrix(
  C, p_12,
  0, 1
)
transmod &lt;- CohortDtstmTrans$new(params = tparams_transprobs(tpmat, tpmat_id))
stprobs &lt;- transmod$sim_stateprobs(n_cycles = 3)

## Construct model for state values
outcome_tbl &lt;- stateval_tbl(
  data.frame(
    state_id = 1,
    est = 5000
  ),
  dist = "fixed"
)
outmod &lt;- create_StateVals(outcome_tbl, n = 2, hesim_data = hesim_dat)

# We can then simulate expected values
## The generic expected values function
sim_ev(stprobs, models = outmod)

## We can also pass a list of models
sim_ev(stprobs, models = list(`Outcome 1` = outmod))

## Suppose the outcome were a cost category. Then we might
## prefer the following:
sim_costs(stprobs, models = list(drug = outmod))

## Length of stay is computed if there is no state value model
sim_ev(stprobs)
</code></pre>

<hr>
<h2 id='sim_stateprobs'>Simulated state probabilities</h2><span id='topic+sim_stateprobs'></span>

<h3>Description</h3>

<p>A generic function to simulate state probabilities and create an object of
class <code><a href="#topic+stateprobs">stateprobs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_stateprobs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_stateprobs_+3A_x">x</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="sim_stateprobs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+stateprobs">stateprobs</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_stateprobs.survival">sim_stateprobs.survival</a></code>
</p>

<hr>
<h2 id='sim_stateprobs.survival'>Simulate state probabilities from survival curves</h2><span id='topic+sim_stateprobs.survival'></span>

<h3>Description</h3>

<p>Simulate health state probabilities from a <code><a href="#topic+survival">survival</a></code> object using partitioned
survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survival'
sim_stateprobs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_stateprobs.survival_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+survival">survival</a></code>.</p>
</td></tr>
<tr><td><code id="sim_stateprobs.survival_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code class="reqn">N</code>-state partitioned survival model there are <code class="reqn">N-1</code> survival curves
and <code class="reqn">S_n(t)</code> is the cumulative survival function denoting the probability of
survival to health state <code class="reqn">n</code> or a lower indexed state beyond time <code class="reqn">t</code>.
The probability that a patient is in health state 1 at time <code class="reqn">t</code> is simply
<code class="reqn">S_1(t)</code>. State membership in health states <code class="reqn">2,\ldots, N -1</code> is calculated
as <code class="reqn">S_n(t) - S_{n-1}(t)</code>. Finally, the probability of being in the final
health state <code class="reqn">N</code> (i.e., the death state) is <code class="reqn">1-S_{N-1}(t)</code>, or
one minus the overall survival curve.
</p>
<p>In some cases, the survival curves may cross. <code>hesim</code> will issue a warning
but the function will still run. Probabilities will be set to 0 in a health state
if the prior survival curve lies above the curve for state <code class="reqn">n</code>;
that is, if <code class="reqn">S_n(t) &lt; S_{n-1}(t)</code>, then the probability of being in state <code class="reqn">n</code>
is set to 0 and <code class="reqn">S_n(t)</code> is adjusted to equal <code class="reqn">S_{n-1}(t)</code>. The
probability of being in the final health state is also adjusted if necessary to
ensure that probabilities sum to 1.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+stateprobs">stateprobs</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survival">survival</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
library("survival")

# This example shows how to simulate a partitioned survival model by
# manually constructing a "survival" object. We will consider a case in which
# Cox proportional hazards models from the survival package---which are not
# integrated with hesim---are used for parameter estimation. We will use 
# point estimates in the example, but bootstrapping, Bayesian modeling,
# or other techniques could be used to draw samples for a probabilistic 
# sensitivity analysis. 

# (0) We first setup our model per usual by defining the treatment strategies,
# target population, and health states
hesim_dat &lt;- hesim_data(
  strategies = data.table(strategy_id = 1:3,
                          strategy_name = c("SOC", "New 1", "New 2")),
  patients = data.table(patient_id = 1:2,
                        female = c(0, 1),
                        grp_id = 1),
  states = data.table(state_id = 1:2,
                      state_name = c("Stable", "Progression"))
)

# (1) Next we will estimate Cox models with survival::coxph(). We illustrate 
# by predicting progression free survival (PFS) and overall survival (OS)
## Fit models
onc3_pfs_os &lt;- as_pfs_os(onc3, patient_vars = c("patient_id", "female",
                                                "strategy_name"))
fit_pfs &lt;- coxph(Surv(pfs_time, pfs_status) ~ strategy_name + female,
                 data = onc3_pfs_os)
fit_os &lt;- coxph(Surv(os_time, pfs_status) ~ strategy_name + female,
                data = onc3_pfs_os)

## Predict survival on input data
surv_input_data &lt;- expand(hesim_dat)
times &lt;- seq(0, 14, 1/12)
predict_survival &lt;- function(object, newdata, times) {
  surv &lt;- summary(survfit(object, newdata = newdata, se.fit = FALSE),
                  t = times)
  pred &lt;- newdata[rep(seq_len(nrow(newdata)), each = length(times)), ]
  pred[, sample := 1] # Point estimates only in this example
  pred[, time := rep(surv$time, times = nrow(newdata))]
  pred[, survival := c(surv$surv)]
  return(pred[, ])
}
pfs &lt;- predict_survival(fit_pfs, newdata = surv_input_data, times = times)
os &lt;- predict_survival(fit_os, newdata = surv_input_data, times = times)
surv &lt;- rbind(
  as.data.table(pfs)[, curve := 1L],
  as.data.table(os)[, curve := 2L]
)

## Convert predictions to a survival object
surv &lt;- survival(surv, t = "time")
## Not run: autoplot(surv)

# (2) We can then compute state probabilities from the survival object
stprobs &lt;- sim_stateprobs(surv)

# (3) Finally, we can use the state probabilities to compute QALYs and costs
## A dummy utility model to illustrate
utility_tbl &lt;- stateval_tbl(
  data.table(state_id = 1:2,
             est = c(1, 1)
  ),
  dist = "fixed"
)
utilitymod &lt;- create_StateVals(utility_tbl, 
                               hesim_data = hesim_dat,
                               n = 1)

## Instantiate Psm class and compute QALYs
psm &lt;- Psm$new(utility_model = utilitymod)
psm$stateprobs_ &lt;- stprobs
psm$sim_qalys()
psm$qalys_

</code></pre>

<hr>
<h2 id='stateprobs'>State probability object</h2><span id='topic+stateprobs'></span>

<h3>Description</h3>

<p>An object of class <code>stateprobs</code> returned by <code><a href="#topic+sim_stateprobs">sim_stateprobs()</a></code> or from
<code style="white-space: pre;">&#8288;$sim_stateprobs()&#8288;</code> methods in model classes.
</p>


<h3>Components</h3>

<p>A <code>stateprobs</code> object inherits from <code>data.table</code> and contains
the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>grp_id</dt><dd><p>The subgroup ID.</p>
</dd>
<dt>state_id</dt><dd><p>The health state ID.</p>
</dd>
<dt>t</dt><dd><p>The time at which a state probability is computed.</p>
</dd>
<dt>prob</dt><dd><p>The probability of being in a given health state.</p>
</dd>
</dl>

<p>When simulating individual-level models, the <code>patient_id</code> column is
not included as state probabilities are computed by averaging across patients.
</p>
<p>In cohort models, the object also contains <code>size</code> and <code>absorbing</code> attributes.
The <code>size</code> attribute is a numeric vector with the elements <code>n_samples</code>,
<code>n_strategies</code>, <code>n_patients</code>, <code>n_states</code>, and
<code>n_times</code> denoting the number of samples, treatment strategies, patients,
health states, and times. The <code>absorbing</code> attribute is a numeric vector
containing the absorbing health states (see the <code>absorbing</code> field of the
<code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> class for more details).
</p>

<hr>
<h2 id='stateval_tbl'>Table to store state value parameters</h2><span id='topic+stateval_tbl'></span>

<h3>Description</h3>

<p>Create a table for storing parameter estimates used to simulate costs or
utility in an economic model by treatment strategy, patient, health state, and
(optionally) time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateval_tbl(
  tbl,
  dist = c("norm", "beta", "gamma", "lnorm", "unif", "fixed", "custom"),
  hesim_data = NULL,
  grp_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stateval_tbl_+3A_tbl">tbl</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> for storing parameter
values. See &quot;Details&quot; for specifics.</p>
</td></tr>
<tr><td><code id="stateval_tbl_+3A_dist">dist</code></td>
<td>
<p>Probability distribution used to sample parameters for a
probabilistic sensitivity analysis (PSA).</p>
</td></tr>
<tr><td><code id="stateval_tbl_+3A_hesim_data">hesim_data</code></td>
<td>
<p>A <code><a href="#topic+hesim_data">hesim_data</a></code> object. This argument is deprecated
and should be passed to <code><a href="#topic+create_StateVals.stateval_tbl">create_StateVals.stateval_tbl()</a></code> instead.</p>
</td></tr>
<tr><td><code id="stateval_tbl_+3A_grp_var">grp_var</code></td>
<td>
<p>The name of the variable used to group patients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tbl</code> is a tabular object containing columns for treatment
strategies (<code>strategy_id</code>), patients (<code>patient_id</code>),
health states (<code>state_id</code>), and/or the start of time intervals
(<code>time_start</code>). The table must contain at least one column
named <code>strategy_id</code>, <code>patient_id</code>, or <code>state_id</code>,
but does not need to contain all of them. Each row denotes a unique
treatment strategy, patient, health state, and/or time interval pair.
<code>tbl</code> may also contain a column with the name specified in <code>grp_var</code>
(rather than <code>patient_id</code>) so that state values are assigned to
groups of patients.
</p>
<p><code>tbl</code> must also contain columns summarizing the state values for each
row, which depend on the probability distribution selected with <code>dist</code>.
Available distributions include the normal (<code>norm</code>), beta (<code>beta</code>),
gamma (<code>gamma</code>), lognormal (<code>lnorm</code>), and uniform (<code>unif</code>)
distributions. In addition, the option <code>fixed</code> can be used if estimates
are known with certainty and <code>custom</code> can be used if
parameter values for a PSA  have been previously
sampled from an arbitrary probability distribution.
The columns in <code>tbl</code> that must be included,
by distribution, are:
</p>

<dl>
<dt>norm</dt><dd><p><code>mean</code> and <code>sd</code></p>
</dd>
<dt>beta</dt><dd><p><code>mean</code> and <code>se</code> or <code>shape1</code> and <code>shape2</code></p>
</dd>
<dt>gamma</dt><dd><p><code>mean</code> and <code>se</code>, <code>shape</code> and <code>rate</code>,
or <code>shape</code> and <code>scale</code></p>
</dd>
<dt>lnorm</dt><dd><p><code>meanlog</code> or <code>sdlog</code></p>
</dd>
<dt>unif</dt><dd><p><code>min</code> and <code>max</code></p>
</dd>
<dt>fixed</dt><dd><p><code>est</code></p>
</dd>
<dt>custom</dt><dd><p><code>sample</code> and <code>value</code></p>
</dd>
</dl>

<p>Note that if <code>dist = "custom"</code>, then <code>tbl</code> must include a column
named <code>sample</code> (an integer vector denoting a unique random draw) and
<code>value</code> (denoting the value of the randomly sampled parameter). In this case,
there is a unique row in <code>tbl</code> for each random draw (<code>sample</code>) and
each combination of strategies, patients, health states, and/or time intervals.
Again, <code>tbl</code> must contain at least one column
named <code>strategy_id</code>, <code>patient_id</code> (or <code>grp_var</code>), or <code>state_id</code>,
but does not need to contain them all.
</p>


<h3>Value</h3>

<p>An object of class <code>stateval_tbl</code>, which is a <code>data.table</code> of
parameter values with attributes for <code>dist</code> and <code>grp_var</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_StateVals">create_StateVals()</a></code>, <code><a href="#topic+StateVals">StateVals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3),
                       grp = c(1, 1, 2),
                       age = c(45, 50, 60),
                       female = c(0, 0, 1))
states &lt;- data.frame(state_id = c(1, 2))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients,
                        states = states)

# Utility varies by health state and patient group
utility_tbl &lt;- stateval_tbl(data.frame(state_id = rep(states$state_id, 2),
                                       grp = rep(rep(c(1, 2)), each = nrow(states)), 
                                       mean = c(.8, .7, .75, .55),
                                       se = c(.18, .12, .10, .06)),
                            dist = "beta",
                            grp_var = "grp")
print(utility_tbl)
utilmod &lt;- create_StateVals(utility_tbl, n = 2, hesim_data = hesim_dat)

# Costs vary by treatment strategy
cost_tbl &lt;- stateval_tbl(data.frame(strategy_id = strategies$strategy_id,
                                    mean = c(5000, 3000),
                                    se = c(200, 100)),
                         dist = "gamma")
print(cost_tbl)
costmod &lt;- create_StateVals(cost_tbl, n = 2, hesim_data = hesim_dat)


</code></pre>

<hr>
<h2 id='StateVals'>Model for state values</h2><span id='topic+StateVals'></span>

<h3>Description</h3>

<p>Simulate values (i.e., utility or costs) associated with health states in a
state transition or partitioned survival model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>params</code></dt><dd><p>Parameters for simulating state values. Currently supports
objects of class <code><a href="#topic+tparams_mean">tparams_mean</a></code> or <code><a href="#topic+params_lm">params_lm</a></code>.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>An object of class <a href="#topic+input_mats">input_mats</a>. Only used for
<code><a href="#topic+params_lm">params_lm</a></code> objects.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used to simulate costs and
quality-adjusted life-years (QALYs) as a function of state values.
If <code>wlos</code>, then costs and QALYs are
simulated by weighting state values by the length of stay in a health
state. If <code>starting</code>, then state values represent a one-time value
that occurs when a patient enters a health state. When <code>starting</code> is
used in a cohort model, the state values only accrue at time 0;
in contrast, in an individual-level model, state values
accrue each time a patient enters a new state and are discounted based on
time of entrance into that state.</p>
</dd>
<dt><code>time_reset</code></dt><dd><p>If <code>FALSE</code> then time intervals are based on time since
the start of the simulation. If <code>TRUE</code>, then time intervals reset each
time a patient enters a new health state. This is relevant if, for example,
costs vary over time within health states. Only used if <code>method = wlos</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StateVals-new"><code>StateVals$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StateVals-sim"><code>StateVals$sim()</code></a>
</p>
</li>
<li> <p><a href="#method-StateVals-check"><code>StateVals$check()</code></a>
</p>
</li>
<li> <p><a href="#method-StateVals-clone"><code>StateVals$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StateVals-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>StateVals</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>StateVals$new(
  params,
  input_data = NULL,
  method = c("wlos", "starting"),
  time_reset = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>The <code>params</code> field.</p>
</dd>
<dt><code>input_data</code></dt><dd><p>The <code>input_data</code> field.</p>
</dd>
<dt><code>method</code></dt><dd><p>The <code>method</code> field.</p>
</dd>
<dt><code>time_reset</code></dt><dd><p>The <code>time_reset</code> field.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>StateVals</code> object.
</p>


<hr>
<a id="method-StateVals-sim"></a>



<h4>Method <code>sim()</code></h4>

<p>Simulate state values with either predicted means or random samples by
treatment strategy, patient, health state, and time <code>t</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>StateVals$sim(t, type = c("predict", "random"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>A numeric vector of times.</p>
</dd>
<dt><code>type</code></dt><dd><p><code>"predict"</code> for mean values or <code>"random"</code> for random samples.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.table</code> of simulated state values with columns for <code>sample</code>,
<code>strategy_id</code>, <code>patient_id</code>, <code>state_id</code>, <code>time</code>, and <code>value</code>.
</p>


<hr>
<a id="method-StateVals-check"></a>



<h4>Method <code>check()</code></h4>

<p>Input validation for class. Checks that fields are the correct type.
</p>


<h5>Usage</h5>

<div class="r"><pre>StateVals$check()</pre></div>


<hr>
<a id="method-StateVals-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StateVals$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Simple sick-sicker example where drug costs vary by treatment strategy
# and over time. Prior to time = 5, costs are $10,000 for treatment strategy 
# 1 and $5,000 for treatment strategy 2. After time = 5, costs are $2,000
# for both treatment strategies

## Setup the model
hesim_dat &lt;- hesim_data(
  strategies = data.frame(strategy_id = c(1, 2)),
  patients = data.frame(patient_id = 1:3),
  states = data.frame(state_id = c(1, 2), # Non-death states
                      state_name = c("sick", "sicker")) 
)

## Drug costs vary by health state and time interval
drugcost_tbl &lt;- stateval_tbl(
  data.frame(
    strategy_id = c(1, 1, 2, 2),
    time_start = c(0, 5, 0, 5),
    est = c(10000, 2000, 5000, 2000)
  ),
  dist = "fixed"
)
drugcost_tbl

## Create drug cost model
drugcostmod &lt;- create_StateVals(drugcost_tbl, n = 1, hesim_data = hesim_dat)
      
## Explore predictions from the drug cost model
drugcostmod$sim(t = c(2, 6), type = "predict")
 
</code></pre>

<hr>
<h2 id='summarize_ce'>Summarize costs and effectiveness</h2><span id='topic+summarize_ce'></span>

<h3>Description</h3>

<p>Summarize costs and quality-adjusted life-years (QALYs) given output simulated
from an economic model. The summary output is used to perform
cost-effectiveness analysis with <code><a href="#topic+cea">cea()</a></code> and <code><a href="#topic+cea_pw">cea_pw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_ce(costs, qalys, by_grp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_ce_+3A_costs">costs</code></td>
<td>
<p>Simulated costs by category (objects of class <code><a href="#topic+costs">costs</a></code>).</p>
</td></tr>
<tr><td><code id="summarize_ce_+3A_qalys">qalys</code></td>
<td>
<p>Simulated QALYs (objects of class <code><a href="#topic+qalys">qalys</a></code>).</p>
</td></tr>
<tr><td><code id="summarize_ce_+3A_by_grp">by_grp</code></td>
<td>
<p>If <code>TRUE</code>, then costs and QALYs are computed by subgroup. If
<code>FALSE</code>, then costs and QALYs are aggregated across all patients (and subgroups).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If mean costs and/or QALYs have already been computed
(i.e., an average within a population), then there
must be one observation for each discount rate (<code>dr</code>),
PSA sample (<code>sample</code>), treatment strategy (<code>strategy_id</code>),
and health state (<code>state_id</code>). Alternatively, there can be a column
denoting a patient (<code>patient_id</code>), in which case outcomes will first be
averaged across patients. A <code>grp_id</code> column can also be used so that
outcomes are computed for each subgroup (if <code>by_grp = TRUE</code>); otherwise it is assumed that
there is only one subgroup.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ce">ce</a></code>.
</p>

<hr>
<h2 id='summary.ce'>Summary method for cost-effectiveness object</h2><span id='topic+summary.ce'></span><span id='topic+format.summary.ce'></span>

<h3>Description</h3>

<p>Summarize a <code><a href="#topic+ce">ce</a></code> object by producing confidence intervals for quality-adjusted
life-years (QALYs) and each cost category with <code>summary.ce()</code> and format for
pretty printing with <code>format.summary.ce()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ce'
summary(object, prob = 0.95, labels = NULL, ...)

## S3 method for class 'summary.ce'
format(
  x,
  digits_qalys = 2,
  digits_costs = 0,
  dr_qalys = NULL,
  dr_costs = NULL,
  pivot_from = "strategy",
  drop_grp = TRUE,
  pretty_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ce_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+ce">ce</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval <code style="white-space: pre;">&#8288;(0,1)&#8288;</code> giving the confidence interval.
Default is 0.95 for a 95 percent interval.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_labels">labels</code></td>
<td>
<p>A list of named vectors containing the values and labels of
variables. The elements of each vector are the values of a variable and the
names are the labels. The names of the list are the names of the variables.
See the output returned by <code><a href="#topic+get_labels">get_labels()</a></code> for an example.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_x">x</code></td>
<td>
<p>A <code>summary.ce</code> object.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_digits_qalys">digits_qalys</code></td>
<td>
<p>Number of digits to use to report QALYs.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_digits_costs">digits_costs</code></td>
<td>
<p>Number of digits to use to report costs.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_dr_qalys">dr_qalys</code></td>
<td>
<p>Discount rate to subset to for quality-adjusted life-years (QALYs).</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_dr_costs">dr_costs</code></td>
<td>
<p>Discount rate to subset to for costs.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_pivot_from">pivot_from</code></td>
<td>
<p>Character vector denoting a column or columns used to
&quot;widen&quot; the data. Should either be <code>"strategy"</code>, <code>"grp"</code>, <code>"outcome"</code>,
or some combination of the three. There will be one column for each value of
the variables in <code>pivot_from</code>. Default is to widen so there is a column for each treatment
strategy. Set to <code>NULL</code> if you do not want to widen the table.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_drop_grp">drop_grp</code></td>
<td>
<p>If <code>TRUE</code>, then the group column will be removed if there is only
one subgroup; other it will be kept. If <code>FALSE</code>, then the <code>grp</code> column is never
removed.</p>
</td></tr>
<tr><td><code id="summary.ce_+3A_pretty_names">pretty_names</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the columns <code>strategy</code>, <code>grp</code>,
<code>outcome</code>, <code>dr</code>, and <code>value</code> are renamed (if they exist) to <code>Strategy</code>, <code>Group</code>,
<code>Outcome</code>, <code style="white-space: pre;">&#8288;Discount rate&#8288;</code>, and <code>Value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an example, see <code><a href="#topic+IndivCtstm">IndivCtstm</a></code>.
</p>


<h3>Value</h3>

<p><code>summary.ce()</code> returns an object of class <code>summary.ce</code> that is a tidy
<code>data.table</code> with the following columns:
</p>

<dl>
<dt>dr</dt><dd><p>The discount rate.</p>
</dd>
<dt>strategy</dt><dd><p>The treatment strategy.</p>
</dd>
<dt>grp</dt><dd><p>The patient subgroup.</p>
</dd>
<dt>type</dt><dd><p>Either <code>"QALYs"</code> or <code>"Costs"</code>.</p>
</dd>
<dt>category</dt><dd><p>Category is always <code>"QALYs"</code> when <code>type == "QALYs"</code>; otherwise,
it is the cost category.</p>
</dd>
<dt>estimate</dt><dd><p>The point estimate computed as the average across the PSA samples.</p>
</dd>
<dt>lower</dt><dd><p>The lower limit of the confidence interval.</p>
</dd>
<dt>upper</dt><dd><p>The upper limit of the confidence interval.</p>
</dd>
</dl>

<p><code>format.summary.ce()</code> formats the table according to the arguments passed.
</p>

<hr>
<h2 id='summary.eval_rng'>Summarize <code>eval_rng</code> object</h2><span id='topic+summary.eval_rng'></span><span id='topic+print.eval_rng'></span>

<h3>Description</h3>

<p>Summarize the model parameters randomly sampled for probabilistic sensitivity
analysis with <code><a href="#topic+eval_rng">eval_rng()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eval_rng'
summary(object, probs = c(0.025, 0.975), sep = "_", ...)

## S3 method for class 'eval_rng'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eval_rng_+3A_object">object</code>, <code id="summary.eval_rng_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+eval_rng">eval_rng</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.eval_rng_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used to
compute quantiles with <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.eval_rng_+3A_sep">sep</code></td>
<td>
<p>When a list element returned by <code>eval_rng</code> is a tabular object,
the parameter name is created by concatenating the name of the list element
with the columns of the tabular object. The <code>sep</code> argument determines the
character string used to separate the terms.</p>
</td></tr>
<tr><td><code id="summary.eval_rng_+3A_...">...</code></td>
<td>
<p>For the print method, arguments to pass to <code>summary.eval_rng()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.eval_rng()</code> returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns for
(i) the name of the parameter (<code>param</code>), (ii) the mean of the parameter
samples (<code>mean</code>), (iii) the standard deviation of the parameter samples (<code>sd</code>),
and (iv) quantiles of the parameter samples corresponding
to the <code>probs</code> argument. <code>print.eval_rng()</code> prints the output of
<code>summary.eval_rng()</code> to the console.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+eval_rng">eval_rng()</a></code> for an example.
</p>

<hr>
<h2 id='summary.params'>Summarize parameter objects</h2><span id='topic+summary.params'></span><span id='topic+summary.params_lm'></span><span id='topic+summary.params_mlogit'></span><span id='topic+summary.params_mlogit_list'></span><span id='topic+summary.params_surv'></span><span id='topic+summary.params_surv_list'></span>

<h3>Description</h3>

<p>Summarize the coefficients of a parameter object by computing the mean,
standard deviation, and quantiles for each model term.
This is a convenient way to check whether a parameter object has been specified
correctly and sampling distributions of the coefficients are as expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'params_lm'
summary(object, probs = c(0.025, 0.975), ...)

## S3 method for class 'params_mlogit'
summary(object, probs = c(0.025, 0.975), ...)

## S3 method for class 'params_mlogit_list'
summary(object, probs = c(0.025, 0.975), ...)

## S3 method for class 'params_surv'
summary(object, probs = c(0.025, 0.975), ...)

## S3 method for class 'params_surv_list'
summary(object, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.params_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="summary.params_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used
to compute quantiles. By default, the 2.5th and 97.5th percentiles are
computed.</p>
</td></tr>
<tr><td><code id="summary.params_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> that always contains the following columns:
</p>

<dl>
<dt>term</dt><dd><p>The regression term.</p>
</dd>
<dt>mean</dt><dd><p>The mean value of the regression term.</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation of the values of the regression term.</p>
</dd>
</dl>

<p>In addition, the <code>probs</code> argument determines the quantiles that are computed.
By default, the columns <code style="white-space: pre;">&#8288;2.5%&#8288;</code> and <code style="white-space: pre;">&#8288;97.5%&#8288;</code> are returned corresponding to the
2.5th and 97.5th percentiles.
</p>
<p>Finally, the following columns may also be present:
</p>

<dl>
<dt>parameter</dt><dd><p>The name of the parameter of interest. This is relevant
for any parametric model in which the underlying probability distribution
has multiple parameters. For instance, both <code><a href="#topic+params_surv">params_surv</a></code> and <code><a href="#topic+params_surv_list">params_surv_list</a></code>
store regression coefficients that are used to model the underlying parameters
of the survival distribution (e.g., shape and scale for a Weibull model). Similarly,
there are two parameters (<code>mean</code> and <code>sd</code>) for <code><a href="#topic+params_lm">params_lm</a></code> objects.</p>
</dd>
<dt>model</dt><dd><p>The name of the statistical model. This is used for a
<code><a href="#topic+params_surv_list">params_surv_list</a></code> object, where each list element represents a separate model.
In a state transition model, each model is a unique health state transition and
in a partitioned survival model, there is a separate model for each curve.</p>
</dd>
<dt>to</dt><dd><p>The health state that is being transitioned to. In <code><a href="#topic+params_mlogit">params_mlogit</a></code>
and <code><a href="#topic+params_mlogit_list">params_mlogit_list</a></code> objects, there are coefficients for each health
state that can be transitioned to.</p>
</dd>
<dt>from</dt><dd><p>The health state that is being transitions from. This is used
for a <code><a href="#topic+params_mlogit_list">params_mlogit_list</a></code> objects where a different multinomial
logistic regression is used for each state that can be transitioned from.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>For examples, see the the underlying parameter object functions:
<code><a href="#topic+params_lm">params_lm()</a></code>, <code><a href="#topic+params_surv">params_surv()</a></code>, <code><a href="#topic+params_surv_list">params_surv_list()</a></code>, <code><a href="#topic+params_mlogit">params_mlogit()</a></code>, and
<code><a href="#topic+params_mlogit_list">params_mlogit_list()</a></code>.
</p>

<hr>
<h2 id='summary.tparams_mean'>Summarize <code>tparams_mean</code> object</h2><span id='topic+summary.tparams_mean'></span><span id='topic+print.tparams_mean'></span>

<h3>Description</h3>

<p>The <code>summary()</code> method summarizes a <code><a href="#topic+tparams_mean">tparams_mean</a></code> object containing
predicted means; summary statistics are computed for each
combination of the ID variables. The <code>print()</code> method
summarizes the object using <code>summary.tparams_mean()</code> and prints it to the
console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tparams_mean'
summary(object, probs = c(0.025, 0.975), ...)

## S3 method for class 'tparams_mean'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tparams_mean_+3A_object">object</code>, <code id="summary.tparams_mean_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+tparams_mean">tparams_mean</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.tparams_mean_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used
to compute quantiles. By default, the 2.5th and 97.5th percentiles are
computed.</p>
</td></tr>
<tr><td><code id="summary.tparams_mean_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with columns for (i) the ID variables,
(ii) the mean of each parameter across parameter samples (<code>mean</code>),
(iii) the standard deviation of the parameter samples (<code>sd</code>), and
(iv) quantiles of the parameter samples corresponding to the <code>probs</code> argument.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+tparams_mean">tparams_mean</a></code> for an example use of the summary and
print methods.
</p>

<hr>
<h2 id='summary.tparams_transprobs'>Summarize <code>tparams_transprobs</code> object</h2><span id='topic+summary.tparams_transprobs'></span>

<h3>Description</h3>

<p>The <code>summary()</code> method summarizes a <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object containing
predicted transition probabilities; summary statistics are computed for each
possible transition by the relevant ID variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tparams_transprobs'
summary(object, probs = NULL, unflatten = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tparams_transprobs_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.tparams_transprobs_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used
to compute quantiles. Computing quantiles can be slow when <code>object</code> is large,
so the default is <code>NULL</code>, meaning that no quantiles are computed.</p>
</td></tr>
<tr><td><code id="summary.tparams_transprobs_+3A_unflatten">unflatten</code></td>
<td>
<p>If <code>FALSE</code>, then each column containing a summary statistic
is a vector and the generated table contains one row
(for each set of ID variables) for each possible transition; if
<code>TRUE</code>, then each column stores a list of <code>matrix</code> objects containing
transition probability matrices formed by &quot;unflattening&quot; the one-dimensional
vectors. See &quot;Value&quot; below for additional details.</p>
</td></tr>
<tr><td><code id="summary.tparams_transprobs_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>unflatten = "FALSE"</code> (the default), then a <code><a href="data.table.html#topic+data.table">data.table</a></code>
is returned with columns for (i) the health state that is being transitioned
from (<code>from</code>), (ii) the health state that is being transitioned to (<code>to</code>)
(iii) the mean of each parameter across parameter samples (<code>mean</code>),
(iv) the standard deviation of the parameter samples (<code>sd</code>), and
(v) quantiles of the parameter samples corresponding to the <code>probs</code> argument.
</p>
<p>If, on the other hand, <code>unflatten = "TRUE"</code>, then the parameters are unflattened
to form transition probability matrices; that is, the <code>mean</code>, <code>sd</code>, and
quantile columns are (lists of) matrices.
</p>
<p>In both cases, the ID variables are also returned as columns.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> for an example use of the summary method.
</p>

<hr>
<h2 id='summary.tpmatrix'>Summarize transition probability matrix</h2><span id='topic+summary.tpmatrix'></span>

<h3>Description</h3>

<p>Summarize a <code><a href="#topic+tpmatrix">tpmatrix</a></code> object storing transition probability matrices.
Summary statistics are computed for each possible transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpmatrix'
summary(object, id = NULL, probs = NULL, unflatten = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tpmatrix_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+tpmatrix">tpmatrix</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.tpmatrix_+3A_id">id</code></td>
<td>
<p>A <code><a href="#topic+tpmatrix_id">tpmatrix_id</a></code> object for which columns contain the ID variables
for each row in <code>object</code>. If not <code>NULL</code>, then transition probability matrices
are summarized by the ID variables in <code>id</code>.</p>
</td></tr>
<tr><td><code id="summary.tpmatrix_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> used
to compute quantiles. Computing quantiles can be slow when <code>object</code> is large,
so the default is <code>NULL</code>, meaning that no quantiles are computed.</p>
</td></tr>
<tr><td><code id="summary.tpmatrix_+3A_unflatten">unflatten</code></td>
<td>
<p>If <code>FALSE</code>, then each column containing a summary statistic
is a vector and the generated table contains one row
(for each set of ID variables) for each possible transition; if
<code>TRUE</code>, then each column stores a list of <code>matrix</code> objects containing
transition probability matrices formed by &quot;unflattening&quot; the one-dimensional
vectors. See &quot;Value&quot; below for additional details.</p>
</td></tr>
<tr><td><code id="summary.tpmatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary. Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>unflatten = "FALSE"</code> (the default), then a <code><a href="data.table.html#topic+data.table">data.table</a></code>
is returned with columns for (i) the health state that is being transitioned
from (<code>from</code>), (ii) the health state that is being transitioned to (<code>to</code>)
(iii) the mean of each parameter across parameter samples (<code>mean</code>),
(iv) the standard deviation of the parameter samples (<code>sd</code>), and
(v) quantiles of the parameter samples corresponding to the <code>probs</code> argument.
</p>
<p>If, on the other hand, <code>unflatten = "TRUE"</code>, then the parameters are unflattened
to form transition probability matrices; that is, the <code>mean</code>, <code>sd</code>, and
quantile columns are (lists of) matrices.
</p>
<p>In both cases, if <code>id</code> is not <code>NULL</code>, then the ID variables are also
returned as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
hesim_dat &lt;-  hesim_data(strategies = data.table(strategy_id = 1:2),
                                patients = data.table(patient_id = 1:3))
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))

# Summarize across all rows in "input_data"
p_12 &lt;- ifelse(input_data$strategy_id == 1, .8, .6)
p &lt;- tpmatrix(
  C, p_12,
  0, 1
)

## Summary where each column is a vector
summary(p)
summary(p, probs = c(.025, .975))

## Summary where each column is a matrix
ps &lt;- summary(p, probs = .5, unflatten = TRUE)
ps
ps$mean

# Summarize by ID variables
tpmat_id &lt;- tpmatrix_id(input_data, n_samples = 2) 
p_12 &lt;- ifelse(tpmat_id$strategy_id == 1, .8, .6)
p &lt;- tpmatrix(
  C, p_12,
  0, 1
)

## Summary where each column is a vector
summary(p, id = tpmat_id)

## Summary where each column is a matrix
ps &lt;- summary(p, id = tpmat_id, unflatten = TRUE)
ps
ps$mean
</code></pre>

<hr>
<h2 id='surv_quantile'>Survival quantiles</h2><span id='topic+surv_quantile'></span>

<h3>Description</h3>

<p>Compute quantiles from survival curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_quantile(x, probs = 0.5, t, surv_cols, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_quantile_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code> or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="surv_quantile_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="surv_quantile_+3A_t">t</code></td>
<td>
<p>A character scalar of the name of the time column.</p>
</td></tr>
<tr><td><code id="surv_quantile_+3A_surv_cols">surv_cols</code></td>
<td>
<p>A character vector of the names of columns containing
survival curves.</p>
</td></tr>
<tr><td><code id="surv_quantile_+3A_by">by</code></td>
<td>
<p>A character vector of the names of columns to group by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> of quantiles of each survival curve in
<code>surv_cols</code> by each group in <code>by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
t &lt;- seq(0, 10, by = .01)
surv1 &lt;- seq(1, .3, length.out = length(t))
surv2 &lt;- seq(1, .2, length.out = length(t))
strategies &lt;- c("Strategy 1", "Strategy 2")
surv &lt;- data.table(strategy = rep(strategies, each = length(t)),
                   t = rep(t, 2), 
                   surv = c(surv1, surv2))
surv_quantile(surv, probs = c(.4, .5), t = "t",
              surv_cols = "surv", by = "strategy")
</code></pre>

<hr>
<h2 id='survival'>Survival object</h2><span id='topic+survival'></span>

<h3>Description</h3>

<p>An object of class <code>survival</code> stores survival probabilities. It is typically
returned by <code>Psm$sim_survival()</code> or <code>PsmCurves$survival()</code>; however, it can also
be constructed &quot;manually&quot; from existing data using the <code>survival()</code>
function as described below. The latter option is useful if survival modeling
has been performed by an <code>R</code> package other than those that integrate with <code>hesim</code> (
currently <code>flexsurv</code>). In this case a simulation model can still be developed
by using <code><a href="#topic+sim_stateprobs.survival">sim_stateprobs.survival()</a></code> to compute simulated state probabilities and
then simulating quality-adjusted life-years and costs in a typical fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival(
  data,
  sample = "sample",
  strategy_id = "strategy_id",
  patient_id = "patient_id",
  grp_id = "grp_id",
  curve = "curve",
  t = "t",
  survival = "survival"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_+3A_data">data</code></td>
<td>
<p>A tabular object that can be coerced to a <code>data.table</code> with
<code><a href="#topic+as.data.table">as.data.table()</a></code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_sample">sample</code></td>
<td>
<p>The name of the column corresponding to <code>sample</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_strategy_id">strategy_id</code></td>
<td>
<p>The name of the column corresponding to <code>strategy_id</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_patient_id">patient_id</code></td>
<td>
<p>The name of the column corresponding to <code>patient_id</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_grp_id">grp_id</code></td>
<td>
<p>The name of the column corresponding to <code>grp_id</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_curve">curve</code></td>
<td>
<p>The name of the column corresponding to <code>curve</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_t">t</code></td>
<td>
<p>The name of the column corresponding to <code>t</code>.</p>
</td></tr>
<tr><td><code id="survival_+3A_survival">survival</code></td>
<td>
<p>The name of the column corresponding to <code>survival</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>survival</code> that inherits from <code>data.table</code> and contains
the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt><dd><p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt><dd><p>The patient ID.</p>
</dd>
<dt>grp_id</dt><dd><p>The subgroup ID.</p>
</dd>
<dt>curve</dt><dd><p>One of the <code>N</code>-1 survival curves in an N-state partitioned
survival model. Each curve corresponds to unique endpoint.</p>
</dd>
<dt>t</dt><dd><p>The time at which a survival probability is computed.</p>
</dd>
<dt>survival</dt><dd><p>The probability of surviving to time <code>t</code>.</p>
</dd>
</dl>

<p>The object also contains a <code>size</code> attribute that contains the elements
<code>n_samples</code>, <code>n_strategies</code>, <code>n_patients</code>, <code>n_states</code>, and <code>n_times</code> denoting
the number of samples, treatment strategies, patients, health states, and times.
</p>


<h3>See Also</h3>

<p><code>survival</code> objects are returned by methods in the <code><a href="#topic+Psm">Psm</a></code> and <code><a href="#topic+PsmCurves">PsmCurves</a></code>
classes. An example in which a <code>survival</code> object is constructed &quot;manually&quot;
(presumably from a preexisting survival model fit using software other than <code>flexsurv</code>)
is provided in the documentation to <code><a href="#topic+sim_stateprobs.survival">sim_stateprobs.survival()</a></code>.
</p>

<hr>
<h2 id='time_intervals'>Time intervals</h2><span id='topic+time_intervals'></span>

<h3>Description</h3>

<p>Create a table of time intervals given a vector or data frame of unique times.
This would typically be passed to <a href="#topic+id_attributes">id_attributes</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_intervals(times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_intervals_+3A_times">times</code></td>
<td>
<p>Either a vector of starting times for each interval or a
<code>data.frame</code> with at least one column named <code>time_start</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>time_intervals</code> that inherits from
<code>data.table</code> in the same format as <code>time_intervals</code> as
described in <a href="#topic+id_attributes">id_attributes</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+id_attributes">id_attributes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time_intervals(c(0, 3, 5))
time_intervals(data.frame(time_start = c(0, 3, 5),
                          time_cat = c("Time &lt;= 3", "3 &lt; Time &lt;= 5", 
                                       "Time &gt; 5")))
</code></pre>

<hr>
<h2 id='tparams'>Transformed parameter object</h2><span id='topic+tparams'></span>

<h3>Description</h3>

<p>Objects prefixed by &quot;tparams_&quot; are lists containing transformed parameters used
to simulate outcomes. The parameters have presumably already been transformed as a
function of input data and consequently do not need to be used alongside
input matrices. In other words, transformed parameters are parameters that have
already been predicted as a function of covariates.
</p>


<h3>See Also</h3>

<p><a href="#topic+params">params</a>
</p>

<hr>
<h2 id='tparams_mean'>Predicted means</h2><span id='topic+tparams_mean'></span>

<h3>Description</h3>

<p>Create a list containing means predicted from a statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tparams_mean(value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tparams_mean_+3A_value">value</code></td>
<td>
<p>Matrix of samples from the distribution of the
mean. Columns denote random samples and rows denote means for different
observations.</p>
</td></tr>
<tr><td><code id="tparams_mean_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <a href="#topic+id_attributes">id_attributes</a>. Each row in
<code>value</code> must be a prediction for a <code>strategy_id</code>,
<code>patient_id</code>, <code>state_id</code>, and optionally <code>time_id</code> combination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tparams_mean</code>, which is a list containing <code>value</code>,
<code>n_samples</code>, and the ID attributes passed to <a href="#topic+id_attributes">id_attributes</a>.
</p>


<h3>Note</h3>

<p>The <code>tparams_mean()</code> constructor would not normally be used by users; instead,
a <code>tparams_mean</code> object is typically created automatically as part of the
<code><a href="#topic+StateVals">StateVals</a></code> class with <code><a href="#topic+create_StateVals">create_StateVals()</a></code>.
</p>


<h3>See Also</h3>

<p>A <code>tparams_mean</code> object is a type of <a href="#topic+tparams">transformed parameter</a>
object and is a supported class type of the <code>params</code> field of the <code><a href="#topic+StateVals">StateVals</a></code>
class. See the documentation for <code><a href="#topic+create_StateVals">create_StateVals()</a></code> and <code><a href="#topic+stateval_tbl">stateval_tbl()</a></code>
for examples of how to create<code>StateVals</code> objects. Predicted means can be
summarized across parameter samples using <code><a href="#topic+summary.tparams_mean">summary.tparams_mean()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup model
hesim_dat &lt;- hesim_data(
  strategies = data.frame(strategy_id = c(1, 2)),
  patients = data.frame(patient_id = c(1, 2)),
  states = data.frame(
    state_id = c(1, 2, 3),
    state_name = c("state1", "state2", "state3")
  )
)

# Cost model
cost_tbl &lt;- stateval_tbl(
  data.frame(strategy_id = hesim_dat$strategies$strategy_id,
             mean = c(5000, 3000),
             se = c(200, 100)
            ),
  dist = "gamma"
)
costmod &lt;- create_StateVals(cost_tbl, n = 2, hesim_data = hesim_dat)

# The 'params' field of the `StateVals` class is a tparams_mean object
class(costmod$params)
costmod$params
summary(costmod$params)
</code></pre>

<hr>
<h2 id='tparams_transprobs'>Transition probabilities</h2><span id='topic+tparams_transprobs'></span><span id='topic+print.tparams_transprobs'></span><span id='topic+tparams_transprobs.array'></span><span id='topic+tparams_transprobs.data.table'></span><span id='topic+tparams_transprobs.data.frame'></span><span id='topic+tparams_transprobs.tpmatrix'></span>

<h3>Description</h3>

<p>Create a list containing predicted transition probabilities at discrete times.
Since the transition probabilities have presumably already been predicted
based on covariate values, no input data is required for
simulation. The class can be instantiated from either an <code>array</code>,
a <code>data.table</code>, a <code>data.frame</code>, or a <code><a href="#topic+tpmatrix">tpmatrix</a></code>. This is the object in
<code>hesim</code> used to specify the transition probabilities required to simulate
Markov chains with the <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tparams_transprobs(object, ...)

## S3 method for class 'array'
tparams_transprobs(
  object,
  tpmatrix_id = NULL,
  times = NULL,
  grp_id = NULL,
  patient_wt = NULL,
  ...
)

## S3 method for class 'data.table'
tparams_transprobs(object, ...)

## S3 method for class 'data.frame'
tparams_transprobs(object, ...)

## S3 method for class 'tpmatrix'
tparams_transprobs(object, tpmatrix_id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tparams_transprobs_+3A_object">object</code></td>
<td>
<p>An object of the appropriate class.</p>
</td></tr>
<tr><td><code id="tparams_transprobs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Currently unused.</p>
</td></tr>
<tr><td><code id="tparams_transprobs_+3A_tpmatrix_id">tpmatrix_id</code></td>
<td>
<p>An object of class <code><a href="#topic+tpmatrix_id">tpmatrix_id</a></code> (or an equivalent
<code>data.table</code> with the same ID columns as returned by <code>tpmatrix_id()</code>).</p>
</td></tr>
<tr><td><code id="tparams_transprobs_+3A_times">times</code></td>
<td>
<p>An optional numeric vector of distinct times to pass to
<a href="#topic+time_intervals">time_intervals</a> representing time intervals indexed by the 4th dimension of
the array. May either be the start or the end of intervals.
This argument is not required if there is only one time interval.</p>
</td></tr>
<tr><td><code id="tparams_transprobs_+3A_grp_id">grp_id</code></td>
<td>
<p>An optional numeric vector of integers denoting the subgroups. Must
be the same length as the 3rd dimension of the array.</p>
</td></tr>
<tr><td><code id="tparams_transprobs_+3A_patient_wt">patient_wt</code></td>
<td>
<p>An optional numeric vector denoting the weight to apply to each
patient within a subgroup. Must be the same length as the 3rd dimension of the array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of <code>object</code> depends on its class:
</p>

<dl>
<dt>array</dt><dd>
<p>Either a 3D or a 6D array is possible.
</p>

<ul>
<li><p> If a 3D array, then each slice is a
square transition probability matrix. In this case
<code>tpmatrix_id</code> is required and each matrix slice corresponds to the same
numbered row in <code>tpmatrix_id</code>. The number of matrix slices must equal the number
of rows in <code>tpmatrix_id</code>.
</p>
</li>
<li><p> If a 6D array, then the dimensions of the array should be indexed as follows:
1st (<code>sample</code>), 2nd (<code>strategy_id</code>), 3rd (<code>patient_id</code>),
4th (<code>time_id</code>), 5th (rows of transition matrix), and
6th (columns of transition matrix). In other words, an index of
<code style="white-space: pre;">&#8288;[s, k, i, t]&#8288;</code> represents the transition matrix for the <code>s</code>th
sample, <code>k</code>th treatment strategy, <code>i</code>th patient, and <code>t</code>th
time interval.
</p>
</li></ul>

</dd>
<dt>data.table</dt><dd><p>Must contain the following:
</p>

<ul>
<li><p> ID columns for the parameter sample (<code>sample</code>),
treatment strategy (<code>strategy_id</code>), and patient (<code>patient_id</code>).
If the number of time intervals is greater than 1 it must also contain the
column <code>time_start</code> denoting the starting time of a time interval. A column
<code>patient_wt</code> may also be used to denote the weight to apply to each
patient.
</p>
</li>
<li><p> Columns for each element of the transition probability matrix.
They should be prefixed with &quot;prob_&quot; and ordered rowwise.
For example, the following columns would be used for a 2x2 transition
probability matrix:
<code>prob_1</code> (1st row, 1st column),
<code>prob_2</code> (1st row, 2nd column),
<code>prob_3</code> (2nd row, 1st column), and
<code>prob_4</code> (2nd row, 2nd column).
</p>
</li></ul>

</dd>
<dt>data.frame</dt><dd><p>Same as <code>data.table</code>.</p>
</dd>
<dt>tpmatrix</dt><dd><p>An object of class <code><a href="#topic+tpmatrix">tpmatrix</a></code>.</p>
</dd>
</dl>

<p>A <code>tparams_transprobs</code> object is also instantiated when creating a
cohort discrete time state transition model using <code><a href="#topic+define_model">define_model()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>tparams_transprobs</code>,
which is a list containing <code>value</code> and relevant ID attributes. The element
<code>value</code> is an array of predicted transition probability matrices from the
probability distribution of the underlying statistical model. Each matrix in
<code>value</code> is a prediction for a <code>sample</code>, <code>strategy_id</code>, <code>patient_id</code>, and
optionally <code>time_id</code> combination.
</p>


<h3>See Also</h3>

<p>A <code>tparams_transprobs</code> object is used to store the &quot;parameters&quot; of
the transition component of a cohort discrete time state transition
model (cDTSTM). You can create such an object with <code>CohortDtstmTran$new()</code>.
</p>
<p><code><a href="#topic+tpmatrix">tpmatrix()</a></code> and <code><a href="#topic+tpmatrix_id">tpmatrix_id()</a></code> provide a convenient way to construct a
<code>tparams_transprobs</code> object in a flexible way. <code><a href="#topic+define_model">define_model()</a></code> is, in turn,
a convenient way to construct a <code><a href="#topic+tpmatrix">tpmatrix</a></code> object using mathematical
expressions; in this case, an entire cDTSTM can be instantiated from a model
definition using <code><a href="#topic+create_CohortDtstm.model_def">create_CohortDtstm.model_def()</a></code>. Detailed examples
are provided in <code>vignette("markov-cohort")</code> and
<code>vignette("markov-inhomogeneous-cohort")</code>
</p>
<p>The output of a <code>tparams_transprobs</code> object is rather verbose. It can be
helpful to check the output by converting it to a <code>data.table</code> (containing
both the ID variables and flattened transition probability matrices)
with <code><a href="#topic+as.data.table.tparams_transprobs">as.data.table.tparams_transprobs()</a></code>. Transition probabilities can
also be summarized (across parameter samples) using
<code><a href="#topic+summary.tparams_transprobs">summary.tparams_transprobs()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hesim_dat &lt;- hesim_data(strategies = data.frame(strategy_id = 1:2),
                        patients = data.frame(patient_id = 1:3))
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))    

# tpmatrix objects provide a convenient way to construct
# tparams_transprobs() objects
tpmat_id &lt;- tpmatrix_id(input_data, n_samples = 2)      
p_12 &lt;- runif(nrow(tpmat_id), .6, .7) + 
  .05 * (tpmat_id$strategy_id == 2)
tpmat &lt;- tpmatrix(
  C, p_12,
  0, 1
)
tprobs &lt;- tparams_transprobs(tpmat, tpmat_id)
names(tprobs) # Names of list elements

# Convert to data.table in wide format
as.data.table(tprobs)

# Convert to data.table in long format
as.data.table(tprobs, long = TRUE)

# Summary where each column is a vector
summary(tprobs)
summary(tprobs, probs = c(.025, .975))

# Summary where each column is a matrix
ps &lt;- summary(tprobs, id = tpmat_id, unflatten = TRUE)
ps
ps$mean
</code></pre>

<hr>
<h2 id='tpmatrix'>Transition probability matrix</h2><span id='topic+tpmatrix'></span>

<h3>Description</h3>

<p><code>tpmatrix()</code> both defines and evaluates a transition probability matrix in which
elements are expressions. It can be used within <code><a href="#topic+define_tparams">define_tparams()</a></code> to
create a transition probability matrix or directly to create a <code><a href="#topic+tparams_transprobs">tparams_transprobs()</a></code>
object. These are, in turn, ultimately used to create a <a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a> object
for simulating health state transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpmatrix(..., complement = NULL, states = NULL, prefix = "", sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpmatrix_+3A_...">...</code></td>
<td>
<p>Named values of expressions defining elements of the matrix. Each
element of <code>...</code> should either be a vector or a 2-dimensional tabular object
such as a data frame. See &quot;Details&quot; and the examples below.</p>
</td></tr>
<tr><td><code id="tpmatrix_+3A_complement">complement</code></td>
<td>
<p>Either a character vector or a numeric vector denoting the
transitions (i.e., the columns of the tabular object formed from <code>...</code>) that
are complementary (see &quot;Details&quot; below). If a character vector, each element
should be the name of a column in the tabular object; if a numeric vector,
each element should be the index of a column in the tabular object.</p>
</td></tr>
<tr><td><code id="tpmatrix_+3A_states">states</code>, <code id="tpmatrix_+3A_prefix">prefix</code>, <code id="tpmatrix_+3A_sep">sep</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+tpmatrix_names">tpmatrix_names()</a></code> for naming
the columns. If <code>states = NULL</code> (the default), then the states are named
<code>s1</code>, ..., <code>sh</code> where <code>h</code> is the number of health states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>tpmatrix</code> is a 2-dimensional tabular object that stores flattened
square transition probability matrices in each row. Each transition probability
matrix is filled rowwise. The complementary probability (equal to <code class="reqn">1</code>
minus the sum of the probabilities of all other elements in a row of a
transition probability matrix) can be conveniently referred to as <code>C</code> or
specified with the <code>complement</code> argument. There can only be one complement
for each row in a transition probability matrix.
</p>


<h3>Value</h3>

<p>Returns a <code>tpmatrix</code> object that inherits from <code>data.table</code>
where each column is an element of the transition probability matrix with
elements ordered rowwise.
</p>


<h3>See Also</h3>

<p>A <code>tpmatrix</code> is useful because it provides a convenient
way to construct a <code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> object, which is the object in
<code>hesim</code> used to specify the transition probabilities required to simulate
Markov chains with the <code><a href="#topic+CohortDtstmTrans">CohortDtstmTrans</a></code> class. See the
<code><a href="#topic+tparams_transprobs">tparams_transprobs</a></code> documentation for more details.
</p>
<p>The <code><a href="#topic+summary.tpmatrix">summary.tpmatrix()</a></code> method can be used to summarize a <code>tpmatrix</code>
across parameter samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_12 &lt;- c(.7, .6)
tpmatrix(
  C, p_12,
  0, 1
)

tpmatrix(
  C, p_12,
  C, 1
)

# Pass matrix
pmat &lt;- matrix(c(.5, .5, .3, .7), byrow = TRUE, ncol = 4)
tpmatrix(pmat)

# Pass vectors and data frames
p1 &lt;- data.frame(
  p_12 = c(.7, .6),
  p_13 = c(.1, .2)
)

p2 &lt;- data.frame(
  p_21 = 0,
  p_22 = c(.4, .45),
  p_23 = c(.6, .55)
)

p3 &lt;- data.frame(
  p_31 = c(0, 0),
  p_32 = c(0, 0),
  p_33 = c(1, 1)
)

tpmatrix(
  C, p1,
  p2,
  p3
)

# Use the 'complement' argument
pmat &lt;- data.frame(s1_s1 = 0, s1_s2 = .5, s2_s1 = .3, s2_s2 = 0)
tpmatrix(pmat, complement = c("s1_s1", "s2_s2"))
tpmatrix(pmat, complement = c(1, 4)) # Can also pass integers

# Can control column names
tpmatrix(pmat, complement = c(1, 4),
         states = c("state1", "state2"), sep = ".")

</code></pre>

<hr>
<h2 id='tpmatrix_id'>Transition probability matrix IDs</h2><span id='topic+tpmatrix_id'></span>

<h3>Description</h3>

<p>Creates ID variables for each row returned by <code>tpmatrix()</code>. This function is
most conveniently used along with <code>tpmatrix()</code> to construct a
<code>tparams_transprobs()</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpmatrix_id(object, n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpmatrix_id_+3A_object">object</code></td>
<td>
<p>An object of class <code>expanded_hesim_data</code> returned by
<code>expand.hesim_data()</code>. This dataset must be expanded by treatment
strategies, patients, and optionally time intervals.</p>
</td></tr>
<tr><td><code id="tpmatrix_id_+3A_n_samples">n_samples</code></td>
<td>
<p>The number of parameters samples used for the probabilistic
sensitivity analysis (PSA).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>tpmatrix_id</code> object that inherits from <code>data.table</code> with
the same columns in <code>object</code> repeated <code>n_samples</code> times. That is, to facilitate
creation of a <code>tparams_transprobs()</code> object,  there is one row for each
parameter sample, treatment strategy, patient, and optionally time interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpmatrix">tpmatrix()</a></code>, <code><a href="#topic+tparams_transprobs">tparams_transprobs()</a></code>, <code><a href="#topic+expand.hesim_data">expand.hesim_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strategies &lt;- data.frame(strategy_id = c(1, 2))
patients &lt;- data.frame(patient_id = seq(1, 3), age = c(65, 50, 75),
                        gender = c("Female", "Female", "Male"))
hesim_dat &lt;- hesim_data(strategies = strategies,
                        patients = patients)
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))    
tpmatrix_id(input_data, n_samples = 2)                   
</code></pre>

<hr>
<h2 id='tpmatrix_names'>Names for elements of a transition probability matrix</h2><span id='topic+tpmatrix_names'></span>

<h3>Description</h3>

<p>Create names for all elements of a transition probability matrix given
names for the health states. This is useful for flattening a transition
probability matrix (rowwise) into a vector and naming the resulting vector.
The name of an element of the flattened vector representing a transition from
the ith state to the jth state is of the form
<code>paste0(prefix, states[i], sep, states[j])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpmatrix_names(states, prefix = "p_", sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpmatrix_names_+3A_states">states</code></td>
<td>
<p>A character vector of the names of health states in the
transition matrix.</p>
</td></tr>
<tr><td><code id="tpmatrix_names_+3A_prefix">prefix</code></td>
<td>
<p>A prefix that precedes the described transitions between states
used to name a transition. For example, if <code>prefix = "p_"</code> (and <code>sep = "_"</code>),
then a transition between state <code>i</code> and state <code>j</code> will be of the form
<code>"p_states[i]_states[j]"</code>; similarly, if <code>prefix = ""</code>, then the same
transition will be named <code>"states[i]_states[j]"</code>.</p>
</td></tr>
<tr><td><code id="tpmatrix_names_+3A_sep">sep</code></td>
<td>
<p>A character string to separate the terms representing
state <code>i</code> and state <code>j</code>. For instance, if <code>sep = "."</code>, the resulting name
will be of the form <code>"states[i].states[j]"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing a name for each element of the transition
probability matrix encompassing all possible transitions.
</p>


<h3>See Also</h3>

<p>See <code>tpmatrix()</code>, which uses <code>tpmatrix_names()</code> to name the columns
of the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tpmatrix_names(LETTERS[1:4])
tpmatrix_names(LETTERS[1:4], prefix = "")
tpmatrix_names(LETTERS[1:4], prefix = "", sep = ".")

</code></pre>

<hr>
<h2 id='uv_rng'>Generate variates for univariate distributions</h2><span id='topic+uv_rng'></span>

<h3>Description</h3>

<p>Generate variates for univariate distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uv_rng(n, params, rng_fun, mom_fun = NULL, names = NULL)
</code></pre>

<hr>
<h2 id='weibullNMA'>Parameterization of the Weibull distribution for network meta-analysis</h2><span id='topic+weibullNMA'></span><span id='topic+dweibullNMA'></span><span id='topic+pweibullNMA'></span><span id='topic+qweibullNMA'></span><span id='topic+rweibullNMA'></span><span id='topic+hweibullNMA'></span><span id='topic+HweibullNMA'></span><span id='topic+rmst_weibullNMA'></span><span id='topic+mean_weibullNMA'></span>

<h3>Description</h3>

<p>Density, distribution function, hazards, quantile function and random generation
for the Weibull distribution when parameterized for network meta-analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dweibullNMA(x, a0, a1 = FALSE, log = FALSE)

pweibullNMA(q, a0, a1, lower.tail = TRUE, log.p = FALSE)

qweibullNMA(p, a0, a1, lower.tail = TRUE, log.p = FALSE)

rweibullNMA(n, a0, a1)

hweibullNMA(n, a0, a1, log = FALSE)

HweibullNMA(n, a0, a1, log = FALSE)

rmst_weibullNMA(t, a0, a1, start = 0)

mean_weibullNMA(a0, a1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weibullNMA_+3A_x">x</code>, <code id="weibullNMA_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_a0">a0</code></td>
<td>
<p>Intercept of reparameterization of the Weibull distribution.</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_a1">a1</code></td>
<td>
<p>Slope of the reparameterization of the Weibull distribution.</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_log">log</code>, <code id="weibullNMA_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X
\le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_n">n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_t">t</code></td>
<td>
<p>Vector of times for which restricted mean survival time is evaluated.</p>
</td></tr>
<tr><td><code id="weibullNMA_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times. The returned restricted
mean survival will be conditional on survival up to this time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dweibullNMA</code> gives the density, <code>pweibullNMA</code> gives the
distribution function, <code>qweibullNMA</code> gives the quantile function,
<code>rweibullNMA</code> generates random deviates, <code>HweibullNMA</code> returns the
cumulative hazard and <code>hweibullNMA</code> the hazard.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
