<!DOCTYPE html><html><head><title>Help for package inverseRegex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inverseRegex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inverseRegex'><p>Reverse Engineers a Regular Expression Pattern to Represent the Input Object.</p></a></li>
<li><a href='#occurrencesLessThan'><p>Identifies Infrequent inverseRegex Patterns in an R Object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Reverse Engineers Regular Expression Patterns for R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Reverse engineer a regular expression pattern for the characters
    contained in an R object. Individual characters can be categorised into
    digits, letters, punctuation or spaces and encoded into run-lengths. This
    can be used to summarise the structure of a dataset or identify non-standard
    entries. Many non-character inputs such as numeric vectors and data frames
    are supported.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tibble, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rntq472/inverseRegex/issues">https://github.com/rntq472/inverseRegex/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-23 15:58:30 UTC; jasper</td>
</tr>
<tr>
<td>Author:</td>
<td>Jasper Watson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jasper Watson &lt;jasper.g.watson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-23 16:25:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='inverseRegex'>Reverse Engineers a Regular Expression Pattern to Represent the Input Object.</h2><span id='topic+inverseRegex'></span>

<h3>Description</h3>

<p>Deconstructs the input into collections of letters, digits, punctuation, and
spaces that represent a regex pattern consistent with that input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseRegex(
  x,
  numbersToKeep = c(2, 3, 4, 5, 10),
  combineCases = FALSE,
  combineAlphanumeric = FALSE,
  combinePunctuation = FALSE,
  combineSpace = FALSE,
  sep = "",
  escapePunctuation = FALSE,
  enclose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseRegex_+3A_x">x</code></td>
<td>
<p>Object to derive a regex pattern for.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_numberstokeep">numbersToKeep</code></td>
<td>
<p>Set of numbers giving the length for which elements
repeated that many times should be counted explicitly
(e.g. &quot;[[:digit:]]{5}&quot;). Repeat sequences not included in numbersToKeep
will be coded with a &quot;+&quot; (e.g. &quot;[[:digit:]]+&quot;). Defaults to c(2, 3, 4, 5, 10).
Set to NULL to have all runs coded as &quot;+&quot; and set to <code>2:maxCharacters</code>
to have the length specified for all repeated values. If one is included then
all unique patterns with be counted as &quot;{1}&quot;; if it is not then the &quot;{1}&quot;
is left off.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_combinecases">combineCases</code></td>
<td>
<p>Logical indicating whether to treat upper and lower case
letters as a single entity. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_combinealphanumeric">combineAlphanumeric</code></td>
<td>
<p>Logical indicating whether to treat alphabetic
characters and digits as a single entity. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_combinepunctuation">combinePunctuation</code></td>
<td>
<p>Logical indicating whether to treat all punctuation
characters as a single entity. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_combinespace">combineSpace</code></td>
<td>
<p>Logical indicating whether to treat all space characters
as a single entity. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_sep">sep</code></td>
<td>
<p>Value used to separate the regex patterns. Defaults to an empty
string.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_escapepunctuation">escapePunctuation</code></td>
<td>
<p>Logical indicating whether to escape any punctuation
characters. Defaults to FALSE. Set to TRUE if you want to use the returned
value as an argument to grep.</p>
</td></tr>
<tr><td><code id="inverseRegex_+3A_enclose">enclose</code></td>
<td>
<p>Logical indicating whether to surround each returned value
with <code>'^'</code> and <code>'$'</code>. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fundamental use of inverseRegex applies only to strings. Inputs of a class
other than character are treated as follows: 
</p>

<ul>
<li><p> Integer: Converted using <code>as.character()</code>.
</p>
</li>
<li><p> Factor: Converted using <code>as.character()</code>.
</p>
</li>
<li><p> Logical: Left as is. Converting to character would not provide any
simplification.
</p>
</li>
<li><p> Numeric: Converted to character by applying <code>format(..., nsmall = 1)</code>
element by element. NA values will be returned as NA_character_, whilst
<code>NaN</code>, <code>Inf</code>, and <code>-Inf</code> will be returned as literal
strings: <code>"NaN"</code>, <code>"Inf"</code>, and <code>"-Inf"</code>.
</p>
</li>
<li><p> Date: Converted using <code>as.character()</code>.
</p>
</li>
<li><p> POSIXct: Converted using <code>as.character()</code>.
</p>
</li>
<li><p> Data frame: Each column is assessed individually and the results
combined together so that the output is a data frame of regex patterns
with the same dimensions as the input. The columns of class other than
character will each be converted as described previously, with one
exception: Unlike above where numerics are passed to
<code>format(..., nsmall = 1)</code> element by element, here the entire
column is passed to <code>trimws(format(...))</code>. This will lead to a
common number of digits to the right of the decimal point and a variable
number of digits with no padding on the left side.
</p>
</li>
<li><p> Matrix: Creates a matrix of regex patterns with the same dimensions
as the input. If the matrix has a mode of numeric then it will first
be passed to <code>trimws(format(...))</code>.
</p>
</li>
<li><p> Tibble: Same as a data frame except the returned object is a tibble.
Requires the tibble package to be installed.
</p>
</li>
<li><p> Anything else: Not supported; an error will be thrown.
</p>
</li></ul>

<p>If these conversion methods are not appropriate then you can do the conversion
yourself so that the input is dispatched directly to inverseRegex.character.
</p>
<p>The regex patterns are identified using the constructs &quot;[:digit:]&quot;, &quot;[:upper:]&quot;,
&quot;[:lower:]&quot;, &quot;[:alpha:]&quot;, &quot;[:alnum:]&quot;, &quot;[:punct:]&quot;, and &quot;[:space:]&quot; as described
in <code>?regex</code>. This will allow for non-ASCII characters to be identified, to
the extent supported by <code>grep</code>. Any characters not identified by these
search patterns will be left as is. Note that for characters from unicameral
alphabets the combineCases argument will need to be set to TRUE otherwise they
will not be detected by &quot;lower&quot; and &quot;upper&quot;.
</p>
<p>NA values in the input will remain as NA values in the output.
</p>


<h3>Value</h3>

<p>A set of regex patterns that match the input data. These patterns will
either be character vectors or the same class as the input object if it was
a matrix, data frame, or tibble.
</p>


<h3>Author(s)</h3>

<p>Jasper Watson
</p>


<h3>See Also</h3>

<p>occurrencesLessThan, regex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inverseRegex('Hello World!')

table(inverseRegex(c(rep('HELLO', 10), 'HELL0')))

unique(inverseRegex(iris, numbersToKeep = 1:10))

inverseRegex(c(1, NA, 3.45, NaN, Inf, -Inf))

</code></pre>

<hr>
<h2 id='occurrencesLessThan'>Identifies Infrequent inverseRegex Patterns in an R Object.</h2><span id='topic+occurrencesLessThan'></span>

<h3>Description</h3>

<p>Calls <code>inverseRegex</code> on the input object and identifies values that
occur infrequently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencesLessThan(x, fraction = 0.05, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occurrencesLessThan_+3A_x">x</code></td>
<td>
<p>Object to analyse for infrequent regex patterns.</p>
</td></tr>
<tr><td><code id="occurrencesLessThan_+3A_fraction">fraction</code></td>
<td>
<p>Fraction of the R object size; regex patterns that occur less
(or equal) often than this will be identified. For a vector this fraction will
be multiplied by the length of the object; for a matrix it will be multiplied by
the total number of entries; and for a data frame or tibble it will be multiplied
by the number of rows. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="occurrencesLessThan_+3A_n">n</code></td>
<td>
<p>Alternative to the <code>fraction</code> argument which allows a literal
number of occurrences to be searched for. Defaults to NULL, in which case
<code>fraction</code> will be used.</p>
</td></tr>
<tr><td><code id="occurrencesLessThan_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>inverseRegex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper around calling <code>table()</code> on
the return value of <code>inverseRegex</code>. It can be used to identify the indices
of values that consist of a regex pattern different to others in the R object.
</p>


<h3>Value</h3>

<p>A collection of logical values with <code>TRUE</code> indicating entries with
an infrequent regex pattern. The class of the return value will depend on the
input object; matrices, data frames, and tibbles will be returned in kind; all
others are returned as vectors.
</p>


<h3>Note</h3>

<p>NA values are not considered and will need to be identified separately.
</p>


<h3>Author(s)</h3>

<p>Jasper Watson
</p>


<h3>See Also</h3>

<p>inverseRegex, regex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>occurrencesLessThan(c(LETTERS, 1))

x &lt;- iris
x$Species &lt;- as.character(x$Species)
x[27, 'Species'] &lt;- 'set0sa'
apply(occurrencesLessThan(x), 2, which)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
