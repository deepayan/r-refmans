<!DOCTYPE html><html lang="en"><head><title>Help for package StanHeaders</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StanHeaders}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CxxFlags'><p>Compilation flags for StanHeaders</p></a></li>
<li><a href='#stanFunction'><p>Compile and Call a Stan Math Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>C++ Header Files for Stan</td>
</tr>
<tr>
<td>Version:</td>
<td>2.32.10</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/">https://mc-stan.org/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>The C++ header files of the Stan project are provided by this package, but it contains little R code or documentation. The main reference is the vignette. There is a shared object containing part of the 'CVODES' library, but its functionality is not accessible from R. 'StanHeaders' is primarily useful for developers who want to utilize the 'LinkingTo' directive of their package's DESCRIPTION file to build on the Stan library without incurring unnecessary dependencies. The Stan project develops a probabilistic programming language that implements full or approximate Bayesian statistical inference via Markov Chain Monte Carlo or 'variational' methods and implements (optionally penalized) maximum likelihood estimation via optimization. The Stan library includes an advanced automatic differentiation scheme, 'templated' statistical and linear algebra functions that can handle the automatically 'differentiable' scalar types (and doubles, 'ints', etc.), and a parser for the Stan language. The 'rstan' package provides user-facing R functions to parse, compile, test, estimate, and analyze Stan models.</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppParallel (&ge; 5.1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rcpp, BH (&ge; 1.75.0-0), knitr (&ge; 1.36), rmarkdown, Matrix,
methods, rstan, withr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen (&ge; 0.3.4.0.0), RcppParallel (&ge; 5.1.4)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-15 06:14:33 UTC; ben</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Goodrich [cre, aut],
  Joshua Pritikin [ctb],
  Andrew Gelman [aut],
  Bob Carpenter [aut],
  Matt Hoffman [aut],
  Daniel Lee [aut],
  Michael Betancourt [aut],
  Marcus Brubaker [aut],
  Jiqiang Guo [aut],
  Peter Li [aut],
  Allen Riddell [aut],
  Marco Inacio [aut],
  Mitzi Morris [aut],
  Jeffrey Arnold [aut],
  Rob Goedman [aut],
  Brian Lau [aut],
  Rob Trangucci [aut],
  Jonah Gabry [aut],
  Alp Kucukelbir [aut],
  Robert Grant [aut],
  Dustin Tran [aut],
  Michael Malecki [aut],
  Yuanjun Gao [aut],
  Hamada S. Badr <a href="https://orcid.org/0000-0002-9808-2344"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Trustees of Columbia University [cph],
  Lawrence Livermore National Security [cph] (CVODES),
  The Regents of the University of California [cph] (CVODES),
  Southern Methodist University [cph] (CVODES)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Goodrich &lt;benjamin.goodrich@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-15 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CxxFlags'>Compilation flags for StanHeaders
</h2><span id='topic+CxxFlags'></span><span id='topic+LdFlags'></span>

<h3>Description</h3>

<p>Output the compiler or linker flags required to build with the <span class="pkg">StanHeaders</span>
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CxxFlags(as_character = FALSE)
  LdFlags(as_character = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CxxFlags_+3A_as_character">as_character</code></td>
<td>

<p>A logical scalar that defaults to <code><a href="base.html#topic+FALSE">FALSE</a></code> that indicates whether
to return the compiler or linker flags as a <code><a href="base.html#topic+character">character</a></code> vector of
length one. Otherwise, the compiler or linker flags are merely output to the
screen, which is appropriate when called from a Makevars or Makevars.win file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are currently not exported and are typically called from a Makevars 
or a Makevars.win file of another package.
</p>


<h3>Value</h3>

<p>If <code>as_character</code> is <code><a href="base.html#topic+TRUE">TRUE</a></code>, then these functions return
a character vector of length one. Otherwise, (which is the default) these
functions return <code><a href="base.html#topic+NULL">NULL</a></code> invisibly after outputing the compiler
or linker flags to the screen.
</p>

<hr>
<h2 id='stanFunction'>Compile and Call a Stan Math Function
</h2><span id='topic+stanFunction'></span>

<h3>Description</h3>

<p>Call a function defined in the Stan Math Library from R using this wrapper around 
<code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stanFunction(function_name, ..., env = parent.frame(), rebuild = FALSE,
               cacheDir = getOption("rcpp.cache.dir", tempdir()), 
               showOutput = verbose, verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanFunction_+3A_function_name">function_name</code></td>
<td>

<p>A <code><a href="base.html#topic+character">character</a></code> vector of length one that is the unscoped basename of a 
C++ function under the <code>prim/</code> directory of the Stan Math Library that you 
would like to evaluate. Functions (such as <code>integrate_1d</code>) of other functions
are not permitted and neither are functions (such as <code>reject</code>) of characters.
</p>
</td></tr>
<tr><td><code id="stanFunction_+3A_...">...</code></td>
<td>

<p>Further arguments that are passed to <code>function_name</code> in <code>tag = value</code>
form, which are passed to <code>function_name</code> by  <em>position</em>. See the Details 
and Examples sections.
</p>
</td></tr>
<tr><td><code id="stanFunction_+3A_env">env</code>, <code id="stanFunction_+3A_rebuild">rebuild</code>, <code id="stanFunction_+3A_cachedir">cacheDir</code>, <code id="stanFunction_+3A_showoutput">showOutput</code>, <code id="stanFunction_+3A_verbose">verbose</code></td>
<td>

<p>The same as in <code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stanFunction</code> function essentially compiles and
evaluates a C++ function of the form
</p>
<pre>auto function_name(...) { return stan::math::function_name(...); }</pre>
<p>It is essential to pass all arguments to <code>function_name</code> through the ...
in order for the C++ wrapper to know what the argument types are. The mapping
between R types and Stan types is
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>R type</b>  </td><td style="text-align: right;"> <b>Stan type</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>double</code>  </td><td style="text-align: right;"> <code>real</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>integer</code> </td><td style="text-align: right;"> <code>int</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>complex</code> </td><td style="text-align: right;"> <code>complex</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>vector</code>  </td><td style="text-align: right;"> <code>vector</code> or <code>complex_vector</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>matrix(*, nrow = 1)</code> </td><td style="text-align: right;"> <code>row_vector</code> or <code>complex_row_vector</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>matrix</code>  </td><td style="text-align: right;"> <code>matrix</code> or <code>complex_matrix</code>
  </td>
</tr>

</table>

<p>and, in addition, lists of the aforementioned R types map
to arrays of Stan types and thus must not be ragged if they are nested. The
Stan version of the function is called with arguments specified by position,
i.e. in the order that they appear in the .... However, the R wrapper
function has arguments whose names are the same as the names passed through
the ....
</p>


<h3>Value</h3>

<p>The result of <code>function_name</code> evaluated at the arguments
that are passed through the ..., which could be of various
R types. It also has the side effect of defining a function
named <code>function_name</code> in the environment given by the
<code>env</code> argument that can subsequently be called with
inputs of the same type (but not necessarily the same value)
that were passed through the ....
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  files &lt;- dir(system.file("include", "stan", "math", "prim",
                           package = "StanHeaders"), 
               pattern = "hpp$", recursive = TRUE)
  functions &lt;- sub("\\.hpp$", "", 
                   sort(unique(basename(files[dirname(files) != "."]))))
  length(functions) # you could call most of these Stan functions
  
  ## Not run: 
    log(sum(exp(exp(1)), exp(pi))) # true value
    
    stanFunction("log_sum_exp", x = exp(1), y = pi)
    args(log_sum_exp) # now exists in .GlobalEnv
    log_sum_exp(x = pi, y = exp(1))
    
    # but log_sum_exp() was not defined for a vector or matrix
    x &lt;- c(exp(1), pi)
    try(log_sum_exp(x))
    stanFunction("log_sum_exp", x = x) # now it is
    
    # log_sum_exp() is now also defined for a matrix
    log_sum_exp(as.matrix(x))
    log_sum_exp(t(as.matrix(x)))
    log_sum_exp(rbind(x, x))
    
    # but log_sum_exp() was not defined for a list
    try(log_sum_exp(as.list(x)))
    stanFunction("log_sum_exp", x = as.list(x)) # now it is

    # in rare cases, passing a nested list is needed
    stanFunction("dims", x = list(list(1:3)))
    
    # functions of complex arguments work
    stanFunction("eigenvalues", # different ordering than base:eigen()
                 x = matrix(complex(real = 1:9, imaginary = pi),
                            nrow = 3, ncol = 3))
    
    # nullary functions work but are not that interesting
    stanFunction("negative_infinity")
    
    # PRNG functions work by adding a seed argument
    stanFunction("lkj_corr_rng", K = 3L, eta = 1)
    args(lkj_corr_rng) # has a seed argument
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
