<!DOCTYPE html><html lang="en"><head><title>Help for package twdtw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {twdtw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#date_to_numeric_cycle'><p>Convert Date/POSIXct to a Numeric Cycle</p></a></li>
<li><a href='#max_cycle_length'><p>Calculate the Maximum Possible Value of a Time Cycle</p></a></li>
<li><a href='#plot_cost_matrix'><p>Plot TWDTW cost matrix</p></a></li>
<li><a href='#print.twdtw'><p>Print method for twdtw class</p></a></li>
<li><a href='#twdtw'><p>Calculate Time-Weighted Dynamic Time Warping (TWDTW) distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Time-Weighted Dynamic Time Warping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Time-Weighted Dynamic Time Warping (TWDTW), 
    a measure for quantifying time series similarity. The TWDTW algorithm, 
    described in Maus et al. (2016) &lt;<a href="https://doi.org/10.1109%2FJSTARS.2016.2517118">doi:10.1109/JSTARS.2016.2517118</a>&gt; and 
    Maus et al. (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v088.i05">doi:10.18637/jss.v088.i05</a>&gt;, is applicable to multi-dimensional 
    time series of various resolutions. It is particularly suitable for comparing 
    time series with seasonality for environmental and ecological data analysis, 
    covering domains such as remote sensing imagery, climate data, hydrology, 
    and animal movement. The 'twdtw' package offers a user-friendly 'R' interface, 
    efficient 'Fortran' routines for TWDTW calculations, flexible time weighting 
    definitions, as well as utilities for time series preprocessing and visualization.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vwmaus/twdtw/">https://github.com/vwmaus/twdtw/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vwmaus/twdtw/issues/">https://github.com/vwmaus/twdtw/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, proxy</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rbenchmark, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'convert_date_to_numeric.R' 'init.R'
'plot_cost_matrix.R' 'twdtw.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-07 23:39:33 UTC; maus</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Maus <a href="https://orcid.org/0000-0002-7385-4723"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victor Maus &lt;vwmaus1@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='date_to_numeric_cycle'>Convert Date/POSIXct to a Numeric Cycle</h2><span id='topic+date_to_numeric_cycle'></span>

<h3>Description</h3>

<p>This function takes a date or datetime and converts it to a numeric cycle.
The cycle can be specified in units of years, months, days, hours, minutes, or seconds.
When cycle_length is a string, time_scale only changes the unit in which the result is expressed.
When cycle_length is numeric, time_scale and origin are used to compute the elapsed time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_to_numeric_cycle(x, cycle_length, time_scale, origin = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_to_numeric_cycle_+3A_x">x</code></td>
<td>
<p>A vector of dates or datetimes to convert. If not of type Date or POSIXct,
the function attempts to convert it.</p>
</td></tr>
<tr><td><code id="date_to_numeric_cycle_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The length of the cycle. Can be a numeric value or a string
specifying the units ('year', 'month', 'day', 'hour', 'minute', 'second').
When numeric, the cycle length is in the same units as time_scale. When a string,
it specifies the time unit of the cycle.</p>
</td></tr>
<tr><td><code id="date_to_numeric_cycle_+3A_time_scale">time_scale</code></td>
<td>
<p>Specifies the time scale for the conversion. Must be one of
'year', 'month', 'day', 'hour', 'minute', 'second'. When cycle_length is a string,
time_scale changes the unit in which the result is expressed.
When cycle_length is numeric, time_scale is used to compute the elapsed time in seconds.</p>
</td></tr>
<tr><td><code id="date_to_numeric_cycle_+3A_origin">origin</code></td>
<td>
<p>For numeric cycle_length, the origin must be specified. This is the point
from which the elapsed time is computed. Must be of the same class as x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric cycle value(s) corresponding to x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_to_numeric_cycle(Sys.time(), "year", "day") # Returns the day of the year
date_to_numeric_cycle(Sys.time(), "day", "hour") # Returns the hour of the day
</code></pre>

<hr>
<h2 id='max_cycle_length'>Calculate the Maximum Possible Value of a Time Cycle</h2><span id='topic+max_cycle_length'></span>

<h3>Description</h3>

<p>This function returns the maximum possible value that a specific time
component can take, given a cycle length and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_cycle_length(cycle_length, time_scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_cycle_length_+3A_cycle_length">cycle_length</code></td>
<td>
<p>A character string indicating the larger unit of time.
It must be one of &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;.</p>
</td></tr>
<tr><td><code id="max_cycle_length_+3A_time_scale">time_scale</code></td>
<td>
<p>A character string indicating the smaller unit of time,
which is a division of the <code>cycle_length</code>. If <code>cycle_length</code> is &quot;year&quot;,
<code>time_scale</code> can be one of &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;.
If <code>cycle_length</code> is &quot;month&quot;, <code>time_scale</code> can be &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;,
&quot;second&quot;, and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the maximum possible value that the <code>time_scale</code>
can take within one <code>cycle_length</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
max_cycle_length("year", "month")  # Maximum months is a year 12
max_cycle_length("day", "minute")  # Maximum minutes in a day 1440
max_cycle_length("year", "day")    # Maximum days in a year 366

</code></pre>

<hr>
<h2 id='plot_cost_matrix'>Plot TWDTW cost matrix</h2><span id='topic+plot_cost_matrix'></span>

<h3>Description</h3>

<p>This function visualizes the Time-Weighted Dynamic Time Warping cost matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cost_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cost_matrix_+3A_x">x</code></td>
<td>
<p>An object of class 'twdtw' including internal data.</p>
</td></tr>
<tr><td><code id="plot_cost_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image plot of the TWDTW cost matrix. The x-axis represents the time series x,
and the y-axis represents the time series y. The cost matrix is color-coded,
with darker shades indicating higher costs and lighter shades indicating lower costs.
No object is returned by this function; the plot is directly outputted to the active device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a time series
n &lt;- 23
t &lt;- seq(0, pi, length.out = n)
d &lt;- seq(as.Date('2020-09-01'), length.out = n, by = "15 day")

x &lt;- data.frame(time = d,      v1 = sin(t)*2 + runif(n))

# shift time by 30 days
y &lt;- data.frame(time = d + 30, v1 = sin(t)*2 + runif(n))

plot(x, type = "l", xlim = range(c(d, d + 5)))
lines(y, col = "red")

# Call twdtw using "output = 'internals'
twdtw_obj &lt;- twdtw(x, y,
       cycle_length = 'year',
       time_scale = 'day',
       time_weight = c(steepness = 0.1, midpoint = 50), output = 'internals')

plot_cost_matrix(twdtw_obj)

</code></pre>

<hr>
<h2 id='print.twdtw'>Print method for twdtw class</h2><span id='topic+print.twdtw'></span>

<h3>Description</h3>

<p>Print method for twdtw class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twdtw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.twdtw_+3A_x">x</code></td>
<td>
<p>An object of class <code>twdtw</code>.</p>
</td></tr>
<tr><td><code id="print.twdtw_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code> or other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a textual representation of the object <code>twdtw</code>, which is printed directly to the console.
If <code>x</code> is a list, the function will print a summary of matches and omit <code>twdtw</code>'s  internal data, see <code>names(x)</code>.
If <code>x</code> is not a list, it prints the content of <code>x</code>, i.e. either a matrix with all matches or the lowest <code>twdtw</code> distance.
</p>

<hr>
<h2 id='twdtw'>Calculate Time-Weighted Dynamic Time Warping (TWDTW) distance</h2><span id='topic+twdtw'></span><span id='topic+twdtw.data.frame'></span><span id='topic+twdtw.matrix'></span>

<h3>Description</h3>

<p>This function calculates the Time-Weighted Dynamic Time Warping (TWDTW) distance between two time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twdtw(x, y, time_weight, cycle_length, time_scale, ...)

## S3 method for class 'data.frame'
twdtw(
  x,
  y,
  time_weight,
  cycle_length,
  time_scale,
  origin = NULL,
  index_column = "time",
  max_elapsed = Inf,
  output = "distance",
  version = "f90",
  ...
)

## S3 method for class 'matrix'
twdtw(
  x,
  y,
  time_weight,
  cycle_length,
  time_scale = NULL,
  index_column = 1,
  max_elapsed = Inf,
  output = "distance",
  version = "f90",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twdtw_+3A_x">x</code></td>
<td>
<p>A data.frame or matrix representing time series.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_y">y</code></td>
<td>
<p>A data.frame or matrix representing a labeled time series (reference).</p>
</td></tr>
<tr><td><code id="twdtw_+3A_time_weight">time_weight</code></td>
<td>
<p>A numeric vector with length two (steepness and midpoint of logistic weight) or a function. See details.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_cycle_length">cycle_length</code></td>
<td>
<p>The length of the cycle. Can be a numeric value or a string
specifying the units ('year', 'month', 'day', 'hour', 'minute', 'second').
When numeric, the cycle length is in the same units as time_scale. When a string,
it specifies the time unit of the cycle.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_time_scale">time_scale</code></td>
<td>
<p>Specifies the time scale for the conversion. Must be one of
'year', 'month', 'day', 'hour', 'minute', 'second'. When cycle_length is a string,
time_scale changes the unit in which the result is expressed.
When cycle_length is numeric, time_scale is used to compute the elapsed time in seconds.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_...">...</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="twdtw_+3A_origin">origin</code></td>
<td>
<p>For numeric cycle_length, the origin must be specified. This is the point
from which the elapsed time is computed. Must be of the same class as x.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_index_column">index_column</code></td>
<td>
<p>(optional) The column name of the time index for data.frame inputs. Defaults to &quot;time&quot;.
For matrix input, an integer indicating the column with the time index. Defaults to 1.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_max_elapsed">max_elapsed</code></td>
<td>
<p>Numeric value constraining the TWDTW calculation to the lower band given by a maximum elapsed time. Defaults to Inf.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_output">output</code></td>
<td>
<p>A character string defining the output. It must be one of 'distance', 'matches', 'internals'. Defaults to 'distance'.
'distance' will return the lowest TWDTW distance between <code>x</code> and <code>y</code>.
'matches' will return all matches within the TWDTW matrix. 'internals' will return all TWDTW internal data.</p>
</td></tr>
<tr><td><code id="twdtw_+3A_version">version</code></td>
<td>
<p>A string identifying the version of TWDTW implementation.
Options are 'f90' for Fortran 90, 'f90goto' for Fortran 90 with goto statements,
or 'cpp' for C++ version. Defaults to 'f90'. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TWDTW calculates a time-weighted version of DTW by modifying each element of the
DTW's local cost matrix (see details in Maus et al. (2016) and Maus et al. (2019)).
The default time weight is calculated using a logistic function
that adds a weight to each pair of observations in the time series <code>x</code> and <code>y</code>
based on the time difference between observations, such that
</p>
<p style="text-align: center;"><code class="reqn">tw(dist_{i,j}) = dist_{i,j} + \frac{1}{1 + e^{-{\alpha} (el_{i,j} - {\beta})}}</code>
</p>

<p>Where:
</p>

<ul>
<li><p><code class="reqn">tw</code> is the time-weight function
</p>
</li>
<li><p><code class="reqn">dist_{i,j}</code> is the Euclidean distance between the i-th element of <code>x</code> and the j-th element of <code>y</code> in a multi-dimensional space
</p>
</li>
<li><p><code class="reqn">el_{i,j}</code> is the time elapsed between the i-th element of <code>x</code> and the j-th element of <code>y</code>
</p>
</li>
<li><p><code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are the steepness and midpoint of the logistic function, respectively
</p>
</li></ul>

<p>The logistic function is implemented as the default option in the C++ and Fortran versions of the code.
To use the native implementation, <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> must be provided as a numeric vector of
length two using the argument <code>time_weight</code>. This implementation provides high processing performance.
</p>
<p>The <code>time_weight</code> argument also accepts a function defined in R, allowing the user to define a different
weighting scheme. However, passing a function to <code>time_weight</code> can degrade the processing performance,
i.e., it can be up to 3x slower than using the default logistic time-weight.
</p>
<p>A time-weight function passed to <code>time_weight</code> must receive two numeric arguments and return a
single numeric value. The first argument received is the Euclidean <code class="reqn">dist_{i,j}</code> and the second
is the elapsed time <code class="reqn">el_{i,j}</code>. For example,
<code>time_weight = function(dist, el) dist + 0.1*el</code> defines a linear weighting scheme with a slope of 0.1.
</p>
<p>The Fortran 90 versions of <code>twdtw</code> are usually faster than the C++ version.
The '<code>f90goto</code>' version, which uses goto statements, is slightly quicker than the
'<code>f90</code>' version that uses while and for loops. You can use the <code>max_elapsed</code> parameter
to limit the TWDTW calculation to a maximum elapsed time. This means it will skip
comparisons between pairs of observations in <code>x</code> and <code>y</code> that are far apart in time.
Be careful, though: if <code>max_elapsed</code> is set too low, it could change the results.
It important to try out different settings for your specific problem.
</p>


<h3>Value</h3>

<p>An S3 object twdtw either:
If output = 'distance', a numeric value representing the TWDTW distance between the two time series.
If output = 'matches', a numeric matrix of all TWDTW matches. For each match the starting index, ending index,
and distance are returned. If output = 'internals', a list of all TWDTW internal data is returned.
</p>


<h3>References</h3>

<p>Maus, V., Camara, G., Cartaxo, R., Sanchez, A., Ramos, F. M., &amp; de Moura, Y. M. (2016).
A Time-Weighted Dynamic Time Warping Method for Land-Use and Land-Cover Mapping.
IEEE Journal of Selected Topics in Applied Earth Observations and Remote Sensing, 9(8), 3729-3739.
<a href="https://doi.org/10.1109/JSTARS.2016.2517118">doi:10.1109/JSTARS.2016.2517118</a>
</p>
<p>Maus, V., Camara, G., Appel, M., &amp; Pebesma, E. (2019).
dtwSat: Time-Weighted Dynamic Time Warping for Satellite Image Time Series Analysis in R.
Journal of Statistical Software, 88(5), 1-31.
<a href="https://doi.org/10.18637/jss.v088.i05">doi:10.18637/jss.v088.i05</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a time series
n &lt;- 23
t &lt;- seq(0, pi, length.out = n)
d &lt;- seq(as.Date('2020-09-01'), length.out = n, by = "15 day")

x &lt;- data.frame(time = d,      v1 = sin(t)*2 + runif(n))

# shift time by 30 days
y &lt;- data.frame(time = d + 30, v1 = sin(t)*2 + runif(n))

plot(x, type = "l", xlim = range(c(d, d + 5)))
lines(y, col = "red")

# Calculate TWDTW distance between x and y using logistic weight
twdtw(x, y,
      cycle_length = 'year',
      time_scale = 'day',
      time_weight = c(steepness = 0.1, midpoint = 50))

# Pass a generic time-weight function
twdtw(x, y,
      cycle_length = 'year',
      time_scale = 'day',
      time_weight = function(x,y) x + 1.0 / (1.0 + exp(-0.1 * (y - 50))))

# Test other version
twdtw(x, y,
      cycle_length = 'year',
      time_scale = 'day',
      time_weight = c(steepness = 0.1, midpoint = 50),
      version = 'f90goto')

twdtw(x, y,
      cycle_length = 'year',
      time_scale = 'day',
      time_weight = c(steepness = 0.1, midpoint = 50),
      version = 'cpp')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
