<!DOCTYPE html><html><head><title>Help for package eclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plot.eclust'><p>Plot Heatmap of Cluster Summaries by Exposure Status</p></a></li>
<li><a href='#plot.similarity'><p>Function to generate heatmap</p></a></li>
<li><a href='#r_cluster_data'><p>Cluster data using environmental exposure</p></a></li>
<li><a href='#r_prepare_data'><p>Prepare data for regression routines</p></a></li>
<li><a href='#s_generate_data'><p>Generate linear response data and test and training sets for simulation study</p></a></li>
<li><a href='#s_generate_data_mars'><p>Generate non linear response and test and training sets for non-linear</p>
simulation study</a></li>
<li><a href='#s_mars_clust'><p>Fit MARS Models on Simulated Cluster Summaries</p></a></li>
<li><a href='#s_mars_separate'><p>Fit Multivariate Adaptive Regression Splines on Simulated Data</p></a></li>
<li><a href='#s_modules'><p>Simulate Covariates With Exposure Dependent Correlations</p></a></li>
<li><a href='#s_pen_clust'><p>Fit Penalized Regression Models on Simulated Cluster Summaries</p></a></li>
<li><a href='#s_pen_separate'><p>Fit Penalized Regression Models on Simulated Data</p></a></li>
<li><a href='#s_response'><p>Generate True Response vector for Linear Simulation</p></a></li>
<li><a href='#s_response_mars'><p>Generate True Response vector for Non-Linear Simulation</p></a></li>
<li><a href='#simdata'><p>Simulated Data with Environment Dependent Correlations</p></a></li>
<li><a href='#tcgaov'><p>Subset of TCGA mRNA Ovarian serous cystadenocarcinoma data</p></a></li>
<li><a href='#u_cluster_similarity'><p>Cluster similarity matrix</p></a></li>
<li><a href='#u_extract_selected_earth'><p>Get selected terms from an earth object</p></a></li>
<li><a href='#u_extract_summary'><p>Calculates cluster summaries</p></a></li>
<li><a href='#u_fisherZ'><p>Calculate Fisher's Z Transformation for Correlations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Environment Based Clustering for Interpretable Predictive Models
in High Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Companion package to the paper: An analytic approach for 
    interpretable predictive models in high dimensional data, in the presence of 
    interactions with exposures. Bhatnagar, Yang, Khundrakpam, Evans, Blanchette, Bouchard, Greenwood (2017) &lt;<a href="https://doi.org/10.1101%2F102475">doi:10.1101/102475</a>&gt;. 
    This package includes an algorithm for clustering high dimensional data that can be affected by an environmental factor. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sahirbhatnagar/eclust/">https://github.com/sahirbhatnagar/eclust/</a>,
<a href="http://sahirbhatnagar.com/eclust/">http://sahirbhatnagar.com/eclust/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sahirbhatnagar/eclust/issues">https://github.com/sahirbhatnagar/eclust/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster, earth, ncvreg, knitr, rmarkdown, protoclust,
factoextra, ComplexHeatmap, circlize, pheatmap, viridis, pROC,
glmnet</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, data.table, dynamicTreeCut, magrittr, pacman, WGCNA,
stringr, pander, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-25 09:20:51 UTC; sahir</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahir Rai Bhatnagar [aut, cre] (http://sahirbhatnagar.com/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahir Rai Bhatnagar &lt;sahir.bhatnagar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-26 12:08:12</td>
</tr>
</table>
<hr>
<h2 id='plot.eclust'>Plot Heatmap of Cluster Summaries by Exposure Status</h2><span id='topic+plot.eclust'></span>

<h3>Description</h3>

<p>Plots cluster summaries such as the 1st principal component or
average by exposure status. This is a plot method for object of class
eclust returned by the <code><a href="#topic+r_cluster_data">r_cluster_data</a></code> function. Two heatmaps,
side-by-side are returned, where the first heatmap corresponds to the
unexposed subjects and the second heatmap corresponds to the exposed
subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eclust'
plot(x, type = c("ECLUST", "CLUST"), summary = c("pc",
  "avg"), sample = c("training", "test"), unexposed_title = "E=0",
  exposed_title = "E=1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.eclust_+3A_x">x</code></td>
<td>
<p>object of class <code>eclust</code>, which is returned by the
<code><a href="#topic+r_cluster_data">r_cluster_data</a></code> function</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_type">type</code></td>
<td>
<p>show results from the &quot;ECLUST&quot; (which considers the environment)
or &quot;CLUST&quot; (which ignores the environment) methods. Default is &quot;ECLUST&quot;.
See <code><a href="#topic+r_cluster_data">r_cluster_data</a></code> for details. This function uses the
<code>clustersAddon</code> object for &quot;ECLUST&quot; and the <code>clustersAll</code> for
&quot;CLUST&quot;</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_summary">summary</code></td>
<td>
<p>show the 1st principal component or the average of each
cluster. Default is &quot;pc&quot;.</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_sample">sample</code></td>
<td>
<p>which sample to show, the &quot;training&quot; or the &quot;test&quot; set. Default
is &quot;training&quot;. This is determined by the <code>train_index</code> and
<code>test_index</code> arguments in the <code><a href="#topic+r_cluster_data">r_cluster_data</a></code> function.
If you want to show all subjects, then provide the numeric vector 1:n to
either argument, where n is the entire sample size.</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_unexposed_title">unexposed_title</code></td>
<td>
<p>The title for the unexposed subjects heatmap. Default
is &quot;E=0&quot;.</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_exposed_title">exposed_title</code></td>
<td>
<p>The title for the exposed subjects heatmap. Default is
&quot;E=1&quot;.</p>
</td></tr>
<tr><td><code id="plot.eclust_+3A_...">...</code></td>
<td>
<p>other arguments passed to the
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rows are the cluster summaries and columns are the subjects. This
function determines the minimum and maximum value for the whole dataset and
then creates a color scale using those values with the
<code><a href="circlize.html#topic+colorRamp2">colorRamp2</a></code>. This is so that both heatmaps are on
the same color scale, i.e., each color represents the same value in both
heatmaps. This is done for being able to visually compare the results.
</p>


<h3>Value</h3>

<p>a plot of two Heatmaps, side-by-side, of the cluster summaries by exposure status
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("tcgaov")
tcgaov[1:5,1:6, with = FALSE]
Y &lt;- log(tcgaov[["OS"]])
E &lt;- tcgaov[["E"]]
genes &lt;- as.matrix(tcgaov[,-c("OS","rn","subtype","E","status"),with = FALSE])
trainIndex &lt;- drop(caret::createDataPartition(Y, p = 1, list = FALSE, times = 1))
testIndex &lt;- setdiff(seq_len(length(Y)),trainIndex)

cluster_res &lt;- r_cluster_data(data = genes,
                              response = Y,
                              exposure = E,
                              train_index = trainIndex,
                              test_index = testIndex,
                              cluster_distance = "tom",
                              eclust_distance = "difftom",
                              measure_distance = "euclidean",
                              clustMethod = "hclust",
                              cutMethod = "dynamic",
                              method = "average",
                              nPC = 1,
                              minimum_cluster_size = 60)

class(cluster_res)

plot(cluster_res, show_column_names = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.similarity'>Function to generate heatmap</h2><span id='topic+plot.similarity'></span>

<h3>Description</h3>

<p>Plots a heatmap of a similarity matrix such as a correlation
matrix or a TOM matrix. This function is a plotting method for an object of
class similarity. These objects are returned by the
<code><a href="#topic+s_generate_data">s_generate_data</a></code> and <code><a href="#topic+s_generate_data_mars">s_generate_data_mars</a></code>
functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'similarity'
plot(x, color = viridis::viridis(100), truemodule,
  active, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.similarity_+3A_x">x</code></td>
<td>
<p>an object of class similarity. This is a p x p symmetric matix such
as a correlation matrix or a TOM matrix, where p is the number of genes</p>
</td></tr>
<tr><td><code id="plot.similarity_+3A_color">color</code></td>
<td>
<p>colors for the heatmap. By default it uses the <code>viridis</code>
color scheme. The <code>viridis</code> package needs to be installed.</p>
</td></tr>
<tr><td><code id="plot.similarity_+3A_truemodule">truemodule</code></td>
<td>
<p>a numeric vector of length p where p is the number of
genes, giving the module membership. By default, 0 = Grey, 1 = Turquoise, 2
= Blue, 3 = Red, 4 = Green, and 5 = Yellow. This information is used for
annotating the heatmap</p>
</td></tr>
<tr><td><code id="plot.similarity_+3A_active">active</code></td>
<td>
<p>a binary vector of length p (where p is the number of genes)
where 0 means that gene is not related to the response, and 1 means that
the gene is associated to the response.</p>
</td></tr>
<tr><td><code id="plot.similarity_+3A_...">...</code></td>
<td>
<p>other arguments passed to the pheatmap function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a heatmap of a similarity matrix
</p>


<h3>Note</h3>

<p>this function is only meant to be used with output from the
<code><a href="#topic+s_generate_data">s_generate_data</a></code> and <code><a href="#topic+s_generate_data_mars">s_generate_data_mars</a></code>
functions, since it assumes a fixed number of modules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
corrX &lt;- cor(simdata[,c(-1,-2)])
class(corrX) &lt;- append(class(corrX), "similarity")
plot(corrX, truemodule = c(rep(1:5, each=150), rep(0, 250)))

## End(Not run)
</code></pre>

<hr>
<h2 id='r_cluster_data'>Cluster data using environmental exposure</h2><span id='topic+r_cluster_data'></span>

<h3>Description</h3>

<p>This is one of the functions for real data analysis, which will
cluster the data based on the environment, as well as ignoring the
environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_cluster_data(data, response, exposure, train_index, test_index,
  cluster_distance = c("corr", "corr0", "corr1", "tom", "tom0", "tom1",
  "diffcorr", "difftom", "fisherScore"), eclust_distance = c("fisherScore",
  "corScor", "diffcorr", "difftom"), measure_distance = c("euclidean",
  "maximum", "manhattan", "canberra", "binary", "minkowski"),
  minimum_cluster_size = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_cluster_data_+3A_data">data</code></td>
<td>
<p>n x p matrix of data. rows are samples, columns are genes or cpg
sites. Should not contain the environment variable</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_response">response</code></td>
<td>
<p>numeric vector of length n</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_exposure">exposure</code></td>
<td>
<p>binary (0,1) numeric vector of length n for the exposure
status of the n samples</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_train_index">train_index</code></td>
<td>
<p>numeric vector indcating the indices of <code>response</code>
and the rows of <code>data</code> that are in the training set</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_test_index">test_index</code></td>
<td>
<p>numeric vector indcating the indices of <code>response</code> and
the rows of <code>data</code> that are in the test set</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_cluster_distance">cluster_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
</p>
 <ul>
<li><p> corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore </p>
</li></ul>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_eclust_distance">eclust_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
<code>cluster_distance</code> for avaialble options. Should be different from
<code>cluster_distance</code>. For example, if <code>cluster_distance=corr</code> and
<code>EclustDistance=fisherScore</code>. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_measure_distance">measure_distance</code></td>
<td>
<p>one of &quot;euclidean&quot;,&quot;maximum&quot;,&quot;manhattan&quot;,
&quot;canberra&quot;, &quot;binary&quot;,&quot;minkowski&quot; to be passed to <code><a href="stats.html#topic+dist">dist</a></code>
function for calculating the distance for the clusters based on the
corr,corr1,corr0, tom, tom0, tom1 matrices</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_minimum_cluster_size">minimum_cluster_size</code></td>
<td>
<p>The minimum cluster size. Only applicable if
<code>cutMethod='dynamic'</code>. This argument is passed to the
<code><a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a></code> function through the
<code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code> function. Default is 50.</p>
</td></tr>
<tr><td><code id="r_cluster_data_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code>
function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function clusters the data. The results of this function should
then be passed to the <code><a href="#topic+r_prepare_data">r_prepare_data</a></code> function which output
the appropriate X and Y matrices in the right format for regression
packages such as <code>mgcv</code>, <code>caret</code> and <code>glmnet</code>
</p>


<h3>Value</h3>

<p>a list of length 8: </p>
<dl>
<dt>clustersAddon</dt><dd><p>clustering results
based on the environment and not the environment. see
<code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code> for
details</p>
</dd><dt>clustersAll</dt><dd><p>clustering results ignoring the environment. See
<code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code> for details</p>
</dd><dt>etrain</dt><dd><p>vector of the
exposure variable for the training
set</p>
</dd><dt>cluster_distance_similarity</dt><dd><p>the similarity matrix based on the
argument specified in
<code>cluster_distance</code></p>
</dd><dt>eclust_distance_similarity</dt><dd><p>the similarity
matrix based on the argument specified in
<code>eclust_distance</code></p>
</dd><dt>clustersAddonMembership</dt><dd><p>a data.frame and
data.table of the clustering membership for clustering results based on the
environment and not the environment. As a result, each gene will show up
twice in this table</p>
</dd><dt>clustersAllMembership</dt><dd><p>a data.frame and
data.table of the clustering membership for clustering results based on all
subjects i.e. ignoring the environment. Each gene will only show up once in
this table</p>
</dd><dt>clustersEclustMembership</dt><dd><p>a data.frame and data.table of
the clustering membership for clustering results accounting for the
environment. Each gene will only show up once in this table</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tcgaov")
tcgaov[1:5,1:6, with = FALSE]
Y &lt;- log(tcgaov[["OS"]])
E &lt;- tcgaov[["E"]]
genes &lt;- as.matrix(tcgaov[,-c("OS","rn","subtype","E","status"),with = FALSE])
trainIndex &lt;- drop(caret::createDataPartition(Y, p = 0.5, list = FALSE, times = 1))
testIndex &lt;- setdiff(seq_len(length(Y)),trainIndex)

## Not run: 
cluster_res &lt;- r_cluster_data(data = genes,
                              response = Y,
                              exposure = E,
                              train_index = trainIndex,
                              test_index = testIndex,
                              cluster_distance = "tom",
                              eclust_distance = "difftom",
                              measure_distance = "euclidean",
                              clustMethod = "hclust",
                              cutMethod = "dynamic",
                              method = "average",
                              nPC = 1,
                              minimum_cluster_size = 60)

# the number of clusters determined by the similarity matrices specified
# in the cluster_distance and eclust_distance arguments. This will always be larger
# than cluster_res$clustersAll$nclusters which is based on the similarity matrix
# specified in the cluster_distance argument
cluster_res$clustersAddon$nclusters

# the number of clusters determined by the similarity matrices specified
# in the cluster_distance argument only
cluster_res$clustersAll$nclusters

## End(Not run)
</code></pre>

<hr>
<h2 id='r_prepare_data'>Prepare data for regression routines</h2><span id='topic+r_prepare_data'></span>

<h3>Description</h3>

<p>This function will output the appropriate X and Y matrices in
the right format for regression packages such as <code>mgcv</code>, <code>caret</code>
and <code>glmnet</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_prepare_data(data, response = "Y", exposure = "E", probe_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_prepare_data_+3A_data">data</code></td>
<td>
<p>the data frame which contains the response, exposure, and genes
or cpgs or covariates. the columns should be labelled.</p>
</td></tr>
<tr><td><code id="r_prepare_data_+3A_response">response</code></td>
<td>
<p>the column name of the response in the <code>data</code> argument</p>
</td></tr>
<tr><td><code id="r_prepare_data_+3A_exposure">exposure</code></td>
<td>
<p>the column name of the exposure in the <code>data</code> argument</p>
</td></tr>
<tr><td><code id="r_prepare_data_+3A_probe_names">probe_names</code></td>
<td>
<p>the column names of the genes, or cpg sites or covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length 5: </p>
<dl>
<dt>X</dt><dd><p>the X matrix</p>
</dd><dt>Y</dt><dd><p>the
response vector</p>
</dd><dt>E</dt><dd><p>the exposure vector</p>
</dd><dt>main_effect_names</dt><dd><p>the
names of the main effects including the
exposure</p>
</dd><dt>interaction_names</dt><dd><p>the names of the interaction effects</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("tcgaov")
tcgaov[1:5,1:6, with = FALSE]
Y &lt;- log(tcgaov[["OS"]])
E &lt;- tcgaov[["E"]]
genes &lt;- as.matrix(tcgaov[,-c("OS","rn","subtype","E","status"),with = FALSE])
trainIndex &lt;- drop(caret::createDataPartition(Y, p = 0.5, list = FALSE, times = 1))
testIndex &lt;- setdiff(seq_len(length(Y)),trainIndex)

## Not run: 
cluster_res &lt;- r_cluster_data(data = genes,
                              response = Y,
                              exposure = E,
                              train_index = trainIndex,
                              test_index = testIndex,
                              cluster_distance = "tom",
                              eclust_distance = "difftom",
                              measure_distance = "euclidean",
                              clustMethod = "hclust",
                              cutMethod = "dynamic",
                              method = "average",
                              nPC = 1,
                              minimum_cluster_size = 50)

pc_eclust_interaction &lt;- r_prepare_data(data = cbind(cluster_res$clustersAddon$PC,
                                                     survival = Y[trainIndex],
                                                     subtype = E[trainIndex]),
                                        response = "survival", exposure = "subtype")
names(pc_eclust_interaction)
dim(pc_eclust_interaction$X)
pc_eclust_interaction$main_effect_names
pc_eclust_interaction$interaction_names

## End(Not run)
</code></pre>

<hr>
<h2 id='s_generate_data'>Generate linear response data and test and training sets for simulation study</h2><span id='topic+s_generate_data'></span>

<h3>Description</h3>

<p>create a function that takes as input, the number of genes, the
true beta vector, the gene expression matrix created from the
generate_blocks function and returns a list of data matrix, as well as
correlation matrices, TOM matrices, cluster information, training and test
data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_generate_data(p, X, beta, binary_outcome = FALSE,
  cluster_distance = c("corr", "corr0", "corr1", "tom", "tom0", "tom1",
  "diffcorr", "difftom", "corScor", "tomScor", "fisherScore"), n, n0,
  include_interaction = F, signal_to_noise_ratio = 1,
  eclust_distance = c("fisherScore", "corScor", "diffcorr", "difftom"),
  cluster_method = c("hclust", "protoclust"), cut_method = c("dynamic",
  "gap", "fixed"), distance_method = c("euclidean", "maximum", "manhattan",
  "canberra", "binary", "minkowski"), n_clusters,
  agglomeration_method = c("complete", "average", "ward.D2", "single",
  "ward.D", "mcquitty", "median", "centroid"), nPC = 1, K.max = 10,
  B = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_generate_data_+3A_p">p</code></td>
<td>
<p>number of genes in design matrix</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_x">X</code></td>
<td>
<p>gene expression matrix of size n x p using the
<code>generate_blocks</code> function</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_beta">beta</code></td>
<td>
<p>true beta coefficient vector</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_binary_outcome">binary_outcome</code></td>
<td>
<p>Logical. Should a binary outcome be generated. Default
is <code>FALSE</code>. See details on how a binary outcome is generated</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_cluster_distance">cluster_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
</p>
 <ul>
<li><p> corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore </p>
</li></ul>
</td></tr>
<tr><td><code id="s_generate_data_+3A_n">n</code></td>
<td>
<p>total number of subjects</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_n0">n0</code></td>
<td>
<p>total number of subjects with E=0</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should an interaction with the environment be
generated as part of the response. Default is FALSE.</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_signal_to_noise_ratio">signal_to_noise_ratio</code></td>
<td>
<p>signal to noise ratio, default is 1</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_eclust_distance">eclust_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
<code>cluster_distance</code> for avaialble options. Should be different from
<code>cluster_distance</code>. For example, if <code>cluster_distance=corr</code> and
<code>EclustDistance=fisherScore</code>. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_cluster_method">cluster_method</code></td>
<td>
<p>Cluster the data using hierarchical clustering or
prototype clustering. Defaults <code>cluster_method="hclust"</code>. Other option
is <code><a href="protoclust.html#topic+protoclust">protoclust</a></code>, however this package must be
installed before proceeding with this option</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_cut_method">cut_method</code></td>
<td>
<p>what method to use to cut the dendrogram. <code>'dynamic'</code>
refers to <code>dynamicTreeCut</code> library. <code>'gap'</code> is Tibshirani's gap
statistic <code><a href="cluster.html#topic+clusGap">clusGap</a></code> using the <code>'Tibs2001SEmax'</code>
rule. <code>'fixed'</code> is a fixed number specified by the <code>n_clusters</code>
argument</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_distance_method">distance_method</code></td>
<td>
<p>one of &quot;euclidean&quot;,&quot;maximum&quot;,&quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot;,&quot;minkowski&quot; to be passed to <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_n_clusters">n_clusters</code></td>
<td>
<p>Number of clusters specified by the user. Only applicable
when <code>cut_method="fixed"</code></p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_agglomeration_method">agglomeration_method</code></td>
<td>
<p>the agglomeration method to be used. This should
be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC)
or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to extract from each cluster.
Default is 1. Only 1 or 2 is allowed.</p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_k.max">K.max</code></td>
<td>
<p>the maximum number of clusters to consider, must be at least
two. Only used if <code>cutMethod='gap'</code></p>
</td></tr>
<tr><td><code id="s_generate_data_+3A_b">B</code></td>
<td>
<p>integer, number of Monte Carlo (“bootstrap”) samples. Only used if
<code>cutMethod='gap'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate a binary outcome we first generate a continuous outcome
Y which is <code class="reqn">X^T \beta</code>, defined <code class="reqn">p = 1/(1 + exp(-Y ))</code> and used
this to generate a two-class outcome z with <code class="reqn">Pr(z = 1) = p</code> and
<code class="reqn">Pr(z = 0) = 1 - p</code>.
</p>


<h3>Value</h3>

<p>list of (in the following order) </p>
 <dl>
<dt>beta_truth</dt><dd><p>a 1
column matrix containing the true beta coefficient vector</p>
</dd>
<dt>similarity</dt><dd><p>an object of class similarity which is the similarity
matrix specified by the <code>cluster_distance</code>
argument</p>
</dd><dt>similarityEclust</dt><dd><p>an object of class similarity which is the
similarity matrix specified by the <code>eclust_distance</code> argument</p>
</dd>
<dt>DT</dt><dd><p>data.table of simulated data from the <code>s_response</code> function</p>
</dd>
<dt>Y</dt><dd><p>The simulated response</p>
</dd> <dt>X0</dt><dd><p>the n0 x p design matrix for the
unexposed subjects</p>
</dd> <dt>X1</dt><dd><p>the n1 x p design matrix for the exposed
subjects</p>
</dd> <dt>X_train</dt><dd><p>the training design matrix for all subjects</p>
</dd>
<dt>X_test</dt><dd><p>the test set design matrix for all subjects</p>
</dd>
<dt>Y_train</dt><dd><p>the training set response</p>
</dd> <dt>Y_test</dt><dd><p>the test set
response</p>
</dd> <dt>DT_train</dt><dd><p>the training response and training design matrix
in a single data.frame object</p>
</dd> <dt>DT_test</dt><dd><p>the test response and
training design matrix in a single data.frame object</p>
</dd> <dt>S0</dt><dd><p>a character
vector of the active genes i.e. the ones that are associated with the
response</p>
</dd> <dt>n_clusters_All</dt><dd><p>the number of clusters identified by using
the similarity matrix specified by the <code>cluster_distance</code> argument</p>
</dd>
<dt>n_clusters_Eclust</dt><dd><p>the number of clusters identified by using the
similarity matrix specified by the <code>eclust_distance</code>
argument</p>
</dd><dt>n_clusters_Addon</dt><dd><p>the sum of <code>n_clusters_All</code> and
<code>n_clusters_Eclust</code></p>
</dd> <dt>clustersAll</dt><dd><p>the cluster membership of each
gene based on the <code>cluster_distance</code> matrix</p>
</dd> <dt>clustersAddon</dt><dd><p>the
cluster membership of each gene based on both the <code>cluster_distance</code>
matrix and the <code>eclust_distance</code> matrix. Note that each gene will
appear twice here</p>
</dd><dt>clustersEclust</dt><dd><p>the cluster membership of each gene
based on the <code>eclust_distance</code> matrix</p>
</dd>
<dt>gene_groups_inter</dt><dd><p>cluster membership of each gene with a penalty
factor used for the group lasso</p>
</dd> <dt>gene_groups_inter_Addon</dt><dd><p>cluster
membership of each gene with a penalty factor used for the group lasso</p>
</dd>
<dt>tom_train_all</dt><dd><p>the TOM matrix based on all training subjects</p>
</dd>
<dt>tom_train_diff</dt><dd><p>the absolute difference of the exposed and unexposed
TOM matrices: <code class="reqn">|TOM_{E=1} - TOM_{E=0}|</code></p>
</dd> <dt>tom_train_e1</dt><dd><p>the TOM
matrix based on training exposed subjects only</p>
</dd> <dt>tom_train_e0</dt><dd><p>the TOM
matrix based on training unexposed subjects only</p>
</dd> <dt>corr_train_all</dt><dd><p>the
Pearson correlation matrix based on all training subjects</p>
</dd>
<dt>corr_train_diff</dt><dd><p>the absolute difference of the exposed and unexposed
Pearson correlation matrices: <code class="reqn">|Cor_{E=1} - Cor_{E=0}|</code></p>
</dd>
<dt>corr_train_e1</dt><dd><p>the Pearson correlation matrix based on training
exposed subjects only</p>
</dd> <dt>corr_train_e0</dt><dd><p>the Pearson correlation matrix
based on training unexposed subjects only</p>
</dd><dt>fisherScore</dt><dd><p>The fisher
scoring matrix. see <code><a href="#topic+u_fisherZ">u_fisherZ</a></code> for details</p>
</dd><dt>corScor</dt><dd><p>The
correlation scoring matrix: <code class="reqn">|Cor_{E=1} + Cor_{E=0} - 2|</code></p>
</dd>
<dt>mse_null</dt><dd><p>The MSE for the null model</p>
</dd><dt>DT_train_folds</dt><dd><p>The 10
training folds used for the stability measures</p>
</dd><dt>X_train_folds</dt><dd><p>The 10
X training folds (the same as in DT_train_folds)</p>
</dd><dt>Y_train_folds</dt><dd><p>The
10 Y training folds (the same as in DT_train_folds)</p>
</dd> </dl>



<h3>Note</h3>

<p>this function calls the <code>s_response</code> to generate phenotype as a
function of the gene expression data. This function also returns other
information derived from the simulated data including the test and training
sets, the correlation and TOM matrices and the clusters.
</p>
<p>the PCs and averages need to be calculated in the fitting functions,
because these will change based on the CV fold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)
betaMainInteractions &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
betaMainInteractions[which(betaMainEffect!=0)] &lt;- runif(nActive, alphaMean - 0.1, alphaMean + 0.1)
beta &lt;- c(betaMainEffect, betaE, betaMainInteractions)
## Not run: 
result &lt;- s_generate_data(p = p, X = X,
                          beta = beta,
                          include_interaction = TRUE,
                          cluster_distance = cluster_distance,
                          n = n, n0 = n0,
                          eclust_distance = Ecluster_distance,
                          signal_to_noise_ratio = SNR,
                          distance_method = distanceMethod,
                          cluster_method = clustMethod,
                          cut_method = cutMethod,
                          agglomeration_method = agglomerationMethod,
                          nPC = 1)
names(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='s_generate_data_mars'>Generate non linear response and test and training sets for non-linear
simulation study</h2><span id='topic+s_generate_data_mars'></span>

<h3>Description</h3>

<p>create a function that takes as input, the number of genes, the
true beta vector, the gene expression matrix created from the
generate_blocks function and returns a list of data matrix, as well as
correlation matrices, TOM matrices, cluster information, training and test
data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_generate_data_mars(p, X, beta, binary_outcome = FALSE, truemodule, nActive,
  cluster_distance = c("corr", "corr0", "corr1", "tom", "tom0", "tom1",
  "diffcorr", "difftom", "corScor", "tomScor", "fisherScore"), n, n0,
  include_interaction = F, signal_to_noise_ratio = 1,
  eclust_distance = c("fisherScore", "corScor", "diffcorr", "difftom"),
  cluster_method = c("hclust", "protoclust"), cut_method = c("dynamic",
  "gap", "fixed"), distance_method = c("euclidean", "maximum", "manhattan",
  "canberra", "binary", "minkowski"), n_clusters,
  agglomeration_method = c("complete", "average", "ward.D2", "single",
  "ward.D", "mcquitty", "median", "centroid"), nPC = 1, K.max = 10,
  B = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_generate_data_mars_+3A_p">p</code></td>
<td>
<p>number of genes in design matrix</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_x">X</code></td>
<td>
<p>gene expression matrix of size n x p using the
<code>generate_blocks</code> function</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_beta">beta</code></td>
<td>
<p>true beta coefficient vector</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_binary_outcome">binary_outcome</code></td>
<td>
<p>Logical. Should a binary outcome be generated. Default
is <code>FALSE</code>. See details on how a binary outcome is generated</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_truemodule">truemodule</code></td>
<td>
<p>numeric vector of the true module membership used in the
<code>s_response_mars</code> function. Modules 3 and 4 are active in the
response. See <code>s_response_mars</code> function for details.</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_nactive">nActive</code></td>
<td>
<p>number of active genes in the response used in the
<code>s_response_mars</code></p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_cluster_distance">cluster_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes. Must be one of the following
</p>
 <ul>
<li><p> corr, corr0, corr1, tom, tom0, tom1, diffcorr, difftom,
corScor, tomScor, fisherScore </p>
</li></ul>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_n">n</code></td>
<td>
<p>total number of subjects</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_n0">n0</code></td>
<td>
<p>total number of subjects with E=0</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should an interaction with the environment be
generated as part of the response. Default is FALSE.</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_signal_to_noise_ratio">signal_to_noise_ratio</code></td>
<td>
<p>signal to noise ratio, default is 1</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_eclust_distance">eclust_distance</code></td>
<td>
<p>character representing which matrix from the training
set that you want to use to cluster the genes based on the environment. See
<code>cluster_distance</code> for avaialble options. Should be different from
<code>cluster_distance</code>. For example, if <code>cluster_distance=corr</code> and
<code>EclustDistance=fisherScore</code>. That is, one should be based on
correlations ignoring the environment, and the other should be based on
correlations accounting for the environment. This function will always
return this add on</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_cluster_method">cluster_method</code></td>
<td>
<p>Cluster the data using hierarchical clustering or
prototype clustering. Defaults <code>cluster_method="hclust"</code>. Other option
is <code><a href="protoclust.html#topic+protoclust">protoclust</a></code>, however this package must be
installed before proceeding with this option</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_cut_method">cut_method</code></td>
<td>
<p>what method to use to cut the dendrogram. <code>'dynamic'</code>
refers to <code>dynamicTreeCut</code> library. <code>'gap'</code> is Tibshirani's gap
statistic <code><a href="cluster.html#topic+clusGap">clusGap</a></code> using the <code>'Tibs2001SEmax'</code>
rule. <code>'fixed'</code> is a fixed number specified by the <code>n_clusters</code>
argument</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_distance_method">distance_method</code></td>
<td>
<p>one of &quot;euclidean&quot;,&quot;maximum&quot;,&quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot;,&quot;minkowski&quot; to be passed to <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_n_clusters">n_clusters</code></td>
<td>
<p>Number of clusters specified by the user. Only applicable
when <code>cut_method="fixed"</code></p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_agglomeration_method">agglomeration_method</code></td>
<td>
<p>the agglomeration method to be used. This should
be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC)
or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_npc">nPC</code></td>
<td>
<p>number of principal components. Can be 1 or 2.</p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_k.max">K.max</code></td>
<td>
<p>the maximum number of clusters to consider, must be at least
two. Only used if <code>cutMethod='gap'</code></p>
</td></tr>
<tr><td><code id="s_generate_data_mars_+3A_b">B</code></td>
<td>
<p>integer, number of Monte Carlo (“bootstrap”) samples. Only used if
<code>cutMethod='gap'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of (in the following order) </p>
 <dl>
<dt>beta_truth</dt><dd><p>a 1
column matrix containing the true beta coefficient vector</p>
</dd>
<dt>similarity</dt><dd><p>an object of class similarity which is the similarity
matrix specified by the <code>cluster_distance</code>
argument</p>
</dd><dt>similarityEclust</dt><dd><p>an object of class similarity which is the
similarity matrix specified by the <code>eclust_distance</code> argument</p>
</dd>
<dt>DT</dt><dd><p>data.table of simulated data from the <code>s_response</code> function</p>
</dd>
<dt>Y</dt><dd><p>The simulated response</p>
</dd> <dt>X0</dt><dd><p>the n0 x p design matrix for the
unexposed subjects</p>
</dd> <dt>X1</dt><dd><p>the n1 x p design matrix for the exposed
subjects</p>
</dd> <dt>X_train</dt><dd><p>the training design matrix for all subjects</p>
</dd>
<dt>X_test</dt><dd><p>the test set design matrix for all subjects</p>
</dd>
<dt>Y_train</dt><dd><p>the training set response</p>
</dd> <dt>Y_test</dt><dd><p>the test set
response</p>
</dd> <dt>DT_train</dt><dd><p>the training response and training design matrix
in a single data.frame object</p>
</dd> <dt>DT_test</dt><dd><p>the test response and
training design matrix in a single data.frame object</p>
</dd> <dt>S0</dt><dd><p>a character
vector of the active genes i.e. the ones that are associated with the
response</p>
</dd> <dt>n_clusters_All</dt><dd><p>the number of clusters identified by using
the similarity matrix specified by the <code>cluster_distance</code> argument</p>
</dd>
<dt>n_clusters_Eclust</dt><dd><p>the number of clusters identified by using the
similarity matrix specified by the <code>eclust_distance</code>
argument</p>
</dd><dt>n_clusters_Addon</dt><dd><p>the sum of <code>n_clusters_All</code> and
<code>n_clusters_Eclust</code></p>
</dd> <dt>clustersAll</dt><dd><p>the cluster membership of each
gene based on the <code>cluster_distance</code> matrix</p>
</dd> <dt>clustersAddon</dt><dd><p>the
cluster membership of each gene based on both the <code>cluster_distance</code>
matrix and the <code>eclust_distance</code> matrix. Note that each gene will
appear twice here</p>
</dd><dt>clustersEclust</dt><dd><p>the cluster membership of each gene
based on the <code>eclust_distance</code> matrix</p>
</dd>
<dt>gene_groups_inter</dt><dd><p>cluster membership of each gene with a penalty
factor used for the group lasso</p>
</dd> <dt>gene_groups_inter_Addon</dt><dd><p>cluster
membership of each gene with a penalty factor used for the group lasso</p>
</dd>
<dt>tom_train_all</dt><dd><p>the TOM matrix based on all training subjects</p>
</dd>
<dt>tom_train_diff</dt><dd><p>the absolute difference of the exposed and unexposed
TOM matrices: <code class="reqn">|TOM_{E=1} - TOM_{E=0}|</code></p>
</dd> <dt>tom_train_e1</dt><dd><p>the TOM
matrix based on training exposed subjects only</p>
</dd> <dt>tom_train_e0</dt><dd><p>the TOM
matrix based on training unexposed subjects only</p>
</dd> <dt>corr_train_all</dt><dd><p>the
Pearson correlation matrix based on all training subjects</p>
</dd>
<dt>corr_train_diff</dt><dd><p>the absolute difference of the exposed and unexposed
Pearson correlation matrices: <code class="reqn">|Cor_{E=1} - Cor_{E=0}|</code></p>
</dd>
<dt>corr_train_e1</dt><dd><p>the Pearson correlation matrix based on training
exposed subjects only</p>
</dd> <dt>corr_train_e0</dt><dd><p>the Pearson correlation matrix
based on training unexposed subjects only</p>
</dd><dt>fisherScore</dt><dd><p>The fisher
scoring matrix. see <code><a href="#topic+u_fisherZ">u_fisherZ</a></code> for details</p>
</dd><dt>corScor</dt><dd><p>The
correlation scoring matrix: <code class="reqn">|Cor_{E=1} + Cor_{E=0} - 2|</code></p>
</dd>
<dt>mse_null</dt><dd><p>The MSE for the null model</p>
</dd><dt>DT_train_folds</dt><dd><p>The 10
training folds used for the stability measures</p>
</dd><dt>X_train_folds</dt><dd><p>The 10
X training folds (the same as in DT_train_folds)</p>
</dd><dt>Y_train_folds</dt><dd><p>The
10 Y training folds (the same as in DT_train_folds)</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta &lt;- c(betaMainEffect, betaE)

result &lt;- s_generate_data_mars(p = p, X = X,
                               beta = beta,
                               binary_outcome = FALSE,
                               truemodule = truemodule1,
                               nActive = nActive,
                               include_interaction = FALSE,
                               cluster_distance = cluster_distance,
                               n = n, n0 = n0,
                               eclust_distance = Ecluster_distance,
                               signal_to_noise_ratio = SNR,
                               distance_method = distanceMethod,
                               cluster_method = clustMethod,
                               cut_method = cutMethod,
                               agglomeration_method = agglomerationMethod,
                               nPC = 1)
names(result)
</code></pre>

<hr>
<h2 id='s_mars_clust'>Fit MARS Models on Simulated Cluster Summaries</h2><span id='topic+s_mars_clust'></span>

<h3>Description</h3>

<p>This function creates summaries of the given clusters (e.g. 1st
PC or average), and then runs Friedman's MARS on those
summaries. To be used with simulated data where the 'truth' is known i.e.,
you know which features are associated with the response. This function was
used to produce the simulation results in Bhatnagar et al. 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_mars_clust(x_train, x_test, y_train, y_test, s0, summary = c("pc", "avg"),
  model = c("MARS"), exp_family = c("gaussian", "binomial"), gene_groups,
  true_beta = NULL, topgenes = NULL, stability = F, filter = F,
  include_E = T, include_interaction = F, clust_type = c("CLUST",
  "ECLUST"), nPC = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_mars_clust_+3A_x_train">x_train</code></td>
<td>
<p><code>ntrain x p</code> matrix of simulated training set where
<code>ntrain</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_x_test">x_test</code></td>
<td>
<p><code>ntest x p</code> matrix of simulated training set where
<code>ntest</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_y_train">y_train</code></td>
<td>
<p>numeric vector of length <code>ntrain</code> representing the
responses for the training subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class)</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_y_test">y_test</code></td>
<td>
<p>numeric vector of length <code>ntest</code> representing the
responses for the test subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class).</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_s0">s0</code></td>
<td>
<p>chracter vector of the active feature names, i.e., the features in
<code>x_train</code> that are truly associated with the response.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_summary">summary</code></td>
<td>
<p>the summary of each cluster. Can be the principal component or
average. Default is <code>summary = "pc"</code> which takes the first
<code>number_pc</code> principal components. Currently a maximum of 2 principal
components can be chosen.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_model">model</code></td>
<td>
<p>Type of non-linear model to be fit. Currently only Friedman's
MARS is supported.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_exp_family">exp_family</code></td>
<td>
<p>Response type. See details for <code>y_train</code> argument
above.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_gene_groups">gene_groups</code></td>
<td>
<p>data.frame that contains the group membership for each
feature. The first column is called 'gene' and the second column should be
called 'cluster'. The 'gene' column identifies the features and must be the
same identifiers in the <code>x_train,x_test</code> matrices. The 'cluster'
column is a numeric integer indicating the cluster group membership.  A
cluster group membership of 0 implies the feature did not cluster into any
group.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_true_beta">true_beta</code></td>
<td>
<p>numeric vector of true beta coefficients</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_topgenes">topgenes</code></td>
<td>
<p>List of features to keep if <code>filter=TRUE</code>. Default is
<code>topgenes = NULL</code> which means all features are kept for the analysis</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_stability">stability</code></td>
<td>
<p>Should stability measures be calculated. Default is
<code>stability=FALSE</code>. See details</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_filter">filter</code></td>
<td>
<p>Should analysis be run on a subset of features. Default is
<code>filter = FALSE</code></p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_include_e">include_E</code></td>
<td>
<p>Should the environment variable be included in the
regression analysis. Default is <code>include_E = TRUE</code></p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should interaction effects between the features in
<code>x_train</code> and the environment variable be fit. Default is
<code>include_interaction=TRUE</code></p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_clust_type">clust_type</code></td>
<td>
<p>Method used to cluster the features. This is used for
naming the output only and has no consequence for the results.
<code>clust_type = "CLUST"</code> is the default which means that the environment
varible was not used in the clustering step. <code>clust_type = "ECLUST"</code>
means that the environment variable was used in the clustering aspect.</p>
</td></tr>
<tr><td><code id="s_mars_clust_+3A_npc">nPC</code></td>
<td>
<p>Number of principal components if <code>summary = "pc"</code>.
Default is <code>nPC = 1</code>. Can be either 1 or 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first does 10 fold cross-validation to tune the degree
(either 1 or 2) using the <code><a href="caret.html#topic+train">train</a></code> function with
<code>method="earth"</code> and nprune is fixed at 1000. Then the
<code><a href="earth.html#topic+earth">earth</a></code> function is used, with <code>nk = 1000</code> and
<code>pmethod = "backward"</code> to fit the MARS model using the optimal degree
from the 10-fold CV.
</p>


<h3>Value</h3>

<p>This function has two different outputs depending on whether
<code>stability = TRUE</code> or <code>stability = FALSE</code>
</p>
<p>If <code>stability = TRUE</code> then this function returns a <code>p x 2</code>
data.frame or data.table of regression coefficients without the intercept.
The output of this is used for subsequent calculations of stability.
</p>
<p>If <code>stability = FALSE</code> then returns a vector with the following
elements (See Table 3: Measures of Performance in Bhatnagar et al (2016+)
for definitions of each measure of performance): </p>
<table>
<tr><td><code>mse or AUC</code></td>
<td>
<p>Test set
mean squared error if <code>exp_family = "gaussion"</code> or test set Area under
the curve if <code>exp_family = "binomial"</code> calculated using the
<code><a href="pROC.html#topic+roc">roc</a></code> function</p>
</td></tr> <tr><td><code>RMSE</code></td>
<td>
<p>Square root of the mse. Only
applicable if <code>exp_family = "gaussion"</code></p>
</td></tr> <tr><td><code>Shat</code></td>
<td>
<p>Number of
non-zero estimated regression coefficients. The non-zero estimated
regression coefficients are referred to as being selected by the model</p>
</td></tr>
<tr><td><code>TPR</code></td>
<td>
<p>true positive rate</p>
</td></tr> <tr><td><code>FPR</code></td>
<td>
<p>false positive rate</p>
</td></tr>
<tr><td><code>Correct Sparsity</code></td>
<td>
<p>Correct true positives + correct true negative
coefficients divided by the total number of features</p>
</td></tr>
<tr><td><code>CorrectZeroMain</code></td>
<td>
<p>Proportion of correct true negative main effects</p>
</td></tr>
<tr><td><code>CorrectZeroInter</code></td>
<td>
<p>Proportion of correct true negative interactions</p>
</td></tr>
<tr><td><code>IncorrectZeroMain</code></td>
<td>
<p>Proportion of incorrect true negative main
effects</p>
</td></tr> <tr><td><code>IncorrectZeroInter</code></td>
<td>
<p>Proportion of incorrect true negative
interaction effects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta &lt;- c(betaMainEffect, betaE)

result &lt;- s_generate_data_mars(p = p, X = X,
                               beta = beta,
                               binary_outcome = FALSE,
                               truemodule = truemodule1,
                               nActive = nActive,
                               include_interaction = FALSE,
                               cluster_distance = cluster_distance,
                               n = n, n0 = n0,
                               eclust_distance = Ecluster_distance,
                               signal_to_noise_ratio = SNR,
                               distance_method = distanceMethod,
                               cluster_method = clustMethod,
                               cut_method = cutMethod,
                               agglomeration_method = agglomerationMethod,
                               nPC = 1)


mars_res &lt;- s_mars_clust(x_train = result[["X_train"]],
                         x_test = result[["X_test"]],
                         y_train = result[["Y_train"]],
                         y_test = result[["Y_test"]],
                         s0 = result[["S0"]],
                         summary = "pc",
                         exp_family = "gaussian",
                         gene_groups = result[["clustersAddon"]],
                         clust_type = "ECLUST")
unlist(mars_res)

## End(Not run)
</code></pre>

<hr>
<h2 id='s_mars_separate'>Fit Multivariate Adaptive Regression Splines on Simulated Data</h2><span id='topic+s_mars_separate'></span>

<h3>Description</h3>

<p>This function can run Friedman's MARS models on the
untransformed design matrix. To be used with simulated data where the
'truth' is known i.e., you know which features are associated with the
response. This function was used to produce the simulation results in
Bhatnagar et al. 2016. Uses caret functions to tune the degree and the
nprune parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_mars_separate(x_train, x_test, y_train, y_test, s0, model = c("MARS"),
  exp_family = c("gaussian", "binomial"), topgenes = NULL, stability = F,
  filter = F, include_E = T, include_interaction = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_mars_separate_+3A_x_train">x_train</code></td>
<td>
<p><code>ntrain x p</code> matrix of simulated training set where
<code>ntrain</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_x_test">x_test</code></td>
<td>
<p><code>ntest x p</code> matrix of simulated training set where
<code>ntest</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_y_train">y_train</code></td>
<td>
<p>numeric vector of length <code>ntrain</code> representing the
responses for the training subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class)</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_y_test">y_test</code></td>
<td>
<p>numeric vector of length <code>ntest</code> representing the
responses for the test subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class).</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_s0">s0</code></td>
<td>
<p>chracter vector of the active feature names, i.e., the features in
<code>x_train</code> that are truly associated with the response.</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_model">model</code></td>
<td>
<p>Type of non-linear model to be fit. Currently only Friedman's
MARS is supported.</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_exp_family">exp_family</code></td>
<td>
<p>Response type. See details for <code>y_train</code> argument
above.</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_topgenes">topgenes</code></td>
<td>
<p>List of features to keep if <code>filter=TRUE</code>. Default is
<code>topgenes = NULL</code> which means all features are kept for the analysis</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_stability">stability</code></td>
<td>
<p>Should stability measures be calculated. Default is
<code>stability=FALSE</code>. See details</p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_filter">filter</code></td>
<td>
<p>Should analysis be run on a subset of features. Default is
<code>filter = FALSE</code></p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_include_e">include_E</code></td>
<td>
<p>Should the environment variable be included in the
regression analysis. Default is <code>include_E = TRUE</code></p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should interaction effects between the features in
<code>x_train</code> and the environment variable be fit. Default is
<code>include_interaction=TRUE</code></p>
</td></tr>
<tr><td><code id="s_mars_separate_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="caret.html#topic+trainControl">trainControl</a></code>
function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first does 10 fold cross-validation to tune the degree
(either 1 or 2) using the <code><a href="caret.html#topic+train">train</a></code> function with
<code>method="earth"</code> and nprune is fixed at 1000. Then the
<code><a href="earth.html#topic+earth">earth</a></code> function is used, with <code>nk = 1000</code> and
<code>pmethod = "backward"</code> to fit the MARS model using the optimal degree
from the 10-fold CV.
</p>


<h3>Value</h3>

<p>This function has two different outputs depending on whether
<code>stability = TRUE</code> or <code>stability = FALSE</code>
</p>
<p>If <code>stability = TRUE</code> then this function returns a <code>p x 2</code>
data.frame or data.table of regression coefficients without the intercept.
The output of this is used for subsequent calculations of stability.
</p>
<p>If <code>stability = FALSE</code> then returns a vector with the following
elements (See Table 3: Measures of Performance in Bhatnagar et al (2016+)
for definitions of each measure of performance): </p>
<table>
<tr><td><code>mse or AUC</code></td>
<td>
<p>Test set
mean squared error if <code>exp_family = "gaussion"</code> or test set Area under
the curve if <code>exp_family = "binomial"</code> calculated using the
<code><a href="pROC.html#topic+roc">roc</a></code> function</p>
</td></tr> <tr><td><code>RMSE</code></td>
<td>
<p>Square root of the mse. Only
applicable if <code>exp_family = "gaussion"</code></p>
</td></tr> <tr><td><code>Shat</code></td>
<td>
<p>Number of
non-zero estimated regression coefficients. The non-zero estimated
regression coefficients are referred to as being selected by the model</p>
</td></tr>
<tr><td><code>TPR</code></td>
<td>
<p>true positive rate</p>
</td></tr> <tr><td><code>FPR</code></td>
<td>
<p>false positive rate</p>
</td></tr>
<tr><td><code>Correct Sparsity</code></td>
<td>
<p>Correct true positives + correct true negative
coefficients divided by the total number of features</p>
</td></tr>
<tr><td><code>CorrectZeroMain</code></td>
<td>
<p>Proportion of correct true negative main effects</p>
</td></tr>
<tr><td><code>CorrectZeroInter</code></td>
<td>
<p>Proportion of correct true negative interactions</p>
</td></tr>
<tr><td><code>IncorrectZeroMain</code></td>
<td>
<p>Proportion of incorrect true negative main
effects</p>
</td></tr> <tr><td><code>IncorrectZeroInter</code></td>
<td>
<p>Proportion of incorrect true negative
interaction effects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta &lt;- c(betaMainEffect, betaE)

result &lt;- s_generate_data_mars(p = p, X = X,
                               beta = beta,
                               binary_outcome = FALSE,
                               truemodule = truemodule1,
                               nActive = nActive,
                               include_interaction = FALSE,
                               cluster_distance = cluster_distance,
                               n = n, n0 = n0,
                               eclust_distance = Ecluster_distance,
                               signal_to_noise_ratio = SNR,
                               distance_method = distanceMethod,
                               cluster_method = clustMethod,
                               cut_method = cutMethod,
                               agglomeration_method = agglomerationMethod,
                               nPC = 1)


mars_res &lt;- s_mars_separate(x_train = result[["X_train"]],
                            x_test = result[["X_test"]],
                            y_train = result[["Y_train"]],
                            y_test = result[["Y_test"]],
                            s0 = result[["S0"]],
                            exp_family = "gaussian")
unlist(mars_res)

## End(Not run)
</code></pre>

<hr>
<h2 id='s_modules'>Simulate Covariates With Exposure Dependent Correlations</h2><span id='topic+s_modules'></span>

<h3>Description</h3>

<p>This is a wrapper of the <code><a href="WGCNA.html#topic+simulateDatExpr">simulateDatExpr</a></code>
function which simulates data in a modular structure (i.e. in blocks). This
function simulates data in 5 blocks referred to as Turquoise, Blue, Red,
Green and Yellow, separately for exposed (E=1) and unexposed (E=0)
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_modules(n, p, rho, exposed, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_modules_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="s_modules_+3A_p">p</code></td>
<td>
<p>total number of predictors to simulate</p>
</td></tr>
<tr><td><code id="s_modules_+3A_rho">rho</code></td>
<td>
<p>numeric value representing the expected correlation between green
module and red module</p>
</td></tr>
<tr><td><code id="s_modules_+3A_exposed">exposed</code></td>
<td>
<p>binary numeric vector of length <code>n</code> with 0 for unexposed
and 1 for exposed</p>
</td></tr>
<tr><td><code id="s_modules_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code><a href="WGCNA.html#topic+simulateDatExpr">simulateDatExpr</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>n x p</code> matrix of simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
p &lt;- 1000
n &lt;- 200
d0 &lt;- s_modules(n = 100, p = 1000, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = 100, p = 1000, rho = 0.90, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
 magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
 magrittr::set_rownames(paste0("Subject",1:n))
dim(X)
</code></pre>

<hr>
<h2 id='s_pen_clust'>Fit Penalized Regression Models on Simulated Cluster Summaries</h2><span id='topic+s_pen_clust'></span>

<h3>Description</h3>

<p>This function creates summaries of the given clusters (e.g. 1st
PC or average), and then fits a penalized regression model on those
summaries. To be used with simulated data where the 'truth' is known i.e.,
you know which features are associated with the response. This function was
used to produce the simulation results in Bhatnagar et al. 2016. Can run
lasso, elasticnet, SCAD or MCP models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_pen_clust(x_train, x_test, y_train, y_test, s0, gene_groups,
  summary = c("pc", "avg"), model = c("lasso", "elasticnet", "scad", "mcp"),
  exp_family = c("gaussian", "binomial"), filter = F, topgenes = NULL,
  stability = F, include_E = T, include_interaction = F,
  clust_type = c("CLUST", "ECLUST"), number_pc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_pen_clust_+3A_x_train">x_train</code></td>
<td>
<p><code>ntrain x p</code> matrix of simulated training set where
<code>ntrain</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_x_test">x_test</code></td>
<td>
<p><code>ntest x p</code> matrix of simulated training set where
<code>ntest</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_y_train">y_train</code></td>
<td>
<p>numeric vector of length <code>ntrain</code> representing the
responses for the training subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class)</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_y_test">y_test</code></td>
<td>
<p>numeric vector of length <code>ntest</code> representing the
responses for the test subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class).</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_s0">s0</code></td>
<td>
<p>chracter vector of the active feature names, i.e., the features in
<code>x_train</code> that are truly associated with the response.</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_gene_groups">gene_groups</code></td>
<td>
<p>data.frame that contains the group membership for each
feature. The first column is called 'gene' and the second column should be
called 'cluster'. The 'gene' column identifies the features and must be the
same identifiers in the <code>x_train,x_test</code> matrices. The 'cluster'
column is a numeric integer indicating the cluster group membership.  A
cluster group membership of 0 implies the feature did not cluster into any
group.</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_summary">summary</code></td>
<td>
<p>the summary of each cluster. Can be the principal component or
average. Default is <code>summary = "pc"</code> which takes the first
<code>number_pc</code> principal components. Currently a maximum of 2 principal
components can be chosen.</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_model">model</code></td>
<td>
<p>Regression model to be fit on cluster summaries. Default is
<code>model="lasso"</code> which corresponds to glmnet mixing parameter
<code>alpha=1</code>. <code>model="elasticnet"</code> corresponds to glmnet mixing
parameter <code>alpha=0.5</code>, <code>model="mcp"</code> and <code>model="scad"</code> are
the non-convex models from the <code><a href="ncvreg.html#topic+ncvreg">ncvreg</a></code> package</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_exp_family">exp_family</code></td>
<td>
<p>Response type. See details for <code>y_train</code> argument
above.</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_filter">filter</code></td>
<td>
<p>Should analysis be run on a subset of features. Default is
<code>filter = FALSE</code></p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_topgenes">topgenes</code></td>
<td>
<p>List of features to keep if <code>filter=TRUE</code>. Default is
<code>topgenes = NULL</code> which means all features are kept for the analysis</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_stability">stability</code></td>
<td>
<p>Should stability measures be calculated. Default is
<code>stability=FALSE</code>. See details</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_include_e">include_E</code></td>
<td>
<p>Should the environment variable be included in the
regression analysis. Default is <code>include_E = TRUE</code></p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should interaction effects between the features in
<code>x_train</code> and the environment variable be fit. Default is
<code>include_interaction=TRUE</code></p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_clust_type">clust_type</code></td>
<td>
<p>Method used to cluster the features. This is used for
naming the output only and has no consequence for the results.
<code>clust_type = "CLUST"</code> is the default which means that the environment
varible was not used in the clustering step. <code>clust_type = "ECLUST"</code>
means that the environment variable was used in the clustering aspect.</p>
</td></tr>
<tr><td><code id="s_pen_clust_+3A_number_pc">number_pc</code></td>
<td>
<p>Number of principal components if <code>summary = "pc"</code>.
Default is <code>number_pc = 1</code>. Can be either 1 or 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stability of feature importance is defined as the variability of
feature weights under perturbations of the training set, i.e., small
modifications in the training set should not lead to considerable changes
in the set of important covariates (Toloşi, L., &amp; Lengauer, T. (2011)). A
feature selection algorithm produces a weight, a ranking, and a subset of
features. In the CLUST and ECLUST methods, we defined a predictor to be
non-zero if its corresponding cluster representative weight was non-zero.
Using 10-fold cross validation (CV), we evaluated the similarity between
two features and their rankings using Pearson and Spearman correlation,
respectively. For each CV fold we re-ran the models and took the average
Pearson/Spearman correlation of the 10 choose 2 combinations of estimated
coefficients vectors. To measure the similarity between two subsets of
features we took the average of the Jaccard distance in each fold. A
Jaccard distance of 1 indicates perfect agreement between two sets while no
agreement will result in a distance of 0.
</p>


<h3>Value</h3>

<p>This function has two different outputs depending on whether
<code>stability = TRUE</code> or <code>stability = FALSE</code>
</p>
<p>If <code>stability = TRUE</code> then this function returns a <code>p x 2</code>
data.frame or data.table of regression coefficients without the intercept.
The output of this is used for subsequent calculations of stability.
</p>
<p>If <code>stability = FALSE</code> then returns a vector with the following
elements (See Table 3: Measures of Performance in Bhatnagar et al (2016+)
for definitions of each measure of performance): </p>
<table>
<tr><td><code>mse or AUC</code></td>
<td>
<p>Test set
mean squared error if <code>exp_family = "gaussion"</code> or test set Area under
the curve if <code>exp_family = "binomial"</code> calculated using the
<code><a href="pROC.html#topic+roc">roc</a></code> function</p>
</td></tr> <tr><td><code>RMSE</code></td>
<td>
<p>Square root of the mse. Only
applicable if <code>exp_family = "gaussion"</code></p>
</td></tr> <tr><td><code>Shat</code></td>
<td>
<p>Number of
non-zero estimated regression coefficients. The non-zero estimated
regression coefficients are referred to as being selected by the model</p>
</td></tr>
<tr><td><code>TPR</code></td>
<td>
<p>true positive rate</p>
</td></tr> <tr><td><code>FPR</code></td>
<td>
<p>false positive rate</p>
</td></tr>
<tr><td><code>Correct Sparsity</code></td>
<td>
<p>Correct true positives + correct true negative
coefficients divided by the total number of features</p>
</td></tr>
<tr><td><code>CorrectZeroMain</code></td>
<td>
<p>Proportion of correct true negative main effects</p>
</td></tr>
<tr><td><code>CorrectZeroInter</code></td>
<td>
<p>Proportion of correct true negative interactions</p>
</td></tr>
<tr><td><code>IncorrectZeroMain</code></td>
<td>
<p>Proportion of incorrect true negative main
effects</p>
</td></tr> <tr><td><code>IncorrectZeroInter</code></td>
<td>
<p>Proportion of incorrect true negative
interaction effects</p>
</td></tr> <tr><td><code>nclusters</code></td>
<td>
<p>number of estimated clusters by the
<code><a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a></code> function</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>number_pc=2</code> will not work if there is only one feature in an
estimated cluster
</p>


<h3>References</h3>

<p>Toloşi, L., &amp; Lengauer, T. (2011). <em>Classification with
correlated features: unreliability of feature ranking and solutions.
Bioinformatics, 27(14), 1986-1994.</em>
</p>
<p>Bhatnagar, SR., Yang, Y., Blanchette, M., Bouchard, L.,
Khundrakpam, B., Evans, A., Greenwood, CMT. (2016+). <em>An analytic
approach for interpretable predictive models in high dimensional data, in
the presence of interactions with exposures
<a href="http://sahirbhatnagar.com/slides/manuscript1_SB_v4.pdf">Preprint</a></em>
</p>
<p>Langfelder, P., Zhang, B., &amp; Horvath, S. (2008). <em>Defining
clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for
R. Bioinformatics, 24(5), 719-720.</em>
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008)
<em>Regularization Paths for Generalized Linear Models via Coordinate
Descent, <a href="http://www.stanford.edu/~hastie/Papers/glmnet.pdf">http://www.stanford.edu/~hastie/Papers/glmnet.pdf</a></em>
</p>
<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection. Ann. Appl. Statist., 5: 232-253.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)
betaMainInteractions &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
betaMainInteractions[which(betaMainEffect!=0)] &lt;- runif(nActive, alphaMean - 0.1, alphaMean + 0.1)
beta &lt;- c(betaMainEffect, betaE, betaMainInteractions)

result &lt;- s_generate_data(p = p, X = X,
                          beta = beta,
                          include_interaction = TRUE,
                          cluster_distance = cluster_distance,
                          n = n, n0 = n0,
                          eclust_distance = Ecluster_distance,
                          signal_to_noise_ratio = SNR,
                          distance_method = distanceMethod,
                          cluster_method = clustMethod,
                          cut_method = cutMethod,
                          agglomeration_method = agglomerationMethod,
                          nPC = 1)

pen_res &lt;- s_pen_clust(x_train = result[["X_train"]],
                       x_test = result[["X_test"]],
                       y_train = result[["Y_train"]],
                       y_test = result[["Y_test"]],
                       s0 = result[["S0"]],
                       gene_groups = result[["clustersAddon"]],
                       summary = "pc",
                       model = "lasso",
                       exp_family = "gaussian",
                       clust_type = "ECLUST",
                       include_interaction = TRUE)
unlist(pen_res)


</code></pre>

<hr>
<h2 id='s_pen_separate'>Fit Penalized Regression Models on Simulated Data</h2><span id='topic+s_pen_separate'></span>

<h3>Description</h3>

<p>This function can run penalized regression models on the
untransformed design matrix. To be used with simulated data where the
'truth' is known i.e., you know which features are associated with the
response. This function was used to produce the simulation results in
Bhatnagar et al. 2016. Can run lasso, elasticnet, SCAD or MCP models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_pen_separate(x_train, x_test, y_train, y_test, s0,
  exp_family = c("gaussian", "binomial"), model = c("lasso", "elasticnet",
  "scad", "mcp"), topgenes = NULL, stability = F, filter = F,
  include_E = T, include_interaction = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_pen_separate_+3A_x_train">x_train</code></td>
<td>
<p><code>ntrain x p</code> matrix of simulated training set where
<code>ntrain</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_x_test">x_test</code></td>
<td>
<p><code>ntest x p</code> matrix of simulated training set where
<code>ntest</code> is the number of training observations  and <code>p</code> is total
number of predictors. This matrix needs to have named columns representing
the feature names or the gene names</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_y_train">y_train</code></td>
<td>
<p>numeric vector of length <code>ntrain</code> representing the
responses for the training subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class)</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_y_test">y_test</code></td>
<td>
<p>numeric vector of length <code>ntest</code> representing the
responses for the test subjects. If continuous then you must set
<code>exp_family = "gaussion"</code>. For <code>exp_family="binomial"</code> should be
either a factor with two levels, or a two-column matrix of counts or
proportions (the second column is treated as the target class; for a
factor, the last level in alphabetical order is the target class).</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_s0">s0</code></td>
<td>
<p>chracter vector of the active feature names, i.e., the features in
<code>x_train</code> that are truly associated with the response.</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_exp_family">exp_family</code></td>
<td>
<p>Response type. See details for <code>y_train</code> argument
above.</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_model">model</code></td>
<td>
<p>Regression model to be fit on cluster summaries. Default is
<code>model="lasso"</code> which corresponds to glmnet mixing parameter
<code>alpha=1</code>. <code>model="elasticnet"</code> corresponds to glmnet mixing
parameter <code>alpha=0.5</code>, <code>model="mcp"</code> and <code>model="scad"</code> are
the non-convex models from the <code><a href="ncvreg.html#topic+ncvreg">ncvreg</a></code> package</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_topgenes">topgenes</code></td>
<td>
<p>List of features to keep if <code>filter=TRUE</code>. Default is
<code>topgenes = NULL</code> which means all features are kept for the analysis</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_stability">stability</code></td>
<td>
<p>Should stability measures be calculated. Default is
<code>stability=FALSE</code>. See details</p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_filter">filter</code></td>
<td>
<p>Should analysis be run on a subset of features. Default is
<code>filter = FALSE</code></p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_include_e">include_E</code></td>
<td>
<p>Should the environment variable be included in the
regression analysis. Default is <code>include_E = TRUE</code></p>
</td></tr>
<tr><td><code id="s_pen_separate_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Should interaction effects between the features in
<code>x_train</code> and the environment variable be fit. Default is
<code>include_interaction=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stability of feature importance is defined as the variability of
feature weights under perturbations of the training set, i.e., small
modifications in the training set should not lead to considerable changes
in the set of important covariates (Toloşi, L., &amp; Lengauer, T. (2011)). A
feature selection algorithm produces a weight, a ranking, and a subset of
features. In the CLUST and ECLUST methods, we defined a predictor to be
non-zero if its corresponding cluster representative weight was non-zero.
Using 10-fold cross validation (CV), we evaluated the similarity between
two features and their rankings using Pearson and Spearman correlation,
respectively. For each CV fold we re-ran the models and took the average
Pearson/Spearman correlation of the 10 choose 2 combinations of estimated
coefficients vectors. To measure the similarity between two subsets of
features we took the average of the Jaccard distance in each fold. A
Jaccard distance of 1 indicates perfect agreement between two sets while no
agreement will result in a distance of 0.
</p>


<h3>Value</h3>

<p>This function has two different outputs depending on whether
<code>stability = TRUE</code> or <code>stability = FALSE</code>
</p>
<p>If <code>stability = TRUE</code> then this function returns a <code>p x 2</code>
data.frame or data.table of regression coefficients without the intercept.
The output of this is used for subsequent calculations of stability.
</p>
<p>If <code>stability = FALSE</code> then returns a vector with the following
elements (See Table 3: Measures of Performance in Bhatnagar et al (2016+)
for definitions of each measure of performance): </p>
<table>
<tr><td><code>mse or AUC</code></td>
<td>
<p>Test set
mean squared error if <code>exp_family = "gaussion"</code> or test set Area under
the curve if <code>exp_family = "binomial"</code> calculated using the
<code><a href="pROC.html#topic+roc">roc</a></code> function</p>
</td></tr> <tr><td><code>RMSE</code></td>
<td>
<p>Square root of the mse. Only
applicable if <code>exp_family = "gaussion"</code></p>
</td></tr> <tr><td><code>Shat</code></td>
<td>
<p>Number of
non-zero estimated regression coefficients. The non-zero estimated
regression coefficients are referred to as being selected by the model</p>
</td></tr>
<tr><td><code>TPR</code></td>
<td>
<p>true positive rate</p>
</td></tr> <tr><td><code>FPR</code></td>
<td>
<p>false positive rate</p>
</td></tr>
<tr><td><code>Correct Sparsity</code></td>
<td>
<p>Correct true positives + correct true negative
coefficients divided by the total number of features</p>
</td></tr>
<tr><td><code>CorrectZeroMain</code></td>
<td>
<p>Proportion of correct true negative main effects</p>
</td></tr>
<tr><td><code>CorrectZeroInter</code></td>
<td>
<p>Proportion of correct true negative interactions</p>
</td></tr>
<tr><td><code>IncorrectZeroMain</code></td>
<td>
<p>Proportion of incorrect true negative main
effects</p>
</td></tr> <tr><td><code>IncorrectZeroInter</code></td>
<td>
<p>Proportion of incorrect true negative
interaction effects</p>
</td></tr>
</table>


<h3>References</h3>

<p>Toloşi, L., &amp; Lengauer, T. (2011). <em>Classification with
correlated features: unreliability of feature ranking and solutions.
Bioinformatics, 27(14), 1986-1994.</em>
</p>
<p>Bhatnagar, SR., Yang, Y., Blanchette, M., Bouchard, L.,
Khundrakpam, B., Evans, A., Greenwood, CMT. (2016+). <em>An analytic
approach for interpretable predictive models in high dimensional data, in
the presence of interactions with exposures
<a href="http://sahirbhatnagar.com/slides/manuscript1_SB_v4.pdf">Preprint</a></em>
</p>
<p>Langfelder, P., Zhang, B., &amp; Horvath, S. (2008). <em>Defining
clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for
R. Bioinformatics, 24(5), 719-720.</em>
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008)
<em>Regularization Paths for Generalized Linear Models via Coordinate
Descent, <a href="http://www.stanford.edu/~hastie/Papers/glmnet.pdf">http://www.stanford.edu/~hastie/Papers/glmnet.pdf</a></em>
</p>
<p>Breheny, P. and Huang, J. (2011) <em>Coordinate descent
algorithms for nonconvex penalized regression, with applications to
biological feature selection. Ann. Appl. Statist., 5: 232-253.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)
betaMainInteractions &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
betaMainInteractions[which(betaMainEffect!=0)] &lt;- runif(nActive, alphaMean - 0.1, alphaMean + 0.1)
beta &lt;- c(betaMainEffect, betaE, betaMainInteractions)

result &lt;- s_generate_data(p = p, X = X,
                          beta = beta,
                          include_interaction = TRUE,
                          cluster_distance = cluster_distance,
                          n = n, n0 = n0,
                          eclust_distance = Ecluster_distance,
                          signal_to_noise_ratio = SNR,
                          distance_method = distanceMethod,
                          cluster_method = clustMethod,
                          cut_method = cutMethod,
                          agglomeration_method = agglomerationMethod,
                          nPC = 1)

pen_res &lt;- s_pen_separate(x_train = result[["X_train"]],
                          x_test = result[["X_test"]],
                          y_train = result[["Y_train"]],
                          y_test = result[["Y_test"]],
                          s0 = result[["S0"]],
                          model = "lasso",
                          exp_family = "gaussian",
                          include_interaction = TRUE)
unlist(pen_res)

## End(Not run)
</code></pre>

<hr>
<h2 id='s_response'>Generate True Response vector for Linear Simulation</h2><span id='topic+s_response'></span>

<h3>Description</h3>

<p>Given the true beta vector, covariates and environment variable this function
generates the linear response with specified signal to noise ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_response(n, n0, p, genes, binary_outcome = FALSE, E,
  signal_to_noise_ratio = 1, include_interaction = FALSE, beta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_response_+3A_n">n</code></td>
<td>
<p>Total number of subjects</p>
</td></tr>
<tr><td><code id="s_response_+3A_n0">n0</code></td>
<td>
<p>Total number of unexposed subjects</p>
</td></tr>
<tr><td><code id="s_response_+3A_p">p</code></td>
<td>
<p>Total number of genes (or covariates)</p>
</td></tr>
<tr><td><code id="s_response_+3A_genes">genes</code></td>
<td>
<p>nxp matrix of the genes or covariates</p>
</td></tr>
<tr><td><code id="s_response_+3A_binary_outcome">binary_outcome</code></td>
<td>
<p>Logical. Should a binary outcome be generated. Default
is <code>FALSE</code>. See details on how a binary outcome is generated</p>
</td></tr>
<tr><td><code id="s_response_+3A_e">E</code></td>
<td>
<p>binary 0,1, vector of the exposure/environment variable</p>
</td></tr>
<tr><td><code id="s_response_+3A_signal_to_noise_ratio">signal_to_noise_ratio</code></td>
<td>
<p>a numeric variable for the signal to noise ratio</p>
</td></tr>
<tr><td><code id="s_response_+3A_include_interaction">include_interaction</code></td>
<td>
<p>Logical. Should the response include the
interaction between E and the genes (for the non-zero <code>beta</code>
coefficient vector)</p>
</td></tr>
<tr><td><code id="s_response_+3A_beta">beta</code></td>
<td>
<p>true beta coefficient vector. Assumes this vector is in the same
order as the <code>genes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame/data.table containing the response and the design
matrix. Also an object of class <code>expression</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta &lt;- c(betaMainEffect, betaE)

result &lt;- s_response(n = n, n0 = n0,
                     p = p, genes = X, binary_outcome = FALSE,
                     E = c(rep(0,n0), rep(1, n1)), signal_to_noise_ratio = 1,
                     include_interaction = FALSE,
                     beta = beta)
result[1:5,1:5]

</code></pre>

<hr>
<h2 id='s_response_mars'>Generate True Response vector for Non-Linear Simulation</h2><span id='topic+s_response_mars'></span>

<h3>Description</h3>

<p>Given the covariates and environment variable this function
generates the nonlinear response with specified signal to noise ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_response_mars(n, n0, p, genes, beta, binary_outcome = FALSE, E,
  signal_to_noise_ratio = 1, truemodule, nActive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_response_mars_+3A_n">n</code></td>
<td>
<p>total number of subjects</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_n0">n0</code></td>
<td>
<p>total number of subjects with E=0</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_p">p</code></td>
<td>
<p>number of genes in design matrix</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_genes">genes</code></td>
<td>
<p>nxp matrix of the genes or covariates</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_beta">beta</code></td>
<td>
<p>true beta coefficient vector</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_binary_outcome">binary_outcome</code></td>
<td>
<p>Logical. Should a binary outcome be generated. Default
is <code>FALSE</code>. See details on how a binary outcome is generated</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_e">E</code></td>
<td>
<p>binary 0,1, vector of the exposure/environment variable</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_signal_to_noise_ratio">signal_to_noise_ratio</code></td>
<td>
<p>signal to noise ratio, default is 1</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_truemodule">truemodule</code></td>
<td>
<p>numeric vector of the true module membership used in the
<code>s_response_mars</code> function. Modules 3 and 4 are active in the
response. See <code>s_response_mars</code> function for details.</p>
</td></tr>
<tr><td><code id="s_response_mars_+3A_nactive">nActive</code></td>
<td>
<p>number of active genes in the response used in the
<code>s_response_mars</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame/data.table containing the response and the design
matrix. Also an object of class <code>expression</code>
</p>


<h3>Note</h3>

<p>See Bhatnagar et al (2017+) for details on how the response is simulated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# simulation parameters
rho = 0.90; p = 500 ;SNR = 1 ; n = 200; n0 = n1 = 100 ; nActive = p*0.10 ; cluster_distance = "tom";
Ecluster_distance = "difftom"; rhoOther = 0.6; betaMean = 2;
alphaMean = 1; betaE = 3; distanceMethod = "euclidean"; clustMethod = "hclust";
cutMethod = "dynamic"; agglomerationMethod = "average"

#in this simulation its blocks 3 and 4 that are important
#leaveOut:  optional specification of modules that should be left out
#of the simulation, that is their genes will be simulated as unrelated
#("grey"). This can be useful when simulating several sets, in some which a module
#is present while in others it is absent.
d0 &lt;- s_modules(n = n0, p = p, rho = 0, exposed = FALSE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.01,
                maxCor = 1,
                corPower = 1,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE,
                leaveOut = 1:4)

d1 &lt;- s_modules(n = n1, p = p, rho = rho, exposed = TRUE,
                modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                minCor = 0.4,
                maxCor = 1,
                corPower = 0.3,
                propNegativeCor = 0.3,
                backgroundNoise = 0.5,
                signed = FALSE)

truemodule1 &lt;- d1$setLabels

X &lt;- rbind(d0$datExpr, d1$datExpr) %&gt;%
  magrittr::set_colnames(paste0("Gene", 1:p)) %&gt;%
  magrittr::set_rownames(paste0("Subject",1:n))

betaMainEffect &lt;- vector("double", length = p)

# the first nActive/2 in the 3rd block are active
betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean - 0.1, betaMean + 0.1)

# the first nActive/2 in the 4th block are active
betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] &lt;- runif(
  nActive/2, betaMean+2 - 0.1, betaMean+2 + 0.1)
beta &lt;- c(betaMainEffect, betaE)

result &lt;- s_response_mars(n = n, n0 = n0,
                          p = p, genes = X, binary_outcome = TRUE,
                          E = c(rep(0,n0), rep(1, n1)), signal_to_noise_ratio = 1,
                          truemodule = truemodule1, nActive = nActive,
                          beta = beta)
result[1:5,1:5]
</code></pre>

<hr>
<h2 id='simdata'>Simulated Data with Environment Dependent Correlations</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>A dataset containing simulated data for example use of the <code>eclust</code>
package functions. This data was generated using the <code><a href="#topic+s_modules">s_modules</a></code>
and <code><a href="#topic+s_generate_data">s_generate_data</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 502 variables: </p>

<dl>
<dt>Y</dt><dd><p>continuous response vector</p>
</dd> <dt>E</dt><dd><p>binary environment variable
for ECLUST method. E = 0 for unexposed (n=50) and E = 1 for exposed (n=50)</p>
</dd> <dt>columns
3:502</dt><dd><p>gene expression data for 1000 genes. column names are the gene
names </p>
</dd> </dl>


<h3>Note</h3>

<p>Code used to generate this data can be found on the GitHub page for
this package. See URL below.
</p>


<h3>Source</h3>

<p><a href="https://raw.githubusercontent.com/sahirbhatnagar/eclust/master/data-raw/simulated-data-processing.R">https://raw.githubusercontent.com/sahirbhatnagar/eclust/master/data-raw/simulated-data-processing.R</a>
</p>


<h3>References</h3>

<p>Bhatnagar, SR., Yang, Y., Blanchette, M., Bouchard, L.,
Khundrakpam, B., Evans, A., Greenwood, CMT. (2016+). <em>An analytic
approach for interpretable predictive models in high dimensional data, in
the presence of interactions with exposures
<a href="http://sahirbhatnagar.com/slides/manuscript1_SB_v4.pdf">Preprint</a></em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simdata[1:5, 1:10]
table(simdata[,"E"])
</code></pre>

<hr>
<h2 id='tcgaov'>Subset of TCGA mRNA Ovarian serous cystadenocarcinoma data</h2><span id='topic+tcgaov'></span>

<h3>Description</h3>

<p>A dataset containing a subset of the TCGA mRNA Ovarian serous
cystadenocarcinoma data generated using Affymetrix HTHGU133a arrays.
Differences in gene expression profiles have led to the identification of
robust molecular subtypes of ovarian cancer; these are of biological and
clinical importance because they have been shown to correlate with overall
survival (Tothill et al., 2008). Improving prediction of survival time based
on gene expression signatures can lead to targeted therapeutic interventions
(Helland et al., 2011). The proposed ECLUST algorithm was applied to gene
expression data from 511 ovarian cancer patients profiled by the Affymetrix
Human Genome U133A 2.0 Array. The data were obtained from the TCGA Research
Network: http://cancergenome.nih.gov/ and downloaded via the TCGA2STAT R
library (Wanet al., 2015). Using the 881 signature genes from Helland et al.
(2011) we grouped subjects into two groups based on the results in this
paper, to create a “positive control” environmental variable expected to have
a strong effect. Specifically, we defined an environment variable in our
framework as: E = 0 for subtypes C1 and C2 (n = 253), and E = 1 for subtypes
C4 and C5 (n = 258).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcgaov
</code></pre>


<h3>Format</h3>

<p>A data.table and data.frame with 511 rows and 886 variables:
</p>
 <dl>
<dt>rn</dt><dd><p>unique patient identifier (<code>character</code>)</p>
</dd>
<dt>subtype</dt><dd><p>cancer subtype (1,2,3 or 4) as per Helland et al. 2011
(<code>integer</code>)</p>
</dd> <dt>E</dt><dd><p>binary environment variable for ECLUST method. E
= 0 for subtypes 1 and 2 (n = 253), and E = 1 for subtypes 4 and 5 (n =
258) (<code>numeric</code>)</p>
</dd> <dt>status</dt><dd><p>vital status, 0 = alive, 1 = dead
(<code>numeric</code>)</p>
</dd> <dt>OS</dt><dd><p>overall survival time (<code>numeric</code>)</p>
</dd>
<dt>columns 6:886</dt><dd><p>gene expression data for 881 genes. column names are
the gene names (<code>numeric</code>)</p>
</dd> </dl>


<h3>Source</h3>

<p><a href="http://www.liuzlab.org/TCGA2STAT/#import-gene-expression">http://www.liuzlab.org/TCGA2STAT/#import-gene-expression</a>
</p>
<p><a href="http://gdac.broadinstitute.org/">http://gdac.broadinstitute.org/</a>
</p>
<p><a href="http://journals.plos.org/plosone/article/asset?unique&amp;id=info:doi/10.1371/journal.pone.0018064.s015">http://journals.plos.org/plosone/article/asset?unique&amp;id=info:doi/10.1371/journal.pone.0018064.s015</a>
</p>


<h3>References</h3>

<p>Richard W Tothill, Anna V Tinker, Joshy George, Robert Brown,
Stephen B Fox, Stephen Lade, Daryl S Johnson, Melanie K Trivett, Dariush
Etemadmoghadam, Bianca Locandro, et al. Novel molecular subtypes of serous
and endometrioid ovarian cancer linked to clinical outcome. Clinical Cancer
Research, 14(16):5198–5208, 2008.
</p>
<p>Aslaug Helland, Michael S Anglesio, Joshy George, Prue A Cowin,
Cameron N Johnstone, Colin M House, Karen E Sheppard, Dariush
Etemadmoghadam, Nataliya Melnyk, Anil K Rustgi, et al. Deregulation of
mycn, lin28b and let7 in a molecular subtype of aggressive high-grade
serous ovarian cancers. PloS one, 6(4):e18064, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using data.table syntax from the data.table package
tcgaov[1:5, 1:10, with = FALSE]
tcgaov[,table(subtype, E, useNA = "always")]
</code></pre>

<hr>
<h2 id='u_cluster_similarity'>Cluster similarity matrix</h2><span id='topic+u_cluster_similarity'></span>

<h3>Description</h3>

<p>Return cluster membership of each predictor. This function is
called internally by the <code><a href="#topic+s_generate_data">s_generate_data</a></code> and
<code><a href="#topic+s_generate_data_mars">s_generate_data_mars</a></code> functions. Is also used by the
<code>r_clust</code> function for real data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u_cluster_similarity(x, expr, exprTest, distanceMethod,
  clustMethod = c("hclust", "protoclust"), cutMethod = c("dynamic", "gap",
  "fixed"), nClusters, method = c("complete", "average", "ward.D2", "single",
  "ward.D", "mcquitty", "median", "centroid"), K.max = 10, B = 50, nPC,
  minimum_cluster_size = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u_cluster_similarity_+3A_x">x</code></td>
<td>
<p>similarity matrix. must have non-NULL dimnames i.e., the rows and
columns should be labelled, e.g. &quot;Gene1, Gene2, ...&quot;</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_expr">expr</code></td>
<td>
<p>gene expression data (training set). rows are people, columns are
genes</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_exprtest">exprTest</code></td>
<td>
<p>gene expression test set. If using real data, and you dont
have enough samples for a test set then just supply the same data supplied
to the <code>expr</code> argument</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_distancemethod">distanceMethod</code></td>
<td>
<p>one of &quot;euclidean&quot;,&quot;maximum&quot;,&quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot;,&quot;minkowski&quot; to be passed to <code><a href="stats.html#topic+dist">dist</a></code> function. If
missing, then this function will take 1-x as the dissimilarity measure.
This functionality is for diffCorr,diffTOM, fisherScore matrices which need
to be converted to a distance type matrix.</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_clustmethod">clustMethod</code></td>
<td>
<p>Cluster the data using hierarchical clustering or
prototype clustering. Defaults <code>clustMethod="hclust"</code>. Other option is
<code><a href="protoclust.html#topic+protoclust">protoclust</a></code>, however this package must be
installed before proceeding with this option</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_cutmethod">cutMethod</code></td>
<td>
<p>what method to use to cut the dendrogram. <code>'dynamic'</code>
refers to <code><a href="dynamicTreeCut.html#topic+cutreeDynamicTree">cutreeDynamicTree</a></code> library.
<code>'gap'</code> is Tibshirani's gap statistic <code><a href="cluster.html#topic+clusGap">clusGap</a></code>
using the <code>'Tibs2001SEmax'</code> rule. <code>'fixed'</code> is a fixed number
specified by the <code>nClusters</code> argument</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_nclusters">nClusters</code></td>
<td>
<p>number of clusters. Only used if <code>cutMethod = fixed</code></p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;,
&quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC)
or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_k.max">K.max</code></td>
<td>
<p>the maximum number of clusters to consider, must be at least
two. Only used if <code>cutMethod='gap'</code></p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_b">B</code></td>
<td>
<p>integer, number of Monte Carlo (“bootstrap”) samples. Only used if
<code>cutMethod='gap'</code></p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_npc">nPC</code></td>
<td>
<p>number of principal components. Can be 1 or 2.</p>
</td></tr>
<tr><td><code id="u_cluster_similarity_+3A_minimum_cluster_size">minimum_cluster_size</code></td>
<td>
<p>The minimum cluster size. Only applicable if
<code>cutMethod='dynamic'</code>. This argument is passed to the
<code><a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a></code> function. Default is 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length 2: </p>
<dl>
<dt>clusters</dt><dd><p>a p x 3 data.frame or
data.table which give the cluster membership of each gene, where p is the
number of genes. The first column is the gene name, the second column is
the cluster number (numeric) and the third column is the cluster membership
as a character vector of color names (these will match up exactly with the
cluster number)</p>
</dd><dt>pcInfo</dt><dd><p>a list of length
9:</p>
<dl>
<dt>eigengenes</dt><dd><p>a list of the eigengenes i.e. the 1st (and
2nd if nPC=2) principal component of each module</p>
</dd><dt>averageExpr</dt><dd><p>a
data.frame of the average expression for each module for the training
set</p>
</dd><dt>averageExprTest</dt><dd><p>a data.frame of the average expression for each
module for the test set</p>
</dd><dt>varExplained</dt><dd><p>percentage of variance
explained by each 1st (and 2nd if nPC=2) principal component of each
module</p>
</dd><dt>validColors</dt><dd><p>cluster membership of each gene</p>
</dd><dt>PC</dt><dd><p>a
data.frame of the 1st (and 2nd if nPC=2) PC for each module for the
training set</p>
</dd><dt>PCTest</dt><dd><p>a data.frame of the 1st (and 2nd if nPC=2) PC
for each module for the test set</p>
</dd><dt>prcompObj</dt><dd><p>the <code>prcomp</code>
object</p>
</dd><dt>nclusters</dt><dd><p>a numeric value for the total number of
clusters</p>
</dd></dl>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("simdata")
X = simdata[,c(-1,-2)]
train_index &lt;- sample(1:nrow(simdata),100)

cluster_results &lt;- u_cluster_similarity(x = cor(X),
                                        expr = X[train_index,],
                                        exprTest = X[-train_index,],
                                        distanceMethod = "euclidean",
                                        clustMethod = "hclust",
                                        cutMethod = "dynamic",
                                        method = "average", nPC = 2,
                                        minimum_cluster_size = 75)

cluster_results$clusters[, table(module)]
names(cluster_results$pcInfo)
cluster_results$pcInfo$nclusters
</code></pre>

<hr>
<h2 id='u_extract_selected_earth'>Get selected terms from an earth object</h2><span id='topic+u_extract_selected_earth'></span>

<h3>Description</h3>

<p>function to extract the selected terms from an earth object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u_extract_selected_earth(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u_extract_selected_earth_+3A_obj">obj</code></td>
<td>
<p>object of class <code>earth</code> returned by the
<code><a href="earth.html#topic+earth">earth</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>called internally by the <code><a href="#topic+s_mars_separate">s_mars_separate</a></code> and
<code><a href="#topic+s_mars_clust">s_mars_clust</a></code> functions
</p>


<h3>Value</h3>

<p>character vector of selected terms from the MARS model
</p>

<hr>
<h2 id='u_extract_summary'>Calculates cluster summaries</h2><span id='topic+u_extract_summary'></span>

<h3>Description</h3>

<p>This is a modified version of
<code><a href="WGCNA.html#topic+moduleEigengenes">moduleEigengenes</a></code>. It can extract (1st and 2nd
principal component) of modules in a given single dataset. It can also
return the average, the variance explained This function is more flexible
and the nPC argument is used. currently only nPC = 1 and nPC = 2 are
supported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u_extract_summary(x_train, colors, x_test, y_train, y_test, impute = TRUE,
  nPC, excludeGrey = FALSE, grey = if (is.numeric(colors)) 0 else "grey",
  subHubs = TRUE, trapErrors = FALSE, returnValidOnly = trapErrors,
  softPower = 6, scale = TRUE, verbose = 0, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u_extract_summary_+3A_x_train">x_train</code></td>
<td>
<p>Training data for a single set in the form of a data frame
where rows are samples and columns are genes (probes, cpgs, covariates).</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_colors">colors</code></td>
<td>
<p>A vector of the same length as the number of probes in expr,
giving module color for all probes (genes). Color &quot;grey&quot; is reserved for
unassigned genes.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_x_test">x_test</code></td>
<td>
<p>Test set in the form of a data frame where rows are samples and
columns are genes (probes, cpgs, covariates).</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_y_train">y_train</code></td>
<td>
<p>Training response numeric vector</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_y_test">y_test</code></td>
<td>
<p>Test response numeric vector</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_impute">impute</code></td>
<td>
<p>If TRUE, expression data will be checked for the presence of NA
entries and if the latter are present, numerical data will be imputed,
using function impute.knn and probes from the same module as the missing
datum. The function impute.knn uses a fixed random seed giving repeatable
results.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_npc">nPC</code></td>
<td>
<p>Number of principal components and variance explained entries to
be calculated. Note that only 1 or 2 is possible.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_excludegrey">excludeGrey</code></td>
<td>
<p>Should the improper module consisting of 'grey' genes be
excluded from the eigengenes?</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_grey">grey</code></td>
<td>
<p>Value of colors designating the improper module. Note that if
colors is a factor of numbers, the default value will be incorrect.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_subhubs">subHubs</code></td>
<td>
<p>Controls whether hub genes should be substituted for missing
eigengenes. If TRUE, each missing eigengene (i.e., eigengene whose
calculation failed and the error was trapped) will be replaced by a
weighted average of the most connected hub genes in the corresponding
module. If this calculation fails, or if subHubs==FALSE, the value of
trapErrors will determine whether the offending module will be removed or
whether the function will issue an error and stop.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_traperrors">trapErrors</code></td>
<td>
<p>Controls handling of errors from that may arise when there
are too many NA entries in expression data. If TRUE, errors from calling
these functions will be trapped without abnormal exit. If FALSE, errors
will cause the function to stop. Note, however, that subHubs takes
precedence in the sense that if subHubs==TRUE and trapErrors==FALSE, an
error will be issued only if both the principal component and the hubgene
calculations have failed.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_returnvalidonly">returnValidOnly</code></td>
<td>
<p>logical; controls whether the returned data frame of
module eigengenes contains columns corresponding only to modules whose
eigengenes or hub genes could be calculated correctly (TRUE), or whether
the data frame should have columns for each of the input color labels
(FALSE).</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_softpower">softPower</code></td>
<td>
<p>The power used in soft-thresholding the adjacency matrix.
Only used when the hubgene approximation is necessary because the principal
component calculation failed. It must be non-negative. The default value
should only be changed if there is a clear indication that it leads to
incorrect results.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_scale">scale</code></td>
<td>
<p>logical; can be used to turn off scaling of the expression data
before calculating the singular value decomposition. The scaling should
only be turned off if the data has been scaled previously, in which case
the function can run a bit faster. Note however that the function first
imputes, then scales the expression data in each module. If the expression
contain missing data, scaling outside of the function and letting the
function impute missing data may lead to slightly different results than if
the data is scaled within the function.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity of printed progress messages. 0 means
silent, up to (about) 5 the verbosity gradually increases.</p>
</td></tr>
<tr><td><code id="u_extract_summary_+3A_indent">indent</code></td>
<td>
<p>A single non-negative integer controlling indentation of
printed messages. 0 means no indentation, each unit above that adds two
spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called internally by the
<code><a href="#topic+u_cluster_similarity">u_cluster_similarity</a></code> function
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<dl>
<dt>eigengenes</dt><dd><p>Module eigengenes in a dataframe, with each
column corresponding to one eigengene</p>
</dd><dt>averageExpr</dt><dd><p>the average
expression per module in the training set</p>
</dd><dt>averageExprTest</dt><dd><p>the
average expression per module in the training set</p>
</dd><dt>varExplained</dt><dd><p>The
variance explained by the first PC in each module</p>
</dd><dt>validColors</dt><dd><p>A copy
of the input colors with entries corresponding to invalid modules set to
grey if given, otherwise 0 if colors is numeric and &quot;grey&quot;
otherwise.</p>
</dd><dt>PC</dt><dd><p>The 1st or 1st and 2nd PC from each module in the
training set</p>
</dd><dt>PCTest</dt><dd><p>The 1st or 1st and 2nd PC from each module in
the test set</p>
</dd><dt>prcompObj</dt><dd><p>The <code>prcomp</code> object returned by
<code><a href="stats.html#topic+prcomp">prcomp</a></code></p>
</dd><dt>nclusters</dt><dd><p>the number of modules
(clusters)</p>
</dd></dl>



<h3>References</h3>

<p>Zhang, B. and Horvath, S. (2005), &quot;A General Framework for
Weighted Gene Co-Expression Network Analysis&quot;, Statistical Applications in
Genetics and Molecular Biology: Vol. 4: No. 1, Article 17
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#see u_cluster_similarity for examples

## End(Not run)
</code></pre>

<hr>
<h2 id='u_fisherZ'>Calculate Fisher's Z Transformation for Correlations</h2><span id='topic+fisherTransform'></span><span id='topic+u_fisherZ'></span>

<h3>Description</h3>

<p>Calculate Fisher's Z transformation for correlations. This can
be used as an alternative measure of similarity. Used in the
<code>s_generate_data</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u_fisherZ(n0, cor0, n1, cor1)

fisherTransform(n_1, r1, n_2, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u_fisherZ_+3A_n0">n0</code></td>
<td>
<p>number of unexposed subjects</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_cor0">cor0</code></td>
<td>
<p>correlation matrix of unexposed covariate values. Should be
dimension pxp</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_n1">n1</code></td>
<td>
<p>number of exposed subjects</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_cor1">cor1</code></td>
<td>
<p>correlation matrix of exposed covariate values. Should be
dimension pxp</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_n_1">n_1</code></td>
<td>
<p>number of unexposed subjects</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_r1">r1</code></td>
<td>
<p>correlation for unexposed</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_n_2">n_2</code></td>
<td>
<p>number of exposed subjects</p>
</td></tr>
<tr><td><code id="u_fisherZ_+3A_r2">r2</code></td>
<td>
<p>correlation for exposed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pxp matrix of Fisher's Z transformation of correlations
</p>


<h3>Note</h3>

<p><code>fisherTransform</code> is called internally by <code>u_fisherZ</code> function
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Fisher_transformation">https://en.wikipedia.org/wiki/Fisher_transformation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simdata")

X = simdata[,c(-1,-2)]
fisherScore &lt;- u_fisherZ(n0 = 100, cor0 = cor(X[1:50,]),
                         n1 = 100, cor1 = cor(X[51:100,]))

dim(fisherScore)

fisherScore[1:5,1:5]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
