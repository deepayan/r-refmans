<!DOCTYPE html><html><head><title>Help for package astrochron</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {astrochron}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anchorTime'><p>Anchor a floating astrochronology to a radioisotopic age</p></a></li>
<li><a href='#ar1'><p>Generate AR(1) surrogates</p></a></li>
<li><a href='#ar1etp'><p>AR(1) + ETP simulation routine</p></a></li>
<li><a href='#arcsinT'><p>Arcsine transformation of stratigraphic series</p></a></li>
<li><a href='#armaGen'><p>Generate autoregressive moving-average model</p></a></li>
<li><a href='#asm'><p>Average Spectral Misfit</p></a></li>
<li><a href='#astrochron-package'><p>astrochron: A Computational Tool for Astrochronology</p></a></li>
<li><a href='#autoPlot'><p>Automatically plot multiple stratigraphic series, with smoothing if desired</p></a></li>
<li><a href='#bandpass'><p>Bandpass filter stratigraphic series</p></a></li>
<li><a href='#bergerPeriods'><p>Obliquity and precession periods of Berger et al. (1992)</p></a></li>
<li><a href='#bicoherence'><p>bicoherence: Calculate bispectrum and bicoherence using WOSA method as detailed in Choudhury et al. (2008).</p></a></li>
<li><a href='#bioturb'><p>Bioturbate time series using diffusion model from Guinasso and Schinck (1975), as in Liu et al. (2021)</p></a></li>
<li><a href='#calcPeriods'><p>Calculate eccentricity, obliquity and precession periods in ka, given g, s and k in arcsec/yr</p></a></li>
<li><a href='#cb'><p>Combine multiple vectors</p></a></li>
<li><a href='#clipIt'><p>Create non-linear response by clipping stratigraphic series</p></a></li>
<li><a href='#confAdjust'><p>Adjust spectrum confidence levels for multiple comparisons</p></a></li>
<li><a href='#constantSedrate'><p>Apply a constant sedimentation rate model to transform a spatial series to temporal series</p></a></li>
<li><a href='#conv_fft'><p>Convolution through Fast Fourier Transform</p></a></li>
<li><a href='#cosTaper'><p>Apply cosine taper to stratigraphic series</p></a></li>
<li><a href='#cycles'><p>Generate harmonic model</p></a></li>
<li><a href='#deconv'><p>Wiener Deconvolution through Fast Fourier Transform</p></a></li>
<li><a href='#delPts'><p>Interactively delete points in plot</p></a></li>
<li><a href='#demean'><p>Remove mean value from stratigraphic series</p></a></li>
<li><a href='#detrend'><p>Subtract linear trend from stratigraphic series</p></a></li>
<li><a href='#diffAccum'><p>Model differential accumulation</p></a></li>
<li><a href='#divTrend'><p>Divide by linear trend in stratigraphic series</p></a></li>
<li><a href='#dpssTaper'><p>Apply DPSS taper to stratigraphic series</p></a></li>
<li><a href='#eAsm'><p>Evolutive Average Spectral Misfit</p></a></li>
<li><a href='#eAsmTrack'><p>Track ASM null hypothesis significance level minima in eASM results</p></a></li>
<li><a href='#eha'><p>Evolutive Harmonic Analysis &amp; Evolutive Power Spectral Analysis</p></a></li>
<li><a href='#eTimeOpt'><p>eTimeOpt: Evolutive implementation of TimeOpt (Meyers, 2015; Meyers, 2019)</p></a></li>
<li><a href='#eTimeOptTrack'><p>Track eTimeOpt r2 maxima</p></a></li>
<li><a href='#etp'><p>Generate eccentricity-tilt-precession models</p></a></li>
<li><a href='#extract'><p>Extract record from EHA time-frequency output or eAsm output</p></a></li>
<li><a href='#flip'><p>Flip stratigraphic series</p></a></li>
<li><a href='#freq2sedrate'><p>Convert record of local spatial frequency (from EHA) to sedimentation rate curve</p></a></li>
<li><a href='#gausTaper'><p>Apply Gaussian taper to stratigraphic series</p></a></li>
<li><a href='#getColor'><p>Query R for color information</p></a></li>
<li><a href='#getData'><p>Download file from astrochron data server</p></a></li>
<li><a href='#getLaskar'><p>Download Laskar et al. (2004, 2011a, 2011b) astronomical solutions</p></a></li>
<li><a href='#hannTaper'><p>Apply Hann taper to stratigraphic series</p></a></li>
<li><a href='#headn'><p>List column numbers for each variable</p></a></li>
<li><a href='#hilbert'><p>Hilbert transform of stratigraphic series</p></a></li>
<li><a href='#idPts'><p>Interactively identify points in plot</p></a></li>
<li><a href='#imbrie'><p>Imbrie and Imbrie (1980) ice sheet model</p></a></li>
<li><a href='#impulseResponse'><p>Impulse response function calculation</p></a></li>
<li><a href='#insoDiff'><p>insolation difference map using Laskar et al. (2004) insolation calculations</p></a></li>
<li><a href='#insoMap'><p>generate an insolation map using Laskar et al. (2004) insolation calculations</p></a></li>
<li><a href='#insoSeries'><p>Laskar et al. (2004) insolation calculations</p></a></li>
<li><a href='#integratePower'><p>Determine the total power within a given bandwidth</p></a></li>
<li><a href='#iso'><p>Isolate data from a specified stratigraphic interval</p></a></li>
<li><a href='#linage'><p>Tune stratigraphic series to an astronomical target using graphical interface</p></a></li>
<li><a href='#linterp'><p>Piecewise linear interpolation of stratigraphic series</p></a></li>
<li><a href='#logT'><p>Log transformation of stratigraphic series</p></a></li>
<li><a href='#lowpass'><p>Lowpass filter stratigraphic series</p></a></li>
<li><a href='#lowspec'><p>Robust Locally-Weighted Regression Spectral Background Estimation</p></a></li>
<li><a href='#makeNoise'><p>Generate noise surrogates from a theoretical power spectrum</p></a></li>
<li><a href='#modelA'><p>Example stratigraphic model series</p></a></li>
<li><a href='#mtm'><p>Multitaper method spectral analysis</p></a></li>
<li><a href='#mtmAR'><p>Intermediate spectrum test of Thomson et al. (2001)</p></a></li>
<li><a href='#mtmML96'><p>Mann and Lees (1996) robust red noise MTM analysis</p></a></li>
<li><a href='#mtmPL'><p>Multitaper Method Spectral Analysis with Power Law (1/f) fit</p></a></li>
<li><a href='#multiTest'><p>Adjust spectral p-values for multiple comparisons</p></a></li>
<li><a href='#mwCor'><p>Calculate moving window correlation coefficient for two stratigraphic series, using a 'dynamic window'</p></a></li>
<li><a href='#mwin'><p>Determine 'dynamic moving window' for stratigraphic series, adjusting for changing sample density to maintain a window of constant duration</p></a></li>
<li><a href='#mwinGrid'><p>Determine 'dynamic moving window' for stratigraphic series, adjusting for changing sample density to maintain a window of constant duration; output on evenly spaced grid</p></a></li>
<li><a href='#mwMinMax'><p>'Dynamic window' moving assessment of maxima and minima in stratigraphic series</p></a></li>
<li><a href='#mwStats'><p>'Dynamic window' moving average, median and variance of stratigraphic series</p></a></li>
<li><a href='#mwStatsGrid'><p>'Dynamic window' moving average, median and variance of stratigraphic series, using evenly spaced spatial/temporal grid</p></a></li>
<li><a href='#noKernel'><p>Remove Gaussian kernel smoother from stratigraphic series</p></a></li>
<li><a href='#noLow'><p>Fit and remove Lowess smoother from stratigraphic series</p></a></li>
<li><a href='#pad'><p>Pad stratigraphic series with zeros</p></a></li>
<li><a href='#peak'><p>Identify maxima of peaks in series, filter at desired threshold value</p></a></li>
<li><a href='#periodogram'><p>Simple periodogram</p></a></li>
<li><a href='#pl'><p>Set up plots</p></a></li>
<li><a href='#plotEha'><p>Create color time-frequency plots from eha results.</p></a></li>
<li><a href='#plS'><p>Set default plotting parameters for vertical stratigraphic plots</p></a></li>
<li><a href='#prewhiteAR'><p>Prewhiten stratigraphic series with autoregressive filter, order selected by Akaike Information Criterion</p></a></li>
<li><a href='#prewhiteAR1'><p>Prewhiten stratigraphic series with AR1 filter, using 'standard' or unbiased estimate of rho</p></a></li>
<li><a href='#pwrLaw'><p>Generate power law (1/f) noise surrogates</p></a></li>
<li><a href='#pwrLawFit'><p>Estimate power law (1/f) fit to power spectrum</p></a></li>
<li><a href='#rankSeries'><p>Create lithofacies rank series from bed thickness data</p></a></li>
<li><a href='#read'><p>Read data from file</p></a></li>
<li><a href='#readMatrix'><p>Read data matrix from file</p></a></li>
<li><a href='#repl0'><p>Replace values &lt; 0 with 0</p></a></li>
<li><a href='#replEps'><p>Replace values &lt;= 0 with smallest positive value</p></a></li>
<li><a href='#resample'><p>Resample stratigraphic series</p></a></li>
<li><a href='#rmNA'><p>Remove stratigraphic levels that contain one or more NAs</p></a></li>
<li><a href='#s'><p>Standardize variable in stratigraphic series</p></a></li>
<li><a href='#sedRamp'><p>Apply 'ramping' sedimentation rate model to convert time to stratigraphy</p></a></li>
<li><a href='#sedrate2time'><p>Integrate sedimentation rate curve to obtain time-space map</p></a></li>
<li><a href='#slideCor'><p>Identify optimal spatial/temporal shift to maximize correlation between two stratigraphic/time series.</p></a></li>
<li><a href='#sortNave'><p>Remove missing entries, sort data, average duplicates</p></a></li>
<li><a href='#stepHeat'><p>Ar/Ar Geochronology: Generate an Ar/Ar age spectrum and calculate step-heating plateau age.</p></a></li>
<li><a href='#strats'><p>Summary statistics for stratigraphic series</p></a></li>
<li><a href='#surrogateCor'><p>Estimate correlation coefficient and significance for serially correlated data</p></a></li>
<li><a href='#surrogates'><p>Generate phase-randomized surrogate series as in Ebisuzaki (1997)</p></a></li>
<li><a href='#synthStrat'><p>Synthesize stratigraphy from forcing function</p></a></li>
<li><a href='#taner'><p>Apply Taner bandpass or lowpass filter to stratigraphic series</p></a></li>
<li><a href='#tanerFC'><p>Apply Taner bandpass or lowpass filter to Fourier coefficients</p></a></li>
<li><a href='#testBackground'><p>Evaluate power spectrum false positive rates via Monte Carlo simulation</p></a></li>
<li><a href='#testPrecession'><p>Astrochronologic testing via the precession amplitude modulation approach of Zeeden et al. (2015).</p></a></li>
<li><a href='#testTilt'><p>Astrochronologic testing via the obliquity amplitude modulation approach of Zeeden et al. (2019 submitted).</p></a></li>
<li><a href='#timeOpt'><p>TimeOpt: Evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data</p></a></li>
<li><a href='#timeOptMCMC'><p>TimeOptMCMC: Evaluation of eccentricity-related amplitude modulation and bundling</p>
in paleoclimate data (&quot;TimeOpt&quot;), with uncertainties via Markov-Chain Monte Carlo</a></li>
<li><a href='#timeOptPlot'><p>TimeOptPlot: Generate summary figure for TimeOpt analyses</p></a></li>
<li><a href='#timeOptSim'><p>Monte Carlo simulation for TimeOpt</p></a></li>
<li><a href='#timeOptSimPwrLaw'><p>Monte Carlo simulation for TimeOpt, using power law (1/f) noise</p></a></li>
<li><a href='#timeOptTemplate'><p>TimeOpt analysis using variable sedimentation models</p></a></li>
<li><a href='#timeOptTemplatePlot'><p>TimeOptTemplatePlot: Generate summary figure for TimeOptTemplate analyses</p></a></li>
<li><a href='#timeOptTemplateSim'><p>Simulations for timeOptTemplate</p></a></li>
<li><a href='#tones'><p>Calculate all possible difference and combinations tones</p></a></li>
<li><a href='#traceFreq'><p>Frequency-domain minimal tuning: Use interactive graphical interface to trace frequency drift</p></a></li>
<li><a href='#tracePeak'><p>A tool to interactively trace peak trajectories on plots</p></a></li>
<li><a href='#trackFreq'><p>Frequency-domain minimal tuning: Use interactive graphical interface and sorting to track frequency drift</p></a></li>
<li><a href='#trackPeak'><p>A tool to interactively select points to track peak trajectories on plots</p></a></li>
<li><a href='#trim'><p>Remove outliers from stratigraphic series</p></a></li>
<li><a href='#trimAT'><p>Remove outliers from stratigraphic series</p></a></li>
<li><a href='#trough'><p>Identify minima of troughs in series, filter at desired threshold value</p></a></li>
<li><a href='#tune'><p>Tune stratigraphic series</p></a></li>
<li><a href='#unbioturb'>
<p>Bioturbation removal function following the approach of Liu et al (2021)</p></a></li>
<li><a href='#writeCSV'><p>Write CSV file</p></a></li>
<li><a href='#writeT'><p>Write tab-delimited file</p></a></li>
<li><a href='#wtMean'><p>Ar/Ar Geochronology: calculate weighted mean age, age uncertainty, and other associated statistics/plots (with interactive graphics for data culling).</p></a></li>
<li><a href='#xplot'><p>Generate cross-plot with kernel density estimates on axes</p></a></li>
<li><a href='#zoomIn'><p>Dynamically explore cross-plot, zoom-in into specified region</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Computational Tool for Astrochronology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Meyers [aut,cre], Alberto Malinverno [ctb], Linda Hinnov [ctb], Christian Zeeden [ctb], Huaran Liu [ctb], Vincent Moron [ctb], Michel Crucifix [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Meyers &lt;smeyers@geology.wisc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for astrochronologic testing, astronomical time scale construction, and time series analysis &lt;<a href="https://doi.org/10.1016%2Fj.earscirev.2018.11.015">doi:10.1016/j.earscirev.2018.11.015</a>&gt;. Also included are a range of statistical analysis and modeling routines that are relevant to time scale development and paleoclimate analysis.</td>
</tr>
<tr>
<td>Imports:</td>
<td>multitaper, parallel, doParallel,foreach, iterators, IDPmisc,
fields, viridisLite, palinsol</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 17:17:43 UTC; smeyers</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-26 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anchorTime'>Anchor a floating astrochronology to a radioisotopic age</h2><span id='topic+anchorTime'></span>

<h3>Description</h3>

<p>Anchor a floating astrochronology to a radioisotopic age. The floating astrochronology is centered on a given ('floating') time datum and assigned the 'anchored' age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchorTime(dat,time,age,timeDir=1,flipOut=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchorTime_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series. First column should be floating time scale, second column should be data value.</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_time">time</code></td>
<td>
<p>'Floating' time datum to center record on. Units should be ka.</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_age">age</code></td>
<td>
<p>Radioisotopic age (or othwerwise) for anchoring at floating 'time' datum. Units should be ka.</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_timedir">timeDir</code></td>
<td>
<p>Direction of 'floating' time in input record; 1 = elapsed time towards present; 2 = elapsed time away from present</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_flipout">flipOut</code></td>
<td>
<p>Flip the output (sort so the ages are presented in decreasing order)? (T or F)</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="anchorTime_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='ar1'>Generate AR(1) surrogates</h2><span id='topic+ar1'></span>

<h3>Description</h3>

<p>Generate AR(1) surrogates. Implement shuffling algorithm of Meyers (2012) if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1(npts=1024,dt=1,mean=0,sdev=1,rho=0.9,shuffle=F,nsim=1,genplot=T,verbose=T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1_+3A_npts">npts</code></td>
<td>
<p>number of time series data points</p>
</td></tr>
<tr><td><code id="ar1_+3A_dt">dt</code></td>
<td>
<p>sampling interval</p>
</td></tr>
<tr><td><code id="ar1_+3A_mean">mean</code></td>
<td>
<p>mean value for AR1 surrogate series</p>
</td></tr>
<tr><td><code id="ar1_+3A_sdev">sdev</code></td>
<td>
<p>standard deviation for AR1 surrogate series</p>
</td></tr>
<tr><td><code id="ar1_+3A_rho">rho</code></td>
<td>
<p>AR(1) coefficient</p>
</td></tr>
<tr><td><code id="ar1_+3A_shuffle">shuffle</code></td>
<td>
<p>Apply secondary shuffle of Gaussian deviates before AR modeling</p>
</td></tr>
<tr><td><code id="ar1_+3A_nsim">nsim</code></td>
<td>
<p>Number of AR1 surrogate series to generate</p>
</td></tr>
<tr><td><code id="ar1_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F)</p>
</td></tr>
<tr><td><code id="ar1_+3A_verbose">verbose</code></td>
<td>
<p>verbose output (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These simulations use the random number generator of Matsumoto and Nishimura [1998]. 
If shuffle = T, the algorithm from Meyers (2012, pg. 11) is applied: (1) two
sets of random sequences of the same length are generated, (2) the first random 
sequence is then sorted, and finally (3) the permutation vector of the sorted sequence 
is used to reorder the second random number sequence. This is done to guard against
potential shortcomings in random number generation that are specific to spectral estimation.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2012,
<em>Seeing red in cyclic stratigraphy: Spectral noise estimation for astrochronology</em>: Paleoceanography, v. 27, PA3328.
</p>

<hr>
<h2 id='ar1etp'>AR(1) + ETP simulation routine</h2><span id='topic+ar1etp'></span>

<h3>Description</h3>

<p>Simulate a combined AR(1) + ETP signal, plot spectrum and confidence levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1etp(etpdat=NULL,nsim=100,rho=0.9,wtAR=1,sig=90,tbw=2,padfac=5,ftest=F,fmax=0.1,
       speed=0.5,pl=2,graphfile=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1etp_+3A_etpdat">etpdat</code></td>
<td>
<p>Eccentricity, tilt, precession astronmical series. First column = time, second column = ETP. If not entered will use default series from Laskar et al. (2004), spanning 0-1000 kyr.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_rho">rho</code></td>
<td>
<p>AR(1) coefficient for noise modeling.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_wtar">wtAR</code></td>
<td>
<p>Multiplicative factor for AR1 noise (1= eqivalent to ETP variance). If &lt; 0, etp signal will be excluded from the simulations (noise only)</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_sig">sig</code></td>
<td>
<p>Demarcate what confidence level (percent) on plots?</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the number of data points.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_ftest">ftest</code></td>
<td>
<p>Include MTM harmonic f-test results? (T or F)</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_fmax">fmax</code></td>
<td>
<p>Maximum frequency for plotting.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_speed">speed</code></td>
<td>
<p>Set the amount of time to pause before plotting new graph, in seconds.</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_pl">pl</code></td>
<td>
<p>Plot (1) log frequency-log power or (2) linear frequency-linear power?</p>
</td></tr>
<tr><td><code id="ar1etp_+3A_graphfile">graphfile</code></td>
<td>
<p>Output a pdf or jpg image of each plot? 0 = no, 1 = pdf, 2 = jpeg.  If yes, there will be no output to screen. Individual graphic files will be produced for each simluation, for assembling into a movie.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Setting wtAR=1 will provide equal variance contributions from the etp model and the ar1 model.
More generally, set wtAR to the square root of the desired variance contribution (wtAR=0.5 will generate an AR1 model with variance that is 25% of the etp model).
If you would like to exclusively evaluate the noise (no etp), set wtAR &lt; 0. 
</p>
<p>Note: You may use the function etp to generate eccentricity-tilt-precession models.
</p>


<h3>References</h3>

 
<p>Laskar, J., Robutel, P., Joutel, F., Gastineau, M., Correia, A.C.M., Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: Astron. Astrophys., Volume 428, 261-285.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getLaskar">getLaskar</a></code>, and <code><a href="#topic+etp">etp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

# run simulations using the default settings
ar1etp()

# compare with a second model:
# generate etp model spanning 0-2000 ka, with sampling interval of 5 ka.
ex1=etp(tmin=0,tmax=2000,dt=5)
# run simulations, with rho=-.7, and scaling noise to have 50
ar1etp(etpdat=ex1,rho=0.7,wtAR=sqrt(0.5))

 
## End(Not run)
</code></pre>

<hr>
<h2 id='arcsinT'>Arcsine transformation of stratigraphic series</h2><span id='topic+arcsinT'></span>

<h3>Description</h3>

<p>Arcsine transformation of stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsinT(dat,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsinT_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for arcsine transformation. Input can have any number of columns desired. If two or more columns are input, the first column must be location (e.g., depth), while remaining columns are data values for transformation.</p>
</td></tr>
<tr><td><code id="arcsinT_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F). This is automatically deactivated if more than one variable is transformed.</p>
</td></tr>
<tr><td><code id="arcsinT_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code></p>

<hr>
<h2 id='armaGen'>Generate autoregressive moving-average model</h2><span id='topic+armaGen'></span>

<h3>Description</h3>

<p>Generate an autoregressive moving-average time series model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armaGen(npts=1024,dt=1,m=0,std=1,rhos=c(0.9),thetas=c(0),genplot=T,verbose=T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armaGen_+3A_npts">npts</code></td>
<td>
<p>Number of time series data points.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_dt">dt</code></td>
<td>
<p>Sampling interval.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_m">m</code></td>
<td>
<p>Mean value of final time series.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_std">std</code></td>
<td>
<p>Standard deviation of final time series.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_rhos">rhos</code></td>
<td>
<p>Vector of AR coefficients for each order.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_thetas">thetas</code></td>
<td>
<p>Vector of MA coefficients for each order.</p>
</td></tr>
<tr><td><code id="armaGen_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="armaGen_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='asm'>Average Spectral Misfit</h2><span id='topic+asm'></span>

<h3>Description</h3>

<p>Calculate Average Spectral Misfit with Monte Carlo spectra simulations, as updated in Meyers et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asm(freq,target,fper=NULL,rayleigh,nyquist,sedmin=1,sedmax=5,numsed=50,
    linLog=1,iter=100000,output=F,genplot=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asm_+3A_freq">freq</code></td>
<td>
<p>A vector of candidate astronomical cycles observed in your data spectrum (cycles/m). Maximum allowed is 500.</p>
</td></tr>
<tr><td><code id="asm_+3A_target">target</code></td>
<td>
<p>A vector of astronomical frequencies to evaluate (1/ka). These must be in order of increasing frequency (e.g., e1,e2,e3,o1,o2,p1,p2). Maximum allowed is 50 frequencies.</p>
</td></tr>
<tr><td><code id="asm_+3A_fper">fper</code></td>
<td>
<p>A vector of uncertainties on each target frequency (1/ka).  Values should be from 0-1, representing uncertainty as a percent of each target frequency.  The order of the uncertainties must follow that of the target vector. By default, no uncertainty is assigned.</p>
</td></tr>
<tr><td><code id="asm_+3A_rayleigh">rayleigh</code></td>
<td>
<p>Rayleigh frequency (cycles/m).</p>
</td></tr>
<tr><td><code id="asm_+3A_nyquist">nyquist</code></td>
<td>
<p>Nyquist frequency (cycles/m).</p>
</td></tr>
<tr><td><code id="asm_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="asm_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="asm_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in ASM optimization grid. Maximum allowed is 500.</p>
</td></tr>
<tr><td><code id="asm_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="asm_+3A_iter">iter</code></td>
<td>
<p>Number of Monte Carlo simulations for significance testing. Maximum allowed is 100,000.</p>
</td></tr>
<tr><td><code id="asm_+3A_output">output</code></td>
<td>
<p>Return output as a new data frame? (T or F)</p>
</td></tr>
<tr><td><code id="asm_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will caculate the Average Spectral Misfit between a data spectrum and astronomical 
target spectrum, following the approach outlined in Meyers and Sageman (2007), and the 
improvements of Meyers et al. (2012). 
</p>


<h3>Value</h3>

<p>A data frame containing:
Sedimentation rate (cm/ka), ASM (cycles/ka), Null hypothesis significance level (0-100 percent), Number of astronomical terms fit.
</p>


<h3>References</h3>

<p>S.R. Meyers and  B.B. Sageman, 2007,
<em>Quantification of Deep-Time Orbital Forcing by Average Spectral Misfit</em>: American Journal of Science, v. 307, p. 773-792.
</p>
<p>S.R. Meyers, B.B. Sageman and M.A. Arthur, 2012,
<em>Obliquity forcing of organic matter accumulation during Oceanic Anoxic Event 2</em>: Paleoceanography, 27, PA3212, doi:10.1029/2012PA002286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eAsm">eAsm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## These frequencies are from modelA (type '?astrochron' for more information). 
## They are for an 8 meter window, centered at 22 meters height. Units are cycles/m . 
freq &lt;- c(0.1599833,0.5332776,1.5998329,2.6797201,3.2796575,3.8795948,5.5194235,6.5459830)
freq &lt;- data.frame(freq)

## Rayleigh frequency in cycles/m
rayleigh &lt;- 0.1245274

## Nyquist frequency in cycles/m
nyquist &lt;- 6.66597

## orbital target in 1/ky. Predicted periods for 94 Ma (see Meyers et al., 2012)
target &lt;- c(1/405.47,1/126.98,1/96.91,1/37.66,1/22.42,1/18.33)

## percent uncertainty in orbital target
fper=c(0.023,0.046,0.042,0.008,0.035,0.004)

asm(freq=freq,target=target,fper=fper,rayleigh=rayleigh,nyquist=nyquist,sedmin=0.5,sedmax=3,
    numsed=100,linLog=1,iter=100000,output=FALSE)
</code></pre>

<hr>
<h2 id='astrochron-package'>astrochron: A Computational Tool for Astrochronology</h2><span id='topic+astrochron-package'></span><span id='topic+astrochron'></span>

<h3>Description</h3>

<p>This software provides routines for astrochronologic testing, astronomical time scale 
construction, and time series analysis &lt;doi:10.1016/j.earscirev.2018.11.015&gt;. Also 
included are a range of statistical analysis and modeling routines that are relevant 
to time scale development and paleoclimate analysis.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> astrochron</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h3>Note</h3>

<p>Development of the 'astrochron' package is partially supported by the U.S. National Science Foundation and the Heising-Simons Foundation:
</p>
<p><em>Leveraging the Geologic Record to Constrain Solar System Evolution, Earth-Moon Dynamics, Paleoclimate Change and Geological Time (Heising-Simons Foundation Award 2021-2797)</em>
</p>
<p><em>Collaborative Research: Improving the Late Cretaceous-Eocene geomagnetic polarity time scale by integrating the global magnetic anomaly record and astrochronology (U.S. National Science Foundation Award OCE 2051616)</em>
</p>
<p><em>CAREER: Deciphering the Beat of a Timeless Rhythm - The Future of Astrochronology (U.S. National Science Foundation Award EAR 1151438)</em>
</p>
<p><em>Collaborative Research: Evolution of the Climate Continuum - Late Paleogene to Present (U.S. National Science Foundation Award OCE 1003603)</em>
</p>
<p>TO CITE THIS PACKAGE IN PUBLICATIONS, PLEASE USE:
</p>
<p>Meyers, S.R. (2014). <em>Astrochron: An R Package for Astrochronology</em>. https://cran.r-project.org/package=astrochron 
</p>
<p>Also cite the original research papers that document the relevant algorithms, as referenced on the help pages for specific functions.
</p>


<h3>Author(s)</h3>

<p>Stephen Meyers
</p>
<p>Maintainer: Stephen Meyers &lt;smeyers@geology.wisc.edu&gt;
</p>


<h3>References</h3>

<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews
v.190, 190-223, doi:10.1016/j.earscirev.2018.11.015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### EXAMPLES OF SOME FUNCTIONS AVAILABLE IN THIS SOFTWARE:

### This demo will use a model (series are usually read using the function 'read').
data(modelA)

### Interpolate the model stratigraphic series to its median sampling interval
modelAInterp=linterp(modelA)

### Calculate MTM spectrum using 2pi Slepian tapers, include AR1 condfidence level estimates,
###  plot power with linear scale
mtm(modelAInterp,tbw=2,ar=TRUE,pl=2)

### Perform Evolutive Harmonic Analysis using 2pi Slepian tapers, a window of 8 meters,
###  pad to 1000 points, and output Harmonic F-test confidence level results
fCL=eha(modelAInterp,win=8,pad=1000,output=4)

### Perform Average Spectral Misfit analysis
### Extract Harmonic F-test spectrum at approximately 22 meters height
spec=extract(fCL,22)
### In this extracted spectrum, identify F-test peak maxima exceeding 90% confidence level
freqs=peak(spec,level=0.9)[2]
### Conduct ASM testing on these peaks
# set Rayleigh frequency in cycles/m
rayleigh=0.1245274
# set Nyquist frequency in cycles/m
nyquist=6.66597
# set astronomical target in 1/ky
target=c(1/405.47,1/126.98,1/96.91,1/37.66,1/22.42,1/18.33)
# execute ASM
asm(freq=freqs,target=target,rayleigh=rayleigh,nyquist=nyquist,sedmin=0.5,sedmax=3,numsed=100,
    linLog=1,iter=100000,output=FALSE)

# Check to see if this is an interactive R session (for compliance with CRAN standards).
# YOU SHOULD SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

### Interactively track obliquity term in EHA harmonic F-test confidence level results
freqs=trackFreq(fCL,fmin=1.2,fmax=2.4,threshold=0.8)

### Convert the spatial frequencies to sedimentation rates
sedrate=freq2sedrate(freqs,period=37.66)

### Convert the sedimentation rate curve to a time-space map
time=sedrate2time(sedrate)

### Tune the stratigraphic series using the time-space map
modelATuned=tune(modelAInterp,time)

### Interpolate the tuned series
modelATunedInterp=linterp(modelATuned)

### Perform Evolutive Harmonic Analysis on the tuned series
eha(modelATunedInterp)

}

</code></pre>

<hr>
<h2 id='autoPlot'>Automatically plot multiple stratigraphic series, with smoothing if desired</h2><span id='topic+autoPlot'></span>

<h3>Description</h3>

<p>Automatically plot and smooth specified stratigraphic data, versus location. Data are smoothed with a Gaussian kernel if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoPlot(dat,cols=NULL,dmin=NULL,dmax=NULL,vertical=T,ydir=NULL,nrows=NULL,plotype=1,
        smooth=0,xgrid=1,output=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoPlot_+3A_dat">dat</code></td>
<td>
<p>Your data frame; first column should be location identifier (e.g., depth).</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_cols">cols</code></td>
<td>
<p>A vector that identifies the columns to extract (first column automatically extracted).</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_dmin">dmin</code></td>
<td>
<p>Minimum depth/height/time for plotting.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_dmax">dmax</code></td>
<td>
<p>Maximum depth/height/time for plotting.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_vertical">vertical</code></td>
<td>
<p>Generate vertical stratigraphic plots? (T or F) If F, will generate horizontal plots.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_ydir">ydir</code></td>
<td>
<p>Direction for stratigraphic axis in plots (depth,height,time). If vertical=T, then -1 results in values increasing downwards, while 1 results in values increasing upwards. If vertical=F, then -1 results in values increasing toward the left, while 1 results in values increasing toward the right.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows in figure (if vertical = T; otherwise this will be the number of columns).</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_plotype">plotype</code></td>
<td>
<p>Type of plot to generate: 1= points and lines, 2 = points, 3 = lines</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_smooth">smooth</code></td>
<td>
<p>Width (temporal or spatial dimension) for smoothing with a Gaussian kernel (0 = no smoothing); the Gaussian kernel is scaled so that its quartiles (viewed as probability densities, that is, containing 50 percent of the area) are at +/- 25 percent of this value.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_xgrid">xgrid</code></td>
<td>
<p>For kernal smoothing: (1) evaluate on ORIGINAL sample grid, or (2) evaluate on EVENLY SPACED grid covering range.</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_output">output</code></td>
<td>
<p>Output data frame of smoothed values? (T or F)</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots (T or F)</p>
</td></tr>
<tr><td><code id="autoPlot_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='bandpass'>Bandpass filter stratigraphic series</h2><span id='topic+bandpass'></span>

<h3>Description</h3>

<p>Bandpass filter stratigraphic series using rectangular, Gaussian or tapered cosine (a.k.a. Tukey) window. This function can also be used to notch fiter a record (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandpass(dat,padfac=2,flow=NULL,fhigh=NULL,win=0,alpha=3,p=0.25,demean=T,
         detrend=F,addmean=T,output=1,xmin=0,xmax=Nyq,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandpass_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for bandpass filtering. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_flow">flow</code></td>
<td>
<p>Lowest frequency to bandpass.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_fhigh">fhigh</code></td>
<td>
<p>Highest frequency to bandpass.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_win">win</code></td>
<td>
<p>Window type for bandpass filter: 0 = rectangular , 1= Gaussian, 2= Cosine-tapered window (a.k.a. Tukey window).</p>
</td></tr>
<tr><td><code id="bandpass_+3A_alpha">alpha</code></td>
<td>
<p>Gaussian window parameter: alpha is 1/stdev, a measure of the width of the Dirichlet kernel. Choose alpha &gt;= 2.5.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_p">p</code></td>
<td>
<p>Cosine-tapered (Tukey) window parameter: p is the percent of the data series tapered (choose 0-1).</p>
</td></tr>
<tr><td><code id="bandpass_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="bandpass_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="bandpass_+3A_addmean">addmean</code></td>
<td>
<p>Add mean value to bandpass result? (T or F)</p>
</td></tr>
<tr><td><code id="bandpass_+3A_output">output</code></td>
<td>
<p>Output: (1) filtered series, (2) bandpass filter window.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="bandpass_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="bandpass_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bandpassed stratigraphic series.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, <code><a href="#topic+noLow">noLow</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code>, and <code><a href="#topic+taner">taner</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 405 ka, 100 ka, 40ka, and 20 ka, plus noise
ex=cycles(freqs=c(1/405,1/100,1/40,1/20),end=1000,dt=5,noisevar=.1)

# bandpass precession term using cosine-tapered window 
bandpass_ex &lt;- bandpass(ex,flow=0.045,fhigh=0.055,win=2,p=.4)

# notch filter (remove) obliquity term using cosine-tapered window
#  if you'd like the final notch filtered record to be centered on the mean proxy 
#  value, set addmean=FALSE
notch_ex &lt;- bandpass(ex,flow=0.02,fhigh=0.03,win=2,p=.4,addmean=FALSE)
notch_ex[2] &lt;- ex[2]-notch_ex[2]
pl(2)
plot(ex,type="l",main="Eccentricity+Obliquity+Precession")
plot(notch_ex,type="l",main="Following application of obliquity notch filter")
</code></pre>

<hr>
<h2 id='bergerPeriods'>Obliquity and precession periods of Berger et al. (1992)</h2><span id='topic+bergerPeriods'></span>

<h3>Description</h3>

<p>Determine the predicted precession and obliquity periods based on Berger et al. (1992). Values are determined by piecewise linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bergerPeriods(age,genplot=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bergerPeriods_+3A_age">age</code></td>
<td>
<p>Age (millions of years before present)</p>
</td></tr>
<tr><td><code id="bergerPeriods_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Berger, M.F. Loutre, and J. Laskar, 1992,
<em>Stability of the Astronomical Frequencies Over the Earth's History for Paleoclimate Studies</em>: Science, v. 255, p. 560-566.
</p>

<hr>
<h2 id='bicoherence'>bicoherence: Calculate bispectrum and bicoherence using WOSA method as detailed in Choudhury et al. (2008).</h2><span id='topic+bicoherence'></span>

<h3>Description</h3>

<p>bicoherence: Calculate bispectrum and bicoherence using WOSA method as detailed in Choudhury et al. (2008). Kim and Powers (1979) bicoherence normalization is used, with a conditioning factor to reduce the potential for spurious bicoherence peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicoherence(dat,overlap=50,segments=8,CF=0,CL=95,padfac=2,demean=T,detrend=T,
            taper=T,maxF=Nyq,output=0,genplot=T,color=1,id=NULL,logpwr=F,logbis=F,
            check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicoherence_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to analyze. First column should be location (e.g., depth, time), second column should be data value.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_overlap">overlap</code></td>
<td>
<p>Percent overlap for WOSA segments (use 0-50 percent).</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_segments">segments</code></td>
<td>
<p>Number of segments for WOSA.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_cf">CF</code></td>
<td>
<p>Conditioning factor for bicoherence estimation (see pg. 70 of Choudhury et al., 2008). When CF=0, this will be automatically estimated as the 75th percentile of the magnitude-squared bicoherence denominator</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_cl">CL</code></td>
<td>
<p>Confidence level to identify with a contour on the plots (0-100).</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points per segment.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_taper">taper</code></td>
<td>
<p>Apply Hanning taper? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_maxf">maxF</code></td>
<td>
<p>Maximum frequency for analysis/plotting.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_output">output</code></td>
<td>
<p>Return output as new data frame? 0 = none, 1 = magnitude-squared bispectrum, 2 = magnitude-squared bicoherence, 3 = magnitude-squared bicoherence confidence levels, 4 = everything.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_color">color</code></td>
<td>
<p>Use (1) grayscale or (2) viridis color scale for 3D plots?</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_id">id</code></td>
<td>
<p>A vector listing frequencies to identify on the plots as diagonal lines.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_logpwr">logpwr</code></td>
<td>
<p>Use a log scale for power spectrum? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_logbis">logbis</code></td>
<td>
<p>Use a log scale for bispectrum? (T or F)</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="bicoherence_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accompanies the publication Sullivan et al. (in press 2023, PNAS): &quot;Bicoherence is a higher-order statistic, which 
quantifies coupling of individual frequencies (as combination and difference tones). For three frequencies, f1, f2 and f3, 
high bicoherence indicates that f1 + f2 = f3, with the additional property that their phases are also coupled in the data 
series. We employ the bicoherence approach of Choudhury, Shah and Thornhill (2008), which uses Welch Overlapping Spectral 
Analysis (WOSA), as this method includes improvements to the standard approach that reduce the potential for spurious 
bicoherence peaks. Note that reliable bicoherence estimates require a substantial increase in bandwidth resolution (&quot;smoothing&quot;)&quot;.
</p>


<h3>References</h3>

<p>Choudhury, A.A.S., Shah, S.L., and Thornhill, N.F. (2008),
<em>Diagnosis of Process Nonlinearities and Valve Stiction: Data Driven Approaches</em>: Springer, 284 pp.
</p>
<p>Kim, Y.C., and Powers, E.J. (1979), 
<em>Digital Bispectral Analysis and Its Applications to Nonlinear Wave Interactions</em>: IEEE Transactions on Plasma Science, v. PS-7, 120-131.
</p>
<p>Sullivan, N.B., Meyers, S.R., Levy, R.H., McKay, R.M., Golledge, N.R., Cortese, G. (in press 2023),
<em>Millennial-scale variability of the Antarctic Ice Sheet during the Early Miocene</em>: Proceedings of the National Academy of Sciences.
</p>
<p>Welch, P.D. (1967),
<em>The use of Fast Fourier Tranform for the estimation of power spectra: A method based on time averaging over short, modified periodograms</em>: IEEE Transactions on Audio and Electroacoustics, AU-5 (2): 70-73.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Generate an example quadratic phase-coupled signal as in Choudhury et al. (2008, pg. 79)
    n = rnorm(500)
    t=1:500
    signal = sin(2*pi*0.12*t + pi/3) + sin(2*pi*0.18*t + pi/12) + sin(2*pi*0.3*t + 5*pi/12) + n
    ex=data.frame(cbind(t,signal))
    bicoherence(ex)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='bioturb'>Bioturbate time series using diffusion model from Guinasso and Schinck (1975), as in Liu et al. (2021)</h2><span id='topic+bioturb'></span>

<h3>Description</h3>

<p>'bioturb' is a function for simulating the bioturbed time series when bioturbation is modeled as a diffusive process.
It implements the methodology outlined in Liu et al. (2021), which builds on the approaches of (Guinasso and Schink, 1975),
Goreau (1977), and Goreau (1980). Given the bioturbation parameters, an impulse response function is first calculated 
using function 'impulseResponse'. This function is then convolved with the input time series (true signal) to output the 
bioturbed time series. Note that the input true signal 'dat' and impulse response function are interpolated to the same 
resolution before convolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioturb(dat, G, ML, v, output=1, genplot=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bioturb_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to be bioturbated. First column should be age (kyr), second column should be data value.</p>
</td></tr>
<tr><td><code id="bioturb_+3A_g">G</code></td>
<td>
<p>Control parameter in Guinasso and Schinck, 1975. G = D/ML/v</p>
</td></tr>
<tr><td><code id="bioturb_+3A_ml">ML</code></td>
<td>
<p>Mix layer depth (cm)</p>
</td></tr>
<tr><td><code id="bioturb_+3A_v">v</code></td>
<td>
<p>Sedimentation rate (cm/kyr)</p>
</td></tr>
<tr><td><code id="bioturb_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to the console? (0) no output; (1) return bioturbated series; (2) return impulse response</p>
</td></tr>
<tr><td><code id="bioturb_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="bioturb_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Guinasso, N.L. and Schinck, D.R., 1975, <em>Quantitative estimates of biological mixing rates in abyssal sediments</em>, J. Geophys. Res., 80, 3032-3043.
</p>
<p>Goreau, T.J., 1977, <em>Quantitative effects of sediment mixing on stratigraphy and biogeochemistry: a signal theory approach</em>, Nature, 256, 730-732.
</p>
<p>Goreau, T.J., 1980, <em>Frequency sensitivity of the deep-sea climatic record</em>, Nature, 287, 620-622.
</p>
<p>Liu, H., Meyers, S.R., and Marcott, S.A., 2021, <em>Unmixing dee-sea paleoclimate records: A study on bioturbation effects through convolution and deconvolution</em>, Earth and Planetary Science Letters, 564, 116883.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># as a test series, use the three dominant precession terms from Berger et al. (1992)
ex1=cycles()

# mix it
res1 &lt;- bioturb(ex1, G=4, ML=10, v=1, genplot = TRUE)

# un-mix it
res2=unbioturb(res1, G=4, ML=10, v=1, genplot = TRUE)

pl()
plot(ex1,type="l",main="black=signal, blue=bioturbated, red=unbioturbated",lwd=3)
lines(res2,col="red")
lines(res1,col="blue")
</code></pre>

<hr>
<h2 id='calcPeriods'>Calculate eccentricity, obliquity and precession periods in ka, given g, s and k in arcsec/yr</h2><span id='topic+calcPeriods'></span>

<h3>Description</h3>

<p>Calculate eccentricity, obliquity and precession periods in ka, given g, s and k in arcsec/yr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPeriods(g,s=NULL,k,output=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPeriods_+3A_g">g</code></td>
<td>
<p>Required Data frame or matrix with columns representing the fundamental frequencies: g1, g2, g3, g4, g5. Frequencies must be in arcsec/yr.</p>
</td></tr>
<tr><td><code id="calcPeriods_+3A_s">s</code></td>
<td>
<p>Optional data frame or matrix with columns representing the fundamental frequencies: s1, s2, s3, s4, s5, s6. Frequencies must be in arcsec/yr. This is only required if you want to calculate obliquity periods.</p>
</td></tr>
<tr><td><code id="calcPeriods_+3A_k">k</code></td>
<td>
<p>Required data frame or vector with precession constant (frequency). Frequencies must be in arcsec/yr.</p>
</td></tr>
<tr><td><code id="calcPeriods_+3A_output">output</code></td>
<td>
<p>(1) return results as data frame, (2) return results as a numeric vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># calculate eccentricity and precession periods for one set of g's and k
gVal= c(5.579378,7.456665,17.366595,17.910194,4.257564)
kVal= 50.475838
calcPeriods(g=gVal, k=kVal)

# calculate eccentricity and precession periods for two sets of g's and k
gVal= matrix(c(5.579378,7.456665,17.366595,17.910194,4.257564,5.494302,7.452619,
      17.480760,18.348310,4.257451,5.531285,7.456848,17.320480,17.912240,4.257456),
      nrow=3,ncol=5,byrow=TRUE)

kVal= c(50.475838,51.280910,85.790450)

calcPeriods(g=gVal, k=kVal)
</code></pre>

<hr>
<h2 id='cb'>Combine multiple vectors</h2><span id='topic+cb'></span>

<h3>Description</h3>

<p>Bind two vectors together and return result as a data frame. Alternatively, extract specified columns from a data frame, bind them together, and return result as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cb(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cb_+3A_a">a</code></td>
<td>
<p>first input vector OR a data frame with &gt;1 column.</p>
</td></tr>
<tr><td><code id="cb_+3A_b">b</code></td>
<td>
<p>second input vector OR if a is a data frame with &gt; 1 column, a list of columns to bind.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># example dataset
x&lt;-rnorm(100)
dim(x)&lt;-c(10,10)
x&lt;-data.frame(x)

# bind two columns
cb(x[1],x[5])

# bind five columns
cb(x,c(1,2,4,7,9))
</code></pre>

<hr>
<h2 id='clipIt'>Create non-linear response by clipping stratigraphic series</h2><span id='topic+clipIt'></span>

<h3>Description</h3>

<p>Create non-linear response by clipping stratigraphic series below a threshold value. Alternatively, mute response below a threshold value using a contant divisor.  Both approaches will enhance power in modulator (e.g., eccentricity) and diminish power the carrier (e.g., precession).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipIt(dat,thresh=NULL,clipval=NULL,clipdiv=NULL,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipIt_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="clipIt_+3A_thresh">thresh</code></td>
<td>
<p>Clip below what theshold value? By default will clip at mean value.</p>
</td></tr>
<tr><td><code id="clipIt_+3A_clipval">clipval</code></td>
<td>
<p>What number should be assigned to the clipped values? By default, the value of thresh is used.</p>
</td></tr>
<tr><td><code id="clipIt_+3A_clipdiv">clipdiv</code></td>
<td>
<p>Clip using what divisor? A typical value is 2. By default, clipdiv is unity.</p>
</td></tr>
<tr><td><code id="clipIt_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="clipIt_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='confAdjust'>Adjust spectrum confidence levels for multiple comparisons</h2><span id='topic+confAdjust'></span>

<h3>Description</h3>

<p>Adjust spectrum confidence levels for multiple comparisons, using the Bonferroni correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confAdjust(spec,npts,dt,tbw=3,ntap=5,flow=NULL,fhigh=NULL,output=T,
    xmin=df,xmax=NULL,pl=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confAdjust_+3A_spec">spec</code></td>
<td>
<p>A data frame with three columns: frequency, power, background power. If more than 3 columns are input, the results are assumed to come from periodogram, mtm, mtmML96, lowspec or mtmPL.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_npts">npts</code></td>
<td>
<p>Number of points in stratigraphic series.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_dt">dt</code></td>
<td>
<p>Sampling interval of stratigraphic series.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_ntap">ntap</code></td>
<td>
<p>Number of DPSS tapers to use.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_flow">flow</code></td>
<td>
<p>Vector of lower bounds for each frequency band of interest. Order must match fhigh.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_fhigh">fhigh</code></td>
<td>
<p>Vector of upper bounds for each frequency band of interest. Order must match flow.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_output">output</code></td>
<td>
<p>Output data frame? (T or F)</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_pl">pl</code></td>
<td>
<p>Plotting option (1-4): 1=linear frequency &amp; log power, 2=log frequency &amp; power, 3=linear frequency &amp; power, 4=log frequency &amp; linear power.</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="confAdjust_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple testing is a common problem in the evaluation of power spectrum peaks 
(Vaughan et al., 2011; Crampton et al., PNAS).  To address the issue of multiple testing, 
a range of approaches have been advocated. This function will conduct an assessment 
using the Bonferroni correction, which is the simplest, and also the most conservative,
of the common approaches (it is overly pessimistic).
</p>
<p>If one is exclusively concerned with particular frequency bands a priori 
(e.g., those associated with Milankovitch cycles), the statistical power of the method
can be improved by restricting the analysis to those frequency bands (use options 'flow' and 'fhigh').
</p>
<p>Application of multiple testing corrections does not guarantee that the spectral background
is appropriate.  To address this issue, carefully examine the fit of the spectral background,
and also conduct simulations with the function testBackground.
</p>


<h3>References</h3>

<p>J.S. Campton, S.R. Meyers, R.A. Cooper, P.M Sadler, M. Foote, D. Harte, 2018, 
<em>Pacing of Paleozoic macroevolutionary rates by Milankovitch grand cycles</em>: Proceedings of the National Academy of Sciences, doi:10.1073/pnas.1714342115.
</p>
<p>S. Vaughan, R.J. Bailey, and D.G. Smith, 2011, 
<em>Detecting cycles in stratigraphic data: Spectral analysis in the presence of red noise</em>. Paleoceanography 26, PA4211, doi:10.1029/2011PA002195.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+testBackground">testBackground</a></code>,<code><a href="#topic+multiTest">multiTest</a></code>,<code>spec.mtm</code>, <code><a href="#topic+lowspec">lowspec</a></code>, and <code><a href="#topic+periodogram">periodogram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# first, let's use mtm with conventional AR1 background
spec=mtm(ex,padfac=1,ar1=TRUE,output=1)

# when blindly prospecting for cycles, it is necessary to consider all of the 
#  observed frequencies in the test
confAdjust(spec,npts=200,dt=5,tbw=3,ntap=5,output=FALSE)

# if, a priori, you are only concerned with the Milankovitch frequency bands, 
#  restrict your analysis to those bands (as constrained by available sedimentation
#  rate estimates and the frequency resolution of the spectrum). in the example below, 
#  the mtm bandwidth resolution is employed to search frequencies nearby the 
#  Milankovitch-target periods.
flow=c((1/400)-0.003,(1/100)-0.003,(1/41)-0.003,(1/20)-0.003)
fhigh=c((1/400)+0.003,(1/100)+0.003,(1/41)+0.003,(1/20)+0.003)
confAdjust(spec,npts=200,dt=5,tbw=3,ntap=5,flow=flow,fhigh=fhigh,output=FALSE)

# now try with the lowspec method. this uses prewhitening, so it has one less data point.
spec=lowspec(ex,padfac=1,output=1)
flow=c((1/400)-0.003015075,(1/100)-0.003015075,(1/41)-0.003015075,(1/20)-0.003015075)
fhigh=c((1/400)+0.003015075,(1/100)+0.003015075,(1/41)+0.003015075,(1/20)+0.003015075)
confAdjust(spec,npts=199,dt=5,tbw=3,ntap=5,flow=flow,fhigh=fhigh,output=FALSE)

# for comparison...
confAdjust(spec,npts=199,dt=5,tbw=3,ntap=5,output=FALSE)
</code></pre>

<hr>
<h2 id='constantSedrate'>Apply a constant sedimentation rate model to transform a spatial series to temporal series</h2><span id='topic+constantSedrate'></span>

<h3>Description</h3>

<p>Apply a constant sedimentation rate model to transform a spatial series to temporal series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantSedrate(dat,sedrate,begin=0,timeDir=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantSedrate_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="constantSedrate_+3A_sedrate">sedrate</code></td>
<td>
<p>Sedimentation rate, in same spatial units as dat.</p>
</td></tr>
<tr><td><code id="constantSedrate_+3A_begin">begin</code></td>
<td>
<p>Time value to assign to first datum.</p>
</td></tr>
<tr><td><code id="constantSedrate_+3A_timedir">timeDir</code></td>
<td>
<p>Direction of floating time in tuned record: 1 = elapsed time increases with depth/height; -1 = elapsed time decreases with depth/height)</p>
</td></tr>
<tr><td><code id="constantSedrate_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="constantSedrate_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='conv_fft'>Convolution through Fast Fourier Transform</h2><span id='topic+conv_fft'></span>

<h3>Description</h3>

<p>Convolution through Fast Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_fft(x, y, index, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_fft_+3A_x">x</code></td>
<td>
<p>Input signal that needs to be convolved</p>
</td></tr>
<tr><td><code id="conv_fft_+3A_y">y</code></td>
<td>
<p>Green's function; impulse response function</p>
</td></tr>
<tr><td><code id="conv_fft_+3A_index">index</code></td>
<td>
<p>index in the impulse response function that corresponds to the deposition time</p>
</td></tr>
<tr><td><code id="conv_fft_+3A_dt">dt</code></td>
<td>
<p>time resolution for the input series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function 'conv_fft' is used by function 'bioturb'. x and y do not need to be of the same length.
</p>


<h3>Value</h3>

<p>z Convolved output series. length(z) = length(x)
</p>

<hr>
<h2 id='cosTaper'>Apply cosine taper to stratigraphic series</h2><span id='topic+cosTaper'></span>

<h3>Description</h3>

<p>Apply a &quot;percent-tapered&quot; cosine taper (a.k.a. Tukey window) to a stratigraphic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosTaper(dat,p=.25,rms=T,demean=T,detrend=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosTaper_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tapering. First column should be location (e.g., depth), second column should be data value. If no data is identified, will output a 256 point taper to evaluate the spectral properties of the window.</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_p">p</code></td>
<td>
<p>Cosine-tapered window parameter: p is the percent of the data series tapered (choose 0-1). When p=1, this is equivalent to a Hann taper.</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_rms">rms</code></td>
<td>
<p>Normalize taper to RMS=1 to preserve power for white process? (T or F)</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="cosTaper_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+dpssTaper">dpssTaper</a></code>, <code><a href="#topic+gausTaper">gausTaper</a></code>, and <code><a href="#topic+hannTaper">hannTaper</a></code> </p>

<hr>
<h2 id='cycles'>Generate harmonic model</h2><span id='topic+cycles'></span>

<h3>Description</h3>

<p>Make a time series with specified harmonic components and noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycles(freqs=NULL,phase=NULL,amp=NULL,start=0,end=499,dt=1,noisevar=0,genplot=T,
        verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycles_+3A_freqs">freqs</code></td>
<td>
<p>Vector with frequencies to model ('linear' frequencies).</p>
</td></tr>
<tr><td><code id="cycles_+3A_phase">phase</code></td>
<td>
<p>Vector with phases for each frequency (phase in radians). Phases are subtracted.</p>
</td></tr>
<tr><td><code id="cycles_+3A_amp">amp</code></td>
<td>
<p>Vector with amplitudes for each frequency.</p>
</td></tr>
<tr><td><code id="cycles_+3A_start">start</code></td>
<td>
<p>First time/depth/height for output.</p>
</td></tr>
<tr><td><code id="cycles_+3A_end">end</code></td>
<td>
<p>Last time/depth/height for output.</p>
</td></tr>
<tr><td><code id="cycles_+3A_dt">dt</code></td>
<td>
<p>Sampling interval.</p>
</td></tr>
<tr><td><code id="cycles_+3A_noisevar">noisevar</code></td>
<td>
<p>Variance of additive Gaussian noise.</p>
</td></tr>
<tr><td><code id="cycles_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="cycles_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modeled time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## test signal on pg 38 of Choudhury, Shah, and Thornhill (2008)
freqs=c(0.12,0.18,0.30,0.42)
phase=c(-pi/3,-pi/12,-pi/4,-3*pi/8)
amp=c(1,1,1,1)

cycles(freqs,phase,amp,start=0,end=4095,dt=1,noisevar=0.2)
</code></pre>

<hr>
<h2 id='deconv'>Wiener Deconvolution through Fast Fourier Transform</h2><span id='topic+deconv'></span>

<h3>Description</h3>

<p>Wiener Deconvolution through Fast Fourier Transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv(x, y, index, dt, pt = 0.2, wiener = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconv_+3A_x">x</code></td>
<td>
<p>Time series that needs to be deconvolved.</p>
</td></tr>
<tr><td><code id="deconv_+3A_y">y</code></td>
<td>
<p>Green function/Impulse response function.</p>
</td></tr>
<tr><td><code id="deconv_+3A_index">index</code></td>
<td>
<p>index in the impulse response function that corresponds to the deposition time.</p>
</td></tr>
<tr><td><code id="deconv_+3A_dt">dt</code></td>
<td>
<p>time resolution for the input series.</p>
</td></tr>
<tr><td><code id="deconv_+3A_pt">pt</code></td>
<td>
<p>Cosine-tapered window parameter: pt is the percent of the data series tapered (choose 0-1). When pt=1, this is equivalent to a Hann taper.</p>
</td></tr>
<tr><td><code id="deconv_+3A_wiener">wiener</code></td>
<td>
<p>Apply Wiener filter? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function 'deconv' is used by function 'unbioturb'. A cosine taper is applied to remove edge effects.
The signal-to-noise ratio is chosen to be 0.05, and gamma is also chosen to be 0.05.
x and y do not need to be of the same length. For additional information see Liu et al. (2021)
</p>


<h3>Value</h3>

<p>z deconvolved/un-bioturbed  series. length(z) = length(x)
</p>


<h3>References</h3>

<p>Liu, H., Meyers, S.R., and Marcott, S.A., 2021, <em>Unmixing dee-sea paleoclimate records: A study on bioturbation effects through convolution and deconvolution</em>, Earth and Planetary Science Letters, 564, 116883.
</p>

<hr>
<h2 id='delPts'>Interactively delete points in plot</h2><span id='topic+delPts'></span>

<h3>Description</h3>

<p>Interactively delete points in x,y plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delPts(dat,del=NULL,cols=c(1,2),ptsize=1,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,
       plotype=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delPts_+3A_dat">dat</code></td>
<td>
<p>Data frame containing stratigraphic variable(s) of interest. Any number of columns permitted.</p>
</td></tr>
<tr><td><code id="delPts_+3A_del">del</code></td>
<td>
<p>A vector of indices indicating points to delete. If specified, the interactive plot is disabled.</p>
</td></tr>
<tr><td><code id="delPts_+3A_cols">cols</code></td>
<td>
<p>If you are using the graphical interface, which columns would you like to plot? (default = 1 &amp; 2).</p>
</td></tr>
<tr><td><code id="delPts_+3A_ptsize">ptsize</code></td>
<td>
<p>Size of plotted points.</p>
</td></tr>
<tr><td><code id="delPts_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value (column 1) to plot</p>
</td></tr>
<tr><td><code id="delPts_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value (column 1) to plot</p>
</td></tr>
<tr><td><code id="delPts_+3A_ymin">ymin</code></td>
<td>
<p>Minimum y-value (column 2) to plot</p>
</td></tr>
<tr><td><code id="delPts_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-value (column 2) to plot</p>
</td></tr>  
<tr><td><code id="delPts_+3A_plotype">plotype</code></td>
<td>
<p>Type of plot to generate: 1= points and lines, 2 = points, 3 = lines</p>
</td></tr>
<tr><td><code id="delPts_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="delPts_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+idPts">idPts</a></code>, <code><a href="#topic+iso">iso</a></code>, <code><a href="#topic+trim">trim</a></code> and <code><a href="#topic+trimAT">trimAT</a></code> </p>

<hr>
<h2 id='demean'>Remove mean value from stratigraphic series</h2><span id='topic+demean'></span>

<h3>Description</h3>

<p>Remove mean value from stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demean(dat,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demean_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for mean removal. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="demean_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="demean_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code></p>

<hr>
<h2 id='detrend'>Subtract linear trend from stratigraphic series</h2><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Remove linear trend from stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend(dat,output=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for linear detrending. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="detrend_+3A_output">output</code></td>
<td>
<p>1= output detrended signal; 2= output linear trend</p>
</td></tr>
<tr><td><code id="detrend_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="detrend_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code></p>

<hr>
<h2 id='diffAccum'>Model differential accumulation</h2><span id='topic+diffAccum'></span>

<h3>Description</h3>

<p>Model differential accumulation. The input variable (e.g., insolation, proxy value) is rescaled to sedimentation rate curve varying from sedmin to sedmax. Input series must be evenly sampled in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffAccum(dat,sedmin=0.01,sedmax=0.02,dir=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffAccum_+3A_dat">dat</code></td>
<td>
<p>Model input series with two columns. First column must be time in ka, second column should be data value. Data series must be evenly sampled in time.</p>
</td></tr>
<tr><td><code id="diffAccum_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate (m/ka)</p>
</td></tr>
<tr><td><code id="diffAccum_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate (m/ka)</p>
</td></tr>
<tr><td><code id="diffAccum_+3A_dir">dir</code></td>
<td>
<p>1=peaks have higher accumulation rate, -1=troughs have higher accumulation rate</p>
</td></tr>
<tr><td><code id="diffAccum_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="diffAccum_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate model with one 20 ka cycle
ex &lt;- cycles(1/20)

diffAccum(ex)
</code></pre>

<hr>
<h2 id='divTrend'>Divide by linear trend in stratigraphic series</h2><span id='topic+divTrend'></span>

<h3>Description</h3>

<p>Divide data series value by linear trend observed in stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divTrend(dat,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divTrend_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for div-trending. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="divTrend_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="divTrend_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code></p>

<hr>
<h2 id='dpssTaper'>Apply DPSS taper to stratigraphic series</h2><span id='topic+dpssTaper'></span>

<h3>Description</h3>

<p>Apply a single Discrete Prolate Spheroidal Sequence (DPSS) taper to a stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpssTaper(dat,tbw=1,num=1,rms=T,demean=T,detrend=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpssTaper_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tapering. First column should be location (e.g., depth), second column should be data value. If no data is identified, will output a 256 point taper to evaluate the spectral properties of the window.</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_tbw">tbw</code></td>
<td>
<p>Time-bandwidth product for the DPSS</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_num">num</code></td>
<td>
<p>Which one of the DPSS would you like to use?</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_rms">rms</code></td>
<td>
<p>Normalize taper to RMS=1 to preserve power for white process? (T or F)</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="dpssTaper_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+cosTaper">cosTaper</a></code>, <code><a href="#topic+gausTaper">gausTaper</a></code>, and <code><a href="#topic+hannTaper">hannTaper</a></code> </p>

<hr>
<h2 id='eAsm'>Evolutive Average Spectral Misfit</h2><span id='topic+eAsm'></span>

<h3>Description</h3>

<p>Calculate Evolutive Average Spectral Misfit with Monte Carlo spectra simulations, as updated in Meyers et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eAsm(spec,siglevel=0.9,target,fper=NULL,rayleigh,nyquist,sedmin=1,sedmax=5,
      numsed=50,linLog=1,iter=100000,ydir=1,palette=2,output=4,genplot=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eAsm_+3A_spec">spec</code></td>
<td>
<p>Time-frequency spectral results to evaluate. Must have the following format: column 
1=frequency; remaining columns (2 to n)=probability; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_siglevel">siglevel</code></td>
<td>
<p>Threshold level for filtering peaks.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_target">target</code></td>
<td>
<p>A vector of astronomical frequencies to evaluate (1/ka). These must be in order of increasing frequency (e.g., e1,e2,e3,o1,o2,p1,p2). Maximum allowed is 50 frequencies.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_fper">fper</code></td>
<td>
<p>A vector of uncertainties on each target frequency (1/ka).  Values should be from 0-1, representing uncertainty as a percent of each target frequency.  The order of the uncertainties must follow that of the target vector. By default, no uncertainty is assigned.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_rayleigh">rayleigh</code></td>
<td>
<p>Rayleigh frequency (cycles/m).</p>
</td></tr>
<tr><td><code id="eAsm_+3A_nyquist">nyquist</code></td>
<td>
<p>Nyquist frequency (cycles/m).</p>
</td></tr>
<tr><td><code id="eAsm_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="eAsm_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="eAsm_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in ASM optimization grid. Maximum allowed is 500.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="eAsm_+3A_iter">iter</code></td>
<td>
<p>Number of Monte Carlo simulations for significance testing. Maximum allowed is 100,000.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr>
<tr><td><code id="eAsm_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) viridis</p>
</td></tr>
<tr><td><code id="eAsm_+3A_output">output</code></td>
<td>
<p>Return output as a new data frame? (0 = nothing, 1 = Ho-SL, 2 = ASM, 3 = # astronomical terms, 4 = everything)</p>
</td></tr>
<tr><td><code id="eAsm_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see function asm for details.
</p>


<h3>References</h3>

<p>S.R. Meyers and  B.B. Sageman, 2007,
<em>Quantification of Deep-Time Orbital Forcing by Average Spectral Misfit</em>: American Journal of Science, v. 307, p. 773-792.
</p>
<p>S.R. Meyers, 2012,
<em>Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for Astrochronology</em>: Paleoceanography, 27, PA3228, doi:10.1029/2012PA002307.
</p>
<p>S.R. Meyers, B.B. Sageman and M.A. Arthur, 2012,
<em>Obliquity forcing of organic matter accumulation during Oceanic Anoxic Event 2</em>: Paleoceanography, 27, PA3212, doi:10.1029/2012PA002286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# use modelA as an example
data(modelA)

# interpolate to even sampling interval
modelAInterp=linterp(modelA)

# perform EHA analysis, save harmonic F-test confidence level results to 'spec'
spec=eha(modelAInterp,win=8,step=2,pad=1000,output=4)

# perform Evolutive Average Spectral Misfit analysis, save results to 'res'
res=eAsm(spec,target=c(1/405.47,1/126.98,1/96.91,1/37.66,1/22.42,1/18.33),rayleigh=0.1245274,
         nyquist=6.66597,sedmin=0.5,sedmax=3,numsed=100,siglevel=0.8,iter=10000,output=4)

# identify minimum Ho-SL in each record and plot
pl(1)
eAsmTrack(res[1],threshold=0.05)

# extract Ho-SL result at 18.23 m
HoSL18.23=extract(res[1],get=18.23,pl=1)

# extract ASM result at 18.23 m
asm18.23=extract(res[2],get=18.23,pl=0)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='eAsmTrack'>Track ASM null hypothesis significance level minima in eASM results</h2><span id='topic+eAsmTrack'></span>

<h3>Description</h3>

<p>Track ASM null hypothesis significance level minima in eASM results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eAsmTrack(res,threshold=.5,ydir=-1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eAsmTrack_+3A_res">res</code></td>
<td>
<p>eAsm results. Must have the following format: column 
1=sedimentation rate; remaining columns (2 to n)=Ho-SL; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eAsm.</p>
</td></tr>
<tr><td><code id="eAsmTrack_+3A_threshold">threshold</code></td>
<td>
<p>Threshold Ho-SL value for analysis and plotting.</p>
</td></tr>
<tr><td><code id="eAsmTrack_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr>
<tr><td><code id="eAsmTrack_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="eAsmTrack_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see function eAsm for details.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsm">eAsm</a></code>, and <code><a href="#topic+eha">eha</a></code> </p>

<hr>
<h2 id='eha'>Evolutive Harmonic Analysis &amp; Evolutive Power Spectral Analysis</h2><span id='topic+eha'></span>

<h3>Description</h3>

<p>Evolutive Harmonic Analysis &amp; Evolutive Power Spectral Analysis using the Thomson multitaper method (Thomson, 1982)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eha(dat,tbw=2,pad,fmin,fmax,step,win,demean=T,detrend=T,siglevel=0.90,
    sigID=F,ydir=1,output=0,pl=1,palette=6,centerZero=T,ncolors=100,xlab,ylab,
    genplot=2,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eha_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to analyze. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="eha_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product (&lt;=10)</p>
</td></tr>
<tr><td><code id="eha_+3A_pad">pad</code></td>
<td>
<p>Pad with zeros to how many points? Must not factor into a prime number &gt;23. Maximum number of points is 200,000.</p>
</td></tr>
<tr><td><code id="eha_+3A_fmin">fmin</code></td>
<td>
<p>Smallest frequency for analysis and plotting.</p>
</td></tr>
<tr><td><code id="eha_+3A_fmax">fmax</code></td>
<td>
<p>Largest frequency for analysis and plotting.</p>
</td></tr>
<tr><td><code id="eha_+3A_step">step</code></td>
<td>
<p>Step size for EHA window, in units of space or time.</p>
</td></tr>
<tr><td><code id="eha_+3A_win">win</code></td>
<td>
<p>Window size for EHA, in units of space or time.</p>
</td></tr>
<tr><td><code id="eha_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="eha_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="eha_+3A_siglevel">siglevel</code></td>
<td>
<p>Significance level for peak identification/filtering (0-1)</p>
</td></tr>
<tr><td><code id="eha_+3A_sigid">sigID</code></td>
<td>
<p>Identify signficant frequencies on power, amplitude, and probabilty plots. Only applies when one spectrum is calculated. (T or F)</p>
</td></tr>
<tr><td><code id="eha_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in EHA plots (depth,height,time). -1 = values increase downwards (slower plotting), 1 = values increase upwards</p>
</td></tr>
<tr><td><code id="eha_+3A_output">output</code></td>
<td>
<p>Return output as new data frame? 0=no; 1=all results; 2=power; 3=amplitude; 4=probability; 5=significant frequencies (only for one spectrum); 6=significant frequencies and their probabilities (only for one spectrum)</p>
</td></tr>
<tr><td><code id="eha_+3A_pl">pl</code></td>
<td>
<p>Plot logarithm of spectral power (1) or linear spectral power (2)?</p>
</td></tr>
<tr><td><code id="eha_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red (if values are negative and positive, white is centered on zero), (6) viridis</p>
</td></tr>
<tr><td><code id="eha_+3A_centerzero">centerZero</code></td>
<td>
<p>Center color scale on zero (use an equal number of postive and negative color divisions)? (T or F)</p>
</td></tr>
<tr><td><code id="eha_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors steps to use in palette.</p>
</td></tr>
<tr><td><code id="eha_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis. Default = &quot;Frequency&quot;</p>
</td></tr>
<tr><td><code id="eha_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis. Default = &quot;Location&quot;</p>
</td></tr>
<tr><td><code id="eha_+3A_genplot">genplot</code></td>
<td>
<p>Plotting options. 0= no plots; 1= power, amplitude, f-test, probability; 2=data series, power, amplitude, probability; 3= data series, power, normalized amplitude (maximum in each window normalized to unity), normalized amplitude filtered at specified siglevel; 4= data series, normalized power (maximum in each window normalized to unity), normalized amplitude (maximum in each window normalized to unity), normalized amplitude filtered at specified siglevel</p>
</td></tr>
<tr><td><code id="eha_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thomson, D. J., 1982, <em>Spectrum estimation and harmonic analysis</em>, Proc. IEEE, 70, 1055-1096, doi:10.1109/PROC.1982.12433.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+extract">extract</a></code>, <code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtmAR">mtmAR</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, <code><a href="#topic+trackFreq">trackFreq</a></code> and <code><a href="#topic+traceFreq">traceFreq</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## as an example, evaluate the modelA
data(modelA)

## interpolate to even sampling interval of 0.075 m
ex1=linterp(modelA, dt=0.075)
  
## perform EHA with a time-bandwidth parameter of 2, using an 7.95 meter window, 0.15 m step, 
## and pad to 1000 points
## set labels for plots (optional)
eha(ex1,tbw=2,win=7.95,step=0.15,pad=1000,xlab="Frequency (cycles/m)",ylab="Height (m)")

## for comparison generate spectrum for entire record, using time-bandwidth parameter of 3, and 
## pad to 5000 points
## start by making a new plot
pl(1)
eha(ex1,tbw=3,win=38,pad=5000,xlab="Frequency (cycles/m)")
</code></pre>

<hr>
<h2 id='eTimeOpt'>eTimeOpt: Evolutive implementation of TimeOpt (Meyers, 2015; Meyers, 2019)</h2><span id='topic+eTimeOpt'></span>

<h3>Description</h3>

<p>eTimeOpt: Evolutive implementation of TimeOpt (Meyers, 2015; Meyers, 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eTimeOpt(dat,win=dt*100,step=dt*10,sedmin=0.5,sedmax=5,numsed=100,linLog=1,
    limit=T,fit=1,fitModPwr=T,flow=NULL,fhigh=NULL,roll=NULL,targetE=NULL,targetP=NULL,
    detrend=T,ydir=1,palette=6,ncolors=100,output=1,genplot=T,check=T,verbose=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eTimeOpt_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_win">win</code></td>
<td>
<p>Window size, in meters.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_step">step</code></td>
<td>
<p>Step size for moving window, in meters.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log; default value  is 1)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F).</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>  
<tr><td><code id="eTimeOpt_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth,height,time). -1 = values increase downwards (slower plotting), 1 = values increase upwards</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red (if values are negative and positive, white is centered on zero), (6) viridis</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors steps to use in palette.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to the console? (0) no output; (1) everything, (2) r^2_envelope, (3) r^2_power, (4) r^2_opt</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="eTimeOpt_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (0=nothing, 1=minimal, 2=a little more, 3=everything!)</p>
</td></tr>
</table>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in 
paleoclimate data: An inverse approach for astrochronologic testing and time scale 
optimization</em>: Paleoceanography, v.30, 1625-1640.
</p>
<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews
v.190, 190-223.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+tracePeak">tracePeak</a></code>,<code><a href="#topic+trackPeak">trackPeak</a></code>,<code><a href="#topic+timeOpt">timeOpt</a></code>,<code><a href="#topic+timeOptSim">timeOptSim</a></code>, and <code><a href="#topic+eTimeOptTrack">eTimeOptTrack</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a test signal with precession and eccentricity
ex=cycles(freqs=c(1/405.6795,1/130.719,1/123.839,1/98.86307,1/94.87666,1/23.62069, 
1/22.31868,1/19.06768,1/18.91979),end=4000,dt=5)

# convert to meters with a linearly increasing sedimentation rate from 0.01 m/kyr to 0.03 m/kyr
ex=sedRamp(ex,srstart=0.01,srend=0.03)

# interpolate to median sampling interval
ex=linterp(ex)

# evaluate precession &amp; eccentricity power, and precession modulations
res=eTimeOpt(ex,win=20,step=1,fit=1,output=1)

# extract the optimal fits for the power optimization
sedrates=eTimeOptTrack(res[2])

# extract the optimal fits for the envelope*power optimization
sedrates=eTimeOptTrack(res[3])

# you can also interactively track the results using functions 'trackPeak' and 'tracePeak'
#  evaluate the results from the power optimization
sedrates=tracePeak(res[2])
sedrates=trackPeak(res[2])

#  evaluate the results from the envelope*power optimization
sedrates=tracePeak(res[3])
sedrates=trackPeak(res[3])

# evaluate precession &amp; eccentricity power, and short-eccentricity modulations
eTimeOpt(ex,win=20,step=1,fit=2,output=0)

## End(Not run)
</code></pre>

<hr>
<h2 id='eTimeOptTrack'>Track eTimeOpt r2 maxima</h2><span id='topic+eTimeOptTrack'></span>

<h3>Description</h3>

<p>Track eTimeOpt r2 maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eTimeOptTrack(res,threshold=0,ydir=-1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eTimeOptTrack_+3A_res">res</code></td>
<td>
<p>eTimeOpt r2 results. Must have the following format: column 
1=sedimentation rate; remaining columns (2 to n)=r2; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eTimeOpt.</p>
</td></tr>
<tr><td><code id="eTimeOptTrack_+3A_threshold">threshold</code></td>
<td>
<p>Threshold r2-value for analysis and plotting.</p>
</td></tr>
<tr><td><code id="eTimeOptTrack_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr>
<tr><td><code id="eTimeOptTrack_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="eTimeOptTrack_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see function eTimeOpt for details.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in 
paleoclimate data: An inverse approach for astrochronologic testing and time scale 
optimization</em>: Paleoceanography, v.30, 1625-1640.
</p>
<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews
v.190, 190-223.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+eTimeOpt">eTimeOpt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate a test signal with precession and eccentricity
ex=cycles(freqs=c(1/405.6795,1/130.719,1/123.839,1/98.86307,1/94.87666,1/23.62069, 
1/22.31868,1/19.06768,1/18.91979),end=4000,dt=5)

# convert to meters with a linearly increasing sedimentation rate from 0.01 m/kyr to 0.03 m/kyr
ex=sedRamp(ex,srstart=0.01,srend=0.03)

# interpolate to median sampling interval
ex=linterp(ex)

# evaluate precession &amp; eccentricity power, and precession modulations
res=eTimeOpt(ex,win=20,step=1,fit=1,output=1)

# extract the optimal fits for the power optimization
sedrates=eTimeOptTrack(res[2])

# extract the optimal fits for the envelope*power optimization
sedrates=eTimeOptTrack(res[3])

# you can also interactively track the results using functions 'trackPeak' and 'tracePeak'
#  evaluate the results from the power optimization
sedrates=trackPeak(res[2])
sedrates=tracePeak(res[2])

#  evaluate the results from the envelope*power optimization optimization
sedrates=trackPeak(res[3])
sedrates=tracePeak(res[3])

## End(Not run)
</code></pre>

<hr>
<h2 id='etp'>Generate eccentricity-tilt-precession models</h2><span id='topic+etp'></span>

<h3>Description</h3>

<p>Calculate eccentricity-tilt-precession time series using the theoretical astronomical solutions.
By default, the Laskar et al. (2004) solutions will be downloaded. Alternatively, one can
specify the astronomical solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etp(tmin=NULL,tmax=NULL,dt=1,eWt=1,oWt=1,pWt=1,esinw=T,solution=NULL,standardize=T,
     genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etp_+3A_tmin">tmin</code></td>
<td>
<p>Start time (ka before present, J2000) for ETP. Default value is 0 ka, unless the data frame 'solution' is specified, in which case the first time datum is used.</p>
</td></tr>
<tr><td><code id="etp_+3A_tmax">tmax</code></td>
<td>
<p>End time (ka before present, J2000) for ETP. Default value is 1000 ka, unless the data frame 'solution' is specified, in which case the last time datum is used.</p>
</td></tr>
<tr><td><code id="etp_+3A_dt">dt</code></td>
<td>
<p>Sample interval for ETP (ka). Minimum = 1 ka.</p>
</td></tr>
<tr><td><code id="etp_+3A_ewt">eWt</code></td>
<td>
<p>Relative weight applied to eccentricity solution.</p>
</td></tr>
<tr><td><code id="etp_+3A_owt">oWt</code></td>
<td>
<p>Relative weight applied to obliquity solution.</p>
</td></tr>
<tr><td><code id="etp_+3A_pwt">pWt</code></td>
<td>
<p>Relative weight applied to precession solution.</p>
</td></tr>
<tr><td><code id="etp_+3A_esinw">esinw</code></td>
<td>
<p>Use e*sinw in ETP calculation? (T or F). If set to false, sinw is used.</p>
</td></tr>
<tr><td><code id="etp_+3A_solution">solution</code></td>
<td>
<p>A data frame containing the astronomical solution to use. The data frame must have four columns: Time (ka, positive and increasing), Precession Angle, Obliquity, Eccentricity.</p>
</td></tr>
<tr><td><code id="etp_+3A_standardize">standardize</code></td>
<td>
<p>Standardize (subtract mean, divide by standard deviation) precession, obliquity and eccentricity series before applying weight and combining? (T or F)</p>
</td></tr>
<tr><td><code id="etp_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F).</p>
</td></tr>
<tr><td><code id="etp_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: If you plan to repeatedly execute the etp function, it is advisable to download the 
astronomical solution once using the function getLaskar.
</p>
<p>Note: It is common practice to construct ETP models that have specified variance ratios
(e.g., 1:1:1 or 1:0.5:0.5) for eccentricity, obliquity and precession. In order to 
construct such models, it is necessary to choose 'standardize=T', and to set the individual 
weights (eWt, oWt, pWt) to the square root of the desired variance contribution.
</p>


<h3>Value</h3>

<p>Eccentricity + tilt + precession.
</p>


<h3>References</h3>

 
<p>Laskar, J., Robutel, P., Joutel, F., Gastineau, M., Correia, A.C.M., Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: Astron. Astrophys., Volume 428, 261-285.
</p>
<p>Laskar, J., Fienga, A., Gastineau, M., Manche, H., 2011, 
<em>La2010: A new orbital solution for the long-term motion of the Earth</em>: Astron. Astrophys., Volume 532, A89.
</p>
<p>Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A.: 2011,
<em>Strong chaos induced by close encounters with Ceres and Vesta</em>: Astron. Astrophys., Volume 532, L4.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getLaskar">getLaskar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# create an ETP model from 10000 ka to 20000 ka, with a 5 ka sampling interval
# this will automatically download the astronomical solution
ex=etp(tmin=10000,tmax=20000,dt=5)

# alternatively, download the astronomical solution first
ex2=getLaskar()
ex=etp(tmin=10000,tmax=20000,dt=5,solution=ex2)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='extract'>Extract record from EHA time-frequency output or eAsm output</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>Extract record from EHA time-frequency output or eAsm output: Use interactive graphical interface to identify record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(spec,get=NULL,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,h=6,w=4,ydir=1,pl=0,
        ncolors=100,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_spec">spec</code></td>
<td>
<p>Time-frequency spectral results to evaluate, or alternatively, eAsm results to evaluate. For time-frequency results, must have the following format: column 
1=frequency; remaining columns (2 to n)=power, amplitude or probability; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha. For eAsm results, must have the following format: column 
1=sedimentation rate; remaining columns (2 to n)=Ho-SL or ASM; titles for columns 2 to n must be the location (depth or height). </p>
</td></tr>
<tr><td><code id="extract_+3A_get">get</code></td>
<td>
<p>Record to extract (height/depth/time). If no value given, graphical interface is activated.</p>
</td></tr>
<tr><td><code id="extract_+3A_xmin">xmin</code></td>
<td>
<p>Minimum frequency or sedimentation rate for PLOTTING.</p>
</td></tr>
<tr><td><code id="extract_+3A_xmax">xmax</code></td>
<td>
<p>Maximum frequency or sedimentation rate for PLOTTING.</p>
</td></tr>
<tr><td><code id="extract_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height for PLOTTING.</p>
</td></tr>
<tr><td><code id="extract_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height for PLOTTING.</p>
</td></tr> 
<tr><td><code id="extract_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="extract_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="extract_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr> 
<tr><td><code id="extract_+3A_pl">pl</code></td>
<td>
<p>An option for the color plots (0=do nothing; 1=plot log of value [useful for plotting power], 2=normalize to maximum value [useful for plotting amplitude]).</p>
</td></tr> 
<tr><td><code id="extract_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="extract_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="extract_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> </p>

<hr>
<h2 id='flip'>Flip stratigraphic series</h2><span id='topic+flip'></span>

<h3>Description</h3>

<p>Flip the stratigraphic order of your data series (e.g., convert stratigraphic depth series to 
height series, relative to a defined datum.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip(dat,begin=0,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="flip_+3A_begin">begin</code></td>
<td>
<p>Depth/height value to assign to (new) first stratigraphic datum.</p>
</td></tr>
<tr><td><code id="flip_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="flip_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='freq2sedrate'>Convert record of local spatial frequency (from EHA) to sedimentation rate curve</h2><span id='topic+freq2sedrate'></span>

<h3>Description</h3>

<p>Convert record of local spatial frequency (from EHA) to sedimentation rate curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq2sedrate(freqs,period=NULL,ydir=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq2sedrate_+3A_freqs">freqs</code></td>
<td>
<p>Data frame containing depth/height in first column (meters) and spatial frequencies in second column (cycles/m)</p>
</td></tr>
<tr><td><code id="freq2sedrate_+3A_period">period</code></td>
<td>
<p>Temporal period of spatial frequency (ka)</p>
</td></tr>
<tr><td><code id="freq2sedrate_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth,height). -1 = values increase downwards (slower), 1 = values increase upwards </p>
</td></tr>
<tr><td><code id="freq2sedrate_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="freq2sedrate_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='gausTaper'>Apply Gaussian taper to stratigraphic series</h2><span id='topic+gausTaper'></span>

<h3>Description</h3>

<p>Apply a Gaussian taper to a stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gausTaper(dat,alpha=3,rms=T,demean=T,detrend=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gausTaper_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tapering. First column should be location (e.g., depth), second column should be data value. If no data is identified, will output a 256 point taper to evaluate the spectral properties of the window.</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_alpha">alpha</code></td>
<td>
<p>Gaussian window parameter: alpha is 1/stdev, a measure of the width of the Dirichlet kernel. Larger values decrease the width of data window, reduce discontinuities, and increase width of the transform. Choose alpha &gt;= 2.5.</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_rms">rms</code></td>
<td>
<p>Normalize taper to RMS=1 to preserve power for white process? (T or F)</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="gausTaper_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Harris, 1978,
<em>On the use of windows for harmonic analysis with the discrete Fourier transform</em>: Proceedings of the IEEE, v. 66, p. 51-83.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cosTaper">cosTaper</a></code>, <code><a href="#topic+dpssTaper">dpssTaper</a></code>, and <code><a href="#topic+hannTaper">hannTaper</a></code> </p>

<hr>
<h2 id='getColor'>Query R for color information</h2><span id='topic+getColor'></span>

<h3>Description</h3>

<p>Query R for color information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColor(color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColor_+3A_color">color</code></td>
<td>
<p>The name of the color you are interested in, in quotes.</p>
</td></tr>
</table>

<hr>
<h2 id='getData'>Download file from astrochron data server</h2><span id='topic+getData'></span>

<h3>Description</h3>

<p>Download data file from astrochron server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(dat="1262-a*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_dat">dat</code></td>
<td>
<p>A character string that specifies the data file to download. At present 
there are ten options: &quot;1262-a*&quot; , &quot;926B-18O&quot;, &quot;graptolite&quot;, &quot;Xiamaling-CuAl&quot;,
&quot;607-18O&quot; , &quot;AEB-18O&quot; , &quot;Newark-rank&quot;, &quot;CDL-rank&quot;, &quot;DVCP2017-18O&quot;, &quot;AND2A-clast&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='getLaskar'>Download Laskar et al. (2004, 2011a, 2011b) astronomical solutions</h2><span id='topic+getLaskar'></span>

<h3>Description</h3>

<p>Download Laskar et al. (2004, 2011a, 2011b) astronomical solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLaskar(sol="la04",verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLaskar_+3A_sol">sol</code></td>
<td>
<p>A character string that specifies the astronomical solution to download: &quot;la04&quot;,&quot;la10a&quot;,&quot;la10b&quot;,&quot;la10c&quot;,&quot;la10d&quot;,&quot;la11&quot;,&quot;insolation&quot;</p>
</td></tr>
<tr><td><code id="getLaskar_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>la04 : three columns containing precession angle, obliquity, and eccentricity of Laskar et al. (2004)
</p>
<p>la10a : one column containing the la10a eccentricity solution of Laskar et al. (2011a)
</p>
<p>la10b : one column containing the la10b eccentricity solution of Laskar et al. (2011a)
</p>
<p>la10c : one column containing the la10c eccentricity solution of Laskar et al. (2011a)
</p>
<p>la10d : one column containing the la10d eccentricity solution of Laskar et al. (2011a)
</p>
<p>la11 : one column containing the la11 eccentricity solution of Laskar et al. (2011b; please also cite 2011a)
</p>
<p>insolation : one column containing insolation at 65 deg North (W/m^2) during summer solstice, from Laskar et al. (2004)
</p>


<h3>References</h3>

<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>
<p>Laskar, J., Fienga, A., Gastineau, M., Manche, H., 2011a, 
<em>La2010: A new orbital solution for the long-term motion of the Earth</em>: Astron. Astrophys., Volume 532, A89.
</p>
<p>Laskar, J., Gastineau, M., Delisle, J.-B., Farres, A., Fienga, A.: 2011b,
<em>Strong chaos induced by close encounters with Ceres and Vesta, Astron</em>: Astrophys., Volume 532, L4.
</p>

<hr>
<h2 id='hannTaper'>Apply Hann taper to stratigraphic series</h2><span id='topic+hannTaper'></span>

<h3>Description</h3>

<p>Apply a Hann (Hanning) taper to a stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hannTaper(dat,rms=T,demean=T,detrend=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hannTaper_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tapering. First column should be location (e.g., depth), second column should be data value. If no data is identified, will output a 256 point taper to evaluate the spectral properties of the window.</p>
</td></tr>
<tr><td><code id="hannTaper_+3A_rms">rms</code></td>
<td>
<p>Normalize taper to RMS=1 to preserve power for white process? (T or F)</p>
</td></tr>
<tr><td><code id="hannTaper_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="hannTaper_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="hannTaper_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="hannTaper_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+cosTaper">cosTaper</a></code>, <code><a href="#topic+dpssTaper">dpssTaper</a></code>, and <code><a href="#topic+gausTaper">gausTaper</a></code> </p>

<hr>
<h2 id='headn'>List column numbers for each variable</h2><span id='topic+headn'></span>

<h3>Description</h3>

<p>Execute 'head' function, with column numbers indicated for each variable. (useful for functions such as 'autopl')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headn(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headn_+3A_dat">dat</code></td>
<td>
<p>Your data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='hilbert'>Hilbert transform of stratigraphic series</h2><span id='topic+hilbert'></span>

<h3>Description</h3>

<p>Calculate instantaneous amplitude (envelope) and phase via Hilbert Transform of stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(dat,phase=F,padfac=2,demean=T,detrend=F,output=T,addmean=F,genplot=T,check=T,
        verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to Hilbert Transform. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="hilbert_+3A_phase">phase</code></td>
<td>
<p>Calculate instantaneous phase? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="hilbert_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_output">output</code></td>
<td>
<p>Return results as new data frame? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_addmean">addmean</code></td>
<td>
<p>Add mean value to instantaneous amplitude? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="hilbert_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="hilbert_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with 3 precession terms and noise
ex &lt;- cycles(noisevar=.0004,dt=5)
# bandpass precession terms using cosine-tapered window 
res_ex &lt;- bandpass(ex,flow=0.038,fhigh=0.057,win=2,p=.4)
# hilbert transform
hil_ex &lt;- hilbert(res_ex)
</code></pre>

<hr>
<h2 id='idPts'>Interactively identify points in plot</h2><span id='topic+idPts'></span>

<h3>Description</h3>

<p>Interactively identify points in x,y plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idPts(dat1,dat2=NULL,ptsize=1,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,
       logx=F,logy=F,plotype=1,annotate=1,output=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idPts_+3A_dat1">dat1</code></td>
<td>
<p>Data frame with one, two or three columns. If one column, dat2 must also be specified. If three columns, the data frame is assumed to represent a stratigraphic series, and the first column should be depth, height or time.</p>
</td></tr>
<tr><td><code id="idPts_+3A_dat2">dat2</code></td>
<td>
<p>Data frame with one column.</p>
</td></tr>
<tr><td><code id="idPts_+3A_ptsize">ptsize</code></td>
<td>
<p>Size of plotted points.</p>
</td></tr>
<tr><td><code id="idPts_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value (column 1) to plot</p>
</td></tr>
<tr><td><code id="idPts_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value (column 1) to plot</p>
</td></tr>  
<tr><td><code id="idPts_+3A_ymin">ymin</code></td>
<td>
<p>Minimum y-value (column 2) to plot</p>
</td></tr>
<tr><td><code id="idPts_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-value (column 2) to plot</p>
</td></tr>  
<tr><td><code id="idPts_+3A_logx">logx</code></td>
<td>
<p>Plot x-axis using logarithmic scaling? (T or F)</p>
</td></tr>
<tr><td><code id="idPts_+3A_logy">logy</code></td>
<td>
<p>Plot y-axis using logarithmic scaling? (T or F)</p>
</td></tr>
<tr><td><code id="idPts_+3A_plotype">plotype</code></td>
<td>
<p>Type of plot to generate: 1= points and lines, 2 = points, 3 = lines</p>
</td></tr>
<tr><td><code id="idPts_+3A_annotate">annotate</code></td>
<td>
<p>Annotate plot with text indicating coordinates?: 0=none, 1=annotate above point, 2=annotate below point</p>
</td></tr>
<tr><td><code id="idPts_+3A_output">output</code></td>
<td>
<p>Return identified points as a data frame? (0) no, (1) return x and y, (2) return index, x and y. If dat1 contains three columns, option 2 will return index, location, x and y.</p>
</td></tr>
<tr><td><code id="idPts_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+delPts">delPts</a></code>, <code><a href="#topic+iso">iso</a></code>, <code><a href="#topic+trim">trim</a></code> and <code><a href="#topic+trimAT">trimAT</a></code> </p>

<hr>
<h2 id='imbrie'>Imbrie and Imbrie (1980) ice sheet model</h2><span id='topic+imbrie'></span>

<h3>Description</h3>

<p>An implementation of the Imbrie and Imbrie (1980) ice sheet model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbrie(insolation=NULL,Tm=17,b=0.6,times=NULL,initial=0,burnin=100,standardize=T,
       output=T,genplot=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbrie_+3A_insolation">insolation</code></td>
<td>
<p>Insolation, in ka (negative for future, positive for past). Default is insolation over the past 1000 ka from 65 deg. North, 21 June.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_tm">Tm</code></td>
<td>
<p>Vector of mean time constants in ka. Default is 17 ka.  The order of the Tm values should match vectors b and times.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_b">b</code></td>
<td>
<p>Vector of nonlinearity coefficient (a value ranging from 0 to 1). Default is 0.6. The order of the b values should match vectors Tm and times.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_times">times</code></td>
<td>
<p>Vector of start times for each Tm and b listed above. Leave as NULL if you only need to model one Tm and b value.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_initial">initial</code></td>
<td>
<p>Initial value for ice volume, relative to centered record. Default is 0.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_burnin">burnin</code></td>
<td>
<p>Number of points for model burn-in. This is required to achieve stable model results. Default is 100 points.</p>
</td></tr>
<tr><td><code id="imbrie_+3A_standardize">standardize</code></td>
<td>
<p>Standardize model output to maximum value of one and minimum value of zero? (T or F)</p>
</td></tr>  
<tr><td><code id="imbrie_+3A_output">output</code></td>
<td>
<p>Output model results? (T or F)</p>
</td></tr>
<tr><td><code id="imbrie_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (1) plot insolation and ice volume series, (2) plot animated insolation, ice volume and phase portrait.)</p>
</td></tr>
<tr><td><code id="imbrie_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will implement the ice volume model of Imbrie and Imbrie (1980), following the conventions of Paillard et al. (1996).
</p>
<p>When using the 'times' vector, consider the following example:
</p>
<p>times= c(500,1000)
</p>
<p>Tm=c(15,5)
</p>
<p>b=c(0.6,0.3)
</p>
<p>In this case, a Tm of 15 (b of 0.6) will be applied to model from 0-500 ka,
and a Tm of 5 (b of 0.3) will be applied to model 500-1000 ka.
</p>


<h3>References</h3>

<p>Imbrie, J., and Imbrie, J.Z., (1980),
<em>Modeling the Climatic Response to Orbital Variations</em>: Science, v. 207, p. 943-953.
</p>
<p>Lisiecki, L. E., and M. E. Raymo, 2005, 
<em>A Pliocene-Pleistocene stack of 57 globally distributed benthic d18O records</em>, Paleoceanography, 20, PA1003, doi:10.1029/2004PA001071.
</p>
<p>Paillard, D., L. Labeyrie and P. Yiou, (1996),
<em>Macintosh program performs time-series analysis</em>: Eos Trans. AGU, v. 77, p. 379.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make a very simple forcing (on/off)
forcing=cycles(0,end=300)
forcing[50:150,2]=1
plot(forcing,type="l")

# use this forcing to drive the imbrie ice model
# set b=0, Tm = 1
imbrie(forcing,b=0,Tm=1,output=F)

# let's view the evolution of the ice sheet
imbrie(forcing,b=0,Tm=1,output=F,genplot=2)

# now increase the response time
imbrie(forcing,b=0,Tm=10,output=F,genplot=2)

# now model slow growth, fast decay
imbrie(forcing,b=0.5,Tm=10,output=F,genplot=2)

# now make a 100 ka cyclic forcing
forcing=cycles(1/100,end=300)
imbrie(forcing,b=0,Tm=1,output=F,genplot=2)
imbrie(forcing,b=0,Tm=10,output=F,genplot=2)
imbrie(forcing,b=0.5,Tm=10,output=F,genplot=2)
# show burn-in
imbrie(forcing,b=0.5,Tm=10,output=F,genplot=2,burnin=0)

# now examine Malutin Milankovitch's hypothesis: 65 deg N, summer solstice
imbrie(b=0.5,Tm=10,output=F,genplot=2,burnin=900)

# use the ice model output to make a synthetic stratigraphic section
res=imbrie(b=0.5,T=10,output=T,genplot=1,burnin=100)
synthStrat(res,clip=F)

# generate ice model for last 5300 ka, using 65 deg. N insolation, 21 June
# allow b and Tm values to change as in Lisiecki and Raymo (2005):
insolation=getLaskar("insolation")
insolation=iso(insolation,xmin=0,xmax=5300)
#  b is 0.3 from 5300 to 3000 ka, then linearly increases to 0.6 between 3000 and 1500 ka.
#  b is 0.6 from 1500 ka to present.
set_b=linterp(cb(c(1500,3000),c(0.6,0.3)),dt=1)
set_b=rbind(set_b,c(5400,0.3))
#  Tm is 5 ka from 5300 to 3000 ka, then linearly increases to 15 ka between 3000 and 1500 ka.
#  Tm is 15 ka from 1500 ka to present.
set_Tm=linterp(cb(c(1500,3000),c(15,5)),dt=1)
set_Tm=rbind(set_Tm,c(5400,5))
# now run model
ex=imbrie(insolation=insolation,Tm=set_Tm[,2],b=set_b[,2],times=set_b[,1])
# time-frequency analysis of model result
eha(ex,fmax=0.1,win=500,step=10,pad=5000,genplot=4,pl=2)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='impulseResponse'>Impulse response function calculation</h2><span id='topic+impulseResponse'></span>

<h3>Description</h3>

<p>Calculate the analytical response function from an impulse forcing using the 1-D advection diffusion model proposed 
in Schink and Guinasso (1975) to model the bioturbation impact on climate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulseResponse(G, ML = NULL, v = NULL, nt = 500, genplot = FALSE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impulseResponse_+3A_g">G</code></td>
<td>
<p>Bioturbation parameter. G = D/ML/v</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_ml">ML</code></td>
<td>
<p>Mix layer depth (cm)</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_v">v</code></td>
<td>
<p>Sedimentation rate (cm/kyr)</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_nt">nt</code></td>
<td>
<p>Number of steps after the signal is deposited.</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fc Impulse response function
</p>


<h3>References</h3>

<p>Guinasso, N.L. and Schinck, D.R., 1975, <em>Quantitative estimates of biological mixing rates in abyssal sediments</em>, J. Geophys. Res., 80, 3032-3043.
</p>
<p>Goreau, T.J., 1977, <em>Quantitative effects of sediment mixing on stratigraphy and biogeochemistry: a signal theory approach</em>, Nature, 256, 730-732.
</p>
<p>Goreau, T.J., 1980, <em>Frequency sensitivity of the deep-sea climatic record</em>, Nature, 287, 620-622.
</p>
<p>Liu, H., Meyers, S.R., and Marcott, S.A., 2021, <em>Unmixing dee-sea paleoclimate records: A study on bioturbation effects through convolution and deconvolution</em>, Earth and Planetary Science Letters, 564, 116883.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- 4
ML &lt;- 10
v &lt;- 1
# take a look at the IRF 
impulseResponse(G=4, ML = 10, v = 1, genplot = TRUE)
</code></pre>

<hr>
<h2 id='insoDiff'>insolation difference map using Laskar et al. (2004) insolation calculations</h2><span id='topic+insoDiff'></span>

<h3>Description</h3>

<p>Generate map that show difference in insolation between two times
using Laskar et al. (2004) insolation calculations.  
This is a wrapper function to calculate insolation using the palinsol package, 
following astrochron syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>insoDiff(t1,t2,S0=1365,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insoDiff_+3A_t1">t1</code></td>
<td>
<p>Time 1, in kyr (negative for future, positive for past; valid from -21000 to 51000)</p>
</td></tr>
<tr><td><code id="insoDiff_+3A_t2">t2</code></td>
<td>
<p>Time 2, in kyr (negative for future, positive for past; valid from -21000 to 51000)</p>
</td></tr>
<tr><td><code id="insoDiff_+3A_s0">S0</code></td>
<td>
<p>Solar constant, W/m^2</p>
</td></tr>    
<tr><td><code id="insoDiff_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper function generates maps with insolation calculations based on 
the Laskar et al. (2004) astronomical parameters, using the 'palinsol' package (Crucifix, 2016).
</p>


<h3>References</h3>

<p>Crucifix, M., 2016,
<em>palinsol: Insolation for Palaeoclimate Studies. R package version 0.93</em>: https://CRAN.R-project.org/package=palinsol
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>

<hr>
<h2 id='insoMap'>generate an insolation map using Laskar et al. (2004) insolation calculations</h2><span id='topic+insoMap'></span>

<h3>Description</h3>

<p>Generate insolation maps using Laskar et al. (2004) insolation calculations.  
This is a wrapper function to calculate insolation using the palinsol package, 
following astrochron syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>insoMap(t=0,pick=0,S0=1365,output=F,verbose=T) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insoMap_+3A_t">t</code></td>
<td>
<p>Time for evaluation, in kyr (negative for future, positive for past; valid from -21000 to 51000)</p>
</td></tr>
<tr><td><code id="insoMap_+3A_pick">pick</code></td>
<td>
<p>Interactively pick (1) latitude to examine seasonal insolation at that latitude, or (2) day to examine insolation across latitude</p>
</td></tr>
<tr><td><code id="insoMap_+3A_s0">S0</code></td>
<td>
<p>Solar constant, W/m^2</p>
</td></tr>    
<tr><td><code id="insoMap_+3A_output">output</code></td>
<td>
<p>Output insolation matrix (if pick=0) or selected insolation transect (if pick = 1 or 2)? (T or F)</p>
</td></tr>
<tr><td><code id="insoMap_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper function generates maps with insolation calculations based on 
the Laskar et al. (2004) astronomical parameters, using the 'palinsol' package (Crucifix, 2016).
</p>
<p>Option 'pick' will allow you to extract insolation by (1) latitude or (2) season.
</p>


<h3>References</h3>

<p>Crucifix, M., 2016,
<em>palinsol: Insolation for Palaeoclimate Studies. R package version 0.93</em>: https://CRAN.R-project.org/package=palinsol
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>

<hr>
<h2 id='insoSeries'>Laskar et al. (2004) insolation calculations</h2><span id='topic+insoSeries'></span>

<h3>Description</h3>

<p>Laskar et al. (2004) insolation calculations.  This is a wrapper function to calculate 
insolation using the palinsol package, following astrochron syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>insoSeries(tmin=0,tmax=1000,dt=1,opt=1,long=90,lat=65,threshold=400,l1=0,l2=70,S0=1365,
         genplot=TRUE,verbose=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insoSeries_+3A_tmin">tmin</code></td>
<td>
<p>Minimum time for evaluation, in kyr (negative for future, positive for past; valid from -21000 to 51000)</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_tmax">tmax</code></td>
<td>
<p>Maximum time for evaluation, in kyr (negative for future, positive for past; valid from -21000 to 51000)</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_dt">dt</code></td>
<td>
<p>Sampling interval in kyr. Must be &gt;= 1</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_opt">opt</code></td>
<td>
<p>1=Calculate daily mean insolation for given day and latitude; 2=calculate caloric insolation for given latitude; 3=calculate integrated insolation for given latitude; 4=calculating integrated insolation for given latitude, with threshold</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_long">long</code></td>
<td>
<p>True solar longitude, in degrees, 0-360</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_lat">lat</code></td>
<td>
<p>Latitude on the Earth for evaluation, in degrees, -90 to 90</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_threshold">threshold</code></td>
<td>
<p>Threshold insolation, in W/m^2</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_l1">l1</code></td>
<td>
<p>Lower true solar longitude bound of the time-integral, in degrees, 0-360</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_l2">l2</code></td>
<td>
<p>Upper true solar longitude bound of the time-integral, in degrees, 0-360</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_s0">S0</code></td>
<td>
<p>Solar constant, W/m^2</p>
</td></tr>    
<tr><td><code id="insoSeries_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="insoSeries_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper function performs four different types of insolation calculations based on 
the Laskar et al. (2004) astronomical parameters, using the 'palinsol' package (Crucifix, 2016).
</p>
<p>The following 'palinsol' functions are used:
</p>
<p>opt 1: Insol - Calculate Mean Insolation for Given Day and Latitude
</p>
<p>opt 2: calins - Calculate Caloric Insolation for Given Latitude (Milankovitch; Berger, 1978)
</p>
<p>opt 3: Insol_l1l2 - Calculate Integrated Insolation for Given Latitude (Berger et al., 2010)
</p>
<p>opt 4: thrins - Calculate Integrated Insolation for Given Latitude, with Threshold (Huybers and Tziperman, 2008)
</p>
<p>la04 -  Calculate astronomical parameters (Laskar et al., 2004)
</p>
<p>Please see those functions for further details.
</p>
<p>If opt 1 is selected: specify 'long' and 'lat'
</p>
<p>If opt 2 is selected: specify 'lat'
</p>
<p>If opt 3 is selected: specify 'lat', 'l1' and 'l2'
</p>
<p>If opt 4 is selected: specify 'lat' and 'threshold'
</p>
<p>APPROXIMATE CONVENTIONAL DATES FOR A GIVEN MEAN LONGITUDE (long):
</p>
<p>0: 21 March (equinox)
</p>
<p>30: 21 April
</p>
<p>60: 21 May
</p>
<p>90: 21 June (solstice)
</p>
<p>120: 21 July
</p>
<p>150: 21 August
</p>
<p>180: 21 September (equinox)
</p>
<p>210: 21 October
</p>
<p>240: 21 November
</p>
<p>270: 21 December (solstice)
</p>
<p>300: 21 January
</p>
<p>330: 21 February
</p>


<h3>References</h3>

<p>Berger, A., 1978, 
<em>Long-term variations of caloric insolation resulting from the earth's orbital elements</em>:
Quaternary Research, 9, 139 - 167.
</p>
<p>Berger, A., Loutre, M.F., Yin Q., 2010, 
<em>Total irradiation during any time interval of the year using elliptic integrals</em>:
Quaternary Science Reviews, 29, 1968 - 1982, doi:10.1016/j.quascirev.2010.05.007
</p>
<p>Crucifix, M., 2016,
<em>palinsol: Insolation for Palaeoclimate Studies. R package version 0.93</em>: https://CRAN.R-project.org/package=palinsol
</p>
<p>Huybers, P., Tziperman, E., 2008, 
<em>Integrated summer insolation forcing and 40,000-year glacial cycles: The perspective from an ice-sheet/energy-balance model</em>:
Paleoceanography, 23.
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>

<hr>
<h2 id='integratePower'>Determine the total power within a given bandwidth</h2><span id='topic+integratePower'></span>

<h3>Description</h3>

<p>Determine the total power within a given bandwidth, and also the ratio of this power to the total power in the spectrum (or up to a specified frequency). If bandwidth is not specified, generate interactive plots for bandwidth selection. For use with the function eha, integratePower can process spectrograms (time-frequency) or single spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integratePower(spec,flow=NULL,fhigh=NULL,fmax=NULL,unity=F,f0=T,xmin=NULL,
               xmax=NULL,ymin=NULL,ymax=NULL,npts=NULL,pad=NULL,ydir=1,
               palette=6,ncolors=100,h=6,w=9,ln=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integratePower_+3A_spec">spec</code></td>
<td>
<p>Spectral results to evaluate. If the data frame contains time-frequency results,
it must have the following format: column 1=frequency; remaining columns (2 to n)=power; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha. If the data frame contains
one spectrum, it must have the following format: column 1=frequency, column 2=power.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_flow">flow</code></td>
<td>
<p>Low frequency cutoff for integration. If flow or fhigh are not specified, interactive plotting is activated.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cutoff for integration. If flow or fhigh are not specified, interactive plotting is activated.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_fmax">fmax</code></td>
<td>
<p>Integrate total power up to this frequency.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_unity">unity</code></td>
<td>
<p>Normalize spectra such that total variance (up to fmax) is unity. (T of F)</p>
</td></tr>
<tr><td><code id="integratePower_+3A_f0">f0</code></td>
<td>
<p>Is f(0) included in the spectra? (T or F)</p>
</td></tr>
<tr><td><code id="integratePower_+3A_xmin">xmin</code></td>
<td>
<p>Minimum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_xmax">xmax</code></td>
<td>
<p>Maximum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height/time for PLOTTING. Only used if processing time-frequency results.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height/time for PLOTTING. Only used if processing time-frequency results.</p>
</td></tr> 
<tr><td><code id="integratePower_+3A_npts">npts</code></td>
<td>
<p>The number of points in the processed time series window. This is needed for proper spectrum normalization.</p>
</td></tr> 
<tr><td><code id="integratePower_+3A_pad">pad</code></td>
<td>
<p>The total padded length of the processed time series window. This is needed for proper spectrum normalization.</p>
</td></tr> 
<tr><td><code id="integratePower_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards. Only used if processing time-frequency results.</p>
</td></tr> 
<tr><td><code id="integratePower_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="integratePower_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot. Only used if processing time-frequency results.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="integratePower_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>  
<tr><td><code id="integratePower_+3A_ln">ln</code></td>
<td>
<p>Plot natural log of spectral results? (T or F)</p>
</td></tr>
<tr><td><code id="integratePower_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="integratePower_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the normalization used, you may want to preprocess the power spectra prior to integration.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate etp signal over past 10 Ma
ex=etp(tmax=10000)

# evolutive power
pwr=eha(ex,win=500,fmax=.1,pad=2000,output=2,pl=2)

# integrate power from main obliquity term
integratePower(pwr,flow=0.02,fhigh=0.029,npts=501,pad=2000)
</code></pre>

<hr>
<h2 id='iso'>Isolate data from a specified stratigraphic interval</h2><span id='topic+iso'></span>

<h3>Description</h3>

<p>Isolate a section of a uni- or multi-variate stratigraphic data set for further analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso(dat,xmin,xmax,col=2,logx=F,logy=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iso_+3A_dat">dat</code></td>
<td>
<p>Data frame containing stratigraphic variable(s) of interest. First column must be location (e.g., depth).</p>
</td></tr>
<tr><td><code id="iso_+3A_xmin">xmin</code></td>
<td>
<p>Minimum depth/height/time for isolation. If xmin is not specified, it will be selected using a graphical interface.</p>
</td></tr>
<tr><td><code id="iso_+3A_xmax">xmax</code></td>
<td>
<p>Maximum depth/height/time for isolation. If xmax is not specified, it will be selected using a graphical interface.</p>
</td></tr>
<tr><td><code id="iso_+3A_col">col</code></td>
<td>
<p>If you are using the graphical interface to select xmin/xmax, which column would you like to plot? (default = 2).</p>
</td></tr>
<tr><td><code id="iso_+3A_logx">logx</code></td>
<td>
<p>Plot x-axis using logarithmic scaling? (T or F)</p>
</td></tr>
<tr><td><code id="iso_+3A_logy">logy</code></td>
<td>
<p>Plot y-axis using logarithmic scaling? (T or F)</p>
</td></tr>
<tr><td><code id="iso_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="iso_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+delPts">delPts</a></code>, <code><a href="#topic+idPts">idPts</a></code>, <code><a href="#topic+trim">trim</a></code> and <code><a href="#topic+trimAT">trimAT</a></code> </p>

<hr>
<h2 id='linage'>Tune stratigraphic series to an astronomical target using graphical interface</h2><span id='topic+linage'></span>

<h3>Description</h3>

<p>Tune stratigraphic series to an astronomical target using graphical interface similar to Analyseries 'Linage' routine (Paillard et al, 1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linage(dat,target,extrapolate=F,xmin=NULL,xmax=NULL,tmin=NULL,tmax=NULL,size=1,plotype=1,
       output=1,genplot=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linage_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tuning, with two columns. First column is depth/height.</p>
</td></tr>
<tr><td><code id="linage_+3A_target">target</code></td>
<td>
<p>Astronomical tuning target series. First column is time.</p>
</td></tr>
<tr><td><code id="linage_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Extrapolate sedimentation rates above and below 'tuned' interval? (T or F)</p>
</td></tr>
<tr><td><code id="linage_+3A_xmin">xmin</code></td>
<td>
<p>Minimum height/depth to plot.</p>
</td></tr>
<tr><td><code id="linage_+3A_xmax">xmax</code></td>
<td>
<p>Maximum height/depth to plot.</p>
</td></tr>
<tr><td><code id="linage_+3A_tmin">tmin</code></td>
<td>
<p>Minimum time value to plot.</p>
</td></tr>
<tr><td><code id="linage_+3A_tmax">tmax</code></td>
<td>
<p>Maximum time value to plot.</p>
</td></tr>  
<tr><td><code id="linage_+3A_size">size</code></td>
<td>
<p>Multiplicative factor to increase or decrease size of symbols and fonts.</p>
</td></tr>
<tr><td><code id="linage_+3A_plotype">plotype</code></td>
<td>
<p>Type of plot to generate: 1= points and lines, 2 = points, 3 = lines</p>
</td></tr>
<tr><td><code id="linage_+3A_output">output</code></td>
<td>
<p>Return which of the following? 1 = tuned stratigraphic series; 2 = age control points; 3 = tuned stratigraphic series and age control points</p>
</td></tr>
<tr><td><code id="linage_+3A_genplot">genplot</code></td>
<td>
<p>Generate additional summary plots (tuned record, time-space map, sedimentation rates)? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Paillard, D., L. Labeyrie and P. Yiou, 1996),
<em>Macintosh program performs time-series analysis</em>: Eos Trans. AGU, v. 77, p. 379.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Check to see if this is an interactive R session, for compliance with CRAN standards.
# YOU CAN SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

# generate example series with 3 precession terms and noise using function 'cycles'
# then convert from time to space using sedimentation rate that increases from 1 to 7 cm/ka
ex=sedRamp(cycles(start=1,end=400, dt=2,noisevar=.00005),srstart=0.01,srend=0.07)

# create astronomical target series
targ=cycles(start=1,end=400,dt=2)

## manually tune
tuned=linage(ex,targ)

## should you need to flip the direction of the astronomical target series, use function 'cb':
tuned=linage(ex,cb(targ[1]*-1,targ[2]))

}

 
## End(Not run)
</code></pre>

<hr>
<h2 id='linterp'>Piecewise linear interpolation of stratigraphic series</h2><span id='topic+linterp'></span>

<h3>Description</h3>

<p>Interpolate stratigraphic series onto a evenly sampled grid, using piecewise linear interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linterp(dat,dt,start,genplot=T,check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linterp_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for piecewise linear interpolation. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="linterp_+3A_dt">dt</code></td>
<td>
<p>New sampling interval.</p>
</td></tr>
<tr><td><code id="linterp_+3A_start">start</code></td>
<td>
<p>Start interpolating at what time/depth/height value? By default, the first value of the stratigraphic series will be used.</p>
</td></tr>
<tr><td><code id="linterp_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="linterp_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="linterp_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='logT'>Log transformation of stratigraphic series</h2><span id='topic+logT'></span>

<h3>Description</h3>

<p>Log transformation of stratigraphic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logT(dat,c=0,opt=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logT_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for log transformation. Input can have any number of columns desired. If two or more columns are input, the first column must be location (e.g., depth), while remaining columns are data values for transformation.</p>
</td></tr>
<tr><td><code id="logT_+3A_c">c</code></td>
<td>
<p>Constant to add prior to log transformation. Default = 0.</p>
</td></tr>
<tr><td><code id="logT_+3A_opt">opt</code></td>
<td>
<p>(1) use natural logarithm, (2) use log10. Default = 1.</p>
</td></tr>
<tr><td><code id="logT_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F). This is automatically deactivated if more than one variable is transformed.</p>
</td></tr>
<tr><td><code id="logT_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code></p>

<hr>
<h2 id='lowpass'>Lowpass filter stratigraphic series</h2><span id='topic+lowpass'></span>

<h3>Description</h3>

<p>Lowpass filter stratigraphic series using rectangular, Gaussian or tapered cosine window. This function can also be used to highpass filter a record (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowpass(dat,padfac=2,fcut=NULL,win=0,demean=T,detrend=F,addmean=T,alpha=3,p=0.25,
        xmin=0,xmax=Nyq,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowpass_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for lowpass filtering. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_fcut">fcut</code></td>
<td>
<p>Cutoff frequency for lowpass filtering.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_win">win</code></td>
<td>
<p>Window type for bandpass filter: 0 = rectangular , 1= Gaussian, 2= Cosine-tapered window.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="lowpass_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="lowpass_+3A_addmean">addmean</code></td>
<td>
<p>Add mean value to bandpass result? (T or F)</p>
</td></tr>
<tr><td><code id="lowpass_+3A_alpha">alpha</code></td>
<td>
<p>Gaussian window parameter: alpha is 1/stdev, a measure of the width of the Dirichlet kernal. Larger values decrease the width of data window, reduce discontinuities, and increase width of the transform. Choose alpha &gt;= 2.5.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_p">p</code></td>
<td>
<p>Cosine-tapered window parameter: p is the percent of the data series tapered (choose 0-1).</p>
</td></tr>
<tr><td><code id="lowpass_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="lowpass_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, <code><a href="#topic+noLow">noLow</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code>, and <code><a href="#topic+taner">taner</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 405 ka, 100 ka, 40ka, and 20 ka, plus noise
ex=cycles(freqs=c(1/405,1/100,1/40,1/20),end=1000,dt=5,noisevar=.1)

# lowpass filter eccentricity terms using cosine-tapered window
lowpass_ex=lowpass(ex,fcut=.02,win=2,p=.4)

# highpass filter obliquity and precession terms using cosine-tapered window
#  if you'd like the final notch filtered record to be centered on the mean proxy 
#  value, set addmean=FALSE
highpass_ex=lowpass(ex,fcut=.02,win=2,p=.4,addmean=FALSE)
highpass_ex[2] &lt;- ex[2]-highpass_ex[2]
pl(2)
plot(ex,type="l",main="Eccentricity+Obliquity+Precession")
plot(highpass_ex,type="l",main="Obliquity+Precession highpassed signal")

</code></pre>

<hr>
<h2 id='lowspec'>Robust Locally-Weighted Regression Spectral Background Estimation</h2><span id='topic+lowspec'></span>

<h3>Description</h3>

<p>LOWSPEC: Robust Locally-Weighted Regression Spectral Background Estimation (Meyers, 2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowspec(dat,decimate=NULL,tbw=3,padfac=5,detrend=F,siglevel=0.9,setrho,
         lowspan,b_tun,output=0,CLpwr=T,xmin,xmax,pl=1,sigID=T,genplot=T,
         verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowspec_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for LOWSPEC. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_decimate">decimate</code></td>
<td>
<p>Decimate statigraphic series to have this sampling interval (via piecewise linear interpolation). By default, no decimation is performed.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product (2 or 3 permitted)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? This detrending is performed following AR1 prewhitening. (T or F)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_siglevel">siglevel</code></td>
<td>
<p>Significance level for peak identification. (0-1)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_setrho">setrho</code></td>
<td>
<p>Define AR1 coefficient for pre-whitening (otherwise calculated). If set to 0, no pre-whitening is applied.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_lowspan">lowspan</code></td>
<td>
<p>Span for LOWESS smoothing of prewhitened signal, usually fixed to 1. If using value &lt;1, the method is overly conservative with a reduced false positive rate.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_b_tun">b_tun</code></td>
<td>
<p>Robustness weight parameter for LOWSPEC. By default, this will be estimated internally.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_output">output</code></td>
<td>
<p>What should be returned as a data frame? (0=nothing; 1=pre-whitened spectrum + harmonic F-test CL + LOWSPEC background + LOWSPEC CL + 90%-99% LOWSPEC power levels; 2=sig peaks)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_clpwr">CLpwr</code></td>
<td>
<p>Plot LOWSPEC noise confidence levels on power spectrum? (T or F)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="lowspec_+3A_pl">pl</code></td>
<td>
<p>Power spectrum plotting: (1) linear frequency-log spectral power, (2) linear frequency-linear spectral power (3) log frequency-log spectral power, (4) log frequency-linear spectral power</p>
</td></tr>
<tr><td><code id="lowspec_+3A_sigid">sigID</code></td>
<td>
<p>Identify significant frequencies on power and probabilty plots? (T or F)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="lowspec_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>LOWSPEC is a 'robust' method for spectral background estimation, designed for the 
identification of potential astronomical signals that are imbedded in red noise (Meyers, 2012). 
The complete algoritm implemented here is as follows: (1) initial pre-whitening with AR1 
filter (default) or other filter as appropriate (e.g., see function prewhiteAR), (2) power spectral 
estimation via the multitaper method (Thomson, 1982), (3) robust locally weighted estimation of 
the spectral background using the LOWESS-based (Cleveland, 1979) procedure of Ruckstuhl et al. (2001), 
(4) assignment of confidence levels using a Chi-square distribution. 
</p>
<p>NOTE: If you choose to pre-whiten before running LOWSPEC (rather than using the default AR1 pre-whitening), 
specify setrho=0.
</p>
<p>Candidiate astronomical cycles are subsequently identified via isolation of those frequencies 
that achieve the required (e.g., 90 percent) LOWSPEC confidence level and MTM harmonic F-test 
confidence level. Allowance is made for the smoothing inherent in the MTM power spectral estimate 
as compared to the MTM harmonic spectrum. That is, an F-test peak is reported if it achieves the 
required MTM harmonic confidence level, while also achieving the required LOWSPEC confidence level 
within +/- half the power spectrum bandwidth resolution. One additional criterion is included to 
further reduce the false positive rate, a requirement that significant F-tests must occur on a local 
power spectrum high, which is parameterized as occurring above the local LOWSPEC background estimate.
See Meyers (2012) for futher information on the algorithm.
</p>
<p>In this implementation, the 'robustness criterion' ('b' in EQ. 6 of Ruckstuhl et al., 2001) has been 
optimized for 2 and 3 pi DPSS, using a 'span' of 1. By default the robustness criterion will be 
estimated. Both 'b' and the 'span' can be expliclty set using parameters 'b_tun' and 'lowspan'.
Note that it is permissible to decrease 'lowspan' from its default value, but this will result in 
an overly conservative false positive rate. However, it may be necessary to reduce 'lowspan' to provide 
an approporiate background fit for some stratigraphic data. Another option is to decimate the data
series prior to spectral estimation.
</p>


<h3>Value</h3>

<p>If option 1 is selected, a data frame containing the following is returned: Frequency, Prewhitened power, harmonic F-test CL, LOWSPEC CL, LOWSPEC background, 90%-99% LOWSPEC power levels.
NOTE: as of version 0.8, the order of the columns in the output data frame has been changed, for consistency with functions mtm, mtmML96, and mtmPL.
</p>
<p>If option 2 is selected, the 'significant' frequencies are returned (as described above).
</p>


<h3>References</h3>

<p>W.S. Cleveland, 1979, 
<em>Locally weighted regression and smoothing scatterplots</em>: Journal of the American Statistical Association, v. 74, p. 829-836.
</p>
<p>S.R. Meyers, 2012,
<em>Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for Astrochronology</em>: Paleoceanography, 27, PA3228, doi:10.1029/2012PA002307.
</p>
<p>A.F. Ruckstuhl, M.P Jacobson, R.W. Field, and J.A. Dodd, 2001,
<em>Baseline subtraction using robust local regression estimation</em>: Journal of Quantitative Spectroscopy &amp; Radiative Transfer, v. 68, p. 179-193.
</p>
<p>D.J. Thomson, 1982, 
<em>Spectrum estimation and harmonic analysis</em>: IEEE Proceedings, v. 70, p. 1055-1096.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmAR">mtmAR</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, <code>rfbaseline</code>, and <code>spec.mtm</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# LOWSPEC analysis
pl(1, title="lowspec")
lowspec(ex)

# compare to MTM spectral analysis, with conventional AR1 noise test
pl(1,title="mtm")
mtm(ex,ar1=TRUE)

# compare to ML96 analysis
pl(1, title="mtmML96")
mtmML96(ex)

# compare to amplitudes from eha
pl(1,title="eha")
eha(ex,tbw=3,win=1000,pad=1000)
</code></pre>

<hr>
<h2 id='makeNoise'>Generate noise surrogates from a theoretical power spectrum</h2><span id='topic+makeNoise'></span>

<h3>Description</h3>

<p>Generate noise surrogates from a theoretical power spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNoise(S,dt=1,mean=0,sdev=1,addPt=F,nsim=1,genplot=T,verbose=T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNoise_+3A_s">S</code></td>
<td>
<p>Vector or 1-D data frame containing the theoretical power, from f(0) to the Nyquist frequency.</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_dt">dt</code></td>
<td>
<p>Sampling interval for surrogate series</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_mean">mean</code></td>
<td>
<p>Mean value for surrogate series</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_sdev">sdev</code></td>
<td>
<p>Standard deviation for surrogate series</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_addpt">addPt</code></td>
<td>
<p>Did you add a Nyquist frequency? (T or F)</p>
</td></tr>  
<tr><td><code id="makeNoise_+3A_nsim">nsim</code></td>
<td>
<p>Number of surrogate series to generate</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F)</p>
</td></tr>
<tr><td><code id="makeNoise_+3A_verbose">verbose</code></td>
<td>
<p>verbose output (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These simulations use the random number generator of Matsumoto and Nishimura [1998]. 
The algorithm of Timmer and Konig (1995) is employed to generate surrogates from
any arbitrary theoretical power spectrum. See examples section below.
</p>


<h3>References</h3>

<p>M. Matsumoto, and T. Nishimura, (1998), 
<em>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudo-random number generator</em>, ACM Transactions on Modeling and Computer Simulation, 8, 3-30.
</p>
<p>J. Timmer and K. Konig (1995), 
<em>On Generating Power Law Noise</em>, Astronomy and Astrophysics: v. 300, p. 707-710.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create theoretical AR1 spectrum, using rho of 0.8
rho=0.8
freq=seq(0,.5,by=0.005)
Nyq=max(freq)
AR1 = (1-(0.8^2)) / (  1 - (2*0.8*cos(pi*freq/Nyq)) + (0.8^2) )
plot(freq,AR1,type="l")

# make noise surrogates from the theoretical AR1 spectrum
makeNoise(AR1)
</code></pre>

<hr>
<h2 id='modelA'>Example stratigraphic model series</h2><span id='topic+modelA'></span>

<h3>Description</h3>

 
<p>Example stratigraphic model series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(modelA)</code></pre>


<h3>Format</h3>

<p>Height (meters), weight percent CaCO3</p>

<hr>
<h2 id='mtm'>Multitaper method spectral analysis</h2><span id='topic+mtm'></span>

<h3>Description</h3>

<p>Multitaper method (MTM) spectral analysis (Thomson, 1982)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtm(dat,tbw=3,ntap=NULL,padfac=5,demean=T,detrend=F,siglevel=0.9,ar1=T,output=0,
     CLpwr=T,xmin,xmax,pl=1,sigID=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtm_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for MTM spectral analysis. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="mtm_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="mtm_+3A_ntap">ntap</code></td>
<td>
<p>Number of DPSS tapers to use. By default, this is set to (2*tbw)-1.</p>
</td></tr>
<tr><td><code id="mtm_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="mtm_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_siglevel">siglevel</code></td>
<td>
<p>Significance level for peak identification. (0-1)</p>
</td></tr>
<tr><td><code id="mtm_+3A_ar1">ar1</code></td>
<td>
<p>Estimate conventional AR(1) noise spectrum and confidence levels? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_clpwr">CLpwr</code></td>
<td>
<p>Plot AR(1) noise confidence levels on power spectrum? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_output">output</code></td>
<td>
<p>What should be returned as a data frame? (0=nothing; 1= power spectrum + harmonic CL + AR1 CL + AR1 fit + 90%-99% AR1 power levels (ar1 must be set to TRUE to output AR model results); 2=significant peak frequencies; 3=significant peak frequencies + harmonic CL; 4=internal variables from spec.mtm). Option 4 is intended for expert users, and should generally be avoided.</p>
</td></tr>
<tr><td><code id="mtm_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtm_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtm_+3A_pl">pl</code></td>
<td>
<p>Power spectrum plotting: (1) linear frequency-log spectral power, (2) linear frequency-linear spectral power (3) log frequency-log spectral power, (4) log frequency-linear spectral power</p>
</td></tr>
<tr><td><code id="mtm_+3A_sigid">sigID</code></td>
<td>
<p>Identify significant frequencies on power and probabilty plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtm_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If ar1=T, candidiate astronomical cycles are identified via isolation of those frequencies 
that achieve the required (e.g., 90 percent) &quot;red noise&quot; confidence level and MTM harmonic F-test 
confidence level. Allowance is made for the smoothing inherent in the MTM power spectral estimate 
as compared to the MTM harmonic spectrum. That is, an F-test peak is reported if it achieves the 
required MTM harmonic confidence level, while also achieving the required red noise confidence level 
within +/- half the power spectrum bandwidth resolution. One additional criterion is included to 
further reduce the false positive rate, a requirement that significant F-tests must occur on a local 
power spectrum high, which is parameterized as occurring above the local red noise background estimate.
See Meyers (2012) for futher information.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2012,
<em>Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for Astrochronology</em>: Paleoceanography, 27, PA3228, doi:10.1029/2012PA002307.
</p>
<p>Rahim, K.J. and Burr W.S. and Thomson, D.J., 2014, <em>Appendix A: Multitaper R package in &quot;Applications of Multitaper Spectral Analysis to Nonstationary Data&quot;</em>, PhD diss., Queen's Univieristy, pp 149-183. http://hdl.handle.net/1974/12584
</p>
<p>Thomson, D. J., 1982, <em>Spectrum estimation and harmonic analysis</em>, Proc. IEEE, 70, 1055-1096, doi:10.1109/PROC.1982.12433.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtmAR">mtmAR</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, and <code>spec.mtm</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# MTM spectral analysis, with conventional AR1 noise test
pl(1,title="mtm")
mtm(ex,ar1=TRUE)

# compare to ML96 analysis
pl(1, title="mtmML96")
mtmML96(ex)

# compare to analysis with LOWSPEC
pl(1, title="lowspec")
lowspec(ex)

# compare to amplitudes from eha
pl(1,title="eha")
eha(ex,tbw=3,win=1000,pad=1000)
</code></pre>

<hr>
<h2 id='mtmAR'>Intermediate spectrum test of Thomson et al. (2001)</h2><span id='topic+mtmAR'></span>

<h3>Description</h3>

<p>Perform the 'intermediate spectrum test' of Thomson et al. (2001).
</p>
<p>Paraphrased from Thomson et al. (2001): 
Form an intermediate spectrum by dividing MTM by AR estimate. 
Choose an order P for a predictor. A variety of formal methods are available in the literature, 
but practically, one keeps increasing P (the order) until the range of the intermediate spectrum 
Si(f) (equation (C4) of Thomson et al., 2001) stops decreasing rapidly as a function of P. If the 
intermediate spectrum is not roughly white, as judged by the minima, the value of P should be 
increased. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtmAR(dat,tbw=3,ntap=NULL,order=1,method="mle",CItype=1,padfac=5,demean=T,detrend=F,
      output=1,xmin=0,xmax=Nyq,pl=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtmAR_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for analysis. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_ntap">ntap</code></td>
<td>
<p>Number of DPSS tapers to use. By default, this is set to (2*tbw)-1.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_order">order</code></td>
<td>
<p>Order of the AR spectrum.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_method">method</code></td>
<td>
<p>AR method (&quot;yule-walker&quot;, &quot;burg&quot;, &quot;ols&quot;, &quot;mle&quot;, &quot;yw&quot;)</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_citype">CItype</code></td>
<td>
<p>Illustrate (1) one-sided or (2) two-sided confidence intervals on plots</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_output">output</code></td>
<td>
<p>Output (1) intermediate spectrum and confidence levels, (2) intermediate spectrum, (3) confidence levels</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_pl">pl</code></td>
<td>
<p>Plot logarithm of spectral power (1) or linear spectral power (2)?</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtmAR_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thomson, D. J., L. J. Lanzerotti, and C. G. Maclennan, 2001, <em>The interplanetary magnetic field: Statistical properties and discrete modes</em>, J. Geophys.Res., 106, 15,941-15,962, doi:10.1029/2000JA000113.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, and <code>spec.mtm</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# MTM spectral analysis, with conventional AR1 noise test
pl(1,title="mtmAR")
mtmAR(ex)
</code></pre>

<hr>
<h2 id='mtmML96'>Mann and Lees (1996) robust red noise MTM analysis</h2><span id='topic+mtmML96'></span>

<h3>Description</h3>

<p>Mann and Lees (1996) robust red noise MTM analysis. This function implements several improvements to the algorithm used in SSA-MTM toolkit, including faster AR1 model optimization, and more appropriate 'edge-effect' treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtmML96(dat,tbw=3,ntap=NULL,padfac=5,demean=T,detrend=F,medsmooth=0.2,
         opt=1,linLog=2,siglevel=0.9,output=0,CLpwr=T,xmin=0,xmax=Nyq,
         sigID=T,pl=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtmML96_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for MTM spectral analysis. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_ntap">ntap</code></td>
<td>
<p>Number of DPSS tapers to use. By default, this is set to (2*tbw)-1.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_medsmooth">medsmooth</code></td>
<td>
<p>ML96 median smoothing parameter (1 = use 100% of spectrum; 0.20 = use 20%)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_opt">opt</code></td>
<td>
<p>Optimization method for robust AR1 model estimation (1=Brent's method:fast, 2=Gauss-Newton:fast, 3=grid search:slow)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_linlog">linLog</code></td>
<td>
<p>Optimize AR1 model fit using (1) linear power or (2) log(power)?</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_siglevel">siglevel</code></td>
<td>
<p>Significance level for peak identification. (0-1)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_output">output</code></td>
<td>
<p>What should be returned as a data frame? (0=nothing; 1= power spectrum + harmonic CL + AR1 CL + AR1 fit + 90%-99% AR1 power levels + median smoothed spectrum; 2=significant peak frequencies; 3=significant peak frequencies + harmonic CL)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_clpwr">CLpwr</code></td>
<td>
<p>Plot ML96 AR(1) noise confidence levels on power spectrum? (T or F)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_sigid">sigID</code></td>
<td>
<p>Identify significant frequencies on power and probabilty plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_pl">pl</code></td>
<td>
<p>Power spectrum plotting: (1) linear frequency-log spectral power, (2) linear frequency-linear spectral power (3) log frequency-log spectral power, (4) log frequency-linear spectral power</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtmML96_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts the Mann and Lees (1996; ML96) &quot;robust red noise&quot; analysis, with an improved median
smoothing approach. The original Mann and Lees (1996) approach applies a truncation of the median 
smoothing window to include fewer frequencies near the edges of the spectrum; while truncation is
required, its implementation in the original method often results in an &quot;edge effect&quot; that can produce 
excess false positive rates at low frequencies, commonly within the eccentricity-band (Meyers, 2012). 
</p>
<p>To help address this issue, an alternative median smoothing approach is applied that implements Tukey's 
robust end-point rule and symmetrical medians (see the function runmed for details). Numerical experiments 
indicate that this approach produces an approximately uniform false positive rate across the spectrum.  
It should be noted that the false positive rates are still inflated with this method, but they are substantially
reduced compared to the original ML96 approach. For example, simulations using rho=0.9 (using identical 
parameters to those in Meyers, 2012) yield median false positive rates of 1.7%, 7.3% and 13.4%, for the 99%, 
95% and 90% confidence levels (respectively). This compares with 4.7%, 11.4% and 17.8% using 
the original approach (see Table 2 of Meyers, 2012).
</p>
<p>Candidiate astronomical cycles are identified via isolation of those frequencies 
that achieve the required (e.g., 90 percent) &quot;robust red noise&quot; confidence level and MTM harmonic F-test 
confidence level. Allowance is made for the smoothing inherent in the MTM power spectral estimate 
as compared to the MTM harmonic spectrum. That is, an F-test peak is reported if it achieves the 
required MTM harmonic confidence level, while also achieving the required robust red noise confidence level 
within +/- half the power spectrum bandwidth resolution. One additional criterion is included to 
further reduce the false positive rate, a requirement that significant F-tests must occur on a local 
power spectrum high, which is parameterized as occurring above the local robust red noise background estimate.
See Meyers (2012) for futher information.
</p>
<p>NOTE: If the (fast) Brent or Gauss-Newton methods fail, use the (slow) grid search approach.
</p>
<p>This version of the ML96 algorithm was first implemented in Patterson et al. (2014).
</p>


<h3>References</h3>

<p>Mann, M.E., and Lees, J.M., 1996, <em>Robust estimation of background noise and signal 
detection in climatic time series</em>, Clim. Change, 33, 409-445.
</p>
<p>Meyers, S.R., 2012, <em>Seeing red in cyclic stratigraphy: Spectral noise estimation for
astrochronology</em>, Paleoceanography, 27, PA3228.
</p>
<p>M.O. Patterson, R. McKay, T. Naish, C. Escutia, F.J. Jimenez-Espejo, M.E. Raymo, M.E., 
S.R. Meyers, L. Tauxe, H. Brinkhuis, and IODP Expedition 318 Scientists,2014, 
<em>Response of the East Antarctic Ice Sheet to orbital forcing during the Pliocene and Early Pleistocene</em>, Nature Geoscience, v. 7, p. 841-847.
</p>
<p>Thomson, D. J., 1982, <em>Spectrum estimation and harmonic analysis</em>, Proc. IEEE, 
70, 1055-1096, doi:10.1109/PROC.1982.12433.
</p>
<p>http://www.meteo.psu.edu/holocene/public_html/Mann/tools/MTM-RED/
</p>
<p>Tukey, J.W., 1977, <em>Exploratory Data Analysis</em>, Addison.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmAR">mtmAR</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, <code><a href="stats.html#topic+runmed">runmed</a></code>, and <code>spec.mtm</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=0.5)
ex[2] = ex[2] + noise[2]

# run ML96 analysis
pl(1, title="mtmML96")
mtmML96(ex)

# compare to analysis with conventional AR1 noise test
pl(1,title="mtm")
mtm(ex)

# compare to analysis with LOWSPEC
pl(1, title="lowspec")
lowspec(ex)

# compare to amplitudes from eha
pl(1,title="eha")
eha(ex,tbw=3,win=1000,pad=1000)
</code></pre>

<hr>
<h2 id='mtmPL'>Multitaper Method Spectral Analysis with Power Law (1/f) fit</h2><span id='topic+mtmPL'></span>

<h3>Description</h3>

<p>Multitaper Method (MTM) Spectral Analysis with Power Law (1/f) fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtmPL(dat,tbw=3,ntap=NULL,padfac=5,demean=T,detrend=F,siglevel=0.9,flow=NULL,fhigh=NULL,
    output=0,CLpwr=T,xmin=0,xmax=Nyq,pl=1,sigID=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtmPL_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for MTM spectral analysis. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_ntap">ntap</code></td>
<td>
<p>Number of DPSS tapers to use. By default, this is set to (2*tbw)-1.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_siglevel">siglevel</code></td>
<td>
<p>Significance level for peak identification.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_flow">flow</code></td>
<td>
<p>Lowest frequency to include in 1/f fit</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_fhigh">fhigh</code></td>
<td>
<p>Highest frequency to include in 1/f fit</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_output">output</code></td>
<td>
<p>What should be returned as a data frame? (0=nothing; 1=spectrum + CLs + power law fit; 2=sig peak freqs; 3=sig peak freqs + prob; 4=all)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_clpwr">CLpwr</code></td>
<td>
<p>Plot power law noise confidence levels on power spectrum (in addition to the power law fit)? (T or F)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_pl">pl</code></td>
<td>
<p>Power spectrum plotting: (1) linear frequency-log spectral power, (2) linear frequency-linear spectral power (3) log frequency-log spectral power, (4) log frequency-linear spectral power</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_sigid">sigID</code></td>
<td>
<p>Identify signficant frequencies on power and probabilty plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mtmPL_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Candidiate astronomical cycles are identified via isolation of those frequencies 
that achieve the required (e.g., 90 percent) power law confidence level and MTM harmonic F-test 
confidence level. Allowance is made for the smoothing inherent in the MTM power spectral estimate 
as compared to the MTM harmonic spectrum. That is, an F-test peak is reported if it achieves the 
required MTM harmonic confidence level, while also achieving the required power law confidence level 
within +/- half the power spectrum bandwidth resolution. One additional criterion is included to 
further reduce the false positive rate, a requirement that significant F-tests must occur on a local 
power spectrum high, which is parameterized as occurring above the local red noise background estimate.
See Meyers (2012) for futher information.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2012,
<em>Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for Astrochronology</em>: Paleoceanography, 27, PA3228, doi:10.1029/2012PA002307.
</p>
<p>Rahim, K.J. and Burr W.S. and Thomson, D.J., 2014, 
<em>Appendix A: Multitaper R package in &quot;Applications of Multitaper Spectral Analysis to Nonstationary Data&quot;</em>, PhD diss., Queen's Univieristy, pp 149-183. http://hdl.handle.net/1974/12584
</p>
<p>Thomson, D. J., 1982, 
<em>Spectrum estimation and harmonic analysis</em>, Proc. IEEE, 70, 1055-1096, doi:10.1109/PROC.1982.12433.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code>, <code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmAR">mtmAR</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, and <code>spec.mtm</code></p>

<hr>
<h2 id='multiTest'>Adjust spectral p-values for multiple comparisons</h2><span id='topic+multiTest'></span>

<h3>Description</h3>

<p>Adjust spectral p-values for multiple comparisons, using a range of approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiTest(spec,flow=NULL,fhigh=NULL,pl=T,output=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiTest_+3A_spec">spec</code></td>
<td>
<p>A data frame with two columns: frequency, uncorrected confidence level. If more than 2 columns are input, the results are assumed to come from periodogram, mtm, mtmML96, lowspec or mtmPL.</p>
</td></tr>
<tr><td><code id="multiTest_+3A_flow">flow</code></td>
<td>
<p>Vector of lower bounds for each frequency band of interest. Order must match fhigh.</p>
</td></tr>
<tr><td><code id="multiTest_+3A_fhigh">fhigh</code></td>
<td>
<p>Vector of upper bounds for each frequency band of interest. Order must match flow.</p>
</td></tr>
<tr><td><code id="multiTest_+3A_pl">pl</code></td>
<td>
<p>Include graphs of uncorrected p-values? (T or F)</p>
</td></tr>
<tr><td><code id="multiTest_+3A_output">output</code></td>
<td>
<p>Return results as new data frame? (T or F)</p>
</td></tr>
<tr><td><code id="multiTest_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="multiTest_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple testing is a common problem in the evaluation of power spectrum peaks 
(Vaughan et al., 2011; Crampton et al., PNAS).  To address the issue
of multiple testing, a range of approaches have been advocated. This function will conduct an 
assessment using six approaches: Bonferroni, Holm (1979), Hochberg (1998), Hommel (1988),
Benjamini &amp; Hochberg (1995, a.k.a. &quot;false discovery rate&quot;), 
Benjamini &amp; Yekutieli (2001, a.k.a. &quot;false discovery rate&quot;).  See the function p.adjust
for additional information on these six approaches.
</p>
<p>In conducting these assessments, it is important that the spectral analysis is conducted 
without zero-padding. If one is exclusively concerned with particular frequency bands a priori 
(e.g., those associated with Milankovitch cycles), the statistical power of the method
can be improved by restricting the analysis to those frequency bands (use options 'flow' and 'fhigh').
</p>
<p>Application of these multiple testing corrections does not guarantee that the spectral background
is appropriate.  To address this issue, carefully examine the fit of the spectral background,
and also conduct simulations with the function testBackground.
</p>


<h3>References</h3>

<p>Y. Benjamini, and Y. Hochberg, 1995,
<em>Controlling the false discovery rate: a practical and powerful approach to multiple testing</em>. Journal of the Royal Statistical Society Series B 57, 289-300.
</p>
<p>Y. Benjamini, and D. Yekutieli, 2001, 
<em>The control of the false discovery rate in multiple testing under dependency</em>. Annals of Statistics 29, 1165-1188.
</p>
<p>J.S. Campton, S.R. Meyers, R.A. Cooper, P.M Sadler, M. Foote, D. Harte, 2018, 
<em>Pacing of Paleozoic macroevolutionary rates by Milankovitch grand cycles</em>: Proceedings of the National Academy of Sciences, doi:10.1073/pnas.1714342115.
</p>
<p>S. Holm, 1979, 
<em>A simple sequentially rejective multiple test procedure</em>. Scandinavian Journal of Statistics 6, 65-70.
</p>
<p>G. Hommel, 1988, 
<em>A stagewise rejective multiple test procedure based on a modified Bonferroni test</em>. Biometrika 75, 383-386.
</p>
<p>Y. Hochberg, 1988, 
<em>A sharper Bonferroni procedure for multiple tests of significance</em>. Biometrika 75, 800-803.
</p>
<p>J.P. Shaffer, 1995,
<em>Multiple hypothesis testing. Annual Review of Psychology 46, 561-576</em>. (An excellent review of the area.)
</p>
<p>S. Vaughan, R.J. Bailey, and D.G. Smith, 2011, 
<em>Detecting cycles in stratigraphic data: Spectral analysis in the presence of red noise</em>. Paleoceanography 26, PA4211, doi:10.1029/2011PA002195.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>,<code><a href="#topic+testBackground">testBackground</a></code>,<code><a href="#topic+confAdjust">confAdjust</a></code>,<code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+mtmPL">mtmPL</a></code>, and <code><a href="#topic+periodogram">periodogram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# first, let's look at mtm with conventional AR1 background
spec=mtm(ex,padfac=1,ar1=TRUE,output=1)

# when blindly prospecting for cycles, it is necessary to consider all of the 
#  observed frequencies in the test
multiTest(cb(spec,c(1,4)),output=FALSE)

# if, a priori, you are only concerned with the Milankovitch frequency bands, 
#  restrict your analysis to those bands (as constrained by available sedimentation
#  rate estimates and the frequency resolution of the spectrum). in the example below, 
#  the mtm bandwidth resolution is employed to search frequencies nearby the 
#  Milankovitch-target periods.
flow=c((1/400)-0.003,(1/100)-0.003,(1/41)-0.003,(1/20)-0.003)
fhigh=c((1/400)+0.003,(1/100)+0.003,(1/41)+0.003,(1/20)+0.003)
multiTest(cb(spec,c(1,4)),flow=flow,fhigh=fhigh,output=FALSE)

# now try with the lowspec method. this uses prewhitening, so it has one less data point.
spec=lowspec(ex,padfac=1,output=1)
flow=c((1/400)-0.003015075,(1/100)-0.003015075,(1/41)-0.003015075,(1/20)-0.003015075)
fhigh=c((1/400)+0.003015075,(1/100)+0.003015075,(1/41)+0.003015075,(1/20)+0.003015075)
multiTest(cb(spec,c(1,4)),flow=flow,fhigh=fhigh,output=FALSE)

# for comparison...
multiTest(cb(spec,c(1,4)),output=FALSE)
</code></pre>

<hr>
<h2 id='mwCor'>Calculate moving window correlation coefficient for two stratigraphic series, using a 'dynamic window'</h2><span id='topic+mwCor'></span>

<h3>Description</h3>

<p>Calculate moving window correlation coefficient for two stratigraphic series, using a 'dynamic window'. 
This routine adjusts the number of data points in the window so it has a constant duration in time or space, for use with unevenly sampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwCor(dat,cols=NULL,win=NULL,conv=1,cormethod=1,output=T,pl=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwCor_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwCor_+3A_cols">cols</code></td>
<td>
<p>A vector that identifies the two variable columns to be extracted (first column automatically extracted).</p>
</td></tr>
<tr><td><code id="mwCor_+3A_win">win</code></td>
<td>
<p>Moving window size in units of space or time.</p>
</td></tr>
<tr><td><code id="mwCor_+3A_conv">conv</code></td>
<td>
<p>Convention for window placement: (1) center each window on a stratigraphic level in 'dat' (DEFAULT), (2) start with the smallest location datum in 'dat', (3) start with the largest location datum in 'dat'. For options 2 and 3, the center of the window will not necessarily coincide with a measured stratigraphic level in 'dat', but edges of the data set are better preserved.</p>
</td></tr>
<tr><td><code id="mwCor_+3A_cormethod">cormethod</code></td>
<td>
<p>Method used for calculation of correlation coefficient (1=Pearson, 2=Spearman, 3=Kendall)</p>
</td></tr>
<tr><td><code id="mwCor_+3A_output">output</code></td>
<td>
<p>Output results? (T or F)</p>
</td></tr>
<tr><td><code id="mwCor_+3A_pl">pl</code></td>
<td>
<p>(1) Plot results at center of window, or (2) create &quot;string of points plot&quot; as in Sageman and Hollander (1999)</p>
</td></tr>
<tr><td><code id="mwCor_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mwCor_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>B.B. Sageman and D.H. Hollander, 1999,
<em>Cross correlation of paleoecological and geochemical proxies: A holistic approach to the study of past global change</em>, in E. Barrera and C.C. Johnson, eds., GSA Special Paper 332, p. 365-384.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series
ex &lt;- cycles(freqs=c(1/40,1/20),noisevar=.2)

# add second variable
ex[3] &lt;- cycles(freqs=c(1/40,1/20),noisevar=0.2)[2]

# jitter sampling times
ex[1]=ex[1]+rnorm(500,sd=1)
# sort
ex = ex[order(ex[,1],na.last=NA,decreasing=FALSE),]

# run mwCor
mwCor(ex,win=50)
</code></pre>

<hr>
<h2 id='mwin'>Determine 'dynamic moving window' for stratigraphic series, adjusting for changing sample density to maintain a window of constant duration</h2><span id='topic+mwin'></span>

<h3>Description</h3>

<p>Determine start and end points for a moving window of fixed duration (e.g. 500 kiloyears). 
The dynamic window allows for adjustment of the number of data points in the window, 
so it has a constant duration in time or space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwin(dat,win,conv=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwin_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwin_+3A_win">win</code></td>
<td>
<p>Moving window size in units of space or time.</p>
</td></tr>
<tr><td><code id="mwin_+3A_conv">conv</code></td>
<td>
<p>Convention for window placement: (1) center each window on a stratigraphic level in 'dat' (DEFAULT), (2) start with the smallest location datum in 'dat', (3) start with the largest location datum in 'dat'. For options 2 and 3, the center of the window will not necessarily coincide with a measured stratigraphic level in 'dat', but edges of the data set are better preserved.</p>
</td></tr>
<tr><td><code id="mwin_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm steps forward one stratigraphic datum at a time. The output consists of:
</p>
<p>Average = this is the average of the depth/time values in the given window.
</p>
<p>Center = this is the center of the 'win' size window.
</p>
<p>Midpoint = this is midpoint between first and last observation in the window 
(for unevenly sampled data this is typically less than than the size of 'win').
</p>


<h3>Value</h3>

<p>A data frame containing: Starting index for window, Ending index for window, Location (average), Location (center), Location (midpoint)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some noise
ex1 &lt;- ar1(npts=50,dt=1)

# jitter sampling times
ex1[1]=ex1[1]+rnorm(50,sd=3)
# sort 
ex1 = ex1[order(ex1[,1],na.last=NA,decreasing=FALSE),]

# run mwin
mwin(ex1,win=10)
</code></pre>

<hr>
<h2 id='mwinGrid'>Determine 'dynamic moving window' for stratigraphic series, adjusting for changing sample density to maintain a window of constant duration; output on evenly spaced grid</h2><span id='topic+mwinGrid'></span>

<h3>Description</h3>

<p>Determine start and end points for a moving window of fixed duration (e.g. 500 kiloyears). 
The dynamic window allows for adjustment of the number of data points in the window, 
so it has a constant duration in time or space. This version will output an evenly spaced
spatial/temporal grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwinGrid(dat,win,step,start=NULL,end=NULL,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwinGrid_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwinGrid_+3A_win">win</code></td>
<td>
<p>Moving window size in units of space or time.</p>
</td></tr>
<tr><td><code id="mwinGrid_+3A_step">step</code></td>
<td>
<p>Step size for moving window, in units of space or time.</p>
</td></tr>
<tr><td><code id="mwinGrid_+3A_start">start</code></td>
<td>
<p>Start moving window at what depth/height/time; by default will use first value</p>
</td></tr>
<tr><td><code id="mwinGrid_+3A_end">end</code></td>
<td>
<p>End moving window at what depth/height/time; by default will use last value</p>
</td></tr>
<tr><td><code id="mwinGrid_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is similar to function mwin, but instead of stepping forward one stratigraphic datum at a time, it generates an evenly spaced spatial/temporal grid.
</p>


<h3>Value</h3>

<p>A data frame containing: Starting index for window, Ending index for window, Location (center)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some noise
ex1 &lt;- ar1(npts=50,dt=1)

# jitter sampling times
ex1[1]=ex1[1]+rnorm(50,sd=0.25)
# sort 
ex1 = ex1[order(ex1[,1],na.last=NA,decreasing=FALSE),]

# run mwin
mwinGrid(ex1,win=10,step=2)
</code></pre>

<hr>
<h2 id='mwMinMax'>'Dynamic window' moving assessment of maxima and minima in stratigraphic series</h2><span id='topic+mwMinMax'></span>

<h3>Description</h3>

<p>'Dynamic window' moving assessment of maxima and minima in stratigraphic series. 
This routine adjusts the number of data points in the window so it has a constant duration in time or space, for use with unevenly sampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwMinMax(dat,cols=NULL,win=NULL,conv=1,output=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwMinMax_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_cols">cols</code></td>
<td>
<p>A vector that identifies the variable column to be extracted (first column automatically extracted).</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_win">win</code></td>
<td>
<p>Moving window size in units of space or time.</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_conv">conv</code></td>
<td>
<p>Convention for window placement: (1) center each window on a stratigraphic level in 'dat' (DEFAULT), (2) start with the smallest location datum in 'dat', (3) start with the largest location datum in 'dat'. For options 2 and 3, the center of the window will not necessarily coincide with a measured stratigraphic level in 'dat', but edges of the data set are better preserved.</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_output">output</code></td>
<td>
<p>Output results? (T or F)</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mwMinMax_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with five columns: 
Center of window, Minimum, Maximum, Maximum-Minimum, Number of points in window
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series from ar1 noise, 5 kyr sampling interval
ex = ar1(npts=1001,dt=5)

# jitter sampling times
ex[1]=ex[1]+rnorm(1001,sd=1)
# sort
ex = ex[order(ex[,1],na.last=NA,decreasing=FALSE),]

# run mwStats
mwMinMax(ex,win=100)
</code></pre>

<hr>
<h2 id='mwStats'>'Dynamic window' moving average, median and variance of stratigraphic series</h2><span id='topic+mwStats'></span>

<h3>Description</h3>

<p>'Dynamic window' moving average, median and variance of stratigraphic series. 
This routine adjusts the number of data points in the window so it has a constant duration in time or space, for use with unevenly sampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwStats(dat,cols=NULL,win=NULL,conv=1,ends=F,CI=0,output=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwStats_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwStats_+3A_cols">cols</code></td>
<td>
<p>A vector that identifies the variable column to be extracted (first column automatically extracted).</p>
</td></tr>
<tr><td><code id="mwStats_+3A_win">win</code></td>
<td>
<p>Moving window size in units of space or time.</p>
</td></tr>
<tr><td><code id="mwStats_+3A_conv">conv</code></td>
<td>
<p>Convention for window placement: (1) center each window on a stratigraphic level in 'dat' (DEFAULT), (2) start with the smallest location datum in 'dat', (3) start with the largest location datum in 'dat'. For options 2 and 3, the center of the window will not necessarily coincide with a measured stratigraphic level in 'dat', but ends of the data set are better preserved. See options 'ends'.</p>
</td></tr>
<tr><td><code id="mwStats_+3A_ends">ends</code></td>
<td>
<p>Assign average values to ends, by averaging data before first window, and averaging data after last window? (T or F; only applicable for conv=1)</p>
</td></tr>
<tr><td><code id="mwStats_+3A_ci">CI</code></td>
<td>
<p>What confidence interval should be calculated for the average value (0-100 percent). If set to 0, the confidence interval calculation is skipped.</p>
</td></tr>
<tr><td><code id="mwStats_+3A_output">output</code></td>
<td>
<p>Output results? (T or F)</p>
</td></tr>
<tr><td><code id="mwStats_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="mwStats_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If conv=1 is selected, the edges of the record are determined using a smaller window size. 
A constant value is assigned based on the observed values within the first and last 0.5*win 
of the record.
</p>


<h3>Value</h3>

<p>A data frame with five or six columns: 
Center of window, Average, Median, Variance, Number of points in window.
If CI&gt;0, the sixth column is the value used to determine the confidence interval (add and subtract it from the average) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series from ar1 noise, 5 kyr sampling interval
ex = ar1(npts=1001,dt=5)

# jitter sampling times
ex[1]=ex[1]+rnorm(1001,sd=1)
# sort
ex = ex[order(ex[,1],na.last=NA,decreasing=FALSE),]

# run mwStats
mwStats(ex,win=100)
</code></pre>

<hr>
<h2 id='mwStatsGrid'>'Dynamic window' moving average, median and variance of stratigraphic series, using evenly spaced spatial/temporal grid</h2><span id='topic+mwStatsGrid'></span>

<h3>Description</h3>

<p>'Dynamic window' moving average, median and variance of stratigraphic series. 
This routine adjusts the number of data points in the window so it has a constant duration in time or space, for use with unevenly sampled data.
The results are output on an evenly spaced spatial/temporal grid (this contrasts with mwStats).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwStatsGrid(dat,cols=NULL,win=NULL,step=NULL,start=NULL,end=NULL,output=T,norm=F,
            palette=6,ncolors=100,genplot=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mwStatsGrid_+3A_dat">dat</code></td>
<td>
<p>Your data frame containing stratigraphic data; any number of columns (variables) are permitted, but the first column should be a location identifier (e.g., depth, height, time).</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_cols">cols</code></td>
<td>
<p>A vector that identifies the variable column to be extracted (first column automatically extracted).</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_win">win</code></td>
<td>
<p>Moving window size, in units of space or time.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_step">step</code></td>
<td>
<p>Moving window step size, in units of space or time.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_start">start</code></td>
<td>
<p>Starting point for analysis, in units of space or time.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_end">end</code></td>
<td>
<p>Ending point for analysis, in units of space or time.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_norm">norm</code></td>
<td>
<p>Normalize density estimates to maximum value? (T or F). If false, density estimates are normalized to unit area.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_output">output</code></td>
<td>
<p>Output results? (T or F)</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (0=none, 1=all time series, 2=kernel density estimates for each window, 3=kernel density estimates with median, 4=kernel density estimates with mean)</p>
</td></tr>
<tr><td><code id="mwStatsGrid_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four columns: Center of window, Average, Median, Variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series from ar1 noise, 5 kyr sampling interval
ex = ar1(npts=1001,dt=5)

# jitter sampling times
ex[1]=ex[1]+rnorm(1001,sd=1)
# sort
ex = ex[order(ex[,1],na.last=NA,decreasing=FALSE),]

# run mwStats
mwStatsGrid(ex,win=100)
</code></pre>

<hr>
<h2 id='noKernel'>Remove Gaussian kernel smoother from stratigraphic series</h2><span id='topic+noKernel'></span>

<h3>Description</h3>

<p>Estimate trend and remove from stratigraphic series using a Gaussian kernel smoother </p>


<h3>Usage</h3>

<pre><code class='language-R'>noKernel(dat,smooth=0.1,sort=F,output=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noKernel_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for smoothing. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="noKernel_+3A_smooth">smooth</code></td>
<td>
<p>Degree of smoothing with a Gaussian kernal (0 = no smoothing); for a value of 0.5, the kernel is scaled so that its quartiles (viewed as prob densities) are at +/- 25 percent of the data series length. Must be &gt; 0.</p>
</td></tr>
<tr><td><code id="noKernel_+3A_sort">sort</code></td>
<td>
<p>Sort data into increasing depth (required for ksmooth)? (T or F)</p>
</td></tr>
<tr><td><code id="noKernel_+3A_output">output</code></td>
<td>
<p>1= output residual values; 2= output Gaussian kernel smoother.</p>
</td></tr>
<tr><td><code id="noKernel_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="noKernel_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noLow">noLow</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code> </p>

<hr>
<h2 id='noLow'>Fit and remove Lowess smoother from stratigraphic series</h2><span id='topic+noLow'></span>

<h3>Description</h3>

<p>Fit and remove lowess smoother from stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noLow(dat,smooth=.20,output=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noLow_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for lowess smoother removal. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="noLow_+3A_smooth">smooth</code></td>
<td>
<p>Lowess smoothing parameter.</p>
</td></tr>
<tr><td><code id="noLow_+3A_output">output</code></td>
<td>
<p>1= output residual values; 2= output lowess fit</p>
</td></tr>
<tr><td><code id="noLow_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="noLow_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code> </p>

<hr>
<h2 id='pad'>Pad stratigraphic series with zeros</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>Pad stratigraphic series with zeros (&quot;zero padding&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(dat,zeros,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for mean removal. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="pad_+3A_zeros">zeros</code></td>
<td>
<p>Number of zeros to add on the end of the series. By default, the number of points will be doubled.</p>
</td></tr>
<tr><td><code id="pad_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="pad_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='peak'>Identify maxima of peaks in series, filter at desired threshold value</h2><span id='topic+peak'></span>

<h3>Description</h3>

<p>Identify maxima of peaks in any 1D or 2D series, filter at desired threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak(dat,level,plateau=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak_+3A_dat">dat</code></td>
<td>
<p>1 or 2 dimensional series. If 2 dimesions, first column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="peak_+3A_level">level</code></td>
<td>
<p>Threshold level for filtering peaks. By default all peak maxima reported.</p>
</td></tr>
<tr><td><code id="peak_+3A_plateau">plateau</code></td>
<td>
<p>Output plateau points not evaluated? If T, identified peaks will not be output. (T or F)</p>
</td></tr>
<tr><td><code id="peak_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="peak_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ex=cycles(genplot=FALSE)
peak(ex,level=0.02)
</code></pre>

<hr>
<h2 id='periodogram'>Simple periodogram</h2><span id='topic+periodogram'></span>

<h3>Description</h3>

<p>Calculate periodogram for stratigraphic series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(dat,padfac=2,demean=T,detrend=F,nrm=1,background=0,medsmooth=0.2,
             bc=F,output=0,f0=F,fNyq=T,xmin=0,xmax=Nyq,pl=1,genplot=T,check=T,
            verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodogram_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to analyze. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points. padfac will automatically promote the total padded series length to an even number, to ensure the Nyquist frequency is calculated. padfac must be &gt;= 1.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_nrm">nrm</code></td>
<td>
<p>Power normalization: 0 = no normalization; 1 = divide Fourier transform by npts.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_background">background</code></td>
<td>
<p>Estimate noise model background spectrum and confidence levels? (0= No, 1= AR1, 2= Power Law, 3= Robust AR1)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_medsmooth">medsmooth</code></td>
<td>
<p>Robust AR1 median smoothing parameter (1 = use 100% of spectrum; 0.20 = use 20%)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_bc">bc</code></td>
<td>
<p>Apply Bonferroni correction? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_output">output</code></td>
<td>
<p>Return output as new data frame? 0= no; 1= frequency, amplitude, power, phase (+ background fit and confidence levels if background selected); 2= frequency, real coeff., imag. coeff. If option 2 is selected, all frequencies from negative to positive Nyquist are returned, regardless of the f0 and fNyq settings</p>
</td></tr>
<tr><td><code id="periodogram_+3A_f0">f0</code></td>
<td>
<p>Return results for the zero frequency? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_fnyq">fNyq</code></td>
<td>
<p>Return results for the Nyquist frequency? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_pl">pl</code></td>
<td>
<p>Power spectrum plotting: 1 = log power, 2 = linear power</p>
</td></tr>
<tr><td><code id="periodogram_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+mtm">mtm</a></code> and <code><a href="#topic+lowspec">lowspec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># ***** PART 1: Demonstrate the impact of tapering
# generate example series with 10 periods: 100, 40, 29, 21, 19, 14, 10, 5, 4 and 3 ka.
ex=cycles(c(1/100,1/40,1/29,1/21,1/19,1/14,1/10,1/5,1/4,1/3),amp=c(1,.75,0.01,.5,.25,
             0.01,0.1,0.05,0.001,0.01))

# set zero padding amount for spectral analyses 
# (pad= 1 results in no zero padding, pad = 2 will pad the series to two times its original length)
# start with pad = 1, then afterwards evaluate pad=2
pad=1

# calculate the periodogram with no tapering applied (a "rectangular window")
res=periodogram(ex,output=1,padfac=pad)

# save the frequency grid and the power for plotting
freq=res[1]
pwr_rect=res[3]

# now compare with results obtained after applying four different tapers: 
#  Hann, 30% cosine taper, DPSS with a time-bandwidth product of 1, and DPSS 
#  with a time-bandwidth product of 3
pwr_hann=periodogram(hannTaper(ex,demean=FALSE),output=1,padfac=pad)[3]
pwr_cos=periodogram(cosTaper(ex,p=.3,demean=FALSE),output=1,padfac=pad)[3]
pwr_dpss1=periodogram(dpssTaper(ex,tbw=1,demean=FALSE),output=1,padfac=pad)[3]
pwr_dpss3=periodogram(dpssTaper(ex,tbw=3,demean=FALSE),output=1,padfac=pad)[3]

# now plot the results
ymin=min(rbind (log(pwr_rect[,1]),log(pwr_hann[,1]),log(pwr_cos[,1]),log(pwr_dpss1[,1]),
          log(pwr_dpss3[,1]) ))
ymax=max(rbind (log(pwr_rect[,1]),log(pwr_hann[,1]),log(pwr_cos[,1]),log(pwr_dpss1[,1]),
          log(pwr_dpss3[,1]) ))

pl(2)
plot(freq[,1],log(pwr_rect[,1]),type="l",ylim=c(ymin,ymax),lwd=2,ylab="log(Power)",
      xlab="Frequency (cycles/ka)",
      main="Comparison of rectangle (black), cosine (blue) and Hann (orange) taper",
      cex.main=1)
lines(freq[,1],log(pwr_hann[,1]),col="orange",lwd=2)
lines(freq[,1],log(pwr_cos[,1]),col="blue")
points(c(1/100,1/40,1/29,1/21,1/19,1/14,1/10,1/5,1/4,1/3),rep(ymax,10),cex=.5,
       col="purple")

plot(freq[,1],log(pwr_rect[,1]),type="l",ylim=c(ymin,ymax),lwd=2,ylab="log(Power)",
      xlab="Frequency (cycles/ka)",
      main="Comparison of rectangle (black), 1pi DPSS (green) and 3pi DPSS (red) taper",
      cex.main=1)
lines(freq[,1],log(pwr_dpss1[,1]),col="green")
lines(freq[,1],log(pwr_dpss3[,1]),col="red",lwd=2)
points(c(1/100,1/40,1/29,1/21,1/19,1/14,1/10,1/5,1/4,1/3),rep(ymax,10),cex=.5,
       col="purple")


# ***** PART 2: Now add a very small amount of red noise to the series 
#               (with lag-1 correlation = 0.5)
ex2=ex
ex2[2]=ex2[2]+ar1(rho=.5,dt=1,npts=500,sd=.005,genplot=FALSE)[2]

# compare the original series with the series+noise
pl(2)
plot(ex,type="l",lwd=2,lty=3,col="black",xlab="time (ka)",ylab="signal",
      main="signal (black dotted) and signal+noise (red)"); lines(ex2,col="red")
plot(ex[,1],ex2[,2]-ex[,2],xlab="time (ka)",ylab="difference",
      main="Difference between the two time series (very small!)")

# calculate the periodogram with no tapering applied (a "rectangular window")
res.2=periodogram(ex2,output=1,padfac=pad)

# save the frequency grid and the power for plotting
freq.2=res.2[1]
pwr_rect.2=res.2[3]

# now compare with results obtained after applying four different tapers: 
#  Hann, 30% cosine taper, DPSS with a time-bandwidth product of 1, and DPSS 
#  with a time-bandwidth product of 3
pwr_hann.2=periodogram(hannTaper(ex2,demean=FALSE),output=1,padfac=pad)[3]
pwr_cos.2=periodogram(cosTaper(ex2,p=.3,demean=FALSE),output=1,padfac=pad)[3]
pwr_dpss1.2=periodogram(dpssTaper(ex2,tbw=1,demean=FALSE),output=1,padfac=pad)[3]
pwr_dpss3.2=periodogram(dpssTaper(ex2,tbw=3,demean=FALSE),output=1,padfac=pad)[3]

# now plot the results
ymin=min(rbind (log(pwr_rect.2[,1]),log(pwr_hann.2[,1]),log(pwr_cos.2[,1]),
         log(pwr_dpss1.2[,1]),log(pwr_dpss3.2[,1]) ))
ymax=max(rbind (log(pwr_rect.2[,1]),log(pwr_hann.2[,1]),log(pwr_cos.2[,1]),
         log(pwr_dpss1.2[,1]),log(pwr_dpss3.2[,1]) ))

pl(2)
plot(freq.2[,1],log(pwr_rect.2[,1]),type="l",ylim=c(ymin,ymax),lwd=2,ylab="log(Power)",
     xlab="Frequency (cycles/ka)",
     main="Comparison of rectangle (black), cosine (blue) and Hann (orange) taper",
     cex.main=1)
lines(freq.2[,1],log(pwr_hann.2[,1]),col="orange",lwd=2)
lines(freq.2[,1],log(pwr_cos.2[,1]),col="blue")
points(c(1/100,1/40,1/29,1/21,1/19,1/14,1/10,1/5,1/4,1/3),rep(ymax,10),cex=.5,
        col="purple")

plot(freq.2[,1],log(pwr_rect.2[,1]),type="l",ylim=c(ymin,ymax),lwd=2,ylab="log(Power)",
      xlab="Frequency (cycles/ka)",
      main="Comparison of rectangle (black), 1pi DPSS (green) and 3pi DPSS (red) taper",
      cex.main=1)
lines(freq.2[,1],log(pwr_dpss1.2[,1]),col="green")
lines(freq.2[,1],log(pwr_dpss3.2[,1]),col="red",lwd=2)
points(c(1/100,1/40,1/29,1/21,1/19,1/14,1/10,1/5,1/4,1/3),rep(ymax,10),cex=.5,
      col="purple")

# ***** PART 3: Return to PART 1, but this time increase the zero padding to 2 (pad=2)
</code></pre>

<hr>
<h2 id='pl'>Set up plots</h2><span id='topic+pl'></span>

<h3>Description</h3>

<p>Open new device and set up for multiple plots, output to screen or PDF if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl(n,r,c,h,w,mar,file,title)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pl_+3A_n">n</code></td>
<td>
<p>Number of plots per page (1-25). When specified, this parameter takes precedence and the default settings for r and c are used (the r and c options below are ignored).</p>
</td></tr>
<tr><td><code id="pl_+3A_r">r</code></td>
<td>
<p>Number of rows of plots.</p>
</td></tr>
<tr><td><code id="pl_+3A_c">c</code></td>
<td>
<p>Number of columns of plots.</p>
</td></tr>
<tr><td><code id="pl_+3A_h">h</code></td>
<td>
<p>Height of new page (a.k.a. &quot;device&quot;).</p>
</td></tr>
<tr><td><code id="pl_+3A_w">w</code></td>
<td>
<p>Width of new page (a.k.a. &quot;device&quot;).</p>
</td></tr>
<tr><td><code id="pl_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form c(bottom, left, top, right) which gives the margin size specified in inches.</p>
</td></tr>
<tr><td><code id="pl_+3A_file">file</code></td>
<td>
<p>File name, in quotes. Accepted file formats include .pdf, .jpg, .png, .tiff, .bmp; the format must be indicated using the appropriate filename extension at the end of the file name. If a file name is not designated, the plot is output to the screen instead.</p>
</td></tr>
<tr><td><code id="pl_+3A_title">title</code></td>
<td>
<p>Plot title (must be in quotes)</p>
</td></tr>
</table>

<hr>
<h2 id='plotEha'>Create color time-frequency plots from eha results.</h2><span id='topic+plotEha'></span>

<h3>Description</h3>

<p>Create color time-frequency plots from eha results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEha(spec,xmin,xmax,ymin,ymax,h=6,w=4,ydir=1,pl=0,norm,palette=6,
        centerZero=T,ncolors=100,colorscale=F,xlab,ylab,filetype=0,output=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEha_+3A_spec">spec</code></td>
<td>
<p>Time-frequency spectral results to evaluate. Must have the following format: column 
1=frequency; remaining columns (2 to n)=power, amplitude or probability; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_xmin">xmin</code></td>
<td>
<p>Minimum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_xmax">xmax</code></td>
<td>
<p>Maximum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height for PLOTTING.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height for PLOTTING.</p>
</td></tr> 
<tr><td><code id="plotEha_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr> 
<tr><td><code id="plotEha_+3A_pl">pl</code></td>
<td>
<p>An option for the color plots (0=linear scale; 1=plot log of value [useful for plotting power], 2=normalize to maximum value in each window [useful for plotting amplitude], 3=use normalization provided in norm.</p>
</td></tr> 
<tr><td><code id="plotEha_+3A_norm">norm</code></td>
<td>
<p>Optional amplitude normalization divisor, consisting of a single column dataframe. This option is provided in case you'd like to normalize a set of EHA results using the same scheme (e.g., before and after removal of spectral lines).</p>
</td></tr>
<tr><td><code id="plotEha_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red (if values are negative and positive, white is centered on zero), (6) viridis</p>
</td></tr>
<tr><td><code id="plotEha_+3A_centerzero">centerZero</code></td>
<td>
<p>Center color scale on zero (use an equal number of postive and negative color divisions)? (T or F)</p>
</td></tr>
<tr><td><code id="plotEha_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors steps to use in palette.</p>
</td></tr>
<tr><td><code id="plotEha_+3A_colorscale">colorscale</code></td>
<td>
<p>Include a color scale in the plot? (T or F)</p>
</td></tr>
<tr><td><code id="plotEha_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis. Default = &quot;Frequency&quot;</p>
</td></tr>
<tr><td><code id="plotEha_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis. Default = &quot;Location&quot;</p>
</td></tr>
<tr><td><code id="plotEha_+3A_filetype">filetype</code></td>
<td>
<p>Generate .pdf, .jpeg, .png or tiff file? (0=no; 1=pdf; 2=jpeg; 3=png; 4=tiff)</p>
</td></tr>
<tr><td><code id="plotEha_+3A_output">output</code></td>
<td>
<p>If amplitude is normalized (pl = 2), output normalization used? (T or F)</p>
</td></tr>
<tr><td><code id="plotEha_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## as an example, evaluate the modelA
data(modelA)

## interpolate to even sampling interval of 0.075 m
ex1=linterp(modelA, dt=0.075)
  
## perform EHA with a time-bandwidth parameter of 2, using an 7.95 meter window, 0.15 m step, 
## and pad to 1000 points, output amplitude
res=eha(ex1,tbw=2,win=7.95,step=0.15,pad=1000,genplot=0,output=3)

# plot EHA amplitude, normalized to maximum value in each window
plotEha(res,xlab="Frequency (cycles/m)",ylab="Height (m)",pl=2)
</code></pre>

<hr>
<h2 id='plS'>Set default plotting parameters for vertical stratigraphic plots</h2><span id='topic+plS'></span>

<h3>Description</h3>

<p>Set default plotting parameters for vertical stratigraphic plots. This is ususally invoked after function pl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plS(f=T,s=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plS_+3A_f">f</code></td>
<td>
<p>Are you plotting the first (leftmost) stratigraphic plot? (T or F)</p>
</td></tr>
<tr><td><code id="plS_+3A_s">s</code></td>
<td>
<p>Size of the symbols and text on plot. Default = 1</p>
</td></tr>
</table>

<hr>
<h2 id='prewhiteAR'>Prewhiten stratigraphic series with autoregressive filter, order selected by Akaike Information Criterion</h2><span id='topic+prewhiteAR'></span>

<h3>Description</h3>

<p>Prewhiten stratigraphic series using autoregressive (AR) filter. Appropriate AR order can be automatically determined using the Akaike Information Criterion, or alternatively, the order may be predefined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prewhiteAR(dat,order=0,method="mle",aic=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prewhiteAR_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for prewhitening. First column should be location (e.g., depth), second column should be data value for prewhitening. Series must have uniform sampling interval.</p>
</td></tr>
<tr><td><code id="prewhiteAR_+3A_order">order</code></td>
<td>
<p>AR order for prewhitening (if aic=F), or alternatively, the maximum AR order to investigate (if aic=T). If order is set to &lt;=0, will evaluate up to maximum default order (this varies based on method).</p>
</td></tr>
<tr><td><code id="prewhiteAR_+3A_method">method</code></td>
<td>
<p>Method for AR parameter estimation: (&quot;yule-walker&quot;, &quot;burg&quot;, &quot;ols&quot;, &quot;mle&quot;, &quot;yw&quot;)</p>
</td></tr>
<tr><td><code id="prewhiteAR_+3A_aic">aic</code></td>
<td>
<p>Select model using AIC? if F, will use order. AIC is only strictly valid if method is &quot;mle&quot;.</p>
</td></tr>
<tr><td><code id="prewhiteAR_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="prewhiteAR_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akaike, H. (1974), <em>A new look at the statistical model identification</em>, IEEE Trans. Autom. Control, 19, 716-723, doi:10.1109/TAC.1974.1100705.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code> </p>

<hr>
<h2 id='prewhiteAR1'>Prewhiten stratigraphic series with AR1 filter, using 'standard' or unbiased estimate of rho</h2><span id='topic+prewhiteAR1'></span>

<h3>Description</h3>

<p>Prewhiten stratigraphic series using autoregressive-1 (AR1) filter. Rho can be estimated using the 'standard' approach, or following a bias correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prewhiteAR1(dat,setrho=NULL,bias=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prewhiteAR1_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for prewhitening. First column should be location (e.g., depth), second column should be data value for prewhitening. Series must have uniform sampling interval.</p>
</td></tr>
<tr><td><code id="prewhiteAR1_+3A_setrho">setrho</code></td>
<td>
<p>Specified lag-1 correlation coefficient (rho). By default, rho is calculated.</p>
</td></tr>
<tr><td><code id="prewhiteAR1_+3A_bias">bias</code></td>
<td>
<p>Calculate unbiased estimate of rho, as in Mudelsee (2010, eq. 2.45). (T or F)</p>
</td></tr>
<tr><td><code id="prewhiteAR1_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="prewhiteAR1_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>M. Mudelsee, 2010,
<em>Climate Time Series Analysis: Classical Statistical and Bootstrap Methods</em>, 474 pp., Springer, Dordrecht, Netherlands.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+arcsinT">arcsinT</a></code>, <code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+demean">demean</a></code>, <code><a href="#topic+detrend">detrend</a></code>, <code><a href="#topic+divTrend">divTrend</a></code>, <code><a href="#topic+logT">logT</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, and <code><a href="#topic+prewhiteAR">prewhiteAR</a></code> </p>

<hr>
<h2 id='pwrLaw'>Generate power law (1/f) noise surrogates</h2><span id='topic+pwrLaw'></span>

<h3>Description</h3>

<p>Generate power law (1/f) noise surrogates, following the algorithm of Timmer and Konig (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwrLaw(npts=1024,dt=1,mean=0,sdev=1,beta=2,fcut=0,nsim=1,genplot=T,verbose=T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwrLaw_+3A_npts">npts</code></td>
<td>
<p>number of data points for 1/f surrogate time series</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_dt">dt</code></td>
<td>
<p>sampling interval</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_mean">mean</code></td>
<td>
<p>mean value for 1/f surrogate series</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_sdev">sdev</code></td>
<td>
<p>standard deviation for 1/f surrogate series</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_beta">beta</code></td>
<td>
<p>power law coefficient. Positive number will yield a negative slope.</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_fcut">fcut</code></td>
<td>
<p>frequency cutoff: below this frequency a plateau will be modeled. Set to zero (default) for no plateau.</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_nsim">nsim</code></td>
<td>
<p>Number of surrogate series to generate</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F)</p>
</td></tr>
<tr><td><code id="pwrLaw_+3A_verbose">verbose</code></td>
<td>
<p>verbose output (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These simulations use the random number generator of Matsumoto and Nishimura (1998). 
Power law noise series are generated following the algorithm of Timmer and Konig (1995).
</p>


<h3>References</h3>

<p>M. Matsumoto, and T. Nishimura, (1998), 
<em>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudo-random number generator</em>, ACM Transactions on Modeling and Computer Simulation, 8, 3-30.
</p>
<p>J. Timmer and K. Konig (1995), 
<em>On Generating Power Law Noise</em>, Astronomy and Astrophysics: v. 300, p. 707-710.
</p>

<hr>
<h2 id='pwrLawFit'>Estimate power law (1/f) fit to power spectrum</h2><span id='topic+pwrLawFit'></span>

<h3>Description</h3>

<p>Estimate power law (1/f) fit to power spectrum, following the algorithm of Vaughan (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwrLawFit(spec,dof=2,flow=NULL,fhigh=NULL,output=1,genplot=T,verbose=T)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwrLawFit_+3A_spec">spec</code></td>
<td>
<p>Power spectrum. First column is frequency, second column is raw power (linear). Do not include the zero frequency and Nyquist.</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_dof">dof</code></td>
<td>
<p>Degrees of freedom for power spectral estimate. Default is 2, for a simple periodogram.</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_flow">flow</code></td>
<td>
<p>Lowest frequency to include in 1/f fit</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_fhigh">fhigh</code></td>
<td>
<p>Highest frequency to include in 1/f fit</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_output">output</code></td>
<td>
<p>Output results of 1/f fit? (0=none; 1=Frequency,Power,Power Law CL,Unbiased Power Law fit,CL_90,CL_95,CL_99; 2=beta, unbiased log10N, biased log10N)</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F)</p>
</td></tr>
<tr><td><code id="pwrLawFit_+3A_verbose">verbose</code></td>
<td>
<p>verbose output (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Vaughan, S. (2005), <em>A simple test for periodic signals in red noise</em>, Astronomy &amp; Astrophysics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 400 ka, 100 ka, 40 ka and 20 ka
ex = cycles(freqs=c(1/400,1/100,1/40,1/20),start=1,end=1000,dt=5)

# add AR1 noise
noise = ar1(npts=200,dt=5,sd=.5)
ex[2] = ex[2] + noise[2]

# calculate periodogram
res=periodogram(ex,output=1,padfac=1)

# extract power and remove the Nyquist frequency
resPwr=cb(res,c(1,3))
resPwr=resPwr[-length(resPwr[,1]),]

pwrLawFit(resPwr)
</code></pre>

<hr>
<h2 id='rankSeries'>Create lithofacies rank series from bed thickness data</h2><span id='topic+rankSeries'></span>

<h3>Description</h3>

<p>Create lithofacies rank series from bed thickness data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankSeries(dat,dt,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankSeries_+3A_dat">dat</code></td>
<td>
<p>First column should be bed thickness, and second column should bed lithofacies rank.</p>
</td></tr>
<tr><td><code id="rankSeries_+3A_dt">dt</code></td>
<td>
<p>Sampling interval for piecewise linear interpolation. By default a grid spacing that is 5 times smaller than the thinnest bed is used. If dt is set to zero, interpolation is skipped.</p>
</td></tr>
<tr><td><code id="rankSeries_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="rankSeries_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with random bed thicknesses
exThick=rnorm(n=20,mean=10,sd=2)
# assign alternating rank of 1 and 2
rank=double(20)
rank[seq(from=1,to=19,by=2)] &lt;- 1
rank[seq(from=2,to=20,by=2)] &lt;- 2

# combine into a dataframe
ex=cb(exThick,rank)

# generate lithofacies rank series
rankSeries(ex)
</code></pre>

<hr>
<h2 id='read'>Read data from file</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>Read stratigraphic data series from a file, either tab-delimited, CSV, or semicolon-delimited. First column MUST contain location data (depth, height, time). The function will remove missing entries, sort by location, average duplicate values, and generate summary plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(file=NULL,d=1,h="auto",skip=0,srt=T,ave=T,check=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_file">file</code></td>
<td>
<p>An optional file name, which must be in quotes (use the full directory path if the file is not in your present working directory). When a file name is not specified (the default), the file will be selected using a graphical user interface.</p>
</td></tr>
<tr><td><code id="read_+3A_d">d</code></td>
<td>
<p>What column delimiter is used? (0 = tab/.txt, 1 = comma/.csv, 2 = semicolon). CSV is the default option, which interfaces well with EXCEL.</p>
</td></tr>
<tr><td><code id="read_+3A_h">h</code></td>
<td>
<p>Does the data file have column titles/headers? (&quot;yes&quot;, &quot;no&quot;, &quot;auto&quot;). &quot;auto&quot; will auto detect column titles/headers, which must be single strings and start with a character.</p>
</td></tr>
<tr><td><code id="read_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before beginning to read file</p>
</td></tr>
<tr><td><code id="read_+3A_srt">srt</code></td>
<td>
<p>Sort data values by first column? (T or F)</p>
</td></tr>
<tr><td><code id="read_+3A_ave">ave</code></td>
<td>
<p>Average duplicate values? (T or F). Only applies if input file has 2 columns</p>
</td></tr>
<tr><td><code id="read_+3A_check">check</code></td>
<td>
<p>Check for sorting, duplicates, and empty entries in the data frame? (T or F). If set to F, sorting, duplicate averaging and empty entry removal are disabled.</p>
</td></tr>
<tr><td><code id="read_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F).</p>
</td></tr>
<tr><td><code id="read_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (in the file that you are reading from) should be indicated by 'NA'.
If you have included characters in the column titles that are not permitted by R, they will be modified!
</p>

<hr>
<h2 id='readMatrix'>Read data matrix from file</h2><span id='topic+readMatrix'></span>

<h3>Description</h3>

<p>Read data matrix from a file, either tab-delimited, CSV, or semicolon-delimited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMatrix(file=NULL,d=1,h="auto",skip=0,output=1,check=T,genplot=F,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMatrix_+3A_file">file</code></td>
<td>
<p>An optional file name, which must be in quotes (use the full directory path if the file is not in your present working directory). When a file name is not specified (the default), the file will be selected using a graphical user interface.</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_d">d</code></td>
<td>
<p>What column delimiter is used? (0 = tab/.txt, 1 = comma/.csv, 2 = semicolon). CSV is the default option, which interfaces well with EXCEL.</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_h">h</code></td>
<td>
<p>Does the data file have column titles/headers? (&quot;yes&quot;, &quot;no&quot;, &quot;auto&quot;). &quot;auto&quot; will auto detect column titles/headers, which must be single strings and start with a character.</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before beginning to read file</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_output">output</code></td>
<td>
<p>Return data as: 1= matrix, 2=data frame</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_check">check</code></td>
<td>
<p>Check for empty entries in the matrix? (T or F).</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_genplot">genplot</code></td>
<td>
<p>generate summary plots (T or F).</p>
</td></tr>
<tr><td><code id="readMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (in the file that you are reading from) should be indicated by 'NA'.
If you have included characters in the column titles that are not permitted by R, they will be modified!
</p>

<hr>
<h2 id='repl0'>Replace values &lt; 0 with 0</h2><span id='topic+repl0'></span>

<h3>Description</h3>

<p>Replace all variable values &lt; 0 with 0. If first column is location ID (depth/height/time), it will not be processed.  Any number of variables (columns) permitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repl0(dat,ID=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repl0_+3A_dat">dat</code></td>
<td>
<p>Data series to process. If location is included (e.g., depth), it should be in the first column.</p>
</td></tr>
<tr><td><code id="repl0_+3A_id">ID</code></td>
<td>
<p>Is a location ID included in the first column? (T or F)</p>
</td></tr>
<tr><td><code id="repl0_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="repl0_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='replEps'>Replace values &lt;= 0 with smallest positive value</h2><span id='topic+replEps'></span>

<h3>Description</h3>

<p>Replace all variable values &lt;= 0 with the smallest positive floating-point number (eps) that can be represented on machine. If first column is location ID (depth/height/time), it will not be processed.  Any number of variables (columns) permitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replEps(dat,ID=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replEps_+3A_dat">dat</code></td>
<td>
<p>Data series to process. If location is included (e.g., depth), it should be in the first column.</p>
</td></tr>
<tr><td><code id="replEps_+3A_id">ID</code></td>
<td>
<p>Is a location ID included in the first column? (T or F)</p>
</td></tr>
<tr><td><code id="replEps_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="replEps_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='resample'>Resample stratigraphic series</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample a stratigraphic series using a new (variably sampled) time or space axis. Values are piecewise-linearly interpolated from original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(dat,xout,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for resampling. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="resample_+3A_xout">xout</code></td>
<td>
<p>Vector of new sampling locations.</p>
</td></tr>
<tr><td><code id="resample_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="resample_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='rmNA'>Remove stratigraphic levels that contain one or more NAs</h2><span id='topic+rmNA'></span>

<h3>Description</h3>

<p>Remove stratigraphic levels that contain one or more NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmNA(dat,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmNA_+3A_dat">dat</code></td>
<td>
<p>Data series to process. If location is included (e.g., depth), it should be in the first column.</p>
</td></tr>
<tr><td><code id="rmNA_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="rmNA_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='s'>Standardize variable in stratigraphic series</h2><span id='topic+s'></span>

<h3>Description</h3>

<p>Standardize variable in stratigraphic series (subtract mean value and divide by standard deviation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s(dat,genplot=F,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for standardization. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="s_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="s_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='sedRamp'>Apply 'ramping' sedimentation rate model to convert time to stratigraphy</h2><span id='topic+sedRamp'></span>

<h3>Description</h3>

<p>Apply a linearly increasing (or decreasing) sedimentation rate model to convert time to stratigraphy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sedRamp(dat,srstart=0.01,srend=0.05,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sedRamp_+3A_dat">dat</code></td>
<td>
<p>Time series. First column should be time (in ka), second column should be data value.</p>
</td></tr>
<tr><td><code id="sedRamp_+3A_srstart">srstart</code></td>
<td>
<p>Initial sedimentation rate (in m/ka).</p>
</td></tr>
<tr><td><code id="sedRamp_+3A_srend">srend</code></td>
<td>
<p>Final sedimentation rate (in m/ka).</p>
</td></tr>
<tr><td><code id="sedRamp_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="sedRamp_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modeled stratigraphic series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with 3 precession terms using function 'cycles'
# then convert from time to space using sedimentation rate that increases from 1 to 7 cm/ka
ex=sedRamp(cycles(),srstart=0.01,srend=0.07)
</code></pre>

<hr>
<h2 id='sedrate2time'>Integrate sedimentation rate curve to obtain time-space map</h2><span id='topic+sedrate2time'></span>

<h3>Description</h3>

<p>Integrate sedimentation rate curve to obtain time-space map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sedrate2time(sedrates,timedir=1,genplot=T,check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sedrate2time_+3A_sedrates">sedrates</code></td>
<td>
<p>Data frame containing depth/height in first column (meters) and sedimentation rates in second column (cm/ka).</p>
</td></tr>
<tr><td><code id="sedrate2time_+3A_timedir">timedir</code></td>
<td>
<p>Floating time scale direction: 1= time increases with depth/height; 2= time decreases with depth/height.)</p>
</td></tr>
<tr><td><code id="sedrate2time_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="sedrate2time_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="sedrate2time_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='slideCor'>Identify optimal spatial/temporal shift to maximize correlation between two stratigraphic/time series.</h2><span id='topic+slideCor'></span>

<h3>Description</h3>

<p>Identify optimal spatial/temporal shift to maximize correlation between two stratigraphic/time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideCor(dat1,dat2,rev=F,cormethod=1,minpts=NULL,detrend=F,rmin=NULL,
         output=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slideCor_+3A_dat1">dat1</code></td>
<td>
<p>Stratigraphic series 1. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="slideCor_+3A_dat2">dat2</code></td>
<td>
<p>Stratigraphic series 2. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="slideCor_+3A_rev">rev</code></td>
<td>
<p>Reverse polarity of stratigraphic series 2 (multiply proxy data value by -1)? (T or F)</p>
</td></tr>
<tr><td><code id="slideCor_+3A_cormethod">cormethod</code></td>
<td>
<p>Method used for calculation of correlation coefficient (1=Pearson, 2=Spearman rank, 3=Kendall)</p>
</td></tr>
<tr><td><code id="slideCor_+3A_minpts">minpts</code></td>
<td>
<p>Minimum number of data points for calculation of correlation coefficient.</p>
</td></tr>
<tr><td><code id="slideCor_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from each window? (T or F)</p>
</td></tr>
<tr><td><code id="slideCor_+3A_rmin">rmin</code></td>
<td>
<p>Minimum r and r2 value shown on plots. By default all r and r2 values will be displayed.</p>
</td></tr>
<tr><td><code id="slideCor_+3A_output">output</code></td>
<td>
<p>Output correlation coefficient results as a dataframe? (T or F)</p>
</td></tr>
<tr><td><code id="slideCor_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="slideCor_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>slideCor is a general purpose tool to identify the optimal spatial/temporal correlation 
between two data sets. A few example applications include:
(1) stratigraphic correlation of data series from two locations (as in Preto et al., 2004), 
(2) identification of the optimal spatial/temporal lag between two variables from the 
same site, and (3) identification of the optimal fit between a floating astrochronology 
and astronomical target (e.g, Mitchell et al., 2008). 
</p>
<p>Both series must be evenly sampled, but are not required to have the same sampling interval.
If stratigraphic series of different duration/length are being compared, the shift (in 
spatial or temporal units) should be interpreted as the location within the longer
stratigraphic series where the shorter stratigraphic series begins.
If both stratigraphic series are of the same duration/length, then the shift is the
location within dat1 where dat2 begins.
</p>
<p>In some cases, it may be desirable to smooth or bandpass the data series before 
implementing slideCor (e.g., functions noLow, noKernel, bandpass, taner, etc.).
</p>


<h3>References</h3>

<p>Preto, N., Hinnov, L.A., De Zanche, V., Mietto, P., and Hardie, L.A., 2004, <em>The Milankovitch interpretation of the Latemar Platform cycles (Dolomites, Italy): Implications for geochronology, biostratigraphy, and Middle Triassic carbonate accumulation</em>, SEPM Special Publication 81.
</p>
<p>Mitchell, R.N., Bice, D.M., Montanari, A., Cleaveland, L.C., Christianson, K.T., Coccioni, R., and Hinnov, L.A., 2008, <em>Oceanic anoxic cycles? Orbital prelude to the Bonarelli Level (OAE 2)</em>, Earth Planet. Sci. Lett. 26, 1-16.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+surrogateCor">surrogateCor</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: generate AR1 noise
ex1 &lt;- ar1(npts=1000,dt=1)
# isolate a section
ex2 &lt;- iso(ex1,xmin=200,500)
ex2[1] &lt;- ex2[1]-200

res=slideCor(ex1,ex2)

# Example 2: an astronomical signal
ex1=etp(tmin=0,tmax=1000)
# isolate a 200 ka section
ex2=iso(ex1,xmin=400,xmax=600)
# convert to a floating timescale (elapsed time)
ex2[1] &lt;- ex2[1]-400

res=slideCor(ex1,ex2)
# now anchor the floating time scale
anchor &lt;- ex1[res[which.max(res[,2]),1],1]
ex2.anchor &lt;- anchorTime(dat=ex2, time=0, age=anchor, timeDir=2)
</code></pre>

<hr>
<h2 id='sortNave'>Remove missing entries, sort data, average duplicates</h2><span id='topic+sortNave'></span>

<h3>Description</h3>

<p>Sort and average duplicates in stratigraphic series, as performed in 'read' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortNave(dat,sortDecr=F,ave=T,xmin=NULL,xmax=NULL,genplot=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortNave_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for processing. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="sortNave_+3A_sortdecr">sortDecr</code></td>
<td>
<p>Sorting direction? (F=increasing, T=decreasing)</p>
</td></tr>
<tr><td><code id="sortNave_+3A_ave">ave</code></td>
<td>
<p>Average duplicate values? (T or F)</p>
</td></tr>
<tr><td><code id="sortNave_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-axis value for plotting</p>
</td></tr>
<tr><td><code id="sortNave_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-axis value for plotting</p>
</td></tr>
<tr><td><code id="sortNave_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? 0=none, 1=stratigraphic series, distribution, box plot, Q-Q, 2=stratigraphic series</p>
</td></tr>
<tr><td><code id="sortNave_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='stepHeat'>Ar/Ar Geochronology: Generate an Ar/Ar age spectrum and calculate step-heating plateau age.</h2><span id='topic+stepHeat'></span>

<h3>Description</h3>

<p>The stepHeat function will evaluate data from stepwise heating experiments, producing an Ar/Ar age spectrum, 
a weighted mean age with uncertainty, and other helpful statistics/plots (with interactive graphics for data culling). 
The function includes the option to generate results using the approach of IsoPlot 3.70 (Ludwig, 2008) or ArArCALC (Koppers, 2002).</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepHeat(dat,unc=1,lambda=5.463e-10,J=NULL,Jsd=NULL,CI=2,cull=-1,del=NULL,output=F,
         idPts=T,size=NULL,unit=1,setAr=95,color="black",genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepHeat_+3A_dat">dat</code></td>
<td>
<p>dat must be a data frame with seven columns, as follows: (1) %Ar39 released, (2) date, (3) date uncertainty (one or two sigma), (4) K/Ca, (5) %Ar40*, (6) F, and (7) F uncertainty (one or two sigma). NOTE: F is the ratio Ar40*/Ar39K (see Koppers, 2002).</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_unc">unc</code></td>
<td>
<p>What is the uncertainty on your input dates? (1) one sigma, or (2) two sigma. DEFAULT is one sigma. This also applies to the F uncertainty, and the J-value uncertainty (if specified) </p>
</td></tr>
<tr><td><code id="stepHeat_+3A_lambda">lambda</code></td>
<td>
<p>Total decay constant of K40, in units of 1/year. The default value is 5.463e-10/year (Min et al., 2000).</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_j">J</code></td>
<td>
<p>Neutron fluence parameter</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_jsd">Jsd</code></td>
<td>
<p>Uncertainty for J-value (neutron fluence parameter; as one or two sigma)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_ci">CI</code></td>
<td>
<p>Which convention would you like to use for the 95% confidence intervals? (1) ISOPLOT (Ludwig, 2008), (2) ArArCALC (Koppers, 2002)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_cull">cull</code></td>
<td>
<p>Would you like select dates with a graphical interface? (0=no, 1=select points to retain, -1=select points to remove)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_del">del</code></td>
<td>
<p>A vector of indices indicating dates to remove from weighted mean calculation. If specified, this takes precedence over cull.</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_output">output</code></td>
<td>
<p>Return weighted mean results as new data frame? (T or F)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_idpts">idPts</code></td>
<td>
<p>Identify datum number on each point? (T or F)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_size">size</code></td>
<td>
<p>Multiplicative factor to increase or decrease size of symbols and fonts. The default is 1.4</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_unit">unit</code></td>
<td>
<p>The time unit for your results. (1) = Ma, (2) = Ka</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_setar">setAr</code></td>
<td>
<p>Set the %Ar40* level to be illustrated on the plot. The default is 95%.</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_color">color</code></td>
<td>
<p>Color to use for symbols. Default is black.</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="stepHeat_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs weighted mean age calculations for step-heating data, including estimation of age uncertainties, 
mean square weighted deviation, and probability of fit. 
</p>
<p>The following plots are produced:
</p>
<p>(1) %Ar40* versus %Ar39 released
</p>
<p>(2) K/Ca versus %Ar39 released
</p>
<p>(3) Ar/Ar age spectrum, with 2 sigma uncertainties for each step, and weighted mean with 95% confidence interval (in red)
</p>
<p>If the J-value and its uncertainty are input, stepHeat will calculate and include the uncertainty associated with J. The uncertainty is calculated and propagated following equation 18 of Koppers (2002).
</p>
<p>A NOTE regarding confidence intervals: There are two conventions that can be used to calculate the confidence intervals, selected with the option 'CI':
</p>
<p>(1) ISOPLOT convention (Ludwig, 2008). When the probability of fit is &gt;= 0.15, the confidence interval is based on 1.96*sigma.  When the probability of fit is &lt; 0.15, the confidence interval is based on t*sigma*sqrt(MSWD). 
</p>
<p>(2) ArArCALC convention (Koppers, 2002). When MSWD &lt;=1, the confidence interval is based on 1.96*sigma. When MSWD &gt; 1, the confidence interval is based on 1.96*sigma*sqrt(MSWD).
</p>
<p>ADDITIONAL ADVICE: Use the function readMatrix to load your data in R (rather than the function read).
</p>


<h3>References</h3>

<p>A.A.P. Koppers, 2002,
<em>ArArCALC- software for 40Ar/39Ar age calculations</em>: Computers &amp; Geosciences, v. 28, p. 605-619.
</p>
<p>K.R. Ludwig, 2008,
<em>User's Manual for Isoplot 3.70: A Geochronological Toolkit for Microsoft Excel</em>: Berkeley Geochronology Center Special Publication No. 4, Berkeley, 77 p.
</p>
<p>I. McDougall and T.M. Harrison, 1991,
<em>Geochronology and Thermochronology by the 40Ar/39Ar Method</em>: Oxford University Press, New York, 269 pp.
</p>
<p>K. Min, R. Mundil, P.R. Renne, and K. Ludwig, 2000,
<em>A test for systematic errors in 40Ar/39Ar geochronology through comparison with U/Pb analysis of a 1.1-Ga rhyolite</em>: Geochimica et Cosmochimica Acta, v. 64, p. 73-98.
</p>
<p>I. Wendt and C. Carl, 1991,
<em>The statistical distribution of the mean squared weighted deviation</em>: Chemical Geology, v. 86, p. 275-285.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+wtMean">wtMean</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Check to see if this is an interactive R session, for compliance with CRAN standards.
# YOU CAN SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

# Sample MT-09-09 incremental heating Ar/Ar data from Sageman et al. (2014).
perAr39 &lt;- c(4.96,27.58,19.68,39.9,6.25,1.02,0.42,0.19)
age &lt;- c(90.08,89.77,89.92,89.95,89.89,89.55,87.71,86.13)
sd &lt;- c(0.18,0.11,0.08,0.06,0.14,0.64,1.5,3.22)
KCa &lt;- c(113,138,101,195,307,27,17,24)
perAr40 &lt;- c(93.42,99.42,99.64,99.79,99.61,97.99,94.64,90.35)
Fval &lt;- c(2.148234,2.140643,2.144197,2.145006,2.143627,2.135163,2.090196,2.051682)
Fsd &lt;- c(0.00439,0.00270,0.00192,0.00149,0.00331,0.01557,0.03664,0.07846)
ex &lt;- data.frame(cbind(perAr39,age,sd,KCa,perAr40,Fval,Fsd))

stepHeat(ex)

# plot without points identified
stepHeat(ex,size=0,idPts=FALSE,cull=0)

}
 
## End(Not run)
</code></pre>

<hr>
<h2 id='strats'>Summary statistics for stratigraphic series</h2><span id='topic+strats'></span>

<h3>Description</h3>

<p>Summary statistics for stratigraphic series: sampling interval and proxy values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strats(dat,output=0,genplot=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strats_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to evaluate. The first column should contain location (e.g., depth), and the second column should contain data value. This function also accepts non-stratigraphic (single column) input, in which case the sampling interval assessment is skipped.</p>
</td></tr>
<tr><td><code id="strats_+3A_output">output</code></td>
<td>
<p>Output: (0) nothing, (1) cumulative dt as percent of data points, (2) cumulative dt as percent of total interval duration, (3) dt by location</p>
</td></tr>
<tr><td><code id="strats_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (0) none, (1) include plot of cumulative dt, (2) include dt histogram/density plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will generate a range of summary statistics for time series, including 
sampling interval information and the statistical distribution of proxy values.
</p>

<hr>
<h2 id='surrogateCor'>Estimate correlation coefficient and significance for serially correlated data</h2><span id='topic+surrogateCor'></span>

<h3>Description</h3>

<p>Estimate correlation coefficient and significance for serially correlated data. This 
algorithm permits the analysis of data sets with different sampling grids, as 
discussed in Baddouh et al. (2016). The sampling grid from the data set with fewer 
points (in the common interval) is used for resampling. Resampling is conducted 
using piecewise-linear interpolation. 
</p>
<p>If either dat1 or dat2 have only one column, the resampling is skipped. 
</p>
<p>The significance of the correlation is determined using the method of Ebisuzaki W. (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogateCor(dat1,dat2,firstDiff=F,cormethod=1,nsim=1000,output=2,genplot=T,check=T,
             verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogateCor_+3A_dat1">dat1</code></td>
<td>
<p>Data series with one or two columns. If two columns, first should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_dat2">dat2</code></td>
<td>
<p>Data series with one or two columns. If two columns, first should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_firstdiff">firstDiff</code></td>
<td>
<p>Calculate correlation using first differences? (T or F)</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_cormethod">cormethod</code></td>
<td>
<p>Method used for calculation of correlation coefficient (1=Pearson, 2=Spearman rank, 3=Kendall)</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_nsim">nsim</code></td>
<td>
<p>Number of phase-randomized surrogate series to generate. If nsim &lt;=1, simulation is deactivated.</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_output">output</code></td>
<td>
<p>Return which of the following?: 1= correlation coefficients for each simulation;  2= correlation coefficient for data series; 3= data values used in correlation estimate (resampled)</p>
</td></tr>  
<tr><td><code id="surrogateCor_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="surrogateCor_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Paraphrased from Baddouh et al. (2016):
To provide a quantitative evaluation of the correlation between two data sets that do
not share a common sampling grid, we introduce a statistical approach that employs sample 
interpolation, and significance testing with phase-randomized surrogate data (Ebisuzaki, 1997). 
The sparser sampling grid is used to avoid over-interpolation. Correlation is evaluated 
using Pearson, Spearman Rank, or Kendall rank coefficients. The statistical significance of the 
resulting correlation coefficients are estimated via Monte Carlo simulations 
using phase-randomized surrogates; the surrogates are subject to the same interpolation 
process, and compensate for potential serial correlation of data (Ebisuzaki, 1997).  
</p>
<p>The first-difference series of each variable can also evaluated, to assess correlation in 
the magnitude of change between sequential stratigraphic samples rather than absolute 
magnitude.  
</p>


<h3>References</h3>

<p>M. Baddouh, S.R. Meyers, A.R. Carroll, B.L. Beard, C.M. Johnson , 2016,
<em>Lacustrine 87-Sr/86-Sr as a tracer to reconstruct Milankovitch forcing of the Eocene hydrologic cycle</em>: Earth and Planetary Science Letters.
</p>
<p>W. Ebisuzaki, 1997,
<em>A Method to Estimate the Statistical Significance of a Correlation When the Data Are Serially Correlated</em>: Journal of Climate, v. 10, p. 2147-2153.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+surrogates">surrogates</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate two stochastic AR1 series
ex1 &lt;- ar1(npts=100,dt=5)
ex2 &lt;- ar1(npts=100,dt=6)

# calculate pearson correlation coefficient and p-value 
surrogateCor(ex1,ex2)
</code></pre>

<hr>
<h2 id='surrogates'>Generate phase-randomized surrogate series as in Ebisuzaki (1997)</h2><span id='topic+surrogates'></span>

<h3>Description</h3>

<p>Generate phase-randomized surrogate series as in Ebisuzaki (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogates(dat,nsim=1,preserveMean=T,std=T,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogates_+3A_dat">dat</code></td>
<td>
<p>Data series with one or two columns. If two columns, first should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="surrogates_+3A_nsim">nsim</code></td>
<td>
<p>Number of phase-randomized surrogate series to generate.</p>
</td></tr>
<tr><td><code id="surrogates_+3A_preservemean">preserveMean</code></td>
<td>
<p>Should surrogate series have the same mean value as data series? (T or F)</p>
</td></tr>
<tr><td><code id="surrogates_+3A_std">std</code></td>
<td>
<p>Standardize results to guarantee equivalent variance as data series? (T or F)</p>
</td></tr>
<tr><td><code id="surrogates_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? Only applies if nsim=1. (T or F)</p>
</td></tr>
<tr><td><code id="surrogates_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will generate phase-randomized surrogate series as in Ebisuzaki (1997). It
is an R-translation of the Matlab code by V. Moron (see link below), with modifications and
additional features.
</p>


<h3>References</h3>

<p>W. Ebisuzaki, 1997,
<em>A Method to Estimate the Statistical Significance of a Correlation When the Data Are Serially Correlated</em>: Journal of Climate, v. 10, p. 2147-2153.
</p>
<p>Matlab code by V. Moron: http://www.mathworks.com/matlabcentral/fileexchange/10881-weaclim/content/ebisuzaki.m
</p>
<p>Original C-code by W. Ebisuzaki: http://www.ftp.cpc.ncep.noaa.gov/wd51we/random_phase/
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with 3 precession terms and noise
ex &lt;- cycles(start=0,end=500,noisevar=.0004,dt=5)

# generate phase-randomized surrogates 
ran_ex &lt;- surrogates(ex,nsim=1)

# compare periodograms of data and surrogates
res1 &lt;- periodogram(ex,padfac=0,output=1,genplot=FALSE)
res2 &lt;- periodogram(ran_ex,padfac=0,output=1,genplot=FALSE)

pl(2)
plot(ex,type="l",main="black=original; red=surrogate")
lines(ran_ex,col="red",lty=4)
plot(res1[,1],res1[,2],type="l",lwd=2,main="black=original; red=surrogate",
     xlab="frequency",ylab="amplitude")
lines(res2[,1],res2[,2],col="red",lwd=2,lty=4)
</code></pre>

<hr>
<h2 id='synthStrat'>Synthesize stratigraphy from forcing function</h2><span id='topic+synthStrat'></span>

<h3>Description</h3>

<p>Synthesize stratigraphy from forcing function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthStrat(signal=NULL,nfacies=4,clip=T,flip=F,fmax=0.1,output=F,genplot=2,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthStrat_+3A_signal">signal</code></td>
<td>
<p>Forcing signal. First column should be time (in ka), second column should be forcing.</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_nfacies">nfacies</code></td>
<td>
<p>Number of sedimentary facies to model.</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_clip">clip</code></td>
<td>
<p>Clip forcing signal at mean value? (T or F)</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_flip">flip</code></td>
<td>
<p>Reverse the sign of the forcing? (T or F)</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_fmax">fmax</code></td>
<td>
<p>Maximum frequency for spectra (if genplot=2).</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_output">output</code></td>
<td>
<p>Output facies series? (T or F)</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (1) plot stratigraphy, (2) plot statigraphy and spectra.</p>
</td></tr>
<tr><td><code id="synthStrat_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modeled stratigraphic series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# EX.1: precession, unclipped
signal=etp(tmin=8400,tmax=8900,pWt=1,oWt=0,eWt=0)
synthStrat(signal,nfacies=4,clip=FALSE,genplot=2)

# EX.2: more finely resolved facies
#synthStrat(signal,nfacies=15,clip=FALSE,genplot=2)

# EX.3: couplets
#synthStrat(signal,nfacies=2,clip=FALSE,genplot=2)

# EX.4: precession, clipped
#synthStrat(signal,nfacies=4,genplot=2)

# EX.5: noise
noise=ar1(npts=501,rho=0.8)
#synthStrat(noise,nfacies=4,genplot=2)

# EX.6: precession + noise 
#signal2=signal
#signal2[2]=signal2[2]+0.75*noise[2]
#synthStrat(signal2,nfacies=4,genplot=2)

# EX.7: p-0.5t, clipped (demonstrates interference pattern; compare with EX.4
#signal3=etp(tmin=8400,tmax=8900,pWt=1,oWt=-0.5,eWt=0)
#synthStrat(signal3,nfacies=4,genplot=2)

# EX.8: ice sheet model, using p-0.5t
#ice=imbrie()
#synthStrat(ice,nfacies=5,clip=FALSE,genplot=2)

# EX.9: precession, clipped, ramping sedimentation rate
#synthStrat(linterp(sedRamp(signal,genplot=FALSE),genplot=FALSE),nfacies=6,
# clip=TRUE,genplot=2,fmax=10)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='taner'>Apply Taner bandpass or lowpass filter to stratigraphic series</h2><span id='topic+taner'></span>

<h3>Description</h3>

<p>Apply Taner bandpass or lowpass filter to stratigraphic series. This function can also be used to notch filter or highpass a record (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taner(dat,padfac=2,flow=NULL,fhigh=NULL,roll=10^3,demean=T,detrend=F,addmean=T,
       output=1,xmin=0,xmax=Nyq,genplot=T,check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taner_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for bandpass filtering. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="taner_+3A_padfac">padfac</code></td>
<td>
<p>Pad with zeros to (padfac*npts) points, where npts is the original number of data points.</p>
</td></tr>
<tr><td><code id="taner_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner filter (half power point). If this value is not set (NULL), it will default to -1*fhigh, which will create a lowpass filter.</p>
</td></tr>
<tr><td><code id="taner_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner filter (half power point).</p>
</td></tr>
<tr><td><code id="taner_+3A_roll">roll</code></td>
<td>
<p>Roll-off rate, in dB/octave.  Typical values are 10^3 to 10^12, but can be larger.</p>
</td></tr>
<tr><td><code id="taner_+3A_demean">demean</code></td>
<td>
<p>Remove mean from data series? (T or F)</p>
</td></tr>
<tr><td><code id="taner_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="taner_+3A_addmean">addmean</code></td>
<td>
<p>Add mean value to bandpass result? (T or F)</p>
</td></tr>
<tr><td><code id="taner_+3A_output">output</code></td>
<td>
<p>Output: (1) filtered series, (2) bandpass filter window.</p>
</td></tr>
<tr><td><code id="taner_+3A_xmin">xmin</code></td>
<td>
<p>Smallest frequency for plotting.</p>
</td></tr>
<tr><td><code id="taner_+3A_xmax">xmax</code></td>
<td>
<p>Largest frequency for plotting.</p>
</td></tr>
<tr><td><code id="taner_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="taner_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="taner_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bandpassed stratigraphic series.
</p>


<h3>References</h3>

<p>http://www.rocksolidimages.com/pdf/attrib_revisited.htm#_Toc328470897
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, <code><a href="#topic+noLow">noLow</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 405 ka, 100 ka, 40ka, and 20 ka, plus noise
ex=cycles(freqs=c(1/405,1/100,1/40,1/20),end=1000,dt=5,noisevar=.1)

# bandpass precession term using Taner window 
bandpass_ex &lt;- taner(ex,flow=0.045,fhigh=0.055,roll=10^10)

# lowpass filter eccentricity terms using Taner window
lowpass_ex=taner(ex,fhigh=.02,roll=10^10)

# notch filter (remove) obliquity term using Taner window
#  if you'd like the final notch filtered record to be centered on the mean proxy 
#  value, set addmean=FALSE
notch_ex &lt;- taner(ex,flow=0.02,fhigh=0.03,roll=10^10,addmean=FALSE)
notch_ex[2] &lt;- ex[2]-notch_ex[2]
pl(2)
plot(ex,type="l",main="Eccentricity+Obliquity+Precession")
plot(notch_ex,type="l",main="Following application of obliquity notch filter")

# highpass filter obliquity and precession terms using Taner window
#  if you'd like the final highpass filtered record to be centered on the mean proxy 
#  value, set addmean=FALSE
highpass_ex=taner(ex,fhigh=.02,roll=10^10,addmean=FALSE)
highpass_ex[2] &lt;- ex[2]-highpass_ex[2]
pl(2)
plot(ex,type="l",main="Eccentricity+Obliquity+Precession")
plot(highpass_ex,type="l",main="Obliquity+Precession highpassed signal")
</code></pre>

<hr>
<h2 id='tanerFC'>Apply Taner bandpass or lowpass filter to Fourier coefficients</h2><span id='topic+tanerFC'></span>

<h3>Description</h3>

<p>Apply Taner bandpass or lowpass filter to Fourier coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tanerFC(fc,npts,flow=NULL,fhigh=NULL,roll=10^3,output=1,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tanerFC_+3A_fc">fc</code></td>
<td>
<p>Fourier coefficients, as output by the function 'periodogram'. The first column is frequency, the second column contains the real coefficients, and the third column contains the imaginary coefficients.</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_npts">npts</code></td>
<td>
<p>The number of points in the stratigraphic series used to estimate the Fourier coefficients.</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner filter (half power point). If this value is not set (NULL), it will default to -1*fhigh, which will create a lowpass filter.</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner filter (half power point).</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_roll">roll</code></td>
<td>
<p>Roll-off rate, in dB/octave.  Typical values are 10^3 to 10^12, but can be larger.</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_output">output</code></td>
<td>
<p>Output: (1) filtered series, (2) bandpass filter window.</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="tanerFC_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed for cases when one needs to efficiently apply a range of filter 
parameters to a stratigraphic series. It is used within function 'timeOpt' to speed up 
processing. For more general use, function 'taner' is preferred, which also provides
a range of plots for evaluating the filtering.
</p>
<p>Fourier coefficients for 'tanerFC' can be determined with the function 'periodogram',
using options 'output=2' and 'nrm=0'.
</p>


<h3>Value</h3>

<p>bandpassed stratigraphic series.
</p>


<h3>References</h3>

<p>http://www.rocksolidimages.com/pdf/attrib_revisited.htm#_Toc328470897
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bandpass">bandpass</a></code>, <code><a href="#topic+lowpass">lowpass</a></code>, <code><a href="#topic+noKernel">noKernel</a></code>, <code><a href="#topic+noLow">noLow</a></code>, <code><a href="#topic+prewhiteAR">prewhiteAR</a></code>, and <code><a href="#topic+prewhiteAR1">prewhiteAR1</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with periods of 405 ka, 100 ka, 40ka, and 20 ka, plus noise
ex=cycles(freqs=c(1/405,1/100,1/40,1/20),end=1000,dt=5,noisevar=.1)

# calculate the Fourier coefficients using periodogram function. this must be done with 
# no normalization (nrm=0)
fc_ex &lt;- periodogram(ex,demean=TRUE,output=2,nrm=0)

# bandpass precession term using Taner window 
bandpass_ex &lt;- tanerFC(fc=fc_ex,npts=201,flow=0.045,fhigh=0.055,roll=10^10)

# lowpass filter eccentricity terms using Taner window
lowpass_ex &lt;- tanerFC(fc=fc_ex,npts=201,fhigh=.02,roll=10^10)
</code></pre>

<hr>
<h2 id='testBackground'>Evaluate power spectrum false positive rates via Monte Carlo simulation</h2><span id='topic+testBackground'></span>

<h3>Description</h3>

<p>This is a simulation tool to evaluate power spectrum false positive rates, the 
frequency distribution of the false positives, and the behavior of numerous
&quot;multiple correction&quot; procedures, for a range of background estimation 
approaches that are implemented in Astrochron. The tool can be used to conduct
surrogate analyses, alongside analysis of real data, to better understand
the suitability of particular background estimation approaches. The resulting 
simulations are similar to those presented in Figure 3 of Meyers (2012) and 
Crampton et al. (PNAS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testBackground(npts=1001,dt=5,noiseType="ar1",coeff=NULL,method="periodogramAR1",
               opt=NULL,demean=T,detrend=F,low=0,tbw=3,multi=F,iter=2000,output=F,
               genplot=F,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testBackground_+3A_npts">npts</code></td>
<td>
<p>Number of points in simulated stratigraphic series (surrogates).</p>
</td></tr>
<tr><td><code id="testBackground_+3A_dt">dt</code></td>
<td>
<p>Sampling interval for surrogates.</p>
</td></tr>
<tr><td><code id="testBackground_+3A_noisetype">noiseType</code></td>
<td>
<p>Select &quot;ar1&quot; for AR1 noise surrogates, or &quot;pwrLaw&quot; for Power Law noise surrogates</p>
</td></tr>
<tr><td><code id="testBackground_+3A_coeff">coeff</code></td>
<td>
<p>AR1 coefficient (rho) or Power Law coefficient (beta) for surrogates.</p>
</td></tr>
<tr><td><code id="testBackground_+3A_method">method</code></td>
<td>
<p>Background estimation method: (1) &quot;mtmAR1&quot; (function mtm), (2) &quot;mtmML96&quot; (function mtmML96), (3) &quot;lowspec&quot; (function lowspec), (4) &quot;mtmPL&quot; (function mtmPL), (5) &quot;periodogramPL&quot; (function periodogram), (6) &quot;periodogramAR1&quot; (function periodogram)</p>
</td></tr>
<tr><td><code id="testBackground_+3A_opt">opt</code></td>
<td>
<p>Method specific options. For mtmML96, this is medsmooth (see function mtmML96); for lowspec this is lowspan (see function lowspec); for periodogram this is percent cosine taper (see function cosTaper).</p>
</td></tr>
<tr><td><code id="testBackground_+3A_demean">demean</code></td>
<td>
<p>Remove mean value from simulated surrogates? (T or F; this option does not apply to lowspec)</p>
</td></tr>
<tr><td><code id="testBackground_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from simulated surrogates? (T or F)</p>
</td></tr>
<tr><td><code id="testBackground_+3A_low">low</code></td>
<td>
<p>Remove long-term trend using a LOWESS smoother? Choose a value ranging from 0-1 (see function noLow). 0 = no long-term trend removal.</p>
</td></tr>
<tr><td><code id="testBackground_+3A_tbw">tbw</code></td>
<td>
<p>MTM time-bandwidth product. This option is ignored for methods 5 and 6.</p>
</td></tr>
<tr><td><code id="testBackground_+3A_multi">multi</code></td>
<td>
<p>Evaluate a range of multiple-comparison tests too? (T or F)</p>
</td></tr>
<tr><td><code id="testBackground_+3A_iter">iter</code></td>
<td>
<p>Number of iterations (surrogate series) for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="testBackground_+3A_output">output</code></td>
<td>
<p>Output data frame? (T or F)</p>
</td></tr> 
<tr><td><code id="testBackground_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="testBackground_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Monte Carlo simulations can utilize AR1 or Power Law noise surrogates.
Background estimation approaches include conventional AR1, ML96, LOWSPEC 
and Power Law. The function also allows evaluation of common data detrending
approaches (linear trend removal, LOWESS trend removal).
</p>
<p>Note that MTM-ML96 conducts the Mann and Lees (1996; ML96) &quot;robust red noise&quot; analysis, 
with an improved median smoothing approach. The original Mann and Lees (1996) approach 
applies a truncation of the median smoothing window to include fewer frequencies near 
the edges of the spectrum; while truncation is required, its implementation in the 
original method often results in an &quot;edge effect&quot; that can produce excess false positive 
rates at low frequencies, commonly within the eccentricity-band (Meyers, 2012). To help 
address this issue, an alternative median smoothing approach is applied that implements 
Tukey's robust end-point rule and symmetrical medians (see the function mtmML96 for more
details). This version of the ML96 algorithm was first implemented in Patterson et al. (2014).
</p>
<p>See function multiTest for more information on the multiple comparison tests evaluated.
</p>


<h3>References</h3>

<p>W.S. Cleveland, 1979, 
<em>Locally weighted regression and smoothing scatterplots</em>: Journal of the American Statistical Association, v. 74, p. 829-836.
</p>
<p>J.S. Campton, S.R. Meyers, R.A. Cooper, P.M Sadler, M. Foote, D. Harte, 2018, 
<em>Pacing of Paleozoic macroevolutionary rates by Milankovitch grand cycles</em>: Proceedings of the National Academy of Sciences, doi:10.1073/pnas.1714342115.
</p>
<p>M.E. Mann, and J.M. Lees, 1996,
<em>Robust estimation of background noise and signal detection in climatic time series</em>, Clim. Change, 33, 409-445.
</p>
<p>S.R. Meyers, 2012,
<em>Seeing Red in Cyclic Stratigraphy: Spectral Noise Estimation for Astrochronology</em>: Paleoceanography, 27, PA3228, doi:10.1029/2012PA002307.
</p>
<p>M.O. Patterson, R. McKay, T. Naish, C. Escutia, F.J. Jimenez-Espejo, M.E. Raymo, M.E., 
S.R. Meyers, L. Tauxe, H. Brinkhuis, and IODP Expedition 318 Scientists,2014, 
<em>Response of the East Antarctic Ice Sheet to orbital forcing during the Pliocene and Early Pleistocene</em>, Nature Geoscience, v. 7, p. 841-847.
</p>
<p>D.J. Thomson, 1982, 
<em>Spectrum estimation and harmonic analysis</em>: IEEE Proceedings, v. 70, p. 1055-1096.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+confAdjust">confAdjust</a></code>,<code><a href="#topic+multiTest">multiTest</a></code>,<code><a href="#topic+lowspec">lowspec</a></code>, <code><a href="#topic+mtm">mtm</a></code>, <code><a href="#topic+mtmML96">mtmML96</a></code>, <code><a href="#topic+mtmPL">mtmPL</a></code>, and <code><a href="#topic+periodogram">periodogram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# evaluate false positive rate for MTM-AR1 using AR1 surrogates
testBackground(noiseType="ar1",method="mtmAR1")

# evaluate false positive rate for MTM-AR1 using Power Law surrogates
testBackground(noiseType="pwrLaw",method="mtmAR1")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='testPrecession'>Astrochronologic testing via the precession amplitude modulation approach of Zeeden et al. (2015).</h2><span id='topic+testPrecession'></span>

<h3>Description</h3>

<p>Astrochronologic testing via the precession amplitude modulation approach of Zeeden et al. (2015), as updated in Zeeden et al. (2018 submitted).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPrecession(dat,nsim=1000,gen=1,edge=0.025,maxNoise=1,rho=NULL,detrendEnv=T,
               solution=NULL,output=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPrecession_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to analyze. First column should be location (time in ka, a positive value), second column should be data value.</p>
</td></tr>
<tr><td><code id="testPrecession_+3A_nsim">nsim</code></td>
<td>
<p>Number of Monte Carlo simulations (phase-randomized surrogates or AR1 surrogates).</p>
</td></tr>
<tr><td><code id="testPrecession_+3A_gen">gen</code></td>
<td>
<p>Monte Carlo simulation generator: (1) use phase-randomized surrogates, (2) use AR1 surrogates.</p>
</td></tr>
<tr><td><code id="testPrecession_+3A_edge">edge</code></td>
<td>
<p>Percentage of record to exclude from beginning and end of data series, to remove edge effects. (a value from 0-1)</p>
</td></tr>  
<tr><td><code id="testPrecession_+3A_maxnoise">maxNoise</code></td>
<td>
<p>Maximum noise level to add in simulations. A value of 1 will apply maximum noise that is equivalent to 1 standard deviation of the data.</p>
</td></tr>
<tr><td><code id="testPrecession_+3A_rho">rho</code></td>
<td>
<p>Specified lag-1 correlation coefficient (rho). If rho is not specified, it will be calculated within the function.</p>
</td></tr>  
<tr><td><code id="testPrecession_+3A_detrendenv">detrendEnv</code></td>
<td>
<p>Linearly detrend envelope? (T or F)</p>
</td></tr>  
<tr><td><code id="testPrecession_+3A_solution">solution</code></td>
<td>
<p>Theoretical solution used for astrochronologic testing. Solution should be in the format: time (ka), precession angle, obliquity, eccentricity (the output from function 'getLaskar'). By default this is automatically determined within the function, using the solution of Laskar et al. (2004).</p>
</td></tr>  
<tr><td><code id="testPrecession_+3A_output">output</code></td>
<td>
<p>Return results as a new data frame? (T or F)</p>
</td></tr>  
<tr><td><code id="testPrecession_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="testPrecession_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This astrochronologic testing method compares observed precession-scale amplitude modulations to those expected from the theoretical eccentricity solutions. It is applicable for testing astrochronologies spanning 0-50 Ma. 
The technique implements a series of filters to guard against artificial introduction of eccentricity modulations during tuning and data processing, and evaluates the statistical significance of the results using Monte Carlo simulation (Zeeden et al., 2015). 
</p>
<p>The algorithm includes an improvement in the significance testing approach. Specifically, as a safeguard against artificially imposed modulations, an adaptive noise addition step is implemented (as outlined in Zeeden et al., submitted).
</p>
<p>The astronomically-tuned data series under evaluation should consist of two columns: time in kiloyears &amp; data value. 
Note that time must be positive. The default astronomical solutions used for the astrochronologic testing come from Laskar et al. (2004).
</p>
<p>When reporting a p-value for your result, it is important to consider the number of simulations used. 
A factor of 10 is appropriate, such that for 1000 simulations one would report a minimum p-value of &quot;p&lt;0.01&quot;, and for 10000 simulations one would report a minimum p-value of &quot;p&lt;0.001&quot;.
</p>
<p>Please be aware that the kernel density estimate plots, which summarize the simulations, represent 'smoothed' models. Due to the smoothing bandwidth, they can sometimes give the impression of simulation values that are larger or smaller than actually present.  However, the reported p-value does not suffer from these issues.
</p>
<p>IMPORTANT CHANGES (June 20, 2018): Note that this version has been updated to use 'solution' instead of 'esinw', for consistency with the function 'testTilt'. If you are invoking the default option, you do not need to make any changes to your script.
Also note that the new option 'edge' has been added, which by default will truncate your data series by 5 percent (2.5 percent on each end of the record), to guard against edge effects that can be present in the amplitude envelope. Set edge to 0 to reconstruct the
original (now legacy) 'testPrecession' approach.
</p>


<h3>Value</h3>

<p>When nsim is set to zero, the function will output a data frame with five columns:
</p>
<p>1=time, 2=precession bandpass filter output, 3=amplitude envelope of (2), 4=lowpass filter output of (3), 5=theoretical eccentricity (as extracted from precession modulations using the filtering algorithm), 6=(2) + noise, 7=amplitude envelope of (6), 8=lowpass filter output of (7)
</p>
<p>When nsim is &gt; 0, the function will output the correlation coefficients for each simulation.
</p>


<h3>References</h3>

<p>C. Zeeden, S.R. Meyers, L.J. Lourens, and F.J. Hilgen, 2015,
<em>Testing astronomically tuned age models</em>: Paleoceanography, 30, doi:10.1002/2014PA002762.
</p>
<p>C. Zeeden, S.R. Meyers, F.J. Hilgen, L.J. Lourens, and J. Laskar, submitted,
<em>Time scale evaluation and the quantification of obliquity forcing</em>: Quaternary Science Reviews.
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
### as a test series, use the three dominant precession terms from Berger et al. (1992)
ex&lt;-cycles(start=0,end=1000,dt=2)

### now conduct astrochronologic testing
res1=testPrecession(ex)


### if you plan to run testPrecession repeatedly, it is advisable to download the astronomical
### solution first
solution&lt;-getLaskar()

### now conduct astrochronologic testing
res2&lt;-testPrecession(ex,solution=solution)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='testTilt'>Astrochronologic testing via the obliquity amplitude modulation approach of Zeeden et al. (2019 submitted).</h2><span id='topic+testTilt'></span>

<h3>Description</h3>

<p>Astrochronologic testing via the obliquity amplitude modulation approach of Zeeden et al. (2019 submitted).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testTilt(dat,nsim=1000,gen=1,edge=0.025,cutoff=1/150,maxNoise=0.25,rho=NULL,detrendEnv=T,
               solution=NULL,output=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testTilt_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to analyze. First column should be location (time in ka, a positive value), second column should be data value.</p>
</td></tr>
<tr><td><code id="testTilt_+3A_nsim">nsim</code></td>
<td>
<p>Number of Monte Carlo simulations (phase-randomized surrogates or AR1 surrogates).</p>
</td></tr>
<tr><td><code id="testTilt_+3A_gen">gen</code></td>
<td>
<p>Monte Carlo simulation generator: (1) use phase-randomized surrogates, (2) use AR1 surrogates.</p>
</td></tr>
<tr><td><code id="testTilt_+3A_edge">edge</code></td>
<td>
<p>Percentage of record to exclude from beginning and end of data series, to remove edge effects. (0-1)</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_cutoff">cutoff</code></td>
<td>
<p>Cutoff frequency for lowpass filtering.</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_maxnoise">maxNoise</code></td>
<td>
<p>Maximum noise level to add in simulations. A value of 1 will apply maximum noise that is equivalent to 1 sd of data.</p>
</td></tr>
<tr><td><code id="testTilt_+3A_rho">rho</code></td>
<td>
<p>Specified lag-1 correlation coefficient (rho). This value is only used if gen=2. If rho is not specified, it will be calculated within the function.</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_detrendenv">detrendEnv</code></td>
<td>
<p>Linearly detrend envelope? (T or F)</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_solution">solution</code></td>
<td>
<p>Theoretical solution used for astrochronologic testing. Solution should be in the format: time (ka), precession angle, obliquity, eccentricity (the output from function 'getLaskar'). By default this is automatically determined within the function, using the solution of Laskar et al. (2004).</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_output">output</code></td>
<td>
<p>Return results as a new data frame? (T or F)</p>
</td></tr>  
<tr><td><code id="testTilt_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="testTilt_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This astrochronologic testing method compares observed obliquity-scale amplitude modulations to those expected from the theoretical solutions. It is applicable for testing astrochronologies spanning 0-50 Ma. 
The technique implements a series of filters to guard against artificial introduction of modulations during tuning and data processing, and evaluates the statistical significance of the results using Monte Carlo simulation.
The algorithm includes an adaptive noise addition step to improvement the significance testing approach. See Zeeden et al. (2019 submitted) for additional information. 
</p>
<p>The astronomically-tuned data series under evaluation should consist of two columns: time in kiloyears &amp; data value. 
Note that time must be positive. The default obliquity solution used for the astrochronologic testing comes from Laskar et al. (2004).
</p>
<p>When reporting a p-value for your result, it is important to consider the number of simulations used. 
A factor of 10 is appropriate, such that for 1000 simulations one would report a minimum p-value of &quot;p&lt;0.01&quot;, and for 10000 simulations one would report a minimum p-value of &quot;p&lt;0.001&quot;.
</p>
<p>Please be aware that the kernel density estimate plots, which summarize the simulations, represent 'smoothed' models. Due to the smoothing bandwidth, they can sometimes give the impression of simulation values that are larger or smaller than actually present.  However, the reported p-value does not suffer from these issues.
</p>


<h3>Value</h3>

<p>When nsim is set to zero, the function will output a data frame with five columns:
</p>
<p>1=time, 2=obliquity bandpass filter output, 3=amplitude envelope of (2), 4=lowpass filter output of (3), 5=theoretical obliquity (as extracted from modulations using the filtering algorithm), 6=(2) + noise, 7=amplitude envelope of (6), 8=lowpass filter output of (7)
</p>
<p>When nsim is &gt; 0, the function will output the correlation coefficients for each simulation.
</p>


<h3>References</h3>

<p>C. Zeeden, S.R. Meyers, F.J. Hilgen, L.J. Lourens, and J. Laskar, 2019 submitted,
<em>Time scale evaluation and the quantification of obliquity forcing</em>: Quaternary Science Reviews.
</p>
<p>C. Zeeden, S.R. Meyers, L.J. Lourens, and F.J. Hilgen, 2015,
<em>Testing astronomically tuned age models</em>: Paleoceanography, 30, doi:10.1002/2014PA002762.
</p>
<p>J. Laskar, P. Robutel, F. Joutel, M. Gastineau, A.C.M. Correia, and B. Levrard, B., 2004, 
<em>A long term numerical solution for the insolation quantities of the Earth</em>: 
Astron. Astrophys., Volume 428, 261-285.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
### as a test series, use the obliquity series from Laskar et al. (2004), spanning 
### the past 4 million years
ex&lt;-etp(tmin=0,tmax=4000,dt=2,eWt=0,oWt=1,pWt=0,solution=solution,standardize=FALSE)

### now conduct astrochronologic testing
res1=testTilt(ex)

### if you plan to run testTilt repeatedly, it is advisable to download the astronomical
### solution
solution&lt;-getLaskar()

### now conduct astrochronologic testing
res&lt;-testTilt(ex,solution=solution)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='timeOpt'>TimeOpt: Evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data</h2><span id='topic+timeOpt'></span>

<h3>Description</h3>

<p>TimeOpt: Evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data, as in Meyers (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOpt(dat,sedmin=0.5,sedmax=5,numsed=100,linLog=1,limit=T,fit=1,fitModPwr=T,
        flow=NULL,fhigh=NULL,roll=NULL,targetE=NULL,targetP=NULL,detrend=T,
        output=0,title=NULL,genplot=T,check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOpt_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log; default value  is 1)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>  
<tr><td><code id="timeOpt_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to the console? (0) no output; (1) return sedimentation rate grid, r^2_envelope, r^2_power, r^2_opt; (2) return optimal time series, bandpassed series, envelope, reconstructed eccentricity model</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_title">title</code></td>
<td>
<p>A character string (in quotes) specifying the title for the graphics window (optional)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="timeOpt_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt is an astronomical testing algorithm for untuned (spatial) stratigraphic data. 
The algorithm identifies the sedimentation rate(s) that simultaneously optimizes: 
(1) eccentricity amplitude modulations within the precession band, and (2) the 
concentration of spectral power at specified target astronomical periods.
</p>
<p>For each temporal calibration investigated (i.e., sedimentation rate), the observed precession 
band amplitude envelope is extracted using bandpass filtering and the Hilbert transform. 
The fit of the extracted precession envelope to the eccentricity periods is evaluated 
using a linear regression onto sine and cosine terms that reflect the five dominant 
eccentricity periods (~405.7, 130.7, 123.8, 98.9 and 94.9 kyr); amplitude and phase of the 
eccentricity terms are not assigned, but are determined during the linear model optimization. 
This approach is advantageous, as (1) the transfer functions associated with the climate 
and depositional systems can alter the amplitude and phase of the theoretical eccentricity 
terms (e.g, Laurin et al., 2005), and (2) the amplitude and phase of the eccentricity terms 
are unconstrained for deep-time investigations (&gt;50 Ma). The quality of the &quot;fit&quot; is 
estimated by calculation of the correlation of the fitted eccentricity model time series 
to the observed precession band envelope (r^2_envelope), indicating the fraction of 
variance shared between the model and envelope.
</p>
<p>The concentration of power at the target astronomical periods is evaluated using
a linear regression of the temporally-calibrated series onto sine and cosine terms 
that reflect the dominant eccentricity and precession periods. As above, the amplitude
and phase of each term is determined during the linear model optimization, and the
quality of the &quot;fit&quot; is estimated by calculation of the correlation of the fitted
astronomical model series to the temporally-calibrated series (r^2_spectral).
</p>
<p>The final measure of fit (r^2_opt) is determined as: 
</p>
<p>r^2_opt = r^2_envelope * r^2_spectral
</p>
<p>which is simply the product of the fraction of variance shared between &quot;model and envelope&quot; 
and &quot;model and time-calibrated data&quot;. This optimization approach identifies the sedimentation 
rate at which the precession envelope strongly expresses expected eccentricity modulation, 
while simultaneously, spectral power is concentrated at the target astronomical periods. 
r^2_opt can take on values ranging from 0 to 1 (a perfect fit to the astronomical model),
and provides a measure of overall quality of the astronomically calibrated time series.  
A similar approach is applicable to evaluate short eccentricity amplitude modulations. 
The statistical significance of the r^2_opt is determined via Monte Carlo simulation 
(see timeOptSim).
</p>


<h3>Value</h3>

<p>if output = 1, a data frame containing the following will be returned:
Sedimentation rate (cm/ka), r^2_envelope, r^2_spectral, r^2_opt
</p>
<p>if output = 2, a data frame containing the following will be returned:
Time (ka), tuned time series, bandpassed series, envelope, reconstructed model
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography, 30, doi:10.1002/2015PA002850.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOptPlot">timeOptPlot</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# generate a test signal with precession and eccentricity
ex=etp(tmin=1,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE,genplot=FALSE,verbose=FALSE)
# convert to meters with sedimentation rate of 2 cm/kyr
ex[1]&lt;-ex[1]*0.02
# evaluate precession modulations
timeOpt(ex,sedmin=0.5,sedmax=5,numsed=100,fit=1,output=0)
# evaluate short eccentricity modulations
timeOpt(ex,sedmin=0.5,sedmax=5,numsed=100,fit=2,output=0)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='timeOptMCMC'>TimeOptMCMC: Evaluation of eccentricity-related amplitude modulation and bundling 
in paleoclimate data (&quot;TimeOpt&quot;), with uncertainties via Markov-Chain Monte Carlo</h2><span id='topic+timeOptMCMC'></span>

<h3>Description</h3>

<p>TimeOptMCMC: Evaluation of eccentricity-related amplitude modulation and bundling in 
paleoclimate data (&quot;TimeOpt&quot;; Meyers, 2015), with uncertainties on all fitting parameters 
via Markov-Chain Monte Carlo (MCMC). This function follows the approach of 
Meyers and Malinverno (2018).  MCMC is implemented using the Metropolis-Hastings algorithm.  
Optimization is conducted upon the sedimentation rate (constant within the study interval), 
the fundamental frequencies g1-g5, the precession constant k, and four hyperparameters 
associated with the residuals from the spectral and envelope fit. The priors for the 
k and g's are Gaussian, while other parameters (sedrate, hyperparameters) are 
uniform (uninformative).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptMCMC(dat,iopt=1,sedmin=0.5,sedmax=5,sedstart=NULL,gAve=NULL,
        gSd=NULL,gstart=NULL,kAve=NULL,kSd=NULL,kstart=NULL,
        rhomin=0,rhomax=0.9999,rhostart=NULL,sigmamin=NULL,sigmamax=NULL,sigmastart=NULL,
        ran=T,fit=1,ftol=0.01,roll=10^3,nsamples=1000,epsilon=NULL,test=F,burnin=-1,
        detrend=T,output=1,savefile=F,genplot=1,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptMCMC_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_iopt">iopt</code></td>
<td>
<p>(1) fit power and envelope, (2) fit power only.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sedstart">sedstart</code></td>
<td>
<p>Initial sedimentation rate for MCMC search (cm/ka). Default is 0.5*(sedmin+sedmax). Alternatively, if set to negative number, a random value is selected from the prior distribution.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_gave">gAve</code></td>
<td>
<p>Vector which contains the average values for the g1 through g5 fundamental frequencies (arcsec/year). Must be in the following order: g1,g2,g3,g4,g5.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_gsd">gSd</code></td>
<td>
<p>Vector which contains the standard deviation for the g1 through g5 fundamental frequencies (arcsec/year). Must be in the following order: g1,g2,g3,g4,g5.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_gstart">gstart</code></td>
<td>
<p>Vector which contains the initial values for the g1 through g5 fundamental frequencies (arcsec/year). Must be in the following order: g1,g2,g3,g4,g5. Default is 0.5*(gmin+gmax). Alternatively, if set to negative number, a random value is selected from the prior distribution.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_kave">kAve</code></td>
<td>
<p>Average value for the precession constant (arcsec/year).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_ksd">kSd</code></td>
<td>
<p>Standard deviation for the precession constant (arcsec/year).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_kstart">kstart</code></td>
<td>
<p>Initial value for the precession constant (arcsec/year). Default is 0.5*(kmin+kmax). Alternatively, if set to negative number, a random value is selected from the prior distribution.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_rhomin">rhomin</code></td>
<td>
<p>Minimum value for residual lag-1 autocorrelation (for both spectral and envelope fit). Default is 0.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_rhomax">rhomax</code></td>
<td>
<p>Maximum value for residual lag-1 autocorrelation (for both spectral and envelope fit). Default is 0.9999</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_rhostart">rhostart</code></td>
<td>
<p>Initial value for residual lag-1 autocorrelation (for both spectral and envelope fit). Default 0.5. Alternatively, if set to negative number, a random value is selected from the prior distribution.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sigmamin">sigmamin</code></td>
<td>
<p>Minimum value for residual sigma (for both spectral and envelope fit).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sigmamax">sigmamax</code></td>
<td>
<p>Maximum value for residual sigma (for both spectral and envelope fit).</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_sigmastart">sigmastart</code></td>
<td>
<p>Initial value for residual sigma (for both spectral and envelope fit). Default 0.5*(data standard deviation). Alternatively, if set to negative number, a random value is selected from the prior distribution.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_ran">ran</code></td>
<td>
<p>Would you like to randomly select the parameter for updating (T), or simultaneously update all the parameters (F)?</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation? Option 2 is not yet functional!</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_ftol">ftol</code></td>
<td>
<p>Tolerance in cycles/ka used to define the precession bandpass. It is added to the highest precession frequency, and subtracted from the lowest precession frequency, to define the half power points for the Taner bandpass filter.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>  
<tr><td><code id="timeOptMCMC_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of candidate MCMC simluations to perform.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_epsilon">epsilon</code></td>
<td>
<p>Vector of dimension 11, which controls how large the jump is between each candidate value, e.g. sedimentation rate. For example, a value of 0.2 will yield maximum jump +/- 10 percent of sedimentation rate range. The vector must be arranged in the the following order: sedrate,k,g1,g2,g3,g4,g5,spec_rho,spec_sigma,env_rho,env_sigma. If NULL, all epsilon values will be assigned 0.2</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_test">test</code></td>
<td>
<p>Activate epsilon testing mode? This option will assign all MCMC samples a log-likelihood of unity. This provides a diagnostic check to ensure that the applied epsilon values are sampling the entire range of parameter values. (T or F)</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_burnin">burnin</code></td>
<td>
<p>Threshold for detection of MCMC stability.</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to the console? (0) no output; (1) return all MCMC candidates</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_savefile">savefile</code></td>
<td>
<p>Save MCMC samples to file MCMCsamples.csv? (T or F). If true, results are output after every 1000 iterations (last iterations will not be reported if you do not end on an even thousand!)</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (0= none; 1=display all summary plots; 2=also include progress plot during iterations; 3=be quiet, but save all plots as pngs to the working directory)</p>
</td></tr>
<tr><td><code id="timeOptMCMC_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt is an astronomical testing algorithm for untuned (spatial) stratigraphic data. 
The algorithm identifies the sedimentation rate(s) that simultaneously optimizes: 
(1) eccentricity amplitude modulations within the precession band, and (2) the 
concentration of spectral power at specified target astronomical periods.
</p>
<p>This version of TimeOpt uses MCMC via Metropolis-Hastings to estimate the parameters 
and their uncertainties. The priors for the k and g's are Gaussian, while the other 
parameters (sedrate, hyperparameters) are uniform (uninformative). 
</p>
<p>When ran=T, the following approach is used to select the parameter to modify:
</p>
<p>0.25 probability of changing sedimentation rate
</p>
<p>0.25 probability of changing k
</p>
<p>0.30 probability of changing g1,g2,g3,g4,g5 (simultaneously)
</p>
<p>0.10 probability of changing sigma_spec,rho_spec (simultaneously)
</p>
<p>0.10 probability of changing sigma_env,rho_env (simultaneously)
</p>
<p>This is motivated by sensitivity tests, and the fact that we are most interested 
in g, k and s;  moving each group of parameters (sedrate, k or g's) has specific
consequences we can isolate. 
</p>
<p>Here are some additional notes on the application of timeOptMCMC:
</p>
<p>(1) Before conducting a timeOptMCMC analysis, run timeOpt to get a sense of the optimal 
sedimentation rate region(s).
</p>
<p>(2) Make epsilon as large as you reasonably can, to maximize the chance of jumping between 
modes. Think of epsilon as analogous to a diffusion coefficient. A good strategy is to run 
a coarse resolution analysis (large epsilon) to identify the optimum region, then use as 
small an epsilon as possible to explore that optimum region. Note that larger epsilon 
yields less correlation in candidates. If you want to determine the time constant 
(thus number of independent samples) associated with a given epsilon, calculate the 
autocovariance function for accepted candidates (post-burnin).  Decimation is useful for 
generating independent samples if desired.
</p>
<p>(3) For greatest efficiency, the percentage of accepted candidates is typically expected 
to be between 23-44 percent (see Gelman et al., 1996, &quot;Efficient Metropolis jumping rules&quot;).  
However, the multimodal nature of the parameter space may require smaller acceptance rates.
</p>
<p>(4) To ensure that the MCMC algorithm is exploring the full parameter space, run an 
analysis with 'test=T'. This option will accept all MCMC candidates. The histogram for 
each parameter value should approximate the prior distribution. If this is not the case, 
epsilon should be increased.
</p>
<p>(5) It is expected that the MAP should be close to the mode when you have enough samples, 
although this is not guaranteed.
</p>
<p>(6) There are different strategies for implementing the algorithm. One can run one long 
chain, or run multiple short chains and combine.
</p>
<p>(7) If you run a very long test chain, you can decimate to conduct a rarefaction analysis 
(of the parameters).
</p>
<p>(8) For testing, it is recommended to run at least 3 very long chains. Ideally they should 
be long enough that you can't tell the difference. Plot likelihood versus each candidate, 
and also sigma vs each candidate, for each run.  This will allow identification of 
simulations that have gone into local minima.
</p>
<p>(9) The following are useful estimates to consider: mean of candidate values (post-burnin), 
MAP, mode of kernel density estimate (post-burnin), 95 percent Credible Interval from 
kernel density estimate (post-burnin).
</p>
<p>(10) Keep in mind that a parabolic plot of log-likelihood vs. parameter value (quadratic
in log-likelihood) indicates a Gaussian distribution.
</p>
<p>For additional information see Meyers &amp; Malinverno (2018), Meyers (2015), Tarantola (2005), 
and Malinverno &amp; Briggs (2004).
</p>


<h3>References</h3>

<p>A. Gelman et al., 1996, 
<em>Efficient Metropolis jumping rules</em>, Bayesian Statistics 5, p. 599-607.
</p>
<p>A. Malinverno and V.A. Briggs, 2004,
<em>Expanded uncertainty quantification in inverse problems: Hierarchical Bayes and empirical bayes</em>: Geophysics, 69, doi:10.1190/1.1778243.
</p>
<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography, 30, doi:10.1002/2015PA002850.
</p>
<p>S.R. Meyers and A. Malinverno, 2018,
<em>Proterozoic Milankovitch cycles and the history of the solar system</em>: Proceedings of the National Academy of Sciences, www.pnas.org/cgi/doi/10.1073/pnas.1717689115.
</p>
<p>A. Tarantola, 2005, 
<em>Inverse Problem Theory and Methods for Model Parameter Estimation</em>, Society for Industrial and Applied Mathematics, 339 pages.
</p>

<hr>
<h2 id='timeOptPlot'>TimeOptPlot: Generate summary figure for TimeOpt analyses</h2><span id='topic+timeOptPlot'></span>

<h3>Description</h3>

<p>TimeOptPlot: Generate summary figure for TimeOpt analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptPlot(dat=NULL,res1=NULL,res2=NULL,simres=NULL,fit=1,fitModPwr,flow=NULL,
            fhigh=NULL,roll=NULL,targetE=NULL,targetP=NULL,xlab="Depth (m)",
            ylab="Proxy Value",fitR=NULL,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptPlot_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series used for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_res1">res1</code></td>
<td>
<p>Data frame containing TimeOpt results: sedimentation rate grid, r^2_envelope, r^2_power, r^2_opt.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_res2">res2</code></td>
<td>
<p>Data frame containing the optimal-fitted time series, bandpassed series, envelope, and reconstructed eccentricity model.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_simres">simres</code></td>
<td>
<p>Data frame containing the r^2_opt value for each Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka).</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka).</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the depth/height axis.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_ylab">ylab</code></td>
<td>
<p>Label for proxy variable evaluated.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_fitr">fitR</code></td>
<td>
<p>The r2_opt value at the optimal sedimentation rate.</p>
</td></tr>
<tr><td><code id="timeOptPlot_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulation and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography, 30, doi:10.1002/2015PA002850.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptSim">timeOptSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# generate a test signal with precession and eccentricity
ex=etp(tmin=1,tmax=1000,dt=1,pWt=1,oWt=0,eWt=1,esinw=TRUE,genplot=FALSE,verbose=FALSE)
# convert to meters with sedimentation rate of 2 cm/kyr
ex[1]&lt;-ex[1]*0.02
# evaluate precession modulations
res1=timeOpt(ex,sedmin=0.5,sedmax=5,numsed=100,fit=1,output=1)
res2=timeOpt(ex,sedmin=0.5,sedmax=5,numsed=100,fit=1,output=2)
simres=timeOptSim(ex,sedrate=2,numsim=2000,fit=1,output=2)
timeOptPlot(ex,res1,res2,simres,flow=0.035,fhigh=0.065,roll=10^3,
 targetE=c(405.6795,130.719,123.839,98.86307,94.87666),
 targetP=c(23.62069,22.31868,19.06768,18.91979),xlab="Depth (m)",
 ylab="Value",fitR=0.832,verbose=T)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='timeOptSim'>Monte Carlo simulation for TimeOpt</h2><span id='topic+timeOptSim'></span>

<h3>Description</h3>

<p>Perform Monte Carlo AR1 simulations to evaluate significance of TimeOpt results, as in Meyers (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptSim(dat,numsim=2000,rho=NULL,sedrate=NULL,sedmin=0.5,sedmax=5,numsed=100,
         linLog=1,limit=T,fit=1,fitModPwr=T,flow=NULL,fhigh=NULL,roll=NULL,
         targetE=NULL,targetP=NULL,detrend=T,ncores=2,output=0,genplot=T,
         check=T,verbose=T)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptSim_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo AR1 simulations.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_rho">rho</code></td>
<td>
<p>AR1 coefficient to use in simulations. By default this will be estimated from the stratigraphic series.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_sedrate">sedrate</code></td>
<td>
<p>Sedimentation rate for investigation (cm/ka). This option is for compatibility with prior versions of timeOptSim. Please use sedmin, sedmax, numsed.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>  
<tr><td><code id="timeOptSim_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Must be &gt;=2</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to console? (0) no output; (1) p-value; (2) simulation r2 results</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F). In general this should be activated.</p>
</td></tr>
<tr><td><code id="timeOptSim_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt is an astronomical testing algorithm for untuned (spatial) stratigraphic data. 
The algorithm identifies the sedimentation rate(s) that simultaneously optimizes: 
(1) eccentricity amplitude modulations within the precession band, and (2) the 
concentration of spectral power at specified target astronomical periods.
The statistical significance of the r^2_opt is determined via Monte Carlo simulation using timeOptSim.
</p>
<p>The present version of timeOptSim improves upon the original significance testing method of Meyers (2015),
by conducting simulations across the entire sedimentation grid. This approach more rigorously
protects against inflation of the p-value due to multiple testing. Parallel processing has been implemented
to address the greater computational demand that is required.
</p>
<p>See timeOpt for more information on the basic methodology.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsm">eAsm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptPlot">timeOptPlot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# generate a test signal with precession and eccentricity
ex=etp(tmin=1,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE,genplot=FALSE,verbose=FALSE)
# convert to meters with sedimentation rate of 2 cm/kyr
ex[1]&lt;-ex[1]*0.02
# evaluate with timeOptSim. be patient, this may take a while to run.
timeOptSim(ex,sedmin=0.5,sedmax=5,numsed=100)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='timeOptSimPwrLaw'>Monte Carlo simulation for TimeOpt, using power law (1/f) noise</h2><span id='topic+timeOptSimPwrLaw'></span>

<h3>Description</h3>

<p>Perform Monte Carlo power law (1/f) simulations to evaluate significance of TimeOpt results, as in Meyers (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptSimPwrLaw(dat,numsim=2000,beta=NULL,sedrate=NULL,sedmin=0.5,sedmax=5,numsed=100,
         linLog=1,limit=T,fit=1,fitModPwr=T,flow=NULL,fhigh=NULL,roll=NULL,
         targetE=NULL,targetP=NULL,detrend=T,ncores=2,output=0,genplot=T,
         check=T,verbose=T)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptSimPwrLaw_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo power law (1/f) simulations.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_beta">beta</code></td>
<td>
<p>Power law coefficient for 1/f noise. Positive number yields a negative slope. By default this will be estimated from the stratigraphic series.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_sedrate">sedrate</code></td>
<td>
<p>Sedimentation rate for investigation (cm/ka). This option is for compatibility with prior versions of timeOptSim. Please use sedmin, sedmax, numsed.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>  
<tr><td><code id="timeOptSimPwrLaw_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Must be &gt;=2</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to console? (0) no output; (1) p-value; (2) simulation r2 results</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F). In general this should be activated.</p>
</td></tr>
<tr><td><code id="timeOptSimPwrLaw_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt is an astronomical testing algorithm for untuned (spatial) stratigraphic data. 
The algorithm identifies the sedimentation rate(s) that simultaneously optimizes: 
(1) eccentricity amplitude modulations within the precession band, and (2) the 
concentration of spectral power at specified target astronomical periods.
The statistical significance of the r^2_opt is determined via Monte Carlo simulation using timeOptSim.
</p>
<p>The present version of timeOptSim improves upon the original significance testing method of Meyers (2015),
by conducting simulations across the entire sedimentation grid. This approach more rigorously
protects against inflation of the p-value due to multiple testing. Parallel processing has been implemented
to address the greater computational demand that is required.
</p>
<p>See timeOpt for more information on the basic methodology.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsm">eAsm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, and <code><a href="#topic+timeOptPlot">timeOptPlot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# generate a test signal with precession and eccentricity
ex=etp(tmin=1,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE,genplot=FALSE,verbose=FALSE)
# convert to meters with sedimentation rate of 2 cm/kyr
ex[1]&lt;-ex[1]*0.02
# evaluate with timeOptSim. be patient, this may take a while to run.
timeOptSimPwrLaw(ex,sedmin=0.5,sedmax=5,numsed=100)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='timeOptTemplate'>TimeOpt analysis using variable sedimentation models</h2><span id='topic+timeOptTemplate'></span>

<h3>Description</h3>

<p>Evaluation of eccentricity-related amplitude modulations and bundling in paleoclimate data, as in Meyers (2015)
and Meyers (2019), adapted to allow the evaluation of a wide range of variable sedimentation models, 
including: differential accumulation across bedding couplets, linear accumulation rate change, step 
changes in sedimentation rate, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptTemplate(dat,template=NULL,sedmin=0.5,sedmax=5,difmin=NULL,difmax=NULL,fac=NULL,
         numsed=50,linLog=1,limit=T,fit=1,fitModPwr=T,iopt=3,flow=NULL,fhigh=NULL,
         roll=NULL,targetE=NULL,targetP=NULL,cormethod=1,detrend=T,detrendTemplate=F,
         flipTemplate=F,ncores=1,output=0,genplot=1,check=T,verbose=1)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptTemplate_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_template">template</code></td>
<td>
<p>Instantaneous sedimentation rate template to fit. This represents a unitless proportional sedimentation rate history. Default model is a copy of dat, which will be scaled for instantaneous accumulation optimization.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum AVERAGE sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum AVERAGE sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_difmin">difmin</code></td>
<td>
<p>Minimum instantaneous sedimentation rate to investigate (cm/ka).</p>
</td></tr>  
<tr><td><code id="timeOptTemplate_+3A_difmax">difmax</code></td>
<td>
<p>Maximum instantaneous sedimentation rate to investigate (cm/ka). By default, this is ignored, and fac is used.</p>
</td></tr> 
<tr><td><code id="timeOptTemplate_+3A_fac">fac</code></td>
<td>
<p>Maximum instantaneous accumulation factor. Maximum rate is scaled to each investigated sedrate as fac*sedrate. Default value of 5 is based on experimentation. If larger than this, risk getting into local minimum during fit.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulations or (2) short eccentricity amplitude modulations?</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_iopt">iopt</code></td>
<td>
<p>Optimize on (1) modulations, (2) spectral power, (3) modulations*spectral power</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.  Default value is 10^3.</p>
</td></tr>  
<tr><td><code id="timeOptTemplate_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_cormethod">cormethod</code></td>
<td>
<p>Method used for calculation of correlation coefficient (1=Pearson, 2=Spearman)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_detrendtemplate">detrendTemplate</code></td>
<td>
<p>Remove linear trend from sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_fliptemplate">flipTemplate</code></td>
<td>
<p>Flip direction of sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_output">output</code></td>
<td>
<p>Which results you like to return to console? (0) no output; (1) return sedimentation rate grid, r2opt; (2) return optimal time series, bandpassed series, Hilbert and fitted periods; (3) return the optimal sedimentation rate at each depth or height</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (0 = nothing, 1=summary plot, 2=progress + summary plots)</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="timeOptTemplate_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (0 = nothing, 1=minimal, 2=everything)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt employs a probabilistic linear regression model framework to investigate amplitude
modulation and frequency ratios (bundling) in stratigraphic data, while simultaneously
determining the optimal time scale. This function further develops the method to optimize
upon complex sedimentation templates. The approach is demonstrated below with a series of 
examples. 
</p>
<p>The statistical significance of the r^2_opt is determined via Monte Carlo simulation 
(see timeOptSim). See timeOpt for more information on the basic methodology.
</p>


<h3>Value</h3>

<p>if output = 1, a data frame containing the following will be returned:
Sedimentation rate (cm/ka), r-squared value (r^2_envelope, r^2_spectra, or r^2_opt)
</p>
<p>if output = 2, a data frame containing the following will be returned:
Time (ka), tuned time series, bandpassed series, envelope, reconstructed model
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in 
paleoclimate data: An inverse approach for astrochronologic testing and time scale 
optimization</em>: Paleoceanography, v.30, 1625-1640.
</p>
<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews
v.190, 190-223.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, <code><a href="#topic+timeOptSim">timeOptSim</a></code>, and <code><a href="#topic+timeOptTemplatePlot">timeOptTemplatePlot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# EXAMPLE (1): Differential accumulation across bedding couplets
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=diffAccum(ex,0.01,.05)
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
timeOptSim(ex2,sedmin=1,sedmax=4,numsed=100,numsim=2000)
# then with the timeOptTemplate approach
timeOptTemplate(ex2,sedmin=1,sedmax=4,difmin=.5,difmax=6,numsed=100,ncores=2)
timeOptTemplateSim(ex2,sedmin=1,sedmax=4,difmin=.5,difmax=6,numsed=100,numsim=1000,
 ncores=2)


# EXAMPLE (2): Linear sedimentation rate increase
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=sedRamp(ex,srstart=0.01,srend=0.05)
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
# create linear model for input. the magnitude does not matter, it will be rescaled. 
# (it just needs to be a line)
template=ex2; template[2]=ex2[1]
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=4,difmin=.5,difmax=6,numsed=100,ncores=2)
# view optimization procedure (must set ncores=1)
timeOptTemplate(ex2,template=template,sedmin=2.75,sedmax=3.25,difmin=.5,difmax=6,numsed=20,
ncores=1,genplot=2)

# EXAMPLE (3): Step increase in sedimentation rate, from 1 cm/kyr to 2 cm/kyr at 7 meters depth
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=ex
ex2[1]=ex[1]*.01
ex2[141:201,1]=ex2[141:201,1]*2-7
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
# create step model for input. the magnitude does not matter, it will be rescaled. 
template=ex2; template[1:140,2]=1; template[141:261,2]=2
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=4,numsed=100,ncores=2)
# view optimization procedure (must set ncores=1)
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=2,numsed=20,ncores=1,genplot=2)


# EXAMPLE (4): A record with a 100 kyr hiatus at 10 meters depth
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=delPts(ex,del=101:121)
# use a background sedimentation rate of 2 cm/kyr
ex2[1]=0:179*5*0.02
# first evaluate the distorted record with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
#  create a constant sedimentation rate template with possible hiatus of unknown
#  duration at 10 m
template=ex2; template[2]=10; template[101,2]=1
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=3,difmax=3,numsed=100,ncores=2)
# now perform a finer grid search near the maximum, using power only
#  notice the oscillatory nature of the power fit.
res=timeOptTemplate(ex2,template=template,sedmin=1.5,sedmax=2,difmax=3,numsed=100,
 ncores=2,iopt=2,output=2)
# compare true eccentricity to TimeOpt-derived eccentricity
pl(2)
plot(ex,type="l",main="True Eccentricity Series",xlab="True Time (kyr)",ylab="")
plot(res[,1],res[,4],type="l",main="Black=TimeOpt precession AM;  Red=TimeOpt eccentricity model",
xlab="TimeOpt derived time (kyr)",ylab="")
lines(res[,1],res[,5],col="red",lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='timeOptTemplatePlot'>TimeOptTemplatePlot: Generate summary figure for TimeOptTemplate analyses</h2><span id='topic+timeOptTemplatePlot'></span>

<h3>Description</h3>

<p>TimeOptTemplatePlot: Generate summary figure for TimeOptTemplate analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptTemplatePlot(dat=NULL,template=NULL,detrend=T,detrendTemplate=F,flipTemplate=F,
   srMin=NULL,srMax=NULL,res1=NULL,simres=NULL,fit=1,flow=NULL,fhigh=NULL,roll=NULL,
   targetE=NULL,targetP=NULL,xlab="Depth (m)",ylab="Proxy Value",fitR=NULL,output=0,
   verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptTemplatePlot_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series used for astrochronologic assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_template">template</code></td>
<td>
<p>Instantaneous sedimentation rate template to fit. This represents a unitless proportional sedimentation rate history. Default model is a copy of dat, which will be scaled for instantaneous accumulation optimization.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_detrendtemplate">detrendTemplate</code></td>
<td>
<p>Remove linear trend from sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_fliptemplate">flipTemplate</code></td>
<td>
<p>Flip direction of sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_srmin">srMin</code></td>
<td>
<p>Minimum sedimentation rate for template</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_srmax">srMax</code></td>
<td>
<p>Maximum sedimentation rate for template</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_res1">res1</code></td>
<td>
<p>Data frame containing TimeOpt results: sedimentation rate grid, r^2_envelope, r^2_power, r^2_opt.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_simres">simres</code></td>
<td>
<p>Data frame containing the r^2_opt value for each Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulation or (2) short eccentricity amplitude modulation?</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with a first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the depth/height axis.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_ylab">ylab</code></td>
<td>
<p>Label for proxy variable evaluated.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_fitr">fitR</code></td>
<td>
<p>The r2 value at the optimal sedimentation rate.</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_output">output</code></td>
<td>
<p>Which results you like to return to console? (0) no output; (1) return sedimentation rate grid, r2; (2) return optimal time series, bandpassed series, Hilbert and fitted periods</p>
</td></tr>
<tr><td><code id="timeOptTemplatePlot_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in 
paleoclimate data: An inverse approach for astrochronologic testing and time scale 
optimization</em>: Paleoceanography, v.30, 1625-1640.
</p>
<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews
v. 190, 190-223.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+asm">asm</a></code>, <code><a href="#topic+eAsmTrack">eAsmTrack</a></code>, <code><a href="#topic+testPrecession">testPrecession</a></code>, <code><a href="#topic+timeOpt">timeOpt</a></code>, <code><a href="#topic+timeOptSim">timeOptSim</a></code>, and <code><a href="#topic+timeOptTemplate">timeOptTemplate</a></code></p>

<hr>
<h2 id='timeOptTemplateSim'>Simulations for timeOptTemplate</h2><span id='topic+timeOptTemplateSim'></span>

<h3>Description</h3>

<p>Simulations for timeOptTemplate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeOptTemplateSim(dat,template=NULL,corVal=NULL,numsim=2000,rho=NULL,sedmin=0.5,sedmax=5,
         difmin=NULL,difmax=NULL,fac=NULL,numsed=50,linLog=1,limit=T,fit=1,fitModPwr=T,
         iopt=3,flow=NULL,fhigh=NULL,roll=NULL,targetE=NULL,targetP=NULL,
         cormethod=1,detrend=T,detrendTemplate=F,flipTemplate=F,ncores=1,output=0,
         genplot=T,check=T,verbose=T)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeOptTemplateSim_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for modulation assessment. First column should be depth or height (in meters), second column should be data value.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_template">template</code></td>
<td>
<p>Instantaneous sedimentation rate template to fit. This represents a unitless proportional sedimentation rate history. Default template is a copy of dat, which will be scaled for instantaneous accumulation optimization.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_corval">corVal</code></td>
<td>
<p>r2opt value for data. By default this will be calculated.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo AR1 simulations.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_rho">rho</code></td>
<td>
<p>AR1 coefficient to use in simulations. By default this will be estimated from the stratigraphic series.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_sedmin">sedmin</code></td>
<td>
<p>Minimum AVERAGE sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_sedmax">sedmax</code></td>
<td>
<p>Maximum AVERAGE sedimentation rate for investigation (cm/ka).</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_difmin">difmin</code></td>
<td>
<p>Minimum instantaneous sedimentation rate to investigate (cm/ka).</p>
</td></tr>  
<tr><td><code id="timeOptTemplateSim_+3A_difmax">difmax</code></td>
<td>
<p>Maximum instantaneous sedimentation rate to investigate (cm/ka). By default, this is ignored, and fac is used.</p>
</td></tr> 
<tr><td><code id="timeOptTemplateSim_+3A_fac">fac</code></td>
<td>
<p>Maximum instantaneous accumulation factor. Maximum rate is scaled to each investigated sedrate as fac*sedrate. Default value of 5 is based on experimentation. If larger than this, risk getting into local minimum during fit.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_numsed">numsed</code></td>
<td>
<p>Number of sedimentation rates to investigate in optimization grid.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_linlog">linLog</code></td>
<td>
<p>Use linear or logarithmic scaling for sedimentation rate grid spacing? (0=linear, 1=log)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_limit">limit</code></td>
<td>
<p>Limit evaluated sedimentation rates to region in which full target signal can be recovered? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_fit">fit</code></td>
<td>
<p>Test for (1) precession amplitude modulations or (2) short eccentricity amplitude modulations? fit= 2 is not yet functional.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_fitmodpwr">fitModPwr</code></td>
<td>
<p>Include the modulation periods in the spectral fit? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_iopt">iopt</code></td>
<td>
<p>Optimize on (1) modulations, (2) power, (3) mod*power</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_flow">flow</code></td>
<td>
<p>Low frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_fhigh">fhigh</code></td>
<td>
<p>High frequency cut-off for Taner bandpass (half power point; in cycles/ka)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_roll">roll</code></td>
<td>
<p>Taner filter roll-off rate, in dB/octave.  Default value is 10^3.</p>
</td></tr>  
<tr><td><code id="timeOptTemplateSim_+3A_targete">targetE</code></td>
<td>
<p>A vector of eccentricity periods to evaluate (in ka). These must be in order of decreasing period, with first value of 405 ka.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_targetp">targetP</code></td>
<td>
<p>A vector of precession periods to evaluate (in ka). These must be in order of decreasing period.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_cormethod">cormethod</code></td>
<td>
<p>Method used for calculation of correlation coefficient (1=Pearson, 2=Spearman)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_detrend">detrend</code></td>
<td>
<p>Remove linear trend from data series? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_detrendtemplate">detrendTemplate</code></td>
<td>
<p>Remove linear trend from sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_fliptemplate">flipTemplate</code></td>
<td>
<p>Flip direction of sedimentation rate template? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_output">output</code></td>
<td>
<p>Which results you like to return to console? (0) no output; (1) return sedimentation rate grid, p, r, r*p; (2) return optimal time series, bandpassed series, Hilbert and fitted periods</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="timeOptTemplateSim_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeOpt employs a probabilistic linear regression model framework to investigate amplitude
modulation and frequency ratios (bundling) in stratigraphic data, while simultaneously
determining the optimal time scale. This function further develops the method to optimize
upon complex sedimentation templates. The approach is demonstrated below with a series of 
examples. 
</p>
<p>The statistical significance of the r^2_opt is determined via Monte Carlo simulation 
(see timeOptSim). See timeOpt for more information on the basic methodology.
</p>


<h3>Value</h3>

<p>QUESTION: is this correct?
</p>
<p>if output = 1, a data frame containing the following will be returned:
Sedimentation rate (cm/ka), r-squared value for instantaneous amplitude vs. fitted periods, r-squared value for fit to specified periods, r-squared*r-squared.
</p>
<p>if output = 2, a data frame containing the following will be returned:
Time (ka), tuned time series, bandpassed series, instantaneous amplitude, fitted periods.
</p>


<h3>References</h3>

<p>S.R. Meyers, 2015,
<em>The evaluation of eccentricity-related amplitude modulations and bundling in paleoclimate data: An inverse approach for astrochronologic testing and time scale optimization</em>: Paleoceanography.
</p>
<p>S.R. Meyers, 2019, 
<em>Cyclostratigraphy and the problem of astrochronologic testing</em>: Earth-Science Reviews.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# EXAMPLE (1): Differential accumulation across bedding couplets
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=diffAccum(ex,0.01,.05)
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
timeOptSim(ex2,sedmin=1,sedmax=4,numsed=100,numsim=2000)
# then with the timeOptTemplate approach
timeOptTemplate(ex2,sedmin=1,sedmax=4,difmin=.5,difmax=6,numsed=100,ncores=2)
timeOptTemplateSim(ex2,sedmin=1,sedmax=4,difmin=.5,difmax=6,numsed=100,numsim=1000,
 ncores=2)


# EXAMPLE (2): Linear sedimentation rate increase
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=sedRamp(ex,srstart=0.01,srend=0.05)
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
# create linear model for input. the magnitude does not matter, it will be rescaled. 
# (it just needs to be a line)
template=ex2; template[2]=ex2[1]
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=4,numsed=100,ncores=2)
# view optimization procedure
timeOptTemplate(ex2,template=template,sedmin=2.75,sedmax=3.25,numsed=20,ncores=1,genplot=2)

# EXAMPLE (3): Step increase in sedimentation rate, from 1 cm/kyr to 2 cm/kyr at 7 meters depth
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=ex
ex2[1]=ex[1]*.01
ex2[141:201,1]=ex2[141:201,1]*2-7
ex2=linterp(ex2)
# first with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
# create step model for input. the magnitude does not matter, it will be rescaled. 
template=ex2; template[1:140,2]=1; template[141:261,2]=2
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=4,numsed=100,ncores=2)
# view optimization procedure
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=2,numsed=20,ncores=1,genplot=2)


# EXAMPLE (4): A record with a 100 kyr hiatus at 10 meters depth
ex=etp(tmin=0,tmax=1000,dt=5,pWt=1,oWt=0,eWt=1,esinw=TRUE)
ex2=delPts(ex,del=101:121)
# use a background sedimentation rate of 2 cm/kyr
ex2[1]=0:179*5*0.02
# first evaluate the distorted record with the nominal timeOpt approach
timeOpt(ex2,sedmin=1,sedmax=4,numsed=100)
# then with the timeOptTemplate approach
# create a constant sedimentation rate model with possible hiatus of unknown
#  duration at 10 m
template=ex2; template[2]=10; template[101,2]=1
timeOptTemplate(ex2,template=template,sedmin=1,sedmax=3,difmax=3,numsed=100,ncores=2)
# now perform a finer grid search near the maximum, using power only
#  notice the oscillatory nature of the power fit.
res=timeOptTemplate(ex2,template=template,sedmin=1.5,sedmax=2,difmax=3,numsed=100,ncores=2,
 iopt=2,output=2)
# compare true eccentricity to TimeOpt-derived eccentricity
pl(2)
plot(ex,type="l",main="True Eccentricity Series",xlab="True Time (kyr)",ylab="")
plot(res[,1],res[,4],type="l",main="Black=TimeOpt precession AM;  Red=TimeOpt eccentricity model",
xlab="TimeOpt derived time (kyr)",ylab="")
lines(res[,1],res[,5],col="red",lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='tones'>Calculate all possible difference and combinations tones</h2><span id='topic+tones'></span>

<h3>Description</h3>

<p>Determine all possible difference and combinations tones from a set of frequencies, and
find the closest one to a specified frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tones(a=NULL,freqs=NULL,f=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tones_+3A_a">a</code></td>
<td>
<p>The frequency you are seeking to match, in cycles/ka.</p>
</td></tr>
<tr><td><code id="tones_+3A_freqs">freqs</code></td>
<td>
<p>The vector of frequencies from which to calculate difference and combination tones, in cycles/ka.</p>
</td></tr>
<tr><td><code id="tones_+3A_f">f</code></td>
<td>
<p>Output results as frequencies (cycles/ka)? If false, will output results as periods (ka). (T or F)</p>
</td></tr>
</table>

<hr>
<h2 id='traceFreq'>Frequency-domain minimal tuning: Use interactive graphical interface to trace frequency drift</h2><span id='topic+traceFreq'></span>

<h3>Description</h3>

<p>Frequency-domain minimal tuning: Use interactive graphical interface to trace frequency drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceFreq(spec,color=2,h=6,w=4,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,ydir=1,
          palette=6,ncolors=100,path=1,pl=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceFreq_+3A_spec">spec</code></td>
<td>
<p>Time-frequency spectral results to evaluate. Must have the following format: column 
1=frequency; remaining columns (2 to n)=power, amplitude or probability; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_color">color</code></td>
<td>
<p>Line color for tracing. 1 = transparent black; 2 = transparent white; 3 = transparent yellow</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_xmin">xmin</code></td>
<td>
<p>Minimum spatial frequency to plot.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_xmax">xmax</code></td>
<td>
<p>Maximum spatial frequency to plot.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height to plot.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height to plot.</p>
</td></tr>  
<tr><td><code id="traceFreq_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_path">path</code></td>
<td>
<p>How do you want to represent the spatial frequency path?: 1=lines and points; 2=lines; 3=points</p>
</td></tr>
<tr><td><code id="traceFreq_+3A_pl">pl</code></td>
<td>
<p>An option for the color plots: 0=linear scale; 1=plot log of value, 2=normalize to maximum value</p>
</td></tr> 
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> and <code><a href="#topic+trackFreq">trackFreq</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Check to see if this is an interactive R session, for compliance with CRAN standards.
# YOU CAN SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

# Generate example series with 3 terms using function 'cycles'.
# Then convert from time to space with sedimentation rate that increases from 1 to 5 cm/ka, using 
# function 'sedramp'.
# Finally interpolate to median sampling interval using function 'linterp'.
dat=linterp(sedRamp(cycles(freqs=c(1/100,1/40,1/20),start=1,end=2500,dt=5)))

# EHA anlaysis, output amplitude results
out=eha(dat,output=3)

## Interactively track frequency drift
freq=traceFreq(out)

}
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tracePeak'>A tool to interactively trace peak trajectories on plots</h2><span id='topic+tracePeak'></span>

<h3>Description</h3>

<p>A tool to interactively trace peak trajectories on plots, for results from such functions as eTimeOpt, EHA, eAsm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracePeak(dat,color=2,h=6,w=4,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,
          ydir=-1,palette=6,ncolors=100,path=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracePeak_+3A_dat">dat</code></td>
<td>
<p>Data frame with results to evaluate. It must have the following format: column 
1=parameter to track (e.g., frequency, sedimentation rate, etc.; x-axis of plot); remaining columns 
(2 to n)=parameter to evaluate for peak identification (color on plot); titles for columns 2 to n 
must be the location (depth/height/time; y-axis of plot). Note that this format is ouput by functions 
eha, eTimeOpt, eAsm.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_color">color</code></td>
<td>
<p>Line color for tracing. 1 = transparent black; 2 = transparent white; 3 = transparent yellow</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_xmin">xmin</code></td>
<td>
<p>Minimum parameter value to plot.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_xmax">xmax</code></td>
<td>
<p>Maximum parameter value to plot.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height/time to plot.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height/time to plot.</p>
</td></tr>  
<tr><td><code id="tracePeak_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth/height/time). -1 = values increase downwards, 1 = values increase upwards.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="tracePeak_+3A_path">path</code></td>
<td>
<p>How do you want to represent the path?: 1=lines and points; 2=lines; 3=points</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> and <code><a href="#topic+eTimeOpt">eTimeOpt</a></code> </p>

<hr>
<h2 id='trackFreq'>Frequency-domain minimal tuning: Use interactive graphical interface and sorting to track frequency drift</h2><span id='topic+trackFreq'></span>

<h3>Description</h3>

<p>Frequency-domain minimal tuning: Use interactive graphical interface and sorting algorithm to track frequency drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackFreq(spec,threshold=NULL,pick=T,fmin=NULL,fmax=NULL,dmin=NULL,dmax=NULL,xmin=NULL,
          xmax=NULL,ymin=NULL,ymax=NULL,h=6,w=4,ydir=1,palette=6,ncolors=100,genplot=T,
          verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackFreq_+3A_spec">spec</code></td>
<td>
<p>Time-frequency spectral results to evaluate. Must have the following format: column 
1=frequency; remaining columns (2 to n)=power, amplitude or probability; titles for columns 2 to 
n must be the location (depth or height). Note that this format is ouput by function eha.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_threshold">threshold</code></td>
<td>
<p>Threshold level for filtering peaks. By default all peak maxima reported.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_pick">pick</code></td>
<td>
<p>Pick the peaks of interest using a graphical interface? (T or F). Only activated if genplot=T.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_fmin">fmin</code></td>
<td>
<p>Minimum frequency for analysis.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_fmax">fmax</code></td>
<td>
<p>Maximum frequency for analysis.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_dmin">dmin</code></td>
<td>
<p>Minimum depth/height for analysis. NOT ACTIVATED YET!</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_dmax">dmax</code></td>
<td>
<p>Maximum depth/height for analysis. NOT ACTIVATED YET!</p>
</td></tr>  
<tr><td><code id="trackFreq_+3A_xmin">xmin</code></td>
<td>
<p>Minimum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_xmax">xmax</code></td>
<td>
<p>Maximum frequency for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height for PLOTTING.</p>
</td></tr> 
<tr><td><code id="trackFreq_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr> 
<tr><td><code id="trackFreq_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="trackFreq_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> and <code><a href="#topic+traceFreq">traceFreq</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Check to see if this is an interactive R session, for compliance with CRAN standards.
# YOU CAN SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

# Generate example series with 3 terms using function 'cycles'.
# Then convert from time to space with sedimentation rate that increases from 1 to 5 cm/ka, using
# function 'sedramp'.
# Finally interpolate to median sampling interval using function 'linterp'.
dat=linterp(sedRamp(cycles(freqs=c(1/100,1/40,1/20),start=1,end=2500,dt=5)))

# EHA anlaysis, output probability results
out=eha(dat,output=4)

## Isolate peaks with probability &gt;= 0.8
freq=trackFreq(out,0.8)

}
 
## End(Not run)
</code></pre>

<hr>
<h2 id='trackPeak'>A tool to interactively select points to track peak trajectories on plots</h2><span id='topic+trackPeak'></span>

<h3>Description</h3>

<p>A tool to interactively select points to track peak trajectories on plots, for results from functions such as eTimeOpt, EHA, eAsm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackPeak(dat,threshold=NULL,pick=T,minVal=NULL,maxVal=NULL,dmin=NULL,dmax=NULL,
          xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,h=6,w=4,ydir=-1,
          palette=6,ncolors=100,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackPeak_+3A_dat">dat</code></td>
<td>
<p>Data frame with results to evaluate. It must have the following format: column 
1=parameter to track (e.g., frequency, sedimentation rate, etc.; x-axis of plot); remaining columns 
(2 to n)=parameter to evaluate for peak identification (color on plot); titles for columns 2 to n 
must be the location (depth/height/time; y-axis of plot). Note that this format is ouput by functions 
eha, eTimeOpt, eAsm.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_threshold">threshold</code></td>
<td>
<p>Threshold level for filtering peaks. By default all peak maxima reported.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_pick">pick</code></td>
<td>
<p>Pick the peaks of interest using a graphical interface? (T or F). Only activated if genplot=T.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_minval">minVal</code></td>
<td>
<p>Minimum parameter value for analysis (e.g., frequency, sedimentation rate, etc.).</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_maxval">maxVal</code></td>
<td>
<p>Maximum parameter value for analysis  (e.g., frequency, sedimentation rate, etc.).</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_dmin">dmin</code></td>
<td>
<p>Minimum depth/height/time for analysis. NOT ACTIVATED YET!</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_dmax">dmax</code></td>
<td>
<p>Maximum depth/height/time for analysis. NOT ACTIVATED YET!</p>
</td></tr>  
<tr><td><code id="trackPeak_+3A_xmin">xmin</code></td>
<td>
<p>Minimum parameter value for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_xmax">xmax</code></td>
<td>
<p>Maximum parameter value for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_ymin">ymin</code></td>
<td>
<p>Minimum depth/height/time for PLOTTING.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_ymax">ymax</code></td>
<td>
<p>Maximum depth/height/time for PLOTTING.</p>
</td></tr> 
<tr><td><code id="trackPeak_+3A_h">h</code></td>
<td>
<p>Height of plot in inches.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_w">w</code></td>
<td>
<p>Width of plot in inches.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_ydir">ydir</code></td>
<td>
<p>Direction for y-axis in plots (depth or height). -1 = values increase downwards (slower plotting!), 1 = values increase upwards.</p>
</td></tr> 
<tr><td><code id="trackPeak_+3A_palette">palette</code></td>
<td>
<p>What color palette would you like to use? (1) rainbow, (2) grayscale, (3) blue, (4) red, (5) blue-white-red, (6) viridis</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_ncolors">ncolors</code></td>
<td>
<p>Number of colors to use in plot.</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="trackPeak_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+eha">eha</a></code> and <code><a href="#topic+eTimeOpt">eTimeOpt</a></code> </p>

<hr>
<h2 id='trim'>Remove outliers from stratigraphic series</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>Automatically remove outliers from stratigraphic series, using 'boxplot' algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(dat,c=1.5,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for outlier removal. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="trim_+3A_c">c</code></td>
<td>
<p>'c' defines the 'coef' variable for boxplot.stats. For more information: ?boxplot.stats</p>
</td></tr>
<tr><td><code id="trim_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="trim_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+delPts">delPts</a></code>, <code><a href="#topic+idPts">idPts</a></code>, <code><a href="#topic+iso">iso</a></code> and <code><a href="#topic+trimAT">trimAT</a></code> </p>

<hr>
<h2 id='trimAT'>Remove outliers from stratigraphic series</h2><span id='topic+trimAT'></span>

<h3>Description</h3>

<p>Remove outliers from stratigraphic series, using specified threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimAT(dat,thresh=0,dir=2,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimAT_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for outlier removal. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="trimAT_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value for outlier detection.</p>
</td></tr>
<tr><td><code id="trimAT_+3A_dir">dir</code></td>
<td>
<p>Remove values (1) smaller than or (2) larger than this threshold?</p>
</td></tr>
<tr><td><code id="trimAT_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="trimAT_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+delPts">delPts</a></code>, <code><a href="#topic+idPts">idPts</a></code>, <code><a href="#topic+iso">iso</a></code> and <code><a href="#topic+trim">trim</a></code> </p>

<hr>
<h2 id='trough'>Identify minima of troughs in series, filter at desired threshold value</h2><span id='topic+trough'></span>

<h3>Description</h3>

<p>Identify minima of troughs in any 1D or 2D series, filter at desired threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trough(dat,level,plateau=F,genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trough_+3A_dat">dat</code></td>
<td>
<p>1 or 2 dimensional series. If 2 dimesions, first column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="trough_+3A_level">level</code></td>
<td>
<p>Threshold level for filtering troughs. By default all trough minima reported.</p>
</td></tr>
<tr><td><code id="trough_+3A_plateau">plateau</code></td>
<td>
<p>Output plateau points not evaluated? If T, identified troughs will not be output. (T or F)</p>
</td></tr>
<tr><td><code id="trough_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="trough_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ex=cycles(genplot=FALSE)
trough(ex,level=-0.02)
</code></pre>

<hr>
<h2 id='tune'>Tune stratigraphic series</h2><span id='topic+tune'></span>

<h3>Description</h3>

<p>Tune stratigraphic series from space to time, using specified control points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune(dat,controlPts,extrapolate=F,genplot=T,check=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series for tuning. First column should be location (e.g., depth), second column should be data value.</p>
</td></tr>
<tr><td><code id="tune_+3A_controlpts">controlPts</code></td>
<td>
<p>Tuning control points. A data frame or matrix containing two columns: depth, time</p>
</td></tr>
<tr><td><code id="tune_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Extrapolate sedimentation rates above and below 'tuned' interval? (T or F)</p>
</td></tr>
<tr><td><code id="tune_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="tune_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="tune_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate example series with 3 precession terms using function 'cycles'
ex1=cycles()

# then convert from time to space using a sedimentation rate that increases from 1 to 7 cm/ka
ex2=sedRamp(ex1,srstart=0.01,srend=0.07)

# assemble tuning control points (this is the depth-time map)
controlPts=cbind(ex2[,1],ex1[,1])

# tune record
ex3=tune(ex2,controlPts=controlPts)
</code></pre>

<hr>
<h2 id='unbioturb'>
Bioturbation removal function following the approach of Liu et al (2021)
</h2><span id='topic+unbioturb'></span>

<h3>Description</h3>

<p>'unbioturb' is a function to remove bioturbation effects from a time series 
given the bioturbation parameters. It implements the method outlined in 
Liu et al. (2021), which builds on the approaches of (Guinasso and Schink, 1975),
Goreau (1977), and Goreau (1980). 'unbioturb' is the inverse of the function 'bioturb', 
both of which model bioturbation as a diffusive process (Guinasso and Schink, 1975). 
In 'unbioturb', the proxy series is deconvolved from an impulse response function 
determined by the bioturbation characteristics, G = D/ML/v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbioturb(dat, G, ML, v, pt = 0.2, wiener = TRUE, fhigh=NULL, output = 1,
  genplot = TRUE, check = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbioturb_+3A_dat">dat</code></td>
<td>
<p>Stratigraphic series to be bioturbated. First column should be age (kyr), second column should be data value.</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_g">G</code></td>
<td>
<p>Control parameter in Guinasso and Schinck, 1975. G = D/ML/v</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_ml">ML</code></td>
<td>
<p>Mix layer depth (cm)</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_v">v</code></td>
<td>
<p>Sedimentation rate (cm/kyr)</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_pt">pt</code></td>
<td>
<p>Cosine-tapered window parameter: pt is the percent of the data series tapered (choose 0-1). When pt=1, this is equivalent to a Hann taper.</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_wiener">wiener</code></td>
<td>
<p>Apply Wiener filter for deconvolution stabilization? (T or F)</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_fhigh">fhigh</code></td>
<td>
<p>Taner filter cut-off frequency for deconvolution stabilization. By default, no Taner lowpass filter is applied.</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_output">output</code></td>
<td>
<p>Which results would you like to return to the console? (0) no output; (1) return unbioturbated series; (2) return impulse response</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_check">check</code></td>
<td>
<p>Conduct compliance checks before processing? (T or F) In general this should be activated; the option is included for Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="unbioturb_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Guinasso, N.L. and Schinck, D.R., 1975, <em>Quantitative estimates of biological mixing rates in abyssal sediments</em>, J. Geophys. Res., 80, 3032-3043.
</p>
<p>Goreau, T.J., 1977, <em>Quantitative effects of sediment mixing on stratigraphy and biogeochemistry: a signal theory approach</em>, Nature, 256, 730-732.
</p>
<p>Goreau, T.J., 1980, <em>Frequency sensitivity of the deep-sea climatic record</em>, Nature, 287, 620-622.
</p>
<p>Liu, H., Meyers, S.R., and Marcott, S.A., 2021, <em>Unmixing dee-sea paleoclimate records: A study on bioturbation effects through convolution and deconvolution</em>, Earth and Planetary Science Letters, 564, 116883.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># as a test series, use the three dominant precession terms from Berger et al. (1992)
ex1=cycles()

# mix it
res1 &lt;- bioturb(ex1, G=4, ML=10, v=1, genplot = TRUE)

# un-mix it
res2=unbioturb(res1, G=4, ML=10, v=1, genplot = TRUE)

pl()
plot(ex1,type="l",main="black=signal, blue=bioturbated, red=unbioturbated",lwd=3)
lines(res2,col="red")
lines(res1,col="blue")
</code></pre>

<hr>
<h2 id='writeCSV'>Write CSV file</h2><span id='topic+writeCSV'></span>

<h3>Description</h3>

<p>Write data frame as file with comma separated values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCSV(filename,output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCSV_+3A_filename">filename</code></td>
<td>
<p>Desired filename, in quotes: &quot;result.csv&quot;</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_output">output</code></td>
<td>
<p>Data frame to write to file.</p>
</td></tr>
</table>

<hr>
<h2 id='writeT'>Write tab-delimited file</h2><span id='topic+writeT'></span>

<h3>Description</h3>

<p>Write data frame as file with tab-delimited values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeT(filename,output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeT_+3A_filename">filename</code></td>
<td>
<p>Desired filename, in quotes: &quot;result.tab&quot;</p>
</td></tr>
<tr><td><code id="writeT_+3A_output">output</code></td>
<td>
<p>Data frame to write to file.</p>
</td></tr>
</table>

<hr>
<h2 id='wtMean'>Ar/Ar Geochronology: calculate weighted mean age, age uncertainty, and other associated statistics/plots (with interactive graphics for data culling).</h2><span id='topic+wtMean'></span>

<h3>Description</h3>

<p>The wtMean function is designed for Ar/Ar Geochronology, but is also useful as a general purpose weighted mean estimator. 
It will calculate weighted mean age, age uncertainty, and other helpful statistics/plots (with interactive graphics for data culling).
The function includes the option to generate results using the approach of IsoPlot 3.70 (Ludwig, 2008) or ArArCALC (Koppers, 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtMean(dat,sd=NULL,unc=1,lambda=5.463e-10,J=NULL,Jsd=NULL,CI=2,cull=-1,del=NULL,
        sort=1,output=F,idPts=T,size=NULL,unit=1,setAr=95,color="black",
        genplot=T,verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtMean_+3A_dat">dat</code></td>
<td>
<p>dat must contain one of the following: (1) a vector of dates/values for weighted mean calculation, (2) a matrix with two columns: date or value and uncertainty (one or two sigma), or (3) a matrix with six columns, as follows: date, date uncertainty (one or two sigma), K/Ca, %Ar40*, F, and F uncertainty (one or two sigma). NOTE: F is the ratio Ar40*/Ar39K (see Koppers, 2002). See &quot;details&quot; for more information.</p>
</td></tr>
<tr><td><code id="wtMean_+3A_sd">sd</code></td>
<td>
<p>Vector of uncertainties associated with each date or value in 'dat', as one or two sigma. This option is ignored if dat has more than one column</p>
</td></tr>
<tr><td><code id="wtMean_+3A_unc">unc</code></td>
<td>
<p>What is the uncertainty on your input dates/values? (1) one sigma, or (2) two sigma. DEFAULT is one sigma. This also applies to the F uncertainty, and the J-value uncertainty (if specified) </p>
</td></tr>
<tr><td><code id="wtMean_+3A_lambda">lambda</code></td>
<td>
<p>Relevant for Ar/Ar only- Total decay constant of K40, in units of 1/year. The default value is 5.463e-10/year (Min et al., 2000).</p>
</td></tr>
<tr><td><code id="wtMean_+3A_j">J</code></td>
<td>
<p>Relevant for Ar/Ar only- Neutron fluence parameter</p>
</td></tr>
<tr><td><code id="wtMean_+3A_jsd">Jsd</code></td>
<td>
<p>Relevant for Ar/Ar only- Uncertainty for J-value (neutron fluence parameter; as one or two sigma)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_ci">CI</code></td>
<td>
<p>Which convention would you like to use for the 95% confidence intervals? (1) ISOPLOT (Ludwig, 2008), (2) ArArCALC (Koppers, 2002) (see below for details)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_cull">cull</code></td>
<td>
<p>Would you like select dates/data with a graphical interface? (0=no, 1=select points to retain, -1=select points to remove)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_del">del</code></td>
<td>
<p>A vector of indices indicating data points to remove from weighted mean calculation. If specified, this takes precedence over cull.</p>
</td></tr>
<tr><td><code id="wtMean_+3A_sort">sort</code></td>
<td>
<p>Sort by date/values? (0=no; 1=sort into increasing order; 2=sort into decreasing order)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_output">output</code></td>
<td>
<p>Return weighted mean results as new data frame? (T or F)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_idpts">idPts</code></td>
<td>
<p>Identify datum number on each point? (T or F)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_size">size</code></td>
<td>
<p>Multiplicative factor to increase or decrease size of symbols and fonts for plot.</p>
</td></tr>
<tr><td><code id="wtMean_+3A_unit">unit</code></td>
<td>
<p>Relevant for geochronology only- The time unit for your results. (1) = Ma, (2) = Ka</p>
</td></tr>
<tr><td><code id="wtMean_+3A_setar">setAr</code></td>
<td>
<p>Relevant for Ar/Ar only- Set the %Ar40* level to be illustrated on the plot. The default is 95%.</p>
</td></tr>
<tr><td><code id="wtMean_+3A_color">color</code></td>
<td>
<p>Color to use for symbols. Default is black.</p>
</td></tr>
<tr><td><code id="wtMean_+3A_genplot">genplot</code></td>
<td>
<p>Generate summary plots? (T or F)</p>
</td></tr>
<tr><td><code id="wtMean_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs weighted mean age calculations, including estimation of age uncertainties, 
mean square weighted deviation, and probability of fit, following the approaches used in 
IsoPlot 3.70 (Ludwig, 2008) and ArArCALC (Koppers, 2002). It is also useful as a general purpose
weighted mean estimator.
</p>
<p>The function accepts input in three formats:
</p>
<p>(1) each date/value and its uncertainty can be entered as individual vectors ('dat' and 'sd').
</p>
<p>(2) a two column matrix can be input as 'dat', with each date or value (first column) and its uncertainty (second column).
</p>
<p>(3) a six column matrix can be input as 'dat', with each date, its uncertainty, the associated K/Ca value, %Ar40*, F, and F uncertainty (one or two sigma).
This option must be used if you wish to calculate and include the uncertainty associated with J. The uncertainty is calculated and propagated following equation 18 of Koppers (2002).
</p>
<p>The following plots are produced:
</p>
<p>(1) A normal Q-Q plot for the dates/values (in essence this is the same as IsoPlot's linearized probability plot).
</p>
<p>(2) A cumulative Gaussian plot for the dates/values (a.k.a. cumulative probability plot). This is derived by summing the individual normal distributions for each date/value.
</p>
<p>(3) A plot of each date/value with its 2-sigma uncertainties.
</p>
<p>In addition, K/Ca and Ar40* data are plotted if provided.
</p>
<p>A NOTE regarding confidence intervals: There are two conventions that can be used to calculate the confidence intervals, selected with the option 'CI':
</p>
<p>(1) ISOPLOT convention (Ludwig, 2008). When the probability of fit is &gt;= 0.15, the confidence interval is based on 1.96*sigma.  When the probability of fit is &lt; 0.15, the confidence interval is based on t*sigma*sqrt(MSWD). 
</p>
<p>(2) ArArCALC convention (Koppers, 2002). When MSWD &lt;=1, the confidence interval is based on 1.96*sigma. When MSWD &gt; 1, the confidence interval is based on 1.96*sigma*sqrt(MSWD).
</p>
<p>ADDITIONAL ADVICE: Use the function readMatrix to load your data in R (rather than the function read).
</p>


<h3>References</h3>

<p>A.A.P. Koppers, 2002,
<em>ArArCALC- software for 40Ar/39Ar age calculations</em>: Computers &amp; Geosciences, v. 28, p. 605-619.
</p>
<p>K.R. Ludwig, 2008,
<em>User's Manual for Isoplot 3.70: A Geochronological Toolkit for Microsoft Excel</em>: Berkeley Geochronology Center Special Publication No. 4, Berkeley, 77 p.
</p>
<p>I. McDougall and T.M. Harrison, 1991,
<em>Geochronology and Thermochronology by the 40Ar/39Ar Method</em>: Oxford University Press, New York, 269 pp.
</p>
<p>K. Min, R. Mundil, P.R. Renne, and K. Ludwig, 2000,
<em>A test for systematic errors in 40Ar/39Ar geochronology through comparison with U/Pb analysis of a 1.1-Ga rhyolite</em>: Geochimica et Cosmochimica Acta, v. 64, p. 73-98.
</p>
<p>I. Wendt and C. Carl, 1991,
<em>The statistical distribution of the mean squared weighted deviation</em>: Chemical Geology, v. 86, p. 275-285.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+stepHeat">stepHeat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Check to see if this is an interactive R session, for compliance with CRAN standards.
# YOU CAN SKIP THE FOLLOWING LINE IF YOU ARE USING AN INTERACTIVE SESSION.
if(interactive()) {

# Sample NE-08-01 Ar/Ar data from Meyers et al. (2012) supplement
age &lt;- c(93.66,94.75,94.6,94.22,86.87,94.64,94.34,94.03,93.56,93.85,88.55,93.45,93.84,
          94.39,94.11,94.48,93.82,93.81,94.18,93.78,94.41,93.49,95.07,94.19)
sd2&lt;- c(5.83,4.10,8.78,2.5,8.86,3.37,4.63,3.18,8.35,5.73,4.23,2.56,2.3,1.7,3.1,2.78,
         1.62,.92,.98,1.41,1.21,1.38,1.48,0.93)
sd &lt;- sd2/2
wtMean(age,sd)

# to calculate the weighted mean without interactive plots and data culling
wtMean(age,sd,cull=0,output=TRUE,genplot=FALSE,verbose=FALSE)
}
 
## End(Not run)
</code></pre>

<hr>
<h2 id='xplot'>Generate cross-plot with kernel density estimates on axes</h2><span id='topic+xplot'></span>

<h3>Description</h3>

<p>Generate a cross-plot with kernel density estimates on axes. If multiple data points are superposed
in cross-plot, transparency of points reflects data density. Custom axes titles optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xplot(x,y,xlab=NULL,ylab=NULL,main=NULL,fill=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xplot_+3A_x">x</code></td>
<td>
<p>Variable 1</p>
</td></tr>
<tr><td><code id="xplot_+3A_y">y</code></td>
<td>
<p>Variable 2</p>
</td></tr>
<tr><td><code id="xplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis, in quotes</p>
</td></tr>
<tr><td><code id="xplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis, in quotes</p>
</td></tr>
<tr><td><code id="xplot_+3A_main">main</code></td>
<td>
<p>Label for the plot, in quotes</p>
</td></tr>
<tr><td><code id="xplot_+3A_fill">fill</code></td>
<td>
<p>Use gray fill for density plots? (T or F)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># random numbers from a normal distribution
ex1&lt;-rnorm(1000)
# random numbers from an exponential distribution
ex2&lt;-rexp(1000)

xplot(ex1,ex2)
</code></pre>

<hr>
<h2 id='zoomIn'>Dynamically explore cross-plot, zoom-in into specified region</h2><span id='topic+zoomIn'></span>

<h3>Description</h3>

<p>Dynamically explore cross-plot, zoom-in into specfied region. Accepts one dataframe/matrix 
with two columns, or two dataframes/vectors with one column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoomIn(dat1,dat2=NULL,ptsize=1,xmin=NULL,xmax=NULL,ymin=NULL,ymax=NULL,plotype=1,
       verbose=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoomIn_+3A_dat1">dat1</code></td>
<td>
<p>Data frame with one or two columns. If one column, dat2 must also be specified.</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_dat2">dat2</code></td>
<td>
<p>Data frame with one column.</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_ptsize">ptsize</code></td>
<td>
<p>Size of plotted points.</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_xmin">xmin</code></td>
<td>
<p>Minimum x-value (column 1) to plot</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_xmax">xmax</code></td>
<td>
<p>Maximum x-value (column 1) to plot</p>
</td></tr>  
<tr><td><code id="zoomIn_+3A_ymin">ymin</code></td>
<td>
<p>Minimum y-value (column 2) to plot</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y-value (column 2) to plot</p>
</td></tr>  
<tr><td><code id="zoomIn_+3A_plotype">plotype</code></td>
<td>
<p>Type of plot to generate: 1= points and lines, 2 = points, 3 = lines</p>
</td></tr>
<tr><td><code id="zoomIn_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output? (T or F)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
