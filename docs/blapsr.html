<!DOCTYPE html><html lang="en"><head><title>Help for package blapsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blapsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustPD'><p>Test positive definiteness and adjust positive definite matrix.</p></a></li>
<li><a href='#amlps'><p>Bayesian additive partial linear modeling with Laplace-P-splines.</p></a></li>
<li><a href='#amlps.object'><p>Object resulting from the fit of an additive partial linear model.</p></a></li>
<li><a href='#coxlps'><p>Fit a Cox proportional hazards regression model with Laplace-P-splines.</p></a></li>
<li><a href='#coxlps.baseline'><p>Extract estimated baseline quantities from a fit with coxlps.</p></a></li>
<li><a href='#coxlps.object'><p>Object from a Cox proportional hazards fit with Laplace-P-splines.</p></a></li>
<li><a href='#cubicbs'><p>Construct a cubic B-spline basis.</p></a></li>
<li><a href='#curelps'><p>Promotion time cure model with Laplace P-splines.</p></a></li>
<li><a href='#curelps.extract'><p>Extract estimates of survival functions and cure probability for the</p>
promotion time cure model.</a></li>
<li><a href='#curelps.object'><p>Object from a promotion time model fit with Laplace-P-splines.</p></a></li>
<li><a href='#ecog1684'><p>Phase III Melanoma clinical trial.</p></a></li>
<li><a href='#gamlps'><p>Bayesian generalized additive modeling with Laplace-P-splines.</p></a></li>
<li><a href='#gamlps.object'><p>Object resulting from the fit of a generalized additive model.</p></a></li>
<li><a href='#kidneytran'><p>Survival data of kidney transplant patients.</p></a></li>
<li><a href='#laryngeal'><p>Survival data of male laryngeal cancer patients.</p></a></li>
<li><a href='#lt'><p>Specification of covariates entering the long-term part</p>
in a promotion time cure model.</a></li>
<li><a href='#medicaid'><p>Data from the 1986 Medicaid Consumer Survey.</p></a></li>
<li><a href='#melanoma'><p>Melanoma survival data.</p></a></li>
<li><a href='#penaltyplot'><p>Plot the approximate posterior distribution of the penalty vector.</p></a></li>
<li><a href='#plot.amlps'><p>Plot smooth functions of an additive model object.</p></a></li>
<li><a href='#plot.coxlps'><p>Plot baseline hazard and survival curves from a coxlps object.</p></a></li>
<li><a href='#plot.curelps'><p>Plot estimated survival functions and cure probability for the promotion</p>
time cure model.</a></li>
<li><a href='#plot.gamlps'><p>Plot smooth functions of a generalized additive model object.</p></a></li>
<li><a href='#print.amlps'><p>Print an additive partial linear model object.</p></a></li>
<li><a href='#print.coxlps'><p>Print a coxlps object.</p></a></li>
<li><a href='#print.curelps'><p>Print the fit of a promotion time cure model.</p></a></li>
<li><a href='#print.gamlps'><p>Print a generalized additive model object.</p></a></li>
<li><a href='#simcuredata'><p>Simulation of survival times for the promotion time cure model.</p></a></li>
<li><a href='#simgamdata'><p>Simulation of data for (Generalized) additive models.</p></a></li>
<li><a href='#simsurvdata'><p>Simulation of right censored survival times for the Cox model.</p></a></li>
<li><a href='#sm'><p>Specification of smooth terms in (g)amlps function.</p></a></li>
<li><a href='#snmatch'><p>Fit a skew-normal distribution to a target density.</p></a></li>
<li><a href='#st'><p>Specification of covariates entering the short-term part</p>
in a promotion time cure model.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Inference with Laplace Approximations and P-Splines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), survival (&ge; 2.44.1)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oswaldo Gressani &lt;oswaldo_gressani@hotmail.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Laplace approximations and penalized B-splines are combined
    for fast Bayesian inference in latent Gaussian models. The routines can be
    used to fit survival models, especially proportional hazards and promotion 
    time cure models (Gressani, O. and Lambert, P. (2018) 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2018.02.007">doi:10.1016/j.csda.2018.02.007</a>&gt;). The Laplace-P-spline methodology can also
    be implemented for inference in (generalized) additive models
    (Gressani, O. and Lambert, P. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.107088">doi:10.1016/j.csda.2020.107088</a>&gt;).
    See the associated website for more information and examples.</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://www.blapsr-project.org/&amp;gt;">https://www.blapsr-project.org/&gt;</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda (&ge; 0.19.3), graphics(&ge; 3.6.0), MASS (&ge; 7.3.51), Matrix
(&ge; 1.2.17), RSpectra (&ge; 0.16.0), sn (&ge; 1.5.4), stats, utils
(&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.26), rmarkdown (&ge; 1.14), testthat (&ge; 2.3.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-20 12:47:40 UTC; Oswaldo1989</td>
</tr>
<tr>
<td>Author:</td>
<td>Oswaldo Gressani [aut, cre] (Author),
  Philippe Lambert [aut, ths] (Co-author and thesis advisor)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-20 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustPD'>Test positive definiteness and adjust positive definite matrix.</h2><span id='topic+adjustPD'></span>

<h3>Description</h3>

<p>The routine checks if a real symmetric matrix is positive definite and
if required adjusts for positive definiteness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustPD(x, eigentol = 1e-06, correct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustPD_+3A_x">x</code></td>
<td>
<p>A real symmetric matrix.</p>
</td></tr>
<tr><td><code id="adjustPD_+3A_eigentol">eigentol</code></td>
<td>
<p>A tolerance level for the eigenvalues below which
the input matrix is not considered to be positive definite.</p>
</td></tr>
<tr><td><code id="adjustPD_+3A_correct">correct</code></td>
<td>
<p>logical; if TRUE a corrected positive definite matrix
is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In statistical models, Newton's method is often used to solve a
(multivariate) maximization problem. For this iterative technique to
converge, the search direction must be controlled to guarantee an ascent
in the objective function at each step. For maximization with Newton-like
methods, an iteration yields an ascent provided that the negative of the
Hessian matrix is positive definite. When an iteration or initial value
choice does note lie in a &ldquo;small&rdquo; neighborhood of the maximum, positive
definiteness of the negative Hessian may not be guaranteed and a correction
should be implemented to ensure that the trajectory points in the ascent
direction.
This routine checks if a symmetric input matrix is positive definite and
if required computes a positive definite adjusted matrix following the work
of Levenberg (1944), Marquardt (1963) and Goldfeld (1966). The correction
consists in perturbing the main diagonal of the original input matrix
<code>x</code> by adding to each diagonal entry the absolute value of the most
negative eigenvalue of <code>x</code> incremented by <em>10^(-4)</em>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>isPD</code> <code style="white-space: pre;">&#8288;   &#8288;</code> logical; if TRUE the input matrix <code>x</code> is
positive definite.
</p>
<p><code>PD</code>  <code style="white-space: pre;">&#8288;     &#8288;</code> The corrected positive definite matrix.
</p>


<h3>References</h3>

<p>Levenberg, K. (1944). A method for the solution of certain
non-linear problems in least squares,
<em>Quarterly of Applied Mathematics</em> <strong>2</strong>(2): 164-168.
</p>
<p>Marquardt, D. W. (1963). An algorithm for least-squares
estimation of nonlinear parameters. <em>Journal of the society for
Industrial and Applied Mathematics</em> <strong>11</strong>(2): 431-441.
</p>
<p>Goldfeld, S. M., Quandt, R. E., and Trotter, H. F. (1966).
Maximization by Quadratic Hill-Climbing
<em>Econometrica</em> <strong>34</strong>(3): 541-551.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a 3 x 3 matrix that fails to be positive definite
A &lt;- matrix(c( - 0.478, - 0.013, 0.001, - 0.013, 1.256, 0.001,
            0.001, 0.001, 0.024), ncol = 3, byrow = TRUE)
adjustPD(A)
</code></pre>

<hr>
<h2 id='amlps'>Bayesian additive partial linear modeling with Laplace-P-splines.</h2><span id='topic+amlps'></span>

<h3>Description</h3>

<p>Fits an additive partial linear model to data using an
approximate Bayesian inference technique based on penalized regression
splines and Laplace approximations. Smooth additive terms are specified as a
linear combination of of a large number of cubic B-splines. To counterbalance
the roughness of the fit, a discrete penalty on neighboring spline
coefficients is imposed in the spirit of Eilers and Marx (1996). The error
of the model is assumed to be Gaussian with zero mean and finite variance.
</p>
<p>The optimal amount of smoothing is determined by a grid-based exploration of
the posterior penalty space when the number of smooth terms is small to
moderate. When the dimension of the penalty space is large, the optimal
smoothing parameter is chosen to be the value that maximizes the
(log-)posterior of the penalty vector.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>amlps(formula, data, K = 30, penorder = 2, cred.int = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amlps_+3A_formula">formula</code></td>
<td>
<p>A formula object where the ~ operator separates the response
from the covariates of the linear part <code>z1,z2,..</code> and the smooth
terms. A smooth term is specified by using the notation <code>sm(.)</code>.
For instance, the formula <code>y ~ z1+sm(x1)+sm(x2)</code> specifies an
additive model of the form <em>E(y)=b0+b1z1+f1(x1)+f2(x2)</em>, where
<em>b0, b1</em> are the regression coefficients of the linear part and
<em>f1(.)</em> and <em>f2(.)</em> are smooth functions of the continuous
covariates <em>x1</em> and <em>x2</em> respectively.</p>
</td></tr>
<tr><td><code id="amlps_+3A_data">data</code></td>
<td>
<p>Optional. A data frame to match the variable names provided
in formula.</p>
</td></tr>
<tr><td><code id="amlps_+3A_k">K</code></td>
<td>
<p>A positive integer specifying the number of cubic B-spline
functions in the basis used to model the smooth terms. Default is
<code>K = 30</code> and allowed values are <code>15 &lt;= K &lt;= 60</code>. The same basis
dimension is used for each smooth term in the model. Also, the
computational cost to fit the model increases with <code>K</code>.</p>
</td></tr>
<tr><td><code id="amlps_+3A_penorder">penorder</code></td>
<td>
<p>The penalty order used on finite differences of the
coefficients of contiguous B-splines. Can be either 2 for a second-order
penalty (the default) or 3 for a third-order penalty.</p>
</td></tr>
<tr><td><code id="amlps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level of the pointwise credible interval to be computed
for the coefficients in the linear part of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The B-spline basis used to approximate a smooth additive component
is computed with  the function <code><a href="#topic+cubicbs">cubicbs</a></code>. The lower (upper)
bound of the B-spline basis is taken to be the minimum (maximum) value of
the covariate associated to the smooth. For identifiability
purposes, the B-spline matrices (computed over the observed covariates)
are centered. The centering consists is subtracting from each column of the
B-spline matrix, the corresponding column average of another B-spline matrix
computed on a fine grid of equidistant values in the domain of the smooth
term.
</p>
<p>A hierarchical Gamma prior is imposed on the roughness penalty vector
and Jeffreys' prior is imposed on the precision of the error. A
Newton-Raphson algorithm is used to compute the posterior
mode of the (log-)posterior penalty vector. The latter algorithm uses
analytically derived versions of the gradient and Hessian. When the number
of smooth terms in the model is smaller or equal to 4, a grid-based strategy
is used for posterior exploration of the penalty space. Above that
threshold, the optimal amount of smoothness is determined by the posterior
maximum value of the penalty vector. This strategy allows to keep the
computational burden to fit the model relatively low and to conserve good
statistical performance.
</p>


<h3>Value</h3>

<p>An object of class <code>amlps</code> containing several components from
the fit. Details can be found in <code><a href="#topic+amlps.object">amlps.object</a></code>. Details on
the output printed by <code>amlps</code> can be found in
<code><a href="#topic+print.amlps">print.amlps</a></code>. Fitted smooth terms can be visualized with the
<code><a href="#topic+plot.amlps">plot.amlps</a></code> routine.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties. <em>Statistical Science</em>, <strong>11</strong>(2): 89-121.
</p>
<p>Fan, Y. and Li, Q. (2003). A kernel-based method for estimating
additive partially linear models. <em>Statistica Sinica</em>, <strong>13</strong>(3):
739-762.
</p>
<p>Gressani, O. and Lambert, P. (2018). Fast Bayesian inference
using Laplace approximations in a flexible promotion time cure model based
on P-splines. <em>Computational Statistical &amp; Data Analysis</em> <strong>124</strong>:
151-167.
</p>
<p>Opsomer, J. D. and Ruppert, D. (1999). A root-n consistent
backfitting estimator for semiparametric additive modeling. <em>Journal of
Computational and Graphical Statistics</em>, <strong>8</strong>(4): 715-732.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubicbs">cubicbs</a></code>, <code><a href="#topic+amlps.object">amlps.object</a></code>,
<code><a href="#topic+print.amlps">print.amlps</a></code>, <code><a href="#topic+plot.amlps">plot.amlps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Classic simulated data example (with simgamdata)

set.seed(17)
sim.data &lt;- simgamdata(setting = 2, n = 200, dist = "gaussian", scale = 0.4)
data &lt;- sim.data$data  # Simulated data frame

# Fit model
fit &lt;- amlps(y ~ z1 + z2 + sm(x1) + sm(x2), data = data, K = 15)
fit

</code></pre>

<hr>
<h2 id='amlps.object'>Object resulting from the fit of an additive partial linear model.</h2><span id='topic+amlps.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+amlps">amlps</a></code> function consists in a list
with various components related to the fit of an additive partial linear
model with the Laplace-P-spline approach.
</p>


<h3>Value</h3>

<p>An <code>amlps</code> object has the following elements:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula of the additive model.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Total number of smooth terms.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of B-spline basis functions used for the fit.</p>
</td></tr>
<tr><td><code>penalty.order</code></td>
<td>
<p>Chosen penalty order.</p>
</td></tr>
<tr><td><code>latfield.dim</code></td>
<td>
<p>The dimension of the latent field. This is equal
to the sum of the number of B-spline coefficients and the number of
regression parameters related to the covariates in the linear part.</p>
</td></tr>
<tr><td><code>linear.coeff</code></td>
<td>
<p>Estimated linear regression coefficients. This is a
matrix containing the posterior point estimate, standard deviation and
lower/upper bounds of the credible interval.</p>
</td></tr>
<tr><td><code>spline.estim</code></td>
<td>
<p>The estimated B-spline coefficients. This is a list
with <code>q</code> vectors of size <code>K-1</code> representing the estimated B-spline
amplitudes for each smooth term.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Estimated effective degrees of freedom for each latent field
variable.</p>
</td></tr>
<tr><td><code>Approx.signif</code></td>
<td>
<p>A matrix returning the observed test statistic and
p-value for the approximate significance of smooth terms.</p>
</td></tr>
<tr><td><code>EDf</code></td>
<td>
<p>The estimated effective degrees of freedom of the smooth terms.</p>
</td></tr>
<tr><td><code>EDfHPD.95</code></td>
<td>
<p>95% HPD interval for the degrees of freedom of the smooth
terms.</p>
</td></tr>
<tr><td><code>ED</code></td>
<td>
<p>The estimated degrees of freedom of the additive model.</p>
</td></tr>
<tr><td><code>sd.error</code></td>
<td>
<p>The estimated standard deviation of the error.</p>
</td></tr>
<tr><td><code>vmap</code></td>
<td>
<p>The maximum a posteriori of the (log) posterior penalty vector.</p>
</td></tr>
<tr><td><code>Cov.vmap</code></td>
<td>
<p>Covariance matrix of the (log) posterior penalty vector
evaluated at vmap.</p>
</td></tr>
<tr><td><code>pen.family</code></td>
<td>
<p>The family of the posterior distribution for v. It is either
&quot;skew-normal&quot; or &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code>pendist.params</code></td>
<td>
<p>The parameterization for the posterior distribution of
v. If the posterior of v belongs to the skew-normal family, then
<code>pendist.params</code> is a matrix with as many rows as the number of smooth
terms <code>q</code>. Each row contains the location, scale and shape parameter
of the skew-normal distribution. If the posterior of v belongs to the
Gaussian family, then <code>pendist.params</code> is a vector of length <code>q</code>,
corresponding to <code>vmap</code>.</p>
</td></tr>
<tr><td><code>Covmaximum</code></td>
<td>
<p>The covariance matrix of the latent field evaluated at vmap.</p>
</td></tr>
<tr><td><code>latmaximum</code></td>
<td>
<p>The latent field vector evaluated at vmap.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted response values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The response residuals.</p>
</td></tr>
<tr><td><code>r2.adj</code></td>
<td>
<p>The adjusted r-squared of the model indicating the proportion
of the data variance explained by the model fit.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data frame.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amlps">amlps</a></code>, <code><a href="#topic+print.amlps">print.amlps</a></code>,
<code><a href="#topic+plot.amlps">plot.amlps</a></code>
</p>

<hr>
<h2 id='coxlps'>Fit a Cox proportional hazards regression model with Laplace-P-splines.</h2><span id='topic+coxlps'></span>

<h3>Description</h3>

<p>Fits a Cox proportional hazards regression model for right censored data by
combining Bayesian P-splines and Laplace approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxlps(formula, data, K = 30, penorder = 2, tmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxlps_+3A_formula">formula</code></td>
<td>
<p>A formula object where the ~ operator separates the response
from the covariates. In a Cox model, it takes the form
<em>response ~ covariates</em>, where <em>response</em> is a survival object
returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function of the <em>survival</em>
package.</p>
</td></tr>
<tr><td><code id="coxlps_+3A_data">data</code></td>
<td>
<p>Optional. A data frame to match the variable names provided in
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="coxlps_+3A_k">K</code></td>
<td>
<p>A positive integer specifying the number of cubic B-spline
functions in the basis. Default is <em>K = 30</em> and allowed values
are <code>10 &lt;= K &lt;= 60</code>.</p>
</td></tr>
<tr><td><code id="coxlps_+3A_penorder">penorder</code></td>
<td>
<p>The penalty order used on finite differences of the
coefficients of contiguous B-splines. Can be either 2 for a second-order
penalty (the default) or 3 for a third-order penalty.</p>
</td></tr>
<tr><td><code id="coxlps_+3A_tmax">tmax</code></td>
<td>
<p>A user-specified value for the upper bound of the B-spline basis.
The default is NULL, so that the B-spline basis is specified in the interval
<em>[0, tup]</em>, where <em>tup</em> is the  upper bound of the follow-up
times. It is required that <em>tmax</em> &gt; <em>tup</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-baseline hazard is modeled as a linear combination of
<code>K</code> cubic B-splines as obtained from <code><a href="#topic+cubicbs">cubicbs</a></code>. The
B-spline basis is specified in the interval <em>[0, tup]</em>, where
<em>tup</em> is the upper bound of the follow-up times,
i.e. the largest observed follow-up time. Following Jullion
and Lambert (2007), a robust Gamma prior is imposed on the roughness
penalty parameter. A grid-based approach is used to explore the posterior
penalty space and the resulting quadrature points serve to compute the
approximate (joint) marginal posterior of the latent field vector. Point
and set estimates of latent field elements are obtained from a finite
mixture of Gaussian densities. The routine centers the columns of the
covariate matrix around their mean value for numerical stability.
</p>


<h3>Value</h3>

<p>An object of class <code>coxlps</code> containing various components from
the fit. Details can be found in coxlps.object. Plot of
estimated smooth hazard and survival curves can be obtained using
<code><a href="#topic+plot.coxlps">plot.coxlps</a></code>. If required, estimated baseline quantities
on specific time values can be obtained with coxlps.baseline.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Cox, D.R. (1972). Regression models and life-tables.
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>
<strong>34</strong>(2): 187-202.
</p>
<p>Gressani, O. and Lambert, P. (2018). Fast Bayesian inference
using Laplace approximations in a flexible promotion time cure model based
on P-splines. <em>Computational Statistical &amp; Data Analysis</em> <strong>124</strong>:
151-167.
</p>
<p>Jullion, A. and Lambert, P. (2007). Robust specification of the
roughness penalty prior distribution in spatially adaptive Bayesian
P-splines models. <em>Computational Statistical &amp; Data Analysis</em>
<strong>51</strong>(5): 2542-2558.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+Surv">Surv</a></code>, <code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="#topic+simsurvdata">simsurvdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1 (Simulated survival data)

set.seed(3)

# Simulate survival data  with simsurvdata
betas &lt;- c(0.13, 0.52, 0.30)
simul &lt;- simsurvdata(a = 3.8, b = 2.2, n = 250, betas = betas , censperc = 20)
simul
simdat &lt;- simul$survdata
plot(simul) # Plot survival data

# Estimation with coxlps
fit &lt;- coxlps(Surv(time, delta) ~ x1 + x2 + x3, data = simdat, K = 15)
# Compare coxlps and coxph
fit
summary(coxph(Surv(time, delta) ~ x1 + x2 + x3, data = simdat))

# Fitted baseline survival vs target
plot(fit, h0 = FALSE, cred.int = 0.95, overlay.km = TRUE)
domt &lt;- seq(0, 4, length = 100)
lines(domt, simul$S0(domt), type = "l", col = "red")
legend("topright", col=c("black", "blue", "red"), lty = rep(1,3),
      c("Bayesian LPS", "Kaplan-Meier", "Target"), cex = 0.8, bty = "n")

### Example 2 (Kidney transplant data)

data(kidneytran)
Surv.obj &lt;- Surv(kidneytran$time, kidneytran$delta)
fit &lt;- coxlps(Surv.obj ~ age + gender + race, data = kidneytran)
coxphfit &lt;- coxph(Surv.obj ~ age + gender + race, data = kidneytran)
## Compare coxph and coxlps results
summary(coxphfit)
fit
## Plot Kaplan-Meier curve vs Laplace-P-spline fit
plot(fit, h0 = FALSE, overlay.km = TRUE, plot.cred = FALSE)

### Example 3 (Laryngeal cancer data)

data(laryngeal)
fit &lt;- coxlps(Surv(time, delta) ~ age + diagyr + as.factor(stage),
               data = laryngeal)
coxphfit &lt;- coxph(Surv(time, delta) ~ age + diagyr + as.factor(stage),
                  data = laryngeal)
## Compare coxph and coxlps results
summary(coxphfit)
fit
## Plot Kaplan-Meier curve vs Laplace-P-spline fit
plot(fit, h0 = FALSE, overlay.km = TRUE, plot.cred = FALSE)


</code></pre>

<hr>
<h2 id='coxlps.baseline'>Extract estimated baseline quantities from a fit with coxlps.</h2><span id='topic+coxlps.baseline'></span>

<h3>Description</h3>

<p>The routine takes as input an object of class 'coxlps' and computes
point estimates and credible intervals for the baseline hazard and survival
on a user-specified time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxlps.baseline(object, time = NULL, compute.cred = TRUE, cred.int = 0.95,
                verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxlps.baseline_+3A_object">object</code></td>
<td>
<p>An object of class 'coxlps'.</p>
</td></tr>
<tr><td><code id="coxlps.baseline_+3A_time">time</code></td>
<td>
<p>A vector of time values on which to compute the estimated
baseline quantities. Each component of 'time' must be between 0 and
the largest observed follow-up time. If time is 'NULL' (the default),
then only the baseline median lifetime (if available) is computed.</p>
</td></tr>
<tr><td><code id="coxlps.baseline_+3A_compute.cred">compute.cred</code></td>
<td>
<p>Should the credible intervals be computed? Default is
TRUE.</p>
</td></tr>
<tr><td><code id="coxlps.baseline_+3A_cred.int">cred.int</code></td>
<td>
<p>The level for an approximate pointwise credible interval
to be computed for the baseline hazard and survival curves. Default
is 0.95.</p>
</td></tr>
<tr><td><code id="coxlps.baseline_+3A_verbose">verbose</code></td>
<td>
<p>Should the table of estimated values be printed to console?
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fit.time</code></td>
<td>
<p>A matrix with point and set estimates of
the baseline hazard and survival curves for values provided in 'time'.
Only available if 'time' is not 'NULL'. Column <em>Time</em>
summarizes the provided values in 'time'. Columns named <em>h0</em>,
<em>S0</em>, are the point estimates of the baseline hazard and baseline
survival respectively. <em>low</em> and <em>up</em> give the lower and
upper bound respectively of the approximate pointwise credible interval.</p>
</td></tr>
<tr><td><code>median.lifetime</code></td>
<td>
<p>The estimated baseline median lifetime.</p>
</td></tr>
<tr><td><code>cred.int</code></td>
<td>
<p>The chosen level to construct credible intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate survival data
set.seed(2)
betas &lt;- c(0.15, 0.82, 0.41) # Regression coefficients
data &lt;- simsurvdata(a = 1.8, b = 2, n = 300, betas = betas, censperc = 15)
simdat &lt;- data$survdata

# Fit model
fit &lt;- coxlps(Surv(time, delta) ~ x1 + x2 + x3, data = simdat, K = 20)
coxlps.baseline(fit, time = seq(0, 2, by = 0.5), cred.int = 0.90)

</code></pre>

<hr>
<h2 id='coxlps.object'>Object from a Cox proportional hazards fit with Laplace-P-splines.</h2><span id='topic+coxlps.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+coxlps">coxlps</a></code> function consists in a list
with various components related to the fit of a Cox model using the
Laplace-P-spline methodology.
</p>


<h3>Value</h3>

<p>A <code>coxlps</code> object has the following elements:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula of the Cox model.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of B-spline basis functions used for the fit.</p>
</td></tr>
<tr><td><code>penalty.order</code></td>
<td>
<p>Chosen penalty order.</p>
</td></tr>
<tr><td><code>latfield.dim</code></td>
<td>
<p>The dimension of the latent field. This is equal
to the sum of the number of B-spline coefficients and the number of
regression parameters related to the covariates.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>num.events</code></td>
<td>
<p>The number of events that occurred.</p>
</td></tr>
<tr><td><code>event.times</code></td>
<td>
<p>The standardized event times, i.e. if <em>t</em> denotes
the original time scale, then <code>event.times = t / sd(t)</code>, where
<code>sd</code> is the standard deviation.</p>
</td></tr>
<tr><td><code>tup</code></td>
<td>
<p>The upper bound of the follow-up, i.e. <code>max(event.times)</code>.</p>
</td></tr>
<tr><td><code>sd.time</code></td>
<td>
<p>The standard deviation of the event times in original scale.</p>
</td></tr>
<tr><td><code>event.indicators</code></td>
<td>
<p>The event indicators.</p>
</td></tr>
<tr><td><code>regcoeff</code></td>
<td>
<p>Posterior estimates of the regression coefficients.
<em>coef</em> gives the point estimate, <em>sd.post</em> gives the posterior
standard deviation, <em>z</em> is the Wald test statistic, <em>lower .95</em>
and <em> upper .95</em> the posterior approximate 95% quantile-based credible
interval.</p>
</td></tr>
<tr><td><code>penalty.vector</code></td>
<td>
<p>The selected grid of penalty values.</p>
</td></tr>
<tr><td><code>vmap</code></td>
<td>
<p>The maximum a posteriori of the (log) penalty parameter.</p>
</td></tr>
<tr><td><code>spline.estim</code></td>
<td>
<p>The estimated B-spline coefficients.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Estimated effective degrees of freedom for each latent field
variable.</p>
</td></tr>
<tr><td><code>ED</code></td>
<td>
<p>The effective model dimension.</p>
</td></tr>
<tr><td><code>Covthetamix</code></td>
<td>
<p>The posterior covariance matrix of the B-spline
coefficients.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The matrix of covariate values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log-likelihood evaluated at the posterior latent field
estimate.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of parametric coefficients in the model.</p>
</td></tr>
<tr><td><code>AIC.p</code></td>
<td>
<p>The AIC computed with the formula <em>-2*loglik+2*p</em>,
where <em>p</em> is the number of parametric coefficients.</p>
</td></tr>
<tr><td><code>AIC.ED</code></td>
<td>
<p>The AIC computed with the formula <em>-2*loglik+2*ED</em>, where
<em>ED</em> is the effective model dimension.</p>
</td></tr>
<tr><td><code>BIC.p</code></td>
<td>
<p>The BIC computed with the formula <em>-2*loglik+p*log(ne)</em>,
where <em>p</em> is the number of parametric coefficients and <em>ne</em> the
number of events.</p>
</td></tr>
<tr><td><code>BIC.ED</code></td>
<td>
<p>The BIC computed with the formula <em>-2*loglik+ED*log(ne)</em>,
where <em>ED</em> is the effective model dimension and <em>ne</em> the
number of events.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlps">coxlps</a></code>, <code><a href="#topic+coxlps.baseline">coxlps.baseline</a></code>
</p>

<hr>
<h2 id='cubicbs'>Construct a cubic B-spline basis.</h2><span id='topic+cubicbs'></span>

<h3>Description</h3>

<p>Computation of a cubic B-spline basis matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubicbs(x, lower, upper, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubicbs_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the values on which to evaluate the
B-spline basis.</p>
</td></tr>
<tr><td><code id="cubicbs_+3A_lower">lower</code>, <code id="cubicbs_+3A_upper">upper</code></td>
<td>
<p>The lower and upper bounds of the B-spline basis domain.
Must be finite with lower &lt; upper.</p>
</td></tr>
<tr><td><code id="cubicbs_+3A_k">K</code></td>
<td>
<p>A positive integer specifying the number of B-spline functions in
the basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cubicbs for which
print and plot methods are available. The cubicbs
class consists of a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A numeric vector on which the basis is evaluated.</p>
</td></tr>
<tr><td><code>lower</code>, <code>upper</code></td>
<td>
<p>The lower and upper bounds of the basis domain.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The number of cubic B-spline functions in the basis.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>The knot sequence to build the basis.</p>
</td></tr>
<tr><td><code>nknots</code></td>
<td>
<p>Total number of knots.</p>
</td></tr>
<tr><td><code>dimbasis</code></td>
<td>
<p>The dimension of the B-spline basis matrix.</p>
</td></tr>
<tr><td><code>Bmatrix</code></td>
<td>
<p>The B-spline basis matrix.</p>
</td></tr>
</table>
<p>The print method summarizes the B-spline basis and the plot
method gives a graphical representation of the basis
with dashed vertical lines indicating knot placement and blue ticks the
coordinates of x.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>
<p>The core algorithm of the cubicbs function owes much to a code written
by Phlilippe Lambert.
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties. <em>Statistical Science</em>, <strong>11</strong>(2): 89-121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb &lt;- 0  # Lower bound
ub &lt;- 1  # Upper bound
xdom &lt;- runif(100, lb, ub) # Draw uniform values between lb and ub
Bsmat &lt;- cubicbs(xdom, lb, ub, 25) # 100 x 25 B-spline matrix
Bsmat
plot(Bsmat) # Plot the basis
</code></pre>

<hr>
<h2 id='curelps'>Promotion time cure model with Laplace P-splines.</h2><span id='topic+curelps'></span>

<h3>Description</h3>

<p>Fits a promotion time cure model with the Laplace-P-spline methodology. The
routine can be applied to survival data for which a plateau is observed in
the Kaplan-Meier curve. In this case, the follow-up period is considered to
be sufficiently long to intrinsically account for long-term survivors and
hence a cured fraction. The user can separately specify the model covariates
influencing the cure probability (long-term survival) and the population
hazard dynamics (short-term survival).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curelps(formula, data, K = 30, penorder = 2, tmax = NULL, constr = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curelps_+3A_formula">formula</code></td>
<td>
<p>A formula object where the ~ operator separates the response
from the covariates. In a promotion time cure model, it takes the form
<em>response ~ covariates</em>, where <em>response</em> is a survival object
returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function of the <em>survival</em> package.
The model covariates influencing the long-term survival can be specified
in the function <code>lt(.)</code> separated by '+', while the
covariates affecting the short-term survival can be specified
in <code>st(.)</code>. For instance, a promotion time cure model with
covariates specified as <code>lt(x1+x2)+st(x1)</code>, means that <code>x1</code> will
jointly influence the long- and short-term survival, while <code>x2</code> will
only influence the long-term survival.</p>
</td></tr>
<tr><td><code id="curelps_+3A_data">data</code></td>
<td>
<p>Optional. A data frame to match the variable names provided in
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="curelps_+3A_k">K</code></td>
<td>
<p>A positive integer specifying the number of cubic B-spline
functions in the basis. Default is <code>K = 30</code> and allowed values
are <code>10 &lt;= K &lt;= 60</code>.</p>
</td></tr>
<tr><td><code id="curelps_+3A_penorder">penorder</code></td>
<td>
<p>The penalty order used on finite differences of the
coefficients of contiguous B-splines. Can be either 2 for a second-order
penalty (the default) or 3 for a third-order penalty.</p>
</td></tr>
<tr><td><code id="curelps_+3A_tmax">tmax</code></td>
<td>
<p>A user-specified value for the upper bound of the B-spline
basis. The default is NULL, so that the B-spline basis is specified
in the interval <em>[0, tup]</em>, where <em>tup</em> is the upper bound of
the follow-up times. It is required that <em>tmax</em> &gt; <em>tup</em>.</p>
</td></tr>
<tr><td><code id="curelps_+3A_constr">constr</code></td>
<td>
<p>Constraint imposed on last B-spline coefficient
(default is 6).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-baseline hazard is modeled as a linear combination of
<code>K</code> cubic B-splines as obtained from <code><a href="#topic+cubicbs">cubicbs</a></code>. A
robust Gamma prior is imposed on the roughness penalty parameter.
A grid-based approach is used to explore the posterior penalty space and
the resulting quadrature points serve to compute the approximate (joint)
posterior of the latent field vector. Point and set estimates of latent
field elements are obtained from a finite mixture of Gaussian densities.
The routine centers the columns of the covariate matrix around their mean
value for numerical stability. See <code><a href="#topic+print.curelps">print.curelps</a></code> for a
detailed explanation on the output printed by the curelps
function.
</p>


<h3>Value</h3>

<p>An object of class <code>curelps</code> containing various components
from the promotion time cure model fit. Details can be found in
<code><a href="#topic+curelps.object">curelps.object</a></code>. Estimates on the baseline survival,
population survival (for a chosen covariate profile) and cure probability
can be obtained with the <code><a href="#topic+plot.curelps">plot.curelps</a></code> and
<code><a href="#topic+curelps.extract">curelps.extract</a></code> routines.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Cox, D.R. (1972). Regression models and life-tables.
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>
<strong>34</strong>(2): 187-202.
</p>
<p>Bremhorst, V. and Lambert, P. (2016). Flexible estimation in
cure survival models using Bayesian P-splines.
<em>Computational Statistical &amp; Data Analysis</em> <strong>93</strong>: 270-284.
</p>
<p>Gressani, O. and Lambert, P. (2018). Fast Bayesian inference
using Laplace approximations in a flexible promotion time cure model based
on P-splines. <em>Computational Statistical &amp; Data Analysis</em> <strong>124</strong>:
151-167.
</p>
<p>Lambert, P. and Bremhorst, V. (2019). Estimation and
identification issues in the promotion time cure model when the same
covariates influence long- and short-term survival. <em>Biometrical
Journal</em> <strong>61</strong>(2): 275-289.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curelps.object">curelps.object</a></code>, <code><a href="#topic+curelps.extract">curelps.extract</a></code>,
<code><a href="#topic+plot.curelps">plot.curelps</a></code>, <code><a href="#topic+print.curelps">print.curelps</a></code>,
<code><a href="survival.html#topic+Surv">Surv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Fit a promotion time cure model on malignant melanoma data

data(melanoma)
medthick &lt;- median(melanoma$thickness)

# Kaplan-Meier estimate to check the existence of a plateau
KapMeier &lt;- survfit(Surv(time,status) ~ 1, data = melanoma)
plot(KapMeier, mark.time = TRUE, mark = 4, xlab = "Time (in years)")

# Fit with curelps
fit &lt;- curelps(Surv(time , status) ~ lt(thickness + ulcer) +
                   st(thickness + ulcer), data = melanoma, K = 40)
fit

# Cure prediction for median thickness and absence of ulceration
curelps.extract(fit, time = c(2, 4 ,6, 8), curvetype = "probacure",
                cred.int = 0.90, covar.profile = c(medthick, 0, medthick, 0))

# Plot of baseline and population survival functions
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
# Baseline survival
plot(fit, curvetype = "baseline", plot.cred = FALSE, ylim = c(0,1))
# Population survival
plot(fit, curvetype = "population", covar.profile = c(medthick, 0, medthick, 0),
plot.cred = FALSE, ylim = c(0,1))
par(opar)

</code></pre>

<hr>
<h2 id='curelps.extract'>Extract estimates of survival functions and cure probability for the
promotion time cure model.</h2><span id='topic+curelps.extract'></span>

<h3>Description</h3>

<p>The routine takes as input an object of class <code>curelps</code> and computes
estimates of the baseline survival curve, the population survival
curve and the cure probability on a specified time vector. Approximate
pointwise credible intervals are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curelps.extract(object, time = NULL, curvetype = c("baseline", "population", "probacure"),
                covar.profile, compute.cred = TRUE, cred.int = 0.95, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curelps.extract_+3A_object">object</code></td>
<td>
<p>An object of class <code>curelps</code>.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_time">time</code></td>
<td>
<p>A vector of time values on which to compute the estimates.
Each component of <code>time</code> must be between 0 and the largest observed
follow-up time.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_curvetype">curvetype</code></td>
<td>
<p>The curve on which estimates are computed ; <code>baseline</code>
(the default) is for the baseline survival, <code>population</code> is for the
population survival function for a profile of covariates given in
<code>covar.profile</code>, and <code>probacure</code> is for the probability to be
cured (for a profile of covariates given in <code>covar.profile</code>) given
that the subject has survived until time t.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_covar.profile">covar.profile</code></td>
<td>
<p>A numeric vector of the same length as the number
of covariates in the model. This corresponds to the profile of covariates
for which to compute the population survival function  and cure probability
estimates. The order of the covariates in <code>covar.profile</code> is the same
as the order specified in <code>formula</code> of the <code>curelps</code> routine.
Each component of <code>covar.profile</code> should be in the range of the
observed values for the corresponding covariate. If <code>covar.profile</code>
is left unspecified by the user, the default will be to take the median
covariate values.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_compute.cred">compute.cred</code></td>
<td>
<p>Should credible intervals be computed? Default is TRUE.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_cred.int">cred.int</code></td>
<td>
<p>The level for an approximate pointwise credible interval.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="curelps.extract_+3A_verbose">verbose</code></td>
<td>
<p>Should estimates be printed to console?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fit.time</code></td>
<td>
<p>Estimates on the time values provided in <code>time</code>.</p>
</td></tr>
<tr><td><code>cred.int</code></td>
<td>
<p>The chosen level to construct approximate pointwise
credible intervals.</p>
</td></tr>
<tr><td><code>covar.profile</code></td>
<td>
<p>The chosen profile of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curelps">curelps</a></code>, <code><a href="#topic+curelps.object">curelps.object</a></code>,
<code><a href="#topic+plot.curelps">plot.curelps</a></code>, <code><a href="#topic+print.curelps">print.curelps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example on phase III clinical trial e1684 on melanoma data

data(ecog1684)

# Kaplan-Meier curve
plot(survfit(Surv(time, status) ~ 1, data = ecog1684), mark.time = TRUE)
fit &lt;- curelps(Surv(time, status) ~ lt(age + trt+ sex) +
             st(age + trt + sex), data = ecog1684, K = 20, penorder = 2)
fit
profile1 &lt;- c(0, 1, 1, 0, 1, 1) # Mean age, trt = IFN, sex = Female.
profile2 &lt;- c(0, 0, 1, 0, 0, 1) # Mean age, trt = control, sex = Female.

# Extract cure probabilities
curelps.extract(fit, time = c(0, 1, 2, 3), curvetype = "probacure",
                covar.profile = profile1, cred.int = 0.90)
curelps.extract(fit, time = c(0, 1, 2, 3), curvetype = "probacure",
                covar.profile = profile2, cred.int = 0.90)
</code></pre>

<hr>
<h2 id='curelps.object'>Object from a promotion time model fit with Laplace-P-splines.</h2><span id='topic+curelps.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+curelps">curelps</a></code> function consists in a list
with various components related to the fit of a promotion time cure model
using the Laplace-P-spline methodology.
</p>


<h3>Value</h3>

<p>A <code>curelps</code> object has the following elements:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula of the promotion time cure model.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of B-spline basis functions used for the fit.</p>
</td></tr>
<tr><td><code>penalty.order</code></td>
<td>
<p>Chosen penalty order.</p>
</td></tr>
<tr><td><code>latfield.dim</code></td>
<td>
<p>The dimension of the latent field. This is equal
to the sum of the number of B-spline coefficients and the number of
regression parameters related to the covariates.</p>
</td></tr>
<tr><td><code>event.times</code></td>
<td>
<p>The observed event times.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>num.events</code></td>
<td>
<p>The number of events that occurred.</p>
</td></tr>
<tr><td><code>tup</code></td>
<td>
<p>The upper bound of the follow up, i.e. <code>max(event.times)</code>.</p>
</td></tr>
<tr><td><code>event.indicators</code></td>
<td>
<p>The event indicators.</p>
</td></tr>
<tr><td><code>coeff.probacure</code></td>
<td>
<p>Posterior estimates of the regression coefficients
related to the cure probability (or long-term survival).</p>
</td></tr>
<tr><td><code>coeff.cox</code></td>
<td>
<p>Posterior estimates of the regression coefficients
related to the population hazard dynamics (or short-term survival).</p>
</td></tr>
<tr><td><code>vmap</code></td>
<td>
<p>The maximum a posteriori of the (log-)posterior penalty parameter.</p>
</td></tr>
<tr><td><code>vquad</code></td>
<td>
<p>The quadrature points of (log-) posterior penalty parameters
used to compute the Gaussian mixture posterior of the latent field vector.</p>
</td></tr>
<tr><td><code>spline.estim</code></td>
<td>
<p>The estimated B-spline coefficients.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Estimated effective degrees of freedom for each latent field
variable.</p>
</td></tr>
<tr><td><code>ED</code></td>
<td>
<p>The effective model dimension.</p>
</td></tr>
<tr><td><code>Covtheta.map</code></td>
<td>
<p>The posterior covariance matrix of the B-spline
coefficients for a penalty fixed at its maximum posterior value.</p>
</td></tr>
<tr><td><code>Covlatc.map</code></td>
<td>
<p>The posterior covariance matrix of the latent field
for a penalty fixed at its maximum posterior value.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The covariate matrix for the long-term survival part.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>The covariate matrix for the short-term survival part.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log-likelihood evaluated at the posterior latent field
estimate.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Number of parametric coefficients in the model.</p>
</td></tr>
<tr><td><code>AIC.p</code></td>
<td>
<p>The AIC computed with the formula <em>-2*loglik+2*p</em>,
where <em>p</em> is the number of parametric coefficients.</p>
</td></tr>
<tr><td><code>AIC.ED</code></td>
<td>
<p>The AIC computed with the formula <em>-2*loglik+2*ED</em>, where
<em>ED</em> is the effective model dimension.</p>
</td></tr>
<tr><td><code>BIC.p</code></td>
<td>
<p>The BIC computed with the formula <em>-2*loglik+p*log(ne)</em>,
where <em>p</em> is the number of parametric coefficients and <em>ne</em> the
number of events.</p>
</td></tr>
<tr><td><code>BIC.ED</code></td>
<td>
<p>The BIC computed with the formula <em>-2*loglik+ED*log(ne)</em>,
where <em>ED</em> is the effective model dimension and <em>ne</em> the
number of events.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curelps">curelps</a></code>
</p>

<hr>
<h2 id='ecog1684'>Phase III Melanoma clinical trial.</h2><span id='topic+ecog1684'></span>

<h3>Description</h3>

<p>Melanoma data from the phase III Eastern Cooperative
Oncology Group (ECOG) two-arm clinical trial studied in
Kirkwood et al. (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecog1684)
</code></pre>


<h3>Format</h3>

<p>A data frame with 284 rows and 5 columns.
</p>

<dl>
<dt><code>trt</code></dt><dd><p>Treatment: <code>0</code>=control,
<code>1</code>=Interferon alpha-2b (IFN).</p>
</dd>
<dt><code>time</code></dt><dd><p>Relapse-free survival (in years).</p>
</dd>
<dt><code>status</code></dt><dd><p><code>1</code>=death or relapse, <code>0</code>=censored.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age centered to the mean.</p>
</dd>
<dt><code>sex</code></dt><dd><p><code>0</code>=Male, <code>1</code>=Female.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://CRAN.R-project.org/package=smcure">https://CRAN.R-project.org/package=smcure</a>
</p>


<h3>References</h3>

<p>Kirkwood, J. M., Strawderman, M. H., Ernstoff, M. S.,
Smith, T. J., Borden, E. C. and Blum, R. H. (1996). Interferon alfa-2b
adjuvant therapy of high-risk resected cutaneous melanoma: the Eastern
Cooperative Oncology Group Trial EST 1684.
<em>Journal of clinical oncology</em> <strong>14</strong>(1): 7-17.
</p>
<p>Corbiere, F. and Joly, P. (2007). A SAS macro for parametric
and semiparametric mixture cure models. <em>Computer methods and programs
in Biomedicine</em> <strong>85</strong>(2): 173-180.
</p>

<hr>
<h2 id='gamlps'>Bayesian generalized additive modeling with Laplace-P-splines.</h2><span id='topic+gamlps'></span>

<h3>Description</h3>

<p>Fits a generalized additive model (GAM) to data using an
approximate Bayesian inference technique based on penalized regression
splines and Laplace approximations. Smooth additive terms are specified as a
linear combination of a large number of cubic B-splines. To counterbalance
the roughness of the fit, a discrete penalty on neighboring spline
coefficients is imposed in the spirit of Eilers and Marx (1996). The
effective degrees of freedom of the smooth terms are also estimated.
</p>
<p>The optimal amount of smoothing is determined by a grid-based exploration of
the posterior penalty space when the number of smooth terms is small to
moderate. When the dimension of the penalty space is large, the optimal
smoothing parameter is chosen to be the value that maximizes the
(log-)posterior of the penalty vector. Approximate Bayesian credible
intervals for latent model variables and functions of latent model variables
are available.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlps(formula, data, K = 30, family = c("gaussian", "poisson", "bernoulli", "binomial"),
       gauss.scale, nbinom, penorder = 2, cred.int = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamlps_+3A_formula">formula</code></td>
<td>
<p>A formula object where the ~ operator separates the response
from the covariates of the linear part <code>z1,z2,..</code> and the smooth
terms. A smooth term is specified by using the notation <code>sm(.)</code>.
For instance, the formula <code>y ~ z1+sm(x1)+sm(x2)</code> specifies a
generalized additive model of the form
<em>g(mu) = b0+b1z1+f1(x1)+f2(x2)</em>, where <em>b0, b1</em> are the
regression coefficients of the linear part and <em>f1(.)</em> and
<em>f2(.)</em> are smooth functions of the continuous covariates <em>x1</em>
and <em>x2</em> respectively. The function <em>g(.)</em> is the canonical
link function.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_data">data</code></td>
<td>
<p>Optional. A data frame to match the variables names provided in
formula.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_k">K</code></td>
<td>
<p>A positive integer specifying the number of cubic B-spline
functions in the basis used to model the smooth terms. Default is
<code>K = 30</code> and allowed values are <code>15 &lt;= K &lt;= 60</code>. The same basis
dimension is used for each smooth term in the model. Also, the
computational cost to fit the model increases with <code>K</code>.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_family">family</code></td>
<td>
<p>The error distribution of the model. It is a character string
that must partially match either <code>"gaussian"</code> for Normal data with
an identity link, <code>"poisson"</code> for Poisson data with a log link,
<code>"bernoulli"</code> or <code>"binomial"</code> for Bernoulli or Binomial data
with a logit link.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_gauss.scale">gauss.scale</code></td>
<td>
<p>The scale parameter to be specified when
<code>family = "gaussian"</code>. It corresponds to the variance of the response.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_nbinom">nbinom</code></td>
<td>
<p>The number of experiments in the Binomial family.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_penorder">penorder</code></td>
<td>
<p>The penalty order used on finite differences of the
coefficients of contiguous B-splines. Can be either 2 for a second-order
penalty (the default) or 3 for a third-order penalty.</p>
</td></tr>
<tr><td><code id="gamlps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level of the pointwise credible interval to be computed
for the coefficients in the linear part of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The B-spline basis used to approximate a smooth additive component
is computed with  the function <code><a href="#topic+cubicbs">cubicbs</a></code>. The lower (upper)
bound of the B-spline basis is taken to be the minimum (maximum) value of
the covariate associated to the smooth. For identifiability
purposes, the B-spline matrices (computed over the observed covariates)
are centered. The centering consists is subtracting from each column of the
B-spline matrix, the corresponding column average of another B-spline matrix
computed on a fine grid of equidistant values in the domain of the smooth
term.
</p>
<p>A hierarchical Gamma prior is imposed on the roughness penalty vector. A
Newton-Raphson algorithm is used to compute the posterior
mode of the (log-)posterior penalty vector. The latter algorithm uses
analytically derived versions of the gradient and Hessian. When the number
of smooth terms in the model is smaller or equal to 4, a grid-based strategy
is used for posterior exploration of the penalty space. Above that
threshold, the optimal amount of smoothness is determined by the posterior
maximum value of the penalty vector. This strategy allows to keep the
computational burden to fit the model relatively low and conserve good
statistical performance.
</p>


<h3>Value</h3>

<p>An object of class <code>gamlps</code> containing several components from
the fit. Details can be found in <code><a href="#topic+gamlps.object">gamlps.object</a></code>. Details on
the output printed by <code>gamlps</code> can be found in
<code><a href="#topic+print.gamlps">print.gamlps</a></code>. Fitted smooth terms can be visualized with the
<code><a href="#topic+plot.gamlps">plot.gamlps</a></code> routine.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Hastie, T. J. and Tibshirani., RJ (1990). Generalized additive
models. <em>Monographs on statistics and applied probability</em>, 43, 335.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties. <em>Statistical Science</em>, <strong>11</strong>(2): 89-121.
</p>
<p>Gressani, O. and Lambert, P. (2018). Fast Bayesian inference
using Laplace approximations in a flexible promotion time cure model based
on P-splines. <em>Computational Statistical &amp; Data Analysis</em> <strong>124</strong>:
151-167.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubicbs">cubicbs</a></code>, <code><a href="#topic+gamlps.object">gamlps.object</a></code>,
<code><a href="#topic+print.gamlps">print.gamlps</a></code>, <code><a href="#topic+plot.gamlps">plot.gamlps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(14)
sim &lt;- simgamdata(n = 300, setting = 2, dist = "binomial", scale = 0.25)
dat &lt;- sim$data
fit &lt;- gamlps(y ~ z1 + z2 + sm(x1) + sm(x2), K = 15, data = dat,
              penorder = 2, family = "binomial", nbinom = 15)
fit

# Check fit and compare with target (in red)
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
domx &lt;- seq(-1, 1 ,length = 200)
plot(fit, smoo.index = 1, cred.int = 0.95, ylim = c(-2, 2))
lines(domx, sim$f[[1]](domx), type= "l", lty = 2, lwd = 2, col = "red")
plot(fit, smoo.index = 2, cred.int = 0.95, ylim = c(-3, 3))
lines(domx, sim$f[[2]](domx), type= "l", lty = 2, lwd = 2, col = "red")
par(opar)

</code></pre>

<hr>
<h2 id='gamlps.object'>Object resulting from the fit of a generalized additive model.</h2><span id='topic+gamlps.object'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+gamlps">gamlps</a></code> function consists in a list
with various components related to the fit of a generalized additive model
with the Laplace-P-spline approach.
</p>


<h3>Value</h3>

<p>A <code>gamlps</code> object has the following elements:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula of the generalized additive model.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The chosen exponential family.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The link function used for the fit.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Total number of smooth terms.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of B-spline basis functions used for the fit.</p>
</td></tr>
<tr><td><code>penalty.order</code></td>
<td>
<p>Chosen penalty order.</p>
</td></tr>
<tr><td><code>latfield.dim</code></td>
<td>
<p>The dimension of the latent field. This is equal
to the sum of the number of B-spline coefficients and the number of
regression parameters related to the covariates in the linear part.</p>
</td></tr>
<tr><td><code>linear.coeff</code></td>
<td>
<p>Estimated linear regression coefficients. This is a
matrix containing the posterior point estimate, standard deviation, z-score
and lower/upper bounds of the credible interval.</p>
</td></tr>
<tr><td><code>spline.estim</code></td>
<td>
<p>The estimated B-spline coefficients. This is a list
with <code>q</code> vectors of size <code>K-1</code> representing the estimated B-spline
amplitudes for each smooth term.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Estimated effective degrees of freedom for each latent field
variable.</p>
</td></tr>
<tr><td><code>Approx.signif</code></td>
<td>
<p>A matrix returning the observed test statistic and
p-value for the approximate significance of smooth terms.</p>
</td></tr>
<tr><td><code>EDf</code></td>
<td>
<p>The estimated effective degrees of freedom of the smooth terms.</p>
</td></tr>
<tr><td><code>EDfHPD.95</code></td>
<td>
<p>95% HPD interval for the degrees of freedom of the smooth
terms.</p>
</td></tr>
<tr><td><code>ED</code></td>
<td>
<p>The estimated degrees of freedom of the GAM model.</p>
</td></tr>
<tr><td><code>vmap</code></td>
<td>
<p>The maximum a posteriori of the (log) posterior penalty vector.</p>
</td></tr>
<tr><td><code>Cov.vmap</code></td>
<td>
<p>Covariance matrix of the (log) posterior penalty vector
evaluated at vmap.</p>
</td></tr>
<tr><td><code>pen.family</code></td>
<td>
<p>The family of the posterior distribution for v. It is
either &quot;skew-normal&quot; or &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code>pendist.params</code></td>
<td>
<p>The parameterization for the posterior distribution of
v. If the posterior of v belongs to the skew-normal family, then
<code>pendist.params</code> is a matrix with as many rows as the number of smooth
terms <code>q</code>. Each row contains the location, scale and shape parameter
of the skew-normal distribution. If the posterior of v belongs to the
Gaussian family, then <code>pendist.params</code> is a vector of length <code>q</code>,
corresponding to <code>vmap</code>.</p>
</td></tr>
<tr><td><code>Covmaximum</code></td>
<td>
<p>The covariance matrix of the latent field evaluated at the
posterior maximum value of the penalty vector.</p>
</td></tr>
<tr><td><code>latmaximum</code></td>
<td>
<p>The latent field value evaluated at the posterior
maximum value of the penalty vector.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted response values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The response residuals.</p>
</td></tr>
<tr><td><code>r2.adj</code></td>
<td>
<p>The adjusted r-squared of the model indicating the proportion
of the data variance explained by the model fit.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data frame of the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlps">gamlps</a></code>, <code><a href="#topic+print.gamlps">print.gamlps</a></code>,
<code><a href="#topic+plot.gamlps">plot.gamlps</a></code>
</p>

<hr>
<h2 id='kidneytran'>Survival data of kidney transplant patients.</h2><span id='topic+kidneytran'></span>

<h3>Description</h3>

<p>Survival data of kidney transplant patients from Section 1.7
of Klein and Moeschberger (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kidneytran)
</code></pre>


<h3>Format</h3>

<p>A data frame with 863 rows and 6 columns.
</p>

<dl>
<dt><code>obs</code></dt><dd><p>Observation number.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time to death.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Event indicator, <code>1</code>=Dead, <code>0</code>=Alive.</p>
</dd>
<dt><code>gender</code></dt><dd><p>Gender, <code>1</code>=Male, <code>2</code>=Female.</p>
</dd>
<dt><code>race</code></dt><dd><p>Race, <code>1</code>=White, <code>2</code>=Black.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://cran.r-project.org/package=KMsurv">https://cran.r-project.org/package=KMsurv</a>
</p>


<h3>References</h3>

<p>Klein, J.P. and Moeschberger, M. L. (2003). Survival analysis:
Techniques for Censored and Truncated Data (Second edition), Springer.
ISBN 978-1-4419-2985-3
</p>

<hr>
<h2 id='laryngeal'>Survival data of male laryngeal cancer patients.</h2><span id='topic+laryngeal'></span>

<h3>Description</h3>

<p>Survival data of male patients with larynx cancer from
Section 1.8 of Klein and Moeschberger (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(laryngeal)
</code></pre>


<h3>Format</h3>

<p>A data frame with 90 rows and 5 columns.
</p>

<dl>
<dt><code>stage</code></dt><dd><p>Stage of disease.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time to death in months.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age at diagnosis of larynx cancer.</p>
</dd>
<dt><code>diagyr</code></dt><dd><p>Year of diagnosis of larynx cancer.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Event indicator, <code>1</code>=Dead, <code>0</code>=Alive.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://cran.r-project.org/package=KMsurv">https://cran.r-project.org/package=KMsurv</a>
</p>


<h3>References</h3>

<p>Klein, J.P. and Moeschberger, M. L. (2003). Survival analysis:
Techniques for Censored and Truncated Data (Second edition), Springer.
ISBN 978-1-4419-2985-3
</p>

<hr>
<h2 id='lt'>Specification of covariates entering the long-term part
in a promotion time cure model.</h2><span id='topic+lt'></span>

<h3>Description</h3>

<p>Specification of covariates entering the long-term part
in a promotion time cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lt(...)
</code></pre>

<hr>
<h2 id='medicaid'>Data from the 1986 Medicaid Consumer Survey.</h2><span id='topic+medicaid'></span>

<h3>Description</h3>

<p>Data from the 1986 Medicaid survey sponsored by the Health
Care Financing Administration (USA). It can be used to illustrate
generalized additive models with a log link for the number of doctor
visits as a response variable. The dataset is studied in Gurmu (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(medicaid)
</code></pre>


<h3>Format</h3>

<p>A data frame with 485 rows and 10 columns.
</p>

<dl>
<dt><code>numvisits</code></dt><dd><p>Count of doctor office/clinic and health
centre visits.</p>
</dd>
<dt><code>exposure</code></dt><dd><p>Length of observation period for ambulatory
care in days.</p>
</dd>
<dt><code>children</code></dt><dd><p>Number of children in the household.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age of the respondent.</p>
</dd>
<dt><code>income1000</code></dt><dd><p>Annual household income in US dollars.</p>
</dd>
<dt><code>access</code></dt><dd><p>Access to health services, <code>0</code>=Low access,
<code>100</code>=High access.</p>
</dd>
<dt><code>pc1times1000</code></dt><dd><p>First principal component of three health
status variables: functional limitations, acute conditions and
chronic conditions.</p>
</dd>
<dt><code>maritalstat</code></dt><dd><p>Marital status, <code>0</code>=Other,
<code>1</code>=Married.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Gender, <code>1</code>=Female, <code>0</code>=Male.</p>
</dd>
<dt><code>race</code></dt><dd><p>Race, <code>0</code>=Other, <code>1</code>=White.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://qed.econ.queensu.ca/jae/1997-v12.3/gurmu/">http://qed.econ.queensu.ca/jae/1997-v12.3/gurmu/</a>
</p>


<h3>References</h3>

<p>Gurmu, S.(1997). Semi-parametric estimation of hurdle regression
models with an application to medicaid utilization. <em>Journal of Applied
Econometrics</em> <strong>12</strong>(3):225-242.
</p>

<hr>
<h2 id='melanoma'>Melanoma survival data.</h2><span id='topic+melanoma'></span>

<h3>Description</h3>

<p>Melanoma survival dataset with 205 patients suffering from
skin cancer and operated for malignant melanoma at Odense University
Hospital in Denmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(melanoma)
</code></pre>


<h3>Format</h3>

<p>A data frame with 205 rows and 7 columns.
</p>

<dl>
<dt><code>time</code></dt><dd><p>Survival time in years.</p>
</dd>
<dt><code>status</code></dt><dd><p><code>1</code> Died from melanoma, <code>0</code> still alive or died from
another event.</p>
</dd>
<dt><code>sex</code></dt><dd><p><code>1</code>=Male, <code>0</code>=Female.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years.</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of operation.</p>
</dd>
<dt><code>thickness</code></dt><dd><p>Tumour thickness measured in mm.</p>
</dd>
<dt><code>ulcer</code></dt><dd><p><code>1</code>=Presence of ulceration, <code>0</code>=Absence of
ulceration.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.stats.ox.ac.uk/pub/MASS4/">http://www.stats.ox.ac.uk/pub/MASS4/</a>
</p>


<h3>References</h3>

<p>Venables W.N., and Ripley, B.D. (2002). Modern Applied
Statistics with S, Fourth edition. Springer, New York. ISBN 0-387-95457-0.
</p>
<p>Andersen, P.K., Borgan, O., Gill, R.D., and Keiding, N. (1993)
Statistical Models based on Counting Processes. Springer.
</p>

<hr>
<h2 id='penaltyplot'>Plot the approximate posterior distribution of the penalty vector.</h2><span id='topic+penaltyplot'></span>

<h3>Description</h3>

<p>The routine gives a graphical representation of the univariate
approximate posterior distribution of the (log-)penalty parameters for
objects of class <em>coxlps</em>, <em>curelps</em>, <em>amlps</em> and
<em>gamlps</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penaltyplot(object, dimension, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="penaltyplot_+3A_object">object</code></td>
<td>
<p>An object of class <code>coxlps</code>, <code>curelps</code>, <code>amlps</code>
or <code>gamlps</code>.</p>
</td></tr>
<tr><td><code id="penaltyplot_+3A_dimension">dimension</code></td>
<td>
<p>For objects of class <code>amlps</code> and <code>gamlps</code>, the
penalty vector can have a dimension larger than one, i.e. more than a
single smooth term is present in the considered additive model. In that case,
<code>dimension</code> is the penalty dimension to be plotted
corresponding either to a scalar indicating the desired dimension or to a
vector indicating more than one dimension. For instance, dimension = c(1,3)
displays two separate plots of the (approximate) posterior distribution of
the (log-)penalty parameter associated to the first and the third smooth
function respectively.</p>
</td></tr>
<tr><td><code id="penaltyplot_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the routine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When q, the number of smooth term in a (generalized) additive model is
smaller than five, the exploration of the posterior penalty space is based
on a grid strategy. In particular, the multivariate grid of dimension q is
constructed by taking the Cartesian product of univariate grids in each
dimension j = 1,...q. These univariate grids are obtained from a skew-normal
fit to the conditional posterior p(vj|vmap[-j]),D), where vj is the
(log-)penalty value associated to the jth smooth function and vmap[-j] is
the posterior maximum of the (log-)penalty vector omitting the jth
dimension. The routine displays the latter skew-normal distributions. When
q&gt;=5, inference is based on vmap and the grid is omitted to avoid
computational overflow. In that case, the posterior distribution of the
(log-)posterior penalty vector v is approximated by a multivariate Gaussian
and the routine shows the marginal distributions.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Classic simulated data example (with simgamdata)

set.seed(123)
sim.data &lt;- simgamdata(setting = 2, n = 250, dist = "gaussian", scale = 0.25)
plot(sim.data)         # Scatter plot of response
data &lt;- sim.data$data  # Simulated data frame
# Fit model
fit &lt;- amlps(y ~ z1 + z2 + sm(x1) + sm(x2), data = data, K = 15)
fit

# Penalty plot
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
penaltyplot(fit, dimension = c(1, 2))
par(opar)

</code></pre>

<hr>
<h2 id='plot.amlps'>Plot smooth functions of an additive model object.</h2><span id='topic+plot.amlps'></span>

<h3>Description</h3>

<p>Displays a plot of the fitted additive smooth components of an
<code>amlps</code> object. The routine can also be used to
print a table of point and set estimates of an additive smooth term for a
user-specified grid of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amlps'
plot(x, xp, smoo.index, cred.int = 0.95, plot.cred = TRUE,
     np = 100, fit.col = "blue", shade.col = "gray75", show.plot = TRUE,
     show.info = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.amlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>amlps</code>.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_xp">xp</code></td>
<td>
<p>A numeric vector of grid values on which to compute a point estimate
and pointwise credible interval for the smooth function specified in
<code>smoo.index</code>. The components of <code>xp</code> must be within the range
of the observed covariate values for the corresponding smooth function.
Results will be displayed in a table.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_smoo.index">smoo.index</code></td>
<td>
<p>The index of the smooth function. For instance
<code>smoo.index = 2</code> refers to the second smooth function specified in
the <code>formula</code> of the <code>amlps</code> routine.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level of the pointwise credible interval to be
computed for the smooth additive term. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_plot.cred">plot.cred</code></td>
<td>
<p>Logical. Should the credible intervals be plotted?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_np">np</code></td>
<td>
<p>The number of points used to construct the plot of the smooth
additive function. Default is 100 and allowed values are between 20 and
200.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_fit.col">fit.col</code></td>
<td>
<p>The color of the fitted curve.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_shade.col">shade.col</code></td>
<td>
<p>The shading color for the credible intervals.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_show.plot">show.plot</code></td>
<td>
<p>Logical. Should the plot be displayed? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_show.info">show.info</code></td>
<td>
<p>Logical. Should the table of point and set estimates of
the smooth function on the specified <code>xp</code> values be displayed? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.amlps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a plot of a smooth additive term fitted with the
<code><a href="#topic+amlps">amlps</a></code> function. On the y-axis, the estimated effective
dimension of the smooth term is also displayed. At the bottom of each
plot, vertical ticks indicate the location of the covariate values. The
labels on the x-axis correspond to the covariate name associated to the
smooth term.
</p>


<h3>Value</h3>

<p>If <code>xp</code> is unspecified (the default), the routine will only
return a plot of the estimated smooth curve. Otherwise, it provides a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xp</code></td>
<td>
<p>The chosen points on which to compute the smooth fit.</p>
</td></tr>
<tr><td><code>sm.xp</code></td>
<td>
<p>The estimated smooth fit at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>sm.low</code></td>
<td>
<p>The lower bound of the pointwise credible interval for the
smooth additive function at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>sm.up</code></td>
<td>
<p>The upper bound of the pointwise credible interval for the
smooth additive function at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>cred.int</code></td>
<td>
<p>The chosen level to compute credible intervals.</p>
</td></tr>
<tr><td><code>smoo.index</code></td>
<td>
<p>The index of the smooth function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amlps">amlps</a></code>, <code><a href="#topic+amlps.object">amlps.object</a></code>,
<code><a href="#topic+print.amlps">print.amlps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Classic simulated data example

set.seed(3)

sim.data &lt;- simgamdata(setting = 2, n = 200, dist = "gaussian", scale = 0.3)
plot(sim.data)         # Scatter plot of response
data &lt;- sim.data$data  # Simulated data frame

# Fit model
fit &lt;- amlps(y ~ z1 + z2 + sm(x1) + sm(x2), data = data, K = 20)
fit

# Plot fit of second function and results for a specific grid x
plot(fit, xp = c(-0.8, -0.4, 0, 0.4, 0.8), smoo.index = 2, ylim=c(-3, 3))

</code></pre>

<hr>
<h2 id='plot.coxlps'>Plot baseline hazard and survival curves from a coxlps object.</h2><span id='topic+plot.coxlps'></span>

<h3>Description</h3>

<p>Produces a plot of the baseline hazard and/or survival based
on a coxlps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxlps'
plot(x, S0 = TRUE, h0 = TRUE, cred.int = 0.95, overlay.km = FALSE,
     plot.cred = FALSE, np = 50, show.legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.coxlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>coxlps</code>.</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_s0">S0</code></td>
<td>
<p>Logical. Should the estimated baseline survival be plotted?</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_h0">h0</code></td>
<td>
<p>Logical. Should the estimated baseline hazard be plotted?</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level for an approximate pointwise credible interval
to be computed for the baseline curves. Default is 0.95.</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_overlay.km">overlay.km</code></td>
<td>
<p>A logical value indicating whether the Kaplan-Meier
estimate should be plotted together with the smooth baseline survival
curve. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_plot.cred">plot.cred</code></td>
<td>
<p>Logical. Should the credible intervals be plotted ?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_np">np</code></td>
<td>
<p>The number of points used to plot the smooth baseline
functions. Default is 50 and allowed values are
between 20 and 200.</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should a legend be displayed?</p>
</td></tr>
<tr><td><code id="plot.coxlps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots for the baseline hazard and survival curves are computed on
a grid (of length <code>np</code>) between 0 and the 99th percentile of follow-up
times. When <code>plot.cred</code> is <code>FALSE</code>, the fit omits to compute the
approximate pointwise credible intervals for plotting and hence is less
computationally intensive. Vertical ticks on the x-axis correspond to the
observed follow-up times.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlps">coxlps</a></code> <code><a href="#topic+coxlps.object">coxlps.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simulate survival data
set.seed(6)
betas &lt;- c(0.35, -0.20, 0.05, 0.80) # Regression coefficients
data &lt;- simsurvdata(a = 1.8, b = 2, n = 200, betas = betas, censperc = 25)
simdat &lt;- data$survdata

# Fit model
fit &lt;- coxlps(Surv(time, delta) ~ x1 + x2 + x3 + x4, data = simdat)
plot(fit, h0 = FALSE, S0 = TRUE, overlay.km = FALSE, show.legend = FALSE)
domt &lt;- seq(0, 5.5, length = 500)
lines(domt, data$S0(domt), type = "l", col = "red")
legend("topright", c("Bayesian LPS", "Target"), col = c("black", "red"),
       lty = c(1, 1), bty = "n", cex = 0.8)

</code></pre>

<hr>
<h2 id='plot.curelps'>Plot estimated survival functions and cure probability for the promotion
time cure model.</h2><span id='topic+plot.curelps'></span>

<h3>Description</h3>

<p>The routine takes as input an object of class <code>curelps</code> and plots
the estimated baseline survival curve, the population survival
curve for a specific covariate profile and a a smooth curve for the cure
probability. Approximate pointwise credible intervals are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curelps'
plot(x, cred.int = 0.95, curvetype = c("baseline", "population",
     "probacure"), covar.profile, fit.col = "black", shade.col = "gray75",
      plot.cred = FALSE, np = 50, show.legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.curelps_+3A_x">x</code></td>
<td>
<p>An object of class <code>curelps</code>.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level for an approximate pointwise credible interval
to be computed for the smooth curves. Default is 0.95.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_curvetype">curvetype</code></td>
<td>
<p>The curve to be plotted; <code>baseline</code> (the default) will
plot the estimated baseline survival, <code>population</code> the population
survival function for a profile of covariates given in
<code>covar.profile</code>, and <code>probacure</code> the probability to be cured (for
a profile of covariates given in <code>covar.profile</code>) given
that the subject has survived until time t.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_covar.profile">covar.profile</code></td>
<td>
<p>A numeric vector of the same length as the number
of covariates in the model. This corresponds to the profile of covariates
for which to compute the population survival function  and cure probability
estimates. The order of the covariates in <code>covar.profile</code> is the same
as the order specified in <code>formula</code> of the <code>curelps</code> routine.
Each component of <code>covar.profile</code> should be in the range of the
observed values for the corresponding covariate. If <code>covar.profile</code>
is left unspecified by the user, the default will be to take the median
covariate values.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_fit.col">fit.col</code></td>
<td>
<p>The color used for the estimated survival curve.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_shade.col">shade.col</code></td>
<td>
<p>The color used for the shading of the credible intervals.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_plot.cred">plot.cred</code></td>
<td>
<p>Logical. Should the credible intervals be plotted?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_np">np</code></td>
<td>
<p>The number of points used to plot the smooth curves. Default is 50
and allowed values are between 20 and 200.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_show.legend">show.legend</code></td>
<td>
<p>Show the legend? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.curelps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>plot.cred</code> is <code>FALSE</code>, the routine omits to compute
the approximate pointwise credible intervals for plotting and hence is
less computationally intensive.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curelps">curelps</a></code>, <code><a href="#topic+curelps.object">curelps.object</a></code>,
<code><a href="#topic+curelps.extract">curelps.extract</a></code>, <code><a href="#topic+print.curelps">print.curelps</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example on phase III clinical trial e1684 on melanoma data

data(ecog1684)

# Kaplan-Meier curve
plot(survfit(Surv(time, status) ~ 1, data = ecog1684), mark.time = TRUE)
fit &lt;- curelps(Surv(time, status) ~ lt(age + trt + sex) +
             st(age + trt + sex), data = ecog1684, K = 20, penorder = 2)
fit
profile1 &lt;- c(0, 1, 1, 0, 1, 1) # Mean age, trt = IFN, sex = Female.
profile2 &lt;- c(0, 0, 1, 0, 0, 1) # Mean age, trt = control, sex = Female.
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
plot(fit, curvetype = "probacure", plot.cred = TRUE, ylim = c(0,1),
     covar.profile = profile1, cred.int = 0.90,
     main = "Mean age, trt = IFN, sex = Female", cex.main = 0.8,
     show.legend = FALSE)
plot(fit, curvetype = "probacure", plot.cred = TRUE, ylim = c(0,1),
     covar.profile = profile2, cred.int = 0.90,
     main = "Mean age, trt = control, sex = Female", cex.main = 0.8,
     show.legend = FALSE)
par(opar)
</code></pre>

<hr>
<h2 id='plot.gamlps'>Plot smooth functions of a generalized additive model object.</h2><span id='topic+plot.gamlps'></span>

<h3>Description</h3>

<p>Displays a plot of the fitted additive smooth components of an
<code>gamlps</code> object. The routine can also be used to
print a table of point and set estimates of an additive smooth term for a
user-specified grid of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlps'
plot(x, xp, smoo.index, cred.int = 0.95, plot.cred = TRUE,
     np = 100, fit.col = "blue", shade.col = "gray75", show.plot = TRUE,
     show.info = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gamlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>gamlps</code>.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_xp">xp</code></td>
<td>
<p>A numeric vector of grid values on which to compute a point estimate
and pointwise credible interval for the smooth function specified in
<code>smoo.index</code>. The components of <code>xp</code> must be within the range
of the observed covariate values for the corresponding smooth function.
Results will be displayed in a table.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_smoo.index">smoo.index</code></td>
<td>
<p>The index of the smooth function. For instance
<code>smoo.index = 2</code> refers to the second smooth function specified in
the <code>formula</code> of the <code>amlps</code> routine.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_cred.int">cred.int</code></td>
<td>
<p>The level of the pointwise credible interval to be
computed for the smooth additive term. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_plot.cred">plot.cred</code></td>
<td>
<p>Logical. Should the credible intervals be plotted?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_np">np</code></td>
<td>
<p>The number of points used to construct the plot of the smooth
additive function. Default is 100 and allowed values are between 20 and
200.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_fit.col">fit.col</code></td>
<td>
<p>The color of the fitted curve.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_shade.col">shade.col</code></td>
<td>
<p>The shading color for the credible intervals.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_show.plot">show.plot</code></td>
<td>
<p>Logical. Should the plot be displayed? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_show.info">show.info</code></td>
<td>
<p>Logical. Should the table of point and set estimates of
the smooth function on the specified <code>xp</code> values be displayed? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.gamlps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a plot of a smooth additive term fitted with the
<code><a href="#topic+gamlps">gamlps</a></code> function. On the y-axis, the estimated effective
dimension of the smooth term is also displayed. At the bottom of each
plot, vertical ticks indicate the location of the covariate values. The
labels on the x-axis correspond to the covariate name associated to the
smooth term.
</p>


<h3>Value</h3>

<p>If <code>xp</code> is unspecified (the default), the routine will only
return a plot of the estimated smooth curve. Otherwise, it provides a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xp</code></td>
<td>
<p>The chosen points on which to compute the smooth fit.</p>
</td></tr>
<tr><td><code>sm.xp</code></td>
<td>
<p>The estimated smooth fit at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>sm.low</code></td>
<td>
<p>The lower bound of the pointwise credible interval for the
smooth additive function at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>sm.up</code></td>
<td>
<p>The upper bound of the pointwise credible interval for the
smooth additive function at points specified in <code>xp</code>.</p>
</td></tr>
<tr><td><code>cred.int</code></td>
<td>
<p>The chosen level to compute credible intervals.</p>
</td></tr>
<tr><td><code>smoo.index</code></td>
<td>
<p>The index of the smooth function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlps">gamlps</a></code>, <code><a href="#topic+gamlps.object">gamlps.object</a></code>,
<code><a href="#topic+print.gamlps">print.gamlps</a></code>
</p>

<hr>
<h2 id='print.amlps'>Print an additive partial linear model object.</h2><span id='topic+print.amlps'></span>

<h3>Description</h3>

<p>Print an additive partial linear model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amlps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.amlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>amlps</code>.</p>
</td></tr>
<tr><td><code id="print.amlps_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints informative output of a fitted additive partial linear model.
In particular, the model formula, sample size, number of B-splines in basis,
number of smooth terms, the chosen penalty order,
the latent field dimension, the estimated coefficients of the linear part,
the estimated standard deviation of the error and the effective dimension
of the smooth terms are displayed.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amlps">amlps</a></code>, <code><a href="#topic+amlps.object">amlps.object</a></code>,
<code><a href="#topic+plot.amlps">plot.amlps</a></code>
</p>

<hr>
<h2 id='print.coxlps'>Print a coxlps object.</h2><span id='topic+print.coxlps'></span>

<h3>Description</h3>

<p>Print method for a <code>coxlps</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxlps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.coxlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>coxlps</code>.</p>
</td></tr>
<tr><td><code id="print.coxlps_+3A_...">...</code></td>
<td>
<p>Further arguments passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints informative output of a fitted Cox proportional hazards model
with Laplace-P-splines.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxlps">coxlps</a></code>
</p>

<hr>
<h2 id='print.curelps'>Print the fit of a promotion time cure model.</h2><span id='topic+print.curelps'></span>

<h3>Description</h3>

<p>Print method for a <code>curelps</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'curelps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.curelps_+3A_x">x</code></td>
<td>
<p>An object of class <code>curelps</code>.</p>
</td></tr>
<tr><td><code id="print.curelps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints informative output of a fitted promotion time cure model
with the Laplace-P-spline approach. In particular, the model formula,
number of B-splines in basis, chosen penalty order, latent field
dimension, sample size, number of events and effective model dimension
are provided. The estimated model coefficients related to the
cure probability (long-term survival) and the population hazard dynamics
(short-term survival) are also provided, where <code>coef</code> is
the point estimate, <code>sd.post</code> the posterior standard deviation,
<code>z</code> is the Wald test statistic and <code>lower.95</code> and
<code>upper.95</code> the lower, respectively upper bounds of the approximate
95% pointwise credible interval.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curelps">curelps</a></code>, <code><a href="#topic+curelps.extract">curelps.extract</a></code>,
<code><a href="#topic+plot.curelps">plot.curelps</a></code>
</p>

<hr>
<h2 id='print.gamlps'>Print a generalized additive model object.</h2><span id='topic+print.gamlps'></span>

<h3>Description</h3>

<p>Print a generalized additive model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gamlps_+3A_x">x</code></td>
<td>
<p>An object of class <code>gamlps</code>.</p>
</td></tr>
<tr><td><code id="print.gamlps_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints informative output of a fitted generalized additive model.
In particular, the model formula, sample size, number of B-splines in basis,
number of smooth terms, the chosen penalty order,
the latent field dimension, model degrees of freedom, the estimated
coefficients of the linear part and
the estimated effective degrees of freedom of the smooth terms are
displayed.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlps">gamlps</a></code>, <code><a href="#topic+gamlps.object">gamlps.object</a></code>,
<code><a href="#topic+plot.gamlps">plot.gamlps</a></code>
</p>

<hr>
<h2 id='simcuredata'>Simulation of survival times for the promotion time cure model.</h2><span id='topic+simcuredata'></span>

<h3>Description</h3>

<p>Generates right censored time-to-event data with a plateau in the
Kaplan-Meier estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcuredata(n, censor = c("Uniform", "Weibull"), cure.setting = 1,
            info = TRUE, KapMeier = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simcuredata_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="simcuredata_+3A_censor">censor</code></td>
<td>
<p>The censoring scheme. Either Uniform (the default) or Weibull.</p>
</td></tr>
<tr><td><code id="simcuredata_+3A_cure.setting">cure.setting</code></td>
<td>
<p>A number indicating the desired cure percentage. If
<code>cure.setting = 1</code> (default) the cure percentage is around 20%.
With  <code>cure.setting = 2</code> the cure percentage is around 30%.</p>
</td></tr>
<tr><td><code id="simcuredata_+3A_info">info</code></td>
<td>
<p>Should information regarding the simulation setting be printed
to the console? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simcuredata_+3A_kapmeier">KapMeier</code></td>
<td>
<p>Logical. Should the Kaplan-Meier curve of the generated
data be plotted? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latent event times are generated following Bender et al. (2005),
with a baseline distribution chosen to be a Weibull with mean 8 and variance
17.47. When <code>cure.setting = 1</code> the regression coefficients of the
long-term survival part are chosen to yield a cure percentage around 20%,
while <code>cure.setting = 2</code> yields a cure percentage around 30%.
Censoring is either governed by a Uniform distribution on the support
[20, 25] or by a Weibull distribution with shape parameter 3 and
scale parameter 25.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>survdata</code></td>
<td>
<p>A data frame containing the simulated data.</p>
</td></tr>
<tr><td><code>beta.coeff</code></td>
<td>
<p>The regression coefficients pertaining to long-term
survival.</p>
</td></tr>
<tr><td><code>gamma.coeff</code></td>
<td>
<p>The regression coefficients pertaining to short-term
survival.</p>
</td></tr>
<tr><td><code>cure.perc</code></td>
<td>
<p>The cure percentage.</p>
</td></tr>
<tr><td><code>censor.perc</code></td>
<td>
<p>The percentage of censoring.</p>
</td></tr>
<tr><td><code>censor</code></td>
<td>
<p>The censoring scheme.</p>
</td></tr>
<tr><td><code>S0</code></td>
<td>
<p>The baseline survival function under the chosen Weibull
parameterization.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>
<p>This function is based on a routine used to describe a simulation setting in
Bremhorst and Lambert (2016). Special thanks go to Vincent Bremhorst who
shared this routine during his PhD thesis.
</p>


<h3>References</h3>

<p>Bender, R., Augustin, T. and Blettner, M. (2005). Generating
survival times to simulate Cox proportional hazards models,
<em>Statistics in Medicine</em> <strong>24</strong>(11): 1713-1723.
</p>
<p>Bremhorst, V. and Lambert, P. (2016). Flexible estimation in
cure survival models using Bayesian P-splines. <em>Computational
Statistics &amp; Data Analysis</em> <strong>93</strong>: 270-284.
</p>
<p>Gressani, O. and Lambert, P. (2018). Fast Bayesian inference
using Laplace approximations in a flexible promotion time cure model based
on P-splines. <em>Computational Statistics &amp; Data Analysis</em> <strong>124</strong>:
151-167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
sim &lt;- simcuredata(n = 300, censor = "Weibull", KapMeier = TRUE)

</code></pre>

<hr>
<h2 id='simgamdata'>Simulation of data for (Generalized) additive models.</h2><span id='topic+simgamdata'></span>

<h3>Description</h3>

<p>Simulation of a data set that can be used to illustrate the
<code><a href="#topic+amlps">amlps</a></code> or <code><a href="#topic+gamlps">gamlps</a></code> routines to fit
(generalized) additive models with the Laplace-P-spline methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simgamdata(setting = 1, n, dist = "gaussian", scale = 0.5, info = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simgamdata_+3A_setting">setting</code></td>
<td>
<p>The simulation setting. The default is <code>setting = 1</code>
for a setting with three smooth terms, while <code>setting = 2</code> is another
setting with only two smooth terms. The coefficients of the linear part
of the predictor are also different in the two settings.</p>
</td></tr>
<tr><td><code id="simgamdata_+3A_n">n</code></td>
<td>
<p>The sample size to simulate.</p>
</td></tr>
<tr><td><code id="simgamdata_+3A_dist">dist</code></td>
<td>
<p>A character string to specify the response distribution. The
default is <code>"gaussian"</code>. Other distributions can be <code>"poisson"</code>,
<code>"bernoulli"</code> and <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="simgamdata_+3A_scale">scale</code></td>
<td>
<p>Used to tune the noise level for Gaussian and Poisson
distributions.</p>
</td></tr>
<tr><td><code id="simgamdata_+3A_info">info</code></td>
<td>
<p>Should information regarding the simulation be printed?
Default is true.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation settings contain two covariates in the linear part
of the predictor, namely <em>z1 ~ Bern(0.5)</em> and <em>z2 ~ N(0,1)</em>. The
smooth additive terms are inspired from Antoniadis et al. (2012).
For Binomial data, the number of trials is fixed to 15.
</p>


<h3>Value</h3>

<p>An object of class <em>simgam</em>. Plot of a <em>simgam</em> object
yields a scatter plot of the generated response values.
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>The true smooth functions.</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>The regression coefficients of the linear part. The first
term is the intercept.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>The distribution of the response.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Antoniadis, A., Gijbels, I., and Verhasselt, A. (2012). Variable
selection in additive models using P-splines. <em>Technometrics</em>
<strong>54</strong>(4): 425-438.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
sim &lt;- simgamdata(n = 150, dist = "poisson", scale = 0.3)
plot(sim)

</code></pre>

<hr>
<h2 id='simsurvdata'>Simulation of right censored survival times for the Cox model.</h2><span id='topic+simsurvdata'></span>

<h3>Description</h3>

<p>Generates right censored time-to-event data. Latent event times are drawn
from a Weibull distribution, while censoring times are generated from an
exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsurvdata(a, b, n, betas, censperc, tmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simsurvdata_+3A_a">a</code>, <code id="simsurvdata_+3A_b">b</code></td>
<td>
<p>The shape parameter 'a&gt;0' and scale parameter 'b&gt;0'
of the Weibull.</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_betas">betas</code></td>
<td>
<p>A numeric vector of regression coefficients. Allowed components
of 'betas' are in the interval <em>[-1 ,1]</em> and the total
number of components cannot exceed 5.</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_censperc">censperc</code></td>
<td>
<p>A numeric value in <em>[0,100]</em> corresponding to
the targeted percentage of censoring.</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_tmax">tmax</code></td>
<td>
<p>A maximum upper bound for the generated latent event times.
Especially useful for a simulation study in which the observed event times
are constrained to be generated in a fixed range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Weibull baseline hazard is parameterized as follows (see Hamada
et al. 2008 pp. 408-409) :
</p>
<p style="text-align: center;"><code class="reqn">h_0(t) = (a/(b^a)) t^(a-1), t &gt; 0.</code>
</p>

<p>The i<em>th</em> latent event time is denoted by <em>T_i</em> and is generated
following Bender et al. (2005) as follows:
</p>
<p style="text-align: center;"><code class="reqn">T_i = b (-log(U_i) exp(-\beta^T x_i))^(1/a),</code>
</p>

<p>where <em>U_i</em> is a uniform random variable obtained with 'runif(1)'
, <em>x_i</em> is the i<em>th</em> row of a covariate matrix X of dimension
'c(n, length(betas))' where each component is generated from a
standard Gaussian distribution and <code class="reqn">\beta</code> is the vector of
regression coefficients given by 'betas'.
</p>


<h3>Value</h3>

<p>An object of class 'simsurvdata' which is a list
with the following components:
</p>
<table role = "presentation">
<tr><td><code>sample.size</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code>censoring</code></td>
<td>
<p>Censoring scheme. Either <em>No censoring</em>
or <em>Exponential</em>.</p>
</td></tr>
<tr><td><code>num.events</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code>censoring.percentage</code></td>
<td>
<p>The effective censoring percentage.</p>
</td></tr>
<tr><td><code>survdata</code></td>
<td>
<p>A data frame containing the simulated data.</p>
</td></tr>
<tr><td><code>regcoeffs</code></td>
<td>
<p>The true regression coefficients used to simulate
the data.</p>
</td></tr>
<tr><td><code>S0</code></td>
<td>
<p>The baseline survival function under the chosen Weibull
parameterization.</p>
</td></tr>
<tr><td><code>h0</code></td>
<td>
<p>The baseline hazard function under the chosen Weibull
parameterization.</p>
</td></tr>
<tr><td><code>Weibull.mean</code></td>
<td>
<p>The mean of the Weibull used to generate latent
event times.</p>
</td></tr>
<tr><td><code>Weibull.variance</code></td>
<td>
<p>The variance of the Weibull used to generate latent
event times.</p>
</td></tr>
</table>
<p>The 'print' method summarizes the generated right censored data and
the 'plot' method produces a graph with time on the x axis and
horizontal bars on the y axis corresponding either to an event or a
right censored observation. If 'n &gt; 25', only the 25 first observations
are plotted.
</p>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Bender, R., Augustin, T. and Blettner, M. (2005). Generating
survival times to simulate Cox proportional hazards models,
<em>Statistics in Medicine</em> <strong>24</strong>(11): 1713-1723.
</p>
<p>Hamada, M. S., Wilson, A., Reese, C. S. and Martz, H. (2008).
<em>Bayesian Reliability</em>. Springer Science and Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
sim &lt;- simsurvdata(a = 2, b = 1, n = 300, betas = c(0.8, -0.6), censperc = 25)
sim
plot(sim)

</code></pre>

<hr>
<h2 id='sm'>Specification of smooth terms in (g)amlps function.</h2><span id='topic+sm'></span>

<h3>Description</h3>

<p>Specification of smooth terms in (g)amlps function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm(x)
</code></pre>

<hr>
<h2 id='snmatch'>Fit a skew-normal distribution to a target density.</h2><span id='topic+snmatch'></span>

<h3>Description</h3>

<p>The routine fits a skew-normal univariate distribution to a target density.
Parameters of the resulting skew-normal fit are estimated by the method
of moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snmatch(x, y, p = c(0.025, 0.5, 0.975))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snmatch_+3A_x">x</code></td>
<td>
<p>A numeric vector on the domain of the target density.</p>
</td></tr>
<tr><td><code id="snmatch_+3A_y">y</code></td>
<td>
<p>The y-coordinates of the target density on grid x.</p>
</td></tr>
<tr><td><code id="snmatch_+3A_p">p</code></td>
<td>
<p>Vector of probabilities at which to compute quantiles of the
skew-normal fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The skew-normal density is parameterized by a location parameter
<code class="reqn">\mu</code>, a scale parameter <code class="reqn">\omega</code> and a shape parameter
<code class="reqn">\rho</code> that regulates skewness. The probability density function at any
x on the real line is:
</p>
<p style="text-align: center;"><code class="reqn">p(x) = (2/\omega) \phi((x-\mu)/\omega) \psi(\rho (x-\mu)/\omega),</code>
</p>

<p>where <code class="reqn">\phi()</code> and <code class="reqn">\psi()</code> denote the standard Gaussian density and
cumulative distribution function respectively (see Azzalini 2018).
The first moment and second and third central moments of the target density
are computed based on the x, y coordinates using the trapezoidal rule
and matched against the theoretical moments of a skew-normal distribution.
The solution to this system of equations is the method of moment estimate of
the location, scale and shape parameters of a skew-normal density.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>location</code></td>
<td>
<p>Estimated location parameter.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Estimated scale parameter.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>Estimated shape parameter.</p>
</td></tr>
<tr><td><code>snfit</code></td>
<td>
<p>Fitted values of the skew-normal density
computed on an equally spaced grid between min(x)
and max(x).</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Vector of quantiles of the skew-normal fit
computed on the input vector of probabilities p.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>Equidistant grid on which the skew-normal fitted
density is computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Oswaldo Gressani <a href="mailto:oswaldo_gressani@hotmail.fr">oswaldo_gressani@hotmail.fr</a>.
</p>


<h3>References</h3>

<p>Azzalini, A. (2018). The Skew-Normal and Related families.
<em>Cambridge University Press</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pdf of skew-normal density
sn.target &lt;- function(x, location, scale, shape){
               val &lt;- 2 * stats::dnorm(x, mean = location, sd = scale) *
               pnorm(shape * (x - location) / scale)
               return(val)
              }

# Extract x and y coordinates from target
x.grid &lt;- seq(-2, 6, length = 200)
y.grid &lt;- sapply(x.grid, sn.target, location = 0, scale = 2, shape = 3)

# Computation of the fit and graphical illustration
fit &lt;- snmatch(x.grid, y.grid)
domx &lt;- seq(-2, 6, length = 1000)
plot(domx, sapply(domx, sn.target, location = 0, scale = 2, shape = 3),
     type = "l", ylab = "f(x)", xlab = "x", lwd= 2)
lines(fit$xgrid, fit$snfit, type="l", col = "red", lwd = 2, lty = 2)
legend("topright", lty = c(1,2), col = c("black", "red"), lwd = c(2, 2),
       c("Target","SN fit"), bty="n")

# Extract estimated parameters
fit$location # Estimated location parameter
fit$scale    # Estimated scale parameter
fit$shape    # Estimated shape parameter

</code></pre>

<hr>
<h2 id='st'>Specification of covariates entering the short-term part
in a promotion time cure model.</h2><span id='topic+st'></span>

<h3>Description</h3>

<p>Specification of covariates entering the short-term part
in a promotion time cure model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st(...)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
