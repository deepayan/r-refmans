<!DOCTYPE html><html><head><title>Help for package STB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {STB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#STB-package'><p>(S)imultaneous (T)olerance (B)ounds</p></a></li>
<li><a href='#fastSTB'><p>Simultaneous Tolerance Bands Using a Fast C-Implementation.</p></a></li>
<li><a href='#getSTB'><p>Load/unload C-lib.</p>
Simultaneous Tolerance Bands Using R-Implementation.</a></li>
<li><a href='#plot.STB'><p>Plot Objects of Class 'STB'.</p></a></li>
<li><a href='#plot.stbVCA'><p>Plot Objects of Class 'stbVCA'.</p></a></li>
<li><a href='#rankSTB'><p>Rank-Based Algorithm for Computing 100(1-alpha)% Simulataneous Tolerance Bounds.</p></a></li>
<li><a href='#SASquantile'><p>Implements SAS-quantile Calculation (PCTLDEF=5) as Described by SAS-Help.</p></a></li>
<li><a href='#stb'><p>Generic Method for computing Simultaneous Tolerance Bounds (bands and intervals)</p>
for fitted models or numeric vectors.</a></li>
<li><a href='#stb.default'><p>Simultaneous Tolerance Bands (STB).</p></a></li>
<li><a href='#stb.VCA'><p>Simultaneous Tolerance Bounds on Residuals and Random Effects for 'VCA' Objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Simultaneous Tolerance Bounds</td>
</tr>
<tr>
<td>Author:</td>
<td>Andre Schuetzenmeister &lt;andre.schuetzenmeister@roche.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andre Schuetzenmeister &lt;andre.schuetzenmeister@roche.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, Matrix, methods, VCA (&ge; 1.3.1),
parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an implementation of simultaneous tolerance bounds (STB), useful for checking whether a numeric vector fits to a hypothetical null-distribution or not.
             Furthermore, there are functions for computing STB (bands, intervals) for random variates of linear mixed models fitted with package 'VCA'. All kinds of, possibly transformed 
             (studentized, standardized, Pearson-type transformed) random variates (residuals, random effects), can be assessed employing STB-methodology. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-15 07:28:12 UTC; schueta6</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-15 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='STB-package'>(S)imultaneous (T)olerance (B)ounds</h2><span id='topic+STB'></span><span id='topic+STB-package'></span>

<h3>Description</h3>

<p>Compute simultaneous tolerance bounds for arbitrary null-distributions or random variates of linear mixed models (LMM).
A common problem is to check whether a numeric values follow a distinct distribution. Formal significance tests lack power
when its most needed, when sample size is small and have sort of too much power for large sample sizes, i.e. rejecting
e.g. normality even if departure from normality is negligible for drawing inference.<br />
</p>
<p>Graphical methods are usually preferred over formal testing but lack some objectivity, i.e.
the same plot is differently interpreted by two different persons. Simultaneous tolerance bounds (intervals or bands)
add some objectivity to plots like the QQ-plot, a plot frequently used to check for specific distributions. See the first reference
for details about simultaneous tolerance bounds (there, used for checking normality in the general linear model). 
Various other null-distributions can be checked, since resampling can be applied to all sorts of distributions (see  argument 'rand.func' of <code><a href="#topic+stb">stb</a></code>).<br />
</p>
<p>Besides checking distributional assumptions of numeric vectors, graphical methods are available for linear mixed models fitted using R-package <code><a href="VCA.html#topic+VCA">VCA</a></code>.
Various types of random variates exist in this framework, i.e. random effects and at least two types of residuals. All types of random variates of 
LMM need to be checked for their particular distributional assumptions. Departure from these may indicate that a transformation of the response variable 
is required or that extreme values (possible outliers) have a negative effect on the distribution of random variates. See the 2nd reference for
a discussion of this topic and for practical examples.<br />
</p>
<p>Generic function <code><a href="#topic+stb">stb</a></code> applies to either numeric vectors or to objects of class <code>VCA</code>. The former generates a quantile-quantile (QQ) plot 
following a specified null-distribution with simultaneous tolerance band (see <code><a href="#topic+stb.default">stb.default</a></code>). The latter checks residuals or random effects,
possibly transformed (e.g. studentized) to be normally distributed, incorporating the covariance-structure of the fitted model (see <code><a href="#topic+stb.VCA">stb.VCA</a></code>). 
Plotting methods exists for the resulting objects (see <code><a href="#topic+plot.STB">plot.STB</a></code> and <code><a href="#topic+plot.stbVCA">plot.stbVCA</a></code> for details). 
There are two graphical methods available for random variates of LMM, the usual QQ-plot with simultaneous tolerance band (argument <code>type</code> set to 1 or 3)
and a plot of the random variates with a simultaneous tolerance interval (STI) (argument <code>type</code> set to 2 or 3), where the STI is derived from the extreme
values (first and last order statistics).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> STB</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-09-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister &lt;andre.schuetzenmeister@roche.com&gt;</p>


<h3>References</h3>

<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P. (2011), Checking assumptions of normality and homoscedasticity in the general linear model. Communications in Statistics - Simulation and Computation; S. 141-154
</p>
<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach. Computational Statistics and Data Analysis, 56, 1405-1416
</p>

<hr>
<h2 id='fastSTB'>Simultaneous Tolerance Bands Using a Fast C-Implementation.</h2><span id='topic+fastSTB'></span>

<h3>Description</h3>

<p>This function represents the interface to a C-implementation of the bisection algorithm for computing
simultaneous tolerance bounds as described in Schuetzenmeister et al. 2012.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastSTB(
  mat,
  alpha = 0.05,
  tol = 1e-04,
  max.iter = 100L,
  Ncpu = 2,
  timer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastSTB_+3A_mat">mat</code></td>
<td>
<p>(numeric) matrix with rows representing simulations of 'ncol' values, rows are supposed to be sorted</p>
</td></tr>
<tr><td><code id="fastSTB_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) 100(1-alpha)% simultaneous tolerance level (coverage)</p>
</td></tr>
<tr><td><code id="fastSTB_+3A_tol">tol</code></td>
<td>
<p>(numeric) convergence tolerance level for the bisection algorithm</p>
</td></tr>
<tr><td><code id="fastSTB_+3A_max.iter">max.iter</code></td>
<td>
<p>(integer) number of bisection-steps for the algorithm</p>
</td></tr>
<tr><td><code id="fastSTB_+3A_ncpu">Ncpu</code></td>
<td>
<p>(integer) specifying the number of processors (CPUs, cores, ...) to be used</p>
</td></tr>
<tr><td><code id="fastSTB_+3A_timer">timer</code></td>
<td>
<p>(logical) TRUE = the time spent for computing the STB will be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantiles will be computed according to SAS PCTLDEF5 definition of quantiles, which is identical to 'type=2' 
in function <code><a href="stats.html#topic+quantile">quantile</a></code>. This is also the default-option throughout this package. Function <code><a href="#topic+SASquantile">SASquantile</a></code>
is a R-implementation identical to the C-implementation used here.
</p>


<h3>Value</h3>

<p>(list) with elements:
</p>
<table>
<tr><td><code>mat</code></td>
<td>
<p>(numeric) matrix with sorted random vector stored in rows</p>
</td></tr>
<tr><td><code>nCol</code></td>
<td>
<p>(integer) number of columns of 'mat'</p>
</td></tr>
<tr><td><code>nRow</code></td>
<td>
<p>(integer) number of rows of 'mat'</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>(numeric) values used for the 100(1-alpha)% STB</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>(numeric) the tolerance value used as stopping criterion for the bisection algorithm</p>
</td></tr>
<tr><td><code>max.iter</code></td>
<td>
<p>(integer) the max. number of iteration of the bisection algorithm</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>(numeric) matrix with 2 rows, corresponding to the bounds of the STB (1st row = lower bounds, 2nd row = upper bounds)</p>
</td></tr>
<tr><td><code>coverage</code></td>
<td>
<p>(numeric) value corresponding to the actual coverage of the STB</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P. (2011), Checking assumptions of normality and homoscedasticity in the general linear model. 
Communications in Statistics - Simulation and Computation; S. 141-154
</p>


<h3>See Also</h3>

<p><a href="#topic+getSTB">getSTB</a> <a href="#topic+stb">stb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### example for 10000 x 30 matrix
 set.seed(333)
 mat &lt;- t(apply(matrix(rnorm(10000*30), ncol=30), 1, sort))
 stb.obj1 &lt;- fastSTB(mat, timer=TRUE)
 stb.obj1$coverage
	stb.obj2 &lt;- fastSTB(mat, timer=TRUE, Ncpu=4)
 stb.obj3 &lt;- fastSTB(mat, timer=TRUE, Ncpu=6)
 stb.obj4 &lt;- fastSTB(mat, timer=TRUE, Ncpu=8)

## End(Not run)
</code></pre>

<hr>
<h2 id='getSTB'>Load/unload C-lib.
Simultaneous Tolerance Bands Using R-Implementation.</h2><span id='topic+getSTB'></span>

<h3>Description</h3>

<p>Compute simultaneous tolerance bounds (STB) from a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSTB(
  mat,
  alpha = 0.05,
  tol = 1e-04,
  max.iter = 100L,
  q.type = 2L,
  logfile = NULL,
  output = TRUE,
  timer = FALSE,
  Ncpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSTB_+3A_mat">mat</code></td>
<td>
<p>(numeric) matrix with nrow=N_simulation, ncol=N_points, where each row is sorted in increasing order</p>
</td></tr>
<tr><td><code id="getSTB_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) 100(1-alpha)% simultaneous tolerance-level will be computed</p>
</td></tr>
<tr><td><code id="getSTB_+3A_tol">tol</code></td>
<td>
<p>(numeric) value controlling the termination of the bisection algorithm, i.e. the condition <code>coverage-(1-alpha)&lt;=tol</code>
has to be TRUE.</p>
</td></tr>
<tr><td><code id="getSTB_+3A_max.iter">max.iter</code></td>
<td>
<p>(integer) maximum number of iterations of the bisection algorithm. If this number is reached the algorithm terminates
and returns the best approximation of lower and upper bounds reached up to this iteration.</p>
</td></tr>
<tr><td><code id="getSTB_+3A_q.type">q.type</code></td>
<td>
<p>(integer) the quantile-type used if <code>algo="R"</code>, see ? quantile for details.</p>
</td></tr>
<tr><td><code id="getSTB_+3A_logfile">logfile</code></td>
<td>
<p>(character) string specifying the name of the (optional) log-file, storing the iteration history</p>
</td></tr>
<tr><td><code id="getSTB_+3A_output">output</code></td>
<td>
<p>(logical) TRUE a txtProgressBar will be printed as well as additional status information</p>
</td></tr>
<tr><td><code id="getSTB_+3A_timer">timer</code></td>
<td>
<p>(logical) TRUE = the time spent for computing the STB will be printed</p>
</td></tr>
<tr><td><code id="getSTB_+3A_ncpu">Ncpu</code></td>
<td>
<p>(integer) specifying the number cores/CPUs to be used in computing the coverage on C-level,
for N&gt;1 multi-processing is applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function computes 100(1-alpha)% simultaneous tolerance bounds (intervals, bands) from a matrix, where rows correspond
to order statistics (sorted) of random samples of a, e.g. normal distribution. It starts by computing joint coverage 
of the naive unadjusted (point-wise) alpha-level  intervals, computed as percentiles across each order statistic (columns).
Alpha is decreased using a bisection search until the joint coverage becomes at least 100(1-alpha)% depending on arguments
<code>max.iter</code> and <code>tol</code>. If the number of simulated random samples goes to infinity, the STB becomes exact.
Note that checking whether a numeric vector is normally distributed is equal to checking whether the residuals of the simplest
linear model y = mu + e (y~1) are normally distributed [e ~ N(0, sigma^2)].
</p>


<h3>Value</h3>

<p>(list) with elements:
</p>
<table>
<tr><td><code>Q</code></td>
<td>
<p>(numeric) matrix with two rows, where the 1st row = lower bounds of the STB, 2nd row = upper bounds of the STB</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>(numeric) value indicating the actual coverage of the STB</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P. (2011), Checking assumptions of normality and homoscedasticity in the general linear model. 
Communications in Statistics - Simulation and Computation; S. 141-154
</p>


<h3>See Also</h3>

<p><a href="#topic+fastSTB">fastSTB</a> <a href="#topic+stb">stb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(333)
mat &lt;- t(apply(matrix(rnorm(10000*30), ncol=30), 1, sort))
stb.obj &lt;- getSTB(mat, timer=TRUE)
stb.obj$cov

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.STB'>Plot Objects of Class 'STB'.</h2><span id='topic+plot.STB'></span>

<h3>Description</h3>

<p>Standard plotting method for objects of class 'STB'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STB'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.STB_+3A_x">x</code></td>
<td>
<p>(object) of class 'STB' as generated by function <code>getSTB</code></p>
</td></tr>
<tr><td><code id="plot.STB_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots objects of class 'STB' as generated by function <code><a href="#topic+stb">stb</a></code>.
Objects of S3-class 'STB' are list-type objects storing all the information
needed to plot QQ-plots with simultaneous tolerance bounds.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+stb">stb</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### generate an 'STB' object without plotting
obj &lt;- stb(rnorm(30), plot=FALSE)
plot(obj)

### manipulate the 'STB' object for plotting
obj$legend=TRUE
plot(obj)

### add a previously generated STB-ocject to an existing plot
plot(sort(rnorm(30)), sort(rnorm(30)))
obj$add &lt;- TRUE
plot(obj) 

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.stbVCA'>Plot Objects of Class 'stbVCA'.</h2><span id='topic+plot.stbVCA'></span>

<h3>Description</h3>

<p>Standard plotting method for objects of Class 'stbVCA'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stbVCA'
plot(x, orient = 1, pick = FALSE, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stbVCA_+3A_x">x</code></td>
<td>
<p>(object) of class 'STB' as generated by function <code>getSTB</code></p>
</td></tr>
<tr><td><code id="plot.stbVCA_+3A_orient">orient</code></td>
<td>
<p>(integer) in 'type=1' plots, 1 = expected vs. observed values, 2 = observed vs. expected values</p>
</td></tr>
<tr><td><code id="plot.stbVCA_+3A_pick">pick</code></td>
<td>
<p>(logical, integer) TRUE = triggers function <code><a href="graphics.html#topic+identify">identify</a></code> for identification
of points using the mouse. Stop interactive identification by pressing 'Esc' or
&quot;Right-Mousclick &ndash;&gt; Stop&quot;. If 'TRUE' and 'type=3', identified points will be added to the residual
plot with STI automatically. If 'pick=1', only in the QQ-plot identification will be toggled, and if
'pick=2' only in the residual plot identification will be possible.</p>
</td></tr>
<tr><td><code id="plot.stbVCA_+3A_type">type</code></td>
<td>
<p>(integer) 1 = plot simultaneous tolerance band (STB), 2 = plot simultaneous tolerance interval (STI),
3 = plot STB and STI</p>
</td></tr>
<tr><td><code id="plot.stbVCA_+3A_...">...</code></td>
<td>
<p>additional arguments changing the visual appearance of the plot, e.g.
'pch', 'pch.out', 'col', 'col.out', 'stb.col', 'stb.main', &quot;'sti.main', 'legend', ...
in fact all elements of 'x'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots objects of class 'stbVCA' as generated by function <code><a href="#topic+stb.VCA">stb.VCA</a></code>.
Objects of S3-class 'stbVCA' are list-type objects storing all the information
needed to plot QQ-plots with simultaneous tolerance bounds. Additionally to the information
contained in ordinary 'STB' objects, a copy of the 'VCA' object is stored as well as the
type of random variate and the mode, i.e. the type of transformation applied.
</p>
<p>One can specify additional parameters for changing the appearance of the plot(s). Any of the following
parameters can be set to a value different from the default: <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>legend</code>   </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> (logical) TRUE = will add legend to plot(s) (is default) </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>pch</code>      </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> plotting symbol for non-outlying points (default=16) </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>col</code>      </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> point color for non-outlying points (default="black") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>col.out</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> point color for outlying points (default="red") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>pch.out</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> plotting symbold for outlying points (default=16) </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>stb.col</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> color of the STB in the QQ-plot (default="#0000FF40") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>stb.lpos</code> </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> position placement as done in function 'legend', or, character string "title" indicating</td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: center;">     </td><td style="text-align: left;"> that legend information should be displayed as (sub-main) title (default="title") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>stb.main</code> </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> character string used as main title in the QQ-plot with STB </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.lty</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> line type for STI-bounds in the residual plot (default=2) </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.lwd</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> line width for STI-bounds (default=1) </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.col</code>  </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> line color for STI bounds (default="red") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.ylab</code> </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> character string specifying the Y-axis label in the resiudal plot with STI </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.lpos</code> </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> position placement as done in function 'legend' (default="topright") </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>sti.main</code> </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> character string used as main title in the residual plot with STI </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>(stbVCA) object is invisibly returned, any additional compution results are added
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+stb.VCA">stb.VCA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(VCA)
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
fit

# use studentized conditional residuals
stb.obj1 &lt;- stb.VCA(fit, term="cond", mode="student", N=1000)

# plot it again
plot(stb.obj1)

# use random effects "day" and apply standardization
stb.obj2 &lt;- stb.VCA(fit, term="day", mode="stand", N=1000)

# plot it again
plot(stb.obj2)

# initially, request QQ-plot with STB
stb.obj3 &lt;- stb.VCA(fit, term="day", mode="stand", N=1000, type=1)

# now request plotting of the residual plot as well
# catch computation result which are invisibly returned
stb.obj4 &lt;- plot(stb.obj3, type=3)

# individualize the appearance of the plot
plot(stb.obj4, sti.lpos="top", col="darkblue", out.pch=17, out.col="green") 

## End(Not run)
</code></pre>

<hr>
<h2 id='rankSTB'>Rank-Based Algorithm for Computing 100(1-alpha)% Simulataneous Tolerance Bounds.</h2><span id='topic+rankSTB'></span>

<h3>Description</h3>

<p>Implementation of a rank-based algorithm for constructing 100(1-alpha)% STBs as outlined in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankSTB(mat, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankSTB_+3A_mat">mat</code></td>
<td>
<p>(numeric) matrix of dimension (N, n), where i-th row corrsponds to ordered values 
of the i-th simulation</p>
</td></tr>
<tr><td><code id="rankSTB_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) value defining the desired coverage as 100(1-alpha)%</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a performance optimized version of the original rank-based algorithm avoiding the time-consuming
iteration. In principle it sorts out simulation results which have at least one extreme order statistic untill
exactly 100(1-alpha)% of all simulation results remain. From these, bounds of the STB are constructed determining
extreme-values per order-statistic (column).
</p>
<p>This implementation also corrects step 4) of the published algorithm, which has to find those indices of elements being
equal to &quot;min(c)&quot; OR being equal to &quot;N-min(c)+1&quot;. This reflects the construction of vector &quot;c&quot;, where max. rank-values
are transformed to min. rank-values. In step 6) the &quot;N_k-1-(1-alpha)*N largest&quot; elements of &quot;d_l^theta&quot; have to
be selected, which needs also correction.
</p>
<p>Parallel processing did not minimize the computation time in contrast to the algorithms for computing the quantile-based algorithm.
Thus, parallel processing is not supported for this algorithm.
</p>


<h3>Value</h3>

<p>(list) with two elements:<br />
</p>
<table>
<tr><td><code>Q</code></td>
<td>
<p>(matrix) 1st row stores lower bounds, 2nd row upper bounds</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>(numeric) value corresponding the coverage</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# for following problem size the rank-based algo
# outperforms the quantile based one, although,
# ran serially
mat &lt;- matrix(rnorm(10000*100), ncol=100)
mat &lt;- t(apply(mat, 1, sort))
system.time(stb.rank &lt;- rankSTB(mat))
system.time(stb.q.R  &lt;- getSTB(mat))
system.time(stb.q.C  &lt;- fastSTB(mat))
x &lt;- apply(mat, 2, mean)
plot(x,x, ylim=c(-5,5))
lines(x, stb.q.R$Q[1,], col="blue", lwd=2)
lines(x, stb.q.R$Q[2,], col="blue", lwd=2)
lines(x, stb.q.C$Q[1,], col="red",  lwd=2)
lines(x, stb.q.C$Q[2,], col="red",  lwd=2)
lines(x, stb.rank$Q[1,],  col="cyan", lwd=2)
lines(x, stb.rank$Q[2,],  col="cyan", lwd=2)
legend("top", legend=c("R-quantile", "C-quantile", "rank-based"), 
       fill=c("blue", "red", "cyan"))

# varying Ncpu for the C-implementation of the quantile-based algo
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=4))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=6))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=8))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=10))
system.time(stb.q.C  &lt;- fastSTB(mat, Ncpu=12))

## End(Not run)
</code></pre>

<hr>
<h2 id='SASquantile'>Implements SAS-quantile Calculation (PCTLDEF=5) as Described by SAS-Help.</h2><span id='topic+SASquantile'></span>

<h3>Description</h3>

<p>This implementation seems to be identical with 'type=2' in function <code><a href="stats.html#topic+quantile">quantile</a></code>
but less efficiently implemented, i.e. for large vectors x it is much slower than the built-in
quantile-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SASquantile(x, prob, tol = 1e-12, type = c("R", "C"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SASquantile_+3A_x">x</code></td>
<td>
<p>(numeric) vector</p>
</td></tr>
<tr><td><code id="SASquantile_+3A_prob">prob</code></td>
<td>
<p>(numeric) value 0 &lt; prob &lt; 1</p>
</td></tr>
<tr><td><code id="SASquantile_+3A_tol">tol</code></td>
<td>
<p>(numeric) value used for checking numerical equivalence</p>
</td></tr>
<tr><td><code id="SASquantile_+3A_type">type</code></td>
<td>
<p>(character) &quot;R&quot; = uses the R-implementation, &quot;C&quot; = calls the C-implementation
n</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
SASquantile(1:100, .75)

### compare to R-default
quantile(1:100, .75) 

### or to what R calls SAS-definition
quantile(1:100, .75, type=3)

# should work for any vector (no seed)
v &lt;- rnorm(50000,20,7)
Q.R2    &lt;- quantile(v, probs=c(.01, .025, .05, .1, .25, .5, .75, .9, .95, .975, .99), type=2)
Q.SAS.R &lt;- SASquantile(v, prob=c(.01, .025, .05, .1, .25, .5, .75, .9, .95, .975, .99), type="R")
Q.SAS.C &lt;- SASquantile(v, prob=c(.01, .025, .05, .1, .25, .5, .75, .9, .95, .975, .99), type="C")

Q.R2
Q.SAS.R
Q.SAS.C

## End(Not run)
</code></pre>

<hr>
<h2 id='stb'>Generic Method for computing Simultaneous Tolerance Bounds (bands and intervals) 
for fitted models or numeric vectors.</h2><span id='topic+stb'></span>

<h3>Description</h3>

<p>If the generic method is applied to an object of class <code>VCA</code> function <code><a href="#topic+stb.VCA">stb.VCA</a></code>
is called and all its arguments may be specified. Otherwise, function <code><a href="#topic+stb.default">stb.default</a></code>
is called and all its arguments may be specified. The latter was developed for numeric vectors
(see ?stb.default). Therefore this method will most likely produce strange results on other
types of objects than <code>VCA</code> and numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stb(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stb_+3A_obj">obj</code></td>
<td>
<p>(object) passed on</p>
</td></tr>
<tr><td><code id="stb_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='stb.default'>Simultaneous Tolerance Bands (STB).</h2><span id='topic+stb.default'></span>

<h3>Description</h3>

<p>Compute And/Or Plot Simultaneous Tolerance Bands for numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
stb(
  obj,
  N = 10000L,
  alpha = 0.05,
  rand.func = rnorm,
  tol = 1e-04,
  max.iter = 100L,
  algo = c("rank", "C", "R"),
  Ncpu = 1,
  q.type = 2L,
  stb.col = "#0000FF40",
  col.points = "black",
  col.out = "red",
  col.pwb = "#0000FF40",
  main = NULL,
  add.pwb = FALSE,
  quiet = FALSE,
  add = FALSE,
  plot = TRUE,
  legend = FALSE,
  timer = FALSE,
  pch = 16,
  pch.out = 16,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stb.default_+3A_obj">obj</code></td>
<td>
<p>(numeric) vector, which is supposed to be N(my, sigma^2)-distributed</p>
</td></tr>
<tr><td><code id="stb.default_+3A_n">N</code></td>
<td>
<p>(integer) value specifying the number of random samples to be used for constructing the STB</p>
</td></tr>
<tr><td><code id="stb.default_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) value specifying the simultaneous tolerance level, i.e. 100(1-alpha)% of all 'N'
random samples have to be completely enclosed by the bounds of the STB</p>
</td></tr>
<tr><td><code id="stb.default_+3A_rand.func">rand.func</code></td>
<td>
<p>(function) a function which generates random samples, e.g. <code>rand.func=rnorm</code> which corresponds to random
sampling from the standard normal distribution. Another example is defining func=function(n)rchisq(n=n, df=3, ncp=2)
and using <code>rand.func=func</code>. See examples for further examples.</p>
</td></tr>
<tr><td><code id="stb.default_+3A_tol">tol</code></td>
<td>
<p>(numeric) value specifying the max. acceptable deviation from 'alpha' used in the bisection algorithm</p>
</td></tr>
<tr><td><code id="stb.default_+3A_max.iter">max.iter</code></td>
<td>
<p>(integer) value specifying the max. number of iteration for finding the bounds of the STB</p>
</td></tr>
<tr><td><code id="stb.default_+3A_algo">algo</code></td>
<td>
<p>(character) (string) specifying the method to be used for constructing a 100(1-alpha)% STB,
choose &quot;rank&quot; for the rank-based, &quot;C&quot; for a C-implementation of the quantile-based, and
&quot;R&quot; for an R-implentation of the quantile-based algorithm (see details). &quot;C&quot; uses SAS PCTLDEF5 definition of quantiles,
whereas &quot;R&quot; can use any of the built-in R types of quantiles (see <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="stb.default_+3A_ncpu">Ncpu</code></td>
<td>
<p>(integer) specifying the number cores/CPUs to be used, for N&gt;1 multi-processing is applied</p>
</td></tr>
<tr><td><code id="stb.default_+3A_q.type">q.type</code></td>
<td>
<p>(integer) the quantile-type used if <code>algo="R"</code>, see ? quantile for details.</p>
</td></tr>
<tr><td><code id="stb.default_+3A_stb.col">stb.col</code></td>
<td>
<p>(character) string, a valid specification of a color to be used for the STB</p>
</td></tr>
<tr><td><code id="stb.default_+3A_col.points">col.points</code></td>
<td>
<p>(character) color for the points in the QQ-plot</p>
</td></tr>
<tr><td><code id="stb.default_+3A_col.out">col.out</code></td>
<td>
<p>(character) color for points outsied of the 100(1-alpha)% STB</p>
</td></tr>
<tr><td><code id="stb.default_+3A_col.pwb">col.pwb</code></td>
<td>
<p>(character) color for the point-wise STB (not adjusted for multiplicity), defaults to &quot;#0000FF40&quot; which is &quot;blue&quot;
with 80% transparency</p>
</td></tr>
<tr><td><code id="stb.default_+3A_main">main</code></td>
<td>
<p>(characer) string for a main title appearing over the plot</p>
</td></tr>
<tr><td><code id="stb.default_+3A_add.pwb">add.pwb</code></td>
<td>
<p>(logical) should the point-wise tolerance band be plotted for comparison?</p>
</td></tr>
<tr><td><code id="stb.default_+3A_quiet">quiet</code></td>
<td>
<p>(logical) TRUE = no additional output ist printed (progress bar etc.)</p>
</td></tr>
<tr><td><code id="stb.default_+3A_add">add</code></td>
<td>
<p>(logical) TRUE = the 100(1-alpha)% STB is added to an existing plot</p>
</td></tr>
<tr><td><code id="stb.default_+3A_plot">plot</code></td>
<td>
<p>(logical) TRUE = either a QQ-plot with STB (add=FALSE) or a STB added to an existing plot (add=TRUE) is plotted.
FALSE = only computations are carried out without plotting, an object of class 'STB' is returned which
can be stored an plotted later on, e.g. to avoid computing an STB every time a Sweave/mWeave report is updated</p>
</td></tr>
<tr><td><code id="stb.default_+3A_legend">legend</code></td>
<td>
<p>(logical) TRUE a legend is plotted &quot;topleft&quot;</p>
</td></tr>
<tr><td><code id="stb.default_+3A_timer">timer</code></td>
<td>
<p>(logical) TRUE = the time spent for computing the STB will be printed</p>
</td></tr>
<tr><td><code id="stb.default_+3A_pch">pch</code></td>
<td>
<p>(integer) plotting symbols for the QQ-plot</p>
</td></tr>
<tr><td><code id="stb.default_+3A_pch.out">pch.out</code></td>
<td>
<p>(integer) plotting symbols for outlying points</p>
</td></tr>
<tr><td><code id="stb.default_+3A_seed">seed</code></td>
<td>
<p>(numeric) value interpreted as integer, setting the random number generator (RNG) to a defined state</p>
</td></tr>
<tr><td><code id="stb.default_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function takes a numeric vector 'vec' and computes the 100(1-alpha)%-simultaneous tolerance band (STB) for
the (DEFAULT )Null-hypothesis H0: vec~N(my, sigma^2) distributed, which is equal to checking whether the residuals of 
the simplest linear model y = mu + e (y~1) are normally distributed, i.e. 'e ~ N(0, sigma^2)'. By specification of argument <code>rand.func</code> 
other null-distributions can be specified. One has to specify a function with a single argument 'n',  which returns a random sample with 'n' 
observations, randomly drawn from the desired null-distribution (see description argument <code>rand.func</code> below). 
Note that all random samples as well as vector <code>vec</code> will be centered to mean=0 and scaled to sd=1.
</p>
<p>One can choose between three methods for constructing the 100(1-alpha)% STB. There are two implementations of the quantile-based algorithm
(&quot;C&quot;, &quot;R&quot; see 1st reference) and one of the rank-based algorithm (see 2nd reference). Methods &quot;C&quot; and &quot;R&quot; can be run in parallel. The rank-based
algorithm does not benefit form parallel processing, at least not in the current implementation. It is still the default and recommended for small to medium 
sized vectors and 10000 &lt;= N &lt;= 20000 simulations, which should be sufficiently accurate reflect the null-distribution. The &quot;C&quot; and &quot;R&quot; options refer
to implementations of the quantile-based algorithm. The &quot;C&quot; implementation benefits most from using multiple cores, i.e. the larger 'Ncpu' the better,
and should be used for large problems, i.e. rather large number of elements and large number of simulations.
</p>
<p>The table below gives an impression how these algorithms perform. Runtimes were measured under Windows 7 on a Intel Xeon E5-2687W 3.1 GHz workstation with 16
logical cores and 16 GB RAM. The runtime of the C-implementation of the quantile-based algorithm is denoted as &quot;t_qC12&quot; applied parallely with 12 cores.
Each setting was repeated 10 times and the overall run time was then divided by 10 providing sufficiently robust simulation results.
Note, that for smaller problem sizes a large proportion of the overall runtime is due to simulating, i.e. drawing from the null-distribution.
</p>

<table>
<tr>
 <td style="text-align: right;">
	<strong>_____N_obs</strong> </td><td style="text-align: right;"> <strong>_____N_sim</strong> </td><td style="text-align: right;"> <strong>____t_rank</strong> </td><td style="text-align: right;"> <strong>____t_qC12</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
 25    </td><td style="text-align: right;"> 5000  </td><td style="text-align: right;">  0.4s </td><td style="text-align: right;">   0.5s </td>
</tr>
<tr>
 <td style="text-align: right;">
 25	  </td><td style="text-align: right;"> 10000 </td><td style="text-align: right;">  0.8s </td><td style="text-align: right;">   1.3s </td>
</tr>
<tr>
 <td style="text-align: right;">
 50	  </td><td style="text-align: right;"> 10000 </td><td style="text-align: right;">  1.0s </td><td style="text-align: right;">   3.2s </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 100	  </td><td style="text-align: right;"> 10000 </td><td style="text-align: right;">  1.7s </td><td style="text-align: right;">   2.9s </td>
</tr>
<tr>
 <td style="text-align: right;">
 100	  </td><td style="text-align: right;"> 20000 </td><td style="text-align: right;">  3.0s </td><td style="text-align: right;">   4.8s </td>
</tr>
<tr>
 <td style="text-align: right;">
 225	  </td><td style="text-align: right;"> 20000 </td><td style="text-align: right;">  5.1s </td><td style="text-align: right;">   8.3s </td>
</tr>
<tr>
 <td style="text-align: right;">
 300	  </td><td style="text-align: right;"> 30000 </td><td style="text-align: right;">  9.6s </td><td style="text-align: right;">  17.2s </td>
</tr>
<tr>
 <td style="text-align: right;">
 300	  </td><td style="text-align: right;"> 50000 </td><td style="text-align: right;"> 16.1s </td><td style="text-align: right;">  24.9s </td>
</tr>
<tr>
 <td style="text-align: right;">
 1000  </td><td style="text-align: right;"> 50000 </td><td style="text-align: right;"> 47.8s </td><td style="text-align: right;"> 123.5s </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>invisibly returns a list-type object of class <code>STB</code>, which comprises all arguments accepted by this function.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P. (2011), Checking assumptions of normality and homoscedasticity in the general linear model. 
Communications in Statistics - Simulation and Computation; S. 141-154
</p>
<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.STB">plot.STB</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### log-normal vector to be checked for normality
## Not run: 
set.seed(111)
stb(exp(rnorm(30)), col.out="red", legend=TRUE)

### uniformly distributed sample checked for Chi-Squared Distribution with DF=1, degrees of freedom
set.seed(707)
stb(runif(25, -5, 5), rand.func=function(n){rchisq(n=n, df=1)}, 
    col.out="red", legend=TRUE, main="Chi-Squared with DF=1")

### check whether an Chi-Squared (DF=1) random sample better fits 
stb(rchisq(25, df=1), rand.func=function(n){rchisq(n=n, df=1)}, 
    col.out="red", legend=TRUE, main="Chi-Squared with DF=1")

### add STB to an existing plot
plot(sort(rnorm(30)), sort(rnorm(30)))
stb(rnorm(30), add=TRUE)

### compute STB for later use and prevent plotting
STB &lt;- stb(rnorm(30), plot=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stb.VCA'>Simultaneous Tolerance Bounds on Residuals and Random Effects for 'VCA' Objects.</h2><span id='topic+stb.VCA'></span>

<h3>Description</h3>

<p>Simulate <code class="reqn">N</code>-times data incorporating the estimated variance-covariance
matrix of observations <code class="reqn">y</code> and construct a 100(1-alpha)% simultaneous tolerance band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VCA'
stb(
  obj,
  term = NULL,
  mode = c("raw", "student", "standard", "pearson"),
  N = 5000,
  alpha = 0.05,
  algo = c("rank", "R", "C"),
  q.type = 2L,
  plot = TRUE,
  legend = TRUE,
  orient = 1,
  main1 = NULL,
  main2 = NULL,
  seed = NULL,
  type = 1,
  pb = TRUE,
  parallel = TRUE,
  Ncpu = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stb.VCA_+3A_obj">obj</code></td>
<td>
<p>(VCA) object</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_term">term</code></td>
<td>
<p>(character, integer) specifying a type of residuals if one of c(&quot;conditional&quot;,
&quot;marginal&quot;), or, the name of a random term (one of obj$re.assign$terms). If 'term'
is a integer, it is interpreted as the i-th random term in 'obj$re.assign$terms'.</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_mode">mode</code></td>
<td>
<p>(character) string specifying a possible transformation of random effects or 
residuals (see <code><a href="VCA.html#topic+residuals.VCA">residuals.VCA</a></code> and <code><a href="VCA.html#topic+ranef.VCA">ranef.VCA</a></code>for details)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_n">N</code></td>
<td>
<p>(integer) specifying the number of simulated datasets <code class="reqn">y_sim</code></p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) value 0 &lt; alpha &lt; 1 specifying the min. 100(1-alpha)% coverage of the
simultaneous tolerance band (STB)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_algo">algo</code></td>
<td>
<p>(character) (string) specifying the method to be used for constructing a 100(1-alpha)% STB,
choose &quot;rank&quot; for the rank-based, &quot;C&quot; for a C-implementation of the quantile-based, and
&quot;R&quot; for an R-implentation of the quantile-based algorithm (see details).</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_q.type">q.type</code></td>
<td>
<p>(integer) value specifying the quantile type to be used as offered in <code><a href="stats.html#topic+quantile">quantile</a></code>
in case 'algo=&quot;R&quot;'.    Whenever 'algo=&quot;C&quot;', quantiles are computed according to SAS PCTLDEF5, 
which is identical to type 2. The rank-based algorithm does not employ quantiles.</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_plot">plot</code></td>
<td>
<p>(logical) TRUE = create 'stbVCA' object and plot it, FALSE = only create the 'stbVCA' object</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_legend">legend</code></td>
<td>
<p>(logical) TRUE = add legend to the plot(s)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_orient">orient</code></td>
<td>
<p>(integer) in QQ-plot, specifying whether to plot expected values vs. observed values (1)
or observed vs. expected (2)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_main1">main1</code></td>
<td>
<p>(character) string specifying an user-defined main-title of the 'type=1' plot (STB)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_main2">main2</code></td>
<td>
<p>(character) string specifying an user-defined main-title of the 'type=2' plot (STI)</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_seed">seed</code></td>
<td>
<p>(integer) value used as seed for the RNG</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_type">type</code></td>
<td>
<p>(integer) 1 = QQ-plot with simultaneous tolerance band (STB), 2 = residual plot with simultaneous 
tolerance interval (STI), 3 = both plot at once</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_pb">pb</code></td>
<td>
<p>(logical) TRUE = a text-based progress bar will display the simulation progress</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_parallel">parallel</code></td>
<td>
<p>(logical) TRUE = parallel processing will be attempted on 'Ncpu' cores of the local machine.
FALSE = no parallel processing applied, only in this case, 'pb' will have an effect, since this 
is only available for non-parallel processing.</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_ncpu">Ncpu</code></td>
<td>
<p>(integer) specifying the number of CPUs on which the parallelization will be carried out.
In case that 'Ncup' is larger than the number of existing CPUs, the max. number of CPUs will be used
instead. Note, that setting 'Ncpu' to the max. number available may not result in the min. time 
spent on computing.</p>
</td></tr>
<tr><td><code id="stb.VCA_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Linear Mixed Models, noted in standard matrix notation, can be written as <code class="reqn">y = Xb + Zg + e</code>, where
<code class="reqn">y</code> is the column vector of observations, <code class="reqn">X</code> and <code class="reqn">Z</code> are design matrices assigning fixed (<code class="reqn">b</code>),
respectively, random (<code class="reqn">g</code>) effects to observations, and <code class="reqn">e</code> is the column vector of residual errors.
</p>
<p>Here, simulation is performed incorporating the variance-covariance matrix <code class="reqn">V = ZGZ^{T}+R</code> of observations <code class="reqn">y</code>. 
There are two types of random variates in a mixed model, random effects <code class="reqn">g</code> and residual errors <code class="reqn">e</code>. These
follow a multivariate normal distribution with expectation zero and covariance matrices <code class="reqn">G</code> and <code class="reqn">R</code>. See the 1st 
reference for a detailed description of the properties. 
Following Schuetzenmeister and Piepho (2012), a Cholesky decomposition <code class="reqn">V = CC'</code> is applied to <code class="reqn">V</code>, 
yielding the upper triangular matrix <code class="reqn">C</code>, which can be used to simulate a new set of observations 
<code class="reqn">y_{sim}=Cz</code>, where <code class="reqn">z</code> is a vector of independent standard normal deviates of the same size as <code class="reqn">y</code>.
Actually, <code class="reqn">y_sim = C'z</code> is used here, because the Cholesky decomposition in <code>R</code> is defined as <code class="reqn">V=C'C</code>. 
For each simulated dataset, random variates of interest ('term') are extracted, possibly transformed ('mode') and
stored in ordered form (order statistics) in a <code class="reqn">N x n</code> matrix, <code class="reqn">N</code> being the number of simulated datasets and
<code class="reqn">n</code> being the number of random variates of interest. For each column of this matrix tolerance intervals 
are computed iteratively untill the joint coverage is as close to but &gt;= 100(1-alpha)/
iterations is reached. This quantile-based algorithm is exact for <code class="reqn">N --&gt; Infinity</code>.
</p>
<p>SAS-quantile definition PCTLDEF=5 is used in the fast C-implementation of the STB-algorithm (<code><a href="#topic+SASquantile">SASquantile</a></code>),
i.e. in case <code>algo="C"</code>. One can compute and plot two types of plots (see argument 'type'). Simultaneous tolerance
bands (STB) are helpful in assessing the general distribution of a random variate, i.e. checking for departure from
the normality assumption. Outlying observations may also be detected using STB. Simultaneous tolerance intervals (STI)
are taylored for identification of extreme values (possible outliers). STI are a simplification of STB, where simultaneous
coverage is only required for extreme values of each simulation, i.e. an STB is constructed from the min and max values 
from all N simulations. This results in lower and upper bounds, which can be used in residuals plots for assessing outliers.
</p>
<p>One can choose between 3 methods for constructing the 100(1-alpha)% STB. The fastest one is the rank-based algorithm (&quot;rank&quot;), which
should only be applied for reasonably large number of simulations (rule of thumb: N&gt;5000). For fewer simulations,
the quantile-based algorithm is recommended. It exists in two flavours, a native R-implementation (&quot;R&quot;) and a pure C-implementation (&quot;C&quot;).
Both can be applied using parallel-processing (see arguments 'parallel' and 'Ncpu'). Only the R-implementation allows to specify
a specific quantile-definition other than <code>type=2</code> of function <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>


<h3>Value</h3>

<p>(stbVCA) object, a list with all information needed to create the QQ-plot with ~100(1-alpha)% STB.
</p>


<h3>Author(s)</h3>

<p>Andre Schuetzenmeister <a href="mailto:andre.schuetzenmeister@roche.com">andre.schuetzenmeister@roche.com</a>
</p>


<h3>References</h3>

<p>Schuetzenmeister, A. and Piepho, H.P. (2012). Residual analysis of linear mixed models using a simulation approach.
Computational Statistics and Data Analysis, 56, 1405-1416
</p>
<p>Schuetzenmeister, A., Jensen, U., Piepho, H.P., 2012. Checking the assumptions of normality and homoscedasticity in 
the general linear model using diagnostic plots. Communications in Statistics-Simulation and Computation 41, 141-154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSTB">getSTB</a></code>, <code><a href="#topic+fastSTB">fastSTB</a></code>, <code><a href="#topic+rankSTB">rankSTB</a></code>
</p>
<p><code><a href="#topic+fastSTB">fastSTB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(VCA)
data(dataEP05A2_1)
fit &lt;- anovaVCA(y~day/run, dataEP05A2_1)
fit

# use studentized conditional residuals
stb.obj1 &lt;- stb(fit, term="cond", mode="student", N=1000)

# plot it again
plot(stb.obj1)

# now request also plotting the corresponding residual plot
# capture additional computation results which are invisibly 
# returned
stb.obj1 &lt;- plot(stb.obj1, type=3)

# use other type of legend in QQ-plot
plot(stb.obj1, stb.lpos="topleft")

# use random effects "day" and apply standardization
stb.obj2 &lt;- stb(fit, term="day", mode="stand", N=1000)
# plot it again
plot(stb.obj2)

# more complex example
data(Orthodont)
Ortho &lt;- Orthodont
Ortho$age2 &lt;- Ortho$age - 11
Ortho$Subject &lt;- factor(as.character(Ortho$Subject))
fit.Ortho &lt;- anovaMM(distance~Sex+Sex:age2+(Subject)+(Subject):age2-1, Ortho)

# studentized conditional residuals
stb.cr.stud &lt;- stb(fit.Ortho, term="cond", mode="stud", N=1000)

# same model fitted via REML (same covariance structure of random effects by
# constraining it to be diagonal)
fit.Ortho.reml1 &lt;- remlMM(distance~Sex*age2+(Subject)*age2, Ortho, cov=FALSE)

# allow block-diagonal covariance structure of random effects due to non-zero
# correlation between intercept and slope of random regression part,
# not 'cov=TRUE' is the default
fit.Ortho.reml2 &lt;- remlMM(distance~Sex*age2+(Subject)*age2, Ortho)
fit.Ortho.reml1
fit.Ortho.reml2

# covariance matrices of random effects 'G' differ
getMat(fit.Ortho.reml1, "G")[1:10, 1:10]
getMat(fit.Ortho.reml2, "G")[1:10, 1:10]

# therefore, (conditional) residuals differ
resid(fit.Ortho.reml1)
resid(fit.Ortho.reml2)

# therefore, STB differ

# studentized conditional residuals
system.time({
stb.cr.stud.reml1 &lt;- stb(fit.Ortho.reml1, term="cond", mode="stud", 
                         N=5000, Ncpu=2, seed=11) })
system.time({
stb.cr.stud.reml2 &lt;- stb(fit.Ortho.reml2, term="cond", mode="stud", 
                         N=5000, Ncpu=4, seed=11) })

# same seed-value should yield identical results
system.time({
stb.cr.stud.reml3 &lt;- stb(fit.Ortho.reml2, term="cond", mode="stud", 
                         N=5000, Ncpu=4, seed=11) })

par(mfrow=c(1,2))
plot(stb.cr.stud.reml2)
plot(stb.cr.stud.reml3)

# both type of plots side-by-side
plot(stb.cr.stud.reml2, type=3)

# and enabling identification of points
# identified elements in the 1st plot will
# be automatically added to the 2nd one
plot(stb.cr.stud.reml2, type=3, pick=TRUE)

# raw "day" random effects
stb.re.subj &lt;- stb(fit.Ortho, term="Subject", N=1000)

# identify points using the mouse
stb.re.subj &lt;- plot(stb.re.subj, pick=TRUE, type=3)

# now click on points

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
