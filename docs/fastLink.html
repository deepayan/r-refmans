<!DOCTYPE html><html lang="en"><head><title>Help for package fastLink</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastLink}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fastLink-package'><p>Fast Probabilistic Record Linkage with Missing Data</p></a></li>
<li><a href='#aggconfusion'><p>aggconfusion</p></a></li>
<li><a href='#aggregateEM'><p>Aggregate EM objects for use in 'summary.fastLink()'</p></a></li>
<li><a href='#blockData'><p>blockData</p></a></li>
<li><a href='#calcMoversPriors'><p>calcMoversPriors</p></a></li>
<li><a href='#clusterMatch'><p>clusterMatch</p></a></li>
<li><a href='#confusion'><p>Get confusion table for fastLink objects</p></a></li>
<li><a href='#countyfips'><p>County-level FIPS Codes</p></a></li>
<li><a href='#countyinflow'><p>County-level inflow rates by state</p></a></li>
<li><a href='#countyoutflow'><p>County-level outflow rates by state</p></a></li>
<li><a href='#dedupeMatches'><p>dedupeMatches</p></a></li>
<li><a href='#dfA'><p>Sample dataset A</p></a></li>
<li><a href='#dfB'><p>Sample dataset B</p></a></li>
<li><a href='#emlinklog'><p>emlinklog</p></a></li>
<li><a href='#emlinkMARmov'><p>emlinkMARmov</p></a></li>
<li><a href='#emlinkRS'><p>emlinkRS</p></a></li>
<li><a href='#fastLink'><p>fastLink</p></a></li>
<li><a href='#gammaCK2par'><p>gammaCK2par</p></a></li>
<li><a href='#gammaCKpar'><p>gammaCKpar</p></a></li>
<li><a href='#gammaKpar'><p>gammaKpar</p></a></li>
<li><a href='#gammaNUMCK2par'><p>gammaNUMCK2par</p></a></li>
<li><a href='#gammaNUMCKpar'><p>gammaNUMCKpar</p></a></li>
<li><a href='#getMatches'><p>getMatches</p></a></li>
<li><a href='#getPatterns'><p>getPatterns</p></a></li>
<li><a href='#getPosterior'><p>getPosterior</p></a></li>
<li><a href='#inspectEM'><p>inspectEM</p></a></li>
<li><a href='#matchesLink'><p>matchesLink</p></a></li>
<li><a href='#nameReweight'><p>nameReweight</p></a></li>
<li><a href='#plot.fastLink'><p>Plot matching patterns of the EM object by posterior probability of match</p></a></li>
<li><a href='#preprocText'><p>preprocText</p></a></li>
<li><a href='#print.inspectEM'><p>print.inspectEM</p></a></li>
<li><a href='#statefips'><p>State-level FIPS Codes</p></a></li>
<li><a href='#stateinflow'><p>State-level inflow rates by state</p></a></li>
<li><a href='#statemove'><p>In-state movers rates by state</p></a></li>
<li><a href='#stateoutflow'><p>State-level outflow rates by state</p></a></li>
<li><a href='#stringSubset'><p>stringSubset</p></a></li>
<li><a href='#summary.fastLink'><p>Get summaries of fastLink() objects</p></a></li>
<li><a href='#tableCounts'><p>tableCounts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Probabilistic Record Linkage with Missing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a Fellegi-Sunter probabilistic record linkage model that allows for missing data
    and the inclusion of auxiliary information. This includes functionalities to conduct a merge of two 
    datasets under the Fellegi-Sunter model using the Expectation-Maximization algorithm. In addition, 
    tools for preparing, adjusting, and summarizing data merges are included. The package implements methods 
    described in Enamorado, Fifield, and Imai (2019) &rdquo;Using a Probabilistic Model to Assist Merging of 
    Large-scale Administrative Records&rdquo; &lt;<a href="https://doi.org/10.1017%2FS0003055418000783">doi:10.1017/S0003055418000783</a>&gt; and is available 
    at <a href="https://imai.fas.harvard.edu/research/linkage.html">https://imai.fas.harvard.edu/research/linkage.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, parallel, foreach, doParallel, gtools, data.table,
stringdist, stringr, stringi, Rcpp (&ge; 0.12.7), adagio, dplyr,
plotrix, grDevices, graphics, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kosukeimai/fastLink/issues">https://github.com/kosukeimai/fastLink/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 06:16:45 UTC; tedenamorado</td>
</tr>
<tr>
<td>Author:</td>
<td>Ted Enamorado [aut, cre],
  Ben Fifield [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fastLink-package'>Fast Probabilistic Record Linkage with Missing Data</h2><span id='topic+fastLink-package'></span>

<h3>Description</h3>

<p><code>fastLink</code> implements methods developed by Enamorado, Fifield, and Imai (2018)
&rdquo;Using a Probabilistic Model to Assist Merging of Large-scale Administrative Records&rdquo;,
to probabilistically merge large datasets using the Fellegi-Sunter model
while allowing for missing data and the inclusion of auxiliary information.
The current version of this package conducts a merge of two datasets under
the Fellegi-Sunter model, using the Expectation-Maximization Algorithm. In addition,
tools for conducting and summarizing data merges are included.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado <a href="mailto:ted.enamorado@gmail.com">ted.enamorado@gmail.com</a>, Ben Fifield <a href="mailto:benfifield@gmail.com">benfifield@gmail.com</a>, and Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>Maintainer: Ted Enamorado <a href="mailto:ted.enamorado@gmail.com">ted.enamorado@gmail.com</a>
</p>


<h3>References</h3>

<p>Enamorado, Ted, Ben Fifield and Kosuke Imai. (2019) &quot;Using a Probabilistic Model to Assist Merging of
Large-scale Administrative Records.&quot; American Political Science Review. Vol. 113, No. 2. Available at <a href="https://imai.fas.harvard.edu/research/files/linkage.pdf">https://imai.fas.harvard.edu/research/files/linkage.pdf</a>.
</p>

<hr>
<h2 id='aggconfusion'>aggconfusion</h2><span id='topic+aggconfusion'></span>

<h3>Description</h3>

<p>Aggregate confusion tables from separate runs of fastLink() (UNDER DEVELOPMENT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggconfusion(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggconfusion_+3A_object">object</code></td>
<td>
<p>A list of confusion tables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'aggconfusion()' returns two tables - one calculating the confusion table, and another
calculating a series of additional summary statistics.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='aggregateEM'>Aggregate EM objects for use in 'summary.fastLink()'</h2><span id='topic+aggregateEM'></span>

<h3>Description</h3>

<p><code>aggregateEM</code> aggregates EM objects for easy processing by 'summary.fastLink()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateEM(em.list, within.geo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregateEM_+3A_em.list">em.list</code></td>
<td>
<p>A list of 'fastLink' or 'fastLink.EM' objects that should be aggregate
in 'summary.fastLink()'</p>
</td></tr>
<tr><td><code id="aggregateEM_+3A_within.geo">within.geo</code></td>
<td>
<p>A vector of booleans corresponding to whether each object in 'em.list'
is a within-geography match or an across-geography match. Should be of equal length to
'em.list'. Default is NULL (assumes all are within-geography matches).</p>
</td></tr>
</table>

<hr>
<h2 id='blockData'>blockData</h2><span id='topic+blockData'></span>

<h3>Description</h3>

<p>Contains functionalities for blocking two data sets on one or more variables prior to
conducting a merge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockData(dfA, dfB, varnames, window.block, window.size,
kmeans.block, nclusters, iter.max, n.cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockData_+3A_dfa">dfA</code></td>
<td>
<p>Dataset A - to be matched to Dataset B</p>
</td></tr>
<tr><td><code id="blockData_+3A_dfb">dfB</code></td>
<td>
<p>Dataset B - to be matched to Dataset A</p>
</td></tr>
<tr><td><code id="blockData_+3A_varnames">varnames</code></td>
<td>
<p>A vector of variable names to use for blocking.
Must be present in both dfA and dfB</p>
</td></tr>
<tr><td><code id="blockData_+3A_window.block">window.block</code></td>
<td>
<p>A vector of variable names indicating that the variable should be
blocked using windowing blocking. Must be present in varnames.</p>
</td></tr>
<tr><td><code id="blockData_+3A_window.size">window.size</code></td>
<td>
<p>The size of the window for window blocking. Default is 1
(observations +/- 1 on the specified variable will be blocked together).</p>
</td></tr>
<tr><td><code id="blockData_+3A_kmeans.block">kmeans.block</code></td>
<td>
<p>A vector of variable names indicating that the variable should be
blocked using k-means blocking. Must be present in varnames.</p>
</td></tr>
<tr><td><code id="blockData_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters to create with k-means. Default value is the
number of clusters where the average cluster size is 100,000 observations.</p>
</td></tr>
<tr><td><code id="blockData_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations for the k-means algorithm to run. Default is 5000</p>
</td></tr>
<tr><td><code id="blockData_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an entry for each block. Each list entry contains two vectors &mdash; one with the indices indicating the block members in dataset A,
and another containing the indices indicating the block members in dataset B.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
block_out &lt;- blockData(dfA, dfB, varnames = c("city", "birthyear"))

## End(Not run)

</code></pre>

<hr>
<h2 id='calcMoversPriors'>calcMoversPriors</h2><span id='topic+calcMoversPriors'></span>

<h3>Description</h3>

<p>calcMoversPriors calculates prior estimates of in-state and
cross-state movers rates from the IRS SOI Migration data,
which can be used to improve the accuracy of the EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMoversPriors(geo.a, geo.b, year.start, year.end,
county, state.a, state.b, matchrate.lambda, remove.instate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMoversPriors_+3A_geo.a">geo.a</code></td>
<td>
<p>The state code (if state = TRUE) or county name
(if state = FALSE) for the earlier of the two voter files.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_geo.b">geo.b</code></td>
<td>
<p>The state code (if state = TRUE) or county name
(if state = FALSE) for the later of the two voter files.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_year.start">year.start</code></td>
<td>
<p>The year of the voter file for geography A.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_year.end">year.end</code></td>
<td>
<p>The year of the voter file for geography B.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_county">county</code></td>
<td>
<p>Whether prior is being calculated on the county or state level.
Default is FALSE (for a state-level calculation).</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_state.a">state.a</code></td>
<td>
<p>If <code>county = TRUE</code> (indicating a county-level match),
the state code of <code>geo.a</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_state.b">state.b</code></td>
<td>
<p>If <code>county = TRUE</code> (indicating a county-level match),
the state code of <code>geo.b</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_matchrate.lambda">matchrate.lambda</code></td>
<td>
<p>If TRUE, then returns the match rate for lambda
(the expected share of observations in dataset A that can be found in
dataset B). If FALSE, then returns the expected share of matches across
all pairwise comparisons of datasets A and B. Default is FALSE</p>
</td></tr>
<tr><td><code id="calcMoversPriors_+3A_remove.instate">remove.instate</code></td>
<td>
<p>If TRUE, then for calculating cross-state movers rates
assumes that successful matches have been subsetted out. The interpretation
of the prior is then the match rate conditional on being an out-of-state or
county mover. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calcMoversPriors</code> returns a list with estimates of the expected
match rate, and of the expected in-state movers rate when matching within-state.
</p>


<h3>Author(s)</h3>

<p>Ben Fifield &lt;benfifield@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calcMoversPriors(geo.a = "CA", geo.b = "CA", year.start = 2014, year.end = 2015)

</code></pre>

<hr>
<h2 id='clusterMatch'>clusterMatch</h2><span id='topic+clusterMatch'></span>

<h3>Description</h3>

<p>Creates properly sized clusters for matching, using either
alphabetical or word embedding clustering. If using word embedding,
the function first creates a word embedding out of the provided
vectors, and then runs PCA on the matrix. It then takes the first
<code>k</code> dimensions (where <code>k</code> is provided by the user) and
k-means is run on that matrix to get the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterMatch(vecA, vecB, nclusters, max.n, word.embed, min.var, iter.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterMatch_+3A_veca">vecA</code></td>
<td>
<p>The character vector from dataset A</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_vecb">vecB</code></td>
<td>
<p>The character vector from dataset B</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_nclusters">nclusters</code></td>
<td>
<p>The number of clusters to create from the provided data. Either
nclusters = NULL or max.n = NULL.</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_max.n">max.n</code></td>
<td>
<p>The maximum size of either dataset A or dataset B in
the largest cluster. Either nclusters = NULL or max.n = NULL</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_word.embed">word.embed</code></td>
<td>
<p>Whether to use word embedding clustering. Default is FALSE.</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_min.var">min.var</code></td>
<td>
<p>The minimum amount of explained variance (maximum = 1) a
PCA dimension can provide in order to be included in k-means clustering when
using word embedding. Default is .20.</p>
</td></tr>
<tr><td><code id="clusterMatch_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations for the k-means algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>clusterMatch</code> returns a list of length 3:
</p>
<table role = "presentation">
<tr><td><code>clusterA</code></td>
<td>
<p>The cluster assignments for dataset A</p>
</td></tr>
<tr><td><code>clusterB</code></td>
<td>
<p>The cluster assignments for dataset B</p>
</td></tr>
<tr><td><code>n.clusters</code></td>
<td>
<p>The number of clusters created</p>
</td></tr>
<tr><td><code>kmeans</code></td>
<td>
<p>The k-means object output.</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>The PCA object output.</p>
</td></tr>
<tr><td><code>dims.pca</code></td>
<td>
<p>The number of dimensions from PCA used for the k-means clustering.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Fifield &lt;benfifield@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(samplematch)
cl &lt;- clusterMatch(dfA$firstname, dfB$firstname, nclusters = 3)
</code></pre>

<hr>
<h2 id='confusion'>Get confusion table for fastLink objects</h2><span id='topic+confusion'></span>

<h3>Description</h3>

<p>Calculate confusion table after running fastLink().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusion(object, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confusion_+3A_object">object</code></td>
<td>
<p>A 'fastLink' object or list of fastLink objects. Can only be run if 'return.all = TRUE' in 'fastLink().'</p>
</td></tr>
<tr><td><code id="confusion_+3A_threshold">threshold</code></td>
<td>
<p>The matching threshold above which a pair is a true match. Default is .85</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'confusion()' returns two tables - one calculating the confusion table, and another
calculating a series of additional summary statistics.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 out &lt;- fastLink(
 dfA = dfA, dfB = dfB,
 varnames = c("firstname", "middlename", "lastname"),
 stringdist.match = c("firstname", "middlename", "lastname"),
 partial.match = c("firstname", "lastname", "streetname"),
 return.all = TRUE)

 ct &lt;- confusion(out)

## End(Not run)

</code></pre>

<hr>
<h2 id='countyfips'>County-level FIPS Codes</h2><span id='topic+countyfips'></span>

<h3>Description</h3>

<p>This data maps county names to FIPS codes for
use in calculating prior movers rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countyfips
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 3235 observations.
</p>

<hr>
<h2 id='countyinflow'>County-level inflow rates by state</h2><span id='topic+countyinflow'></span>

<h3>Description</h3>

<p>This data compiles and cleans county-level
movers inflow rates by county, from the IRS
Statistics on Income dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countyinflow
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 423752 observations.
</p>

<hr>
<h2 id='countyoutflow'>County-level outflow rates by state</h2><span id='topic+countyoutflow'></span>

<h3>Description</h3>

<p>This data compiles and cleans county-level
movers outflow rates by county, from the IRS
Statistics on Income dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countyoutflow
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 424475 observations.
</p>

<hr>
<h2 id='dedupeMatches'>dedupeMatches</h2><span id='topic+dedupeMatches'></span>

<h3>Description</h3>

<p>Dedupe matched dataframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dedupeMatches(matchesA, matchesB, EM,
matchesLink, patterns, linprog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dedupeMatches_+3A_matchesa">matchesA</code></td>
<td>
<p>A dataframe of the matched observations in
dataset A, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="dedupeMatches_+3A_matchesb">matchesB</code></td>
<td>
<p>A dataframe of the matched observations in
dataset B, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="dedupeMatches_+3A_em">EM</code></td>
<td>
<p>The EM object from <code>emlinkMARmov()</code></p>
</td></tr>
<tr><td><code id="dedupeMatches_+3A_matcheslink">matchesLink</code></td>
<td>
<p>The output from <code>matchesLink()</code></p>
</td></tr>
<tr><td><code id="dedupeMatches_+3A_patterns">patterns</code></td>
<td>
<p>The output from <code>getPatterns()</code>.</p>
</td></tr>
<tr><td><code id="dedupeMatches_+3A_linprog">linprog</code></td>
<td>
<p>Whether to implement Winkler's linear programming solution to the deduplication
problem. Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dedupeMatches()</code> returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>matchesA</code></td>
<td>
<p>A deduped version of matchesA</p>
</td></tr>
<tr><td><code>matchesB</code></td>
<td>
<p>A deduped version of matchesB</p>
</td></tr>
<tr><td><code>EM</code></td>
<td>
<p>A deduped version of the EM object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='dfA'>Sample dataset A</h2><span id='topic+dfA'></span>

<h3>Description</h3>

<p>This data is a randomized and anonymized sample dataset
to display features of fastLink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfA
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 500 observations.
</p>

<hr>
<h2 id='dfB'>Sample dataset B</h2><span id='topic+dfB'></span>

<h3>Description</h3>

<p>This data is a randomized and anonymized sample dataset
to display features of fastLink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfB
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 350 observations.
</p>

<hr>
<h2 id='emlinklog'>emlinklog</h2><span id='topic+emlinklog'></span>

<h3>Description</h3>

<p>Expectation-Maximization algorithm for Record Linkage 
allowing for dependencies across linkage fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emlinklog(patterns, nobs.a, nobs.b, p.m, p.gamma.j.m, p.gamma.j.u,
iter.max, tol, varnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emlinklog_+3A_patterns">patterns</code></td>
<td>
<p>table that holds the counts for each unique agreement
pattern. This object is produced by the function: tableCounts.</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_nobs.a">nobs.a</code></td>
<td>
<p>Number of observations in dataset A</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_nobs.b">nobs.b</code></td>
<td>
<p>Number of observations in dataset B</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_p.m">p.m</code></td>
<td>
<p>probability of finding a match. Default is 0.1</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_p.gamma.j.m">p.gamma.j.m</code></td>
<td>
<p>probability that conditional of being in the matched set we observed a specific agreement pattern.</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_p.gamma.j.u">p.gamma.j.u</code></td>
<td>
<p>probability that conditional of being in the non-matched set we observed a specific agreement pattern.</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_iter.max">iter.max</code></td>
<td>
<p>Max number of iterations. Default is 5000</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance. Default is 1e-05</p>
</td></tr>
<tr><td><code id="emlinklog_+3A_varnames">varnames</code></td>
<td>
<p>The vector of variable names used for matching. Automatically provided if using <code>fastLink()</code> wrapper. Used for
clean visualization of EM results in summary functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>emlinklog</code> returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>zeta.j</code></td>
<td>
<p>The posterior match probabilities for each unique pattern.</p>
</td></tr>
<tr><td><code>p.m</code></td>
<td>
<p>The probability of finding a match.</p>
</td></tr>
<tr><td><code>p.u</code></td>
<td>
<p>The probability of finding a non-match.</p>
</td></tr>
<tr><td><code>p.gamma.j.m</code></td>
<td>
<p>The probability of observing a particular agreement pattern conditional on being in the set of matches.</p>
</td></tr>
<tr><td><code>p.gamma.j.u</code></td>
<td>
<p>The probability of observing a particular agreement pattern conditional on being in the set of non-matches.</p>
</td></tr>
<tr><td><code>patterns.w</code></td>
<td>
<p>Counts of the agreement patterns observed, along with the Felligi-Sunter Weights.</p>
</td></tr>
<tr><td><code>iter.converge</code></td>
<td>
<p>The number of iterations it took the EM algorithm to converge.</p>
</td></tr>
<tr><td><code>nobs.a</code></td>
<td>
<p>The number of observations in dataset A.</p>
</td></tr>
<tr><td><code>nobs.b</code></td>
<td>
<p>The number of observations in dataset B.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Benjamin Fifield
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Calculate gammas
g1 &lt;- gammaCKpar(dfA$firstname, dfB$firstname)
g2 &lt;- gammaCKpar(dfA$middlename, dfB$middlename)
g3 &lt;- gammaCKpar(dfA$lastname, dfB$lastname)
g4 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## Run EM
em.log &lt;- emlinklog(tc, nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## End(Not run)

</code></pre>

<hr>
<h2 id='emlinkMARmov'>emlinkMARmov</h2><span id='topic+emlinkMARmov'></span>

<h3>Description</h3>

<p>Expectation-Maximization algorithm for Record Linkage under the
Missing at Random (MAR) assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emlinkMARmov(patterns, nobs.a, nobs.b, p.m, iter.max,
tol, p.gamma.k.m, p.gamma.k.u, prior.lambda, w.lambda,
prior.pi, w.pi, address.field, gender.field, varnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emlinkMARmov_+3A_patterns">patterns</code></td>
<td>
<p>table that holds the counts for each unique agreement
pattern. This object is produced by the function: tableCounts.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_nobs.a">nobs.a</code></td>
<td>
<p>Number of observations in dataset A</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_nobs.b">nobs.b</code></td>
<td>
<p>Number of observations in dataset B</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_p.m">p.m</code></td>
<td>
<p>probability of finding a match. Default is 0.1</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_iter.max">iter.max</code></td>
<td>
<p>Max number of iterations. Default is 5000</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance. Default is 1e-05</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_p.gamma.k.m">p.gamma.k.m</code></td>
<td>
<p>probability that conditional of being in the matched set we observed a specific agreement value for field k.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_p.gamma.k.u">p.gamma.k.u</code></td>
<td>
<p>probability that conditional of being in the non-matched set we observed a specific agreement value for field k.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_prior.lambda">prior.lambda</code></td>
<td>
<p>The prior probability of finding a match, derived from auxiliary data.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_w.lambda">w.lambda</code></td>
<td>
<p>How much weight to give the prior on lambda versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior)</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_prior.pi">prior.pi</code></td>
<td>
<p>The prior probability of the address field not matching, conditional on being in the matched set. To be used when the
share of movers in the population is known with some certainty.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_w.pi">w.pi</code></td>
<td>
<p>How much weight to give the prior on pi versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior)</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_address.field">address.field</code></td>
<td>
<p>Boolean indicators for whether a given field is an address field. Default is NULL (FALSE for all fields).
Address fields should be set to TRUE while non-address fields are set to FALSE if provided.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_gender.field">gender.field</code></td>
<td>
<p>Boolean indicators for whether a given field is for gender. If so, exact match is conducted on gender.
Default is NULL (FALSE for all fields). The one gender field should be set to TRUE while all other fields are set to FALSE if provided.</p>
</td></tr>
<tr><td><code id="emlinkMARmov_+3A_varnames">varnames</code></td>
<td>
<p>The vector of variable names used for matching. Automatically provided if using <code>fastLink()</code> wrapper. Used for
clean visualization of EM results in summary functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>emlinkMARmov</code> returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>zeta.j</code></td>
<td>
<p>The posterior match probabilities for each unique pattern.</p>
</td></tr>
<tr><td><code>p.m</code></td>
<td>
<p>The probability of a pair matching.</p>
</td></tr>
<tr><td><code>p.u</code></td>
<td>
<p>The probability of a pair not matching.</p>
</td></tr>
<tr><td><code>p.gamma.k.m</code></td>
<td>
<p>The matching probability for a specific matching field.</p>
</td></tr>
<tr><td><code>p.gamma.k.u</code></td>
<td>
<p>The non-matching probability for a specific matching field.</p>
</td></tr>
<tr><td><code>p.gamma.j.m</code></td>
<td>
<p>The probability that a pair is in the matched set given a particular agreement pattern.</p>
</td></tr>
<tr><td><code>p.gamma.j.u</code></td>
<td>
<p>The probability that a pair is in the unmatched set given a particular agreement pattern.</p>
</td></tr>
<tr><td><code>patterns.w</code></td>
<td>
<p>Counts of the agreement patterns observed, along with the Felligi-Sunter Weights.</p>
</td></tr>
<tr><td><code>iter.converge</code></td>
<td>
<p>The number of iterations it took the EM algorithm to converge.</p>
</td></tr>
<tr><td><code>nobs.a</code></td>
<td>
<p>The number of observations in dataset A.</p>
</td></tr>
<tr><td><code>nobs.b</code></td>
<td>
<p>The number of observations in dataset B.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Calculate gammas
g1 &lt;- gammaCKpar(dfA$firstname, dfB$firstname)
g2 &lt;- gammaCKpar(dfA$middlename, dfB$middlename)
g3 &lt;- gammaCKpar(dfA$lastname, dfB$lastname)
g4 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## Run EM
em &lt;- emlinkMARmov(tc, nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## End(Not run)

</code></pre>

<hr>
<h2 id='emlinkRS'>emlinkRS</h2><span id='topic+emlinkRS'></span>

<h3>Description</h3>

<p>Calculates Felligi-Sunter weights and posterior zeta probabilities
for matching patterns observed in a larger population that are
not present in a sub-sample used to estimate the EM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emlinkRS(patterns.out, em.out, nobs.a, nobs.b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emlinkRS_+3A_patterns.out">patterns.out</code></td>
<td>
<p>The output from 'tableCounts()' or 'emlinkMARmov()' (run on full dataset),
containing all observed matching patterns in the full sample and the number of times that pattern
is observed.</p>
</td></tr>
<tr><td><code id="emlinkRS_+3A_em.out">em.out</code></td>
<td>
<p>The output from 'emlinkMARmov()', an EM object estimated
on a smaller random sample to apply to counts from a larger sample</p>
</td></tr>
<tr><td><code id="emlinkRS_+3A_nobs.a">nobs.a</code></td>
<td>
<p>Total number of observations in dataset A</p>
</td></tr>
<tr><td><code id="emlinkRS_+3A_nobs.b">nobs.b</code></td>
<td>
<p>Total number of observations in dataset B</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>emlinkMARmov</code> returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>zeta.j</code></td>
<td>
<p>The posterior match probabilities for each unique pattern.</p>
</td></tr>
<tr><td><code>p.m</code></td>
<td>
<p>The posterior probability of a pair matching.</p>
</td></tr>
<tr><td><code>p.u</code></td>
<td>
<p>The posterior probability of a pair not matching.</p>
</td></tr>
<tr><td><code>p.gamma.k.m</code></td>
<td>
<p>The posterior of the matching probability for a specific matching field.</p>
</td></tr>
<tr><td><code>p.gamma.k.u</code></td>
<td>
<p>The posterior of the non-matching probability for a specific matching field.</p>
</td></tr>
<tr><td><code>p.gamma.j.m</code></td>
<td>
<p>The posterior probability that a pair is in the matched set given a particular agreement pattern.</p>
</td></tr>
<tr><td><code>p.gamma.j.u</code></td>
<td>
<p>The posterior probability that a pair is in the unmatched set given a particular agreement pattern.</p>
</td></tr>
<tr><td><code>patterns.w</code></td>
<td>
<p>Counts of the agreement patterns observed, along with the Felligi-Sunter Weights.</p>
</td></tr>
<tr><td><code>iter.converge</code></td>
<td>
<p>The number of iterations it took the EM algorithm to converge.</p>
</td></tr>
<tr><td><code>nobs.a</code></td>
<td>
<p>The number of observations in dataset A.</p>
</td></tr>
<tr><td><code>nobs.b</code></td>
<td>
<p>The number of observations in dataset B.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## -------------
## Run on subset
## -------------
dfA.s &lt;- dfA[sample(1:nrow(dfA), 50),]; dfB.s &lt;- dfB[sample(1:nrow(dfB), 50),]

## Calculate gammas
g1 &lt;- gammaCKpar(dfA.s$firstname, dfB.s$firstname)
g2 &lt;- gammaCKpar(dfA.s$middlename, dfB.s$middlename)
g3 &lt;- gammaCKpar(dfA.s$lastname, dfB.s$lastname)
g4 &lt;- gammaKpar(dfA.s$birthyear, dfB.s$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA.s), nobs.b = nrow(dfB.s))

## Run EM
em &lt;- emlinkMAR(tc, nobs.a = nrow(dfA.s), nobs.b = nrow(dfB.s))

## ------------------
## Apply to full data
## ------------------

## Calculate gammas
g1 &lt;- gammaCKpar(dfA$firstname, dfB$firstname)
g2 &lt;- gammaCKpar(dfA$middlename, dfB$middlename)
g3 &lt;- gammaCKpar(dfA$lastname, dfB$lastname)
g4 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))

em.full &lt;- emlinkRS(tc, em, nrow(dfA), nrow(dfB)

## End(Not run)

</code></pre>

<hr>
<h2 id='fastLink'>fastLink</h2><span id='topic+fastLink'></span>

<h3>Description</h3>

<p>Run the fastLink algorithm to probabilistically match
two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastLink(dfA, dfB, varnames, stringdist.match,
stringdist.method, numeric.match, partial.match,
cut.a, cut.p, jw.weight,
cut.a.num, cut.p.num,
priors.obj, w.lambda, w.pi,
address.field, gender.field, estimate.only, em.obj,
dedupe.matches, linprog.dedupe,
reweight.names, firstname.field, cond.indep,
n.cores, tol.em, threshold.match, return.all, return.df, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastLink_+3A_dfa">dfA</code></td>
<td>
<p>Dataset A - to be matched to Dataset B</p>
</td></tr>
<tr><td><code id="fastLink_+3A_dfb">dfB</code></td>
<td>
<p>Dataset B - to be matched to Dataset A</p>
</td></tr>
<tr><td><code id="fastLink_+3A_varnames">varnames</code></td>
<td>
<p>A vector of variable names to use for matching.
Must be present in both dfA and dfB</p>
</td></tr>
<tr><td><code id="fastLink_+3A_stringdist.match">stringdist.match</code></td>
<td>
<p>A vector of variable names indicating
which variables should use string distance matching. Must be a subset of
'varnames' and must not be present in 'numeric.match'.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_stringdist.method">stringdist.method</code></td>
<td>
<p>String distance method for calculating similarity, options are: &quot;jw&quot; Jaro-Winkler (Default), &quot;dl&quot; Damerau-Levenshtein, &quot;jaro&quot; Jaro, and &quot;lv&quot; Edit</p>
</td></tr>
<tr><td><code id="fastLink_+3A_numeric.match">numeric.match</code></td>
<td>
<p>A vector of variable names indicating which variables should use numeric matching.
Must be a subset of 'varnames' and must not be present in 'stringdist.match'.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_partial.match">partial.match</code></td>
<td>
<p>A vector of variable names indicating whether to include
a partial matching category for the string distances. Must be a subset of 'varnames'
and 'stringdist.match'.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full string-distance match, ranging between 0 and 1. Default is 0.94</p>
</td></tr>
<tr><td><code id="fastLink_+3A_cut.p">cut.p</code></td>
<td>
<p>Lower bound for partial string-distance match, ranging between 0 and 1. Default is 0.88</p>
</td></tr>
<tr><td><code id="fastLink_+3A_jw.weight">jw.weight</code></td>
<td>
<p>Parameter that describes the importance of the first characters of a string (only needed if stringdist.method = &quot;jw&quot;). Default is .10</p>
</td></tr>
<tr><td><code id="fastLink_+3A_cut.a.num">cut.a.num</code></td>
<td>
<p>Lower bound for full numeric match. Default is 1</p>
</td></tr>
<tr><td><code id="fastLink_+3A_cut.p.num">cut.p.num</code></td>
<td>
<p>Lower bound for partial numeric match. Default is 2.5</p>
</td></tr>
<tr><td><code id="fastLink_+3A_priors.obj">priors.obj</code></td>
<td>
<p>A list containing priors for auxiliary movers information,
as output from calcMoversPriors(). Default is NULL</p>
</td></tr>
<tr><td><code id="fastLink_+3A_w.lambda">w.lambda</code></td>
<td>
<p>How much weight to give the prior on lambda versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior).
Default is NULL (no prior information provided).</p>
</td></tr>
<tr><td><code id="fastLink_+3A_w.pi">w.pi</code></td>
<td>
<p>How much weight to give the prior on pi versus the data. Must range between 0 (no weight on prior) and 1 (weight fully on prior).
Default is NULL (no prior information provided).</p>
</td></tr>
<tr><td><code id="fastLink_+3A_address.field">address.field</code></td>
<td>
<p>The name of the address field. To be used when 'pi.prior' is included in 'priors.obj'.
Default is NULL (no matching variables should have address prior applied). Must be present in 'varnames'.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_gender.field">gender.field</code></td>
<td>
<p>The name of the field indicating gender. If provided, the exact-matching gender prior is used in the EM algorithm.
Default is NULL (do not implement exact matching on gender). Must be present in 'varnames'.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_estimate.only">estimate.only</code></td>
<td>
<p>Whether to stop running the algorithm after the EM step (omitting getting the matched indices of dataset A and dataset B).
Only the EM object will be returned. Can be used when running the match on a random sample and applying to a larger dataset, or for out-of-sample
prediction of matches. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_em.obj">em.obj</code></td>
<td>
<p>An EM object from a prior run of 'fastLink' or 'emlinkMARmov'. Parameter estimates will be applied to the matching patterns
in 'dfA' and 'dfB'. If provided. 'estimate.only' is set to FALSE. Often provided when parameters have been
estimated on a smaller sample, and the user wants to apply them to the full dataset. Default is NULL (EM will be estimated from matching patterns in 'dfA' and 'dfB').</p>
</td></tr>
<tr><td><code id="fastLink_+3A_dedupe.matches">dedupe.matches</code></td>
<td>
<p>Whether to dedupe the set of matches returned by the algorithm. Default is TRUE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_linprog.dedupe">linprog.dedupe</code></td>
<td>
<p>If deduping matches, whether to use Winkler's linear programming solution to dedupe. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_reweight.names">reweight.names</code></td>
<td>
<p>Whether to reweight the posterior match probabilities by the frequency of individual first names. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_firstname.field">firstname.field</code></td>
<td>
<p>The name of the field indicating first name. Must be provided if reweight.names = TRUE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_cond.indep">cond.indep</code></td>
<td>
<p>Estimates for the parameters of interest are obtained from the Fellegi-Sunter model under conditional independence. Default is TRUE. 
If set to FALSE parameters estimates are obtained from a model that allows for dependencies across linkage fields.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_tol.em">tol.em</code></td>
<td>
<p>Convergence tolerance for the EM Algorithm. Default is 1e-04.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_threshold.match">threshold.match</code></td>
<td>
<p>A number between 0 and 1 indicating either the lower bound (if only one number provided) or the range of certainty that the
user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches,
while threshold.match = c(.85, .95) will return all pairs with posterior probability between .85 and .95 as matches.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_return.all">return.all</code></td>
<td>
<p>Whether to return the most likely match for each observation in dfA and dfB. Overrides user setting of <code>threshold.match</code> by setting
<code>threshold.match</code> to 0.0001, and automatically dedupes all matches. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_return.df">return.df</code></td>
<td>
<p>Whether to return the entire dataframe of dfA and dfB instead of just the indices. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fastLink_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print elapsed time for each step. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fastLink</code> returns a list of class 'fastLink' containing the following components if calculating matches:
</p>
<table role = "presentation">
<tr><td><code>matches</code></td>
<td>
<p>An nmatches X 2 matrix containing the indices of the successful matches in <code>dfA</code>
in the first column, and the indices of the corresponding successful matches in <code>dfB</code> in the
second column.</p>
</td></tr>
<tr><td><code>EM</code></td>
<td>
<p>A list with the output of the EM algorithm, which contains the exact matching
patterns and the associated posterior probabilities of a match for each matching pattern.</p>
</td></tr>
<tr><td><code>patterns</code></td>
<td>
<p>A matrix with the observed matching patterns for each successfully matched pair.</p>
</td></tr>
<tr><td><code>nobs.a</code></td>
<td>
<p>The number of observations in dataset A.</p>
</td></tr>
<tr><td><code>nobs.b</code></td>
<td>
<p>The number of observations in dataset B.</p>
</td></tr>
<tr><td><code>zeta.name</code></td>
<td>
<p>If reweighting by name, the posterior probability of a match for each match in dataset A and B.</p>
</td></tr>
</table>
<p>If only running the EM and not returning the matched indices, <code>fastLink</code> only returns the EM object.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fl.out &lt;- fastLink(dfA, dfB,
varnames = c("firstname", "lastname", "streetname", "birthyear"),
n.cores = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='gammaCK2par'>gammaCK2par</h2><span id='topic+gammaCK2par'></span>

<h3>Description</h3>

<p>Field comparisons for string variables. Two possible agreement patterns are considered:
0 total disagreement, 2 agreement.
The distance between strings is calculated using a Jaro-Winkler distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaCK2par(matAp, matBp, n.cores, cut.a, method, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaCK2par_+3A_matap">matAp</code></td>
<td>
<p>vector storing the comparison field in data set 1</p>
</td></tr>
<tr><td><code id="gammaCK2par_+3A_matbp">matBp</code></td>
<td>
<p>vector storing the comparison field in data set 2</p>
</td></tr>
<tr><td><code id="gammaCK2par_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
<tr><td><code id="gammaCK2par_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full match, ranging between 0 and 1. Default is 0.92</p>
</td></tr>
<tr><td><code id="gammaCK2par_+3A_method">method</code></td>
<td>
<p>String distance method, options are: &quot;jw&quot; Jaro-Winkler (Default), &quot;dl&quot; Damerau-Levenshtein, &quot;jaro&quot; Jaro, and &quot;lv&quot; Edit</p>
</td></tr>
<tr><td><code id="gammaCK2par_+3A_w">w</code></td>
<td>
<p>Parameter that describes the importance of the first characters of a string (only needed if method = &quot;jw&quot;). Default is .10</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gammaCK2par</code> returns a list with the indices corresponding to each
matching pattern, which can be fed directly into <code>tableCounts</code> and <code>matchesLink</code>.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1 &lt;- gammaCK2par(dfA$firstname, dfB$lastname)

## End(Not run)
</code></pre>

<hr>
<h2 id='gammaCKpar'>gammaCKpar</h2><span id='topic+gammaCKpar'></span>

<h3>Description</h3>

<p>Field comparisons for string variables. Three possible agreement patterns are considered:
0 total disagreement, 1 partial agreement, 2 agreement.
The distance between strings is calculated using a Jaro-Winkler distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaCKpar(matAp, matBp, n.cores, cut.a, cut.p, method, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaCKpar_+3A_matap">matAp</code></td>
<td>
<p>vector storing the comparison field in data set 1</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_matbp">matBp</code></td>
<td>
<p>vector storing the comparison field in data set 2</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full match, ranging between 0 and 1. Default is 0.92</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_cut.p">cut.p</code></td>
<td>
<p>Lower bound for partial match, ranging between 0 and 1. Default is 0.88</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_method">method</code></td>
<td>
<p>String distance method, options are: &quot;jw&quot; Jaro-Winkler (Default), &quot;dl&quot; Damerau-Levenshtein, &quot;jaro&quot; Jaro, and &quot;lv&quot; Edit</p>
</td></tr>
<tr><td><code id="gammaCKpar_+3A_w">w</code></td>
<td>
<p>Parameter that describes the importance of the first characters of a string (only needed if method = &quot;jw&quot;). Default is .10</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gammaCKpar</code> returns a list with the indices corresponding to each
matching pattern, which can be fed directly into <code>tableCounts</code> and <code>matchesLink</code>.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1 &lt;- gammaCKpar(dfA$firstname, dfB$lastname)

## End(Not run)

</code></pre>

<hr>
<h2 id='gammaKpar'>gammaKpar</h2><span id='topic+gammaKpar'></span>

<h3>Description</h3>

<p>Field comparisons: 0 disagreement, 2 total agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKpar(matAp, matBp, gender, n.cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKpar_+3A_matap">matAp</code></td>
<td>
<p>vector storing the comparison field in data set 1</p>
</td></tr>
<tr><td><code id="gammaKpar_+3A_matbp">matBp</code></td>
<td>
<p>vector storing the comparison field in data set 2</p>
</td></tr>
<tr><td><code id="gammaKpar_+3A_gender">gender</code></td>
<td>
<p>Whether the matching variable is gender. Will override
standard warnings of missingness/nonvariability. Default is FALSE.</p>
</td></tr>
<tr><td><code id="gammaKpar_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gammaKpar</code> returns a list with the indices corresponding to each
matching pattern, which can be fed directly into <code>tableCounts</code> and <code>matchesLink</code>.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## End(Not run)
</code></pre>

<hr>
<h2 id='gammaNUMCK2par'>gammaNUMCK2par</h2><span id='topic+gammaNUMCK2par'></span>

<h3>Description</h3>

<p>Field comparisons for numeric variables. Two possible agreement patterns are considered:
0 total disagreement, 2 agreement.
The distance between numbers is calculated using their absolute distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaNUMCK2par(matAp, matBp, n.cores, cut.a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaNUMCK2par_+3A_matap">matAp</code></td>
<td>
<p>vector storing the comparison field in data set 1</p>
</td></tr>
<tr><td><code id="gammaNUMCK2par_+3A_matbp">matBp</code></td>
<td>
<p>vector storing the comparison field in data set 2</p>
</td></tr>
<tr><td><code id="gammaNUMCK2par_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
<tr><td><code id="gammaNUMCK2par_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full match. Default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gammaNUMCK2par</code> returns a list with the indices corresponding to each
matching pattern, which can be fed directly into <code>tableCounts</code> and <code>matchesLink</code>.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1 &lt;- gammaNUMCK2par(dfA$birthyear, dfB$birthyear)

## End(Not run)
</code></pre>

<hr>
<h2 id='gammaNUMCKpar'>gammaNUMCKpar</h2><span id='topic+gammaNUMCKpar'></span>

<h3>Description</h3>

<p>Field comparisons for numeric variables. Three possible agreement patterns are considered:
0 total disagreement, 1 partial agreement, 2 agreement.
The distance between numbers is calculated using their absolute distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaNUMCKpar(matAp, matBp, n.cores, cut.a, cut.p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaNUMCKpar_+3A_matap">matAp</code></td>
<td>
<p>vector storing the comparison field in data set 1</p>
</td></tr>
<tr><td><code id="gammaNUMCKpar_+3A_matbp">matBp</code></td>
<td>
<p>vector storing the comparison field in data set 2</p>
</td></tr>
<tr><td><code id="gammaNUMCKpar_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
<tr><td><code id="gammaNUMCKpar_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full match. Default is 1</p>
</td></tr>
<tr><td><code id="gammaNUMCKpar_+3A_cut.p">cut.p</code></td>
<td>
<p>Lower bound for partial match. Default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gammaNUMCKpar</code> returns a list with the indices corresponding to each
matching pattern, which can be fed directly into <code>tableCounts</code> and <code>matchesLink</code>.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g1 &lt;- gammaNUMCKpar(dfA$birthyear, dfB$birthyear)

## End(Not run)
</code></pre>

<hr>
<h2 id='getMatches'>getMatches</h2><span id='topic+getMatches'></span>

<h3>Description</h3>

<p>Subset two data frames to the matches returned by <code>fastLink()</code>
or <code>matchesLink()</code>. Can also return a single deduped data frame
if dfA and dfB are identical and fl.out is of class 'fastLink.dedupe'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatches(dfA, dfB, fl.out, threshold.match, combine.dfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatches_+3A_dfa">dfA</code></td>
<td>
<p>Dataset A - matched to Dataset B by <code>fastLink()</code>.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_dfb">dfB</code></td>
<td>
<p>Dataset B - matches to Dataset A by <code>fastLink()</code>.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_fl.out">fl.out</code></td>
<td>
<p>Either the output from <code>fastLink()</code> or <code>matchesLink()</code>.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_threshold.match">threshold.match</code></td>
<td>
<p>A number between 0 and 1 indicating the lower bound that the
user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches.
Default is 0.85.</p>
</td></tr>
<tr><td><code id="getMatches_+3A_combine.dfs">combine.dfs</code></td>
<td>
<p>Whether to combine the two data frames being merged into a single data frame. If FALSE, two data frames are returned in a list. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getMatches()</code> returns a list of two data frames:
</p>
<table role = "presentation">
<tr><td><code>dfA.match</code></td>
<td>
<p>A subset of <code>dfA</code> subsetted down to the successful matches.</p>
</td></tr>
<tr><td><code>dfB.match</code></td>
<td>
<p>A subset of <code>dfB</code> subsetted down to the successful matches.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Fifield  &lt;benfifield@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fl.out &lt;- fastLink(dfA, dfB,
varnames = c("firstname", "lastname", "streetname", "birthyear"),
n.cores = 1)
ret &lt;- getMatches(dfA, dfB, fl.out)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPatterns'>getPatterns</h2><span id='topic+getPatterns'></span>

<h3>Description</h3>

<p>Get the full matching patterns for all matched pairs in dataset A and dataset B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPatterns(
  matchesA,
  matchesB,
  varnames,
  stringdist.match,
  numeric.match,
  partial.match,
  stringdist.method = "jw",
  cut.a = 0.92,
  cut.p = 0.88,
  jw.weight = 0.1,
  cut.a.num = 1,
  cut.p.num = 2.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPatterns_+3A_matchesa">matchesA</code></td>
<td>
<p>A dataframe of the matched observations in
dataset A, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_matchesb">matchesB</code></td>
<td>
<p>A dataframe of the matched observations in
dataset B, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_varnames">varnames</code></td>
<td>
<p>A vector of variable names to use for matching.
Must be present in both matchesA and matchesB.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_stringdist.match">stringdist.match</code></td>
<td>
<p>A vector of booleans, indicating whether to use
string distance matching when determining matching patterns on
each variable. Must be same length as varnames.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_numeric.match">numeric.match</code></td>
<td>
<p>A vector of booleans, indicating whether to use
numeric pairwise distance matching when determining matching patterns on
each variable. Must be same length as varnames.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_partial.match">partial.match</code></td>
<td>
<p>A vector of booleans, indicating whether to include
a partial matching category for the string distances. Must be same length
as varnames. Default is FALSE for all variables.</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_stringdist.method">stringdist.method</code></td>
<td>
<p>String distance method for calculating similarity, options are: &quot;jw&quot; Jaro-Winkler (Default), &quot;jaro&quot; Jaro, and &quot;lv&quot; Edit</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_cut.a">cut.a</code></td>
<td>
<p>Lower bound for full string-distance match, ranging between 0 and 1. Default is 0.92</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_cut.p">cut.p</code></td>
<td>
<p>Lower bound for partial string-distance match, ranging between 0 and 1. Default is 0.88</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_jw.weight">jw.weight</code></td>
<td>
<p>Parameter that describes the importance of the first characters of a string (only needed if stringdist.method = &quot;jw&quot;). Default is .10</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_cut.a.num">cut.a.num</code></td>
<td>
<p>Lower bound for full numeric match. Default is 1</p>
</td></tr>
<tr><td><code id="getPatterns_+3A_cut.p.num">cut.p.num</code></td>
<td>
<p>Lower bound for partial numeric match. Default is 2.5</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getPatterns()</code> returns a dataframe with a row for each matched pair,
where each column indicates the matching pattern for each matching variable.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='getPosterior'>getPosterior</h2><span id='topic+getPosterior'></span>

<h3>Description</h3>

<p>Get the posterior probability of a match for each matched pair of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPosterior(matchesA, matchesB, EM, patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPosterior_+3A_matchesa">matchesA</code></td>
<td>
<p>A dataframe of the matched observations in
dataset A, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_matchesb">matchesB</code></td>
<td>
<p>A dataframe of the matched observations in
dataset B, with all variables used to inform the match.</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_em">EM</code></td>
<td>
<p>The EM object from <code>emlinkMARmov()</code></p>
</td></tr>
<tr><td><code id="getPosterior_+3A_patterns">patterns</code></td>
<td>
<p>The output from <code>getPatterns()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getPosterior</code> returns the posterior probability of a match for each matched pair of observations
in matchesA and matchesB
</p>


<h3>Author(s)</h3>

<p>Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='inspectEM'>inspectEM</h2><span id='topic+inspectEM'></span>

<h3>Description</h3>

<p>Inspect EM objects to analyze successfully and
unsuccessfully matched patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspectEM(object, posterior.range, digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspectEM_+3A_object">object</code></td>
<td>
<p>The output from either <code>fastLink</code> or <code>emlinkMARmov</code>.</p>
</td></tr>
<tr><td><code id="inspectEM_+3A_posterior.range">posterior.range</code></td>
<td>
<p>The range of posterior probabilities to display.
Default is c(0.85, 1).</p>
</td></tr>
<tr><td><code id="inspectEM_+3A_digits">digits</code></td>
<td>
<p>How many digits to include in inspectEM dataframe. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inspectEM</code> returns a data frame with information
about patterns around the provided threshold.
</p>


<h3>Author(s)</h3>

<p>Ben Fifield &lt;bfifield@princeton.edu&gt;
</p>

<hr>
<h2 id='matchesLink'>matchesLink</h2><span id='topic+matchesLink'></span>

<h3>Description</h3>

<p>matchesLink produces two dataframes that store
all the pairs that share a pattern that conforms
to the an interval of the Fellegi-Sunter
weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchesLink(gammalist, nobs.a, nobs.b, em, thresh, n.cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchesLink_+3A_gammalist">gammalist</code></td>
<td>
<p>A list of objects produced by either gammaKpar or
gammaCKpar.</p>
</td></tr>
<tr><td><code id="matchesLink_+3A_nobs.a">nobs.a</code></td>
<td>
<p>number of observations in dataset 1</p>
</td></tr>
<tr><td><code id="matchesLink_+3A_nobs.b">nobs.b</code></td>
<td>
<p>number of observations in dataset 2</p>
</td></tr>
<tr><td><code id="matchesLink_+3A_em">em</code></td>
<td>
<p>parameters obtained from the Expectation-Maximization algorithm under the MAR assumption. These estimates are
produced by emlinkMARmov</p>
</td></tr>
<tr><td><code id="matchesLink_+3A_thresh">thresh</code></td>
<td>
<p>is the interval of posterior zeta values for the agreements that we want to examine closer. Ranges between 0 and 1.
Can be a vector of length 1 (from specified value to 1) or 2 (from first specified value to second specified value).</p>
</td></tr>
<tr><td><code id="matchesLink_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matchesLink</code> returns an nmatches X 2 matrix with the indices of the
matches rows in dataset A and dataset B.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Calculate gammas
g1 &lt;- gammaCKpar(dfA$firstname, dfB$firstname)
g2 &lt;- gammaCKpar(dfA$middlename, dfB$middlename)
g3 &lt;- gammaCKpar(dfA$lastname, dfB$lastname)
g4 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## Run EM
em &lt;- emlinkMAR(tc)

## Get matches
ml &lt;- matchesLink(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB),
em = em, thresh = .95)

## End(Not run)

</code></pre>

<hr>
<h2 id='nameReweight'>nameReweight</h2><span id='topic+nameReweight'></span>

<h3>Description</h3>

<p>Reweights posterior probabilities to account for observed frequency
of names. Downweights posterior probability of match if first name is common,
upweights if first name is uncommon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameReweight(dfA, dfB, EM, gammalist, matchesLink,
varnames, firstname.field, patterns, threshold.match, n.cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameReweight_+3A_dfa">dfA</code></td>
<td>
<p>The full version of dataset A that is being matched.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_dfb">dfB</code></td>
<td>
<p>The full version of dataset B that is being matched.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_em">EM</code></td>
<td>
<p>The EM object from <code>emlinkMARmov()</code></p>
</td></tr>
<tr><td><code id="nameReweight_+3A_gammalist">gammalist</code></td>
<td>
<p>The list of gamma objects calculated on the full
dataset that indicate matching patterns, which is fed into <code>tableCounts()</code>
and <code>matchesLink()</code>.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_matcheslink">matchesLink</code></td>
<td>
<p>The output from <code>matchesLink()</code>.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_varnames">varnames</code></td>
<td>
<p>A vector of variable names to use for matching.
Must be present in both matchesA and matchesB.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_firstname.field">firstname.field</code></td>
<td>
<p>A vector of booleans, indicating whether each field indicates
first name. TRUE if so, otherwise FALSE.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_patterns">patterns</code></td>
<td>
<p>The output from <code>getPatterns()</code>.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_threshold.match">threshold.match</code></td>
<td>
<p>A number between 0 and 1 indicating either the lower bound (if only one number provided) or the range of certainty that the
user wants to declare a match. For instance, threshold.match = .85 will return all pairs with posterior probability greater than .85 as matches,
while threshold.match = c(.85, .95) will return all pairs with posterior probability between .85 and .95 as matches.</p>
</td></tr>
<tr><td><code id="nameReweight_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nameReweight()</code> returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>zetaA</code></td>
<td>
<p>The reweighted zeta estimates for each matched element in dataset A.</p>
</td></tr>
<tr><td><code>zetaB</code></td>
<td>
<p>The reweighted zeta estimates for each matched element in dataset B.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt; and Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='plot.fastLink'>Plot matching patterns of the EM object by posterior probability of match</h2><span id='topic+plot.fastLink'></span>

<h3>Description</h3>

<p><code>plot.fastLink()</code> plots the matching patterns of the EM object,
ordering the matching patterns by the posterior probability of the match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastLink'
plot(x, posterior.range, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fastLink_+3A_x">x</code></td>
<td>
<p>Either a <code>fastLink</code> or <code>fastLink.EM</code> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.fastLink_+3A_posterior.range">posterior.range</code></td>
<td>
<p>The range of posterior probabilities to display.
Default is c(0.85, 1).</p>
</td></tr>
<tr><td><code id="plot.fastLink_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot.fastLink()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='preprocText'>preprocText</h2><span id='topic+preprocText'></span>

<h3>Description</h3>

<p>Preprocess text data such as names and addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocText(text, convert_text, tolower, soundex,
usps_address, remove_whitespace, remove_punctuation, convert_text_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preprocText_+3A_text">text</code></td>
<td>
<p>A vector of text data to convert.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_convert_text">convert_text</code></td>
<td>
<p>Whether to convert text to the desired encoding, where
the encoding is specified in the 'convert_text_to' argument. Default is
TRUE</p>
</td></tr>
<tr><td><code id="preprocText_+3A_tolower">tolower</code></td>
<td>
<p>Whether to normalize the text to be all lowercase. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_soundex">soundex</code></td>
<td>
<p>Whether to convert the field to the Census's soundex encoding.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_usps_address">usps_address</code></td>
<td>
<p>Whether to use USPS address standardization rules to clean address fields.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_remove_whitespace">remove_whitespace</code></td>
<td>
<p>Whether to remove leading and trailing whitespace, and to convert multiple
spaces to a single space. Default is TRUE.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_remove_punctuation">remove_punctuation</code></td>
<td>
<p>Whether to remove punctuation from a string. Default is TRUE.</p>
</td></tr>
<tr><td><code id="preprocText_+3A_convert_text_to">convert_text_to</code></td>
<td>
<p>Which encoding to use when converting text. Default is 'Latin-ASCII'.
Full list of encodings in the <code>stri_trans_list()</code> function in the <code>stringi</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>preprocText()</code> returns the preprocessed vector of text.
</p>


<h3>Author(s)</h3>

<p>Ben Fifield &lt;benfifield@gmail.com&gt;
</p>

<hr>
<h2 id='print.inspectEM'>print.inspectEM</h2><span id='topic+print.inspectEM'></span>

<h3>Description</h3>

<p>Print information from the EM algorithm to console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspectEM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.inspectEM_+3A_x">x</code></td>
<td>
<p>An <code>inspectEM</code> object</p>
</td></tr>
<tr><td><code id="print.inspectEM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>print.fastLink()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='statefips'>State-level FIPS Codes</h2><span id='topic+statefips'></span>

<h3>Description</h3>

<p>This data maps state names to FIPS codes for
use in calculating prior movers rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statefips
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 54 observations.
</p>

<hr>
<h2 id='stateinflow'>State-level inflow rates by state</h2><span id='topic+stateinflow'></span>

<h3>Description</h3>

<p>This data compiles and cleans state-level
movers inflow rates by state, from the IRS
Statistics on Income dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateinflow
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 11321 observations.
</p>

<hr>
<h2 id='statemove'>In-state movers rates by state</h2><span id='topic+statemove'></span>

<h3>Description</h3>

<p>This data collects in-state movers rates by state,
for imputation where within-county movers rates are
not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statemove
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 51 observations.
</p>

<hr>
<h2 id='stateoutflow'>State-level outflow rates by state</h2><span id='topic+stateoutflow'></span>

<h3>Description</h3>

<p>This data compiles and cleans state-level
movers outflow rates by state, from the IRS
Statistics on Income dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateoutflow
</code></pre>


<h3>Format</h3>

<p>A dataframe containing 11320 observations.
</p>

<hr>
<h2 id='stringSubset'>stringSubset</h2><span id='topic+stringSubset'></span>

<h3>Description</h3>

<p>Removes as candidate matches any observations with no close matches on
string-distance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringSubset(vecA, vecB, similarity.threshold, stringdist.method,
jw.weight, n.cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stringSubset_+3A_veca">vecA</code></td>
<td>
<p>A character or factor vector from dataset A</p>
</td></tr>
<tr><td><code id="stringSubset_+3A_vecb">vecB</code></td>
<td>
<p>A character or factor vector from dataset B</p>
</td></tr>
<tr><td><code id="stringSubset_+3A_similarity.threshold">similarity.threshold</code></td>
<td>
<p>Lower bound on string-distance measure for being considered a possible match.
If an observation has no possible matches above this threshold, it is discarded from the match. Default is 0.8.</p>
</td></tr>
<tr><td><code id="stringSubset_+3A_stringdist.method">stringdist.method</code></td>
<td>
<p>The method to use for calculating string-distance similarity. Possible values are
'jaro' (Jaro Distance), 'jw' (Jaro-Winkler), and 'lv' (Levenshtein). Default is 'jw'.</p>
</td></tr>
<tr><td><code id="stringSubset_+3A_jw.weight">jw.weight</code></td>
<td>
<p>Parameter that describes the importance of the first characters of a string (only needed if stringdist.method = &quot;jw&quot;). Default is .10.</p>
</td></tr>
<tr><td><code id="stringSubset_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two, where the both entries are a vector of indices to be included in the match from dataset A (entry 1) and dataset B (entry 2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
subset_out &lt;- stringSubset(dfA$firstname, dfB$lastname, n.cores = 1)
fl_out &lt;- fastLink(dfA[subset_out$dfA.block == 1,], dfB[subset_out$dfB.block == 1,],
varnames = c("firstname", "lastname", "streetname", "birthyear"), n.cores = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.fastLink'>Get summaries of fastLink() objects</h2><span id='topic+summary.fastLink'></span>

<h3>Description</h3>

<p><code>summary.fastLink()</code> calculates and outputs FDR, FNR, match counts, and match rates for
estimated matches from a fastLink() object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastLink'
summary(object, num.comparisons = 1,
thresholds = c(.95, .85, .75), weighted = TRUE, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fastLink_+3A_object">object</code></td>
<td>
<p>Either a single 'fastLink' or 'fastLink.EM' object, or a list of 'fastLink' or 'fastLink.EM' objects
to be aggregated together produced  by 'aggregateEM'.</p>
</td></tr>
<tr><td><code id="summary.fastLink_+3A_num.comparisons">num.comparisons</code></td>
<td>
<p>The number of comparisons attempted for each observation in the across-geography match step.
A correction factor to avoid multiple-counting. Default is NULL</p>
</td></tr>
<tr><td><code id="summary.fastLink_+3A_thresholds">thresholds</code></td>
<td>
<p>A vector of posterior probabilities to calculate the summary statistics.</p>
</td></tr>
<tr><td><code id="summary.fastLink_+3A_weighted">weighted</code></td>
<td>
<p>Whether to weight the cross-geography matches on FDR and FNR.</p>
</td></tr>
<tr><td><code id="summary.fastLink_+3A_digits">digits</code></td>
<td>
<p>How many digits to include in summary object. Default is 3.</p>
</td></tr>
<tr><td><code id="summary.fastLink_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>summary.fastLink()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='tableCounts'>tableCounts</h2><span id='topic+tableCounts'></span>

<h3>Description</h3>

<p>Count pairs with the same pattern in the cross product between two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableCounts(gammalist, nobs.a, nobs.b, n.cores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tableCounts_+3A_gammalist">gammalist</code></td>
<td>
<p>A list of objects produced by gammaKpar, gammaCK2par, or
gammaCKpar.</p>
</td></tr>
<tr><td><code id="tableCounts_+3A_nobs.a">nobs.a</code></td>
<td>
<p>number of observations in dataset 1</p>
</td></tr>
<tr><td><code id="tableCounts_+3A_nobs.b">nobs.b</code></td>
<td>
<p>number of observations in dataset 2</p>
</td></tr>
<tr><td><code id="tableCounts_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to parallelize over. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tableCounts</code> returns counts of all unique mathching patterns, which can be
fed directly into <code>emlinkMAR</code> to get posterior matching probabilities for each unique pattern.
</p>


<h3>Author(s)</h3>

<p>Ted Enamorado &lt;ted.enamorado@gmail.com&gt;, Ben Fifield &lt;benfifield@gmail.com&gt;, and Kosuke Imai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Calculate gammas
g1 &lt;- gammaCKpar(dfA$firstname, dfB$firstname)
g2 &lt;- gammaCKpar(dfA$middlename, dfB$middlename)
g3 &lt;- gammaCKpar(dfA$lastname, dfB$lastname)
g4 &lt;- gammaKpar(dfA$birthyear, dfB$birthyear)

## Run tableCounts
tc &lt;- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
