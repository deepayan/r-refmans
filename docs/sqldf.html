<!DOCTYPE html><html><head><title>Help for package sqldf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sqldf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#read.csv.sql'>
<p>Read File Filtered by SQL</p></a></li>
<li><a href='#sqldf'><p>SQL select on data frames</p></a></li>
<li><a href='#sqldf-package'>
<p>sqldf package overview</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-06-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Manipulate R Data Frames Using SQL</td>
</tr>
<tr>
<td>Author:</td>
<td>G. Grothendieck &lt;ggrothendieck@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>G. Grothendieck &lt;ggrothendieck@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The sqldf() function is typically passed a single argument which 
	is an SQL select statement where the table names are ordinary R data 
	frame names.  sqldf() transparently sets up a database, imports the 
	data frames into that database, performs the SQL select or other
	statement and returns the result using a heuristic to determine which 
	class to assign to each column of the returned data frame.  The sqldf() 
	or read.csv.sql() functions can also be used to read filtered files 
	into R even if the original files are larger than R itself can handle.
	'RSQLite', 'RH2', 'RMySQL' and 'RPostgreSQL' backends are supported.</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), gsubfn (&ge; 0.6), proto, RSQLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RH2, RMySQL, RPostgreSQL, svUnit, tcltk, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, chron</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ggrothendieck/sqldf/issues">https://github.com/ggrothendieck/sqldf/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ggrothendieck/sqldf">https://github.com/ggrothendieck/sqldf</a>,
<a href="https://groups.google.com/group/sqldf">https://groups.google.com/group/sqldf</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-06-28 00:38:13 UTC; Louis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-06-28 06:43:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='read.csv.sql'>
Read File Filtered by SQL
</h2><span id='topic+read.csv.sql'></span><span id='topic+read.csv2.sql'></span>

<h3>Description</h3>

<p>Read a file into R filtering it with an sql statement.  Only the filtered
portion is processed by R so that files larger than R can otherwise
handle can be accommodated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.csv.sql(file, sql = "select * from file", header = TRUE, sep = ",", 
row.names, eol, skip, filter, nrows, field.types, 
colClasses, dbname = tempfile(), drv = "SQLite", ...)
read.csv2.sql(file, sql = "select * from file", header = TRUE, sep = ";", 
row.names, eol, skip, filter, nrows, field.types,
colClasses, dbname = tempfile(), drv = "SQLite", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.csv.sql_+3A_file">file</code></td>
<td>

<p>A file path or a URL (beginning with <code>http://</code> or <code>ftp://</code>). If
the <code>filter</code> argument is used and no file is to be input to the filter
then <code>file</code> can be omitted, <code>NULL</code>, <code>NA</code> or <code>""</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_sql">sql</code></td>
<td>

<p>character string holding an SQL statement.  The table representing the
file should be referred to as <code>file</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_header">header</code></td>
<td>

<p>As in <code>read.csv</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_sep">sep</code></td>
<td>

<p>As in <code>read.csv</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_row.names">row.names</code></td>
<td>

<p>As in <code>read.csv</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_eol">eol</code></td>
<td>

<p>Character which ends line.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_skip">skip</code></td>
<td>

<p>Skip indicated number of lines in input file.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_filter">filter</code></td>
<td>

<p>If specified, this should be a shell/batch command that the input file is piped through.  For <code>read.csv2.sql</code> it is by default the following on non-Windows systems: <code>tr , .</code>.  This translates all commas in the file to dots. On Windows similar functionalty is provided but to do that using a vbscript file that is included with <code>sqldf</code> to emulate the <code>tr</code> command.  
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_nrows">nrows</code></td>
<td>

<p>Number of rows used to determine column types.  It defaults to 50.  Using 
<code>-1</code> causes it to use all rows for determining column types.
This argument is rarely needed.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_field.types">field.types</code></td>
<td>

<p>A list whose names are the column names and whose
contents are the SQLite types (not the R class names) of the
columns.  Specifying these types improves how fast it takes.
Unless speed is very important this argument is not normally used.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_colclasses">colClasses</code></td>
<td>
<p>As in <code>read.csv</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_dbname">dbname</code></td>
<td>

<p>As in <code>sqldf</code> except that the default is <code>tempfile()</code>.
Specifying <code>NULL</code> will put the database in memory which may improve speed
but will limit the size of the database by the available memory.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_drv">drv</code></td>
<td>

<p>This argument is ignored. 
Currently the only database SQLite supported by <code>read.csv.sql</code> and 
<code>read.csv2.sql</code> is SQLite.  
Note that the H2 database has a builtin SQL function,
<code>CSVREAD</code>, which can be used in place of <code>read.csv.sql</code>.
</p>
</td></tr>
<tr><td><code id="read.csv.sql_+3A_...">...</code></td>
<td>

<p>Passed to <code>sqldf</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads the indicated file into an sql database creating the database
if it does not already exist.  Then it applies the sql statement
returning the result as a data frame.  If the database did not exist
prior to this statement it is removed.  
</p>
<p>Note that it uses facilities of <code>SQLite</code> to read the file 
which are intended for speed and therefore
not as flexible as in R.  For example, it does not
recognize quoted fields as special but will regard the quotes as 
part of the field. See the
<code>sqldf</code> help for more information.
</p>
<p><code>read.csv2.sql</code> is like <code>read.csv.sql</code> except
the default <code>sep</code> is <code>";"</code> and the default <code>filter</code> translates
all commas in the file to decimal points (i.e. to dots).
</p>
<p>On Windows, if the <code>filter</code> argument is used and if Rtools is detected
in the registry then the Rtools bin directory is added to the search path
facilitating use of those tools without explicitly setting any the path.
</p>


<h3>Value</h3>

<p>If the sql statement is a select statement then a data frame
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# might need to specify eol= too depending on your system
write.csv(iris, "iris.csv", quote = FALSE, row.names = FALSE)
iris2 &lt;- read.csv.sql("iris.csv", 
	sql = "select * from file where Species = 'setosa' ")


## End(Not run)
</code></pre>

<hr>
<h2 id='sqldf'>SQL select on data frames</h2><span id='topic+sqldf'></span>

<h3>Description</h3>

<p>SQL select on data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sqldf(x, stringsAsFactors = FALSE,
   row.names = FALSE, envir = parent.frame(), 
   method = getOption("sqldf.method"),
   file.format = list(), dbname, drv = getOption("sqldf.driver"), 
   user, password = "", host = "localhost", port,
   dll = getOption("sqldf.dll"), connection = getOption("sqldf.connection"),
   verbose = isTRUE(getOption("sqldf.verbose")))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqldf_+3A_x">x</code></td>
<td>
<p>Character string representing an SQL select statement or
character vector whose components each represent a successive SQL
statement to be executed. 
The select statement syntax must conform to the particular database 
being used.  If x is missing then it establishes a connection
which subsequent sqldf statements access.  In that case the database
is not destroyed until the next sqldf statement with no x.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p> If <code>TRUE</code> then those columns output 
from the database as <code>"character"</code> are 
converted to <code>"factor"</code> if the heuristic is unable to determine 
the class.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_row.names">row.names</code></td>
<td>
<p>For <code>TRUE</code> the tables in the data base are given
a <code>row_names</code> column filled with the row names of the corresponding
data frames.  Note that in SQLite a special <code>rowid</code> (or equivalently
<code>oid</code> or <code>_rowid_</code>) is available in any case.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_envir">envir</code></td>
<td>
<p> The environment where the data frames representing the tables
are to be found.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_method">method</code></td>
<td>
<p>This argument is a list of two functions, keywords or character
vectors.  If the second component of the list 
is <code>NULL</code> (the default) then the first component 
of the list can be specified without wrapping it in a list. The
first component
specifies a transformation of the data frame output from the database
and the second specifies a transformation to each data frame that is 
passed to the data base just before it is read into the database.  
The second component is less frequently used.
If the first component is <code>NULL</code> or not
specified that it defaults to &quot;auto&quot;.  If the second component is <code>NULL</code>
or not specified then no transformation is performed on the input.
</p>
<p>The allowable keywords for the first components are (1) <code>"auto"</code> 
which is the default and automatically assigns the class of each
column using the heuristic described later, (2) <code>"auto.factor"</code> which is
the same as <code>"auto"</code> but does not assign <code>"factor"</code> and 
<code>"ordered"</code> classes,
(3) <code>"raw"</code> or <code>NULL</code> which means use
whatever classes are returned by the database with no automatic processing
and (4) <code>"name__class"</code> which
means that columns names that end in <code>__class</code>
with two underscores
where <code>class</code> is an R class (such as <code>Date</code>) are converted to
that class and the <code>__class</code> portion is removed from the column name.
For example, 
<code>sqldf("select a as x__Date from DF", method = "name__class")</code> 
would cause
column <code>a</code> to be coerced to class <code>Date</code> and have the column name 
<code>x</code>.
The first component of <code>method</code>
can also be a character vector of classes to assign to the
returned data.frame.  The example just given could alternately be implemented
using 
<code>sqldf("select a as x from DF", method = "Date")</code> 
Note that when <code>Date</code> is used in this way it assumes the database
contains the number of days since January 1, 1970.  If the date is in
the format <code>yyyy-mm-dd</code> then use <code>Date2</code> as the class.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_file.format">file.format</code></td>
<td>
<p>A list whose components are passed to 
<code>sqliteImportFile</code>.  Components may include <code>sep</code>, 
<code>header</code>, <code>row.names</code>, <code>skip</code>, <code>eol</code> and <code>filter</code>.
Except for <code>filter</code> they are passed to
<code>sqliteImportFile</code> and have the same default values as 
in <code>sqliteImportFile</code> (except for <code>eol</code> which defaults
to the end of line character(s) for the operating system in use &ndash; note
that
if the file being read does not have the line endings for the platform
being used then <code>eol</code> will have to be specified.  In particular, 
certain UNIX-like tools on Windows may produce files with UNIX line endings
in which case <code>eol="\n"</code> should be specified). 
<code>filter</code> may optionally contain a batch/shell command through which the
input file is piped prior to reading it in.  Alternately <code>filter</code>
may be a list whose first component is a batch/shell command containing
names which correspond to the names of the subsequent list components.
These subsequent components should each be a character
vector which <code>sqldf</code> will read into a temporary file. The name of
the temporary file will be replaced into the command.   For example,
<code>filter = list("gawk -f prog", prog = '{ print gensub(/,/, ".", "g") }')</code> . 
command line quoting which may vary among shells and Windows.
Note that if the filter produces files with UNIX line endings on Windows
then <code>eol</code> must be specified, as discussed above.
<code>file.format</code> may be set to <code>NULL</code> in order not to search
for input file objects at all.  The <code>file.format</code> can also
be specified as an attribute in each file object itself in which case 
such specification overrides any given through the argument list.  There
is further discussion of <code>file.format</code> below.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_dbname">dbname</code></td>
<td>
<p>Name of the database.  For SQLite and h2 data bases this 
defaults to
<code>":memory:"</code> which results in an embedded database. For MySQL this
defaults to <code>getOption("RMysql.dbname")</code> and if that is not specified
then <code>"test"</code> is used.  
For RPostgreSQL this
defaults to <code>getOption("sqldf.RPostgreSQL.dbname")</code> and if that is 
not specified then <code>"test"</code> is used.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_drv">drv</code></td>
<td>
<p><code>"SQLite"</code>, <code>"MySQL"</code>, <code>"h2"</code>,
<code>"PostgreSQL"</code> or <code>"pgSQL"</code> or any of those names prefaced with 
<code>"R"</code>.
If not specified then
the <code>"dbDriver"</code> option is checked and if that is not set then
<code>sqldf</code> checks whether <code>RPostgreSQL</code>, 
<code>RMySQL</code> or <code>RH2</code> 
is loaded in that order and the driver corresponding to the first one
found is used.  If none are loaded then <code>"SQLite"</code> is used. 
<code>dbname=NULL</code> causes the default to be used.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_user">user</code></td>
<td>
<p>user name.  Not needed for embedded databases. 
For RPostgreSQL
the default is taken from option <code>sqldf.RPostgreSQL.user</code> and
if that is not specified either then <code>"postgres"</code> is used.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_password">password</code></td>
<td>
<p>password. Not needed for embedded databases. 
For RPostgreSQL
the default is taken from option <code>sqldf.RPostgreSQL.password</code> and
if that is not specified then <code>"postgres"</code> is used.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_host">host</code></td>
<td>
<p>host.  Default of &quot;localhost&quot; is normally sufficient.
For RPostgreSQL
the default is taken from option <code>sqldf.RPostgreSQL.host</code> and
if that is not specified then <code>"test"</code> is used.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_port">port</code></td>
<td>
<p>port. For RPostgreSQL the default 
is taken from the option <code>sqldf.RPostgreSQL.port</code> and if that is not
specified then <code>5432</code> is used.
</p>
</td></tr>
<tr><td><code id="sqldf_+3A_dll">dll</code></td>
<td>
<p>Name of an SQLite loadable extension to automatically load.
If found on PATH then it is 
automatically loaded and the SQLite functions it in will be accessible.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_connection">connection</code></td>
<td>
<p>If this is <code>NULL</code> then a connection is created;
otherwise the indicated connection is used.  The default is
the value of the option <code>sqldf.connection</code>.  If neither 
<code>connection</code> nor <code>sqldf.connection</code> are specified a connection
is automatically generated on-the-fly and closed on exit of the call to 
<code>sqldf</code>.  If this argument is not <code>NULL</code> then the specified
connection is left open on termination of the <code>sqldf</code> call.  Usually 
this argument is left unspecified.  It can be used to make repeated calls
to a database without reloading it.</p>
</td></tr>
<tr><td><code id="sqldf_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then verboe output shown.  Anything else
suppresses verbose output. Can be set globally using option 
<code>"sqldf.verbose"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The typical action of <code>sqldf</code> is to 
</p>

<dl>
<dt>create a database</dt><dd><p>in memory</p>
</dd>
<dt>read in the data frames and files</dt><dd><p>used in the select statement.  
This is done by scanning the select statement to see which words in 
the select statement are of class &quot;data.frame&quot; or &quot;file&quot; in the parent frame,  or the
specified environment if <code>envir</code> is used, and for each object
found by reading it into the database if it is a data frame.  Note
that this heuristic usually reads in the wanted data frames and files
but on occasion may harmlessly reads in extra ones too.</p>
</dd>
<dt>run the select statement</dt><dd><p>getting the result as a data frame</p>
</dd>
<dt>assign the classes</dt><dd><p>of the returned data frame's columns if
<code>method = "auto"</code>.  This is done by checking all the column
names in the read-in data frames and if any are the same
as a column output from the data base then that column is coerced to the
class of the column whose name matched.  
If the class of the column is <code>"factor"</code> or <code>"ordered"</code> or if the
column is not matched then the column is returned
as is.  If <code>method = "auto.factor"</code> then processing is similar except
that <code>"factor"</code> and <code>"ordered"</code> classes and their levels will be
assigned as well.  The <code>"auto.factor"</code> heuristic
is less reliable than the <code>"auto"</code> heuristic.
If <code>method = "raw"</code> then the classes are returned
as is from the database. </p>
</dd>
<dt>cleanup</dt><dd><p>If the database was created by sqldf then it is deleted;
otherwise, all tables that were created are dropped in order to leave
the database in the same state that it was before.  The database
connection is terminated.</p>
</dd>
</dl>

<p><code>sqldf</code> supports the following R options for RPostgreSQL: 
<code>"sqldf.RPostgreSQL.dbname"</code>,
<code>"sqldf.RPostgreSQL.user"</code>,
<code>"sqldf.RPostgreSQL.password"</code>,
<code>"sqldf.RPostgreSQL.host"</code> and
<code>"sqldf.RPostgreSQL.port"</code> which have defaults <code>"test"</code>,
<code>"postgres"</code>, <code>"postgres"</code>, <code>"localhost"</code> and <code>5432</code>,
respectively.  It also supports
<code>"sqldf.RPostgreSQL.other"</code> which is a list of named parameters.  These
may include 
<code>dbname</code>,
<code>user</code>,
<code>password</code>,
<code>host</code> and 
<code>port</code>.
Individually these take precdence over otherwise specified connection
arguments.
</p>
<p>Warning. Although sqldf is usually used with on-the-fly databases
which it automatically sets up and destroys if you wish to use it
with existing databases be sure to back up your database prior to
using it since incorrect operation could destroy the entire 
database.
</p>


<h3>Value</h3>

<p>The result of the specified select statement is output as a data frame.
If a vector of sql statements is given as <code>x</code> then the result of
the last one is returned.  If the <code>x</code> and <code>connection</code>
arguments are missing then it returns a new connection and also places
this connection in the option <code>sqldf.connection</code>.
</p>


<h3>Note</h3>

<p>If <code>row.names = TRUE</code> is used then 
any <code>NATURAL JOIN</code> will make use of it which may not be what was
intended.
</p>
<p>3/2 and 3.0/2 are the same in R but in SQLite the first one
causes integer arithmetic to be used whereas the second using floating point.  
Thus both evaluate to 
1.5 in R but they evaluate to 1 and 1.5 respectively in SQLite.
</p>
<p>The <code>dbWriteTable</code>/<code>sqliteImportFile</code> routines that sqldf uses to transfer files to the data base are intended for speed and they are not as flexible as <code><a href="utils.html#topic+read.table">read.table</a></code>.  Also they have slightly different defaults. (If more flexible input is needed use the slower <code>read.table</code> to read the data into a data frame instead of reading directly from a file.)  The default for <code>sep</code> is <code>sep = ","</code>. If the first row of the file has one fewer entry than subsequent ones then it is assumed that <code>header &lt;- row.names &lt;- TRUE</code> and otherwise that <code>header &lt;- row.names &lt;- FALSE</code>. The <code>header</code> can be forced to <code>header &lt;- TRUE</code> by specifying <code>file.format = list(header = TRUE)</code> as an argument to <code>sqldf.</code> <code>sep</code> and <code>row.names</code> are other <code>file.format</code> subarguments. Also, one limitation with .csv files is that quotes are not regarded as special within files so a comma within a data field such as <code>"Smith, James"</code> would be regarded as a field delimiter and the quotes would be entered as part of the data which probably is not what is intended.  
</p>
<p>Typically the SQL result will have the same data as the analogous
non-database <code>R</code> code manipulations using data frames 
but may differ in row names and other attributes.  In the
examples below we use <code>identical</code> in those cases where the two
results are the same in all respects or set the row names to <code>NULL</code>
if they would have otherwise differed only in row names or use
<code>all.equal</code> if the data portion is the same but attributes aside
from row names differ.
</p>
<p>On MySQL the database must pre-exist.  Create a <code>c:\my.ini</code> 
or <code>%MYSQL_HOME%\my.ini</code> file on Windows or a <code>/etc/my.cnf</code>
file on UNIX to contain information about the database.  This file may 
specify the username, password and port.  The password
can be omitted if one has not been set.  If using a standard port
setup then the <code>port</code> can be omitted as well.  
The database is taken from the <code>dbname</code> argument of the <code>sqldf</code>
command or if not set from <code>getOption("sqldf.dbname")</code> or if that option
is not set it is assumed to be <code>"test"</code>.
Note that MySQL does not use the <code>user</code>, <code>password</code>, <code>host</code>
and codeport arguments of sqldf.
See <a href="http://dev.mysql.com/doc/refman/5.6/en/option-files.html">http://dev.mysql.com/doc/refman/5.6/en/option-files.html</a> for 
additional locations that the configuration files can be placed as well
as other information.
</p>
<p>If <code>getOption("sqldf.dll")</code> is specified
then the named dll will be loaded as an SQLite loadable extension.  
This is in addition to the extension functions included with RSQLite.
</p>


<h3>References</h3>

 
<p>The sqldf home page <a href="https://github.com/ggrothendieck/sqldf">https://github.com/ggrothendieck/sqldf</a> contains
more examples as well as links to SQLite pages that may be helpful in 
formulating queries.  It also containers pointers to using sqldf with H2
and PostgreSQL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# These examples show how to run a variety of data frame manipulations
# in R without SQL and then again with SQL
#

# head
a1r &lt;- head(warpbreaks)
a1s &lt;- sqldf("select * from warpbreaks limit 6")
identical(a1r, a1s)

# subset

a2r &lt;- subset(CO2, grepl("^Qn", Plant))
a2s &lt;- sqldf("select * from CO2 where Plant like 'Qn%'")
all.equal(as.data.frame(a2r), a2s)

data(farms, package = "MASS")
a3r &lt;- subset(farms, Manag %in% c("BF", "HF"))
a3s &lt;- sqldf("select * from farms where Manag in ('BF', 'HF')")
row.names(a3r) &lt;- NULL
identical(a3r, a3s)

a4r &lt;- subset(warpbreaks, breaks &gt;= 20 &amp; breaks &lt;= 30)
a4s &lt;- sqldf("select * from warpbreaks where breaks between 20 and 30", 
   row.names = TRUE)
identical(a4r, a4s)

a5r &lt;- subset(farms, Mois == 'M1')
a5s &lt;- sqldf("select * from farms where Mois = 'M1'", row.names = TRUE)
identical(a5r, a5s)

a6r &lt;- subset(farms, Mois == 'M2')
a6s &lt;- sqldf("select * from farms where Mois = 'M2'", row.names = TRUE)
identical(a6r, a6s)

# rbind
a7r &lt;- rbind(a5r, a6r)
a7s &lt;- sqldf("select * from a5s union all select * from a6s")

# sqldf drops the unused levels of Mois but rbind does not; however,
# all data is the same and the other columns are identical
row.names(a7r) &lt;- NULL
identical(a7r[-1], a7s[-1])

# aggregate - avg conc and uptake by Plant and Type
a8r &lt;- aggregate(iris[1:2], iris[5], mean)
a8s &lt;- sqldf('select Species, avg("Sepal.Length") `Sepal.Length`, 
   avg("Sepal.Width") `Sepal.Width` from iris group by Species')
all.equal(a8r, a8s)

# by - avg conc and total uptake by Plant and Type
a9r &lt;- do.call(rbind, by(iris, iris[5], function(x) with(x,
	data.frame(Species = Species[1], 
		mean.Sepal.Length = mean(Sepal.Length),
		mean.Sepal.Width = mean(Sepal.Width),
		mean.Sepal.ratio = mean(Sepal.Length/Sepal.Width)))))
row.names(a9r) &lt;- NULL
a9s &lt;- sqldf('select Species, avg("Sepal.Length") `mean.Sepal.Length`,
	avg("Sepal.Width") `mean.Sepal.Width`, 
	avg("Sepal.Length"/"Sepal.Width") `mean.Sepal.ratio` from iris
	group by Species')
all.equal(a9r, a9s)

# head - top 3 breaks
a10r &lt;- head(warpbreaks[order(warpbreaks$breaks, decreasing = TRUE), ], 3)
a10s &lt;- sqldf("select * from warpbreaks order by breaks desc limit 3")
row.names(a10r) &lt;- NULL
identical(a10r, a10s)

# head - bottom 3 breaks
a11r &lt;- head(warpbreaks[order(warpbreaks$breaks), ], 3)
a11s &lt;- sqldf("select * from warpbreaks order by breaks limit 3")
# attributes(a11r) &lt;- attributes(a11s) &lt;- NULL
row.names(a11r) &lt;- NULL
identical(a11r, a11s)

# ave - rows for which v exceeds its group average where g is group
DF &lt;- data.frame(g = rep(1:2, each = 5), t = rep(1:5, 2), v = 1:10)
a12r &lt;- subset(DF, v &gt; ave(v, g, FUN = mean))
Gavg &lt;- sqldf("select g, avg(v) as avg_v from DF group by g")
a12s &lt;- sqldf("select DF.g, t, v from DF, Gavg where DF.g = Gavg.g and v &gt; avg_v")
row.names(a12r) &lt;- NULL
identical(a12r, a12s)

# same but reduce the two select statements to one using a subquery
a13s &lt;- sqldf("select g, t, v 
from DF d1, (select g as g2, avg(v) as avg_v from DF group by g) 
where d1.g = g2 and v &gt; avg_v")
identical(a12r, a13s)

# same but shorten using natural join
a14s &lt;- sqldf("select g, t, v 
from DF 
natural join (select g, avg(v) as avg_v from DF group by g) 
where v &gt; avg_v")
identical(a12r, a14s)

# table
a15r &lt;- table(warpbreaks$tension, warpbreaks$wool)
a15s &lt;- sqldf("select sum(wool = 'A'), sum(wool = 'B') 
   from warpbreaks group by tension")
all.equal(as.data.frame.matrix(a15r), a15s, check.attributes = FALSE)

# reshape
t.names &lt;- paste("t", unique(as.character(DF$t)), sep = "_")
a16r &lt;- reshape(DF, direction = "wide", timevar = "t", idvar = "g", varying = list(t.names))
a16s &lt;- sqldf("select 
	g, 
	sum((t == 1) * v) t_1, 
	sum((t == 2) * v) t_2, 
	sum((t == 3) * v) t_3, 
	sum((t == 4) * v) t_4, 
	sum((t == 5) * v) t_5 
from DF group by g")
all.equal(a16r, a16s, check.attributes = FALSE)

# order
a17r &lt;- Formaldehyde[order(Formaldehyde$optden, decreasing = TRUE), ]
a17s &lt;- sqldf("select * from Formaldehyde order by optden desc")
row.names(a17r) &lt;- NULL
identical(a17r, a17s)

# centered moving average of length 7
set.seed(1)
DF &lt;- data.frame(x = rnorm(15, 1:15))
s18 &lt;- sqldf("select a.x x, avg(b.x) movavgx from DF a, DF b 
   where a.row_names - b.row_names between -3 and 3 
   group by a.row_names having count(*) = 7 
   order by a.row_names+0", 
 row.names = TRUE)
r18 &lt;- data.frame(x = DF[4:12,], movavgx = rowMeans(embed(DF$x, 7)))
row.names(r18) &lt;- NULL
all.equal(r18, s18)

# merge.  a19r and a19s are same except row order and row names
A &lt;- data.frame(a1 = c(1, 2, 1), a2 = c(2, 3, 3), a3 = c(3, 1, 2))
B &lt;- data.frame(b1 = 1:2, b2 = 2:1)
a19s &lt;- sqldf("select * from A, B")
a19r &lt;- merge(A, B)
Sort &lt;- function(DF) DF[do.call(order, DF),]
all.equal(Sort(a19s), Sort(a19r), check.attributes = FALSE)

# within Date, of the highest quality records list the one closest 
# to noon.  Note use of two sql statements in one call to sqldf.

Lines &lt;- "DeployID Date.Time LocationQuality Latitude Longitude
STM05-1 2005/02/28 17:35 Good -35.562 177.158
STM05-1 2005/02/28 19:44 Good -35.487 177.129
STM05-1 2005/02/28 23:01 Unknown -35.399 177.064
STM05-1 2005/03/01 07:28 Unknown -34.978 177.268
STM05-1 2005/03/01 18:06 Poor -34.799 177.027
STM05-1 2005/03/01 18:47 Poor -34.85 177.059
STM05-2 2005/02/28 12:49 Good -35.928 177.328
STM05-2 2005/02/28 21:23 Poor -35.926 177.314
"

DF &lt;- read.table(textConnection(Lines), skip = 1,  as.is = TRUE,
 col.names = c("Id", "Date", "Time", "Quality", "Lat", "Long"))

sqldf(c("create temp table DFo as select * from DF order by
  Date DESC, Quality DESC,
  abs(substr(Time, 1, 2) + substr(Time, 4, 2) /60 - 12) DESC",
  "select * from DFo group by Date"))

## Not run: 

# test of file connections with sqldf

# create test .csv file of just 3 records
write.table(head(iris, 3), "iris3.dat", sep = ",", quote = FALSE)

# look at contents of iris3.dat
readLines("iris3.dat")

# set up file connection
iris3 &lt;- file("iris3.dat")
sqldf('select * from iris3 where "Sepal.Width" &gt; 3')

# using a non-default separator
# file.format can be an attribute of file object or an arg passed to sqldf
write.table(head(iris, 3), "iris3.dat", sep = ";", quote = FALSE)
iris3 &lt;- file("iris3.dat")
sqldf('select * from iris3 where "Sepal.Width" &gt; 3', file.format = list(sep = ";"))

# same but pass file.format through attribute of file object
attr(iris3, "file.format") &lt;- list(sep = ";")
sqldf('select * from iris3 where "Sepal.Width" &gt; 3')

# copy file straight to disk without going through R
# and then retrieve portion into R  
sqldf('select * from iris3 where "Sepal.Width" &gt; 3', dbname = tempfile())

### same as previous example except it allows multiple queries against
### the database.  We use iris3 from before.  This time we use an
### in memory SQLite database.

sqldf() # open a connection
sqldf('select * from iris3 where "Sepal.Width" &gt; 3')

# At this point we have an iris3 variable in both
# the R workspace and in the SQLite database so we need to
# explicitly let it know we want the version in the database.
# If we were not to do that it would try to use the R version
# by default and fail since sqldf would prevent it from 
# overwriting the version already in the database to protect
# the user from inadvertent errors.
sqldf('select * from main.iris3 where "Sepal.Width" &gt; 4')
sqldf('select * from main.iris3 where "Sepal_Width" &lt; 4')
sqldf() # close connection

### another way to do this is a mix of sqldf and RSQLite statements
### In that case we need to fetch the connection for use with RSQLite
### and do not have to specifically refer to main since RSQLite can
### only access the database.

con &lt;- sqldf()
# this iris3 refers to the R variable and file
sqldf('select * from iris3 where "Sepal.Width" &gt; 3')
sqldf("select count(*) from iris3")
# these iris3 refer to the database table
dbGetQuery(con, 'select * from iris3 where "Sepal.Width" &gt; 4')
dbGetQuery(con, 'select * from iris3 where "Sepal.Width" &lt; 4')
sqldf()


## End(Not run)
</code></pre>

<hr>
<h2 id='sqldf-package'>
sqldf package overview
</h2><span id='topic+sqldf-package'></span>

<h3>Description</h3>

<p>Provides an easy way to perform SQL selects on R data frames.  
</p>


<h3>Details</h3>

<p>The package contains a single function <a href="#topic+sqldf">sqldf</a> whose help file
contains more information and examples.
</p>


<h3>References</h3>

 
<p>The <a href="#topic+sqldf">sqldf</a> help page contains the primary documentation.
The sqldf github home page <a href="https://github.com/ggrothendieck/sqldf">https://github.com/ggrothendieck/sqldf</a> 
contains links to SQLite pages that may be helpful in formulating queries.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
