<!DOCTYPE html><html><head><title>Help for package snakecase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {snakecase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abbreviation_internal'><p>Internal abbreviation marker, marks abbreviations with an underscore behind.</p>
Useful if <code>parsing_option</code> 1 is needed, but some abbreviations need <code>parsing_option</code> 2.</a></li>
<li><a href='#caseconverter'><p>Specific case converter shortcuts</p></a></li>
<li><a href='#check_design_rule'><p>Internal helper to test the design rules for any string and setting of <code>to_any_case()</code></p></a></li>
<li><a href='#parsing_helpers'><p>Parsing helpers</p></a></li>
<li><a href='#preprocess_internal'><p>Internal function that replaces regex matches with underscores</p></a></li>
<li><a href='#relevant'><p>Internal helper for &quot;lower_upper&quot;, &quot;upper_lower&quot;.</p>
This helper returns a logical vector with TRUE for the
first and every second string of those which contain
an alphabetic character</a></li>
<li><a href='#replace_special_characters_internal'><p>Internal helper to replace special characters.</p></a></li>
<li><a href='#to_any_case'><p>General case conversion</p></a></li>
<li><a href='#to_parsed_case_internal'><p>Internal parser, which is relevant for preprocessing, parsing and parsing options</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.11.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Convert Strings into any Case</td>
</tr>
<tr>
<td>Description:</td>
<td>A consistent, flexible and easy to use tool to parse and convert strings into cases like snake or camel among others.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Malte Grosser &lt;malte.grosser@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, stringi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, tibble, purrrlyr, knitr, rmarkdown, magrittr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Tazinho/snakecase">https://github.com/Tazinho/snakecase</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Tazinho/snakecase/issues">https://github.com/Tazinho/snakecase/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 20:30:20 UTC; malte</td>
</tr>
<tr>
<td>Author:</td>
<td>Malte Grosser [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 22:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='abbreviation_internal'>Internal abbreviation marker, marks abbreviations with an underscore behind.
Useful if <code>parsing_option</code> 1 is needed, but some abbreviations need <code>parsing_option</code> 2.</h2><span id='topic+abbreviation_internal'></span>

<h3>Description</h3>

<p>Internal abbreviation marker, marks abbreviations with an underscore behind.
Useful if <code>parsing_option</code> 1 is needed, but some abbreviations need <code>parsing_option</code> 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abbreviation_internal(string, abbreviations = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abbreviation_internal_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
<tr><td><code id="abbreviation_internal_+3A_abbreviations">abbreviations</code></td>
<td>
<p>character with (uppercase) abbreviations. This marks
abbreviations with an underscore behind (in front of the parsing).
Useful if <code>parsing_option</code> 1 is needed, but some abbreviations need <code>parsing_option</code> 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='caseconverter'>Specific case converter shortcuts</h2><span id='topic+caseconverter'></span><span id='topic+to_snake_case'></span><span id='topic+to_lower_camel_case'></span><span id='topic+to_upper_camel_case'></span><span id='topic+to_screaming_snake_case'></span><span id='topic+to_parsed_case'></span><span id='topic+to_mixed_case'></span><span id='topic+to_lower_upper_case'></span><span id='topic+to_upper_lower_case'></span><span id='topic+to_swap_case'></span><span id='topic+to_sentence_case'></span><span id='topic+to_random_case'></span><span id='topic+to_title_case'></span>

<h3>Description</h3>

<p>Wrappers around <code>to_any_case()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_snake_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_lower_camel_case(string, abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = "middle", sep_out = NULL,
  unique_sep = NULL, empty_fill = NULL, prefix = "", postfix = "")

to_upper_camel_case(string, abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = "middle", sep_out = NULL,
  unique_sep = NULL, empty_fill = NULL, prefix = "", postfix = "")

to_screaming_snake_case(string, abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = "middle", sep_out = NULL,
  unique_sep = NULL, empty_fill = NULL, prefix = "", postfix = "")

to_parsed_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_mixed_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_lower_upper_case(string, abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = "middle", sep_out = NULL,
  unique_sep = NULL, empty_fill = NULL, prefix = "", postfix = "")

to_upper_lower_case(string, abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = "middle", sep_out = NULL,
  unique_sep = NULL, empty_fill = NULL, prefix = "", postfix = "")

to_swap_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_sentence_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_random_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")

to_title_case(string, abbreviations = NULL, sep_in = "[^[:alnum:]]",
  parsing_option = 1, transliterations = NULL, numerals = "middle",
  sep_out = NULL, unique_sep = NULL, empty_fill = NULL,
  prefix = "", postfix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caseconverter_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_abbreviations">abbreviations</code></td>
<td>
<p>character. (Case insensitive) matched abbreviations are surrounded by underscores. In this way, they can get recognized by the parser. This is useful when e.g. <code>parsing_option</code> 1 is needed for the use case, but some abbreviations but some substrings would require <code>parsing_option</code> 2. Furthermore, this argument also specifies the formatting of abbreviations in the output for the cases title, mixed, lower and upper camel. E.g. for upper camel the first letter is always in upper case, but when the abbreviation is supplied in upper case, this will also be visible in the output.
</p>
<p>Use this feature with care: One letter abbreviations and abbreviations next to each other are hard to read and also not easy to parse for further processing.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_sep_in">sep_in</code></td>
<td>
<p>(short for separator input) if character, is interpreted as a
regular expression (wrapped internally into <code>stringr::regex()</code>). 
The default value is a regular expression that matches any sequence of
non-alphanumeric values. All matches will be replaced by underscores 
(additionally to <code>"_"</code> and <code>" "</code>, for which this is always true, even
if <code>NULL</code> is supplied). These underscores are used internally to split
the strings into substrings and specify the word boundaries.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_parsing_option">parsing_option</code></td>
<td>
<p>An integer that will determine the parsing_option.
</p>

<ul>
<li><p>1: <code>"RRRStudio" -&gt; "RRR_Studio"</code>
</p>
</li>
<li><p>2: <code>"RRRStudio" -&gt; "RRRS_tudio"</code>
</p>
</li>
<li><p>3: <code>"RRRStudio" -&gt; "RRRSStudio"</code>. This will become for example <code>"Rrrstudio"</code> when we convert to lower camel case.
</p>
</li>
<li><p>-1, -2, -3: These <code>parsing_options</code>'s will suppress the conversion after non-alphanumeric values.
</p>
</li>
<li><p>0: no parsing
</p>
</li></ul>
</td></tr>
<tr><td><code id="caseconverter_+3A_transliterations">transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently
only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table. When named character elements are supplied as part of 'transliterations', anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of <code>case = "parsed"</code>, <code>case = "internal_parsing"</code> and 
<code>case = "none"</code>, since for upper case letters, which have transliterations/replacements
of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_numerals">numerals</code></td>
<td>
<p>A character specifying the alignment of numerals (<code>"middle"</code>, <code>left</code>, <code>right</code> or <code>asis</code>). I.e. <code>numerals = "left"</code> ensures that no output separator is in front of a digit.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_sep_out">sep_out</code></td>
<td>
<p>(short for separator output) String that will be used as separator. The defaults are <code>"_"</code> 
and <code>""</code>, regarding the specified <code>case</code>. When <code>length(sep_out) &gt; 1</code>, the last element of <code>sep_out</code> gets recycled and separators are incorporated per string according to their order.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_unique_sep">unique_sep</code></td>
<td>
<p>A string. If not <code>NULL</code>, then duplicated names will get 
a suffix integer
in the order of their appearance. The suffix is separated by the supplied string
to this argument.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_empty_fill">empty_fill</code></td>
<td>
<p>A string. If it is supplied, then each entry that matches &quot;&quot; will be replaced
by the supplied string to this argument.</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_prefix">prefix</code></td>
<td>
<p>prefix (string).</p>
</td></tr>
<tr><td><code id="caseconverter_+3A_postfix">postfix</code></td>
<td>
<p>postfix (string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector according the specified parameters above.
</p>
<p>A character vector according the specified target case.
</p>


<h3>Note</h3>

<p>caseconverters are vectorised over <code>string</code>, <code>sep_in</code>, <code>sep_out</code>,
<code>empty_fill</code>, <code>prefix</code> and <code>postfix</code>.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>
<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/Tazinho/snakecase">snakecase on github</a>, <code><a href="#topic+to_any_case">to_any_case</a></code> for flexible high level conversion and more examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c("this Is a Strange_string", "AND THIS ANOTHER_One", NA)

to_snake_case(strings)
to_lower_camel_case(strings)
to_upper_camel_case(strings)
to_screaming_snake_case(strings)
to_lower_upper_case(strings)
to_upper_lower_case(strings)
to_parsed_case(strings)
to_mixed_case(strings)
to_swap_case(strings)
to_sentence_case(strings)
to_random_case(strings)
to_title_case(strings)


</code></pre>

<hr>
<h2 id='check_design_rule'>Internal helper to test the design rules for any string and setting of <code>to_any_case()</code></h2><span id='topic+check_design_rule'></span>

<h3>Description</h3>

<p>Internal helper to test the design rules for any string and setting of <code>to_any_case()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_design_rule(string, sep_in = NULL, transliterations = NULL,
  sep_out = NULL, prefix = "", postfix = "", unique_sep = NULL,
  empty_fill = NULL, parsing_option = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_design_rule_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_sep_in">sep_in</code></td>
<td>
<p>String that will be wrapped internally into <code>stringr::regex()</code>. 
All matches will be treated as additional splitting parameters besides the default ones 
(<code>"_"</code> and <code>" "</code>), when parsing the input string.</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_transliterations">transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently
only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table.</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_sep_out">sep_out</code></td>
<td>
<p>String that will be used as separator. The defaults are <code>"_"</code> 
and <code>""</code>, regarding the specified <code>case</code>.</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_prefix">prefix</code></td>
<td>
<p>prefix (string).</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_postfix">postfix</code></td>
<td>
<p>postfix (string).</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_unique_sep">unique_sep</code></td>
<td>
<p>A string. If it is supplied, then duplicated names will get a suffix integer
in the order of their appearance. The suffix is separated by the supplied string to this argument.</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_empty_fill">empty_fill</code></td>
<td>
<p>A string. If it is supplied, then each entry that matches &quot;&quot; will be replaced
by the supplied string to this argument.</p>
</td></tr>
<tr><td><code id="check_design_rule_+3A_parsing_option">parsing_option</code></td>
<td>
<p>An integer that will determine the parsing_option.
</p>

<ul>
<li><p>1: <code>RRRStudio -&gt; RRR_Studio</code>
</p>
</li>
<li><p>2: <code>RRRStudio -&gt; RRRS_tudio</code>
</p>
</li>
<li><p>3: parses at the beginning like option 1 and the rest like option 2.
</p>
</li>
<li><p>4: parses at the beginning like option 2 and the rest like option 1.
</p>
</li>
<li><p>5: parses like option 1 but suppresses &quot;_&quot; around non special characters.
In this way case conversion won't apply after these characters. See examples.
</p>
</li>
<li><p>6: parses like option 1, but digits directly behind/in front non-digits, will stay as is.
</p>
</li>
<li><p>any other integer &lt;= 0: no parsing&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector separated by underscores, containing the parsed string.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='parsing_helpers'>Parsing helpers</h2><span id='topic+parsing_helpers'></span><span id='topic+parse1_pat_cap_smalls'></span><span id='topic+parse2_pat_digits'></span><span id='topic+parse3_pat_caps'></span><span id='topic+parse4_pat_cap'></span><span id='topic+parse5_pat_non_alnums'></span><span id='topic+parse6_mark_digits'></span><span id='topic+parse7_pat_caps_smalls'></span><span id='topic+parse8_pat_smalls_after_non_alnums'></span>

<h3>Description</h3>

<p>Mainly for usage within <code>to_parsed_case_internal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse1_pat_cap_smalls(string)

parse2_pat_digits(string)

parse3_pat_caps(string)

parse4_pat_cap(string)

parse5_pat_non_alnums(string)

parse6_mark_digits(string)

parse7_pat_caps_smalls(string)

parse8_pat_smalls_after_non_alnums(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsing_helpers_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partly parsed character vector.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='preprocess_internal'>Internal function that replaces regex matches with underscores</h2><span id='topic+preprocess_internal'></span>

<h3>Description</h3>

<p>Internal function that replaces regex matches with underscores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_internal(string, sep_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_internal_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="preprocess_internal_+3A_sep_in">sep_in</code></td>
<td>
<p>(short for separator input) A regex supplied as a character (if not <code>NULL</code>), which will be wrapped internally
into <code>stringr::regex()</code>. All matches will be replaced by underscores (additionally to 
<code>"_"</code> and <code>" "</code>, for which this is always true). Underscores can later turned into another separator via <code>postprocess</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character containing the parsed string.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='relevant'>Internal helper for &quot;lower_upper&quot;, &quot;upper_lower&quot;.
This helper returns a logical vector with TRUE for the 
first and every second string of those which contain 
an alphabetic character</h2><span id='topic+relevant'></span>

<h3>Description</h3>

<p>Internal helper for &quot;lower_upper&quot;, &quot;upper_lower&quot;.
This helper returns a logical vector with TRUE for the 
first and every second string of those which contain 
an alphabetic character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relevant(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevant_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='replace_special_characters_internal'>Internal helper to replace special characters.</h2><span id='topic+replace_special_characters_internal'></span>

<h3>Description</h3>

<p>Internal helper to replace special characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_special_characters_internal(string, transliterations, case)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_special_characters_internal_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
<tr><td><code id="replace_special_characters_internal_+3A_transliterations">transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently
only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table. When named character elements are supplied as part of 'transliterations', anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of <code>case = "parsed"</code>, <code>case = "internal_parsing"</code> and 
<code>case = "none"</code>, since for upper case letters, which have transliterations/replacements
of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.</p>
</td></tr>
<tr><td><code id="replace_special_characters_internal_+3A_case">case</code></td>
<td>
<p>Length one character, from the input options of <code>to_any_case</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

<hr>
<h2 id='to_any_case'>General case conversion</h2><span id='topic+to_any_case'></span>

<h3>Description</h3>

<p>Function to convert strings to any case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_any_case(string, case = c("snake", "small_camel", "big_camel",
  "screaming_snake", "parsed", "mixed", "lower_upper", "upper_lower",
  "swap", "all_caps", "lower_camel", "upper_camel", "internal_parsing",
  "none", "flip", "sentence", "random", "title"), abbreviations = NULL,
  sep_in = "[^[:alnum:]]", parsing_option = 1,
  transliterations = NULL, numerals = c("middle", "left", "right",
  "asis", "tight"), sep_out = NULL, unique_sep = NULL,
  empty_fill = NULL, prefix = "", postfix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_any_case_+3A_string">string</code></td>
<td>
<p>A string (for example names of a data frame).</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_case">case</code></td>
<td>
<p>The desired target case, provided as one of the following:
</p>

<ul>
<li><p>snake_case: <code>"snake"</code>
</p>
</li>
<li><p>lowerCamel: <code>"lower_camel"</code> or <code>"small_camel"</code>
</p>
</li>
<li><p>UpperCamel: <code>"upper_camel"</code> or <code>"big_camel"</code>
</p>
</li>
<li><p>ALL_CAPS: <code>"all_caps"</code> or <code>"screaming_snake"</code>
</p>
</li>
<li><p>lowerUPPER: <code>"lower_upper"</code>
</p>
</li>
<li><p>UPPERlower: <code>"upper_lower"</code>
</p>
</li>
<li><p>Sentence case: <code>"sentence"</code>
</p>
</li>
<li><p>Title Case: <code>"title"</code> - This one is basically the same as sentence case, but in addition it is wrapped into <code>tools::toTitleCase</code> and any <code>abbreviations</code> are always turned into upper case.
</p>
</li></ul>

<p>There are five &quot;special&quot; cases available:
</p>

<ul>
<li><p><code>"parsed"</code>: This case is underlying all other cases. 
Every substring a string consists
of becomes surrounded by an underscore (depending on the <code>parsing_option</code>).
Underscores at the start and end are trimmed. No lower or 
upper case pattern from the input string are changed.
</p>
</li>
<li><p><code>"mixed"</code>: Almost the same as <code>case = "parsed"</code>. Every letter which is not at the start
or behind an underscore is turned into lowercase. If a substring is set as an abbreviation, it will be turned into upper case.
</p>
</li>
<li><p><code>"swap"</code>: Upper case letters will be turned into lower case and vice versa. Also <code>case = "flip"</code> will work.
Doesn't work with any of the other arguments except <code>unique_sep</code>, <code>empty_fill</code>, <code>prefix</code> and <code>postfix</code>.
</p>
</li>
<li><p><code>"random"</code>: Each letter will be randomly turned into lower or upper case. Doesn't work with any of the other arguments except <code>unique_sep</code>, <code>empty_fill</code>, <code>prefix</code> and <code>postfix</code>.
</p>
</li>
<li><p><code>"none"</code>: Neither parsing nor case conversion occur. This case might be helpful, when
one wants to call the function for the quick usage of the other parameters.
To suppress replacement of spaces to underscores set <code>sep_in = NULL</code>.
Works with <code>sep_in</code>, <code>transliterations</code>, <code>sep_out</code>, <code>prefix</code>,
<code>postfix</code>,
<code>empty_fill</code> and <code>unique_sep</code>.
</p>
</li>
<li><p><code>"internal_parsing"</code>: This case is returning the internal parsing
(suppressing the internal protection mechanism), which means that alphanumeric characters will be surrounded by underscores.
It should only be used in very rare use cases and is mainly implemented to showcase the internal workings of <code>to_any_case()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_any_case_+3A_abbreviations">abbreviations</code></td>
<td>
<p>character. (Case insensitive) matched abbreviations are surrounded by underscores. In this way, they can get recognized by the parser. This is useful when e.g. <code>parsing_option</code> 1 is needed for the use case, but some abbreviations but some substrings would require <code>parsing_option</code> 2. Furthermore, this argument also specifies the formatting of abbreviations in the output for the cases title, mixed, lower and upper camel. E.g. for upper camel the first letter is always in upper case, but when the abbreviation is supplied in upper case, this will also be visible in the output.
</p>
<p>Use this feature with care: One letter abbreviations and abbreviations next to each other are hard to read and also not easy to parse for further processing.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_sep_in">sep_in</code></td>
<td>
<p>(short for separator input) if character, is interpreted as a
regular expression (wrapped internally into <code>stringr::regex()</code>). 
The default value is a regular expression that matches any sequence of
non-alphanumeric values. All matches will be replaced by underscores 
(additionally to <code>"_"</code> and <code>" "</code>, for which this is always true, even
if <code>NULL</code> is supplied). These underscores are used internally to split
the strings into substrings and specify the word boundaries.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_parsing_option">parsing_option</code></td>
<td>
<p>An integer that will determine the parsing_option.
</p>

<ul>
<li><p>1: <code>"RRRStudio" -&gt; "RRR_Studio"</code>
</p>
</li>
<li><p>2: <code>"RRRStudio" -&gt; "RRRS_tudio"</code>
</p>
</li>
<li><p>3: <code>"RRRStudio" -&gt; "RRRSStudio"</code>. This will become for example <code>"Rrrstudio"</code> when we convert to lower camel case.
</p>
</li>
<li><p>-1, -2, -3: These <code>parsing_options</code>'s will suppress the conversion after non-alphanumeric values.
</p>
</li>
<li><p>0: no parsing
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_any_case_+3A_transliterations">transliterations</code></td>
<td>
<p>A character vector (if not <code>NULL</code>). The entries of this argument
need to be elements of <code>stringi::stri_trans_list()</code> (like &quot;Latin-ASCII&quot;, which is often useful) or names of lookup tables (currently only &quot;german&quot; is supported). In the order of the entries the letters of the input
string will be transliterated via <code>stringi::stri_trans_general()</code> or replaced via the 
matches of the lookup table. When named character elements are supplied as part of 'transliterations', anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of <code>case = "parsed"</code>, <code>case = "internal_parsing"</code> and 
<code>case = "none"</code>, since for upper case letters, which have transliterations/replacements
of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_numerals">numerals</code></td>
<td>
<p>A character specifying the alignment of numerals (<code>"middle"</code>, <code>left</code>, <code>right</code>, <code>asis</code> or <code>tight</code>). I.e. <code>numerals = "left"</code> ensures that no output separator is in front of a digit.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_sep_out">sep_out</code></td>
<td>
<p>(short for separator output) String that will be used as separator. The defaults are <code>"_"</code> 
and <code>""</code>, regarding the specified <code>case</code>. When <code>length(sep_out) &gt; 1</code>, the last element of <code>sep_out</code> gets recycled and separators are incorporated per string according to their order.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_unique_sep">unique_sep</code></td>
<td>
<p>A string. If not <code>NULL</code>, then duplicated names will get 
a suffix integer
in the order of their appearance. The suffix is separated by the supplied string
to this argument.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_empty_fill">empty_fill</code></td>
<td>
<p>A string. If it is supplied, then each entry that matches &quot;&quot; will be replaced
by the supplied string to this argument.</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_prefix">prefix</code></td>
<td>
<p>prefix (string).</p>
</td></tr>
<tr><td><code id="to_any_case_+3A_postfix">postfix</code></td>
<td>
<p>postfix (string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector according the specified parameters above.
</p>


<h3>Note</h3>

<p><code>to_any_case()</code> is vectorised over <code>string</code>, <code>sep_in</code>, <code>sep_out</code>,
<code>empty_fill</code>, <code>prefix</code> and <code>postfix</code>.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/Tazinho/snakecase">snakecase on github</a> or 
<code><a href="#topic+caseconverter">caseconverter</a></code> for some handy shortcuts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### abbreviations
to_snake_case(c("HHcity", "newUSElections"), abbreviations = c("HH", "US"))
to_upper_camel_case("succesfullGMBH", abbreviations = "GmbH")
to_title_case("succesfullGMBH", abbreviations = "GmbH")

### sep_in (input separator)
string &lt;- "R.St\u00FCdio: v.1.0.143"
to_any_case(string)
to_any_case(string, sep_in = ":|\\.")
to_any_case(string, sep_in = ":|(?&lt;!\\d)\\.")
            
### parsing_option
# the default option makes no sense in this setting
to_parsed_case("HAMBURGcity", parsing_option = 1)
# so the second parsing option is the way to address this example
to_parsed_case("HAMBURGcity", parsing_option = 2)
# By default (option 1) characters are converted after non alpha numeric characters.
# To suppress this behaviour add a minus to the parsing_option
to_upper_camel_case("lookBehindThe.dot", parsing_option = -1)
# For some exotic cases parsing option 3 might be of interest
to_parsed_case("PARSingOption3", parsing_option = 3)
# There may be reasons to suppress the parsing
to_any_case("HAMBURGcity", parsing_option = 0)

### transliterations
to_any_case("\u00E4ngstlicher Has\u00EA", transliterations = c("german", "Latin-ASCII"))

### case
strings &lt;- c("this Is a Strange_string", "AND THIS ANOTHER_One")
to_any_case(strings, case = "snake")
to_any_case(strings, case = "lower_camel") # same as "small_camel"
to_any_case(strings, case = "upper_camel") # same as "big_camel"
to_any_case(strings, case = "all_caps") # same as "screaming_snake"
to_any_case(strings, case = "lower_upper")
to_any_case(strings, case = "upper_lower")
to_any_case(strings, case = "sentence")
to_any_case(strings, case = "title")
to_any_case(strings, case = "parsed")
to_any_case(strings, case = "mixed")
to_any_case(strings, case = "swap")
to_any_case(strings, case = "random")
to_any_case(strings, case = "none")
to_any_case(strings, case = "internal_parsing")

### numerals
to_snake_case("species42value 23month 7-8", numerals = "asis")
to_snake_case("species42value 23month 7-8", numerals = "left")
to_snake_case("species42value 23month 7-8", numerals = "right")
to_snake_case("species42value 23month 7-8", numerals = "middle")
to_snake_case("species42value 23month 7-8", numerals = "tight")

### sep_out (output separator)
string &lt;- c("lowerCamelCase", "ALL_CAPS", "I-DontKNOWWhat_thisCASE_is")
to_snake_case(string, sep_out = ".")
to_mixed_case(string, sep_out = " ")
to_screaming_snake_case(string, sep_out = "=")

### empty_fill
to_any_case(c("","",""), empty_fill = c("empty", "empty", "also empty"))

### unique_sep
to_any_case(c("same", "same", "same", "other"), unique_sep = c("&gt;"))

### prefix and postfix
to_upper_camel_case("some_path", sep_out = "//", 
  prefix = "USER://", postfix = ".exe")

</code></pre>

<hr>
<h2 id='to_parsed_case_internal'>Internal parser, which is relevant for preprocessing, parsing and parsing options</h2><span id='topic+to_parsed_case_internal'></span>

<h3>Description</h3>

<p>Internal parser, which is relevant for preprocessing, parsing and parsing options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_parsed_case_internal(string, parsing_option = 1L, numerals,
  abbreviations, sep_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_parsed_case_internal_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="to_parsed_case_internal_+3A_parsing_option">parsing_option</code></td>
<td>
<p>An integer that will determine the parsing option.
</p>

<ul>
<li><p>1: <code>RRRStudio -&gt; RRR_Studio</code>
</p>
</li>
<li><p>2: <code>RRRStudio -&gt; RRRS_tudio</code>
</p>
</li>
<li><p>3: parses like option 1 but suppresses &quot;_&quot; around non alpha-numeric characters. In this way this option suppresses splits and resulting case conversion after these characters.
</p>
</li>
<li><p>any other integer &lt;= 0: no parsing&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_parsed_case_internal_+3A_numerals">numerals</code></td>
<td>
<p>A character specifying the alignment of numerals (<code>"middle"</code>, <code>left</code>, <code>right</code> or <code>asis</code>). I.e. <code>numerals = "left"</code> ensures that no output separator is in front of a digit.</p>
</td></tr>
<tr><td><code id="to_parsed_case_internal_+3A_abbreviations">abbreviations</code></td>
<td>
<p>A character string specifying abbreviations that should be marked to be recognized by later parsing.</p>
</td></tr>
<tr><td><code id="to_parsed_case_internal_+3A_sep_in">sep_in</code></td>
<td>
<p>A character (regular expression) used to specify input separators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector separated by underscores, containing the parsed string.
</p>


<h3>Author(s)</h3>

<p>Malte Grosser, <a href="mailto:malte.grosser@gmail.com">malte.grosser@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
