<!DOCTYPE html><html><head><title>Help for package NetSci</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetSci}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#avr_proximity_multiple_target_sets'><p>avr_proximity_multiple_target_sets</p></a></li>
<li><a href='#extract_LCC'><p>Extract LCC from a graph</p></a></li>
<li><a href='#Histogram_LCC'><p>Histogram_LCC</p></a></li>
<li><a href='#Hypergeometric.test'><p>Hypergeometric.test</p></a></li>
<li><a href='#Jaccard'><p>Jaccard</p></a></li>
<li><a href='#LCC_Calc'><p>Internal</p></a></li>
<li><a href='#LCC_Significance'><p>LCC Significance</p></a></li>
<li><a href='#NetSci'><p>Global Definition</p></a></li>
<li><a href='#proximity_average'><p>Proximity from target to source</p></a></li>
<li><a href='#proximity_average_weighted'><p>Proximity from target to source</p></a></li>
<li><a href='#proximity_close'><p>Proximity from target to source</p></a></li>
<li><a href='#separation'><p>Separation</p></a></li>
<li><a href='#separation_Significance'><p>Separation Significance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculates Basic Network Measures Commonly Used in Network
Medicine</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Deisy Gysi </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deisy Morselli Gysi &lt;deisy.ccnr@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates network measures such as Largest Connected Component (LCC), Proximity, Separation, Jaccard Index, 
    along with permutation, when needed. </td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, magrittr, wTO, dplyr, Rfast, utils, binr, cubature</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CoDiNA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-03 17:49:50 UTC; deisygysi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-03 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='avr_proximity_multiple_target_sets'>avr_proximity_multiple_target_sets</h2><span id='topic+avr_proximity_multiple_target_sets'></span>

<h3>Description</h3>

<p>Calculates the average proximity from a set of targets to a set of source nodes.
It is calculate using a degree preserving randomization. It is calculated as described in
Guney, E. et al (2016) &lt;doi.org:10.1038/ncomms10331&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avr_proximity_multiple_target_sets(
  set,
  G,
  ST,
  source,
  N = 1000,
  bins = 100,
  min_per_bin = 20,
  weighted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_set">set</code></td>
<td>
<p>Name of the sets you have targets for. (In a drug-target setup, those would be the drugs of interest).</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_g">G</code></td>
<td>
<p>The original graph (often an interactome).</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_st">ST</code></td>
<td>
<p>Set-Target data. It is a data.frame with two columns. ID and Target.</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_source">source</code></td>
<td>
<p>The source nodes (disease genes).</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_n">N</code></td>
<td>
<p>Number of randomizations.</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_bins">bins</code></td>
<td>
<p>the number os bins for the degree preserving randomization.</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_min_per_bin">min_per_bin</code></td>
<td>
<p>the minimum size of each bin.</p>
</td></tr>
<tr><td><code id="avr_proximity_multiple_target_sets_+3A_weighted">weighted</code></td>
<td>
<p>consider a weighted graph? TRUE/FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proximity and its significance based on the degree preserving randomization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)
net$weight = runif(nrow(net))

g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
S = c("N", "A", "F", "I")
T1 = data.frame(ID = "T1", Target = c("H", "M"))
T2 = data.frame(ID = "T2", Target = c("G", "O"))

avr_proximity_multiple_target_sets(set = c('T1', 'T2'),
G = g,
 source = S,
 ST = rbind(T1,T2),
 bins = 1,
 min_per_bin = 2)

# In a weighted graph
# avr_proximity_multiple_target_sets(set = c('T1', 'T2'),
# G = g,
#  source = S,
#  ST = rbind(T1,T2),
#  bins = 1,
#  min_per_bin = 2,
#  weighted = TRUE)

</code></pre>

<hr>
<h2 id='extract_LCC'>Extract LCC from a graph</h2><span id='topic+extract_LCC'></span>

<h3>Description</h3>

<p>Extract LCC from a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_LCC(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_LCC_+3A_g">g</code></td>
<td>
<p>is the graph you want to extract the largest connected component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph (from igraph) with only the largest connected component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x = data.frame(n1 = sample(LETTERS[1:5]),
               n2 =  sample(LETTERS[1:20]))

g = igraph::graph_from_data_frame(x, directed = FALSE)
g = igraph::simplify(g)
LCC = extract_LCC(g)


</code></pre>

<hr>
<h2 id='Histogram_LCC'>Histogram_LCC</h2><span id='topic+Histogram_LCC'></span>

<h3>Description</h3>

<p>Plots the histogram to evaluate the significance of the Largest Connected Component (LCC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Histogram_LCC(LCC_L, Name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Histogram_LCC_+3A_lcc_l">LCC_L</code></td>
<td>
<p>an output from the function LCC_Significance or LCC_Bipartide</p>
</td></tr>
<tr><td><code id="Histogram_LCC_+3A_name">Name</code></td>
<td>
<p>title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Histogram of the simulated LCC, and a red line of the actual LCC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)

g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
targets = c("N", "A", "I", "F")
LCC_Out = LCC_Significance(N = 1000,
                 Targets = targets,
                                  G = g,
                                  bins = 5,
                                  min_per_bin = 2)
                                  # in a real interactome, please use the default

Histogram_LCC(LCC_Out, "Example")
</code></pre>

<hr>
<h2 id='Hypergeometric.test'>Hypergeometric.test</h2><span id='topic+Hypergeometric.test'></span>

<h3>Description</h3>

<p>Calculates the significance of an overlap of two sets using an hypergeometric test.
It is a wrapper of the 'phyper' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hypergeometric.test(
  success,
  universe_success,
  universe_failure,
  size_collected,
  lower.tail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hypergeometric.test_+3A_success">success</code></td>
<td>
<p>Is the number of elements in the overlap of the sets.</p>
</td></tr>
<tr><td><code id="Hypergeometric.test_+3A_universe_success">universe_success</code></td>
<td>
<p>Is the number of elements of the set of interest.</p>
</td></tr>
<tr><td><code id="Hypergeometric.test_+3A_universe_failure">universe_failure</code></td>
<td>
<p>Is the number of elements of the set of the other set.</p>
</td></tr>
<tr><td><code id="Hypergeometric.test_+3A_size_collected">size_collected</code></td>
<td>
<p>The total of elements in the universe</p>
</td></tr>
<tr><td><code id="Hypergeometric.test_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Should the test be calculated on the lower tail? (Hypothesis test is lower than)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-value for the hypergeometric test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(magrittr)
s = 10; S = 15; f = 10; T = 30
Hypergeometric.test(success = s,
universe_success = S,
universe_failure = f,
size_collected = T
)
</code></pre>

<hr>
<h2 id='Jaccard'>Jaccard</h2><span id='topic+Jaccard'></span>

<h3>Description</h3>

<p>Calculates the Jaccard index between different sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jaccard(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jaccard_+3A_data">Data</code></td>
<td>
<p>A data.frame with 2 columns. The first refers to the set and the second the elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the set names and their Jaccard index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
Data = data.frame(Class = sample(c("X", "Y", "Z"), replace = TRUE, size = 50),
                  Element = sample(LETTERS[1:15], replace = TRUE, size = 50))
Data = unique(Data)
Jaccard(Data)
</code></pre>

<hr>
<h2 id='LCC_Calc'>Internal</h2><span id='topic+LCC_Calc'></span>

<h3>Description</h3>

<p>Internal functions. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCC_Calc(PPIg, bins = 100, nodes, n, min_per_bin = 20)
</code></pre>

<hr>
<h2 id='LCC_Significance'>LCC Significance</h2><span id='topic+LCC_Significance'></span>

<h3>Description</h3>

<p>Calculates the Largest Connected Component (LCC) from a given graph, and calculates its significance using a degree preserving approach.
Menche, J., et al (2015) &lt;doi.org:10.1126/science.1065103&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCC_Significance(
  N = N,
  Targets = Targets,
  G,
  bins = 100,
  hypothesis = "greater",
  min_per_bin = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LCC_Significance_+3A_n">N</code></td>
<td>
<p>Number of randomizations.</p>
</td></tr>
<tr><td><code id="LCC_Significance_+3A_targets">Targets</code></td>
<td>
<p>Name of the nodes that the subgraph will focus on - Those are the nodes you want to know whether if forms an LCC.</p>
</td></tr>
<tr><td><code id="LCC_Significance_+3A_g">G</code></td>
<td>
<p>The  graph of interest (often, in NetMed it is an interactome - PPI).</p>
</td></tr>
<tr><td><code id="LCC_Significance_+3A_bins">bins</code></td>
<td>
<p>the number os bins for the degree preserving randomization. When bins = 1, assumes a uniform distribution for nodes.</p>
</td></tr>
<tr><td><code id="LCC_Significance_+3A_hypothesis">hypothesis</code></td>
<td>
<p>are you expecting an LCC greater or smaller than the average?</p>
</td></tr>
<tr><td><code id="LCC_Significance_+3A_min_per_bin">min_per_bin</code></td>
<td>
<p>the minimum size of each bin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the LCC
- $LCCZ all values from the randomizations
- $mean the average LCC of the randomizations
- $sd the sd LCC of the randomizations
- $Z The score
- $LCC the LCC of the given targets
- $emp_p the empirical p-value for the LCC
- $rLCC the relative LCC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)

g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
plot(g)
targets = c("I", "H", "F", "E")
 LCC_Significance(N = 100,
                   Targets = targets,
                                    G = g,
                                  bins = 1,
                                  min_per_bin = 2)


</code></pre>

<hr>
<h2 id='NetSci'>Global Definition</h2><span id='topic+NetSci'></span>

<h3>Description</h3>

<p>Basic global variables to make sure the package runs.
</p>

<hr>
<h2 id='proximity_average'>Proximity from target to source</h2><span id='topic+proximity_average'></span>

<h3>Description</h3>

<p>Calculates the proximity (average or closest) from source to targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity_average(G, source, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_average_+3A_g">G</code></td>
<td>
<p>The original graph (often an interactome).</p>
</td></tr>
<tr><td><code id="proximity_average_+3A_source">source</code></td>
<td>
<p>nodes from the network (in a drug repurpusing set-up those are the disease genes)</p>
</td></tr>
<tr><td><code id="proximity_average_+3A_targets">targets</code></td>
<td>
<p>targets in the network (in a drug repurpusing set-up those are the drug-targets)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proximity value for the source-targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)

g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
T = c("G", "A", "D")
S = c("C", "M")
proximity_average(g, source = S, targets = T)
</code></pre>

<hr>
<h2 id='proximity_average_weighted'>Proximity from target to source</h2><span id='topic+proximity_average_weighted'></span>

<h3>Description</h3>

<p>Calculates the weighted average proximity from source to targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity_average_weighted(G, source, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_average_weighted_+3A_g">G</code></td>
<td>
<p>The original graph (often a weighted interactome).</p>
</td></tr>
<tr><td><code id="proximity_average_weighted_+3A_source">source</code></td>
<td>
<p>nodes from the network (in a drug repurpusing set-up those are the disease genes)</p>
</td></tr>
<tr><td><code id="proximity_average_weighted_+3A_targets">targets</code></td>
<td>
<p>targets in the network (in a drug repurpusing set-up those are the drug-targets)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proximity value for the source-targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)
net$weight = runif(nrow(net))
g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
T = c("G", "A", "D")
S = c("C", "M")
proximity_average_weighted(g, source = S, targets = T)
</code></pre>

<hr>
<h2 id='proximity_close'>Proximity from target to source</h2><span id='topic+proximity_close'></span>

<h3>Description</h3>

<p>Calculates the proximity (average or closest) from source to targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximity_close(G, source, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximity_close_+3A_g">G</code></td>
<td>
<p>The original graph (often an interactome).</p>
</td></tr>
<tr><td><code id="proximity_close_+3A_source">source</code></td>
<td>
<p>nodes from the network (in a drug repurpusing set-up those are the disease genes)</p>
</td></tr>
<tr><td><code id="proximity_close_+3A_targets">targets</code></td>
<td>
<p>targets in the network (in a drug repurpusing set-up those are the drug-targets)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the proximity value for the source-targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
net  = data.frame(
Node.1 = sample(LETTERS[1:15], 15, replace = TRUE),
Node.2 = sample(LETTERS[1:10], 15, replace = TRUE))
net$value = 1
net =  CoDiNA::OrderNames(net)
net = unique(net)

g &lt;- igraph::graph_from_data_frame(net, directed = FALSE )
T = c("G", "A", "D")
S = c("C", "M")
proximity_close(g, source = S, targets = T)
</code></pre>

<hr>
<h2 id='separation'>Separation</h2><span id='topic+separation'></span>

<h3>Description</h3>

<p>Calculates the separation of two set of targets on a network.
Often used to measure separation of disease modules in a interactome.
Separation is calculated as in Menche, J. et al (2015) &lt;doi:10.1126/science.1257601&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separation(G, ST)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separation_+3A_g">G</code></td>
<td>
<p>The original graph (often an interactome).</p>
</td></tr>
<tr><td><code id="separation_+3A_st">ST</code></td>
<td>
<p>Set-Target data. It is a data.frame with two columns. ID and Target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the separation and distance of modules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(magrittr)
set.seed(12)
x = data.frame(n1 = sample(LETTERS[1:5]),
               n2 =  sample(LETTERS[1:20]))

D1 = data.frame(gene = c("H", "I", "S", "N", "A"), disease = "D1")
D2 = data.frame(gene = c("E", "C",  "R" , "J", "Q", "O"), disease = "D2")
D3 = data.frame(gene = c("E", "G", "T", "P"), disease = "D3")
D4 = data.frame(gene = c("A", "B", "E"), disease = "D4")

Diseases = rbind(D1, D2, D3, D4)
Diseases %&lt;&gt;% dplyr::select(disease, gene)
g = igraph::graph_from_data_frame(x, directed = FALSE)
g = igraph::simplify(g)

separation(G = g, ST = Diseases)
</code></pre>

<hr>
<h2 id='separation_Significance'>Separation Significance</h2><span id='topic+separation_Significance'></span>

<h3>Description</h3>

<p>Calculates the separation of two set of targets on a network and assigns a p-value to it.
Often used to measure separation of disease modules in a interactome.
Separation is calculated as in Menche, J. et al (2015) &lt;doi:10.1126/science.1257601&gt;.
p-values are calculates based on the permutation of nodes, you can set the full network to be
in the set for permutation or can select the ones you include as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separation_Significance(G, ST, Threads = 2, N = 1000, correct_by_target = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separation_Significance_+3A_g">G</code></td>
<td>
<p>The original graph (often an interactome / PPI).</p>
</td></tr>
<tr><td><code id="separation_Significance_+3A_st">ST</code></td>
<td>
<p>Set-Target data. It is a data.frame with two columns. ID and Target.</p>
</td></tr>
<tr><td><code id="separation_Significance_+3A_threads">Threads</code></td>
<td>
<p>How many threads you'd like to use (for parallel computation).</p>
</td></tr>
<tr><td><code id="separation_Significance_+3A_n">N</code></td>
<td>
<p>default to 1000. The number of permutations</p>
</td></tr>
<tr><td><code id="separation_Significance_+3A_correct_by_target">correct_by_target</code></td>
<td>
<p>TRUE by default. If you want to use the set of targets for the permutation or the full network.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
require(magrittr)
x = data.frame(n1 = sample(LETTERS[1:5]),
               n2 =  sample(LETTERS[1:20]))

D1 = data.frame(gene = c("H", "I", "S", "N", "A"), disease = "D1")
D2 = data.frame(gene = c("E", "C",  "R" , "J", "Q", "O"), disease = "D2")
D3 = data.frame(gene = c("E", "G", "T", "P"), disease = "D3")
D4 = data.frame(gene = c("A", "B", "E"), disease = "D4")
D5 = data.frame(gene = c("D", "F", "L"), disease = "D5")
D6 = data.frame(gene = c("D", "F", "K"), disease = "D6")
D7 = data.frame(gene = c("A", "B" ,"F", "K"), disease = "D7")

Diseases = rbind(D1, D2, D3, D4, D5, D6, D7)
Diseases %&lt;&gt;% dplyr::select(disease, gene)
g = igraph::graph_from_data_frame(x, directed = FALSE)
g = igraph::simplify(g)

separation_Significance(G = g,
ST = Diseases,
correct_by_target = FALSE,
Threads = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
