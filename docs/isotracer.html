<!DOCTYPE html><html><head><title>Help for package isotracer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isotracer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#isotracer-package'><p>The 'isotracer' package</p></a></li>
<li><a href='#+5B.networkModelStanfit'><p>Subset method for <code>networkModelStanfit</code> objects</p></a></li>
<li><a href='#add_covariates'><p>Add fixed effects of one or several covariates to some parameters.</p></a></li>
<li><a href='#add_pulse_event'><p>Register a pulse event on one of the compartment of a topology</p></a></li>
<li><a href='#aquarium_mod'><p>A simple aquarium network model, ready to run</p></a></li>
<li><a href='#aquarium_run'><p>An MCMC run from a simple aquarium network model</p></a></li>
<li><a href='#as_tbl_graph'><p>Generic for as_tbl_graph()</p></a></li>
<li><a href='#as_tbl_graph.topology'><p>Convert a network topology to a tbl_graph</p></a></li>
<li><a href='#as.mcmc.list.tidy_flows'><p>Convert a <code>tidy_flows</code> object to an <code>mcmc.list</code></p></a></li>
<li><a href='#as.mcmc.list.tidy_steady_states'><p>Convert a <code>tidy_steady_states</code> object to an <code>mcmc.list</code></p></a></li>
<li><a href='#available_priors'><p>List the available priors for model parameters</p></a></li>
<li><a href='#c.mcmc.list'><p>Combine mcmc.list objects</p></a></li>
<li><a href='#calculate_steady_state'><p>Calculate steady-state compartment sizes for a network</p></a></li>
<li><a href='#comps'><p>Return the compartments of a network model</p></a></li>
<li><a href='#constant_p'><p>Define a fixed-value prior</p></a></li>
<li><a href='#delta2prop'><p>Convert delta notation to proportion of heavy isotope</p></a></li>
<li><a href='#dic'><p>Calculate DIC from a model output</p></a></li>
<li><a href='#eelgrass'><p>Eelgrass phosphate incorporation data (McRoy &amp; Barsdate 1970)</p></a></li>
<li><a href='#exponential_p'><p>Define an exponential prior</p></a></li>
<li><a href='#filter'><p>Filter (alias for filter function from dplyr)</p></a></li>
<li><a href='#filter_by_group'><p>Filter a tibble based on the &quot;group&quot; column</p></a></li>
<li><a href='#filter.ppcNetworkModel'><p>Filter method for output of tidy_data_and_posterior_predict()</p></a></li>
<li><a href='#format.prior'><p>Pretty formatting of a <code>prior</code> object</p></a></li>
<li><a href='#format.prior_tibble'><p>Pretty formatting of a <code>prior_tibble</code> object</p></a></li>
<li><a href='#gamma_p'><p>Define a gamma prior</p></a></li>
<li><a href='#ggflows'><p>A quick-and-dirty way of visualizing relative flows in a network</p></a></li>
<li><a href='#ggtopo'><p>Plot a topology</p></a></li>
<li><a href='#ggtopo.networkModel'><p>Plot a network topology</p></a></li>
<li><a href='#ggtopo.topology'><p>Plot a topology</p></a></li>
<li><a href='#groups.networkModel'><p>Get the grouping for a <code>networkModel</code> object</p></a></li>
<li><a href='#hcauchy_p'><p>Define a half-Cauchy prior (on [0;+Inf])</p></a></li>
<li><a href='#lalaja'><p>Dataset for nitrogren fluxes in a Trinidadian mountain stream (Collins 2016)</p></a></li>
<li><a href='#li2017'><p>Protein degradation in Arabidopsis plants (Li et al. 2017)</p></a></li>
<li><a href='#Math.mcmc.list'><p>Math generics for mcmc.list objects</p></a></li>
<li><a href='#mcmc_heatmap'><p>Draw a heatmap based on the correlations between parameters</p></a></li>
<li><a href='#missing_priors'><p>Get a table with parameters which are missing priors</p></a></li>
<li><a href='#new_networkModel'><p>Create an empty network model</p></a></li>
<li><a href='#normal_p'><p>Define a truncated normal prior (on [0;+Inf])</p></a></li>
<li><a href='#obj_sum.prior'><p>Function used for displaying <code>prior</code> object in tibbles</p></a></li>
<li><a href='#Ops.mcmc.list'><p>Ops generics for <code>mcmc.list</code> objects</p></a></li>
<li><a href='#Ops.prior'><p>Implementation of the '==' operator for priors</p></a></li>
<li><a href='#Ops.topology'><p>Ops generics for <code>topology</code> objects</p></a></li>
<li><a href='#params'><p>Return the parameters of a network model</p></a></li>
<li><a href='#pillar_shaft.prior'><p>Function used for displaying <code>prior</code> object in tibbles</p></a></li>
<li><a href='#plot.networkModel'><p>Plot observations/trajectories/predictions from a network model</p></a></li>
<li><a href='#plot.ready_for_unit_plot'><p>Plot output from <code>split_to_unit_plot</code></p></a></li>
<li><a href='#posterior_predict'><p>Draw from the posterior predictive distribution of the model outcome</p></a></li>
<li><a href='#posterior_predict.networkModelStanfit'><p>Draw from the posterior predictive distribution of the model outcome</p></a></li>
<li><a href='#predict.networkModel'><p>Add a column with predictions from a fit</p></a></li>
<li><a href='#print.networkModel'><p>Print method for <code>networkModel</code> objects</p></a></li>
<li><a href='#print.prior'><p>Pretty printing of a <code>prior</code> object</p></a></li>
<li><a href='#print.prior_tibble'><p>Pretty printing of a <code>prior_tibble</code> object</p></a></li>
<li><a href='#print.topology'><p>Pretty printing of a <code>topology</code> object</p></a></li>
<li><a href='#priors'><p>Return the tibble containing the priors of a networkModel</p></a></li>
<li><a href='#project'><p>Calculate the trajectories of a network model</p></a></li>
<li><a href='#prop_family'><p>Return the distribution family for observed proportions</p></a></li>
<li><a href='#prop2delta'><p>Convert isotopic proportions to delta values</p></a></li>
<li><a href='#quick_sankey'><p>Draw a Sankey plot with basic defaults</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#run_mcmc'><p>Run a MCMC sampler on a network model using Stan</p></a></li>
<li><a href='#sample_from'><p>Generate samples from a network model</p></a></li>
<li><a href='#sample_from_prior'><p>Sample from a prior object</p></a></li>
<li><a href='#sample_params'><p>Sample parameter values from priors</p></a></li>
<li><a href='#sankey'><p>Draw a Sankey plot for a network and estimated flows</p></a></li>
<li><a href='#scaled_beta_p'><p>Define a beta prior (on [0;scale])</p></a></li>
<li><a href='#select.mcmc.list'><p>Select parameters based on their names</p></a></li>
<li><a href='#set_half_life'><p>Set the half-life for radioactive tracers</p></a></li>
<li><a href='#set_init'><p>Set initial conditions in a network model</p></a></li>
<li><a href='#set_obs'><p>Set observations in a network model</p></a></li>
<li><a href='#set_params'><p>Set the parameters in a network model</p></a></li>
<li><a href='#set_prior'><p>Set prior(s) for a network model</p></a></li>
<li><a href='#set_prop_family'><p>Set the distribution family for observed proportions</p></a></li>
<li><a href='#set_size_family'><p>Set the distribution family for observed sizes</p></a></li>
<li><a href='#set_split'><p>Flag some network compartments as being split compartments</p></a></li>
<li><a href='#set_steady'><p>Flag some network compartments as being in a steady state</p></a></li>
<li><a href='#set_topo'><p>Set the topology in a network model.</p></a></li>
<li><a href='#size_family'><p>Return the distribution family for observed sizes</p></a></li>
<li><a href='#stanfit_to_named_mcmclist'><p>Convert a Stanfit object to a nicely named mcmc.list object</p></a></li>
<li><a href='#tidy_data'><p>Extract data from a networkModel object into a tidy tibble.</p></a></li>
<li><a href='#tidy_dpp'><p>Prepare tidy data and posterior predictions</p></a></li>
<li><a href='#tidy_flows'><p>Build a tidy table with the flows for each iteration</p></a></li>
<li><a href='#tidy_mcmc'><p>Extract a tidy output from an mcmc.list</p></a></li>
<li><a href='#tidy_posterior_predict'><p>Draw from the posterior predictive distribution of the model outcome</p></a></li>
<li><a href='#tidy_steady_states'><p>Build a tidy table with the calculated steady states for each iteration</p></a></li>
<li><a href='#tidy_trajectories'><p>Build a tidy table with the trajectories for each iteration</p></a></li>
<li><a href='#topo'><p>Return the list of topologies, or a unique topology if all identical</p></a></li>
<li><a href='#traceplot'><p>Plot mcmc.list objects</p></a></li>
<li><a href='#trini_mod'><p>Network model for nitrogen fluxes in Trinidadian streams (Collins et al. 2016)</p></a></li>
<li><a href='#type_sum.prior'><p>Function used for displaying <code>prior</code> object in tibbles</p></a></li>
<li><a href='#uniform_p'><p>Define a uniform prior</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Isotopic Tracer Analysis Using MCMC</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian models to analyze data from tracer addition
    experiments. The implemented method was originally described in the article
    "A New Method to Reconstruct Quantitative Food Webs and Nutrient Flows from
    Isotope Tracer Addition Experiments" by López-Sepulcre et al. (2020)
    &lt;<a href="https://doi.org/10.1086%2F708546">doi:10.1086/708546</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/matthieu-bruneaux/isotracer">https://gitlab.com/matthieu-bruneaux/isotracer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/matthieu-bruneaux/isotracer/-/issues">https://gitlab.com/matthieu-bruneaux/isotracer/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, data.table, dplyr, latex2exp, magrittr, methods, pillar,
purrr, Rcpp, rlang, rstan (&ge; 2.26.0), rstantools, tibble,
tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot, covr, cowplot, ggdist, ggplot2, ggraph, gridBase,
gridExtra, here, igraph, knitr, lattice, readxl, rmarkdown,
testthat, tidygraph, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.72.0), Rcpp (&ge; 1.0.4), RcppEigen (&ge; 0.3.3.7.0),
StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 16:43:16 UTC; matthieu</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrés López-Sepulcre
    <a href="https://orcid.org/0000-0001-9708-0788"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Matthieu Bruneaux <a href="https://orcid.org/0000-0001-6997-192X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthieu Bruneaux &lt;matthieu.bruneaux@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 08:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='isotracer-package'>The 'isotracer' package</h2><span id='topic+isotracer-package'></span><span id='topic+isotracer'></span>

<h3>Description</h3>

<p>The isotracer package allows modelling of fluxes across a network of
compartments. Parameters are estimated using a Bayesian MCMC approach.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthieu Bruneaux <a href="mailto:matthieu.bruneaux@gmail.com">matthieu.bruneaux@gmail.com</a> (<a href="https://orcid.org/0000-0001-6997-192X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Andrés López-Sepulcre <a href="mailto:lopezsepulcre@gmail.com">lopezsepulcre@gmail.com</a> (<a href="https://orcid.org/0000-0001-9708-0788">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>López-Sepulcre, A., M. Bruneaux, S. M. Collins, R. El-Sabaawi,
A. S. Flecker, and S. A. Thomas. The American Naturalist
(2020). &quot;A New Method to Reconstruct Quantitative Food Webs and
Nutrient Flows from Isotope Tracer Addition Experiments.&quot;
https://doi.org/10.1086/708546.
</p>
<p>Stan Development Team (2018). RStan: the R interface to Stan. R package
version 2.18.2. https://mc-stan.org
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/matthieu-bruneaux/isotracer">https://gitlab.com/matthieu-bruneaux/isotracer</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/matthieu-bruneaux/isotracer/-/issues">https://gitlab.com/matthieu-bruneaux/isotracer/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.networkModelStanfit'>Subset method for <code>networkModelStanfit</code> objects</h2><span id='topic++5B.networkModelStanfit'></span>

<h3>Description</h3>

<p>Subset method for <code>networkModelStanfit</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModelStanfit'
x[i, j, drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.networkModelStanfit_+3A_x">x</code></td>
<td>
<p>A <code>networkModelStanfit</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B.networkModelStanfit_+3A_i">i</code></td>
<td>
<p>A vector of iteration indices.</p>
</td></tr>
<tr><td><code id="+2B5B.networkModelStanfit_+3A_j">j</code></td>
<td>
<p>A vector of parameter names or indices.</p>
</td></tr>
<tr><td><code id="+2B5B.networkModelStanfit_+3A_drop">drop</code></td>
<td>
<p>Boolean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModelStanfit</code> object.
</p>

<hr>
<h2 id='add_covariates'>Add fixed effects of one or several covariates to some parameters.</h2><span id='topic+add_covariates'></span>

<h3>Description</h3>

<p>Note that new global parameters are not given any default prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_covariates(nm, ..., use_regexpr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_covariates_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_...">...</code></td>
<td>
<p>One or several formulas defining the covariates.</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_use_regexpr">use_regexpr</code></td>
<td>
<p>Boolean, use regular expression to match the parameters
affected by the formulas?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a subset of the topology from the Trinidad case study
m &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi, FBOM", "epi -&gt; petro, pseph")

# Taking initial condtions from the 'lalaja' dataset at t=0
# Grouping by transect id
inits &lt;- lalaja[lalaja[["time.days"]] == 0, ]
inits
m &lt;- set_init(m, inits, comp = "compartment", size = "mgN.per.m2",
              prop = "prop15N", group_by = "transect")
m

# Default model
params(m, simplify = TRUE)

# Adding an effect of the "transect" covariate on some parameters
m &lt;- add_covariates(m, upsilon_epi_to_pseph ~ transect)
params(m, simplify = TRUE)

</code></pre>

<hr>
<h2 id='add_pulse_event'>Register a pulse event on one of the compartment of a topology</h2><span id='topic+add_pulse_event'></span>

<h3>Description</h3>

<p>When applied to a steady-state compartment, this is equivalent to changing
the steady state. Negative values are allowed, so one can add a &quot;pulse&quot; to a
steady-state compartment and then later add a similar but negative &quot;pulse&quot;
to simulate a drip in a stream for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pulse_event(nm, time, comp = NULL, unmarked, marked, which = NULL, pulses)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pulse_event_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_time">time</code></td>
<td>
<p>Numeric, time at which the pulse is happening.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_comp">comp</code></td>
<td>
<p>One compartment name only.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_unmarked">unmarked</code></td>
<td>
<p>Numeric, quantity of unmarked marker added.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_marked">marked</code></td>
<td>
<p>Numeric, quantity of marked marker added.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_which">which</code></td>
<td>
<p>Vector of integers giving the nm rows to update. Default is to
update all rows.</p>
</td></tr>
<tr><td><code id="add_pulse_event_+3A_pulses">pulses</code></td>
<td>
<p>Optionally, a tibble containing the pulse information in
columns. If provided, 'comp', 'time', 'unmarked' and 'marked' must be
strings giving the corresponding column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- trini_mod
m$events &lt;- NULL
pulses &lt;- tibble::tribble(
   ~ stream,    ~ transect, ~ comp, ~ time, ~ qty_14N, ~ qty_15N,
       "UL",  "transect.1",  "NH4",     11,         0,  -0.00569,
       "UL",  "transect.2",  "NH4",     11,         0,  -0.00264,
       "UL",  "transect.3",  "NH4",     11,         0, -0.000726,
       "UL",  "transect.1",  "NO3",     11,         0,  -0.00851,
       "UL",  "transect.2",  "NO3",     11,         0,  -0.01118,
       "UL",  "transect.3",  "NO3",     11,         0,  -0.01244,
   )
m &lt;- add_pulse_event(m, pulses = pulses, comp = "comp", time = "time",
                     unmarked = "qty_14N", marked = "qty_15N")
m
 

</code></pre>

<hr>
<h2 id='aquarium_mod'>A simple aquarium network model, ready to run</h2><span id='topic+aquarium_mod'></span>

<h3>Description</h3>

<p>This network model is the model used in the Quick Start tutorial
vignette. It is ready to be run at once with <code><a href="#topic+run_mcmc">run_mcmc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aquarium_mod
</code></pre>


<h3>Format</h3>

<p>An object of class <code>networkModel</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 1 rows and 4 columns.
</p>


<h3>Details</h3>

<p>The code used to built the model is given in the example section below.
</p>
<p>The <code><a href="#topic+aquarium_run">aquarium_run</a></code> dataset is a corresponding MCMC run.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
exp &lt;- tibble::tribble(
  ~time.day,  ~species, ~biomass, ~prop15N,
          0,   "algae",     1.02,  0.00384,
          1,   "algae",       NA,   0.0534,
        1.5,   "algae",    0.951,       NA,
          2,   "algae",    0.889,   0.0849,
        2.5,   "algae",       NA,   0.0869,
          3,   "algae",    0.837,   0.0816,
          0, "daphnia",     1.74,  0.00464,
          1, "daphnia",       NA,  0.00493,
        1.5, "daphnia",     2.48,       NA,
          2, "daphnia",       NA,  0.00831,
        2.5, "daphnia",     2.25,       NA,
          3, "daphnia",     2.15,   0.0101,
          0,     "NH4",    0.208,     0.79,
          1,     "NH4",    0.227,       NA,
        1.5,     "NH4",       NA,    0.482,
          2,     "NH4",    0.256,    0.351,
        2.5,     "NH4",       NA,    0.295,
          3,     "NH4",     0.27,        NA
  )
inits &lt;- exp %&gt;% dplyr::filter(time.day == 0)
obs &lt;- exp %&gt;% dplyr::filter(time.day &gt; 0)

aquarium_mod &lt;- new_networkModel() %&gt;%
    set_topo("NH4 -&gt; algae -&gt; daphnia -&gt; NH4") %&gt;%
    set_init(inits, comp = "species", size = "biomass",
             prop = "prop15N") %&gt;%
    set_obs(obs, comp = "species", size = "biomass",
                  prop = "prop15N", time = "time.day")

</code></pre>

<hr>
<h2 id='aquarium_run'>An MCMC run from a simple aquarium network model</h2><span id='topic+aquarium_run'></span>

<h3>Description</h3>

<p>This is an MCMC run on <code><a href="#topic+aquarium_mod">aquarium_mod</a></code>. The code used to run the
MCMC is: <code>aquarium_run &lt;- run_mcmc(aquarium_mod, thin = 4)</code> (note that
<code>thin = 4</code> was only used here to reduce the size of the data file
shipped with the package, but for a real-life analysis keeping the default
<code>thin = 1</code> is usually recommended). The code used to build the model
itself is given in the help page for <code><a href="#topic+aquarium_mod">aquarium_mod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aquarium_run
</code></pre>


<h3>Format</h3>

<p>An object of class <code>networkModelStanfit</code> (inherits from <code>mcmc.list</code>) of length 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(aquarium_run)
summary(aquarium_run)

## End(Not run)
</code></pre>

<hr>
<h2 id='as_tbl_graph'>Generic for as_tbl_graph()</h2><span id='topic+as_tbl_graph'></span>

<h3>Description</h3>

<p>Convert a compatible object to a tbl_graph object (from the tidygraph package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tbl_graph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tbl_graph_+3A_x">x</code></td>
<td>
<p>Object to convert to a tbl_graph.</p>
</td></tr>
<tr><td><code id="as_tbl_graph_+3A_...">...</code></td>
<td>
<p>Passed to the appropriate method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object.
</p>

<hr>
<h2 id='as_tbl_graph.topology'>Convert a network topology to a tbl_graph</h2><span id='topic+as_tbl_graph.topology'></span>

<h3>Description</h3>

<p>Convert a network topology to a tbl_graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'topology'
as_tbl_graph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tbl_graph.topology_+3A_x">x</code></td>
<td>
<p>A network topology.</p>
</td></tr>
<tr><td><code id="as_tbl_graph.topology_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object.
</p>

<hr>
<h2 id='as.mcmc.list.tidy_flows'>Convert a <code>tidy_flows</code> object to an <code>mcmc.list</code></h2><span id='topic+as.mcmc.list.tidy_flows'></span>

<h3>Description</h3>

<p>Convert a <code>tidy_flows</code> object to an <code>mcmc.list</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_flows'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.tidy_flows_+3A_x">x</code></td>
<td>
<p>A tidy flow object, as returned by <code><a href="#topic+tidy_flows">tidy_flows</a></code>. Note
that all chains must have the same iterations extracted (i.e. you must
use <code>n_per_chain</code> when calling <code><a href="#topic+tidy_flows">tidy_flows</a></code>).</p>
</td></tr>
<tr><td><code id="as.mcmc.list.tidy_flows_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mcmc.list</code> object, with ordered iterations.
</p>

<hr>
<h2 id='as.mcmc.list.tidy_steady_states'>Convert a <code>tidy_steady_states</code> object to an <code>mcmc.list</code></h2><span id='topic+as.mcmc.list.tidy_steady_states'></span>

<h3>Description</h3>

<p>Convert a <code>tidy_steady_states</code> object to an <code>mcmc.list</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_steady_states'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.tidy_steady_states_+3A_x">x</code></td>
<td>
<p>A tidy steady states object, as returned by
<code><a href="#topic+tidy_steady_states">tidy_steady_states</a></code>. Note that all chains must have the
same iterations extracted (i.e. you must use <code>n_per_chain</code> when
calling <code><a href="#topic+tidy_flows">tidy_flows</a></code>).</p>
</td></tr>
<tr><td><code id="as.mcmc.list.tidy_steady_states_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mcmc.list</code> object, with ordered iterations.
</p>

<hr>
<h2 id='available_priors'>List the available priors for model parameters</h2><span id='topic+available_priors'></span>

<h3>Description</h3>

<p>List the available priors for model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_priors()
</code></pre>


<h3>Value</h3>

<p>A tibble containing information about the available priors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>available_priors()

</code></pre>

<hr>
<h2 id='c.mcmc.list'>Combine mcmc.list objects</h2><span id='topic+c.mcmc.list'></span>

<h3>Description</h3>

<p>Combine mcmc.list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc.list'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.mcmc.list_+3A_...">...</code></td>
<td>
<p><code>mcmc.list</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mcmc.list</code> object.
</p>

<hr>
<h2 id='calculate_steady_state'>Calculate steady-state compartment sizes for a network</h2><span id='topic+calculate_steady_state'></span>

<h3>Description</h3>

<p>This is an experimental function. It attempts to calculate steady-state
compartment sizes using the set parameter values and the initial compartment
sizes. Use it with caution!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_steady_state(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_steady_state_+3A_nm">nm</code></td>
<td>
<p>A network model, with set parameter values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note about how steady state sizes for split compartments are calculated: the
steady size of the active portion is calculated divide it is divided by the
active fraction (portion.act parameter) to get the total size including the
refractory portion. In this case we get a &quot;steady-state&quot; refractory portion,
consistent with steady state size of active fraction and with portion.act
parameter.
</p>


<h3>Value</h3>

<p>A tibble containing steady-state compartment sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- aquarium_mod
m &lt;- set_prior(m, constant_p(0), "lambda")
m &lt;- set_params(m, sample_params(m))
proj &lt;- project(m, end = 40)
plot(proj)

z &lt;- calculate_steady_state(m)
z
z$stable_sizes

</code></pre>

<hr>
<h2 id='comps'>Return the compartments of a network model</h2><span id='topic+comps'></span>

<h3>Description</h3>

<p>Return the compartments of a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comps(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comps_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors, with one list element per row of the
input network model (list elements are in the same order as the input
network model rows). Each list element containing the names of the
compartments in the topology defined in the corresponding row of the
input network model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aquarium_mod
comps(aquarium_mod)

trini_mod
comps(trini_mod)

</code></pre>

<hr>
<h2 id='constant_p'>Define a fixed-value prior</h2><span id='topic+constant_p'></span>

<h3>Description</h3>

<p>This is equivalent to having a fixed parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant_p(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_p_+3A_value">value</code></td>
<td>
<p>The constant value of the parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constant_p(2)

</code></pre>

<hr>
<h2 id='delta2prop'>Convert delta notation to proportion of heavy isotope</h2><span id='topic+delta2prop'></span>

<h3>Description</h3>

<p>For details and references about quantities used in expressing isotopic
ratios, see:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta2prop(x = NULL, Rstandard = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta2prop_+3A_x">x</code></td>
<td>
<p>Vector of delta values.</p>
</td></tr>
<tr><td><code id="delta2prop_+3A_rstandard">Rstandard</code></td>
<td>
<p>String describing the isotopic measurement, e.g. &quot;d15N&quot;,
&quot;d13C&quot; and used to set automatically Rstandards (see the Section
&quot;Ratios for reference standards&quot; for more details). Alternatively, a
numeric value to use for Rstandard, e.g. 0.0036765.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- Figure 1 in Coplen, Tyler B. “Guidelines and Recommended Terms for
Expression of Stable-Isotope-Ratio and Gas-Ratio Measurement Results.” Rapid
Communications in Mass Spectrometry 25, no. 17 (September 15, 2011):
2538–60. https://doi.org/10.1002/rcm.5129.
</p>
<p>- Table 2.1 in Fry, Brian. Stable Isotope Ecology. New York:
Springer-Verlag, 2006. //www.springer.com/gp/book/9780387305134.
</p>


<h3>Value</h3>

<p>A vector of same length of x, containing the proportion (numeric
between 0 and 1) of heavy isotope based on the delta values and the
Rstandard provided.
</p>


<h3>Ratios for reference standards</h3>

<p>The ratios for reference standards are taken from the Table 2.1 from Fry
2006. Note that the values used for oxygen isotopes are from the standard
mean ocean water (SMOW).
</p>
<p>Standards recognized by this function are: <code>c("d15N", "d2H", "d13C",
"d17O.SMOW", "d18O.SMOW", "d33S", "d34S", "d36S")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deltas &lt;- c(78, 5180, 263, 1065, NA, 153, 345)

# Rstandard can be specified with a string for some preset references
prop15N &lt;- delta2prop(deltas, "d15N")
prop13C &lt;- delta2prop(deltas, "d13C")

# Rstandard can also be specified manually for non-preset references
prop15N_manual &lt;- delta2prop(deltas, 0.0036765)
prop13C_manual &lt;- delta2prop(deltas, 0.011180)

# Call delta2prop() to get the detail of available references
delta2prop()

</code></pre>

<hr>
<h2 id='dic'>Calculate DIC from a model output</h2><span id='topic+dic'></span>

<h3>Description</h3>

<p>Note that DIC might not be indicated for network models, as the posteriors
are often not multinormal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic(..., weight = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic_+3A_...">...</code></td>
<td>
<p>One or several <code>mcmc.list</code> objects, output(s) from
<code><a href="#topic+run_mcmc">run_mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="dic_+3A_weight">weight</code></td>
<td>
<p>Boolean, if TRUE calculate DIC weights based on Link and
Barker 2010 (Link, W. A., and R. J. Barker. 2010. Bayesian Inference
With Ecological Applications. Amsterdam Boston Heidelberg London:
Elsevier/Academic Press).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LOO is probably not a good choice either since the data is akin to a time
series (so data points are not independent). Maybe WAIC could be an option?
(TODO: read about this.)
</p>
<p>DIC is calculated as:
</p>
<p>DIC = Dbar + pD
</p>
<p>where D are deviance values calculated as -2 * loglik for each MCMC
iteration, Dbar is the mean deviance value and pD is the effective number of
parameters in the model and can be calculated as var(D)/2 (Gelman 2003).
</p>


<h3>Value</h3>

<p>A tibble with one row per <code>mcmc.list</code> object provided in
<code>...</code>. This tibble is sorted by DIC, so the row order might be
different from the <code>mcmc.list</code> objects order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define two different models
m1 &lt;- aquarium_mod
m2 &lt;- set_topo(m1, c("NH4 -&gt; algae -&gt; daphnia -&gt; NH4", "algae -&gt; NH4"))
m2 &lt;- set_priors(m2, priors(m1))
m2 &lt;- set_priors(m2, normal_p(0, 0.5), "upsilon_algae_to_NH4")
# Run the models
r1 &lt;- run_mcmc(m1, chains = 2)
r2 &lt;- run_mcmc(m2, chains = 2)
# Model comparison with DIC
dic(r1, r2)


</code></pre>

<hr>
<h2 id='eelgrass'>Eelgrass phosphate incorporation data (McRoy &amp; Barsdate 1970)</h2><span id='topic+eelgrass'></span>

<h3>Description</h3>

<p>Dataset built from the article &quot;Phosphate absorption in eelgrass&quot; by McRoy
and Barsdate (1970)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eelgrass
</code></pre>


<h3>Format</h3>

<p>Tibble with columns
</p>

<dl>
<dt>light_treatment</dt><dd><p>Light treatment: &quot;light&quot; or &quot;dark&quot;.</p>
</dd>
<dt>addition_site</dt><dd><p>The location where 32P phosphate was added: in the
&quot;upper&quot; water compartment or in the &quot;lower&quot; water compartment.</p>
</dd>
<dt>compartment</dt><dd><p>Obsered compartment, one of &quot;leaves_stem&quot;,
&quot;roots_rhizome&quot;, &quot;upper_water&quot;, or &quot;lower_water&quot;.</p>
</dd>
<dt>time_min</dt><dd><p>Elapsed time in minutes since the 32P addition.</p>
</dd>
<dt>n_32P_per_mg</dt><dd><p>Number of 32P atoms per mg (estimated from Figure 2 of
the original paper).</p>
</dd>
<dt>mass_mg</dt><dd><p>Compartment mass in mg (taken from Table 1 of the original
paper). Assumed constant during the experiment.</p>
</dd>
<dt>n_32P</dt><dd><p>Number of 32P atoms in the compartment. Calculated from the
two previous columns.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In brief, the experimental setup consists in individual eelgrass plants
placed in 250 ml containers. Each container is partitioned by a layer of
paraffin into an upper water compartment (containing the leaves and stems)
and a lower water compartment (containing the roots and rhizomes).
</p>
<p>Radioactive phosphorus (32P) is added as phosphate either in the upper or
lower water compartment in each container. Containers were incubated either
in light or dark conditions.
</p>
<p>Tissue samples were collected and dried at various time points and 32P
activity was measured (Figure 2 in the original paper). Biomass estimates in
initial conditions were given in Table 1 of the original paper.
</p>


<h3>Data preparation</h3>

<p>The data for 32P abundance per mg is extracted from Figure 2 of the original
article. Atom counts per mg were derived from cpm per mg using a half-life
value of 14.268 days for 32P.
</p>
<p>For simplicity and in order to be able to match the 32P data with the
biomass data (see below), only four compartments are considerd in the
package dataset. Upper and lower water compartments match the compartments
from the original article. &quot;Leaf and stem&quot; pools the original compartments
&quot;leaf tip&quot;, &quot;leaf middle&quot;, &quot;leaf base&quot;, and &quot;stem&quot;. &quot;Roots and rhizome&quot;
pools the original compartments &quot;root&quot; and &quot;rhizome&quot;. Pooling is done by
averaging the cpm per mg data, thereby making the rough approximation that
each component of the pool contributes the same biomass as the other
components.
</p>
<p>The biomass data is taken from Table 1 in the original paper. Experimental
containers had 160 cc of seawater in the upper compartment and 80 cc of
seawater in the lower compartment. Based on comparison with data from
Risgaard-Petersen 1998, I assumed that the biomasses for tissues were given
in dry weight. I assumed that this was also the case for the cpm/mg data
(i.e. cpm/mg of dry weight).
</p>


<h3>Source</h3>

<p>Data was taken from the figures and tables of the original
paper. The original paper is: McRoy, C. Peter, and Robert
J. Barsdate. “Phosphate Absorption in Eelgrass1.” Limnology and
Oceanography 15, no. 1 (January 1, 1970):
6–13. https://doi.org/10.4319/lo.1970.15.1.0006.
</p>

<hr>
<h2 id='exponential_p'>Define an exponential prior</h2><span id='topic+exponential_p'></span>

<h3>Description</h3>

<p>Define an exponential prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_p(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_p_+3A_lambda">lambda</code></td>
<td>
<p>Lambda parameter (rate) of the exponential distribution. The
mean of the exponential distribution is 1/lambda.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exponential_p(0.5)

</code></pre>

<hr>
<h2 id='filter'>Filter (alias for filter function from dplyr)</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>Filter (alias for filter function from dplyr)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>Data to filter.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>Passed to dplyr::filter.</p>
</td></tr>
<tr><td><code id="filter_+3A_preserve">preserve</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the returned value for dplyr::filter.
</p>

<hr>
<h2 id='filter_by_group'>Filter a tibble based on the &quot;group&quot; column</h2><span id='topic+filter_by_group'></span>

<h3>Description</h3>

<p>This function can be used to filter any tibble (e.g. network model object)
that has a &quot;group&quot; column. See the Examples for more details and syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_by_group(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_by_group_+3A_.data">.data</code></td>
<td>
<p>A tibble that has a 'group' column, such as a 'networkModel'
object.</p>
</td></tr>
<tr><td><code id="filter_by_group_+3A_...">...</code></td>
<td>
<p>Conditional expressions for filtering (see the Examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble similar to the input object, but with rows filtered based
on <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trini_mod
trini_mod$group
groups(trini_mod)
filter_by_group(trini_mod, stream == "LL", transect == "transect.1")
filter_by_group(trini_mod, transect == "transect.1")
## Not run: 
# The code below would raise an error because there is no "color" grouping variable.
filter_by_group(trini_mod, color == "red")

## End(Not run)

</code></pre>

<hr>
<h2 id='filter.ppcNetworkModel'>Filter method for output of tidy_data_and_posterior_predict()</h2><span id='topic+filter.ppcNetworkModel'></span>

<h3>Description</h3>

<p>Filter method for output of tidy_data_and_posterior_predict()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppcNetworkModel'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.ppcNetworkModel_+3A_.data">.data</code></td>
<td>
<p>A ppcNetworkModel object.</p>
</td></tr>
<tr><td><code id="filter.ppcNetworkModel_+3A_...">...</code></td>
<td>
<p>Passed to dplyr::filter.</p>
</td></tr>
<tr><td><code id="filter.ppcNetworkModel_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pccNetworkModel object filtered appropriately based on the
[[&quot;vars&quot;]] tibble.
</p>

<hr>
<h2 id='format.prior'>Pretty formatting of a <code>prior</code> object</h2><span id='topic+format.prior'></span>

<h3>Description</h3>

<p>Pretty formatting of a <code>prior</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.prior_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior</code>.</p>
</td></tr>
<tr><td><code id="format.prior_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string for pretty printing of a prior.
</p>

<hr>
<h2 id='format.prior_tibble'>Pretty formatting of a <code>prior_tibble</code> object</h2><span id='topic+format.prior_tibble'></span>

<h3>Description</h3>

<p>Pretty formatting of a <code>prior_tibble</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior_tibble'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.prior_tibble_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior_tibble</code>.</p>
</td></tr>
<tr><td><code id="format.prior_tibble_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string for pretty printing of a prior tibble.
</p>

<hr>
<h2 id='gamma_p'>Define a gamma prior</h2><span id='topic+gamma_p'></span>

<h3>Description</h3>

<p>Note the name of the function to define a prior (<code>gamma_p</code>), in order
to avoid confusion with the R mathematical function <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_p(alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_p_+3A_alpha">alpha</code></td>
<td>
<p>Shape parameter (equivalent to the <code>shape</code> parameter of
R's <code>rgamma</code>).</p>
</td></tr>
<tr><td><code id="gamma_p_+3A_beta">beta</code></td>
<td>
<p>Rate parameter (equivalent to the <code>rate</code> parameter of R's
<code>rgamma</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gamma_p(9, 2)
hist(sample_from_prior(gamma_p(9, 2), 1e3))

</code></pre>

<hr>
<h2 id='ggflows'>A quick-and-dirty way of visualizing relative flows in a network</h2><span id='topic+ggflows'></span>

<h3>Description</h3>

<p>A quick-and-dirty way of visualizing relative flows in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggflows(x, layout = "auto", edge = "fan", max_width, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggflows_+3A_x">x</code></td>
<td>
<p>A tibble with the flow estimates, with columns &quot;from&quot;, &quot;to&quot;, and
&quot;flow&quot;.</p>
</td></tr>
<tr><td><code id="ggflows_+3A_layout">layout</code></td>
<td>
<p>Optional, layout to use (e.g. &quot;sugiyama&quot;, &quot;kk&quot;, &quot;stress&quot;)</p>
</td></tr>
<tr><td><code id="ggflows_+3A_edge">edge</code></td>
<td>
<p>&quot;curve&quot; (the default), &quot;line&quot; or &quot;fan&quot;.</p>
</td></tr>
<tr><td><code id="ggflows_+3A_max_width">max_width</code></td>
<td>
<p>Optional, numeric giving the maximum edge width (minimum
width is always 1).</p>
</td></tr>
<tr><td><code id="ggflows_+3A_legend">legend</code></td>
<td>
<p>Boolean, display edge width legend?</p>
</td></tr>
<tr><td><code id="ggflows_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggraph")) {
  z &lt;- tibble::tribble(
               ~from,               ~to,            ~flow,
     "leavesAndStem", "rootsAndRhizome", 333.929866077124,
        "lowerWater", "rootsAndRhizome", 4425.15780019304,
   "rootsAndRhizome",   "leavesAndStem", 525.208837577916,
        "upperWater",   "leavesAndStem", 11224.0814971855
  )
  ggflows(z)
  ggflows(z, max_width = 15)
}

</code></pre>

<hr>
<h2 id='ggtopo'>Plot a topology</h2><span id='topic+ggtopo'></span>

<h3>Description</h3>

<p>A quick plot using ggraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggtopo(x, layout = "auto", edge = "fan", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtopo_+3A_x">x</code></td>
<td>
<p>A network model or a topology matrix.</p>
</td></tr>
<tr><td><code id="ggtopo_+3A_layout">layout</code></td>
<td>
<p>Optional, layout to use (e.g. &quot;sugiyama&quot;, &quot;kk&quot;, &quot;stress&quot;)</p>
</td></tr>
<tr><td><code id="ggtopo_+3A_edge">edge</code></td>
<td>
<p>&quot;fan&quot; (the default) or &quot;line&quot; or &quot;curve&quot;.</p>
</td></tr>
<tr><td><code id="ggtopo_+3A_...">...</code></td>
<td>
<p>Passed to the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggraph")) {
  ggtopo(aquarium_mod, edge = "line")
}

</code></pre>

<hr>
<h2 id='ggtopo.networkModel'>Plot a network topology</h2><span id='topic+ggtopo.networkModel'></span>

<h3>Description</h3>

<p>A quick plot using ggraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModel'
ggtopo(x, layout = "auto", edge = "fan", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtopo.networkModel_+3A_x">x</code></td>
<td>
<p>A topology matrix.</p>
</td></tr>
<tr><td><code id="ggtopo.networkModel_+3A_layout">layout</code></td>
<td>
<p>Optional, layout to use (e.g. &quot;sugiyama&quot;, &quot;kk&quot;, &quot;stress&quot;)</p>
</td></tr>
<tr><td><code id="ggtopo.networkModel_+3A_edge">edge</code></td>
<td>
<p>&quot;curve&quot; (the default) or &quot;line&quot;.</p>
</td></tr>
<tr><td><code id="ggtopo.networkModel_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggraph")) {
  ggtopo(aquarium_mod, edge = "line")
  ggtopo(trini_mod)
}

</code></pre>

<hr>
<h2 id='ggtopo.topology'>Plot a topology</h2><span id='topic+ggtopo.topology'></span>

<h3>Description</h3>

<p>A quick plot using ggraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'topology'
ggtopo(x, layout = "auto", edge = "fan", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtopo.topology_+3A_x">x</code></td>
<td>
<p>A topology matrix.</p>
</td></tr>
<tr><td><code id="ggtopo.topology_+3A_layout">layout</code></td>
<td>
<p>Optional, layout to use (e.g. &quot;sugiyama&quot;, &quot;kk&quot;, &quot;stress&quot;)</p>
</td></tr>
<tr><td><code id="ggtopo.topology_+3A_edge">edge</code></td>
<td>
<p>&quot;curve&quot; (the default), &quot;line&quot; or &quot;fan&quot;.</p>
</td></tr>
<tr><td><code id="ggtopo.topology_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggraph")) {
  z &lt;- topo(aquarium_mod)
  ggtopo(z)
  ggtopo(z, edge = "line")

  z &lt;- topo(trini_mod)
  ggtopo(z)

  # For finer control, one can build a tbl_graph from the topology and
  # use ggraph directly
  x &lt;- as_tbl_graph(z)
  library(ggraph)
  ggraph(x) + geom_edge_link()
}

</code></pre>

<hr>
<h2 id='groups.networkModel'>Get the grouping for a <code>networkModel</code> object</h2><span id='topic+groups.networkModel'></span>

<h3>Description</h3>

<p>Get the grouping for a <code>networkModel</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModel'
groups(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups.networkModel_+3A_x">x</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble giving the grouping variable(s) for the input network
model. This tibble is in the same order as the rows of the input network
model. If the input network model did not have any grouping variable,
returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>groups(aquarium_mod)
groups(trini_mod)

</code></pre>

<hr>
<h2 id='hcauchy_p'>Define a half-Cauchy prior (on [0;+Inf])</h2><span id='topic+hcauchy_p'></span>

<h3>Description</h3>

<p>Define a half-Cauchy prior (on [0;+Inf])
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcauchy_p(scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hcauchy_p_+3A_scale">scale</code></td>
<td>
<p>Median of the half-Cauchy distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hcauchy_p(scale = 0.5)

</code></pre>

<hr>
<h2 id='lalaja'>Dataset for nitrogren fluxes in a Trinidadian mountain stream (Collins 2016)</h2><span id='topic+lalaja'></span>

<h3>Description</h3>

<p>Dataset built from the article &quot;Fish introductions and light modulate food
web fluxes in tropical streams: a whole-ecosystem experimental approach” by
Collins et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lalaja
</code></pre>


<h3>Format</h3>

<p>Tibble with columns
</p>

<dl>
<dt>stream</dt><dd><p>Stream identity. It is always &quot;UL&quot; (for &quot;Upper lalaja&quot;) in
this dataset. See the model <code>trini_mod</code> also shipped with the
package for the full dataset from the original Collins et al. study,
including data from the Lower Lajaja stream.</p>
</dd>
<dt>transect</dt><dd><p>Transect identity. Three transects were sampled downstream
of the drip location: <code>c("transect.1", "transect.2",
    "transect.3")</code>.</p>
</dd>
<dt>compartment</dt><dd><p>Foodweb compartments. Eight compartments are included
in this dataset: &quot;NH4&quot;, dissolved ammonium; &quot;NH3&quot;, dissolved nitrate;
&quot;epi&quot;, epilithon (primary producers growing on the surface of rocks on
the stream bed); &quot;FBOM&quot;, fine benthic organic material; &quot;tricor&quot;,
<em>Tricorythodes</em> (invertebrate); &quot;pseph&quot;, <em>Psephenus</em>
(invertebrate); &quot;petro&quot;, <em>Petrophila</em> (invertebrate); &quot;arg&quot;,
<em>Argia</em> (invertebrate).</p>
</dd>
<dt>mgN.per.m2</dt><dd><p>Size of compartment, in mg of nitrogen per m2.</p>
</dd>
<dt>prop15N</dt><dd><p>Proportion of 15N nitrogen in a compartment nitrogen pool
(i.e. 15N / (15N + 14N)).</p>
</dd>
<dt>time.days</dt><dd><p>Sampling time, in days.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In the original study, 15N-enriched ammonium was dripped into two mountain
streams in Trinidad (Upper Lalaja stream and Lower Lalaja stream) and
samples of the different foodweb compartments were taken during the drip and
after the drip in several transects in each stream. The transects were
located at different locations downstream of each drip. There were three
transects per stream. The drip phase lasted 10 days, and the post-drip phase
lasted 30 days. The complete dataset from the original study is available in the
<code>trini_mod</code> model shipped with the <code>isotracer</code> package.
</p>
<p>The <code>lalaja</code> dataset is a subset of the full dataset and is used for
illustrative purpose in the &quot;Trinidadian streams&quot; case study, which is part
of the documentation of <code>isotracer</code>. It contains only the data for the
Upper Lalaja stream, and for some but not all of the foodweb compartments.
</p>
<p>For more details about the dripping regime and how to use this dataset in a
network model, one should refer to the case study in the <code>isotracer</code>
package documentation.
</p>


<h3>Source</h3>

<p>This network model contains data from the original article: Collins, Sarah
M., Steven A. Thomas, Thomas Heatherly, Keeley L. MacNeill, Antoine
O.H.C. Leduc, Andrés López-Sepulcre, Bradley A. Lamphere, et al. 2016. “Fish
Introductions and Light Modulate Food Web Fluxes in Tropical Streams: A
Whole-Ecosystem Experimental Approach.” Ecology, &lt;doi:10.1002/ecy.1530&gt;.
</p>
<p>This dataset was also used in the paper: López-Sepulcre, Andrés, Matthieu
Bruneaux, Sarah M. Collins, Rana El-Sabaawi, Alexander S. Flecker, and
Steven A. Thomas. 2020. “A New Method to Reconstruct Quantitative Food Webs
and Nutrient Flows from Isotope Tracer Addition Experiments.” The American
Naturalist 195 (6): 964–85. &lt;doi:10.1086/708546&gt;.
</p>

<hr>
<h2 id='li2017'>Protein degradation in Arabidopsis plants (Li et al. 2017)</h2><span id='topic+li2017'></span><span id='topic+li2017_prots'></span><span id='topic+li2017_counts'></span>

<h3>Description</h3>

<p>Dataset built from the Dryad depository entry associated with the article
&quot;Protein degradation rate in Arabidopsis thaliana leaf growth and development&quot;
by Li et al. (2017)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>li2017
</code></pre>


<h3>Format</h3>

<p><code>li2017</code> is the main dataset and is a tibble with columns:
</p>

<dl>
<dt>prot_id</dt><dd><p>Protein identifier. Can be matched to a more explicit
protein description in <code>li2017_prots</code>.</p>
</dd>
<dt>sample</dt><dd><p>Sample identity. Different samples were used for relative
abundance measurements and labelled fraction measurements.</p>
</dd>
<dt>rel_abundance</dt><dd><p>Relative abundance compared to a reference sample.</p>
</dd>
<dt>labeled_fraction</dt><dd><p>Proportion of 15N in the protein.</p>
</dd>
<dt>time_day</dt><dd><p>Time elapsed since growth medium switch to 15N, in days.</p>
</dd>
<dt>leaf_id</dt><dd><p>Leaf identity (3rd, 5th, or 7th leaf of individual plants).</p>
</dd>
</dl>

<p><code>li2017_prots</code> maps protein identifiers to protein descriptions
and is a tibble with columns:
</p>

<dl>
<dt>prot_id</dt><dd><p>Protein identifier. Can be matched with the same column in
<code>li2017</code>.</p>
</dd>
<dt>description</dt><dd><p>Protein description</p>
</dd>
</dl>

<p><code>li2017_counts</code> is a summary table counting the number of
available data points for relative abundance and labelled fraction for
each protein in <code>li2017</code>. It is a tibble with columns:
</p>

<dl>
<dt>prot_id</dt><dd><p>Protein identifier. Can be matched with the same column in
<code>li2017</code>.</p>
</dd>
<dt>n_abundance_data</dt><dd><p>Number of relative abundance data points for a
given protein.</p>
</dd>
<dt>n_labelling_data</dt><dd><p>Number of labelled fraction data points for a
given protein.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this study, the authors used a growth medium containing 15N to grow
21-day old Arabidopsis plants which were grown on a natural 14N/15N medium
until that day. The third, fifth and seventh leaves were sampled from
individuals at different time points after the medium switch (0, 1, 3 and 5
days). Proteins were identified and labelled fractions were measured using
mass spectrometry. Relative protein abundances were determined in comparison
with a reference sample.
</p>
<p>The aim of the authors was to quantify in vivo degradation rates for as many
proteins as possible (1228 proteins in the original paper) and examine which
determinants had an effect or not on protein degradation rates (e.g. protein
domains, protein complex membership, ...).
</p>
<p>Three datasets were extracted from the large dataset available on Dryad for
packaging inside isotracer: <code>li2017</code>, <code>li2017_prots</code>, and
<code>li2017_counts</code>.
</p>


<h3>Source</h3>

<p>Data was taken from the following Dryad repository: Li, Lei, Clark
J. Nelson, Josua Troesch, Ian Castleden, Shaobai Huang, and A. Harvey
Millar. “Data from: Protein Degradation Rate in Arabidopsis Thaliana
Leaf Growth and Development.” Dryad,
2018. https://doi.org/10.5061/DRYAD.Q3H85.
</p>
<p>The Dryad repository was associated with the following paper: Li,
Lei, Clark J. Nelson, Josua Trösch, Ian Castleden, Shaobai Huang, and
A. Harvey Millar. “Protein Degradation Rate in Arabidopsis Thaliana Leaf
Growth and Development.” The Plant Cell 29, no. 2 (February 1, 2017):
207–28. https://doi.org/10.1105/tpc.16.00768.
</p>

<hr>
<h2 id='Math.mcmc.list'>Math generics for mcmc.list objects</h2><span id='topic+Math.mcmc.list'></span>

<h3>Description</h3>

<p>Math generics for mcmc.list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc.list'
Math(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.mcmc.list_+3A_x">x</code></td>
<td>
<p><code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object</p>
</td></tr>
<tr><td><code id="Math.mcmc.list_+3A_...">...</code></td>
<td>
<p>Other arguments passed to corresponding methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mcmc.list</code> object (with the added class
<code>derived.mcmc.list</code>).
</p>

<hr>
<h2 id='mcmc_heatmap'>Draw a heatmap based on the correlations between parameters</h2><span id='topic+mcmc_heatmap'></span>

<h3>Description</h3>

<p>Note that the colors represent the strength of the correlations (from 0 to
1), but do not inform about their sign. The method used to calculate
correlation coefficients is Spearman's rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_heatmap(x, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_heatmap_+3A_x">x</code></td>
<td>
<p>A <code>coda::mcmc.list</code> object.</p>
</td></tr>
<tr><td><code id="mcmc_heatmap_+3A_col">col</code></td>
<td>
<p>Optional, vectors of colors defining the color ramp. Default uses
the divergent palette &quot;Blue-Red 2&quot; from the colorspace package.</p>
</td></tr>
<tr><td><code id="mcmc_heatmap_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+heatmap">heatmap</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side effect (plotting).
</p>

<hr>
<h2 id='missing_priors'>Get a table with parameters which are missing priors</h2><span id='topic+missing_priors'></span>

<h3>Description</h3>

<p>Get a table with parameters which are missing priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_priors(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_priors_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the parameters which are missing a prior. If no
priors are missing, the tibble contains zero row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a subset of the topology from the Trinidad case study
m &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi, FBOM", "epi -&gt; petro, pseph")

# No prior is set by default
priors(m)

# Set some priors
m &lt;- set_priors(m, normal_p(0, 10), "lambda")
priors(m)

# Which parameters are missing a prior?
missing_priors(m)

</code></pre>

<hr>
<h2 id='new_networkModel'>Create an empty network model</h2><span id='topic+new_networkModel'></span>

<h3>Description</h3>

<p>The first step in building a network model is to create a new, empty
<code>networkModel</code> object. This model can then be completed using functions
such as <code>set_topo()</code>, <code>set_init()</code>, etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_networkModel(quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_networkModel_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>FALSE</code> print a message indicating which
distribution family is used for proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty <code>networkModel</code> object. It is basically a zero-row
tibble with the appropriate columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- new_networkModel()
m
class(m)

</code></pre>

<hr>
<h2 id='normal_p'>Define a truncated normal prior (on [0;+Inf])</h2><span id='topic+normal_p'></span>

<h3>Description</h3>

<p>Define a truncated normal prior (on [0;+Inf])
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_p(mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_p_+3A_mean">mean</code></td>
<td>
<p>Mean of the untruncated normal.</p>
</td></tr>
<tr><td><code id="normal_p_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the untruncated normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal_p(mean = 0, sd = 4)

</code></pre>

<hr>
<h2 id='obj_sum.prior'>Function used for displaying <code>prior</code> object in tibbles</h2><span id='topic+obj_sum.prior'></span>

<h3>Description</h3>

<p>Function used for displaying <code>prior</code> object in tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
obj_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_sum.prior_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input formatted with <code>format(x)</code>.
</p>

<hr>
<h2 id='Ops.mcmc.list'>Ops generics for <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects</h2><span id='topic+Ops.mcmc.list'></span>

<h3>Description</h3>

<p>Ops generics for <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc.list'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.mcmc.list_+3A_e1">e1</code></td>
<td>
<p>First operand</p>
</td></tr>
<tr><td><code id="Ops.mcmc.list_+3A_e2">e2</code></td>
<td>
<p>Second operand</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mcmc.list</code> object (with the added class
<code>derived.mcmc.list</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# aquarium_run is a coda::mcmc.list object shipped with the isotracer package
a &lt;- aquarium_run
plot(a)
# The calculations below are just given as examples of mathematical
# operations performed on an mcmc.list object, and do not make any sense
# from a modelling point of view.
plot(a[, "upsilon_algae_to_daphnia"] - a[, "lambda_algae"])
plot(a[, "upsilon_algae_to_daphnia"] + a[, "lambda_algae"])
plot(a[, "upsilon_algae_to_daphnia"] / a[, "lambda_algae"])
plot(a[, "upsilon_algae_to_daphnia"] * a[, "lambda_algae"])
plot(a[, "upsilon_algae_to_daphnia"] - 10)
plot(a[, "upsilon_algae_to_daphnia"] + 10)
plot(a[, "upsilon_algae_to_daphnia"] * 10)
plot(a[, "upsilon_algae_to_daphnia"] / 10)
plot(10 - a[, "upsilon_algae_to_daphnia"])
plot(10 + a[, "upsilon_algae_to_daphnia"])
plot(10 * a[, "upsilon_algae_to_daphnia"])
plot(10 / a[, "upsilon_algae_to_daphnia"])

## End(Not run)

</code></pre>

<hr>
<h2 id='Ops.prior'>Implementation of the '==' operator for priors</h2><span id='topic+Ops.prior'></span>

<h3>Description</h3>

<p>Implementation of the '==' operator for priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.prior_+3A_e1">e1</code>, <code id="Ops.prior_+3A_e2">e2</code></td>
<td>
<p>Objects of class &quot;prior&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean (or throws an error for unsupported operators).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- constant_p(0)
q &lt;- constant_p(4)
p == q

p &lt;- hcauchy_p(2)
q &lt;- hcauchy_p(2)
p == q

</code></pre>

<hr>
<h2 id='Ops.topology'>Ops generics for <code>topology</code> objects</h2><span id='topic+Ops.topology'></span>

<h3>Description</h3>

<p>Ops generics for <code>topology</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'topology'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.topology_+3A_e1">e1</code></td>
<td>
<p>First operand</p>
</td></tr>
<tr><td><code id="Ops.topology_+3A_e2">e2</code></td>
<td>
<p>Second operand</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean (or throws an error for unsupported operators).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>topo(aquarium_mod) == topo(trini_mod)
topo(aquarium_mod) == topo(aquarium_mod)

</code></pre>

<hr>
<h2 id='params'>Return the parameters of a network model</h2><span id='topic+params'></span>

<h3>Description</h3>

<p>Return the parameters of a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(nm, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="params_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, return a vector containing the names of all
model parameters (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the parameter names and their current value (if
set). If <code>simplify</code> is <code>TRUE</code>, only return a sorted character
vector containing the parameters names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params(aquarium_mod)
params(trini_mod)
params(trini_mod, simplify = TRUE)

</code></pre>

<hr>
<h2 id='pillar_shaft.prior'>Function used for displaying <code>prior</code> object in tibbles</h2><span id='topic+pillar_shaft.prior'></span>

<h3>Description</h3>

<p>Function used for displaying <code>prior</code> object in tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
pillar_shaft(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pillar_shaft.prior_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior</code>.</p>
</td></tr>
<tr><td><code id="pillar_shaft.prior_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object prepared with pillar::new_pillar_shaft_simple.
</p>

<hr>
<h2 id='plot.networkModel'>Plot observations/trajectories/predictions from a network model</h2><span id='topic+plot.networkModel'></span>

<h3>Description</h3>

<p>Plot observations/trajectories/predictions from a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.networkModel_+3A_x">x</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="plot.networkModel_+3A_...">...</code></td>
<td>
<p>Passed to <code>plot_nm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side effect (plotting).
</p>

<hr>
<h2 id='plot.ready_for_unit_plot'>Plot output from <code>split_to_unit_plot</code></h2><span id='topic+plot.ready_for_unit_plot'></span>

<h3>Description</h3>

<p>Plot output from <code>split_to_unit_plot</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ready_for_unit_plot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ready_for_unit_plot_+3A_x">x</code></td>
<td>
<p>A <code>ready_for_unit_plot</code> object.</p>
</td></tr>
<tr><td><code id="plot.ready_for_unit_plot_+3A_...">...</code></td>
<td>
<p>Passed to <code>plot_nm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side effect (plotting).
</p>

<hr>
<h2 id='posterior_predict'>Draw from the posterior predictive distribution of the model outcome</h2><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distribution of the model outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict_+3A_object">object</code></td>
<td>
<p>Model from which posterior predictions can be made.</p>
</td></tr>
<tr><td><code id="posterior_predict_+3A_...">...</code></td>
<td>
<p>Passed to the appropriate method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Usually methods will implement a <code>draw</code> parameter, and the
returned object is a &quot;draw&quot; by N matrix where N is the number of data
points predicted per draw.
</p>

<hr>
<h2 id='posterior_predict.networkModelStanfit'>Draw from the posterior predictive distribution of the model outcome</h2><span id='topic+posterior_predict.networkModelStanfit'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distribution of the model outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModelStanfit'
posterior_predict(object, newdata, draw = NULL, cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict.networkModelStanfit_+3A_object">object</code></td>
<td>
<p>A networkModelStanfit object.</p>
</td></tr>
<tr><td><code id="posterior_predict.networkModelStanfit_+3A_newdata">newdata</code></td>
<td>
<p>Should be the model used to fit the networkStanfit object.</p>
</td></tr>
<tr><td><code id="posterior_predict.networkModelStanfit_+3A_draw">draw</code></td>
<td>
<p>Integer, number of draws to perform from the posterior. Default
is 100.</p>
</td></tr>
<tr><td><code id="posterior_predict.networkModelStanfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
<tr><td><code id="posterior_predict.networkModelStanfit_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;draw&quot; by N matrix where N is the number of data points predicted
per draw.
</p>

<hr>
<h2 id='predict.networkModel'>Add a column with predictions from a fit</h2><span id='topic+predict.networkModel'></span>

<h3>Description</h3>

<p>Add a column with predictions from a fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModel'
predict(
  object,
  fit,
  draws = NULL,
  error.draws = 5,
  probs = 0.95,
  cores = NULL,
  dt = NULL,
  grid_size = NULL,
  at = NULL,
  end = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.networkModel_+3A_object">object</code></td>
<td>
<p>Network model</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_fit">fit</code></td>
<td>
<p>Model fit (mcmc.list object)</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_draws">draws</code></td>
<td>
<p>Integer, number of draws from the posteriors</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_error.draws">error.draws</code></td>
<td>
<p>Integer, number of draws from the error distribution, for
a given posterior draw.</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_probs">probs</code></td>
<td>
<p>Credible interval (default 0.95).</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_dt">dt</code>, <code id="predict.networkModel_+3A_grid_size">grid_size</code></td>
<td>
<p>Time step size or grid points, respectively.</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_at">at</code></td>
<td>
<p>Timepoints at which the predictions should be returned.</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_end">end</code></td>
<td>
<p>Final timepoint used in the projections.</p>
</td></tr>
<tr><td><code id="predict.networkModel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network model object with an added column <code>"prediction"</code>.
</p>

<hr>
<h2 id='print.networkModel'>Print method for <code>networkModel</code> objects</h2><span id='topic+print.networkModel'></span>

<h3>Description</h3>

<p>Print method for <code>networkModel</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.networkModel_+3A_x">x</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="print.networkModel_+3A_...">...</code></td>
<td>
<p>Passsed to the next method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for the side effect of printing a network model object.
</p>

<hr>
<h2 id='print.prior'>Pretty printing of a <code>prior</code> object</h2><span id='topic+print.prior'></span>

<h3>Description</h3>

<p>Pretty printing of a <code>prior</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prior_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior</code>.</p>
</td></tr>
<tr><td><code id="print.prior_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly called for its side effect of printing, but also returns its
input invisibly.
</p>

<hr>
<h2 id='print.prior_tibble'>Pretty printing of a <code>prior_tibble</code> object</h2><span id='topic+print.prior_tibble'></span>

<h3>Description</h3>

<p>Pretty printing of a <code>prior_tibble</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior_tibble'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prior_tibble_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior_tibble</code>.</p>
</td></tr>
<tr><td><code id="print.prior_tibble_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly called for its side effect of printing, but also returns its
input invisibly.
</p>

<hr>
<h2 id='print.topology'>Pretty printing of a <code>topology</code> object</h2><span id='topic+print.topology'></span>

<h3>Description</h3>

<p>Pretty printing of a <code>topology</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'topology'
print(x, help = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.topology_+3A_x">x</code></td>
<td>
<p>An object of class <code>topology</code>.</p>
</td></tr>
<tr><td><code id="print.topology_+3A_help">help</code></td>
<td>
<p>If TRUE, display a short help after the topology object
explaining e.g. the steady state or the split compartment symbols.</p>
</td></tr>
<tr><td><code id="print.topology_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly called for its side effect (printing).
</p>

<hr>
<h2 id='priors'>Return the tibble containing the priors of a networkModel</h2><span id='topic+priors'></span>

<h3>Description</h3>

<p>Return the tibble containing the priors of a networkModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priors(nm, fix_set_params = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="priors_+3A_fix_set_params">fix_set_params</code></td>
<td>
<p>If TRUE, parameters for which a value is set are given a
fixed value (i.e. their prior is equivalent to a point value).</p>
</td></tr>
<tr><td><code id="priors_+3A_quiet">quiet</code></td>
<td>
<p>Boolean to control verbosity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble giving the current priors defined for the input network
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>priors(aquarium_mod)
priors(trini_mod)

</code></pre>

<hr>
<h2 id='project'>Calculate the trajectories of a network model</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Calculate the trajectories of a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  nm,
  dt = NULL,
  grid_size = NULL,
  at = NULL,
  end = NULL,
  flows = "no",
  cached_ts = NULL,
  cached_ee = NULL,
  ignore_pulses = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="project_+3A_dt">dt</code>, <code id="project_+3A_grid_size">grid_size</code></td>
<td>
<p>Either the time step size for trajectory calculations
(<code>dt</code>) or the number of points for the calculation (<code>grid_size</code>)
can be provided. If none is provided, then a default grid size of 256 steps
is used.</p>
</td></tr>
<tr><td><code id="project_+3A_at">at</code></td>
<td>
<p>Optional, vector of time values at which the trajectory must be
evaluated.</p>
</td></tr>
<tr><td><code id="project_+3A_end">end</code></td>
<td>
<p>Time value for end point. If not provided, the last observation or
event is used.</p>
</td></tr>
<tr><td><code id="project_+3A_flows">flows</code></td>
<td>
<p>Return flow values? The default is &quot;no&quot; and no flows are
calculated. Other values are &quot;total&quot; (total flows summed up from beginning
to end timepoint), &quot;average&quot; (average flows per time unit, equal to total
flows divided by the projection duration), and &quot;per_dt&quot; (detailled flow
values are returned for each interval dt of the projection).</p>
</td></tr>
<tr><td><code id="project_+3A_cached_ts">cached_ts</code>, <code id="project_+3A_cached_ee">cached_ee</code></td>
<td>
<p>Used for optimization by other functions, not for
use by the package user.</p>
</td></tr>
<tr><td><code id="project_+3A_ignore_pulses">ignore_pulses</code></td>
<td>
<p>Default to FALSE (i.e. apply pulses when projecting the
network system). It is set to TRUE when calculating steady-state flows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network model object with a <code>"trajectory"</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- aquarium_mod
m &lt;- set_params(m, sample_params(m))
z &lt;- project(m)
z &lt;- project(m, flows = "per_dt")
z &lt;- project(m, flows = "total")
z &lt;- project(m, flows = "average")

</code></pre>

<hr>
<h2 id='prop_family'>Return the distribution family for observed proportions</h2><span id='topic+prop_family'></span>

<h3>Description</h3>

<p>Return the distribution family for observed proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_family(nm, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_family_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="prop_family_+3A_quiet">quiet</code></td>
<td>
<p>Boolean for being quiet about explaining the role of eta
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string describing the distribution family used to model
observed proportions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop_family(aquarium_mod)
prop_family(trini_mod)

</code></pre>

<hr>
<h2 id='prop2delta'>Convert isotopic proportions to delta values</h2><span id='topic+prop2delta'></span>

<h3>Description</h3>

<p>This function performs the inverse of the operation performed by
<code>delta2prop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop2delta(x = NULL, Rstandard = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop2delta_+3A_x">x</code></td>
<td>
<p>Vector of proportions values.</p>
</td></tr>
<tr><td><code id="prop2delta_+3A_rstandard">Rstandard</code></td>
<td>
<p>String describing the isotopic measurement, e.g. &quot;d15N&quot;,
&quot;d13C&quot; and used to set automatically Rstandards (see the Section
&quot;Ratios for reference standards&quot; for more details). Alternatively, a
numeric value to use for Rstandard, e.g. 0.0036765.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same length of x, containing the delta values based on
the proportions of heavy isotope provided as x and the Rstandard provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop15N &lt;- c(0.00395, 0.02222, 0.00462, 0.00753, NA, 0.00422, 0.00492)

# Rstandard can be specified with a string for some preset references
d15N &lt;- prop2delta(prop15N, "d15N")
d15N

# Rstandard can also be specified manually for non-preset references
d15N_manual &lt;- prop2delta(prop15N, 0.0036765)
d15N_manual

# Call delta2prop() to get the detail of available references
delta2prop()

</code></pre>

<hr>
<h2 id='quick_sankey'>Draw a Sankey plot with basic defaults</h2><span id='topic+quick_sankey'></span>

<h3>Description</h3>

<p>Draw a Sankey plot with basic defaults
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick_sankey(flows, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quick_sankey_+3A_flows">flows</code></td>
<td>
<p>A tibble containing flows (output from
<code><a href="#topic+tidy_flows">tidy_flows</a></code>). For now it should have an &quot;average_flow&quot;
column in the tibbles of the &quot;flows&quot; list column.</p>
</td></tr>
<tr><td><code id="quick_sankey_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+sankey">sankey</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly called for its side effect (plotting), but also returns
invisible the scene object describing the Sankey plot. Note that the
structure of this object is experimental and might change in the future!
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+groups'></span><span id='topic+select'></span><span id='topic+as.mcmc.list'></span><span id='topic+varnames'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>coda</dt><dd><p><code><a href="coda.html#topic+mcmc.list">as.mcmc.list</a></code>, <code><a href="coda.html#topic+varnames">varnames</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+select">select</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='run_mcmc'>Run a MCMC sampler on a network model using Stan</h2><span id='topic+run_mcmc'></span>

<h3>Description</h3>

<p>Run a MCMC sampler on a network model using Stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_mcmc(
  model,
  iter = 2000,
  chains = 4,
  method = "matrix_exp",
  euler_control = list(),
  cores = NULL,
  stanfit = FALSE,
  vb = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_mcmc_+3A_model">model</code></td>
<td>
<p>A <code>networkModel</code>.</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each
chain (including warmup). The default is 2000.</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.
The default is 4.</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_method">method</code></td>
<td>
<p>A character string indicating the method to use to solve ODE
in the Stan model; available methods are &quot;matrix_exp&quot; and &quot;euler&quot;. The
default is &quot;matrix_exp&quot;, which uses matrix exponential and is reasonably
fast for small networks. For large networks, the &quot;euler&quot; method can be
used. It implements a simple forward Euler method to solve the ODE and can
be faster than the matrix exponential approach, but extra caution must be
taken to check for numerical accuracy (e.g. testing different <code>dt</code>
time step values, ensuring that the product between <code>dt</code> and the
largest transfer rates expected from the priors is always very small
compared to 1).</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_euler_control">euler_control</code></td>
<td>
<p>An optional list containing extra parameters when using
<code>method = "euler"</code>. Allowed list elements are <code>"dt"</code> and
<code>"grid_size"</code>, which are respectively the time step size for
trajectory calculations (<code>"dt"</code>) or the number of points for the
calculation (<code>"grid_size"</code>). Only one of &quot;dt&quot; or &quot;grid_size&quot; can be
specified, not both. If none is provided, a default grid size of 256 steps
is used.</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel use. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_stanfit">stanfit</code></td>
<td>
<p>If TRUE, returns a 'stanfit' object instead of the more
classical 'mcmc.list' object. Note that when an 'mcmc.list' object is
returned, the original 'stanfit' object is still accessible as an
attribute of that object (see Examples).</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_vb">vb</code></td>
<td>
<p>Boolean, if TRUE will use <code>rstan::vb</code> for a quick approximate
sampling of the posterior. Important note from <code>?rstan::vb</code>:
&quot;This is still considered an experimental feature.  We recommend calling
<code>stan</code> or <code>sampling</code> for final inferences and only using ‘vb’ to
get a rough idea of the parameter distributions.&quot;</p>
</td></tr>
<tr><td><code id="run_mcmc_+3A_...">...</code></td>
<td>
<p>Arguments passed to 'rstan::sampling' (e.g. iter, chains).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'stanfit' returned by 'rstan::sampling' if
<code>stanfit = TRUE</code>, otherwise the result of converting this
<code>stanfit</code> object with <code>stanfit_to_named_mcmclist</code> (i.e. an object
of class <code>networkModelStanfit</code> and <code>mcmc.list</code>, which still
carries the original 'stanfit' object stored as an attribute).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aquarium_mod
## Not run: 
  # The 'aquarium_run' object is shipped with the package, so you don't
  # actually need to run the line below to obtain it
  aquarium_run &lt;- run_mcmc(aquarium_mod)

  plot(aquarium_run)
  summary(aquarium_run)

  # The original stanfit object returned by Stan
  sfit &lt;- attr(aquarium_run, "stanfit")
  sfit

  # The stanfit object can be used for diagnostics, LOO cross-validation, etc.
  rstan::loo(sfit)

## End(Not run)

</code></pre>

<hr>
<h2 id='sample_from'>Generate samples from a network model</h2><span id='topic+sample_from'></span>

<h3>Description</h3>

<p>Generate samples from a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from(
  nm,
  at,
  dt = NULL,
  grid_size = NULL,
  end = NULL,
  error.draws = 1,
  cached_ts = NULL,
  cached_ee = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_from_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_at">at</code></td>
<td>
<p>Vector of time values at which the samples should be taken.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_dt">dt</code>, <code id="sample_from_+3A_grid_size">grid_size</code></td>
<td>
<p>Time step size or grid points, respectively.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_end">end</code></td>
<td>
<p>Final timepoint used in the projections.</p>
</td></tr>
<tr><td><code id="sample_from_+3A_error.draws">error.draws</code></td>
<td>
<p>Integer, number of draws from the error distribution for
each sample (default: 1).</p>
</td></tr>
<tr><td><code id="sample_from_+3A_cached_ts">cached_ts</code>, <code id="sample_from_+3A_cached_ee">cached_ee</code></td>
<td>
<p>Used for optimization by other functions, not for
use by the package user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the generated samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
mod &lt;- new_networkModel() %&gt;%
   set_topo("NH4 -&gt; algae -&gt; daphnia -&gt; NH4")
inits &lt;- tibble::tribble(
     ~comps, ~sizes, ~props, ~treatment,
      "NH4",    0.2,    0.8,    "light",
    "algae",      1,  0.004,    "light",
  "daphnia",      2,  0.004,    "light",
      "NH4",    0.5,    0.8,     "dark",
    "algae",    1.2,  0.004,     "dark",
  "daphnia",    1.3,  0.004,     "dark")
mod &lt;- set_init(mod, inits, comp = "comps", size = "sizes",
                prop = "props", group_by = "treatment")
mod &lt;- add_covariates(mod, upsilon_NH4_to_algae ~ treatment)
mod &lt;- mod %&gt;%
  set_params(c("eta" = 0.2, "lambda_algae" = 0, "lambda_daphnia" = 0,
               "lambda_NH4" = 0, "upsilon_NH4_to_algae|light" = 0.3,
               "upsilon_NH4_to_algae|dark" = 0.1,
               "upsilon_algae_to_daphnia" = 0.13,
               "upsilon_daphnia_to_NH4" = 0.045, "zeta" = 0.1))
spl &lt;- mod %&gt;% sample_from(at = 1:10)
spl

</code></pre>

<hr>
<h2 id='sample_from_prior'>Sample from a prior object</h2><span id='topic+sample_from_prior'></span>

<h3>Description</h3>

<p>Sample from a prior object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from_prior(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_from_prior_+3A_x">x</code></td>
<td>
<p>A <code>prior</code> object.</p>
</td></tr>
<tr><td><code id="sample_from_prior_+3A_n">n</code></td>
<td>
<p>Integer, number of samples to draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_from_prior(constant_p(1))
sample_from_prior(constant_p(1), 10)
sample_from_prior(hcauchy_p(0.5), 1)
hist(sample_from_prior(hcauchy_p(0.5), 20))
hist(sample_from_prior(uniform_p(0, 3), 1000))
hist(sample_from_prior(scaled_beta_p(3, 7, 2), 1e4))

</code></pre>

<hr>
<h2 id='sample_params'>Sample parameter values from priors</h2><span id='topic+sample_params'></span>

<h3>Description</h3>

<p>Sample parameter values from priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_params(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_params_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

p &lt;- sample_params(aquarium_mod)
p

proj &lt;- aquarium_mod %&gt;% set_params(p) %&gt;% project(end = 10)
plot(proj)

</code></pre>

<hr>
<h2 id='sankey'>Draw a Sankey plot for a network and estimated flows</h2><span id='topic+sankey'></span>

<h3>Description</h3>

<p>Draw a Sankey plot for a network and estimated flows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sankey(
  topo,
  nodes = NULL,
  flows = NULL,
  layout = NULL,
  new = TRUE,
  debug = FALSE,
  node_f = 1,
  edge_f = 1,
  node_s = "auto",
  edge_n = 32,
  cex_lab = NULL,
  cex.lab = NULL,
  fit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sankey_+3A_topo">topo</code></td>
<td>
<p>A topology.</p>
</td></tr>
<tr><td><code id="sankey_+3A_nodes">nodes</code></td>
<td>
<p>Optional, a tibble containing the properties of the nodes. It
should have a 'comp' column with the same entries as the topology. It
cannot have 'x' and 'y' entries. If it has a 'label' entry, it will
replace the 'comp' values for node labels.</p>
</td></tr>
<tr><td><code id="sankey_+3A_flows">flows</code></td>
<td>
<p>A tibble containing the values of the flows in the topology. If
NULL (the default), all flows have same width in the plot.</p>
</td></tr>
<tr><td><code id="sankey_+3A_layout">layout</code></td>
<td>
<p>String, node-placing algorithm to use from the ggraph package
(e.g. &quot;stress&quot;). The ggraph package itself uses some algoritms from the
igraph package. See the Details in the help of
<code><a href="ggraph.html#topic+layout_tbl_graph_igraph">layout_tbl_graph_igraph</a></code> for available
algorithms. The ggraph package must be installed for this argument to be
taken into account. Currently, only the &quot;left2right&quot; and &quot;stress&quot; layout
are implemented in detail, and any other layout will use rough defaults
for the aesthetic adjustments. Other layouts which are kind of working
are &quot;kk&quot;, &quot;lgl&quot;, &quot;fr&quot;, &quot;dh&quot;, &quot;mds&quot;. Some of those produce
non-reproducible node locations (at least I haven't managed to reproduce
them even by setting the RNG seed before calling the function).</p>
</td></tr>
<tr><td><code id="sankey_+3A_new">new</code></td>
<td>
<p>Boolean, create a new page for the plot?</p>
</td></tr>
<tr><td><code id="sankey_+3A_debug">debug</code></td>
<td>
<p>Boolean, if TRUE then draw a lot of shapes to help with
debugging.</p>
</td></tr>
<tr><td><code id="sankey_+3A_node_f">node_f</code>, <code id="sankey_+3A_edge_f">edge_f</code></td>
<td>
<p>Multiplicative factor to adjust node and edge size.</p>
</td></tr>
<tr><td><code id="sankey_+3A_node_s">node_s</code></td>
<td>
<p>String defining how node size is calculated. The effect of the
string also depends on the chosen layout.</p>
</td></tr>
<tr><td><code id="sankey_+3A_edge_n">edge_n</code></td>
<td>
<p>Integer, number of interpolation points along each edge.</p>
</td></tr>
<tr><td><code id="sankey_+3A_cex_lab">cex_lab</code>, <code id="sankey_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Expansion factor for label size (both arguments are
synonyms).</p>
</td></tr>
<tr><td><code id="sankey_+3A_fit">fit</code></td>
<td>
<p>Boolean, if TRUE try to fit all the graphical elements inside the
canvas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly called for its side effect (plotting), but also returns
invisible the scene object describing the Sankey plot. Note that the
structure of this object is experimental and might change in the future!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

topo &lt;- topo(trini_mod)
sankey(topo, debug = TRUE)
sankey(topo, layout = "stress")
sankey(topo(aquarium_mod), layout = "stress", edge_f = 0.5)

m &lt;- new_networkModel() %&gt;%
    set_topo(c("subs -&gt; NH3 -&gt; subs",
               "NH3 -&gt; Q, E", "E -&gt; Q -&gt; E",
               "E -&gt; D, M")) %&gt;%
    set_steady("subs") %&gt;%
    set_prop_family("normal_sd")
ggtopo(m)
sankey(topo(m), layout = "stress")

# Debug visualization

## Helper functions
flows_from_topo &lt;- function(x) {
    x &lt;- unclass(x) # Remove the "topo" class to treat it as a matrix
    n_comps &lt;- ncol(x)
    links &lt;- which(x &gt; 0)
    from &lt;- links %/% n_comps + 1
    to &lt;- links %% n_comps
    links &lt;- tibble::tibble(from = from, to = to)
    for (i in seq_len(nrow(links))) {
        if (links$to[i] == 0) {
            links$from[i] &lt;- links$from[i] - 1
            links$to[i] &lt;- n_comps
        }
        stopifnot(x[links$to[i], links$from[i]] &gt; 0)
    }
    flows &lt;- tibble::tibble(from = colnames(x)[links$from],
                            to = rownames(x)[links$to])
    return(flows)
}
nodes_from_topo &lt;- function(x) {
    nodes &lt;- tibble::tibble(comp = colnames(x),
                            label = colnames(x))
    return(nodes)
}

t &lt;- topo(trini_mod)
nodes &lt;- nodes_from_topo(t)
nodes$label &lt;- as.list(nodes$label)
nodes$label[[2]] &lt;- latex2exp::TeX("$\\beta$")
nodes$size &lt;- runif(nrow(nodes), 1, 2)
flows &lt;- flows_from_topo(t)
flows$width &lt;- runif(nrow(flows), 0.2, 2)
z &lt;- sankey(t, nodes = nodes, flows = flows, layout = "left2right",
            debug = TRUE, node_f = 1, edge_f = 0.9, edge_n = 32,
            cex_lab = 1.5)

# Stress layout
y &lt;- new_networkModel() %&gt;%
        set_topo(c("subs -&gt; NH3 -&gt; subs",
                   "NH3 -&gt; Q, E", "E -&gt; Q -&gt; E",
                   "E -&gt; D, M")) %&gt;%
        set_steady("subs") %&gt;%
            set_prop_family("normal_sd")
y &lt;- topo(y)
nodes &lt;- nodes_from_topo(y)
nodes$size &lt;- runif(nrow(nodes), 1, 10)
ggtopo(y, edge = "fan")
flows &lt;- flows_from_topo(y)
flows$width &lt;- runif(nrow(flows), 0.2, 5)
z &lt;- sankey(y, nodes = nodes, flows = flows, debug = FALSE, edge_n = 32,
            edge_f = 0.4, node_s = "prop")

# Another example
r &lt;- new_networkModel() %&gt;%
    set_topo("infusion -&gt; plasma -&gt; body -&gt; plasma") %&gt;%
    set_steady(c("infusion", "body"))
r &lt;- topo(r)
ggtopo(r, edge = "fan")
sankey(r, debug = TRUE, edge_f = 0.2)

</code></pre>

<hr>
<h2 id='scaled_beta_p'>Define a beta prior (on [0;scale])</h2><span id='topic+scaled_beta_p'></span>

<h3>Description</h3>

<p>If a random variable X follows a scaled beta distribution with parameters
(alpha, beta, scale), then X/scale follows a beta distribution with
parameters (alpha, beta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_beta_p(alpha, beta, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaled_beta_p_+3A_alpha">alpha</code></td>
<td>
<p>Alpha parameter of the unscaled beta distribution.</p>
</td></tr>
<tr><td><code id="scaled_beta_p_+3A_beta">beta</code></td>
<td>
<p>Beta parameter of the unscaled beta distribution.</p>
</td></tr>
<tr><td><code id="scaled_beta_p_+3A_scale">scale</code></td>
<td>
<p>The upper boundary of the prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scaled_beta_p(0.8, 20, scale = 10)

</code></pre>

<hr>
<h2 id='select.mcmc.list'>Select parameters based on their names</h2><span id='topic+select.mcmc.list'></span>

<h3>Description</h3>

<p>Select parameters based on their names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc.list'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.mcmc.list_+3A_.data">.data</code></td>
<td>
<p>A <code>coda::mcmc.list</code> object.</p>
</td></tr>
<tr><td><code id="select.mcmc.list_+3A_...">...</code></td>
<td>
<p>Strings used to select variables using pattern matching with
<code>grepl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object, with the same extra class(es) as
<code>.data</code> (if any).
</p>

<hr>
<h2 id='set_half_life'>Set the half-life for radioactive tracers</h2><span id='topic+set_half_life'></span>

<h3>Description</h3>

<p>Indicating a non-zero value for half-life will add a decay to the marked
portion of the tracer element. The decay constant is calculated from the
half-life value as:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_half_life(nm, hl, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_half_life_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="set_half_life_+3A_hl">hl</code></td>
<td>
<p>Half-life value, in the same time unit as the observations are (or
will be) given. Setting half-life to zero is equivalent to using a
stable isotope (no decay used in the model).</p>
</td></tr>
<tr><td><code id="set_half_life_+3A_quiet">quiet</code></td>
<td>
<p>Boolean for verbosity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lambda_decay = log(2) / half_life
</p>
<p>Note that for correct calculations the half-life value should be given in
the same time unit (e.g. hour, day) that the time unit used for
observations.
</p>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
x &lt;- new_networkModel() %&gt;%
    set_topo("32P -&gt; root -&gt; leaf") %&gt;%
    set_half_life(hl = 14.268)
x

</code></pre>

<hr>
<h2 id='set_init'>Set initial conditions in a network model</h2><span id='topic+set_init'></span>

<h3>Description</h3>

<p>Set initial conditions in a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_init(nm, data, comp, size, prop, group_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_init_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object (e.g. output from
<code><a href="#topic+new_networkModel">new_networkModel</a></code>)</p>
</td></tr>
<tr><td><code id="set_init_+3A_data">data</code></td>
<td>
<p>A tibble containing the initial conditions</p>
</td></tr>
<tr><td><code id="set_init_+3A_comp">comp</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment names</p>
</td></tr>
<tr><td><code id="set_init_+3A_size">size</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment sizes</p>
</td></tr>
<tr><td><code id="set_init_+3A_prop">prop</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment
proportions of marked tracer</p>
</td></tr>
<tr><td><code id="set_init_+3A_group_by">group_by</code></td>
<td>
<p>Optional vector of string giving the names of the columns to
use for grouping the data into replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the topology from the Trinidad case study
m &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi, FBOM", "epi -&gt; petro, pseph",
           "FBOM -&gt; tricor", "petro, tricor -&gt; arg")

# Taking initial condtions from the 'lalaja' dataset at t=0
inits &lt;- lalaja[lalaja[["time.days"]] == 0, ]
inits
m &lt;- set_init(m, inits, comp = "compartment", size = "mgN.per.m2",
              prop = "prop15N", group_by = "transect")
m

</code></pre>

<hr>
<h2 id='set_obs'>Set observations in a network model</h2><span id='topic+set_obs'></span>

<h3>Description</h3>

<p>Set observations in a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_obs(nm, data, comp, size, prop, time, group_by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_obs_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object (e.g. output from
<code><a href="#topic+new_networkModel">new_networkModel</a></code>)</p>
</td></tr>
<tr><td><code id="set_obs_+3A_data">data</code></td>
<td>
<p>A tibble containing the observations. If NULL, remove
observations from the model.</p>
</td></tr>
<tr><td><code id="set_obs_+3A_comp">comp</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment
names</p>
</td></tr>
<tr><td><code id="set_obs_+3A_size">size</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment
sizes</p>
</td></tr>
<tr><td><code id="set_obs_+3A_prop">prop</code></td>
<td>
<p>String, name of the <code>data</code> column with the compartment
proportions of heavy tracer</p>
</td></tr>
<tr><td><code id="set_obs_+3A_time">time</code></td>
<td>
<p>String, name of the <code>data</code> column with the sampling times</p>
</td></tr>
<tr><td><code id="set_obs_+3A_group_by">group_by</code></td>
<td>
<p>Optional vector of string giving the names of the columns to
use for grouping the data into replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the topology from the Trinidad case study
m &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi, FBOM", "epi -&gt; petro, pseph",
           "FBOM -&gt; tricor", "petro, tricor -&gt; arg")

# Taking initial condtions from the 'lalaja' dataset at t=0
inits &lt;- lalaja[lalaja[["time.days"]] == 0, ]
inits
m &lt;- set_init(m, inits, comp = "compartment", size = "mgN.per.m2",
              prop = "prop15N", group_by = "transect")
m

# Taking observations from 'lalaja'
m &lt;- set_obs(m, lalaja[lalaja[["time.days"]] &gt; 0, ], time = "time.days")
m
plot(m)

</code></pre>

<hr>
<h2 id='set_params'>Set the parameters in a network model</h2><span id='topic+set_params'></span>

<h3>Description</h3>

<p>Set the parameters in a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_params(nm, params, force = TRUE, quick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_params_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="set_params_+3A_params">params</code></td>
<td>
<p>A named vector or a tibble with columns c(&quot;parameter&quot;,
&quot;value&quot;) containing the (global) parameter values.</p>
</td></tr>
<tr><td><code id="set_params_+3A_force">force</code></td>
<td>
<p>Boolean, if FALSE will not overwrite already set parameters.</p>
</td></tr>
<tr><td><code id="set_params_+3A_quick">quick</code></td>
<td>
<p>Boolean, if TRUE take some shortcuts for faster parameter
settings when called by another function. This should usually be left to
the default (FALSE) by a regular package user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- aquarium_mod
p &lt;- sample_params(m)
m2 &lt;- set_params(m, p)
m2$parameters

</code></pre>

<hr>
<h2 id='set_prior'>Set prior(s) for a network model</h2><span id='topic+set_prior'></span><span id='topic+set_priors'></span>

<h3>Description</h3>

<p>Set prior(s) for a network model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior(x, prior, param = "", use_regexp = TRUE, quiet = FALSE)

set_priors(x, prior, param = "", use_regexp = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prior_+3A_x">x</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_prior">prior</code></td>
<td>
<p>A prior built with e.g. uniform_p() or hcauchy_p(). Call
<code>available_priors()</code> to see a table of implemented
priors. Alternatively, if <code>prior</code> is a tibble, the function will
try to use it to set parameter priors. The format of such an argument is
the same as the format of the output of the getter function
<code>priors()</code> (see examples). Note that if 'prior' is given as a
tibble, all other arguments (except 'x') are disregarded.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_param">param</code></td>
<td>
<p>String, target parameter or regexp to target several
parameters. Default is the empty string <code>""</code>, which will match all
parameters.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_use_regexp">use_regexp</code></td>
<td>
<p>Boolean, if <code>TRUE</code> (the default) then <code>param</code> is
used as a regular expression to match one or several parameter names.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>FALSE</code> print a message indicating which
parameters had their prior modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Copy `aquarium_mod`
m &lt;- aquarium_mod
priors(m)

# Modify the priors of `m`
m &lt;- set_priors(m, exponential_p(0.5), "lambda")
priors(m)

# Re-apply priors from the original `aquarium_mod`
prev_priors &lt;- priors(aquarium_mod)
prev_priors
m &lt;- set_priors(m, prev_priors)
priors(m)

</code></pre>

<hr>
<h2 id='set_prop_family'>Set the distribution family for observed proportions</h2><span id='topic+set_prop_family'></span>

<h3>Description</h3>

<p>Set the distribution family for observed proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prop_family(nm, family, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prop_family_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object (output from
<code><a href="#topic+new_networkModel">new_networkModel</a></code>).</p>
</td></tr>
<tr><td><code id="set_prop_family_+3A_family">family</code></td>
<td>
<p>Allowed values are &quot;gamma_cv&quot;, &quot;beta_phi&quot;, &quot;normal_cv&quot;, and
&quot;normal_sd&quot;.</p>
</td></tr>
<tr><td><code id="set_prop_family_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>FALSE</code> print a message indicating which
distribution family is used for proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

m &lt;- new_networkModel() %&gt;%
  set_topo(links = "NH4, NO3 -&gt; epi -&gt; pseph, tricor")
m &lt;- m %&gt;% set_prop_family("beta_phi")
m
attr(m, "prop_family")

</code></pre>

<hr>
<h2 id='set_size_family'>Set the distribution family for observed sizes</h2><span id='topic+set_size_family'></span>

<h3>Description</h3>

<p>Set the distribution family for observed sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_size_family(nm, family, by_compartment, quiet = FALSE, quiet_reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_size_family_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object (output from
<code><a href="#topic+new_networkModel">new_networkModel</a></code>).</p>
</td></tr>
<tr><td><code id="set_size_family_+3A_family">family</code></td>
<td>
<p>Allowed values are &quot;normal_cv&quot; and &quot;normal_sd&quot;.</p>
</td></tr>
<tr><td><code id="set_size_family_+3A_by_compartment">by_compartment</code></td>
<td>
<p>Boolean, if TRUE then zeta is compartment-specific.</p>
</td></tr>
<tr><td><code id="set_size_family_+3A_quiet">quiet</code></td>
<td>
<p>Boolean, if <code>FALSE</code> print a message indicating which
distribution family is used for proportions.</p>
</td></tr>
<tr><td><code id="set_size_family_+3A_quiet_reset">quiet_reset</code></td>
<td>
<p>Boolean, write a message when model parameters (and
covariates and priors) are reset?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

m &lt;- new_networkModel() %&gt;%
  set_topo(links = "NH4, NO3 -&gt; epi -&gt; pseph, tricor")
m &lt;- m %&gt;% set_size_family("normal_sd")
m
attr(m, "size_family")

m &lt;- m %&gt;% set_size_family(by_compartment = TRUE)
attr(m, "size_zeta_per_compartment")

</code></pre>

<hr>
<h2 id='set_split'>Flag some network compartments as being split compartments</h2><span id='topic+set_split'></span>

<h3>Description</h3>

<p>This function automatically adds a default prior (uniform on [0,1]) for the
active portion of split compartments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_split(nm, comps = NULL, which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_split_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="set_split_+3A_comps">comps</code></td>
<td>
<p>Vector of strings, the names of the compartments to set split.</p>
</td></tr>
<tr><td><code id="set_split_+3A_which">which</code></td>
<td>
<p>Vector of integers giving the nm rows to update. Default is to
update all rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
x &lt;- new_networkModel() %&gt;%
   set_topo("NH4 -&gt; algae -&gt; daphnia") %&gt;%
   set_split("algae")
topo(x)

</code></pre>

<hr>
<h2 id='set_steady'>Flag some network compartments as being in a steady state</h2><span id='topic+set_steady'></span>

<h3>Description</h3>

<p>Flag some network compartments as being in a steady state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_steady(nm, comps = NULL, which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_steady_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="set_steady_+3A_comps">comps</code></td>
<td>
<p>Vector of strings, names of the compartments to set steady.</p>
</td></tr>
<tr><td><code id="set_steady_+3A_which">which</code></td>
<td>
<p>Vector of integers giving the nm rows to update. Default is to
update all rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
x &lt;- new_networkModel() %&gt;%
   set_topo("NH4 -&gt; algae -&gt; daphnia") %&gt;%
   set_steady("NH4")
topo(x)

</code></pre>

<hr>
<h2 id='set_topo'>Set the topology in a network model.</h2><span id='topic+set_topo'></span>

<h3>Description</h3>

<p>Set the topology in a network model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_topo(nm, ..., from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_topo_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object (output from
<code><a href="#topic+new_networkModel">new_networkModel</a></code>).</p>
</td></tr>
<tr><td><code id="set_topo_+3A_...">...</code></td>
<td>
<p>One or more strings describing the links defining the network
topology. Optionally, links can be given as a data frame. See the
examples for more details about acceptable input formats.</p>
</td></tr>
<tr><td><code id="set_topo_+3A_from">from</code></td>
<td>
<p>Optional, string containing the column name for sources if
links are provided as a data frame.</p>
</td></tr>
<tr><td><code id="set_topo_+3A_to">to</code></td>
<td>
<p>Optional, string containing the column name for destinations if
links are provided as a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>networkModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single string can describe several links in one go.
m &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi -&gt; pseph, tricor")
m
topo(m)

# Several strings can be given as distinct arguments.
m2 &lt;- new_networkModel() %&gt;%
  set_topo("NH4, NO3 -&gt; epi -&gt; pseph, tricor",
           "NH4 -&gt; FBOM, CBOM", "CBOM &lt;- NO3")
m2
topo(m2)

# Multiple strings can be also be combined into a single argument with `c()`.
links &lt;- c("NH4, NO3 -&gt; epi -&gt; pseph, tricor", "NH4 -&gt; FBOM, CBOM",
           "CBOM &lt;- NO3")
m3 &lt;- new_networkModel() %&gt;%
  set_topo(links)
m3
topo(m3)

# A data frame can be used to specify the links.
links &lt;- data.frame(source = c("NH4", "NO3", "epi"),
                    consumer = c("epi", "epi", "petro"))
links
m4 &lt;- new_networkModel() %&gt;%
  set_topo(links, from = "source", to = "consumer")
m4
m4$topology[[1]]

</code></pre>

<hr>
<h2 id='size_family'>Return the distribution family for observed sizes</h2><span id='topic+size_family'></span>

<h3>Description</h3>

<p>Return the distribution family for observed sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size_family(nm, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_family_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="size_family_+3A_quiet">quiet</code></td>
<td>
<p>Boolean for being quiet about explaining the role of zeta
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string describing the distribution family used to model
observed sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size_family(aquarium_mod)
size_family(trini_mod)

</code></pre>

<hr>
<h2 id='stanfit_to_named_mcmclist'>Convert a Stanfit object to a nicely named mcmc.list object</h2><span id='topic+stanfit_to_named_mcmclist'></span>

<h3>Description</h3>

<p>When running <code>run_mcmc</code> with <code>stanfit = FALSE</code> (typically for
debugging purposes), the parameters in the returned <code>stanfit</code> object
are named using a base label and an indexing system. This function provides
a way to convert this <code>stanfit</code> object into a more conventional
<code>mcmc.list</code> object where parameters are named according to their role
in the original network model used when running <code>run_mcmc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanfit_to_named_mcmclist(stanfit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanfit_to_named_mcmclist_+3A_stanfit">stanfit</code></td>
<td>
<p>A stanfit object returned by <code>rstan::sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object. It also has the original stanfit object
stored as an attribute <code>"stanfit"</code>.
</p>

<hr>
<h2 id='tidy_data'>Extract data from a networkModel object into a tidy tibble.</h2><span id='topic+tidy_data'></span>

<h3>Description</h3>

<p>Extract data from a networkModel object into a tidy tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_data_+3A_x">x</code></td>
<td>
<p>A networkModel object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble (note: row ordering is not the same as in the input).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tidy_data(aquarium_mod)
tidy_data(trini_mod)

</code></pre>

<hr>
<h2 id='tidy_dpp'>Prepare tidy data and posterior predictions</h2><span id='topic+tidy_dpp'></span>

<h3>Description</h3>

<p>This function prepares both tidy data from a model and tidy posterior
predictions from a model fit. Having those two tibbles prepared at the same
time allows to merge them to ensure that observed data, predicted data and
original variables other than observations are all in sync when using y and
y_rep objects for bayesplot functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_dpp(model, fit, draw = NULL, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_dpp_+3A_model">model</code></td>
<td>
<p>A networkModel object.</p>
</td></tr>
<tr><td><code id="tidy_dpp_+3A_fit">fit</code></td>
<td>
<p>A networkModelStanfit object.</p>
</td></tr>
<tr><td><code id="tidy_dpp_+3A_draw">draw</code></td>
<td>
<p>Integer, number of draws to sample from the posterior.</p>
</td></tr>
<tr><td><code id="tidy_dpp_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with y, y_rep and vars.
</p>

<hr>
<h2 id='tidy_flows'>Build a tidy table with the flows for each iteration</h2><span id='topic+tidy_flows'></span>

<h3>Description</h3>

<p>If neither <code>n_per_chain</code> and <code>n</code> are provided, all iterations are
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_flows(
  nm,
  mcmc,
  n_per_chain = NULL,
  n = NULL,
  n_grid = 64,
  steady_state = FALSE,
  dt = NULL,
  grid_size = NULL,
  at = NULL,
  end = NULL,
  use_cache = TRUE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_flows_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_mcmc">mcmc</code></td>
<td>
<p>The corresponding output from <code>run_mcmc</code>.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_n_per_chain">n_per_chain</code></td>
<td>
<p>Integer, number of iterations randomly drawn per
chain. Note that iterations are in sync across chains (in practice, random
iterations are chosen, and then parameter values extracted for those same
iterations from all chains).</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_n">n</code></td>
<td>
<p>Integer, number of iterations randomly drawn from <code>mcmc</code>. Note
that iterations are *not* drawn in sync across chains in this case (use
<code>n_per_chain</code> if you need to have the same iterations taken across all
chains).</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_n_grid">n_grid</code></td>
<td>
<p>Size of the time grid used to calculate trajectories</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_steady_state">steady_state</code></td>
<td>
<p>Boolean (default: FALSE). If TRUE, then steady state
compartment sizes are calculated for each iteration and steady state flows
are calculated from those compartment sizes. Note that any pulse that
might be specified in the input model <code>nm</code> is ignored in this case.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_dt">dt</code>, <code id="tidy_flows_+3A_grid_size">grid_size</code></td>
<td>
<p>Time step size or grid points, respectively.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_at">at</code></td>
<td>
<p>Timepoints at which the predictions should be returned.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_end">end</code></td>
<td>
<p>Final timepoint used in the projections.</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_use_cache">use_cache</code></td>
<td>
<p>Boolean, use cache for faster calculations?</p>
</td></tr>
<tr><td><code id="tidy_flows_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: This function is still maturing and its interface and output might
change in the future.
</p>
<p>Note about how steady state sizes for split compartments are calculated: the
steady size of the active portion is calculated divide it is divided by the
active fraction (portion.act parameter) to get the total size including the
refractory portion. In this case we get a &quot;steady-state&quot; refractory portion,
consistent with steady state size of active fraction and with portion.act
parameter.
</p>


<h3>Value</h3>

<p>A tidy table containing the mcmc iterations (chain, iteration,
parameters), the grouping variables from the network model and the
flows. The returned flow values are the average flow per unit of time
over the trajectory calculations (or steady state flows if
<code>steady_state</code> is TRUE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf &lt;- tidy_flows(aquarium_mod, aquarium_run, n_per_chain = 25, cores = 2)
tf
tfmcmc &lt;- as.mcmc.list(tf)
plot(tfmcmc)

</code></pre>

<hr>
<h2 id='tidy_mcmc'>Extract a tidy output from an mcmc.list</h2><span id='topic+tidy_mcmc'></span>

<h3>Description</h3>

<p>Extract a tidy output from an mcmc.list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_mcmc(x, spread = FALSE, include_constant = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_mcmc_+3A_x">x</code></td>
<td>
<p>An mcmc.list object</p>
</td></tr>
<tr><td><code id="tidy_mcmc_+3A_spread">spread</code></td>
<td>
<p>Boolean, spread the parameters into separate columns?</p>
</td></tr>
<tr><td><code id="tidy_mcmc_+3A_include_constant">include_constant</code></td>
<td>
<p>Boolean, include constant parameters as proper
parameter traces?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy table containing one iteration per row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lapply(1:4, function(i) {
  z &lt;- matrix(rnorm(200), ncol = 2)
  colnames(z) &lt;- c("alpha", "beta")
  coda::as.mcmc(z)
})
fit &lt;- coda::as.mcmc.list(fit)
tidy_mcmc(fit)
tidy_mcmc(fit, spread = TRUE)

</code></pre>

<hr>
<h2 id='tidy_posterior_predict'>Draw from the posterior predictive distribution of the model outcome</h2><span id='topic+tidy_posterior_predict'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distribution of the model outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_posterior_predict(object, newdata, draw = NULL, cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_posterior_predict_+3A_object">object</code></td>
<td>
<p>A networkModelStanfit object.</p>
</td></tr>
<tr><td><code id="tidy_posterior_predict_+3A_newdata">newdata</code></td>
<td>
<p>The original model used to fit the networkStanfit object.</p>
</td></tr>
<tr><td><code id="tidy_posterior_predict_+3A_draw">draw</code></td>
<td>
<p>Integer, number of draws to sample from the posterior. Default
is 100.</p>
</td></tr>
<tr><td><code id="tidy_posterior_predict_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
<tr><td><code id="tidy_posterior_predict_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy table.
</p>

<hr>
<h2 id='tidy_steady_states'>Build a tidy table with the calculated steady states for each iteration</h2><span id='topic+tidy_steady_states'></span>

<h3>Description</h3>

<p>If neither <code>n_per_chain</code> and <code>n</code> are provided, all iterations are
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_steady_states(nm, mcmc, n_per_chain = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_steady_states_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="tidy_steady_states_+3A_mcmc">mcmc</code></td>
<td>
<p>The corresponding output from <code>run_mcmc</code>.</p>
</td></tr>
<tr><td><code id="tidy_steady_states_+3A_n_per_chain">n_per_chain</code></td>
<td>
<p>Integer, number of iterations randomly drawn per
chain. Note that iterations are in sync across chains (in practice,
random iterations are chosen, and then parameter values extracted for
those same iterations from all chains).</p>
</td></tr>
<tr><td><code id="tidy_steady_states_+3A_n">n</code></td>
<td>
<p>Integer, number of iterations randomly drawn from <code>mcmc</code>. Note
that iterations are *not* drawn in sync across chains in this case (use
<code>n_per_chain</code> if you need to have the same iterations taken across
all chains).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note about how steady state sizes for split compartments are calculated: the
steady size of the active portion is calculated divide it is divided by the
active fraction (portion.act parameter) to get the total size including the
refractory portion. In this case we get a &quot;steady-state&quot; refractory portion,
consistent with steady state size of active fraction and with portion.act
parameter.
</p>


<h3>Value</h3>

<p>A tidy table containing the mcmc iterations (chain, iteration,
parameters), the grouping variables from the network model and the
steady state sizes.
</p>

<hr>
<h2 id='tidy_trajectories'>Build a tidy table with the trajectories for each iteration</h2><span id='topic+tidy_trajectories'></span>

<h3>Description</h3>

<p>If neither <code>n_per_chain</code> and <code>n</code> are provided, all iterations are
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_trajectories(
  nm,
  mcmc,
  n_per_chain = NULL,
  n = NULL,
  n_grid = 64,
  dt = NULL,
  grid_size = NULL,
  at = NULL,
  end = NULL,
  use_cache = TRUE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_trajectories_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_mcmc">mcmc</code></td>
<td>
<p>The corresponding output from <code>run_mcmc</code>.</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_n_per_chain">n_per_chain</code></td>
<td>
<p>Integer, number of iterations randomly drawn per
chain. Note that iterations are in sync across chains (in practice,
random iterations are chosen, and then parameter values extracted for
those same iterations from all chains).</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_n">n</code></td>
<td>
<p>Integer, number of iterations randomly drawn from <code>mcmc</code>. Note
that iterations are *not* drawn in sync across chains in this case (use
<code>n_per_chain</code> if you need to have the same iterations taken across
all chains).</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_n_grid">n_grid</code></td>
<td>
<p>Size of the time grid used to calculate trajectories</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_dt">dt</code>, <code id="tidy_trajectories_+3A_grid_size">grid_size</code></td>
<td>
<p>Time step size or grid points, respectively.</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_at">at</code></td>
<td>
<p>Timepoints at which the predictions should be returned.</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_end">end</code></td>
<td>
<p>Final timepoint used in the projections.</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_use_cache">use_cache</code></td>
<td>
<p>Boolean, use cache for faster calculations?</p>
</td></tr>
<tr><td><code id="tidy_trajectories_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel calculations. Default is
<code>NULL</code>, which means to use the value stored in
<code>options()[["mc.cores"]]</code> (or 1 if this value is not set).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: This function is still maturing and its interface and output might
change in the future.
</p>


<h3>Value</h3>

<p>A tidy table containing the mcmc iterations (chain, iteration,
parameters), the grouping variables from the network model and the
trajectories.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- tidy_trajectories(aquarium_mod, aquarium_run, n = 10, cores = 2)
tt

</code></pre>

<hr>
<h2 id='topo'>Return the list of topologies, or a unique topology if all identical</h2><span id='topic+topo'></span>

<h3>Description</h3>

<p>Return the list of topologies, or a unique topology if all identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topo(nm, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topo_+3A_nm">nm</code></td>
<td>
<p>A <code>networkModel</code> object.</p>
</td></tr>
<tr><td><code id="topo_+3A_simplify">simplify</code></td>
<td>
<p>Boolean, return only a unique topology if all topologies are
identical or if there is only one? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the <code>networkModel</code> topologies or, if all topologies
are identical (or if there is only one) and <code>simplify</code> is TRUE, a
single topology (not wrapped into a single-element list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aquarium_mod
topo(aquarium_mod)

trini_mod
topo(trini_mod)
</code></pre>

<hr>
<h2 id='traceplot'>Plot mcmc.list objects</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>Plot mcmc.list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_x">x</code></td>
<td>
<p>A <code>coda::mcmc.list</code> object.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>Passed to <code>plot_traces</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side effect (plotting).
</p>

<hr>
<h2 id='trini_mod'>Network model for nitrogen fluxes in Trinidadian streams (Collins et al. 2016)</h2><span id='topic+trini_mod'></span>

<h3>Description</h3>

<p>This model is used in the package case study about Trinidadian streams and
is based on an original dataset taken from Collins et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trini_mod
</code></pre>


<h3>Format</h3>

<p>An object of class <code>networkModel</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 6 rows and 6 columns.
</p>


<h3>Details</h3>

<p>The model is complete, with topology, initial conditions, observations,
covariates and priors.
</p>
<p>It is ready for an MCMC run as shown in the example. Note that it might be a
good idea to relax the priors for uptake rates from seston to Leptonema
(e.g. using hcauchy_p(10)), seston being a compartment that is flowing with
the stream water and that can be replenished from upstream.
</p>


<h3>Source</h3>

<p>This network model contains data from the original article: Collins, Sarah
M., Steven A. Thomas, Thomas Heatherly, Keeley L. MacNeill, Antoine
O.H.C. Leduc, Andrés López-Sepulcre, Bradley A. Lamphere, et al. 2016. “Fish
Introductions and Light Modulate Food Web Fluxes in Tropical Streams: A
Whole-Ecosystem Experimental Approach.” Ecology, &lt;doi:10.1002/ecy.1530&gt;.
</p>
<p>This dataset was also used in the paper: López-Sepulcre, Andrés, Matthieu
Bruneaux, Sarah M. Collins, Rana El-Sabaawi, Alexander S. Flecker, and
Steven A. Thomas. 2020. “A New Method to Reconstruct Quantitative Food Webs
and Nutrient Flows from Isotope Tracer Addition Experiments.” The American
Naturalist 195 (6): 964–85. &lt;doi:10.1086/708546&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trini_mod
ggtopo(trini_mod)

## Not run: 
# Warning: the run below can take quite a long time!
# (about 15 min with 4 cores at 3.3 Ghz).
run &lt;- run_mcmc(trini_mod, iter = 500, chains = 4, cores = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='type_sum.prior'>Function used for displaying <code>prior</code> object in tibbles</h2><span id='topic+type_sum.prior'></span>

<h3>Description</h3>

<p>Function used for displaying <code>prior</code> object in tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
type_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_sum.prior_+3A_x">x</code></td>
<td>
<p>An object of class <code>prior</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input formatted with <code>format(x)</code>.
</p>

<hr>
<h2 id='uniform_p'>Define a uniform prior</h2><span id='topic+uniform_p'></span>

<h3>Description</h3>

<p>Define a uniform prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform_p(min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform_p_+3A_min">min</code>, <code id="uniform_p_+3A_max">max</code></td>
<td>
<p>Minimum and maximum boundaries for the uniform prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining the prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uniform_p(min = 0, max= 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
