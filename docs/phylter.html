<!DOCTYPE html><html><head><title>Help for package phylter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#carnivora'><p>125 genes trees for 53 carnivora species</p></a></li>
<li><a href='#detect.outliers'><p>Detection of outliers in 1D and 2D data</p></a></li>
<li><a href='#Dist2WR'><p>Compute gene x species matrix from the result of Distatis</p></a></li>
<li><a href='#DistatisFast'><p>Fast implementation the multivariate analysis method Distatis</p></a></li>
<li><a href='#impMean'><p>Imputation of missing values in a collection of matrices</p></a></li>
<li><a href='#medcouple'><p>A robust measure of skewness for univariate data</p></a></li>
<li><a href='#normalize'><p>Median normalization of 2D matrix by row or by colomn</p></a></li>
<li><a href='#phylter'><p>Filter phylogenomics datasets</p></a></li>
<li><a href='#plot.phylter'><p>Plot phylter objects</p></a></li>
<li><a href='#PreparePhylterData'><p>Prepare data for phylter analysis</p></a></li>
<li><a href='#print.phylter'><p>Print phylter objects</p></a></li>
<li><a href='#print.phylterfinal'><p>print objects of class phylterfinal</p></a></li>
<li><a href='#print.phylterinitial'><p>print objects of class phylterinitial</p></a></li>
<li><a href='#print.summary.phylter'><p>print summary of phylter objects</p></a></li>
<li><a href='#rename.genes'><p>Name or rename a list of gene trees or matrices</p></a></li>
<li><a href='#simtrees'><p>Simplistic simulation of gene trees with outliers</p></a></li>
<li><a href='#summary.phylter'><p>Get summary for phylter objects</p></a></li>
<li><a href='#trees2matrices'><p>Convert phylogenetic trees to distance matrices</p></a></li>
<li><a href='#write.phylter'><p>Write summary of phyter analysis to file(s)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Detect and Remove Outliers in Phylogenomics Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.11</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, ggplot2, reshape2, Rfast, RSpectra, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen (&ge; 0.3.2.9.0), Rcpp (&ge; 0.12.6), RcppArmadillo
(&ge; 0.7.600.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzis and filtering of phylogenomics datasets. 
	It takes an input either a collection of gene trees (then transformed to matrices) or directly a collection of gene matrices and performs an iterative process to identify
	what species in what genes are outliers, and whose elimination significantly improves the concordance between the input matrices. The methods builds upon the Distatis approach (Abdi et al. (2005) &lt;<a href="https://doi.org/10.1101%2F2021.09.08.459421">doi:10.1101/2021.09.08.459421</a>&gt;), a generalization of classical multidimensional scaling to multiple distance matrices.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/damiendevienne/phylter/issues">https://github.com/damiendevienne/phylter/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 08:05:20 UTC; siberchicot</td>
</tr>
<tr>
<td>Author:</td>
<td>Damien M. de Vienne [aut],
  Stéphane Dray [aut],
  Théo Tricou [aut],
  Aurélie Siberchicot [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurélie Siberchicot &lt;aurelie.siberchicot@univ-lyon1.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 08:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='carnivora'>125 genes trees for 53 carnivora species</h2><span id='topic+carnivora'></span>

<h3>Description</h3>

<p>This dataset contains 125 carnivora gene trees for 53 carnivora species. 
It is a subset of the dataset used in Allio et al. (2021), obtained 
by randomly selecting 125 genes for which all 53 species were present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carnivora
</code></pre>


<h3>Format</h3>

<p>A list of named trees of class multiPhylo
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.7554/eLife.63167">doi:10.7554/eLife.63167</a>
</p>


<h3>References</h3>

<p>Allio, R., Tilak, M. K., Scornavacca, C., Avenant, N. L., Kitchener, A. C., Corre, E., ... &amp; Delsuc, F. (2021). High-quality carnivoran genomes from roadkill samples enable comparative species delineation in aardwolf and bat-eared fox. Elife, 10, e63167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
class(carnivora)
</code></pre>

<hr>
<h2 id='detect.outliers'>Detection of outliers in 1D and 2D data</h2><span id='topic+detect.outliers'></span><span id='topic+detect.outliers.array'></span>

<h3>Description</h3>

<p>Functions to detect outliers, in matrices or in arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.outliers(X, k = 3, test.island = TRUE, normalizeby = "row")

detect.outliers.array(arr, nbsp, k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.outliers_+3A_x">X</code></td>
<td>
<p>2D matrix (gene x species) obtained with the <code>Dist2WR()</code> function.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_k">k</code></td>
<td>
<p>strength of outlier detection. High values (typically 3) 
correspond to less outliers detected than with lower ones (e.g. 1.5).</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_test.island">test.island</code></td>
<td>
<p>should islands of outliers be treated as such. 
If TRUE (the default), only the highest value in an island of outliers is
removed. This prevents erroneous outliers due to hicthiking effect to be removed.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_normalizeby">normalizeby</code></td>
<td>
<p>Should the 2D matrix be normalized prior to outlier detection, and how.
Can be &quot;row&quot; (the default),&quot;col&quot; or &quot;none&quot;. Normalization is done by dividing columns or rows 
by their median.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_arr">arr</code></td>
<td>
<p>Array of values, typically the weight of each gene matrix (alpha values).</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_nbsp">nbsp</code></td>
<td>
<p>Number of species in the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions detect outliers either in matrices or in arrays. For the method 
to be adapted to skewed data, as is the case here, the outlier detection 
method used is the adjusted Tukey proposed by Hubert and Vandervieren (2008).
</p>


<h3>Value</h3>

<p><code>detect.outliers</code>: A matrix with outliers detected in the 2D matric. Each row <code>x</code> contains the 
gene (<code>x[1]</code>) where the species (<code>x[2]</code>) is an outlier.
</p>
<p><code>detect.outliers.array</code>: An array listing the outliers detected (if any)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>detect.outliers()</code>: detect outliers in 2D matrix
</p>
</li>
<li> <p><code>detect.outliers.array()</code>: detects outliers in 1D array
</p>
</li></ul>


<h3>References</h3>

<p>de Vienne D.M., Ollier S. et Aguileta G. (2012) Phylo-MCOA: 
A Fast and Efficient Method to Detect Outlier Genes and Species
in Phylogenomics Using Multiple Co-inertia Analysis. Molecular 
Biology and Evolution 29 : 1587-1598.
</p>
<p>Hubert, M. and Vandervieren, E. (2008). An adjusted boxplot for skewed
distributions. Computational Statistics and Data Analysis, 52, 5186-5201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the initial gene x species matrix
# from the carnivora dataset
data(carnivora) 
mat &lt;- phylter(carnivora, InitialOnly = TRUE, parallel = FALSE)$WR

# detect outliers in this matrix
outliers&lt;-detect.outliers(mat)
outliers$cells # matrix where each row represents one cell in the input matrix

</code></pre>

<hr>
<h2 id='Dist2WR'>Compute gene x species matrix from the result of Distatis</h2><span id='topic+Dist2WR'></span>

<h3>Description</h3>

<p><code>Dist2WR</code> computes the 2WR matrix from the results obtaind with <code>DistatisFast</code>
(the fast version of distatis). For internal use mostly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist2WR(Distatis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist2WR_+3A_distatis">Distatis</code></td>
<td>
<p>output of the fonction <code>DistatisFast</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (gene=rows x species=col). Each cell represents a 
gene/species pair, whose value represents the distance between (i) the position of this species
in this gene tree and (ii) the average position of this species in all other gene trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
matrices&lt;-phylter(carnivora, InitialOnly=TRUE, parallel=FALSE)$matrices
ds&lt;-DistatisFast(matrices, parallel = FALSE)
WR&lt;-Dist2WR(ds) #returns the gene x species matrix

</code></pre>

<hr>
<h2 id='DistatisFast'>Fast implementation the multivariate analysis method Distatis</h2><span id='topic+DistatisFast'></span>

<h3>Description</h3>

<p>New implementation of the DISTATIS method for K matrices of dimension IxI.
This version of Distatis is faster than the original one because only the minimum required number
of eigenvalues and eigenvectors is calculated. The difference in speed 
is particularly visible when the number of matrices is large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistatisFast(matrices, factorskept = "auto", parallel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistatisFast_+3A_matrices">matrices</code></td>
<td>
<p>A list of K distance matrices, all of the same dimension (IxI).</p>
</td></tr>
<tr><td><code id="DistatisFast_+3A_factorskept">factorskept</code></td>
<td>
<p>Number of factors to keep for the computation of the factor. When &quot;auto&quot; (the default), a brokenstick model is used for the choice of the number of components to keep.</p>
</td></tr>
<tr><td><code id="DistatisFast_+3A_parallel">parallel</code></td>
<td>
<p>Should the matrix products computations be parallelized? Default to TRUE. 
scores of the observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>

<ul>
<li> <p><code>F</code>: projected coordinates of species in the compromise
</p>
</li>
<li> <p><code>PartialF</code>: list of projected coordinates of species for each gene.
</p>
</li>
<li> <p><code>alpha</code>: array of length K of the weight associated to each matrix.
</p>
</li>
<li> <p><code>lambda</code>: array of length K of the normalization factors used for each matrix. lambda=1 always.
</p>
</li>
<li> <p><code>RVmat</code>: a KxK matrix with RV correlation coefficient computed between all
pairs of matrices.
</p>
</li>
<li> <p><code>compromise</code>: an IxI matrix representing the best compromise between all matrices. This matrix is the weighted average of all K matrices, using 'alpha' as
a weighting array.
</p>
</li>
<li> <p><code>quality</code>: the quality of the compromise. This value is between 0 and 1 
</p>
</li>
<li> <p><code>matrices.dblcent</code>: matrices after double centering
describes how much of the variance of the K matrices is captured by the compromise.   
</p>
</li></ul>



<h3>References</h3>

<p>Abdi, H., Valentin, D., O'Toole, A.J., &amp; Edelman, B. (2005).
DISTATIS: The analysis of multiple distance matrices.
Proceedings of the IEEE Computer Society: International
Conference on Computer Vision and Pattern Recognition_.  (San
Diego, CA, USA). pp. 42-47.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get a list of matrices 
# from the carnivora dataset
data(carnivora) 
matrices &lt;- phylter(carnivora, InitialOnly = TRUE, parallel = FALSE)$matrices

# Perform a Distatis analysis on these matrices: 
distatis &lt;- DistatisFast(matrices, parallel = FALSE)

#distatis is a list with multiple elements: 
distatis$alpha #weigh of each matrix (how much it correlates with others)
distatis$RVmat #RV matrix: correlation of each matrix with each other
distatis$compromise # distance matrix with "average" pairwise distance between species in matrices
# etc.

</code></pre>

<hr>
<h2 id='impMean'>Imputation of missing values in a collection of matrices</h2><span id='topic+impMean'></span>

<h3>Description</h3>

<p>Impute missing data in a list of matrices. Matrices are first given the same dimension, 
then missing entries are filled by computing the average value in non-missing corresponding
entries in all matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impMean(matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impMean_+3A_matrices">matrices</code></td>
<td>
<p>A list of distance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of matrices with same dimensions, with rows and columns 
in the same order and missing data (if any) imputed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
matrices &lt;- phylter(carnivora, InitialOnly = TRUE, parallel = FALSE)$matrices

# remove n species randomly (n between 1 and 5) in each matrix (to mimic missing data)
fun&lt;-function(mat) {
 species2remove&lt;-sample(1:nrow(mat),sample(1:5,1))
 mat&lt;-mat[-species2remove,-species2remove]
 return(mat)
}
matrices.missing&lt;-lapply(matrices, fun)
#check that all matrices have now different dimensions: 
lapply(matrices.missing, dim)
# Impute data to get back to the same dimensions
matrices.ok&lt;-impMean(matrices.missing)
lapply(matrices.ok, dim) #all dimensions are now identical. Missing data have been imputed. 

</code></pre>

<hr>
<h2 id='medcouple'>A robust measure of skewness for univariate data</h2><span id='topic+medcouple'></span>

<h3>Description</h3>

<p>Computes the medcouple, a robust measure of skewness for univariate data. 
For multivariate data the medcouple is calculated on each column of the data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medcouple(x, do.reflect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medcouple_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> by <code class="reqn">p</code> data matrix.</p>
</td></tr>
<tr><td><code id="medcouple_+3A_do.reflect">do.reflect</code></td>
<td>
<p>Logical indicating whether the medcouple should also be computed on the reflected sample <code>-x</code>, with final result <code class="reqn">(mc</code>(<code>x</code>)<code class="reqn">-mc(-</code><code>x</code><code class="reqn">))/2</code>. <br /> Defaults <code>TRUE</code> when <code class="reqn">n&lt;=100</code> and to <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The medcouple is a robust measure of skewness yielding values between <code class="reqn">-1</code> and <code class="reqn">1</code>. For left- and right-skewed data the medcouple is negative and positive respectively. <br />
The medcouple is defined as the median of the kernel function
<code class="reqn">h(x_i,x_j) = \frac{(x_j - med(x)) - (med(x)-x_i)}{x_j-x_i}</code>
evaluated over all couples <code class="reqn">(x_i,x_j)</code> where
<code class="reqn">x_i</code> is smaller than the median of <code>x</code> and <code class="reqn">x_j</code> larger than the median of <code>x</code>. When there are multiple observations tied to the median, the kernel is defined separately as the denominator is not defined for these observations. Let <code class="reqn">m_1 &lt; ... &lt; m_k</code> denote the indices of the observations which are tied to the median. Then <code class="reqn">h(x_{m_i},x_{m_j})</code> is defined to equal <code class="reqn">-1</code> if <code class="reqn">i + j - 1 &lt; k</code>, <code class="reqn">0</code> when <code class="reqn">i + j - 1 = k</code> and <code class="reqn">+1</code> if <code class="reqn">i + j - 1 &gt; k</code>. To compute the medcouple an algorithm with time complexity <code class="reqn">O(n log(n))</code> is applied. For details, see <a href="https://en.wikipedia.org/wiki/Medcouple">https://en.wikipedia.org/wiki/Medcouple</a>. 
For numerical accuracy it is advised, for small data sets, to compute the medcouple on both <code>x</code> and <code>-x</code>. The final value of the medcouple may then be obtained as a linear combination of both calculations. This procedure is warranted by the properties of the medcouple. Indeed the medcouple of the distribution <code class="reqn">X</code> equals minus the medcouple of the reflected distribution <code class="reqn">-X</code>. Moreover the medcouple is location and scale invariant.
Note that missing values are not allowed.
</p>


<h3>Value</h3>

<p>mc A <code class="reqn">p</code>-vector containing the medcouple of each column of the data matrix <code>x</code>.
</p>


<h3>Note</h3>

<p>This function is extracted from the package mrfDepth - 07/2023
</p>


<h3>Author(s)</h3>

<p>P. Segaert with original code from M. Maechler and G. Brys.
</p>


<h3>References</h3>

<p>Brys G., Hubert M., Struyf A. (2004). A robust measure of skewness. <em>Journal of Computational and Graphical Statistics</em>, <b>13</b>, 996&ndash;1017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the medcouple of univariate data sets.
# For 2000 normally distributed values
# the medcouple value is close to 0 because 
# data are not skewed
x&lt;-rnorm(2000)
medcouple(x) 
# For 2000 values following a lognormal
# distribution (mean 0,sd 1), medcouple is close to 1
# because values are right-skewed
y&lt;-rnorm(2000)
medcouple(y) 
# Use the option do.reflect to increase expected accuracy. 
medcouple(y, do.reflect = TRUE)
</code></pre>

<hr>
<h2 id='normalize'>Median normalization of 2D matrix by row or by colomn</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>This function normalizes the 2WR matrix (or any 2D matrix) according to the
species (rows) or to the genes (columns), by dividing each row or each column by its median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(mat, what = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="normalize_+3A_what">what</code></td>
<td>
<p>Character string indicating whether the matrix should be
normalized and how. If what=&quot;none&quot;, the matrix is not normalized (the
default), if what=&quot;species&quot;, the matrix is normalized so that the difference
between species is increased, and if what=&quot;genes&quot;, the matrix is normalized
so that the difference between genes is increased. Normalization consists
in dividing either each row or each columns by its median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalized matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random matrix
x&lt;-matrix(rnorm(270), nrow=9, ncol=14)

# normalize by row
x1&lt;-normalize(x, "genes")

# normalize by column
x2&lt;-normalize(x, "species")



</code></pre>

<hr>
<h2 id='phylter'>Filter phylogenomics datasets</h2><span id='topic+phylter'></span>

<h3>Description</h3>

<p>Detection and filtering out of outliers in a list of trees 
or a list of distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylter(
  X,
  bvalue = 0,
  distance = "patristic",
  k = 3,
  k2 = k,
  Norm = "median",
  Norm.cutoff = 0.001,
  gene.names = NULL,
  test.island = TRUE,
  verbose = TRUE,
  stop.criteria = 1e-05,
  InitialOnly = FALSE,
  normalizeby = "row",
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylter_+3A_x">X</code></td>
<td>
<p>A list of phylogenetic trees (phylo object) or a list 
of distance matrices. Trees can have different number of leaves and matrices
can have different dimensions. If this is the case, missing values are imputed.</p>
</td></tr>
<tr><td><code id="phylter_+3A_bvalue">bvalue</code></td>
<td>
<p>If X is a list of trees, nodes with a support below 'bvalue' will be collapsed
prior to the outlier detection.</p>
</td></tr>
<tr><td><code id="phylter_+3A_distance">distance</code></td>
<td>
<p>If X is a list of trees, type of distance used to compute the 
pairwise matrices for each tree. Can be &quot;patristic&quot; (sum of branch lengths separating tips, the default)
or nodal (number of nodes separating tips). The &quot;nodal&quot; option should only be used if all species 
are present in all genes.</p>
</td></tr>
<tr><td><code id="phylter_+3A_k">k</code></td>
<td>
<p>Strength of outlier detection. The higher this value the less outliers
detected (see details).</p>
</td></tr>
<tr><td><code id="phylter_+3A_k2">k2</code></td>
<td>
<p>Same as k for complete gene outlier detection. To preserve complete genes from 
being discarded, k2 can be increased. By default, k2 = k. (see above)</p>
</td></tr>
<tr><td><code id="phylter_+3A_norm">Norm</code></td>
<td>
<p>Should the matrices be normalized prior to the complete analysis and how. If &quot;median&quot; (the default), matrices are divided by their median, if 
&quot;mean&quot; they are divided by their mean, if &quot;none&quot;, no normalization if performed. Normalizing ensures that fast-evolving 
(and slow-evolving) genes are not treated as outliers. Normalization by median is a better choice as it is less sensitive to outlier values.</p>
</td></tr>
<tr><td><code id="phylter_+3A_norm.cutoff">Norm.cutoff</code></td>
<td>
<p>Value of the median (if <code>Norm="median"</code>) or the mean (if
<code>Norm="mean"</code>) of phylogenetic distance matrices below which genes are simply discarded from the analysis. This
prevents dividing by 0, and allows getting rid of genes that contain mostly branches
of length 0 and are therefore uninformative anyway. Discarded genes, if any, are listed in 
the output (out$DiscardedGenes).</p>
</td></tr>
<tr><td><code id="phylter_+3A_gene.names">gene.names</code></td>
<td>
<p>List of gene names used to rename elements in X. If NULL (the default), 0
elements are named 1,2,..,length(X).</p>
</td></tr>
<tr><td><code id="phylter_+3A_test.island">test.island</code></td>
<td>
<p>If TRUE (the default), only the highest value in
an 'island' of outliers is considered an outlier. This prevents non-outliers hitchhiked by outliers
to be considered outliers themselves.</p>
</td></tr>
<tr><td><code id="phylter_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (the default), messages are written during the filtering process to get information
of what is happening</p>
</td></tr>
<tr><td><code id="phylter_+3A_stop.criteria">stop.criteria</code></td>
<td>
<p>The optimisation stops when the gain in concordance between matrices between round <code>n</code> and round <code>n+1</code> is smaller
than this value. Default to 1e-5.</p>
</td></tr>
<tr><td><code id="phylter_+3A_initialonly">InitialOnly</code></td>
<td>
<p>Logical. If TRUE, only the Initial state of the data is computed.</p>
</td></tr>
<tr><td><code id="phylter_+3A_normalizeby">normalizeby</code></td>
<td>
<p>Should the gene x species matrix be normalized prior to outlier detection, and how.</p>
</td></tr>
<tr><td><code id="phylter_+3A_parallel">parallel</code></td>
<td>
<p>Should the computations be parallelized when possible? Default to TRUE. Note that the number of threads 
cannot be set by the user when 'parallel=TRUE'. It uses all available cores on the machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'phylter' with the 'Initial' (before filtering) and 'Final' (after filtering) states, 
or a list of class 'phylterinitial' only, if InitialOnly=TRUE. The function also returns the list of DiscardedGenes, if any.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)

# using default paramaters
res &lt;- phylter(carnivora, parallel = FALSE) # perform the phylter analysis
res # brief summary of the analysis
res$DiscardedGenes # list of genes discarded prior to the analysis
res$Initial # See all elements prior to the analysis
res$Final # See all elements at the end of the analysis
res$Final$Outliers # Print all outliers detected


# Change the call to phylter to use nodal distances, instead of patristic: 
res &lt;- phylter(carnivora, distance = "nodal")


</code></pre>

<hr>
<h2 id='plot.phylter'>Plot phylter objects</h2><span id='topic+plot.phylter'></span><span id='topic+plot2WR'></span><span id='topic+plotDispersion'></span><span id='topic+plotRV'></span><span id='topic+plotopti'></span>

<h3>Description</h3>

<p>These functions take objects of class phylter as input
and display various plots summarizing the results obtained (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylter'
plot(x, what = "all", layout = 1, sorted = TRUE, ...)

plot2WR(
  x,
  show.missing = TRUE,
  show.outliers = TRUE,
  transpose = FALSE,
  clust = FALSE
)

plotDispersion(x)

plotRV(x, what = "Initial", labelnames = TRUE, clust = FALSE)

plotopti(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phylter_+3A_x">x</code></td>
<td>
<p>The object returned by the 'phylter()' function.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_what">what</code></td>
<td>
<p>Specifies what to plot. If &quot;species&quot;, a barplot will show how many
genes each species is in, and what proportion of thoses were detected as outliers. 
If &quot;genes&quot;, a barplot shows how many species contains each gene and how many of 
them has been detected as outliers. If &quot;all&quot; (the defaut), the two plots
described above are displayed one after the other, prompting the user to press 
ENTER to display the next one.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_layout">layout</code></td>
<td>
<p>What layout to use. Do not change if you don't know what it is.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_sorted">sorted</code></td>
<td>
<p>Logical. Should bars be sorted by the number of outliers detected. Default
to TRUE</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to plot and print functions.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_show.missing">show.missing</code></td>
<td>
<p>Logical. Should missing data be represented on the heatmap. If TRUE (the default), white dots show were these missing entries are in both the initial and final 2WR matrices.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_show.outliers">show.outliers</code></td>
<td>
<p>Logical. Should outliers be represented on the heatmap. If TRUE (the default), yellow dots indicate outliers on the final 2WR matrix.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_transpose">transpose</code></td>
<td>
<p>Logical. If TRUE, the two matrices are piled up instaed of being displayed side by side. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_clust">clust</code></td>
<td>
<p>Logical. Should the rows or/and columns of the matrices that are plotted be reorderd
prior to plotting. Reordering is based on a hierarchical clustering. Default to FALSE. 
This is conveninent when the names of the genes are very long for instance.</p>
</td></tr>
<tr><td><code id="plot.phylter_+3A_labelnames">labelnames</code></td>
<td>
<p>Logical. If TRUE, the names of labels are indicated on the heatmap. If FALSE they are removed. 
This is conveninent when the names of the genes are very long for instance.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>plot(x)</code> and <code>plot.phylter(x)</code> plot the genes found in each species or species 
found in each gene as barplots, highlighting the outliers detected.
</p>
</li>
<li> <p><code>plot2WR(x)</code> plots side by side the initial and the final gene x species (unreable for large datasets) 
matrices (the 2WR matrices), highlighting missing data and detected outliers.
</p>
</li>
<li> <p><code>plotDispersion(x)</code> plots dispersion of data before and after phylter, on a 2D
space. Each dot represents a gene-species association. 
</p>
</li>
<li> <p><code>plotRV(x)</code> plots the RV coefficient matrix that descibes all agains all correlations between gene matrices
</p>
</li>
<li> <p><code>plotopti(x)</code> plots the compromise matrix score at each step of the 
optimization.  
</p>
</li></ul>



<h3>Value</h3>

<p>The desired plots are returned. Note that you might want to call the pdf(),
png(), jpeg(), or tiff() function first if you want to save the plot(s) to an
external file. You can also use the function <code>write.phylter(pdfreport=TRUE)</code> to write 
all possible plots in a single pdf file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)

# perform phylter analysis
res &lt;- phylter(carnivora, parallel = FALSE)

# plot for each gene the number of outlier species
plot(res, "genes")


# plot for each species the number genes where it is outlier
plot(res, "species")

# plot the dispersion of data before and after the use of phylter
plotDispersion(res)


</code></pre>

<hr>
<h2 id='PreparePhylterData'>Prepare data for phylter analysis</h2><span id='topic+PreparePhylterData'></span>

<h3>Description</h3>

<p>Prepare datasets for the <code>phylter</code> function. Detects possible issues, 
discards genes if necessary, imputes missing data if any, and reorders row- and col-names.
For internal usage mostly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PreparePhylterData(
  X,
  bvalue = 0,
  distance = "patristic",
  Norm = "median",
  Norm.cutoff = 0.001,
  gene.names = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PreparePhylterData_+3A_x">X</code></td>
<td>
<p>A list of phylogenetic trees (phylo object) or a list 
of distance matrices. Trees can have different number of leaves and matrices
can have different dimensions. If this is the case, missing values are imputed.</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_bvalue">bvalue</code></td>
<td>
<p>If X is a list of trees, nodes with a support below 'bvalue' will be collapsed
prior to the outlier detection.</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_distance">distance</code></td>
<td>
<p>If X is a list of trees, type of distance used to compute the 
pairwise matrices for each tree. Can be &quot;patristic&quot; (sum of branch lengths separating tips, the default)
or nodal (number of nodes separating tips).</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_norm">Norm</code></td>
<td>
<p>Should the matrices be normalized and how. If &quot;median&quot;, matrices are divided by their median, if 
&quot;mean&quot; they are divided by their mean, if &quot;none&quot;, no normalization if performed. Normalizing ensures that fast-evolving 
(and slow-evolving) genes are not treated as outliers. Normalization by median is less sensitive to outlier values
but can lead to errors if some matrices have a median value of 0. 
are not considered outliers.</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_norm.cutoff">Norm.cutoff</code></td>
<td>
<p>Value of the median (if Norm=&quot;median&quot;) or the mean (if
Norm=&quot;mean&quot;) below which matrices are simply discarded from the analysis. This
prevents dividing by 0, and getting rid of genes that contain mostly branches
of length 0 and are therefore uninformative anyway.</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_gene.names">gene.names</code></td>
<td>
<p>List of gene names used to rename elements in X. If NULL (the default), 
elements are named 1,2,..,length(X).</p>
</td></tr>
<tr><td><code id="PreparePhylterData_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (the default), messages are written during the filtering process to get information
of what is happening</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'phylter' with the 'Initial' (before filtering) and 'Final' (after filtering) states, 
or a list of class 'phylterinitial' only, if InitialOnly=TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
# transform trees to a named list of matrices with same dimensions
# and identical row and column orders and names
carnivora.clean&lt;-PreparePhylterData(carnivora)

 
</code></pre>

<hr>
<h2 id='print.phylter'>Print phylter objects</h2><span id='topic+print.phylter'></span>

<h3>Description</h3>

<p>Print on screen a simple description of the content of phylter objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylter'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phylter_+3A_x">x</code></td>
<td>
<p>Object returned by function 'phylter()'.</p>
</td></tr>
<tr><td><code id="print.phylter_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print formatting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
res &lt;- phylter(carnivora, parallel = FALSE)
print(res)
</code></pre>

<hr>
<h2 id='print.phylterfinal'>print objects of class phylterfinal</h2><span id='topic+print.phylterfinal'></span>

<h3>Description</h3>

<p>Print on screen a simple description of the content of objects of class <code>phylterfinal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylterfinal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phylterfinal_+3A_x">x</code></td>
<td>
<p>Object returned by function 'phylter()'.</p>
</td></tr>
<tr><td><code id="print.phylterfinal_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
res &lt;- phylter(carnivora, parallel = FALSE) 
print(res$Final)
</code></pre>

<hr>
<h2 id='print.phylterinitial'>print objects of class phylterinitial</h2><span id='topic+print.phylterinitial'></span>

<h3>Description</h3>

<p>Print on screen a simple description of the content of objects of class <code>phylterinitial</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylterinitial'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phylterinitial_+3A_x">x</code></td>
<td>
<p>Object present in the <code>$initial</code> element of the object returned by function <code>phylter()</code>.</p>
</td></tr>
<tr><td><code id="print.phylterinitial_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
res &lt;- phylter(carnivora, parallel = FALSE) 
print(res$Initial)
</code></pre>

<hr>
<h2 id='print.summary.phylter'>print summary of phylter objects</h2><span id='topic+print.summary.phylter'></span>

<h3>Description</h3>

<p>Prints on screen the summary of an object of class <code>summmary.phylter</code> as returned by the <code>summary.phylter()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.phylter'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.phylter_+3A_x">x</code></td>
<td>
<p>Object returned by function 'summary.phylter()'.</p>
</td></tr>
<tr><td><code id="print.summary.phylter_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
res &lt;- phylter(carnivora, parallel = FALSE)
summary &lt;- summary(res)
print(summary)
</code></pre>

<hr>
<h2 id='rename.genes'>Name or rename a list of gene trees or matrices</h2><span id='topic+rename.genes'></span>

<h3>Description</h3>

<p>Name or rename a list of gene trees or gene matrices genes. For internal use mostly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename.genes(X, gene.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename.genes_+3A_x">X</code></td>
<td>
<p>A list of trees or matrices</p>
</td></tr>
<tr><td><code id="rename.genes_+3A_gene.names">gene.names</code></td>
<td>
<p>List of names to assign to the elements of X. Must be of the same length as length(X). 
If NULL (the default) the object are numbered 1,2,...,length(X).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X with name assigned to each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(carnivora)

# names before renaming
names(carnivora)

carnivora.renamed&lt;-rename.genes(carnivora, gene.names=as.character(1:length(carnivora)))

# names after renaming
names(carnivora.renamed)
</code></pre>

<hr>
<h2 id='simtrees'>Simplistic simulation of gene trees with outliers</h2><span id='topic+simtrees'></span>

<h3>Description</h3>

<p>Simple (simplistic) simulation of trees with outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simtrees(Ngn, Nsp, Nsp.out = 0, Ngn.out = 0, Nb.cell.outlier = 0, 
brlen.sd = 0, out.type="topology",bl.mult=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simtrees_+3A_ngn">Ngn</code></td>
<td>
<p>Number of gene trees to simulate.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_nsp">Nsp</code></td>
<td>
<p>Number of species (tips) per tree.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_nsp.out">Nsp.out</code></td>
<td>
<p>Number of outlier species (also called rogue taxa). 0 = none.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_ngn.out">Ngn.out</code></td>
<td>
<p>Number of outlier genes. 0 = none.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_nb.cell.outlier">Nb.cell.outlier</code></td>
<td>
<p>Number of times one species in one tree is an outlier. 0 = none. The type of outlier is set by <code>out.type=</code>.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_brlen.sd">brlen.sd</code></td>
<td>
<p>Heterogeneity of branch lengths in trees. A value with mean 0 and standard
deviation equal to brlen.sd is added to each branch length. If the resulting branch length has a negative value, its absolute value is taken.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_out.type">out.type</code></td>
<td>
<p>The type of cell outlier. Can be &quot;topology&quot; (the default), where outlier species 
are simulated by branching them elsewhere (randomly) in the tree, &quot;brlength&quot;, where terminal branches of outlier species are 
multiplied by <code>bl.mult</code> (see after) or &quot;both&quot; where half of the outliers are &quot;topology&quot; and the other half are &quot;brlength&quot;.  
In the latter case, if the number of outliers (<code>Nb.cell.outlier</code>) id odd, there is one more topology outlier than brlength outlier simulated.</p>
</td></tr>
<tr><td><code id="simtrees_+3A_bl.mult">bl.mult</code></td>
<td>
<p>Multiplier of terminal branches of outlier species when <code>out.type="topology"</code> or <code>out.type="both"</code>. Ignored otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation process is as follows: a first tree is generated with the <code>rtree()</code> function
and is then duplicated and modified according to the parameters chosen by the user.
</p>


<h3>Value</h3>

<p>A list X containing a list of trees in <code>multiPhylo</code> format (X$trees) and a list of outliers (X$outl).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Very basic simulator, for debugging purpose mainly.
# examples: 30 genes, 120 species, 2 outlier species, 3 outlier genes
# 4 gene/species outliers of type "topology", branch length variance = 0.6.
# The branch length multiplier is set to 2 but this is
# ignored if out.type="topology"
simu&lt;-simtrees(30,120,2,3,4,0.6, "topology",2)
trees&lt;-simu$trees #list of trees
outl&lt;-simu$outl #list of simulated outliers and their type



</code></pre>

<hr>
<h2 id='summary.phylter'>Get summary for phylter objects</h2><span id='topic+summary.phylter'></span>

<h3>Description</h3>

<p>Get the summary of an object of class <code>phylter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylter'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.phylter_+3A_object">object</code></td>
<td>
<p>Object returned by function 'phylter()'.</p>
</td></tr>
<tr><td><code id="summary.phylter_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>On object of class <code>summmary.phylter</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
res &lt;- phylter(carnivora, parallel = FALSE)
summary &lt;- summary(res)
class(summary)
</code></pre>

<hr>
<h2 id='trees2matrices'>Convert phylogenetic trees to distance matrices</h2><span id='topic+trees2matrices'></span>

<h3>Description</h3>

<p>Transform a list of phylogenetic trees into a 
list of phylogenetic distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trees2matrices(trees, distance = "patristic", bvalue = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trees2matrices_+3A_trees">trees</code></td>
<td>
<p>A list of gene trees in format &quot;multiphylo&quot;.</p>
</td></tr>
<tr><td><code id="trees2matrices_+3A_distance">distance</code></td>
<td>
<p>A method to generate distance matrices. It could be &quot;nodal&quot;
to establish that the distance between two species is the number of nodes
that separate them. Or &quot;patristic&quot; (default) if the distance between two
species is the sum of branch lengths separating them. The &quot;nodal&quot; option should
only be used if all species are present in all trees (no missing data).</p>
</td></tr>
<tr><td><code id="trees2matrices_+3A_bvalue">bvalue</code></td>
<td>
<p>This argument is only used if trees contain bootstrap values.
It determines under what bootstrap values the nodes should be collapsed.
Value 0 (the default) means that no nodes are collapsed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list of distance matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora)
matrices&lt;-trees2matrices(carnivora)
</code></pre>

<hr>
<h2 id='write.phylter'>Write summary of phyter analysis to file(s)</h2><span id='topic+write.phylter'></span>

<h3>Description</h3>

<p>Write the summary of the phylter analysis in a txt file or as a pdf report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.phylter(
  x,
  file = "",
  include.discarded = TRUE,
  pdfreport = FALSE,
  pdfreport.file = "report.pdf"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.phylter_+3A_x">x</code></td>
<td>
<p>The object returned by the 'phylter()' function.</p>
</td></tr>
<tr><td><code id="write.phylter_+3A_file">file</code></td>
<td>
<p>Name of the file where to write the text summary of the phylter output.
If <code>""</code> (the default), <code>write.phylyer()</code> prints to the standard output.</p>
</td></tr>
<tr><td><code id="write.phylter_+3A_include.discarded">include.discarded</code></td>
<td>
<p>Logical. If TRUE (the default) the elements discarded before the analysis
are still in the list of Outliers in the output. Useful for cleaning datasets after a phylter analysis.</p>
</td></tr>
<tr><td><code id="write.phylter_+3A_pdfreport">pdfreport</code></td>
<td>
<p>Logical. Should a full report of the phylter analysis</p>
</td></tr>
<tr><td><code id="write.phylter_+3A_pdfreport.file">pdfreport.file</code></td>
<td>
<p>If <code>report=TRUE</code>, name of the pdf file where the 
report is written. Default to <code>report.pdf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carnivora) 
res &lt;- phylter(carnivora, parallel = FALSE)
# write a full report to the standard output
write.phylter(res) 


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
