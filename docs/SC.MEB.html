<!DOCTYPE html><html lang="en"><head><title>Help for package SC.MEB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SC.MEB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ClusterPlot'><p>ClusterPlot.</p></a></li>
<li><a href='#find_neighbors2'><p>find_neighbors2.</p></a></li>
<li><a href='#getneighborhood_fast'><p>getneighborhood_fast</p></a></li>
<li><a href='#ICMEM'><p>ICMEM.</p></a></li>
<li><a href='#parafun'><p>parafun.</p></a></li>
<li><a href='#PC'><p>simulated PCs</p></a></li>
<li><a href='#SC.MEB'><p>SC.MEB.</p></a></li>
<li><a href='#sce'><p>A simulated SingleCellExperiment</p></a></li>
<li><a href='#selectK'><p>selectK.</p></a></li>
<li><a href='#selectKPlot'><p>selectKPlot.</p></a></li>
<li><a href='#spatialPreprocess'><p>Preprocess a spatial dataset for SC-MEB</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Clustering with Hidden Markov Random Field using
Empirical Bayes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial clustering with hidden markov random field fitted via EM algorithm, details of which can be found in Yi Yang (2021) &lt;<a href="https://doi.org/10.1101%2F2021.06.05.447181">doi:10.1101/2021.06.05.447181</a>&gt;. It is not only computationally efficient and scalable to the sample size increment, but also is capable of choosing the smoothness parameter and the number of clusters as well.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mclust,parallel,ggplot2, Matrix, R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), SingleCellExperiment, purrr,BiocSingular,
SummarizedExperiment, scater, scran, S4Vectors</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-06 14:54:38 UTC; yygao</td>
</tr>
<tr>
<td>Author:</td>
<td>Yi Yang [aut, cre],
  Xingjie Shi [aut],
  Jin Liu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yi Yang &lt;yygaosansiban@sina.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-08 08:40:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='ClusterPlot'>ClusterPlot.</h2><span id='topic+ClusterPlot'></span>

<h3>Description</h3>

<p>The function ClusterPlot is used to Visualize spatial clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterPlot(out, pos, size = 5, shape = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClusterPlot_+3A_out">out</code></td>
<td>
<p>is the output of function selectK.</p>
</td></tr>
<tr><td><code id="ClusterPlot_+3A_pos">pos</code></td>
<td>
<p>is a n-by-2 matrix of position.</p>
</td></tr>
<tr><td><code id="ClusterPlot_+3A_size">size</code></td>
<td>
<p>is a positive value for characterizing the size of point in the plot, which is the same as size in ggplot2.</p>
</td></tr>
<tr><td><code id="ClusterPlot_+3A_shape">shape</code></td>
<td>
<p>is a positive value for characterizing the shape of point in the plot, which is the same as shape in ggplot2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ClusterPlot is used to Visualize spatial clusters.
</p>


<h3>Value</h3>

<p>a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos = cbind(rep(1:5, each=5), rep(1:5, 5))
out = list()
out[[1]] = ""
out[[2]] = rep(1:5, each = 5)
ClusterPlot(out, pos)
</code></pre>

<hr>
<h2 id='find_neighbors2'>find_neighbors2.</h2><span id='topic+find_neighbors2'></span>

<h3>Description</h3>

<p>find_neighbors2 was used to find the neighborhood of spot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_neighbors2(sce, platform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_neighbors2_+3A_sce">sce</code></td>
<td>
<p>is a SingleCellExperiment object containing PCA and position informatin.</p>
</td></tr>
<tr><td><code id="find_neighbors2_+3A_platform">platform</code></td>
<td>
<p>is the name of spatial transcriptomic platform. Specify 'Visium' for hex lattice geometry or 'ST' for square lattice geometry. Specifying this parameter is optional as this information is included in their metadata.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>find_neighbors2 was used to find the neighborhood of spot.
</p>


<h3>Value</h3>

<p>a sparse matrix recording the information of neighborhood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sce)
platform = "ST"
Adj &lt;- find_neighbors2(sce, platform)
</code></pre>

<hr>
<h2 id='getneighborhood_fast'>getneighborhood_fast</h2><span id='topic+getneighborhood_fast'></span>

<h3>Description</h3>

<p>an efficient function to find the neighborhood based on the matrix of position and a pre-defined cutoff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getneighborhood_fast(x, cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getneighborhood_fast_+3A_x">x</code></td>
<td>
<p>is a n-by-2 matrix of position.</p>
</td></tr>
<tr><td><code id="getneighborhood_fast_+3A_cutoff">cutoff</code></td>
<td>
<p>is a threashold of Euclidean distance to decide whether a spot is an neighborhood of another spot. For example, if the Euclidean distance between spot A and B is less than cutoff, then A is taken as the neighbourhood of B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix containing the neighbourhood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj = getneighborhood_fast(pos, 2)
</code></pre>

<hr>
<h2 id='ICMEM'>ICMEM.</h2><span id='topic+ICMEM'></span>

<h3>Description</h3>

<p>The function ICMEM was used to conduct spatial clustering with hidden Markov random field for a sequence of beta and fixed number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICMEM(
  y,
  x_int,
  Adj,
  mu_int,
  sigma_int,
  alpha,
  beta_grid,
  PX,
  maxIter_ICM,
  maxIter
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICMEM_+3A_y">y</code></td>
<td>
<p>is a matrix of PCs containing gene expression.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_x_int">x_int</code></td>
<td>
<p>is a vector of initial cluster label.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_adj">Adj</code></td>
<td>
<p>is a matrix containing neighborhood information generated by find_neighbors2.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_mu_int">mu_int</code></td>
<td>
<p>is a initial mean vector. we often generated it by Gaussian mixture model.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_sigma_int">sigma_int</code></td>
<td>
<p>is a initial co-variance matrix. we often generated it by Gaussian mixture model.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_alpha">alpha</code></td>
<td>
<p>is a intercept.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_beta_grid">beta_grid</code></td>
<td>
<p>is a sequence of smoothing parameter that can be specified by user.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_px">PX</code></td>
<td>
<p>is a logical value specifying the parameter expansion in EM algorithm.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_maxiter_icm">maxIter_ICM</code></td>
<td>
<p>is the maximum iteration of ICM algorithm.</p>
</td></tr>
<tr><td><code id="ICMEM_+3A_maxiter">maxIter</code></td>
<td>
<p>is the maximum iteration of EM algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ICMEM was used to conduct spatial clustering with hidden Markov random field for fixed beta and fixed number of clusters
</p>


<h3>Value</h3>

<p>a list.
</p>
<p>The item 'x' is the clustering result. 
</p>
<p>The item 'gam' is the posterior probability matrix.
</p>
<p>The item 'ell' is the opposite log-likelihood. 
</p>
<p>The item 'mu' is the mean of each component.
</p>
<p>The item 'sigma' is the variance of each component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = matrix(rnorm(50, 0, 1), 25,2)
pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj = getneighborhood_fast(pos, 1.2)
beta_grid = c(0.5,1)
G = 2
fit_int = Mclust(y, G = G)
x_gmm &lt;- fit_int$classification
mu_int &lt;- unname(fit_int$parameter$mean)
sigma_int &lt;- unname(fit_int$parameter$variance$sigma) 
alpha &lt;- -log(fit_int$parameter$pro)*0
reslist &lt;- ICMEM(y = y, x_int = x_gmm, Adj = Adj, mu_int = mu_int, sigma_int = sigma_int,
alpha = alpha, beta_grid = beta_grid, 
PX = TRUE, maxIter_ICM = 10, maxIter = 50) 
</code></pre>

<hr>
<h2 id='parafun'>parafun.</h2><span id='topic+parafun'></span>

<h3>Description</h3>

<p>The function parafun implements the model SC-MEB for fixed number of clusters and a sequence of beta with initial value from Gaussian mixture model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parafun(
  y,
  Adj,
  G,
  beta_grid = seq(0, 4, 0.2),
  PX = TRUE,
  maxIter_ICM = 10,
  maxIter = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parafun_+3A_y">y</code></td>
<td>
<p>is n-by-d PCs.</p>
</td></tr>
<tr><td><code id="parafun_+3A_adj">Adj</code></td>
<td>
<p>is a sparse matrix of neighborhood.</p>
</td></tr>
<tr><td><code id="parafun_+3A_g">G</code></td>
<td>
<p>is an integer specifying the numbers of clusters.</p>
</td></tr>
<tr><td><code id="parafun_+3A_beta_grid">beta_grid</code></td>
<td>
<p>is a numeric vector specifying the smoothness parameter of Random Markov Field. The default is seq(0,4,0.2).</p>
</td></tr>
<tr><td><code id="parafun_+3A_px">PX</code></td>
<td>
<p>is a logical value specifying the parameter expansion in EM algorithm.</p>
</td></tr>
<tr><td><code id="parafun_+3A_maxiter_icm">maxIter_ICM</code></td>
<td>
<p>is the maximum iteration of ICM algorithm. The default is 10.</p>
</td></tr>
<tr><td><code id="parafun_+3A_maxiter">maxIter</code></td>
<td>
<p>is the maximum iteration of EM algorithm. The default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function parafun implements the model SC-MEB for fixed number of clusters and a sequence of beta with initial value from Gaussian mixture model
</p>


<h3>Value</h3>

<p>a list, We briefly explain the output of the SC.MEB. 
</p>
<p>The item 'x' storing clustering results.
</p>
<p>The item 'gam' is the posterior probability matrix.
</p>
<p>The item 'ell' is the opposite log-likelihood. 
</p>
<p>The item 'mu' is the mean of each component.
</p>
<p>The item 'sigma' is the variance of each component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = matrix(rnorm(50, 0, 1), 25,2)
pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj_sp = getneighborhood_fast(pos, 1.2)
beta_grid = c(0.5,1)
G = 2
out = parafun(y, Adj_sp, G, beta_grid)
</code></pre>

<hr>
<h2 id='PC'>simulated PCs</h2><span id='topic+PC'></span>

<h3>Description</h3>

<p>A dataset containing PCs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PC)
</code></pre>


<h3>Format</h3>

<p>It is a matrix containing 5 PCs
</p>
<p>the variables are listed as following
</p>

<dl>
<dt>PC1</dt><dd><p>The 1th PC</p>
</dd>
<dt>PC2</dt><dd><p>The 2th PC</p>
</dd>
</dl>
<p>...
</p>
<dl>
<dt>PC5</dt><dd><p>The 5th PC</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## run the PC with the Gaussian mixture model
data(PC)
out1 = mclust::Mclust(PC,G = 2)
</code></pre>

<hr>
<h2 id='SC.MEB'>SC.MEB.</h2><span id='topic+SC.MEB'></span>

<h3>Description</h3>

<p>SC.MEB implements the model SC-MEB, spatial clustering with hidden Markov random field using empirical Bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SC.MEB(
  y,
  Adj_sp,
  beta_grid = seq(0, 4, 0.2),
  K_set = 2:10,
  parallel = TRUE,
  num_core = 5,
  PX = TRUE,
  maxIter_ICM = 10,
  maxIter = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SC.MEB_+3A_y">y</code></td>
<td>
<p>is n-by-d PCs.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_adj_sp">Adj_sp</code></td>
<td>
<p>is a sparse matrix of neighborhood. It is often generated from function find_neighbors2 or getneighborhood_fast.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_beta_grid">beta_grid</code></td>
<td>
<p>is a numeric vector specifying the smoothness parameter of Random Markov Field. The default is seq(0,4,0.2).</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_k_set">K_set</code></td>
<td>
<p>is an integer vector specifying the numbers of mixture components (clusters) for which the BIC is to be calculated. The default is K = 2:10.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_parallel">parallel</code></td>
<td>
<p>is a logical value to decide whether the function SC.MEB run in parallel. The default is TRUE.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_num_core">num_core</code></td>
<td>
<p>is an integer value to decide how many cores are used to run SC.MEB in parallel.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_px">PX</code></td>
<td>
<p>is a logical value to decide whether to use parameter expansion in EM algorithm</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_maxiter_icm">maxIter_ICM</code></td>
<td>
<p>is the maximum iteration of ICM algorithm. The default is 10.</p>
</td></tr>
<tr><td><code id="SC.MEB_+3A_maxiter">maxIter</code></td>
<td>
<p>is the maximum iteration of EM algorithm. The default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SC.MEB can implements the model SC-MEB in parallel which can improve the speed of the computation.
</p>


<h3>Value</h3>

<p>a list, We briefly explain the output of the SC.MEB. 
</p>
<p>The item 'x' contains clustering results.
</p>
<p>The item 'gam' is the posterior probability matrix.
</p>
<p>The item 'ell' is the opposite log-likelihood. 
</p>
<p>The item 'mu' is the mean of each component.
</p>
<p>The item 'sigma' is the variance of each component.
</p>


<h3>References</h3>

<p>Yang Y, Shi X, Zhou Q, et al. SC-MEB: spatial clustering with hidden Markov random field using empirical Bayes[J]. bioRxiv, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = matrix(rnorm(50, 0, 1), 25,2)
pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj_sp = getneighborhood_fast(pos, 1.2)
beta_grid = c(0.5,1)
K_set = 2:3
out = SC.MEB(y, Adj_sp, beta_grid, K_set, TRUE, 2)
</code></pre>

<hr>
<h2 id='sce'>A simulated SingleCellExperiment</h2><span id='topic+sce'></span>

<h3>Description</h3>

<p>A dataset of SingleCellExperiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sce)
</code></pre>


<h3>Format</h3>

<p>It is a SingleCellExperiment object with gene expression and meta information
</p>


<h3>References</h3>

<p>Amezquita R A, Lun A T L, Becht E, et al. Orchestrating single-cell analysis with Bioconductor[J]. Nature methods, 2020, 17(2): 137-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## find the neighborhood of spots in SingleCellExperiment
data(sce)
out = find_neighbors2(sce, "ST")
</code></pre>

<hr>
<h2 id='selectK'>selectK.</h2><span id='topic+selectK'></span>

<h3>Description</h3>

<p>The function selectK is used to select the best K according to BIC or Modified BIC criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectK(SCobject, K_set = 2:10, criterion = "BIC", c = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectK_+3A_scobject">SCobject</code></td>
<td>
<p>is an object generated from SC.MEB function.</p>
</td></tr>
<tr><td><code id="selectK_+3A_k_set">K_set</code></td>
<td>
<p>is a integer vector used in SC.MEB. The default is 2:10</p>
</td></tr>
<tr><td><code id="selectK_+3A_criterion">criterion</code></td>
<td>
<p>is a character specifying the criterion for selecting K. The default value is BIC. The alternative value MBIC can also be used.</p>
</td></tr>
<tr><td><code id="selectK_+3A_c">c</code></td>
<td>
<p>is a positive value in the modified BIC. The default is 1.
Here we briefly explain how to choose the parameter c in the modified BIC. In general, For the ST or Visium dataset, it often ranges from 0.4 to 1 while for the MERFISH dataset with large number of cells, it often becomes larger, for example 10,20. Most importantly, SC-MEB is fast, scaling well in terms of sample size, which allow the user to tune the c based on their prior knowledge about the tissues or cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selectK is used to select the best K according to BIC or Modified BIC criterion.
</p>


<h3>Value</h3>

<p>a list contains two items. one is for the best K and the other is the clustering labels of n spots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = matrix(rnorm(50, 0, 1), 25,2)
pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj_sp = getneighborhood_fast(pos, 1.2)
beta_grid = c(0.5,1)
K_set = 2:3
out = SC.MEB(y, Adj_sp, beta_grid, K_set, TRUE, 2)
selectK(out, K_set)
</code></pre>

<hr>
<h2 id='selectKPlot'>selectKPlot.</h2><span id='topic+selectKPlot'></span>

<h3>Description</h3>

<p>The function selectKPlot is used to demonstrate the scatter plot of BIC or Modified BIC vs K for selecting the best K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectKPlot(SCobject, K_set = 2:10, criterion = "BIC", c = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectKPlot_+3A_scobject">SCobject</code></td>
<td>
<p>is a object generated from SC.MEB function.</p>
</td></tr>
<tr><td><code id="selectKPlot_+3A_k_set">K_set</code></td>
<td>
<p>is the corresponding K_set used in your previous function SC.MEB.</p>
</td></tr>
<tr><td><code id="selectKPlot_+3A_criterion">criterion</code></td>
<td>
<p>is a character specifying the criterion for selecting K. The default is BIC, the alternative criterion MBIC can also be used.</p>
</td></tr>
<tr><td><code id="selectKPlot_+3A_c">c</code></td>
<td>
<p>is a positive value in modified BIC. The default is 1.
Here we briefly explain how to choose the parameter c in the modified BIC. In general, For the ST or Visium dataset, it often ranges from 0.4 to 1 while for the MERFISH dataset with large number of cells, it often becomes larger, for example 10,20. Most importantly, SC-MEB is fast, scaling well in terms of sample size, which allow the user to tune the c based on their prior knowledge about the tissues or cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selectKPlot is used to demonstrate the scatter plot of BIC or Modified BIC vs K for selecting the best K.
</p>


<h3>Value</h3>

<p>a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = matrix(rnorm(50, 0, 1), 25,2)
pos = cbind(rep(1:5, each=5), rep(1:5, 5))
Adj_sp = getneighborhood_fast(pos, 1.2)
beta_grid = c(0.5,1)
K_set = 2:3
out = SC.MEB(y, Adj_sp, beta_grid, K_set, TRUE, 2)
selectKPlot(out, K_set)
</code></pre>

<hr>
<h2 id='spatialPreprocess'>Preprocess a spatial dataset for SC-MEB</h2><span id='topic+spatialPreprocess'></span>

<h3>Description</h3>

<p>Adds metadata required for downstream analyses, and (optionally) performs PCA
on log-normalized expression of top HVGs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialPreprocess(
  sce,
  platform = c("Visium", "ST"),
  n.PCs = 15,
  n.HVGs = 2000,
  skip.PCA = FALSE,
  log.normalize = TRUE,
  assay.type = "logcounts",
  BSPARAM = BiocSingular::ExactParam()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialPreprocess_+3A_sce">sce</code></td>
<td>
<p>SingleCellExperiment to preprocess</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_platform">platform</code></td>
<td>
<p>Spatial sequencing platform. Used to determine spot layout
and neighborhood structure (Visium = hex, ST = square).</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_n.pcs">n.PCs</code></td>
<td>
<p>Number of principal components to compute. We suggest using the
top 15 PCs in most cases.</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_n.hvgs">n.HVGs</code></td>
<td>
<p>Number of highly variable genes to run PCA upon.</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_skip.pca">skip.PCA</code></td>
<td>
<p>Skip PCA (if dimensionality reduction was previously
computed.)</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_log.normalize">log.normalize</code></td>
<td>
<p>Whether to log-normalize the input data with scater. May
be omitted if log-normalization previously computed.</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_assay.type">assay.type</code></td>
<td>
<p>Name of assay in <code>sce</code> containing normalized counts.
Leave as &quot;logcounts&quot; unless you explicitly pre-computed a different
normalization and added it to <code>sce</code> under another assay. Note that we
do not recommend running BayesSpace on PCs computed from raw counts.</p>
</td></tr>
<tr><td><code id="spatialPreprocess_+3A_bsparam">BSPARAM</code></td>
<td>
<p>A BiocSingularParam object specifying which
algorithm should be used to perform the PCA. By default, an exact PCA is
performed, as current spatial datasets are generally small (&lt;10,000 spots).
To perform a faster approximate PCA, please specify
<code>FastAutoParam()</code> and set a random seed to ensure
reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SingleCellExperiment with PCA and SC.MEB metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the simulated data 
data(sce)
platform = "ST"
out = find_neighbors2(sce, platform)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
