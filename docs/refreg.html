<!DOCTYPE html><html lang="en"><head><title>Help for package refreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {refreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACE'><p>Alternating Conditional Expectation (ACE) algorithm</p></a></li>
<li><a href='#aegis'><p>A Estrada Glycation and Inflammation Study (AEGIS) Data</p></a></li>
<li><a href='#bivRegion'><p>Bivariate reference region estimation</p></a></li>
<li><a href='#bivRegr'><p>Bivariate regression model</p></a></li>
<li><a href='#Hcov'><p>Kernel bandwidth selection method based on bivariate density</p>
contours coverage</a></li>
<li><a href='#plot.bivRegion'><p>Plot a bivRegion object</p></a></li>
<li><a href='#plot.bivRegr'><p>Plot method for bivRegr fit</p></a></li>
<li><a href='#plot.refcurve'><p>Plot univariate conditional quantile models curves (i.e. reference curves)</p></a></li>
<li><a href='#plot.summary_boot'><p>Default summary_boot plotting</p></a></li>
<li><a href='#plot.trivRegion'><p>Default trivRegion plotting</p></a></li>
<li><a href='#pollution'><p>SO2 and Nox concentrations</p></a></li>
<li><a href='#pollution_episode'><p>SO2 and Nox concentrations during a pollution episode</p></a></li>
<li><a href='#predict.bivRegion'><p>Prediction for a bivRegion object</p></a></li>
<li><a href='#predict.bivRegr'><p>Predict method for bivRegr</p></a></li>
<li><a href='#refcurv'><p>Univariate reference curve model</p></a></li>
<li><a href='#summary_boot'><p>bivRegr summary function</p></a></li>
<li><a href='#summary.bivRegion'><p>bivRegion summary method</p></a></li>
<li><a href='#trivRegion'><p>Trivariate reference region estimation</p></a></li>
<li><a href='#trivRegr'><p>Trivariate regression model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conditional Multivariate Reference Regions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oscar Lado-Baleato &lt;oscarlado.baleato@usc.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R package for estimating conditional multivariate reference regions. 
    The reference region is non parametrically estimated using a kernel density estimator.
    Covariates effects on the multivariate response means vector and variance-covariance
    matrix, thus on the region shape, are estimated by flexible additive predictors. 
    Continuous covariates non linear effects might be estimated using penalized splines smoothers.
    Confidence intervals for the covariates estimated effects might be derived from
    bootstrap resampling. Kernel density bandwidth can be estimated with different methods, including
    a method that optimize the region coverage. Numerical, and graphical, summaries
    can be obtained by the user in order to evaluate reference region performance with real data.
    Full mathematical details can be found in &lt;<a href="https://doi.org/10.1002%2Fsim.9163">doi:10.1002/sim.9163</a>&gt; and &lt;<a href="https://doi.org/10.1007%2Fs00477-020-01901-1">doi:10.1007/s00477-020-01901-1</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>ks,KernSmooth,mgcv,gridExtra,ggplot2,RColorBrewer,sp,stringr,foreach,doParallel,pracma,misc3d,rgl,mbend,matrixcalc,methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-18 10:00:50 UTC; Usuario</td>
</tr>
<tr>
<td>Author:</td>
<td>Oscar Lado-Baleato [cre, aut],
  Javier Roca-Pardinas [aut, ctb],
  Carmen Cadarso-Suarez [aut, ths],
  Gude Francisco [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-18 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACE'>Alternating Conditional Expectation (ACE) algorithm</h2><span id='topic+ACE'></span>

<h3>Description</h3>

<p>This function implements Alternating Conditional Expectation algorithm
(ACE, Hastie and Tibshirani, 1990). This is a bivRegr's inner function
for estimating variance, and correlation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACE(
  y = "y",
  predictor = "~s(x)",
  restriction = "positive",
  eps = 0.01,
  itmax = 10,
  data = data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACE_+3A_y">y</code></td>
<td>
<p>A character defining the response variable.</p>
</td></tr>
<tr><td><code id="ACE_+3A_predictor">predictor</code></td>
<td>
<p>The regression predictor, following the mgcv package structure (see example below).</p>
</td></tr>
<tr><td><code id="ACE_+3A_restriction">restriction</code></td>
<td>
<p>Type of restriction to be imposed to the response variable,
&quot;positive&quot; for variance, and &quot;correlation&quot; for the correlation.</p>
</td></tr>
<tr><td><code id="ACE_+3A_eps">eps</code></td>
<td>
<p>A number defining the allowed estimation error, default = 0.01.</p>
</td></tr>
<tr><td><code id="ACE_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations of the algorithm, default = 10.</p>
</td></tr>
<tr><td><code id="ACE_+3A_data">data</code></td>
<td>
<p>A data frame containing the response, and predictor variables.</p>
</td></tr>
<tr><td><code id="ACE_+3A_...">...</code></td>
<td>
<p>Additional mgcv::gam() parameters to be modified by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a mgcv::gam() fit for a transformed response.
</p>


<h3>References</h3>

<p>Hastie, T. &amp; Tibshirani, J. (1990) Generalized additive models.
CRC press. London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- runif(n, -1, 1)
y &lt;- x^2 + rnorm(n, sd = 0.1)
df &lt;- data.frame(y, x)
plot(df$x, df$y)
m1 &lt;- ACE(
  y = "y", predictor = "~s(x)", restriction = "positive",
  eps = 0.01, itmax = 10, data = df
)$fit
nw &lt;- data.frame(x = seq(-1, 1, 0.1))
abline(h = 0, col = 2)
lines(exp(predict(m1, newdata = nw)) ~ nw$x, col = 3, lwd = 2)
legend("top", legend = c("ACE fit", "Zero"), lty = 1, lwd = 2, col = c(3, 2), bty = "n")
</code></pre>

<hr>
<h2 id='aegis'>A Estrada Glycation and Inflammation Study (AEGIS) Data</h2><span id='topic+aegis'></span>

<h3>Description</h3>

<p>The aegis dataset was obtained from the Estrada Glycation and Inflammation
(AEGIS) project. A cross sectional, population based study that was
performed in the municipality of  A Estrada (Galicia, NW Spain). The study
objective was to investigate the association between glycation, inflammation
status, lifestyle and common diseases, and reasons for glycemic markers
discordances (Gude et al., 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aegis
</code></pre>


<h3>Format</h3>

<p>A data frame containing 1516 observations, and 7 variables:
</p>

<dl>
<dt>id</dt><dd><p>Anonymized patient identificator.</p>
</dd>
<dt>gender</dt><dd><p>A factor variable describing patient gender, (female, and male).</p>
</dd>
<dt>age</dt><dd><p>Patients' age.</p>
</dd>
<dt>dm</dt><dd><p>Diabetes mellitus indicator (no, and yes).</p>
</dd>
<dt>fpg</dt><dd><p>Fasting plasma glucose levels (mg/dL).</p>
</dd>
<dt>hba1c</dt><dd><p>Glycated hemoglobin percentage.</p>
</dd>
<dt>fru</dt><dd><p>Fructosamine concentration (mg/dL).</p>
</dd>
</dl>



<h3>References</h3>

<p>Gude F, Diaz&ndash;Vidal P, Rua&ndash;Perez C, et al. Glycemic variability and its association with demographics and lifestyles in ageneral adult population. J Diabetes Sci Technol. 2017; 11(4): 780&ndash;790
</p>

<hr>
<h2 id='bivRegion'>Bivariate reference region estimation</h2><span id='topic+bivRegion'></span>

<h3>Description</h3>

<p>This functions estimate a probabilistic/reference region for bivariate data. It is
based on a kernel density estimation. It may be applied to a
set of bivariate data points, or to a bivRegr object. In the former case, the
function will estimate a bivariate reference region for the model standarized
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivRegion(
  Y = fit,
  H_choice = "Hcov",
  tau = 0.95,
  k = 20,
  display_plot = TRUE,
  shape = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivRegion_+3A_y">Y</code></td>
<td>
<p>A set of bivariate data points, or a bivRegr object.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_h_choice">H_choice</code></td>
<td>
<p>Kernel bandwidth selection method: &quot;plug.in&quot; for plug.in method,
&quot;LSCV&quot; for least squate cross valiation, &quot;SCV&quot; for smooth cross validation,
and &quot;Hcov&quot; for a bandwidth selection method which optimize the region coverage.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_tau">tau</code></td>
<td>
<p>A number or vector defining the desired coverage(s) of the bivariate
reference region.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_k">k</code></td>
<td>
<p>In case of using &quot;Hcov&quot; the number of k fold cross validations
replicates to be performed.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_display_plot">display_plot</code></td>
<td>
<p>A logical indicating if plot must be displayed during &quot;Hcov&quot;
bandwidht estimation procedure. The plot depicts region's coverage, evaluated
with k fold cross validation, depending on kernel bandwidth value.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_shape">shape</code></td>
<td>
<p>Shape parameter modulating the final shape of the bivariate
probabilistic/reference region by hand.</p>
</td></tr>
<tr><td><code id="bivRegion_+3A_...">...</code></td>
<td>
<p>Additional parameters to be modified in KernSmooth::bkde2D()
function by the user (e.g. gridsize).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a region or a set of regions containing a given
percentage of bivariate data points.
</p>


<h3>References</h3>

<p>Duong, T. (2019) ks: Kernel Smoothing. R package version 1.11.6. https://CRAN.R&ndash;project.org/package=ks.
</p>
<p>Matt Wand (2020). KernSmooth: Functions for Kernel Smoothing Supporting Wand &amp; Jones (1995). R package version 2.23&ndash;18. https://CRAN.R&ndash;project.org/package=KernSmooth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- cbind(rnorm(100), rnorm(100))
Y &lt;- as.data.frame(Y)
names(Y) &lt;- c("y1", "y2")
region &lt;- bivRegion(Y, tau = 0.95, shape = 2)
plot(region)
</code></pre>

<hr>
<h2 id='bivRegr'>Bivariate regression model</h2><span id='topic+bivRegr'></span>

<h3>Description</h3>

<p>This function estimates the covariates effects on the means vector,
and variance covariance matrix from a bivariate variable. Non linear effects
might be estimated for continuous covariates using penalized spline smoothers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivRegr(f = f, data = data, ace.eps = 0.01, ace.itmax = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivRegr_+3A_f">f</code></td>
<td>
<p>A list of five formulas defining the covariates effects
in both responses means, variances, and in their correlation. The formulas
follow the same structure as mgcv::gam() (see example below).</p>
</td></tr>
<tr><td><code id="bivRegr_+3A_data">data</code></td>
<td>
<p>A data frame containing the reponses, and predictor variables values.</p>
</td></tr>
<tr><td><code id="bivRegr_+3A_ace.eps">ace.eps</code></td>
<td>
<p>A number defining the error rate in the ACE algorithm.</p>
</td></tr>
<tr><td><code id="bivRegr_+3A_ace.itmax">ace.itmax</code></td>
<td>
<p>A number defining the maximum number of ACE algorithm iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the covariates effect on the means,
variances, and correlation of a bivariate response variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate reference region for fasting plasma glucose (fpg)
# and glycated hemoglobin (hba1c) levels depending on age

dm_no &lt;- subset(aegis, aegis$dm == "no") # select healthy patients
# 1.1) Define predictors
mu1 &lt;- fpg ~ s(age)
mu2 &lt;- hba1c ~ s(age)
var1 &lt;- ~ s(age)
var2 &lt;- ~ s(age)
rho &lt;- ~ s(age)
f &lt;- list(mu1, mu2, var1, var2, rho)

fit &lt;- bivRegr(f, data = dm_no)

# 1.2) Depict the estimated covariates effects
plot(fit, eq = 1)
plot(fit, eq = 2)
plot(fit, eq = 3)
plot(fit, eq = 4)
plot(fit, eq = 5)
# 1.2.1) Depict the estimated covariates effects with CI (Not Run)

s0 &lt;- summary_boot(fit, B = 100) # no parallelization
# s1 = summary_boot(fit,B=100,parallel=TRUE) #parallelization
plot(s0, eq = 1)


# 1.3) Obtain the reference region in the standarized residuals
region &lt;- bivRegion(fit, tau = 0.95, shape = 2)
plot(region)

# 1.4) Identify those patients located outside the reference region
summary(region)

# 1.5) Depict the conditional reference region for two ages
plot(region,
  cond = TRUE, newdata = data.frame(age = c(20, 50)), col = "grey", pch = "*",
  reg.lwd = 2, reg.lty = 2
)

</code></pre>

<hr>
<h2 id='Hcov'>Kernel bandwidth selection method based on bivariate density
contours coverage</h2><span id='topic+Hcov'></span>

<h3>Description</h3>

<p>This function implements a method for estimating bivariate kernel bandwidth
based on data covarage. The method starts with the plug in estimate (which
usually overfits the data), and then increase this bandwidth value until the
desired coverage is obtained. Region coverage is evaluated in an out sample
design, using a k fold cross validation scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hcov(Y, shape = seq(1, 10, 0.5), k = 20, tau = 0.9, display_plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hcov_+3A_y">Y</code></td>
<td>
<p>A matrix containing bivariate data values.</p>
</td></tr>
<tr><td><code id="Hcov_+3A_shape">shape</code></td>
<td>
<p>A sequence of values which controls plug in estimator increasing.</p>
</td></tr>
<tr><td><code id="Hcov_+3A_k">k</code></td>
<td>
<p>A number indicating k fold cross validations to be performed.</p>
</td></tr>
<tr><td><code id="Hcov_+3A_tau">tau</code></td>
<td>
<p>The desired region coverage</p>
</td></tr>
<tr><td><code id="Hcov_+3A_display_plot">display_plot</code></td>
<td>
<p>A logical indicating if a plot must be displaying, during
the function estimation process, summarizing the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a diagonal kernel bandwidth matrix.
</p>

<hr>
<h2 id='plot.bivRegion'>Plot a bivRegion object</h2><span id='topic+plot.bivRegion'></span>

<h3>Description</h3>

<p>This function allow to depict the estimated bivariate reference/probabilistic region, in
the estandarized residuals scale (cond=FALSE), or for any covariate value (cond=TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivRegion'
plot(
  x,
  tau = 0.95,
  newdata = NULL,
  reg.col = NULL,
  reg.lwd = 1,
  reg.lty = NULL,
  axes = TRUE,
  axes.col = "black",
  axes.lwd = 2L,
  cond = FALSE,
  add = FALSE,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bivRegion_+3A_x">x</code></td>
<td>
<p>A bivRegion object.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_tau">tau</code></td>
<td>
<p>A number, or vector, defining the desired coverage(s) of the bivariate reference region.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_newdata">newdata</code></td>
<td>
<p>If cond=FALSE, a data.frame with new values to be depicted in
the standarized residuals scale. If cond=TRUE, a data frame containing covariate
values for which the reference/probabilistic region will be depicted.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_reg.col">reg.col</code></td>
<td>
<p>Region line colour, in case of more than one tau it can be a vector.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_reg.lwd">reg.lwd</code></td>
<td>
<p>Region line width, in case of more than one tau it can be a vector.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_reg.lty">reg.lty</code></td>
<td>
<p>Region line type, in case of more than one tau it can be a vector.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_axes">axes</code></td>
<td>
<p>Logical; if TRUE (and cond=FALSE), vertical and horizontal lines
are added indicating four quadrants in the model residuals scale.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_axes.col">axes.col</code></td>
<td>
<p>Axes colour.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_axes.lwd">axes.lwd</code></td>
<td>
<p>Axes line width.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_cond">cond</code></td>
<td>
<p>A logical argument, if TRUE a conditional reference region is depicted.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_add">add</code></td>
<td>
<p>A logical argument, if TRUE the conditional reference region is depicted over a pre existing plot.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_legend">legend</code></td>
<td>
<p>A logical argument, if TRUE a legend is given along with the reference region.</p>
</td></tr>
<tr><td><code id="plot.bivRegion_+3A_...">...</code></td>
<td>
<p>Further plot parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a graphical representation for a bivRegion object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- cbind(rnorm(100), rnorm(100))
Y &lt;- as.data.frame(Y)
names(Y) &lt;- c("y1", "y2")
reg &lt;- bivRegion(Y, tau = 0.95, shape = 2)
plot(reg)
</code></pre>

<hr>
<h2 id='plot.bivRegr'>Plot method for bivRegr fit</h2><span id='topic+plot.bivRegr'></span>

<h3>Description</h3>

<p>This function takes an bivRegr object and plots the estimated effects for the
conditional response means, variances or correlation. summary_boot function
must be applied by the user in order to get the estimated effects confidence
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivRegr'
plot(x, eq = 1, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bivRegr_+3A_x">x</code></td>
<td>
<p>A bivRegr fit.</p>
</td></tr>
<tr><td><code id="plot.bivRegr_+3A_eq">eq</code></td>
<td>
<p>A number indicating the model effects to be depicted; 1 = first response mean,
2 = second response mean, 3 = first response variance, 4 = second response variance, and
5 = correlation model.</p>
</td></tr>
<tr><td><code id="plot.bivRegr_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing covariates values.</p>
</td></tr>
<tr><td><code id="plot.bivRegr_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot for bivRegr mean, variance and correlation models.
</p>

<hr>
<h2 id='plot.refcurve'>Plot univariate conditional quantile models curves (i.e. reference curves)</h2><span id='topic+plot.refcurve'></span>

<h3>Description</h3>

<p>This function depict the univariate conditional quantile model based
on the non parametric location scale model fitted with the refcurv function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'refcurve'
plot(
  x,
  newdata = data.frame(x = seq(0, 1, 0.01)),
  tau = seq(0.1, 0.9, 0.2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.refcurve_+3A_x">x</code></td>
<td>
<p>A refcurv object.</p>
</td></tr>
<tr><td><code id="plot.refcurve_+3A_newdata">newdata</code></td>
<td>
<p>A data frame defining a sequence of the predictor variables values.</p>
</td></tr>
<tr><td><code id="plot.refcurve_+3A_tau">tau</code></td>
<td>
<p>A number or vector defining desired quantile.</p>
</td></tr>
<tr><td><code id="plot.refcurve_+3A_...">...</code></td>
<td>
<p>Additional plot options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot of the refcurve model.
</p>

<hr>
<h2 id='plot.summary_boot'>Default summary_boot plotting</h2><span id='topic+plot.summary_boot'></span>

<h3>Description</h3>

<p>This function takes the bivRegr bootstrap replicates obtained with summary_boot
function, and plots the parametric, and smooth effects for each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_boot'
plot(x, eq = 1, select = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.summary_boot_+3A_x">x</code></td>
<td>
<p>A summary_boot object.</p>
</td></tr>
<tr><td><code id="plot.summary_boot_+3A_eq">eq</code></td>
<td>
<p>A number indicating the model effects to be depicted; 1 = first response mean,
2 =  second response mean, 3 = first response variance, 4 = second response variance, and
5 = correlation model.</p>
</td></tr>
<tr><td><code id="plot.summary_boot_+3A_select">select</code></td>
<td>
<p>An optional parameter to represent an specific effect for each equation.</p>
</td></tr>
<tr><td><code id="plot.summary_boot_+3A_...">...</code></td>
<td>
<p>Additional plot parameters, not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a ggplot2 plot for the estimated effects along with
bootstrap 95% confidence intervals.
</p>

<hr>
<h2 id='plot.trivRegion'>Default trivRegion plotting</h2><span id='topic+plot.trivRegion'></span>

<h3>Description</h3>

<p>This function allow to depict in an interactive rgl plot the estimated trivariate reference/probabilistic
region. If cond=FALSE it showes trivariate standarized residuals, while with
cond=TRUE it represents the region shape for any covariate(s) value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivRegion'
plot(
  x,
  cond = FALSE,
  planes = FALSE,
  newdata = NULL,
  add = FALSE,
  reg.col = NULL,
  incol = "grey",
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.trivRegion_+3A_x">x</code></td>
<td>
<p>A trivRegion object.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_cond">cond</code></td>
<td>
<p>A logical argument, if TRUE a conditional reference region is depicted.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_planes">planes</code></td>
<td>
<p>Logical; if TRUE, planes are added indicating (x=0,y=0,z=0).</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_newdata">newdata</code></td>
<td>
<p>If cond==TRUE, a data frame containing covariate
values for which the reference/probabilistic region will be depicted.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_add">add</code></td>
<td>
<p>A logical argument, if TRUE the conditional reference region is depicted over a pre existing plot.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_reg.col">reg.col</code></td>
<td>
<p>Region contour colour.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_incol">incol</code></td>
<td>
<p>Colours for the points included inside the reference region.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_legend">legend</code></td>
<td>
<p>A logical argument, if TRUE a legend is given along with the reference region.</p>
</td></tr>
<tr><td><code id="plot.trivRegion_+3A_...">...</code></td>
<td>
<p>Further rgl plot parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return an interactive rgl plot of a bivRegion object.
</p>

<hr>
<h2 id='pollution'>SO2 and Nox concentrations</h2><span id='topic+pollution'></span>

<h3>Description</h3>

<p>The pollution dataset contains the SO2 and Nox concentrations in the As Pontes
thermal power plant surrondings, during a year. The data was analyzed from a
bivariate perspective in Roca&ndash;Pardiñas et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pollution
</code></pre>


<h3>Format</h3>

<p>A data frame with 6179 observations and 13 variables:
</p>

<dl>
<dt>Date</dt><dd><p>The observation day, hour, and minute.</p>
</dd>
<dt>So2</dt><dd><p>So2 air concentration at the present time.</p>
</dd>
<dt>Nox</dt><dd><p>Nox air concentration at the present time.</p>
</dd>
<dt>So2_0</dt><dd><p>So2 air concentration registered 30 minutes before than the So2 one.</p>
</dd>
<dt>Nox_0</dt><dd><p>Nox air concentration registered 30 minutes before than the Nox one.</p>
</dd>
<dt>So2_1</dt><dd><p>So2 air concentration registered 45 minutes before than the So2 one.</p>
</dd>
<dt>Nox_1</dt><dd><p>Nox air concentration registered 45 minutes before than the Nox one.</p>
</dd>
<dt>So2_2</dt><dd><p>So2 air concentration registered 60 minutes before than the So2 one.</p>
</dd>
<dt>Nox_2</dt><dd><p>Nox air concentration registered 60 minutes before than the Nox one.</p>
</dd>
<dt>So2_3</dt><dd><p>So2 air concentration registered 75 minutes before than the So2 one.</p>
</dd>
<dt>Nox_3</dt><dd><p>Nox air concentration registered 75 minutes before than the Nox one.</p>
</dd>
<dt>So2_4</dt><dd><p>So2 air concentration registered 90 minutes before than the So2 one.</p>
</dd>
<dt>Nox_4</dt><dd><p>Nox air concentration registered 90 minutes before than the Nox one.</p>
</dd>
</dl>



<h3>References</h3>

<p>Roca&ndash;Pardinas, J., Ordonez, C., &amp; Lado Baleato, O. (2021). Nonparametric location scale model for the joint forecasting of SO2 and NOx pollution episodes. Stochastic Environmental Research and Risk Assessment, 35(2), 231&ndash;244.
</p>

<hr>
<h2 id='pollution_episode'>SO2 and Nox concentrations during a pollution episode</h2><span id='topic+pollution_episode'></span>

<h3>Description</h3>

<p>SO2 and Nox concentrations in the As Pontes thermal power plant surrondings,
during a pollution episode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pollution_episode
</code></pre>


<h3>Format</h3>

<p>A data frame with 288 observations and 13 variables:
</p>

<dl>
<dt>Date</dt><dd><p>The observation day, hour and minute.</p>
</dd>
<dt>So2</dt><dd><p>So2 air concentration at the present time.</p>
</dd>
<dt>Nox</dt><dd><p>Nox air concentration at the present time.</p>
</dd>
<dt>So2_0</dt><dd><p>So2 air concentration registered 30 minutes before than the So2 one.</p>
</dd>
<dt>Nox_0</dt><dd><p>Nox air concentration registered 30 minutes before than the Nox one.</p>
</dd>
<dt>So2_1</dt><dd><p>So2 air concentration registered 45 minutes before than the So2 one.</p>
</dd>
<dt>Nox_1</dt><dd><p>Nox air concentration registered 45 minutes before than the Nox one.</p>
</dd>
<dt>So2_2</dt><dd><p>So2 air concentration registered 60 minutes before than the So2 one.</p>
</dd>
<dt>Nox_2</dt><dd><p>Nox air concentration registered 60 minutes before than the Nox one.</p>
</dd>
<dt>So2_3</dt><dd><p>So2 air concentration registered 75 minutes before than the So2 one.</p>
</dd>
<dt>Nox_3</dt><dd><p>Nox air concentration registered 75 minutes before than the Nox one.</p>
</dd>
<dt>So2_4</dt><dd><p>So2 air concentration registered 90 minutes before than the So2 one.</p>
</dd>
<dt>Nox_4</dt><dd><p>Nox air concentration registered 90 minutes before than the Nox one.</p>
</dd>
</dl>


<hr>
<h2 id='predict.bivRegion'>Prediction for a bivRegion object</h2><span id='topic+predict.bivRegion'></span>

<h3>Description</h3>

<p>This function takes a bivRegion object and allow to obtain region limits
for a given covariate value if cond=TRUE. If not, it can be applied
to a new dataset to evaluate which points will be included inside the
standarized region (for instance, if we estimate a reference region with
healthy patients results, we can know where non healthy patients will be located).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivRegion'
predict(object, tau = 0.95, newdata = NULL, cond = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bivRegion_+3A_object">object</code></td>
<td>
<p>A bivRegion object.</p>
</td></tr>
<tr><td><code id="predict.bivRegion_+3A_tau">tau</code></td>
<td>
<p>A number or vector defining the desired coverage(s) of the
bivariate reference/probabilistic region.</p>
</td></tr>
<tr><td><code id="predict.bivRegion_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing new covariate values, or
new observations.</p>
</td></tr>
<tr><td><code id="predict.bivRegion_+3A_cond">cond</code></td>
<td>
<p>A logical argument, if TRUE, a matrix of values defining the
conditional reference region limits is given.</p>
</td></tr>
<tr><td><code id="predict.bivRegion_+3A_...">...</code></td>
<td>
<p>Additional prediction parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns reference region limits values for
a given covariate value (if cond=TRUE), or which observations falls
outside the estimated region (if cond=FALSE).
</p>

<hr>
<h2 id='predict.bivRegr'>Predict method for bivRegr</h2><span id='topic+predict.bivRegr'></span>

<h3>Description</h3>

<p>Obtains predictions for a bivRegr object, that is the bivRegr means,
variances, and correlation for given covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivRegr'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bivRegr_+3A_object">object</code></td>
<td>
<p>A bivRegr fit.</p>
</td></tr>
<tr><td><code id="predict.bivRegr_+3A_newdata">newdata</code></td>
<td>
<p>A data frame defining the covariate values for prediction. Default
is NULL and the prediction will be done in the original data.</p>
</td></tr>
<tr><td><code id="predict.bivRegr_+3A_...">...</code></td>
<td>
<p>Additional predict options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns prediction of bivRegr mean, variance and correlation models.
</p>

<hr>
<h2 id='refcurv'>Univariate reference curve model</h2><span id='topic+refcurv'></span>

<h3>Description</h3>

<p>This function obtain univariate conditional quantiles as described
in Martinez-Silva et. al (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refcurv(mu = "y~s(x)", sigma = "~s(x)", data = data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refcurv_+3A_mu">mu</code></td>
<td>
<p>A formula object for the response mean model following the mgcv package structure (see example below).</p>
</td></tr>
<tr><td><code id="refcurv_+3A_sigma">sigma</code></td>
<td>
<p>a formula object for fitting a model to the response variance (see example below).</p>
</td></tr>
<tr><td><code id="refcurv_+3A_data">data</code></td>
<td>
<p>A data frame containing both the response, and predictor variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the Martinez Silva et. al (2016) the non linear effects of the continuous
covariates are estimating through polynomial kernel smoother, in this package we implement the
same methodology but using penalized splines in order to reduce computational cost.
</p>


<h3>Value</h3>

<p>This function returns univariate conditional quantiles estimated using a non parametric location scale model.
</p>


<h3>References</h3>

<p>Martinez&ndash;Silva, I., Roca&ndash;Pardinas, J., &amp; Ordonez, C. (2016). Forecasting SO2 pollution incidents by means of quantile curves based on additive models. Environmetrics, 27(3), 147&ndash;157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Glycation hemoglobin reference curve depending on age
dm_no &lt;- subset(aegis, aegis$dm == "no")
fit1 &lt;- refcurv(mu = "hba1c~s(age)", sigma = "~s(age)", data = dm_no)
plot(fit1, newdata = data.frame(age = 18:90), tau = c(0.025, 0.05, 0.10, 0.90, 0.95, 0.975))

</code></pre>

<hr>
<h2 id='summary_boot'>bivRegr summary function</h2><span id='topic+summary_boot'></span>

<h3>Description</h3>

<p>This function perform a bootstrap procedure in order to obtain
confidence intervals for the bivRegr estimated effects. The function allow
to paralelize the bootstrap resampling scheme using doParalell, and
foreach libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_boot(object, B = 100, parallel = FALSE, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_boot_+3A_object">object</code></td>
<td>
<p>A bivRegr fit.</p>
</td></tr>
<tr><td><code id="summary_boot_+3A_b">B</code></td>
<td>
<p>A number indicating the bootstrap iterations.</p>
</td></tr>
<tr><td><code id="summary_boot_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating if bootstrap parallelization must be
applied.</p>
</td></tr>
<tr><td><code id="summary_boot_+3A_cores">cores</code></td>
<td>
<p>If parallel = TRUE, a number indicating computer cores
to be used during paralellization. If NULL the function use all cores available
but one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the bootstrap replicates of the bivRegr
sub models. Results might be checked applying plot.summary_boot().
</p>

<hr>
<h2 id='summary.bivRegion'>bivRegion summary method</h2><span id='topic+summary.bivRegion'></span>

<h3>Description</h3>

<p>This function takes an bivRegion object and indicates which observations are
located outside the estimated reference region and why.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivRegion'
summary(object, tau = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bivRegion_+3A_object">object</code></td>
<td>
<p>A bivRegion object.</p>
</td></tr>
<tr><td><code id="summary.bivRegion_+3A_tau">tau</code></td>
<td>
<p>The data coverage proportion previously obtained by the bivRegion function.</p>
</td></tr>
<tr><td><code id="summary.bivRegion_+3A_...">...</code></td>
<td>
<p>Additional summary options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function indicates the region apparent coverage, and which
patients are located outside the estimated reference region.
</p>

<hr>
<h2 id='trivRegion'>Trivariate reference region estimation</h2><span id='topic+trivRegion'></span>

<h3>Description</h3>

<p>This functions estimate a probabilistic/reference region for trivariate data.
It is based on a non parametric kernel density estimation. It can only be applied to
a trivRegr object, and for one single tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trivRegion(fit, tau = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trivRegion_+3A_fit">fit</code></td>
<td>
<p>A trivRegr object.</p>
</td></tr>
<tr><td><code id="trivRegion_+3A_tau">tau</code></td>
<td>
<p>A number defining the desired coverage of the trivariate
reference region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a region containing a given percentage of trivariate data points.
</p>


<h3>References</h3>

<p>Duong, T. (2019) ks: Kernel Smoothing. R package version 1.11.6. https://CRAN.R&ndash;project.org/package=ks.
</p>

<hr>
<h2 id='trivRegr'>Trivariate regression model</h2><span id='topic+trivRegr'></span>

<h3>Description</h3>

<p>This function estimates the covariates effects on the means vector,
and variance covariance matrix of a trivariate variable. Non linear effects
might be estimated for continuous covariates using penalized splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trivRegr(f = f, data = data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trivRegr_+3A_f">f</code></td>
<td>
<p>A list of 9 formulas defining the covariates effects
in three responses means, in their variances, and in their correlations. The formulas
follow the mgcv::gam() structure.</p>
</td></tr>
<tr><td><code id="trivRegr_+3A_data">data</code></td>
<td>
<p>A data frame containing the reponses, and predictor variables values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the covariates effect on the means,
variances, and correlation for a trivariate response variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm_no &lt;- subset(aegis, aegis$dm == "no")

# Model formulas
mu1 &lt;- fpg ~ s(age)
mu2 &lt;- hba1c ~ s(age)
mu3 &lt;- fru~s(age)
var1 &lt;- ~ s(age)
var2 &lt;- ~ s(age)
var3 &lt;- ~ s(age)
theta12 &lt;- ~ s(age)
theta13 &lt;- ~ s(age)
theta23 &lt;- ~ s(age)
f &lt;- list(mu1, mu2, mu3, var1, var2, var3, theta12, theta13, theta23)

# Model fit
fit &lt;- trivRegr(f, data = dm_no)
# Trivariate region estimation
region &lt;- trivRegion(fit, tau = 0.95)
plot(region, col = 2, planes = TRUE)
plot(region,
  cond = TRUE, newdata = data.frame(age = c(20, 80)),
  xlab = "FPG, mg/dl", ylab = "HbA1c, %", zlab = "Fru, mg/dL"
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
